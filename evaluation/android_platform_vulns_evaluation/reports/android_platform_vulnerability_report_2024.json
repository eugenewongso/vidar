{
    "summary": {
        "total_vulnerabilities_tested": 41,
        "total_downstream_versions_tested": 132,
        "total_failed_patches": 24,
        "total_unique_downstream_versions_tested": 0,
        "total_unique_downstream_failed_patches": 0,
        "vulnerabilities_with_all_failures": 7,
        "vulnerabilities_with_partial_failures": 5,
        "vulnerabilities_with_all_successful_patches": 29,
        "vulnerabilities_skipped": 64,
        "vulnerabilities_with_commit_mismatch": 22,
        "per_version_stats": {
            "11": {
                "total_downstreams_tested": 3,
                "total_failed_patches": 1
            },
            "12": {
                "total_downstreams_tested": 27,
                "total_failed_patches": 5
            },
            "12L": {
                "total_downstreams_tested": 27,
                "total_failed_patches": 5
            },
            "13": {
                "total_downstreams_tested": 37,
                "total_failed_patches": 7
            },
            "14": {
                "total_downstreams_tested": 38,
                "total_failed_patches": 6
            }
        },
        "total_tokens": {
            "upstream_patch": {
                "gemini": 61052,
                "openai": 48795,
                "general_word": 19151,
                "general_char": 52141
            },
            "downstream_patch": {
                "gemini": 145375,
                "openai": 115133,
                "general_word": 43326,
                "general_char": 119124
            },
            "upstream_source": {
                "gemini": 594340,
                "openai": 508612,
                "general_word": 198295,
                "general_char": 677479
            },
            "downstream_source": {
                "gemini": 553720,
                "openai": 472366,
                "general_word": 184445,
                "general_char": 630229
            },
            "rej_file": {
                "gemini": 8333,
                "openai": 6976,
                "general_word": 2607,
                "general_char": 8931
            },
            "inline_merge_conflict": {
                "gemini": 2000,
                "openai": 1594,
                "general_word": 499,
                "general_char": 2119
            }
        },
        "average_tokens_per_downstream_version": {
            "upstream_patch": {
                "gemini": 462.52,
                "openai": 369.66,
                "general_word": 145.08,
                "general_char": 395.01
            },
            "downstream_patch": {
                "gemini": 1101.33,
                "openai": 872.22,
                "general_word": 328.23,
                "general_char": 902.45
            },
            "upstream_source": {
                "gemini": 4502.58,
                "openai": 3853.12,
                "general_word": 1502.23,
                "general_char": 5132.42
            },
            "downstream_source": {
                "gemini": 4194.85,
                "openai": 3578.53,
                "general_word": 1397.31,
                "general_char": 4774.46
            },
            "rej_file": {
                "gemini": 63.13,
                "openai": 52.85,
                "general_word": 19.75,
                "general_char": 67.66
            },
            "inline_merge_conflict": {
                "gemini": 15.15,
                "openai": 12.08,
                "general_word": 3.78,
                "general_char": 16.05
            }
        }
    },
    "vulnerabilities_with_all_failures": [
        {
            "id": "ASB-A-336323279",
            "aliases": [
                "A-336323279",
                "CVE-2024-34738"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-336323279",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "955e78071ec49139583056e21f612edba6439436"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 955e78071ec49139583056e21f612edba6439436 Mon Sep 17 00:00:00 2001\nFrom: Hao Ke <haok@google.com>\nDate: Mon, 22 Apr 2024 15:13:58 +0000\nSubject: [PATCH] Fix READ/WRITE operation access issues on Restricted appOps.\n\nProblems were identified around read and write access to the restricted appOps, this change includes:\n\n- Filter out restricted appOps status for unprivileged readers.\n- Allow additional privileged appOps permission holder reading restricted appOps status.\n\nBug: 336273802\nBug: 336323279\nTest: Local test see b/336273802#comment3\nTest: atest AppOpsTest#testRestrictedSettingsOpsRead\nChange-Id: I09008b365e36b2c20c9a1fe5a1d52699ddb17d35\n---\n core/java/android/app/AppOpInfo.java          |  2 +-\n core/java/android/app/AppOpsManager.java      |  2 +-\n .../android/server/appop/AppOpsService.java   | 31 ++++++++++++++++---\n 3 files changed, 28 insertions(+), 7 deletions(-)\n\ndiff --git a/core/java/android/app/AppOpInfo.java b/core/java/android/app/AppOpInfo.java\nindex 5268ec42e21c..a0f0ccaec58c 100644\n--- a/core/java/android/app/AppOpInfo.java\n+++ b/core/java/android/app/AppOpInfo.java\n@@ -88,7 +88,7 @@ class AppOpInfo {\n \n     /**\n      * This specifies whether each option is only allowed to be read\n-     * by apps with manage appops permission.\n+     * by apps with privileged appops permission.\n      */\n     public final boolean restrictRead;\n \ndiff --git a/core/java/android/app/AppOpsManager.java b/core/java/android/app/AppOpsManager.java\nindex 7ae514ac2491..10e4886b2548 100644\n--- a/core/java/android/app/AppOpsManager.java\n+++ b/core/java/android/app/AppOpsManager.java\n@@ -3269,7 +3269,7 @@ public class AppOpsManager {\n     }\n \n     /**\n-     * Retrieve whether the op can be read by apps with manage appops permission.\n+     * Retrieve whether the op can be read by apps with privileged appops permission.\n      * @hide\n      */\n     public static boolean opRestrictsRead(int op) {\ndiff --git a/services/core/java/com/android/server/appop/AppOpsService.java b/services/core/java/com/android/server/appop/AppOpsService.java\nindex a1f80d05fe1f..1e2a79c9f0f2 100644\n--- a/services/core/java/com/android/server/appop/AppOpsService.java\n+++ b/services/core/java/com/android/server/appop/AppOpsService.java\n@@ -1563,19 +1563,29 @@ public class AppOpsService extends IAppOpsService.Stub {\n     private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops,\n             String persistentDeviceId) {\n         ArrayList<AppOpsManager.OpEntry> resOps = null;\n+        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n+                Manifest.permission.GET_APP_OPS_STATS,\n+                Binder.getCallingPid(), Binder.getCallingUid())\n+                == PackageManager.PERMISSION_GRANTED;\n         if (ops == null) {\n             resOps = new ArrayList<>();\n-            for (int j=0; j<pkgOps.size(); j++) {\n+            for (int j = 0; j < pkgOps.size(); j++) {\n                 Op curOp = pkgOps.valueAt(j);\n+                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                    continue;\n+                }\n                 resOps.add(getOpEntryForResult(curOp, persistentDeviceId));\n             }\n         } else {\n-            for (int j=0; j<ops.length; j++) {\n+            for (int j = 0; j < ops.length; j++) {\n                 Op curOp = pkgOps.get(ops[j]);\n                 if (curOp != null) {\n                     if (resOps == null) {\n                         resOps = new ArrayList<>();\n                     }\n+                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                        continue;\n+                    }\n                     resOps.add(getOpEntryForResult(curOp, persistentDeviceId));\n                 }\n             }\n@@ -4242,10 +4252,21 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n     private void verifyIncomingOp(int op) {\n         if (op >= 0 && op < AppOpsManager._NUM_OP) {\n-            // Enforce manage appops permission if it's a restricted read op.\n+            // Enforce privileged appops permission if it's a restricted read op.\n             if (opRestrictsRead(op)) {\n-                mContext.enforcePermission(Manifest.permission.MANAGE_APPOPS,\n-                        Binder.getCallingPid(), Binder.getCallingUid(), \"verifyIncomingOp\");\n+                if (!(mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n+                        Manifest.permission.GET_APP_OPS_STATS,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n+                        Manifest.permission.MANAGE_APP_OPS_MODES,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED)) {\n+                    throw new SecurityException(\"verifyIncomingOp: uid \" + Binder.getCallingUid()\n+                            + \" does not have any of {MANAGE_APPOPS, GET_APP_OPS_STATS, \"\n+                            + \"MANAGE_APP_OPS_MODES}\");\n+                }\n             }\n             return;\n         }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 1280,
                        "general": {
                            "word_based": 532,
                            "char_based": 1339
                        },
                        "gemini": 1635
                    },
                    "total_downstream_versions_tested": 2,
                    "successful_patches": 0,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "e2471e03e471ed701dd1ac0c6c483f82b0dd22d0",
                            "repo_path": "android_repos/base",
                            "result": "failure",
                            "downstream_patch_content": "commit e2471e03e471ed701dd1ac0c6c483f82b0dd22d0\nAuthor: Hao Ke <haok@google.com>\nDate:   Mon Apr 22 15:13:58 2024 +0000\n\n    RESTRICT AUTOMERGE Fix READ/WRITE operation access issues on Restricted appOps.\n    \n    Problems were identified around read and write access to the restricted appOps, this change includes:\n    \n    - Filter out restricted appOps status for unprivileged readers.\n    - Allow additional privileged appOps permission holder reading restricted appOps status.\n    \n    Bug: 336273802\n    Bug: 336323279\n    Test: Local test see b/336273802#comment3\n    Test: atest AppOpsTest#testRestrictedSettingsOpsRead\n    Change-Id: I09008b365e36b2c20c9a1fe5a1d52699ddb17d35\n\ndiff --git a/core/java/android/app/AppOpsManager.java b/core/java/android/app/AppOpsManager.java\nindex 9344d96d2893..353bb15d0d2e 100644\n--- a/core/java/android/app/AppOpsManager.java\n+++ b/core/java/android/app/AppOpsManager.java\n@@ -3290,7 +3290,7 @@ public class AppOpsManager {\n     }\n \n     /**\n-     * Retrieve whether the op can be read by apps with manage appops permission.\n+     * Retrieve whether the op can be read by apps with privileged appops permission.\n      * @hide\n      */\n     public static boolean opRestrictsRead(int op) {\ndiff --git a/services/core/java/com/android/server/appop/AppOpsService.java b/services/core/java/com/android/server/appop/AppOpsService.java\nindex 1bde4e22428f..b891aeeb527d 100644\n--- a/services/core/java/com/android/server/appop/AppOpsService.java\n+++ b/services/core/java/com/android/server/appop/AppOpsService.java\n@@ -2186,16 +2186,26 @@ public class AppOpsService extends IAppOpsService.Stub {\n     private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops) {\n         ArrayList<AppOpsManager.OpEntry> resOps = null;\n         final long elapsedNow = SystemClock.elapsedRealtime();\n+        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n+                Manifest.permission.GET_APP_OPS_STATS,\n+                Binder.getCallingPid(), Binder.getCallingUid())\n+                == PackageManager.PERMISSION_GRANTED;\n         if (ops == null) {\n             resOps = new ArrayList<>();\n-            for (int j=0; j<pkgOps.size(); j++) {\n+            for (int j = 0; j < pkgOps.size(); j++) {\n                 Op curOp = pkgOps.valueAt(j);\n+                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                    continue;\n+                }\n                 resOps.add(getOpEntryForResult(curOp, elapsedNow));\n             }\n         } else {\n-            for (int j=0; j<ops.length; j++) {\n+            for (int j = 0; j < ops.length; j++) {\n                 Op curOp = pkgOps.get(ops[j]);\n                 if (curOp != null) {\n+                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                        continue;\n+                    }\n                     if (resOps == null) {\n                         resOps = new ArrayList<>();\n                     }\n@@ -4400,10 +4410,21 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n     private void verifyIncomingOp(int op) {\n         if (op >= 0 && op < AppOpsManager._NUM_OP) {\n-            // Enforce manage appops permission if it's a restricted read op.\n+            // Enforce privileged appops permission if it's a restricted read op.\n             if (opRestrictsRead(op)) {\n-                mContext.enforcePermission(Manifest.permission.MANAGE_APPOPS,\n-                        Binder.getCallingPid(), Binder.getCallingUid(), \"verifyIncomingOp\");\n+                if (!(mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n+                        Manifest.permission.GET_APP_OPS_STATS,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n+                        Manifest.permission.MANAGE_APP_OPS_MODES,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED)) {\n+                    throw new SecurityException(\"verifyIncomingOp: uid \" + Binder.getCallingUid()\n+                            + \" does not have any of {MANAGE_APPOPS, GET_APP_OPS_STATS, \"\n+                            + \"MANAGE_APP_OPS_MODES}\");\n+                }\n             }\n             return;\n         }\n",
                            "downstream_patch_tokens": {
                                "openai": 1058,
                                "general": {
                                    "word_based": 423,
                                    "char_based": 1135
                                },
                                "gemini": 1337
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
                                    "total_hunks": 2,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n                if (!(mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n                        Manifest.permission.GET_APP_OPS_STATS,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n                        Manifest.permission.MANAGE_APP_OPS_MODES,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED)) {\n                    throw new SecurityException(\"verifyIncomingOp: uid \" + Binder.getCallingUid()\n                            + \" does not have any of {MANAGE_APPOPS, GET_APP_OPS_STATS, \"\n                            + \"MANAGE_APP_OPS_MODES}\");\n                }\n            }\n            return;\n        }\n>>>>>>> UPSTREAM PATCH (commit 955e78071ec49139583056e21f612edba6439436)",
                                            "merge_conflict_tokens": {
                                                "openai": 193,
                                                "general": {
                                                    "word_based": 57,
                                                    "char_based": 272
                                                },
                                                "gemini": 258
                                            }
                                        }
                                    ],
                                    "inline_merge_token_summary": {
                                        "gemini": 32508,
                                        "openai": 24511,
                                        "general_word": 7239,
                                        "general_char": 34544
                                    },
                                    "rej_file_content": "```diff\n--- services/core/java/com/android/server/appop/AppOpsService.java\n+++ services/core/java/com/android/server/appop/AppOpsService.java\n@@ -1563,19 +1563,29 @@ public class AppOpsService extends IAppOpsService.Stub {\n     private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops,\n             String persistentDeviceId) {\n         ArrayList<AppOpsManager.OpEntry> resOps = null;\n+        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n+                Manifest.permission.GET_APP_OPS_STATS,\n+                Binder.getCallingPid(), Binder.getCallingUid())\n+                == PackageManager.PERMISSION_GRANTED;\n         if (ops == null) {\n             resOps = new ArrayList<>();\n-            for (int j=0; j<pkgOps.size(); j++) {\n+            for (int j = 0; j < pkgOps.size(); j++) {\n                 Op curOp = pkgOps.valueAt(j);\n+                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                    continue;\n+                }\n                 resOps.add(getOpEntryForResult(curOp, persistentDeviceId));\n             }\n         } else {\n-            for (int j=0; j<ops.length; j++) {\n+            for (int j = 0; j < ops.length; j++) {\n                 Op curOp = pkgOps.get(ops[j]);\n                 if (curOp != null) {\n                     if (resOps == null) {\n                         resOps = new ArrayList<>();\n                     }\n+                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                        continue;\n+                    }\n                     resOps.add(getOpEntryForResult(curOp, persistentDeviceId));\n                 }\n             }\n```",
                                    "rej_file_tokens": {
                                        "openai": 368,
                                        "general": {
                                            "word_based": 138,
                                            "char_based": 418
                                        },
                                        "gemini": 450
                                    },
                                    "patch_apply_output": "patching file services/core/java/com/android/server/appop/AppOpsService.java\nHunk #1 FAILED at 1563.\nHunk #2 succeeded at 4400 (offset 158 lines).\n1 out of 2 hunks FAILED -- saving rejects to file services/core/java/com/android/server/appop/AppOpsService.java.rej",
                                    "inline_merge_output": "patching file services/core/java/com/android/server/appop/AppOpsService.java\nHunk #1 already applied at 1566-1569,1572,1574-1576,1580, merged at 1589-1591.\nHunk #2 already applied at 4258, NOT MERGED at 4260-4278.",
                                    "upstream_file_tokens": {
                                        "openai": 63381,
                                        "general": {
                                            "word_based": 23827,
                                            "char_based": 83324
                                        },
                                        "gemini": 74277
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.appop;\n\nimport static android.app.ActivityManager.PROCESS_CAPABILITY_FOREGROUND_CAMERA;\nimport static android.app.ActivityManager.PROCESS_CAPABILITY_FOREGROUND_LOCATION;\nimport static android.app.ActivityManager.PROCESS_CAPABILITY_FOREGROUND_MICROPHONE;\nimport static android.app.AppOpsManager.ATTRIBUTION_CHAIN_ID_NONE;\nimport static android.app.AppOpsManager.ATTRIBUTION_FLAG_TRUSTED;\nimport static android.app.AppOpsManager.CALL_BACK_ON_SWITCHED_OP;\nimport static android.app.AppOpsManager.FILTER_BY_ATTRIBUTION_TAG;\nimport static android.app.AppOpsManager.FILTER_BY_OP_NAMES;\nimport static android.app.AppOpsManager.FILTER_BY_PACKAGE_NAME;\nimport static android.app.AppOpsManager.FILTER_BY_UID;\nimport static android.app.AppOpsManager.HISTORY_FLAG_GET_ATTRIBUTION_CHAINS;\nimport static android.app.AppOpsManager.HistoricalOpsRequestFilter;\nimport static android.app.AppOpsManager.KEY_BG_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.KEY_FG_SERVICE_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.KEY_TOP_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.MODE_ALLOWED;\nimport static android.app.AppOpsManager.MODE_DEFAULT;\nimport static android.app.AppOpsManager.MODE_ERRORED;\nimport static android.app.AppOpsManager.MODE_FOREGROUND;\nimport static android.app.AppOpsManager.MODE_IGNORED;\nimport static android.app.AppOpsManager.NoteOpEvent;\nimport static android.app.AppOpsManager.OP_CAMERA;\nimport static android.app.AppOpsManager.OP_FLAGS_ALL;\nimport static android.app.AppOpsManager.OP_FLAG_SELF;\nimport static android.app.AppOpsManager.OP_FLAG_TRUSTED_PROXIED;\nimport static android.app.AppOpsManager.OP_NONE;\nimport static android.app.AppOpsManager.OP_PLAY_AUDIO;\nimport static android.app.AppOpsManager.OP_RECEIVE_AMBIENT_TRIGGER_AUDIO;\nimport static android.app.AppOpsManager.OP_RECORD_AUDIO;\nimport static android.app.AppOpsManager.OP_RECORD_AUDIO_HOTWORD;\nimport static android.app.AppOpsManager.OnOpStartedListener.START_TYPE_FAILED;\nimport static android.app.AppOpsManager.OnOpStartedListener.START_TYPE_RESUMED;\nimport static android.app.AppOpsManager.OnOpStartedListener.START_TYPE_STARTED;\nimport static android.app.AppOpsManager.OpEventProxyInfo;\nimport static android.app.AppOpsManager.RestrictionBypass;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_BOOT_TIME_SAMPLING;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_RARELY_USED;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_UNIFORM;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_UNIFORM_OPS;\nimport static android.app.AppOpsManager.SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE;\nimport static android.app.AppOpsManager.UID_STATE_BACKGROUND;\nimport static android.app.AppOpsManager.UID_STATE_CACHED;\nimport static android.app.AppOpsManager.UID_STATE_FOREGROUND;\nimport static android.app.AppOpsManager.UID_STATE_FOREGROUND_SERVICE;\nimport static android.app.AppOpsManager.UID_STATE_MAX_LAST_NON_RESTRICTED;\nimport static android.app.AppOpsManager.UID_STATE_PERSISTENT;\nimport static android.app.AppOpsManager.UID_STATE_TOP;\nimport static android.app.AppOpsManager.WATCH_FOREGROUND_CHANGES;\nimport static android.app.AppOpsManager._NUM_OP;\nimport static android.app.AppOpsManager.extractFlagsFromKey;\nimport static android.app.AppOpsManager.extractUidStateFromKey;\nimport static android.app.AppOpsManager.makeKey;\nimport static android.app.AppOpsManager.modeToName;\nimport static android.app.AppOpsManager.opAllowSystemBypassRestriction;\nimport static android.app.AppOpsManager.opRestrictsRead;\nimport static android.app.AppOpsManager.opToName;\nimport static android.app.AppOpsManager.opToPublicName;\nimport static android.app.AppOpsManager.resolveFirstUnrestrictedUidState;\nimport static android.content.Intent.ACTION_PACKAGE_REMOVED;\nimport static android.content.Intent.EXTRA_REPLACING;\nimport static android.content.pm.PermissionInfo.PROTECTION_DANGEROUS;\nimport static android.content.pm.PermissionInfo.PROTECTION_FLAG_APPOP;\n\nimport static com.android.server.appop.AppOpsService.ModeCallback.ALL_OPS;\n\nimport static java.lang.Long.max;\n\nimport android.Manifest;\nimport android.annotation.IntRange;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.UserIdInt;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.AppOpsManager.AttributedOpEntry;\nimport android.app.AppOpsManager.AttributionFlags;\nimport android.app.AppOpsManager.HistoricalOps;\nimport android.app.AppOpsManager.Mode;\nimport android.app.AppOpsManager.OpEntry;\nimport android.app.AppOpsManager.OpFlags;\nimport android.app.AppOpsManagerInternal;\nimport android.app.AppOpsManagerInternal.CheckOpsDelegate;\nimport android.app.AsyncNotedAppOp;\nimport android.app.RuntimeAppOpAccessMessage;\nimport android.app.SyncNotedAppOp;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.content.AttributionSource;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.PermissionInfo;\nimport android.content.pm.UserInfo;\nimport android.database.ContentObserver;\nimport android.hardware.camera2.CameraDevice.CAMERA_AUDIO_RESTRICTION;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.PackageTagsList;\nimport android.os.Process;\nimport android.os.RemoteCallback;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.ServiceManager;\nimport android.os.ShellCallback;\nimport android.os.ShellCommand;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.storage.StorageManagerInternal;\nimport android.permission.PermissionManager;\nimport android.provider.Settings;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.IndentingPrintWriter;\nimport android.util.KeyValueListParser;\nimport android.util.LongSparseArray;\nimport android.util.Pair;\nimport android.util.Pools;\nimport android.util.Pools.SimplePool;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\nimport android.util.SparseIntArray;\nimport android.util.TimeUtils;\nimport android.util.TypedXmlPullParser;\nimport android.util.TypedXmlSerializer;\nimport android.util.Xml;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.Immutable;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.app.IAppOpsActiveCallback;\nimport com.android.internal.app.IAppOpsAsyncNotedCallback;\nimport com.android.internal.app.IAppOpsCallback;\nimport com.android.internal.app.IAppOpsNotedCallback;\nimport com.android.internal.app.IAppOpsService;\nimport com.android.internal.app.IAppOpsStartedCallback;\nimport com.android.internal.app.MessageSamplingConfig;\nimport com.android.internal.compat.IPlatformCompat;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.Preconditions;\nimport com.android.internal.util.XmlUtils;\nimport com.android.internal.util.function.pooled.PooledLambda;\nimport com.android.server.LocalServices;\nimport com.android.server.LockGuard;\nimport com.android.server.SystemServerInitThreadPool;\nimport com.android.server.SystemServiceManager;\nimport com.android.server.pm.PackageList;\nimport com.android.server.pm.parsing.pkg.AndroidPackage;\nimport com.android.server.pm.pkg.component.ParsedAttribution;\nimport com.android.server.policy.AppOpsPolicy;\n\nimport dalvik.annotation.optimization.NeverCompile;\n\nimport libcore.util.EmptyArray;\n\nimport org.json.JSONException;\nimport org.json.JSONObject;\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.text.SimpleDateFormat;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Consumer;\n\npublic class AppOpsService extends IAppOpsService.Stub {\n    static final String TAG = \"AppOps\";\n    static final boolean DEBUG = false;\n\n    /**\n     * Used for data access validation collection, we wish to only log a specific access once\n     */\n    private final ArraySet<NoteOpTrace> mNoteOpCallerStacktraces = new ArraySet<>();\n\n    private static final int NO_VERSION = -1;\n    /** Increment by one every time and add the corresponding upgrade logic in\n     *  {@link #upgradeLocked(int)} below. The first version was 1 */\n    private static final int CURRENT_VERSION = 1;\n\n    // Write at most every 30 minutes.\n    static final long WRITE_DELAY = DEBUG ? 1000 : 30*60*1000;\n\n    // Constant meaning that any UID should be matched when dispatching callbacks\n    private static final int UID_ANY = -2;\n\n    // Map from process states to the uid states we track.\n    private static final int[] PROCESS_STATE_TO_UID_STATE = new int[] {\n        UID_STATE_PERSISTENT,           // ActivityManager.PROCESS_STATE_PERSISTENT\n        UID_STATE_PERSISTENT,           // ActivityManager.PROCESS_STATE_PERSISTENT_UI\n        UID_STATE_TOP,                  // ActivityManager.PROCESS_STATE_TOP\n        UID_STATE_FOREGROUND,           // ActivityManager.PROCESS_STATE_BOUND_TOP\n        UID_STATE_FOREGROUND_SERVICE,   // ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE\n        UID_STATE_FOREGROUND,           // ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE\n        UID_STATE_BACKGROUND,           // ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND\n        UID_STATE_BACKGROUND,           // ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND\n        UID_STATE_BACKGROUND,           // ActivityManager.PROCESS_STATE_TRANSIENT_BACKGROUND\n        UID_STATE_BACKGROUND,           // ActivityManager.PROCESS_STATE_BACKUP\n        UID_STATE_BACKGROUND,           // ActivityManager.PROCESS_STATE_SERVICE\n        UID_STATE_BACKGROUND,           // ActivityManager.PROCESS_STATE_RECEIVER\n        UID_STATE_CACHED,               // ActivityManager.PROCESS_STATE_TOP_SLEEPING\n        UID_STATE_CACHED,               // ActivityManager.PROCESS_STATE_HEAVY_WEIGHT\n        UID_STATE_CACHED,               // ActivityManager.PROCESS_STATE_HOME\n        UID_STATE_CACHED,               // ActivityManager.PROCESS_STATE_LAST_ACTIVITY\n        UID_STATE_CACHED,               // ActivityManager.PROCESS_STATE_CACHED_ACTIVITY\n        UID_STATE_CACHED,               // ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT\n        UID_STATE_CACHED,               // ActivityManager.PROCESS_STATE_CACHED_RECENT\n        UID_STATE_CACHED,               // ActivityManager.PROCESS_STATE_CACHED_EMPTY\n        UID_STATE_CACHED,               // ActivityManager.PROCESS_STATE_NONEXISTENT\n    };\n\n    private static final int[] OPS_RESTRICTED_ON_SUSPEND = {\n            OP_PLAY_AUDIO,\n            OP_RECORD_AUDIO,\n            OP_CAMERA,\n    };\n\n    private static final int MAX_UNFORWARDED_OPS = 10;\n    private static final int MAX_UNUSED_POOLED_OBJECTS = 3;\n    private static final int RARELY_USED_PACKAGES_INITIALIZATION_DELAY_MILLIS = 300000;\n\n    final Context mContext;\n    final AtomicFile mFile;\n    private final @Nullable File mNoteOpCallerStacktracesFile;\n    final Handler mHandler;\n\n    /** Pool for {@link OpEventProxyInfoPool} to avoid to constantly reallocate new objects */\n    @GuardedBy(\"this\")\n    private final OpEventProxyInfoPool mOpEventProxyInfoPool = new OpEventProxyInfoPool();\n\n    /** Pool for {@link InProgressStartOpEventPool} to avoid to constantly reallocate new objects */\n    @GuardedBy(\"this\")\n    private final InProgressStartOpEventPool mInProgressStartOpEventPool =\n            new InProgressStartOpEventPool();\n\n    private final AppOpsManagerInternalImpl mAppOpsManagerInternal\n            = new AppOpsManagerInternalImpl();\n    @Nullable private final DevicePolicyManagerInternal dpmi =\n            LocalServices.getService(DevicePolicyManagerInternal.class);\n\n    private final IPlatformCompat mPlatformCompat = IPlatformCompat.Stub.asInterface(\n            ServiceManager.getService(Context.PLATFORM_COMPAT_SERVICE));\n\n    /**\n     * Registered callbacks, called from {@link #collectAsyncNotedOp}.\n     *\n     * <p>(package name, uid) -> callbacks\n     *\n     * @see #getAsyncNotedOpsKey(String, int)\n     */\n    @GuardedBy(\"this\")\n    private final ArrayMap<Pair<String, Integer>, RemoteCallbackList<IAppOpsAsyncNotedCallback>>\n            mAsyncOpWatchers = new ArrayMap<>();\n\n    /**\n     * Async note-ops collected from {@link #collectAsyncNotedOp} that have not been delivered to a\n     * callback yet.\n     *\n     * <p>(package name, uid) -> list&lt;ops&gt;\n     *\n     * @see #getAsyncNotedOpsKey(String, int)\n     */\n    @GuardedBy(\"this\")\n    private final ArrayMap<Pair<String, Integer>, ArrayList<AsyncNotedAppOp>>\n            mUnforwardedAsyncNotedOps = new ArrayMap<>();\n\n    boolean mWriteNoteOpsScheduled;\n\n    boolean mWriteScheduled;\n    boolean mFastWriteScheduled;\n    final Runnable mWriteRunner = new Runnable() {\n        public void run() {\n            synchronized (AppOpsService.this) {\n                mWriteScheduled = false;\n                mFastWriteScheduled = false;\n                AsyncTask<Void, Void, Void> task = new AsyncTask<Void, Void, Void>() {\n                    @Override protected Void doInBackground(Void... params) {\n                        writeState();\n                        return null;\n                    }\n                };\n                task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void[])null);\n            }\n        }\n    };\n\n    @GuardedBy(\"this\")\n    @VisibleForTesting\n    final SparseArray<UidState> mUidStates = new SparseArray<>();\n\n    volatile @NonNull HistoricalRegistry mHistoricalRegistry = new HistoricalRegistry(this);\n\n    long mLastRealtime;\n\n    /*\n     * These are app op restrictions imposed per user from various parties.\n     */\n    private final ArrayMap<IBinder, ClientUserRestrictionState> mOpUserRestrictions =\n            new ArrayMap<>();\n\n    /*\n     * These are app op restrictions imposed globally from various parties within the system.\n     */\n    private final ArrayMap<IBinder, ClientGlobalRestrictionState> mOpGlobalRestrictions =\n            new ArrayMap<>();\n\n    SparseIntArray mProfileOwners;\n\n    private volatile CheckOpsDelegateDispatcher mCheckOpsDelegateDispatcher =\n            new CheckOpsDelegateDispatcher(/*policy*/ null, /*delegate*/ null);\n\n    /**\n      * Reverse lookup for {@link AppOpsManager#opToSwitch(int)}. Initialized once and never\n      * changed\n      */\n    private final SparseArray<int[]> mSwitchedOps = new SparseArray<>();\n\n    private ActivityManagerInternal mActivityManagerInternal;\n\n    /** Package sampled for message collection in the current session */\n    @GuardedBy(\"this\")\n    private String mSampledPackage = null;\n\n    /** Appop sampled for message collection in the current session */\n    @GuardedBy(\"this\")\n    private int mSampledAppOpCode = OP_NONE;\n\n    /** Maximum distance for appop to be considered for message collection in the current session */\n    @GuardedBy(\"this\")\n    private int mAcceptableLeftDistance = 0;\n\n    /** Number of messages collected for sampled package and appop in the current session */\n    @GuardedBy(\"this\")\n    private float mMessagesCollectedCount;\n\n    /** List of rarely used packages priorities for message collection */\n    @GuardedBy(\"this\")\n    private ArraySet<String> mRarelyUsedPackages = new ArraySet<>();\n\n    /** Sampling strategy used for current session */\n    @GuardedBy(\"this\")\n    @AppOpsManager.SamplingStrategy\n    private int mSamplingStrategy;\n\n    /** Last runtime permission access message collected and ready for reporting */\n    @GuardedBy(\"this\")\n    private RuntimeAppOpAccessMessage mCollectedRuntimePermissionMessage;\n\n    /** Package Manager internal. Access via {@link #getPackageManagerInternal()} */\n    private @Nullable PackageManagerInternal mPackageManagerInternal;\n\n    /**\n     * An unsynchronized pool of {@link OpEventProxyInfo} objects.\n     */\n    private class OpEventProxyInfoPool extends SimplePool<OpEventProxyInfo> {\n        OpEventProxyInfoPool() {\n            super(MAX_UNUSED_POOLED_OBJECTS);\n        }\n\n        OpEventProxyInfo acquire(@IntRange(from = 0) int uid, @Nullable String packageName,\n                @Nullable String attributionTag) {\n            OpEventProxyInfo recycled = acquire();\n            if (recycled != null) {\n                recycled.reinit(uid, packageName, attributionTag);\n                return recycled;\n            }\n\n            return new OpEventProxyInfo(uid, packageName, attributionTag);\n        }\n    }\n\n    /**\n     * An unsynchronized pool of {@link InProgressStartOpEvent} objects.\n     */\n    private class InProgressStartOpEventPool extends SimplePool<InProgressStartOpEvent> {\n        InProgressStartOpEventPool() {\n            super(MAX_UNUSED_POOLED_OBJECTS);\n        }\n\n        InProgressStartOpEvent acquire(long startTime, long elapsedTime, @NonNull IBinder clientId,\n                @Nullable String attributionTag, @NonNull Runnable onDeath, int proxyUid,\n                @Nullable String proxyPackageName, @Nullable String proxyAttributionTag,\n                @AppOpsManager.UidState int uidState, @OpFlags int flags, @AttributionFlags\n                int attributionFlags, int attributionChainId) throws RemoteException {\n\n            InProgressStartOpEvent recycled = acquire();\n\n            OpEventProxyInfo proxyInfo = null;\n            if (proxyUid != Process.INVALID_UID) {\n                proxyInfo = mOpEventProxyInfoPool.acquire(proxyUid, proxyPackageName,\n                        proxyAttributionTag);\n            }\n\n            if (recycled != null) {\n                recycled.reinit(startTime, elapsedTime, clientId, attributionTag, onDeath,\n                        uidState, flags, proxyInfo,  attributionFlags, attributionChainId,\n                        mOpEventProxyInfoPool);\n                return recycled;\n            }\n\n            return new InProgressStartOpEvent(startTime, elapsedTime, clientId, attributionTag,\n                    onDeath, uidState, proxyInfo, flags, attributionFlags, attributionChainId);\n        }\n    }\n\n    /**\n     * All times are in milliseconds. These constants are kept synchronized with the system\n     * global Settings. Any access to this class or its fields should be done while\n     * holding the AppOpsService lock.\n     */\n    @VisibleForTesting\n    final class Constants extends ContentObserver {\n\n        /**\n         * How long we want for a drop in uid state from top to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_TOP_STATE_SETTLE_TIME\n         */\n        public long TOP_STATE_SETTLE_TIME;\n\n        /**\n         * How long we want for a drop in uid state from foreground to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_FG_SERVICE_STATE_SETTLE_TIME\n         */\n        public long FG_SERVICE_STATE_SETTLE_TIME;\n\n        /**\n         * How long we want for a drop in uid state from background to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_BG_STATE_SETTLE_TIME\n         */\n        public long BG_STATE_SETTLE_TIME;\n\n        private final KeyValueListParser mParser = new KeyValueListParser(',');\n        private ContentResolver mResolver;\n\n        public Constants(Handler handler) {\n            super(handler);\n            updateConstants();\n        }\n\n        public void startMonitoring(ContentResolver resolver) {\n            mResolver = resolver;\n            mResolver.registerContentObserver(\n                    Settings.Global.getUriFor(Settings.Global.APP_OPS_CONSTANTS),\n                    false, this);\n            updateConstants();\n        }\n\n        @Override\n        public void onChange(boolean selfChange, Uri uri) {\n            updateConstants();\n        }\n\n        private void updateConstants() {\n            String value = mResolver != null ? Settings.Global.getString(mResolver,\n                    Settings.Global.APP_OPS_CONSTANTS) : \"\";\n\n            synchronized (AppOpsService.this) {\n                try {\n                    mParser.setString(value);\n                } catch (IllegalArgumentException e) {\n                    // Failed to parse the settings string, log this and move on\n                    // with defaults.\n                    Slog.e(TAG, \"Bad app ops settings\", e);\n                }\n                TOP_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_TOP_STATE_SETTLE_TIME, 5 * 1000L);\n                FG_SERVICE_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_FG_SERVICE_STATE_SETTLE_TIME, 5 * 1000L);\n                BG_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_BG_STATE_SETTLE_TIME, 1 * 1000L);\n            }\n        }\n\n        void dump(PrintWriter pw) {\n            pw.println(\"  Settings:\");\n\n            pw.print(\"    \"); pw.print(KEY_TOP_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(TOP_STATE_SETTLE_TIME, pw);\n            pw.println();\n            pw.print(\"    \"); pw.print(KEY_FG_SERVICE_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(FG_SERVICE_STATE_SETTLE_TIME, pw);\n            pw.println();\n            pw.print(\"    \"); pw.print(KEY_BG_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(BG_STATE_SETTLE_TIME, pw);\n            pw.println();\n        }\n    }\n\n    @VisibleForTesting\n    final Constants mConstants;\n\n    @VisibleForTesting\n    final class UidState {\n        public final int uid;\n\n        public int state = UID_STATE_CACHED;\n        public int pendingState = UID_STATE_CACHED;\n        public long pendingStateCommitTime;\n        public int capability;\n        public int pendingCapability;\n        public boolean appWidgetVisible;\n        public boolean pendingAppWidgetVisible;\n\n        public ArrayMap<String, Ops> pkgOps;\n        public SparseIntArray opModes;\n\n        // true indicates there is an interested observer, false there isn't but it has such an op\n        public SparseBooleanArray foregroundOps;\n        public boolean hasForegroundWatchers;\n\n        public UidState(int uid) {\n            this.uid = uid;\n        }\n\n        public void clear() {\n            pkgOps = null;\n            opModes = null;\n        }\n\n        public boolean isDefault() {\n            return (pkgOps == null || pkgOps.isEmpty())\n                    && (opModes == null || opModes.size() <= 0)\n                    && (state == UID_STATE_CACHED\n                    && (pendingState == UID_STATE_CACHED));\n        }\n\n        int evalMode(int op, int mode) {\n            if (mode == MODE_FOREGROUND) {\n                if (appWidgetVisible) {\n                    return MODE_ALLOWED;\n                } else if (mActivityManagerInternal != null\n                        && mActivityManagerInternal.isPendingTopUid(uid)) {\n                    return MODE_ALLOWED;\n                } else if (mActivityManagerInternal != null\n                        && mActivityManagerInternal.isTempAllowlistedForFgsWhileInUse(uid)) {\n                    return MODE_ALLOWED;\n                } else if (state <= UID_STATE_TOP) {\n                    // process is in TOP.\n                    return MODE_ALLOWED;\n                } else if (state <= AppOpsManager.resolveFirstUnrestrictedUidState(op)) {\n                    // process is in foreground, check its capability.\n                    switch (op) {\n                        case AppOpsManager.OP_FINE_LOCATION:\n                        case AppOpsManager.OP_COARSE_LOCATION:\n                        case AppOpsManager.OP_MONITOR_LOCATION:\n                        case AppOpsManager.OP_MONITOR_HIGH_POWER_LOCATION:\n                            if ((capability & PROCESS_CAPABILITY_FOREGROUND_LOCATION) != 0) {\n                                return MODE_ALLOWED;\n                            } else {\n                                return MODE_IGNORED;\n                            }\n                        case OP_CAMERA:\n                            if ((capability & PROCESS_CAPABILITY_FOREGROUND_CAMERA) != 0) {\n                                return MODE_ALLOWED;\n                            } else {\n                                return MODE_IGNORED;\n                            }\n                        case OP_RECORD_AUDIO:\n                            if ((capability & PROCESS_CAPABILITY_FOREGROUND_MICROPHONE) != 0) {\n                                return MODE_ALLOWED;\n                            } else {\n                                return MODE_IGNORED;\n                            }\n                        default:\n                            return MODE_ALLOWED;\n                    }\n                } else {\n                    // process is not in foreground.\n                    return MODE_IGNORED;\n                }\n            }\n            return mode;\n        }\n\n        private void evalForegroundWatchers(int op, SparseArray<ArraySet<ModeCallback>> watchers,\n                SparseBooleanArray which) {\n            boolean curValue = which.get(op, false);\n            ArraySet<ModeCallback> callbacks = watchers.get(op);\n            if (callbacks != null) {\n                for (int cbi = callbacks.size() - 1; !curValue && cbi >= 0; cbi--) {\n                    if ((callbacks.valueAt(cbi).mFlags\n                            & AppOpsManager.WATCH_FOREGROUND_CHANGES) != 0) {\n                        hasForegroundWatchers = true;\n                        curValue = true;\n                    }\n                }\n            }\n            which.put(op, curValue);\n        }\n\n        public void evalForegroundOps(SparseArray<ArraySet<ModeCallback>> watchers) {\n            SparseBooleanArray which = null;\n            hasForegroundWatchers = false;\n            if (opModes != null) {\n                for (int i = opModes.size() - 1; i >= 0; i--) {\n                    if (opModes.valueAt(i) == AppOpsManager.MODE_FOREGROUND) {\n                        if (which == null) {\n                            which = new SparseBooleanArray();\n                        }\n                        evalForegroundWatchers(opModes.keyAt(i), watchers, which);\n                    }\n                }\n            }\n            if (pkgOps != null) {\n                for (int i = pkgOps.size() - 1; i >= 0; i--) {\n                    Ops ops = pkgOps.valueAt(i);\n                    for (int j = ops.size() - 1; j >= 0; j--) {\n                        if (ops.valueAt(j).mode == AppOpsManager.MODE_FOREGROUND) {\n                            if (which == null) {\n                                which = new SparseBooleanArray();\n                            }\n                            evalForegroundWatchers(ops.keyAt(j), watchers, which);\n                        }\n                    }\n                }\n            }\n            foregroundOps = which;\n        }\n    }\n\n    final static class Ops extends SparseArray<Op> {\n        final String packageName;\n        final UidState uidState;\n\n        /**\n         * The restriction properties of the package. If {@code null} it could not have been read\n         * yet and has to be refreshed.\n         */\n        @Nullable RestrictionBypass bypass;\n\n        /** Lazily populated cache of attributionTags of this package */\n        final @NonNull ArraySet<String> knownAttributionTags = new ArraySet<>();\n\n        /**\n         * Lazily populated cache of <b>valid</b> attributionTags of this package, a set smaller\n         * than or equal to {@link #knownAttributionTags}.\n         */\n        final @NonNull ArraySet<String> validAttributionTags = new ArraySet<>();\n\n        Ops(String _packageName, UidState _uidState) {\n            packageName = _packageName;\n            uidState = _uidState;\n        }\n    }\n\n    /** Returned from {@link #verifyAndGetBypass(int, String, String, String, boolean)}. */\n    private static final class PackageVerificationResult {\n\n        final RestrictionBypass bypass;\n        final boolean isAttributionTagValid;\n\n        PackageVerificationResult(RestrictionBypass bypass, boolean isAttributionTagValid) {\n            this.bypass = bypass;\n            this.isAttributionTagValid = isAttributionTagValid;\n        }\n    }\n\n    /** A in progress startOp->finishOp event */\n    private static final class InProgressStartOpEvent implements IBinder.DeathRecipient {\n        /** Wall clock time of startOp event (not monotonic) */\n        private long mStartTime;\n\n        /** Elapsed time since boot of startOp event */\n        private long mStartElapsedTime;\n\n        /** Id of the client that started the event */\n        private @NonNull IBinder mClientId;\n\n        /** The attribution tag for this operation */\n        private @Nullable String mAttributionTag;\n\n        /** To call when client dies */\n        private @NonNull Runnable mOnDeath;\n\n        /** uidstate used when calling startOp */\n        private @AppOpsManager.UidState int mUidState;\n\n        /** Proxy information of the startOp event */\n        private @Nullable OpEventProxyInfo mProxy;\n\n        /** Proxy flag information */\n        private @OpFlags int mFlags;\n\n        /** How many times the op was started but not finished yet */\n        int numUnfinishedStarts;\n\n        /** The attribution flags related to this event */\n        private @AttributionFlags int mAttributionFlags;\n\n        /** The id of the attribution chain this even is a part of */\n        private int mAttributionChainId;\n\n        /**\n         * Create a new {@link InProgressStartOpEvent}.\n         *\n         * @param startTime The time {@link #startOperation} was called\n         * @param startElapsedTime The elapsed time when {@link #startOperation} was called\n         * @param clientId The client id of the caller of {@link #startOperation}\n         * @param attributionTag The attribution tag for the operation.\n         * @param onDeath The code to execute on client death\n         * @param uidState The uidstate of the app {@link #startOperation} was called for\n         * @param attributionFlags the attribution flags for this operation.\n         * @param attributionChainId the unique id of the attribution chain this op is a part of.\n         * @param proxy The proxy information, if {@link #startProxyOperation} was called\n         * @param flags The trusted/nontrusted/self flags.\n         *\n         * @throws RemoteException If the client is dying\n         */\n        private InProgressStartOpEvent(long startTime, long startElapsedTime,\n                @NonNull IBinder clientId, @Nullable String attributionTag,\n                @NonNull Runnable onDeath, @AppOpsManager.UidState int uidState,\n                @Nullable OpEventProxyInfo proxy, @OpFlags int flags,\n                @AttributionFlags int attributionFlags, int attributionChainId)\n                throws RemoteException {\n            mStartTime = startTime;\n            mStartElapsedTime = startElapsedTime;\n            mClientId = clientId;\n            mAttributionTag = attributionTag;\n            mOnDeath = onDeath;\n            mUidState = uidState;\n            mProxy = proxy;\n            mFlags = flags;\n            mAttributionFlags = attributionFlags;\n            mAttributionChainId = attributionChainId;\n\n            clientId.linkToDeath(this, 0);\n        }\n\n        /** Clean up event */\n        public void finish() {\n            try {\n                mClientId.unlinkToDeath(this, 0);\n            } catch (NoSuchElementException e) {\n                // Either not linked, or already unlinked. Either way, nothing to do.\n            }\n        }\n\n        @Override\n        public void binderDied() {\n            mOnDeath.run();\n        }\n\n        /**\n         * Reinit existing object with new state.\n         *\n         * @param startTime The time {@link #startOperation} was called\n         * @param startElapsedTime The elapsed time when {@link #startOperation} was called\n         * @param clientId The client id of the caller of {@link #startOperation}\n         * @param attributionTag The attribution tag for this operation.\n         * @param onDeath The code to execute on client death\n         * @param uidState The uidstate of the app {@link #startOperation} was called for\n         * @param flags The flags relating to the proxy\n         * @param proxy The proxy information, if {@link #startProxyOperation} was called\n         * @param attributionFlags the attribution flags for this operation.\n         * @param attributionChainId the unique id of the attribution chain this op is a part of.\n         * @param proxyPool The pool to release previous {@link OpEventProxyInfo} to\n         *\n         * @throws RemoteException If the client is dying\n         */\n        public void reinit(long startTime, long startElapsedTime, @NonNull IBinder clientId,\n                @Nullable String attributionTag, @NonNull Runnable onDeath,\n                @AppOpsManager.UidState int uidState, @OpFlags int flags,\n                @Nullable OpEventProxyInfo proxy, @AttributionFlags int attributionFlags,\n                int attributionChainId, @NonNull Pools.Pool<OpEventProxyInfo> proxyPool\n        ) throws RemoteException {\n            mStartTime = startTime;\n            mStartElapsedTime = startElapsedTime;\n            mClientId = clientId;\n            mAttributionTag = attributionTag;\n            mOnDeath = onDeath;\n            mUidState = uidState;\n            mFlags = flags;\n\n            if (mProxy != null) {\n                proxyPool.release(mProxy);\n            }\n            mProxy = proxy;\n            mAttributionFlags = attributionFlags;\n            mAttributionChainId = attributionChainId;\n\n            clientId.linkToDeath(this, 0);\n        }\n\n        /** @return Wall clock time of startOp event */\n        public long getStartTime() {\n            return mStartTime;\n        }\n\n        /** @return Elapsed time since boot of startOp event */\n        public long getStartElapsedTime() {\n            return mStartElapsedTime;\n        }\n\n        /** @return Id of the client that started the event */\n        public @NonNull IBinder getClientId() {\n            return mClientId;\n        }\n\n        /** @return uidstate used when calling startOp */\n        public @AppOpsManager.UidState int getUidState() {\n            return mUidState;\n        }\n\n        /** @return proxy tag for the access */\n        public @Nullable OpEventProxyInfo getProxy() {\n            return mProxy;\n        }\n\n        /** @return flags used for the access */\n        public @OpFlags int getFlags() {\n            return mFlags;\n        }\n\n        /** @return attributoin flags used for the access */\n        public @AttributionFlags int getAttributionFlags() {\n            return mAttributionFlags;\n        }\n\n        /** @return attribution chain id for the access */\n        public int getAttributionChainId() {\n            return mAttributionChainId;\n        }\n    }\n\n    private final class AttributedOp {\n        public final @Nullable String tag;\n        public final @NonNull Op parent;\n\n        /**\n         * Last successful accesses (noteOp + finished startOp) for each uidState/opFlag combination\n         *\n         * <p>Key is {@link AppOpsManager#makeKey}\n         */\n        @GuardedBy(\"AppOpsService.this\")\n        private @Nullable LongSparseArray<NoteOpEvent> mAccessEvents;\n\n        /**\n         * Last rejected accesses for each uidState/opFlag combination\n         *\n         * <p>Key is {@link AppOpsManager#makeKey}\n         */\n        @GuardedBy(\"AppOpsService.this\")\n        private @Nullable LongSparseArray<NoteOpEvent> mRejectEvents;\n\n        /**\n         * Currently in progress startOp events\n         *\n         * <p>Key is clientId\n         */\n        @GuardedBy(\"AppOpsService.this\")\n        private @Nullable ArrayMap<IBinder, InProgressStartOpEvent> mInProgressEvents;\n\n        /**\n         * Currently paused startOp events\n         *\n         * <p>Key is clientId\n         */\n        @GuardedBy(\"AppOpsService.this\")\n        private @Nullable ArrayMap<IBinder, InProgressStartOpEvent> mPausedInProgressEvents;\n\n        AttributedOp(@Nullable String tag, @NonNull Op parent) {\n            this.tag = tag;\n            this.parent = parent;\n        }\n\n        /**\n         * Update state when noteOp was rejected or startOp->finishOp event finished\n         *\n         * @param proxyUid The uid of the proxy\n         * @param proxyPackageName The package name of the proxy\n         * @param proxyAttributionTag the attributionTag in the proxies package\n         * @param uidState UID state of the app noteOp/startOp was called for\n         * @param flags OpFlags of the call\n         */\n        public void accessed(int proxyUid, @Nullable String proxyPackageName,\n                @Nullable String proxyAttributionTag, @AppOpsManager.UidState int uidState,\n                @OpFlags int flags) {\n            long accessTime = System.currentTimeMillis();\n            accessed(accessTime, -1, proxyUid, proxyPackageName,\n                    proxyAttributionTag, uidState, flags);\n\n            mHistoricalRegistry.incrementOpAccessedCount(parent.op, parent.uid, parent.packageName,\n                    tag, uidState, flags, accessTime, AppOpsManager.ATTRIBUTION_FLAGS_NONE,\n                    AppOpsManager.ATTRIBUTION_CHAIN_ID_NONE);\n        }\n\n        /**\n         * Add an access that was previously collected.\n         *\n         * @param noteTime The time of the event\n         * @param duration The duration of the event\n         * @param proxyUid The uid of the proxy\n         * @param proxyPackageName The package name of the proxy\n         * @param proxyAttributionTag the attributionTag in the proxies package\n         * @param uidState UID state of the app noteOp/startOp was called for\n         * @param flags OpFlags of the call\n         */\n        public void accessed(long noteTime, long duration, int proxyUid,\n                @Nullable String proxyPackageName, @Nullable String proxyAttributionTag,\n                @AppOpsManager.UidState int uidState, @OpFlags int flags) {\n            long key = makeKey(uidState, flags);\n\n            if (mAccessEvents == null) {\n                mAccessEvents = new LongSparseArray<>(1);\n            }\n\n            OpEventProxyInfo proxyInfo = null;\n            if (proxyUid != Process.INVALID_UID) {\n                proxyInfo = mOpEventProxyInfoPool.acquire(proxyUid, proxyPackageName,\n                        proxyAttributionTag);\n            }\n\n            NoteOpEvent existingEvent = mAccessEvents.get(key);\n            if (existingEvent != null) {\n                existingEvent.reinit(noteTime, duration, proxyInfo, mOpEventProxyInfoPool);\n            } else {\n                mAccessEvents.put(key, new NoteOpEvent(noteTime, duration, proxyInfo));\n            }\n        }\n\n        /**\n         * Update state when noteOp/startOp was rejected.\n         *\n         * @param uidState UID state of the app noteOp is called for\n         * @param flags OpFlags of the call\n         */\n        public void rejected(@AppOpsManager.UidState int uidState, @OpFlags int flags) {\n            rejected(System.currentTimeMillis(), uidState, flags);\n\n            mHistoricalRegistry.incrementOpRejected(parent.op, parent.uid, parent.packageName,\n                    tag, uidState, flags);\n        }\n\n        /**\n         * Add an rejection that was previously collected\n         *\n         * @param noteTime The time of the event\n         * @param uidState UID state of the app noteOp/startOp was called for\n         * @param flags OpFlags of the call\n         */\n        public void rejected(long noteTime, @AppOpsManager.UidState int uidState,\n                @OpFlags int flags) {\n            long key = makeKey(uidState, flags);\n\n            if (mRejectEvents == null) {\n                mRejectEvents = new LongSparseArray<>(1);\n            }\n\n            // We do not collect proxy information for rejections yet\n            NoteOpEvent existingEvent = mRejectEvents.get(key);\n            if (existingEvent != null) {\n                existingEvent.reinit(noteTime, -1, null, mOpEventProxyInfoPool);\n            } else {\n                mRejectEvents.put(key, new NoteOpEvent(noteTime, -1, null));\n            }\n        }\n\n        /**\n         * Update state when start was called\n         *\n         * @param clientId Id of the startOp caller\n         * @param proxyUid The UID of the proxy app\n         * @param proxyPackageName The package name of the proxy app\n         * @param proxyAttributionTag The attribution tag of the proxy app\n         * @param uidState UID state of the app startOp is called for\n         * @param flags The proxy flags\n         * @param attributionFlags The attribution flags associated with this operation.\n         * @param attributionChainId The if of the attribution chain this operations is a part of.\n         */\n        public void started(@NonNull IBinder clientId, int proxyUid,\n                @Nullable String proxyPackageName, @Nullable String proxyAttributionTag,\n                @AppOpsManager.UidState int uidState, @OpFlags int flags, @AttributionFlags\n                int attributionFlags, int attributionChainId) throws RemoteException {\n            started(clientId, proxyUid, proxyPackageName, proxyAttributionTag,\n                    uidState, flags,/*triggerCallbackIfNeeded*/ true, attributionFlags,\n                    attributionChainId);\n        }\n\n        private void started(@NonNull IBinder clientId, int proxyUid,\n                @Nullable String proxyPackageName, @Nullable String proxyAttributionTag,\n                @AppOpsManager.UidState int uidState, @OpFlags int flags,\n                boolean triggerCallbackIfNeeded, @AttributionFlags int attributionFlags,\n                int attributionChainId) throws RemoteException {\n            startedOrPaused(clientId, proxyUid, proxyPackageName,\n                    proxyAttributionTag, uidState, flags, triggerCallbackIfNeeded,\n                    /*triggerCallbackIfNeeded*/ true, attributionFlags, attributionChainId);\n        }\n\n        private void startedOrPaused(@NonNull IBinder clientId, int proxyUid,\n                @Nullable String proxyPackageName, @Nullable String proxyAttributionTag,\n                @AppOpsManager.UidState int uidState, @OpFlags int flags,\n                boolean triggerCallbackIfNeeded, boolean isStarted, @AttributionFlags\n                int attributionFlags, int attributionChainId) throws RemoteException {\n            if (triggerCallbackIfNeeded && !parent.isRunning() && isStarted) {\n                scheduleOpActiveChangedIfNeededLocked(parent.op, parent.uid, parent.packageName,\n                        tag, true, attributionFlags, attributionChainId);\n            }\n\n            if (isStarted && mInProgressEvents == null) {\n                mInProgressEvents = new ArrayMap<>(1);\n            } else if (!isStarted && mPausedInProgressEvents == null) {\n                mPausedInProgressEvents = new ArrayMap<>(1);\n            }\n            ArrayMap<IBinder, InProgressStartOpEvent> events = isStarted\n                    ? mInProgressEvents : mPausedInProgressEvents;\n\n            long startTime = System.currentTimeMillis();\n            InProgressStartOpEvent event = events.get(clientId);\n            if (event == null) {\n                event = mInProgressStartOpEventPool.acquire(startTime,\n                        SystemClock.elapsedRealtime(), clientId, tag,\n                        PooledLambda.obtainRunnable(AppOpsService::onClientDeath, this, clientId),\n                        proxyUid, proxyPackageName, proxyAttributionTag, uidState, flags,\n                        attributionFlags, attributionChainId);\n                events.put(clientId, event);\n            } else {\n                if (uidState != event.mUidState) {\n                    onUidStateChanged(uidState);\n                }\n            }\n\n            event.numUnfinishedStarts++;\n\n            if (isStarted) {\n                mHistoricalRegistry.incrementOpAccessedCount(parent.op, parent.uid,\n                        parent.packageName, tag, uidState, flags, startTime, attributionFlags,\n                        attributionChainId);\n            }\n        }\n\n        /**\n         * Update state when finishOp was called. Will finish started ops, and delete paused ops.\n         *\n         * @param clientId Id of the finishOp caller\n         */\n        public void finished(@NonNull IBinder clientId) {\n            finished(clientId, true);\n        }\n\n        private void finished(@NonNull IBinder clientId, boolean triggerCallbackIfNeeded) {\n            finishOrPause(clientId, triggerCallbackIfNeeded, false);\n        }\n\n        /**\n         * Update state when paused or finished is called. If pausing, it records the op as\n         * stopping in the HistoricalRegistry, but does not delete it.\n         */\n        private void finishOrPause(@NonNull IBinder clientId, boolean triggerCallbackIfNeeded,\n                boolean isPausing) {\n            int indexOfToken = isRunning() ? mInProgressEvents.indexOfKey(clientId) : -1;\n            if (indexOfToken < 0) {\n                finishPossiblyPaused(clientId, isPausing);\n                return;\n            }\n\n            InProgressStartOpEvent event = mInProgressEvents.valueAt(indexOfToken);\n            if (!isPausing) {\n                event.numUnfinishedStarts--;\n            }\n            // If we are pausing, create a NoteOpEvent, but don't change the InProgress event\n            if (event.numUnfinishedStarts == 0 || isPausing) {\n                if (!isPausing) {\n                    event.finish();\n                    mInProgressEvents.removeAt(indexOfToken);\n                }\n\n                if (mAccessEvents == null) {\n                    mAccessEvents = new LongSparseArray<>(1);\n                }\n\n                OpEventProxyInfo proxyCopy = event.getProxy() != null\n                        ? new OpEventProxyInfo(event.getProxy()) : null;\n\n                long accessDurationMillis =\n                        SystemClock.elapsedRealtime() - event.getStartElapsedTime();\n                NoteOpEvent finishedEvent = new NoteOpEvent(event.getStartTime(),\n                        accessDurationMillis, proxyCopy);\n                mAccessEvents.put(makeKey(event.getUidState(), event.getFlags()),\n                        finishedEvent);\n\n                mHistoricalRegistry.increaseOpAccessDuration(parent.op, parent.uid,\n                        parent.packageName, tag, event.getUidState(),\n                        event.getFlags(), finishedEvent.getNoteTime(), finishedEvent.getDuration(),\n                        event.getAttributionFlags(), event.getAttributionChainId());\n\n                if (!isPausing) {\n                    mInProgressStartOpEventPool.release(event);\n                    if (mInProgressEvents.isEmpty()) {\n                        mInProgressEvents = null;\n\n                        // TODO ntmyren: Also callback for single attribution tag activity changes\n                        if (triggerCallbackIfNeeded && !parent.isRunning()) {\n                            scheduleOpActiveChangedIfNeededLocked(parent.op, parent.uid,\n                                    parent.packageName, tag, false, event.getAttributionFlags(),\n                                    event.getAttributionChainId());\n                        }\n                    }\n                }\n            }\n        }\n\n        // Finish or pause (no-op) an already paused op\n        private void finishPossiblyPaused(@NonNull IBinder clientId, boolean isPausing) {\n            if (!isPaused()) {\n                Slog.wtf(TAG, \"No ops running or paused\");\n                return;\n            }\n\n            int indexOfToken = mPausedInProgressEvents.indexOfKey(clientId);\n            if (indexOfToken < 0) {\n                Slog.wtf(TAG, \"No op running or paused for the client\");\n                return;\n            } else if (isPausing) {\n                // already paused\n                return;\n            }\n\n            // no need to record a paused event finishing.\n            InProgressStartOpEvent event = mPausedInProgressEvents.valueAt(indexOfToken);\n            event.numUnfinishedStarts--;\n            if (event.numUnfinishedStarts == 0) {\n                mPausedInProgressEvents.removeAt(indexOfToken);\n                mInProgressStartOpEventPool.release(event);\n                if (mPausedInProgressEvents.isEmpty()) {\n                    mPausedInProgressEvents = null;\n                }\n            }\n        }\n\n        /**\n         * Create an event that will be started, if the op is unpaused.\n         */\n        public void createPaused(@NonNull IBinder clientId, int proxyUid,\n                @Nullable String proxyPackageName, @Nullable String proxyAttributionTag,\n                @AppOpsManager.UidState int uidState, @OpFlags int flags, @AttributionFlags\n                int attributionFlags, int attributionChainId) throws RemoteException {\n            startedOrPaused(clientId, proxyUid, proxyPackageName, proxyAttributionTag,\n                    uidState, flags, true, false, attributionFlags, attributionChainId);\n        }\n\n        /**\n         * Pause all currently started ops. This will create a HistoricalRegistry\n         */\n        public void pause() {\n            if (!isRunning()) {\n                return;\n            }\n\n            if (mPausedInProgressEvents == null) {\n                mPausedInProgressEvents = new ArrayMap<>(1);\n            }\n\n            for (int i = 0; i < mInProgressEvents.size(); i++) {\n                InProgressStartOpEvent event = mInProgressEvents.valueAt(i);\n                mPausedInProgressEvents.put(event.mClientId, event);\n                finishOrPause(event.mClientId, true, true);\n\n                scheduleOpActiveChangedIfNeededLocked(parent.op, parent.uid,\n                        parent.packageName, tag, false,\n                        event.getAttributionFlags(), event.getAttributionChainId());\n            }\n            mInProgressEvents = null;\n        }\n\n        /**\n         * Unpause all currently paused ops. This will reinitialize their start and duration\n         * times, but keep all other values the same\n         */\n        public void resume() {\n            if (!isPaused()) {\n                return;\n            }\n\n            if (mInProgressEvents == null) {\n                mInProgressEvents = new ArrayMap<>(mPausedInProgressEvents.size());\n            }\n            boolean shouldSendActive = !mPausedInProgressEvents.isEmpty()\n                    && mInProgressEvents.isEmpty();\n\n            long startTime = System.currentTimeMillis();\n            for (int i = 0; i < mPausedInProgressEvents.size(); i++) {\n                InProgressStartOpEvent event = mPausedInProgressEvents.valueAt(i);\n                mInProgressEvents.put(event.mClientId, event);\n                event.mStartElapsedTime = SystemClock.elapsedRealtime();\n                event.mStartTime = startTime;\n                mHistoricalRegistry.incrementOpAccessedCount(parent.op, parent.uid,\n                        parent.packageName, tag, event.mUidState, event.mFlags, startTime,\n                        event.getAttributionFlags(), event.getAttributionChainId());\n                if (shouldSendActive) {\n                    scheduleOpActiveChangedIfNeededLocked(parent.op, parent.uid, parent.packageName,\n                            tag, true, event.getAttributionFlags(), event.getAttributionChainId());\n                }\n                // Note: this always sends MODE_ALLOWED, even if the mode is FOREGROUND\n                // TODO ntmyren: figure out how to get the real mode.\n                scheduleOpStartedIfNeededLocked(parent.op, parent.uid, parent.packageName,\n                        tag, event.getFlags(), MODE_ALLOWED, START_TYPE_RESUMED,\n                        event.getAttributionFlags(), event.getAttributionChainId());\n            }\n            mPausedInProgressEvents = null;\n        }\n\n        /**\n         * Called in the case the client dies without calling finish first\n         *\n         * @param clientId The client that died\n         */\n        void onClientDeath(@NonNull IBinder clientId) {\n            synchronized (AppOpsService.this) {\n                if (!isPaused() && !isRunning()) {\n                    return;\n                }\n\n                ArrayMap<IBinder, InProgressStartOpEvent> events = isPaused()\n                        ? mPausedInProgressEvents : mInProgressEvents;\n                InProgressStartOpEvent deadEvent = events.get(clientId);\n                if (deadEvent != null) {\n                    deadEvent.numUnfinishedStarts = 1;\n                }\n\n                finished(clientId);\n            }\n        }\n\n        /**\n         * Notify that the state of the uid changed\n         *\n         * @param newState The new state\n         */\n        public void onUidStateChanged(@AppOpsManager.UidState int newState) {\n            if (!isPaused() && !isRunning()) {\n                return;\n            }\n\n            boolean isRunning = isRunning();\n            ArrayMap<IBinder, AppOpsService.InProgressStartOpEvent> events =\n                    isRunning ? mInProgressEvents : mPausedInProgressEvents;\n\n            int numInProgressEvents = events.size();\n            List<IBinder> binders = new ArrayList<>(events.keySet());\n            for (int i = 0; i < numInProgressEvents; i++) {\n                InProgressStartOpEvent event = events.get(binders.get(i));\n\n                if (event != null && event.getUidState() != newState) {\n                    try {\n                        // Remove all but one unfinished start count and then call finished() to\n                        // remove start event object\n                        int numPreviousUnfinishedStarts = event.numUnfinishedStarts;\n                        event.numUnfinishedStarts = 1;\n                        OpEventProxyInfo proxy = event.getProxy();\n\n                        finished(event.getClientId(), false);\n\n                        // Call started() to add a new start event object and then add the\n                        // previously removed unfinished start counts back\n                        if (proxy != null) {\n                            startedOrPaused(event.getClientId(), proxy.getUid(),\n                                    proxy.getPackageName(), proxy.getAttributionTag(), newState,\n                                    event.getFlags(), false, isRunning,\n                                    event.getAttributionFlags(), event.getAttributionChainId());\n                        } else {\n                            startedOrPaused(event.getClientId(), Process.INVALID_UID, null, null,\n                                    newState, event.getFlags(), false, isRunning,\n                                    event.getAttributionFlags(), event.getAttributionChainId());\n                        }\n\n                        events = isRunning ? mInProgressEvents : mPausedInProgressEvents;\n                        InProgressStartOpEvent newEvent = events.get(binders.get(i));\n                        if (newEvent != null) {\n                            newEvent.numUnfinishedStarts += numPreviousUnfinishedStarts - 1;\n                        }\n                    } catch (RemoteException e) {\n                        if (DEBUG) Slog.e(TAG, \"Cannot switch to new uidState \" + newState);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Combine {@code a} and {@code b} and return the result. The result might be {@code a}\n         * or {@code b}. If there is an event for the same key in both the later event is retained.\n         */\n        private @Nullable LongSparseArray<NoteOpEvent> add(@Nullable LongSparseArray<NoteOpEvent> a,\n                @Nullable LongSparseArray<NoteOpEvent> b) {\n            if (a == null) {\n                return b;\n            }\n\n            if (b == null) {\n                return a;\n            }\n\n            int numEventsToAdd = b.size();\n            for (int i = 0; i < numEventsToAdd; i++) {\n                long keyOfEventToAdd = b.keyAt(i);\n                NoteOpEvent bEvent = b.valueAt(i);\n                NoteOpEvent aEvent = a.get(keyOfEventToAdd);\n\n                if (aEvent == null || bEvent.getNoteTime() > aEvent.getNoteTime()) {\n                    a.put(keyOfEventToAdd, bEvent);\n                }\n            }\n\n            return a;\n        }\n\n        /**\n         * Add all data from the {@code opToAdd} to this op.\n         *\n         * <p>If there is an event for the same key in both the later event is retained.\n         * <p>{@code opToAdd} should not be used after this method is called.\n         *\n         * @param opToAdd The op to add\n         */\n        public void add(@NonNull AttributedOp opToAdd) {\n            if (opToAdd.isRunning() || opToAdd.isPaused()) {\n                ArrayMap<IBinder, InProgressStartOpEvent> ignoredEvents = opToAdd.isRunning()\n                        ? opToAdd.mInProgressEvents : opToAdd.mPausedInProgressEvents;\n                Slog.w(TAG, \"Ignoring \" + ignoredEvents.size() + \" app-ops, running: \"\n                        + opToAdd.isRunning());\n\n                int numInProgressEvents = ignoredEvents.size();\n                for (int i = 0; i < numInProgressEvents; i++) {\n                    InProgressStartOpEvent event = ignoredEvents.valueAt(i);\n\n                    event.finish();\n                    mInProgressStartOpEventPool.release(event);\n                }\n            }\n\n            mAccessEvents = add(mAccessEvents, opToAdd.mAccessEvents);\n            mRejectEvents = add(mRejectEvents, opToAdd.mRejectEvents);\n        }\n\n        public boolean isRunning() {\n            return mInProgressEvents != null && !mInProgressEvents.isEmpty();\n        }\n\n        public boolean isPaused() {\n            return mPausedInProgressEvents != null && !mPausedInProgressEvents.isEmpty();\n        }\n\n        boolean hasAnyTime() {\n            return (mAccessEvents != null && mAccessEvents.size() > 0)\n                    || (mRejectEvents != null && mRejectEvents.size() > 0);\n        }\n\n        /**\n         * Clone a {@link LongSparseArray} and clone all values.\n         */\n        private @Nullable LongSparseArray<NoteOpEvent> deepClone(\n                @Nullable LongSparseArray<NoteOpEvent> original) {\n            if (original == null) {\n                return original;\n            }\n\n            int size = original.size();\n            LongSparseArray<NoteOpEvent> clone = new LongSparseArray<>(size);\n            for (int i = 0; i < size; i++) {\n                clone.put(original.keyAt(i), new NoteOpEvent(original.valueAt(i)));\n            }\n\n            return clone;\n        }\n\n        @NonNull AttributedOpEntry createAttributedOpEntryLocked() {\n            LongSparseArray<NoteOpEvent> accessEvents = deepClone(mAccessEvents);\n\n            // Add in progress events as access events\n            if (isRunning()) {\n                long now = SystemClock.elapsedRealtime();\n                int numInProgressEvents = mInProgressEvents.size();\n\n                if (accessEvents == null) {\n                    accessEvents = new LongSparseArray<>(numInProgressEvents);\n                }\n\n                for (int i = 0; i < numInProgressEvents; i++) {\n                    InProgressStartOpEvent event = mInProgressEvents.valueAt(i);\n\n                    accessEvents.append(makeKey(event.getUidState(), event.getFlags()),\n                            new NoteOpEvent(event.getStartTime(), now - event.getStartElapsedTime(),\n                                    event.getProxy()));\n                }\n            }\n\n            LongSparseArray<NoteOpEvent> rejectEvents = deepClone(mRejectEvents);\n\n            return new AttributedOpEntry(parent.op, isRunning(), accessEvents, rejectEvents);\n        }\n    }\n\n    final class Op {\n        int op;\n        int uid;\n        final UidState uidState;\n        final @NonNull String packageName;\n\n        private @Mode int mode;\n\n        /** attributionTag -> AttributedOp */\n        final ArrayMap<String, AttributedOp> mAttributions = new ArrayMap<>(1);\n\n        Op(UidState uidState, String packageName, int op, int uid) {\n            this.op = op;\n            this.uid = uid;\n            this.uidState = uidState;\n            this.packageName = packageName;\n            this.mode = AppOpsManager.opToDefaultMode(op);\n        }\n\n        int getMode() {\n            return mode;\n        }\n\n        int evalMode() {\n            return uidState.evalMode(op, mode);\n        }\n\n        void removeAttributionsWithNoTime() {\n            for (int i = mAttributions.size() - 1; i >= 0; i--) {\n                if (!mAttributions.valueAt(i).hasAnyTime()) {\n                    mAttributions.removeAt(i);\n                }\n            }\n        }\n\n        private @NonNull AttributedOp getOrCreateAttribution(@NonNull Op parent,\n                @Nullable String attributionTag) {\n            AttributedOp attributedOp;\n\n            attributedOp = mAttributions.get(attributionTag);\n            if (attributedOp == null) {\n                attributedOp = new AttributedOp(attributionTag, parent);\n                mAttributions.put(attributionTag, attributedOp);\n            }\n\n            return attributedOp;\n        }\n\n        @NonNull OpEntry createEntryLocked() {\n            final int numAttributions = mAttributions.size();\n\n            final ArrayMap<String, AppOpsManager.AttributedOpEntry> attributionEntries =\n                    new ArrayMap<>(numAttributions);\n            for (int i = 0; i < numAttributions; i++) {\n                attributionEntries.put(mAttributions.keyAt(i),\n                        mAttributions.valueAt(i).createAttributedOpEntryLocked());\n            }\n\n            return new OpEntry(op, mode, attributionEntries);\n        }\n\n        @NonNull OpEntry createSingleAttributionEntryLocked(@Nullable String attributionTag) {\n            final int numAttributions = mAttributions.size();\n\n            final ArrayMap<String, AttributedOpEntry> attributionEntries = new ArrayMap<>(1);\n            for (int i = 0; i < numAttributions; i++) {\n                if (Objects.equals(mAttributions.keyAt(i), attributionTag)) {\n                    attributionEntries.put(mAttributions.keyAt(i),\n                            mAttributions.valueAt(i).createAttributedOpEntryLocked());\n                    break;\n                }\n            }\n\n            return new OpEntry(op, mode, attributionEntries);\n        }\n\n        boolean isRunning() {\n            final int numAttributions = mAttributions.size();\n            for (int i = 0; i < numAttributions; i++) {\n                if (mAttributions.valueAt(i).isRunning()) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n\n    final SparseArray<ArraySet<ModeCallback>> mOpModeWatchers = new SparseArray<>();\n    final ArrayMap<String, ArraySet<ModeCallback>> mPackageModeWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, ModeCallback> mModeWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<ActiveCallback>> mActiveWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<StartedCallback>> mStartedWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<NotedCallback>> mNotedWatchers = new ArrayMap<>();\n    final AudioRestrictionManager mAudioRestrictionManager = new AudioRestrictionManager();\n\n    final class ModeCallback implements DeathRecipient {\n        /** If mWatchedOpCode==ALL_OPS notify for ops affected by the switch-op */\n        public static final int ALL_OPS = -2;\n\n        final IAppOpsCallback mCallback;\n        final int mWatchingUid;\n        final int mFlags;\n        final int mWatchedOpCode;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        ModeCallback(IAppOpsCallback callback, int watchingUid, int flags, int watchedOp,\n                int callingUid, int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mFlags = flags;\n            mWatchedOpCode = watchedOp;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        public boolean isWatchingUid(int uid) {\n            return uid == UID_ANY || mWatchingUid < 0 || mWatchingUid == uid;\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"ModeCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" flags=0x\");\n            sb.append(Integer.toHexString(mFlags));\n            switch (mWatchedOpCode) {\n                case OP_NONE:\n                    break;\n                case ALL_OPS:\n                    sb.append(\" op=(all)\");\n                    break;\n                default:\n                    sb.append(\" op=\");\n                    sb.append(opToName(mWatchedOpCode));\n                    break;\n            }\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void unlinkToDeath() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingMode(mCallback);\n        }\n    }\n\n    final class ActiveCallback implements DeathRecipient {\n        final IAppOpsActiveCallback mCallback;\n        final int mWatchingUid;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        ActiveCallback(IAppOpsActiveCallback callback, int watchingUid, int callingUid,\n                int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"ActiveCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void destroy() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingActive(mCallback);\n        }\n    }\n\n    final class StartedCallback implements DeathRecipient {\n        final IAppOpsStartedCallback mCallback;\n        final int mWatchingUid;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        StartedCallback(IAppOpsStartedCallback callback, int watchingUid, int callingUid,\n                int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"StartedCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void destroy() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingStarted(mCallback);\n        }\n    }\n\n    final class NotedCallback implements DeathRecipient {\n        final IAppOpsNotedCallback mCallback;\n        final int mWatchingUid;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        NotedCallback(IAppOpsNotedCallback callback, int watchingUid, int callingUid,\n                int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"NotedCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void destroy() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingNoted(mCallback);\n        }\n    }\n\n    /**\n     * Call {@link AttributedOp#onClientDeath attributedOp.onClientDeath(clientId)}.\n     */\n    private static void onClientDeath(@NonNull AttributedOp attributedOp,\n            @NonNull IBinder clientId) {\n        attributedOp.onClientDeath(clientId);\n    }\n\n\n    /**\n     * Loads the OpsValidation file results into a hashmap {@link #mNoteOpCallerStacktraces}\n     * so that we do not log the same operation twice between instances\n     */\n    private void readNoteOpCallerStackTraces() {\n        try {\n            if (!mNoteOpCallerStacktracesFile.exists()) {\n                mNoteOpCallerStacktracesFile.createNewFile();\n                return;\n            }\n\n            try (Scanner read = new Scanner(mNoteOpCallerStacktracesFile)) {\n                read.useDelimiter(\"\\\\},\");\n                while (read.hasNext()) {\n                    String jsonOps = read.next();\n                    mNoteOpCallerStacktraces.add(NoteOpTrace.fromJson(jsonOps));\n                }\n            }\n        } catch (Exception e) {\n            Slog.e(TAG, \"Cannot parse traces noteOps\", e);\n        }\n    }\n\n    public AppOpsService(File storagePath, Handler handler, Context context) {\n        mContext = context;\n\n        LockGuard.installLock(this, LockGuard.INDEX_APP_OPS);\n        mFile = new AtomicFile(storagePath, \"appops\");\n        if (AppOpsManager.NOTE_OP_COLLECTION_ENABLED) {\n            mNoteOpCallerStacktracesFile = new File(SystemServiceManager.ensureSystemDir(),\n                    \"noteOpStackTraces.json\");\n            readNoteOpCallerStackTraces();\n        } else {\n            mNoteOpCallerStacktracesFile = null;\n        }\n        mHandler = handler;\n        mConstants = new Constants(mHandler);\n        readState();\n\n        for (int switchedCode = 0; switchedCode < _NUM_OP; switchedCode++) {\n            int switchCode = AppOpsManager.opToSwitch(switchedCode);\n            mSwitchedOps.put(switchCode,\n                    ArrayUtils.appendInt(mSwitchedOps.get(switchCode), switchedCode));\n        }\n    }\n\n    public void publish() {\n        ServiceManager.addService(Context.APP_OPS_SERVICE, asBinder());\n        LocalServices.addService(AppOpsManagerInternal.class, mAppOpsManagerInternal);\n    }\n\n    /** Handler for work when packages are removed or updated */\n    private BroadcastReceiver mOnPackageUpdatedReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            String pkgName = intent.getData().getEncodedSchemeSpecificPart();\n            int uid = intent.getIntExtra(Intent.EXTRA_UID, Process.INVALID_UID);\n\n            if (action.equals(ACTION_PACKAGE_REMOVED) && !intent.hasExtra(EXTRA_REPLACING)) {\n                synchronized (AppOpsService.this) {\n                    UidState uidState = mUidStates.get(uid);\n                    if (uidState == null || uidState.pkgOps == null) {\n                        return;\n                    }\n\n                    Ops removedOps = uidState.pkgOps.remove(pkgName);\n                    if (removedOps != null) {\n                        scheduleFastWriteLocked();\n                    }\n                }\n            } else if (action.equals(Intent.ACTION_PACKAGE_REPLACED)) {\n                AndroidPackage pkg = getPackageManagerInternal().getPackage(pkgName);\n                if (pkg == null) {\n                    return;\n                }\n\n                ArrayMap<String, String> dstAttributionTags = new ArrayMap<>();\n                ArraySet<String> attributionTags = new ArraySet<>();\n                attributionTags.add(null);\n                if (pkg.getAttributions() != null) {\n                    int numAttributions = pkg.getAttributions().size();\n                    for (int attributionNum = 0; attributionNum < numAttributions;\n                            attributionNum++) {\n                        ParsedAttribution attribution = pkg.getAttributions().get(attributionNum);\n                        attributionTags.add(attribution.getTag());\n\n                        int numInheritFrom = attribution.getInheritFrom().size();\n                        for (int inheritFromNum = 0; inheritFromNum < numInheritFrom;\n                                inheritFromNum++) {\n                            dstAttributionTags.put(attribution.getInheritFrom().get(inheritFromNum),\n                                    attribution.getTag());\n                        }\n                    }\n                }\n\n                synchronized (AppOpsService.this) {\n                    UidState uidState = mUidStates.get(uid);\n                    if (uidState == null || uidState.pkgOps == null) {\n                        return;\n                    }\n\n                    Ops ops = uidState.pkgOps.get(pkgName);\n                    if (ops == null) {\n                        return;\n                    }\n\n                    // Reset cached package properties to re-initialize when needed\n                    ops.bypass = null;\n                    ops.knownAttributionTags.clear();\n\n                    // Merge data collected for removed attributions into their successor\n                    // attributions\n                    int numOps = ops.size();\n                    for (int opNum = 0; opNum < numOps; opNum++) {\n                        Op op = ops.valueAt(opNum);\n\n                        int numAttributions = op.mAttributions.size();\n                        for (int attributionNum = numAttributions - 1; attributionNum >= 0;\n                                attributionNum--) {\n                            String attributionTag = op.mAttributions.keyAt(attributionNum);\n\n                            if (attributionTags.contains(attributionTag)) {\n                                // attribution still exist after upgrade\n                                continue;\n                            }\n\n                            String newAttributionTag = dstAttributionTags.get(attributionTag);\n\n                            AttributedOp newAttributedOp = op.getOrCreateAttribution(op,\n                                    newAttributionTag);\n                            newAttributedOp.add(op.mAttributions.valueAt(attributionNum));\n                            op.mAttributions.removeAt(attributionNum);\n\n                            scheduleFastWriteLocked();\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    public void systemReady() {\n        mConstants.startMonitoring(mContext.getContentResolver());\n        mHistoricalRegistry.systemReady(mContext.getContentResolver());\n\n        IntentFilter packageUpdateFilter = new IntentFilter();\n        packageUpdateFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);\n        packageUpdateFilter.addAction(Intent.ACTION_PACKAGE_REPLACED);\n        packageUpdateFilter.addDataScheme(\"package\");\n\n        mContext.registerReceiverAsUser(mOnPackageUpdatedReceiver, UserHandle.ALL,\n                packageUpdateFilter, null, null);\n\n        synchronized (this) {\n            for (int uidNum = mUidStates.size() - 1; uidNum >= 0; uidNum--) {\n                int uid = mUidStates.keyAt(uidNum);\n                UidState uidState = mUidStates.valueAt(uidNum);\n\n                String[] pkgsInUid = getPackagesForUid(uidState.uid);\n                if (ArrayUtils.isEmpty(pkgsInUid)) {\n                    uidState.clear();\n                    mUidStates.removeAt(uidNum);\n                    scheduleFastWriteLocked();\n                    continue;\n                }\n\n                ArrayMap<String, Ops> pkgs = uidState.pkgOps;\n                if (pkgs == null) {\n                    continue;\n                }\n\n                int numPkgs = pkgs.size();\n                for (int pkgNum = 0; pkgNum < numPkgs; pkgNum++) {\n                    String pkg = pkgs.keyAt(pkgNum);\n\n                    String action;\n                    if (!ArrayUtils.contains(pkgsInUid, pkg)) {\n                        action = Intent.ACTION_PACKAGE_REMOVED;\n                    } else {\n                        action = Intent.ACTION_PACKAGE_REPLACED;\n                    }\n\n                    SystemServerInitThreadPool.submit(\n                            () -> mOnPackageUpdatedReceiver.onReceive(mContext, new Intent(action)\n                                    .setData(Uri.fromParts(\"package\", pkg, null))\n                                    .putExtra(Intent.EXTRA_UID, uid)),\n                            \"Update app-ops uidState in case package \" + pkg + \" changed\");\n                }\n            }\n        }\n\n        final IntentFilter packageSuspendFilter = new IntentFilter();\n        packageSuspendFilter.addAction(Intent.ACTION_PACKAGES_UNSUSPENDED);\n        packageSuspendFilter.addAction(Intent.ACTION_PACKAGES_SUSPENDED);\n        mContext.registerReceiverAsUser(new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                final int[] changedUids = intent.getIntArrayExtra(Intent.EXTRA_CHANGED_UID_LIST);\n                final String[] changedPkgs = intent.getStringArrayExtra(\n                        Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                for (int code : OPS_RESTRICTED_ON_SUSPEND) {\n                    ArraySet<ModeCallback> callbacks;\n                    synchronized (AppOpsService.this) {\n                        callbacks = mOpModeWatchers.get(code);\n                        if (callbacks == null) {\n                            continue;\n                        }\n                        callbacks = new ArraySet<>(callbacks);\n                    }\n                    for (int i = 0; i < changedUids.length; i++) {\n                        final int changedUid = changedUids[i];\n                        final String changedPkg = changedPkgs[i];\n                        // We trust packagemanager to insert matching uid and packageNames in the\n                        // extras\n                        notifyOpChanged(callbacks, code, changedUid, changedPkg);\n                    }\n                }\n            }\n        }, UserHandle.ALL, packageSuspendFilter, null, null);\n\n        final IntentFilter packageAddedFilter = new IntentFilter();\n        packageAddedFilter.addAction(Intent.ACTION_PACKAGE_ADDED);\n        packageAddedFilter.addDataScheme(\"package\");\n        mContext.registerReceiver(new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                final Uri data = intent.getData();\n\n                final String packageName = data.getSchemeSpecificPart();\n                PackageInfo pi = getPackageManagerInternal().getPackageInfo(packageName,\n                        PackageManager.GET_PERMISSIONS, Process.myUid(), mContext.getUserId());\n                if (isSamplingTarget(pi)) {\n                    synchronized (this) {\n                        mRarelyUsedPackages.add(packageName);\n                    }\n                }\n            }\n        }, packageAddedFilter);\n\n        mHandler.postDelayed(new Runnable() {\n            @Override\n            public void run() {\n                List<String> packageNames = getPackageListAndResample();\n                initializeRarelyUsedPackagesList(new ArraySet<>(packageNames));\n            }\n        }, RARELY_USED_PACKAGES_INITIALIZATION_DELAY_MILLIS);\n\n        getPackageManagerInternal().setExternalSourcesPolicy(\n                new PackageManagerInternal.ExternalSourcesPolicy() {\n                    @Override\n                    public int getPackageTrustedToInstallApps(String packageName, int uid) {\n                        int appOpMode = checkOperation(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                                uid, packageName);\n                        switch (appOpMode) {\n                            case AppOpsManager.MODE_ALLOWED:\n                                return PackageManagerInternal.ExternalSourcesPolicy.USER_TRUSTED;\n                            case AppOpsManager.MODE_ERRORED:\n                                return PackageManagerInternal.ExternalSourcesPolicy.USER_BLOCKED;\n                            default:\n                                return PackageManagerInternal.ExternalSourcesPolicy.USER_DEFAULT;\n                        }\n                    }\n                });\n\n        mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);\n    }\n\n    /**\n     * Sets a policy for handling app ops.\n     *\n     * @param policy The policy.\n     */\n    public void setAppOpsPolicy(@Nullable CheckOpsDelegate policy) {\n        final CheckOpsDelegateDispatcher oldDispatcher = mCheckOpsDelegateDispatcher;\n        final CheckOpsDelegate delegate = (oldDispatcher != null)\n                ? oldDispatcher.mCheckOpsDelegate : null;\n        mCheckOpsDelegateDispatcher = new CheckOpsDelegateDispatcher(policy, delegate);\n    }\n\n    public void packageRemoved(int uid, String packageName) {\n        synchronized (this) {\n            UidState uidState = mUidStates.get(uid);\n            if (uidState == null) {\n                return;\n            }\n\n            Ops ops = null;\n\n            // Remove any package state if such.\n            if (uidState.pkgOps != null) {\n                ops = uidState.pkgOps.remove(packageName);\n            }\n\n            // If we just nuked the last package state check if the UID is valid.\n            if (ops != null && uidState.pkgOps.isEmpty()\n                    && getPackagesForUid(uid).length <= 0) {\n                mUidStates.remove(uid);\n            }\n\n            if (ops != null) {\n                scheduleFastWriteLocked();\n\n                final int numOps = ops.size();\n                for (int opNum = 0; opNum < numOps; opNum++) {\n                    final Op op = ops.valueAt(opNum);\n\n                    final int numAttributions = op.mAttributions.size();\n                    for (int attributionNum = 0; attributionNum < numAttributions;\n                            attributionNum++) {\n                        AttributedOp attributedOp = op.mAttributions.valueAt(attributionNum);\n\n                        while (attributedOp.isRunning()) {\n                            attributedOp.finished(attributedOp.mInProgressEvents.keyAt(0));\n                        }\n                        while (attributedOp.isPaused()) {\n                            attributedOp.finished(attributedOp.mPausedInProgressEvents.keyAt(0));\n                        }\n                    }\n                }\n            }\n        }\n\n        mHandler.post(PooledLambda.obtainRunnable(HistoricalRegistry::clearHistory,\n                    mHistoricalRegistry, uid, packageName));\n    }\n\n    public void uidRemoved(int uid) {\n        synchronized (this) {\n            if (mUidStates.indexOfKey(uid) >= 0) {\n                mUidStates.remove(uid);\n                scheduleFastWriteLocked();\n            }\n        }\n    }\n\n    /**\n     * Update the pending state for the uid\n     *\n     * @param currentTime The current elapsed real time\n     * @param uid The uid that has a pending state\n     */\n    private void updatePendingState(long currentTime, int uid) {\n        synchronized (this) {\n            mLastRealtime = max(currentTime, mLastRealtime);\n            updatePendingStateIfNeededLocked(mUidStates.get(uid));\n        }\n    }\n\n    public void updateUidProcState(int uid, int procState,\n            @ActivityManager.ProcessCapability int capability) {\n        synchronized (this) {\n            final UidState uidState = getUidStateLocked(uid, true);\n            final int newState = PROCESS_STATE_TO_UID_STATE[procState];\n            if (uidState != null && (uidState.pendingState != newState\n                    || uidState.pendingCapability != capability)) {\n                final int oldPendingState = uidState.pendingState;\n                uidState.pendingState = newState;\n                uidState.pendingCapability = capability;\n                if (newState < uidState.state\n                        || (newState <= UID_STATE_MAX_LAST_NON_RESTRICTED\n                                && uidState.state > UID_STATE_MAX_LAST_NON_RESTRICTED)) {\n                    // We are moving to a more important state, or the new state may be in the\n                    // foreground and the old state is in the background, then always do it\n                    // immediately.\n                    commitUidPendingStateLocked(uidState);\n                } else if (newState == uidState.state && capability != uidState.capability) {\n                    // No change on process state, but process capability has changed.\n                    commitUidPendingStateLocked(uidState);\n                } else if (uidState.pendingStateCommitTime == 0) {\n                    // We are moving to a less important state for the first time,\n                    // delay the application for a bit.\n                    final long settleTime;\n                    if (uidState.state <= UID_STATE_TOP) {\n                        settleTime = mConstants.TOP_STATE_SETTLE_TIME;\n                    } else if (uidState.state <= UID_STATE_FOREGROUND_SERVICE) {\n                        settleTime = mConstants.FG_SERVICE_STATE_SETTLE_TIME;\n                    } else {\n                        settleTime = mConstants.BG_STATE_SETTLE_TIME;\n                    }\n                    final long commitTime = SystemClock.elapsedRealtime() + settleTime;\n                    uidState.pendingStateCommitTime = commitTime;\n\n                    mHandler.sendMessageDelayed(\n                            PooledLambda.obtainMessage(AppOpsService::updatePendingState, this,\n                                    commitTime + 1, uid), settleTime + 1);\n                }\n\n                if (uidState.pkgOps != null) {\n                    int numPkgs = uidState.pkgOps.size();\n                    for (int pkgNum = 0; pkgNum < numPkgs; pkgNum++) {\n                        Ops ops = uidState.pkgOps.valueAt(pkgNum);\n\n                        int numOps = ops.size();\n                        for (int opNum = 0; opNum < numOps; opNum++) {\n                            Op op = ops.valueAt(opNum);\n\n                            int numAttributions = op.mAttributions.size();\n                            for (int attributionNum = 0; attributionNum < numAttributions;\n                                    attributionNum++) {\n                                AttributedOp attributedOp = op.mAttributions.valueAt(\n                                        attributionNum);\n\n                                attributedOp.onUidStateChanged(newState);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    public void shutdown() {\n        Slog.w(TAG, \"Writing app ops before shutdown...\");\n        boolean doWrite = false;\n        synchronized (this) {\n            if (mWriteScheduled) {\n                mWriteScheduled = false;\n                mFastWriteScheduled = false;\n                mHandler.removeCallbacks(mWriteRunner);\n                doWrite = true;\n            }\n        }\n        if (doWrite) {\n            writeState();\n        }\n        if (AppOpsManager.NOTE_OP_COLLECTION_ENABLED && mWriteNoteOpsScheduled) {\n            writeNoteOps();\n        }\n\n        mHistoricalRegistry.shutdown();\n    }\n\n    private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops) {\n        ArrayList<AppOpsManager.OpEntry> resOps = null;\n        final long elapsedNow = SystemClock.elapsedRealtime();\n        if (ops == null) {\n            resOps = new ArrayList<>();\n            for (int j=0; j<pkgOps.size(); j++) {\n                Op curOp = pkgOps.valueAt(j);\n                resOps.add(getOpEntryForResult(curOp, elapsedNow));\n            }\n        } else {\n            for (int j=0; j<ops.length; j++) {\n                Op curOp = pkgOps.get(ops[j]);\n                if (curOp != null) {\n                    if (resOps == null) {\n                        resOps = new ArrayList<>();\n                    }\n                    resOps.add(getOpEntryForResult(curOp, elapsedNow));\n                }\n            }\n        }\n        return resOps;\n    }\n\n    @Nullable\n    private ArrayList<AppOpsManager.OpEntry> collectUidOps(@NonNull UidState uidState,\n            @Nullable int[] ops) {\n        if (uidState.opModes == null) {\n            return null;\n        }\n\n        int opModeCount = uidState.opModes.size();\n        if (opModeCount == 0) {\n            return null;\n        }\n        ArrayList<AppOpsManager.OpEntry> resOps = null;\n        if (ops == null) {\n            resOps = new ArrayList<>();\n            for (int i = 0; i < opModeCount; i++) {\n                int code = uidState.opModes.keyAt(i);\n                resOps.add(new OpEntry(code, uidState.opModes.get(code), Collections.emptyMap()));\n            }\n        } else {\n            for (int j=0; j<ops.length; j++) {\n                int code = ops[j];\n                if (uidState.opModes.indexOfKey(code) >= 0) {\n                    if (resOps == null) {\n                        resOps = new ArrayList<>();\n                    }\n                    resOps.add(new OpEntry(code, uidState.opModes.get(code),\n                            Collections.emptyMap()));\n                }\n            }\n        }\n        return resOps;\n    }\n\n    private static @NonNull OpEntry getOpEntryForResult(@NonNull Op op, long elapsedNow) {\n        return op.createEntryLocked();\n    }\n\n    @Override\n    public List<AppOpsManager.PackageOps> getPackagesForOps(int[] ops) {\n        final int callingUid = Binder.getCallingUid();\n        final boolean hasAllPackageAccess = mContext.checkPermission(\n                Manifest.permission.GET_APP_OPS_STATS, Binder.getCallingPid(),\n                Binder.getCallingUid(), null) == PackageManager.PERMISSION_GRANTED;\n        ArrayList<AppOpsManager.PackageOps> res = null;\n        synchronized (this) {\n            final int uidStateCount = mUidStates.size();\n            for (int i = 0; i < uidStateCount; i++) {\n                UidState uidState = mUidStates.valueAt(i);\n                if (uidState.pkgOps == null || uidState.pkgOps.isEmpty()) {\n                    continue;\n                }\n                ArrayMap<String, Ops> packages = uidState.pkgOps;\n                final int packageCount = packages.size();\n                for (int j = 0; j < packageCount; j++) {\n                    Ops pkgOps = packages.valueAt(j);\n                    ArrayList<AppOpsManager.OpEntry> resOps = collectOps(pkgOps, ops);\n                    if (resOps != null) {\n                        if (res == null) {\n                            res = new ArrayList<>();\n                        }\n                        AppOpsManager.PackageOps resPackage = new AppOpsManager.PackageOps(\n                                pkgOps.packageName, pkgOps.uidState.uid, resOps);\n                        // Caller can always see their packages and with a permission all.\n                        if (hasAllPackageAccess || callingUid == pkgOps.uidState.uid) {\n                            res.add(resPackage);\n                        }\n                    }\n                }\n            }\n        }\n        return res;\n    }\n\n    @Override\n    public List<AppOpsManager.PackageOps> getOpsForPackage(int uid, String packageName,\n            int[] ops) {\n        enforceGetAppOpsStatsPermissionIfNeeded(uid,packageName);\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return Collections.emptyList();\n        }\n        synchronized (this) {\n            Ops pkgOps = getOpsLocked(uid, resolvedPackageName, null, false, null,\n                    /* edit */ false);\n            if (pkgOps == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.OpEntry> resOps = collectOps(pkgOps, ops);\n            if (resOps == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.PackageOps> res = new ArrayList<AppOpsManager.PackageOps>();\n            AppOpsManager.PackageOps resPackage = new AppOpsManager.PackageOps(\n                    pkgOps.packageName, pkgOps.uidState.uid, resOps);\n            res.add(resPackage);\n            return res;\n        }\n    }\n\n    private void enforceGetAppOpsStatsPermissionIfNeeded(int uid, String packageName) {\n        final int callingUid = Binder.getCallingUid();\n        // We get to access everything\n        if (callingUid == Process.myPid()) {\n            return;\n        }\n        // Apps can access their own data\n        if (uid == callingUid && packageName != null\n                && checkPackage(uid, packageName) == MODE_ALLOWED) {\n            return;\n        }\n        // Otherwise, you need a permission...\n        mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS,\n                Binder.getCallingPid(), callingUid, null);\n    }\n\n    /**\n     * Verify that historical appop request arguments are valid.\n     */\n    private void ensureHistoricalOpRequestIsValid(int uid, String packageName,\n            String attributionTag, List<String> opNames, int filter, long beginTimeMillis,\n            long endTimeMillis, int flags) {\n        if ((filter & FILTER_BY_UID) != 0) {\n            Preconditions.checkArgument(uid != Process.INVALID_UID);\n        } else {\n            Preconditions.checkArgument(uid == Process.INVALID_UID);\n        }\n\n        if ((filter & FILTER_BY_PACKAGE_NAME) != 0) {\n            Objects.requireNonNull(packageName);\n        } else {\n            Preconditions.checkArgument(packageName == null);\n        }\n\n        if ((filter & FILTER_BY_ATTRIBUTION_TAG) == 0) {\n            Preconditions.checkArgument(attributionTag == null);\n        }\n\n        if ((filter & FILTER_BY_OP_NAMES) != 0) {\n            Objects.requireNonNull(opNames);\n        } else {\n            Preconditions.checkArgument(opNames == null);\n        }\n\n        Preconditions.checkFlagsArgument(filter,\n                FILTER_BY_UID | FILTER_BY_PACKAGE_NAME | FILTER_BY_ATTRIBUTION_TAG\n                        | FILTER_BY_OP_NAMES);\n        Preconditions.checkArgumentNonnegative(beginTimeMillis);\n        Preconditions.checkArgument(endTimeMillis > beginTimeMillis);\n        Preconditions.checkFlagsArgument(flags, OP_FLAGS_ALL);\n    }\n\n    @Override\n    public void getHistoricalOps(int uid, String packageName, String attributionTag,\n            List<String> opNames, int dataType, int filter, long beginTimeMillis,\n            long endTimeMillis, int flags, RemoteCallback callback) {\n        PackageManager pm = mContext.getPackageManager();\n\n        ensureHistoricalOpRequestIsValid(uid, packageName, attributionTag, opNames, filter,\n                beginTimeMillis, endTimeMillis, flags);\n        Objects.requireNonNull(callback, \"callback cannot be null\");\n        ActivityManagerInternal ami = LocalServices.getService(ActivityManagerInternal.class);\n        boolean isSelfRequest = (filter & FILTER_BY_UID) != 0 && uid == Binder.getCallingUid();\n        if (!isSelfRequest) {\n            boolean isCallerInstrumented =\n                    ami.getInstrumentationSourceUid(Binder.getCallingUid()) != Process.INVALID_UID;\n            boolean isCallerSystem = Binder.getCallingPid() == Process.myPid();\n            boolean isCallerPermissionController;\n            try {\n                isCallerPermissionController = pm.getPackageUidAsUser(\n                        mContext.getPackageManager().getPermissionControllerPackageName(), 0,\n                        UserHandle.getUserId(Binder.getCallingUid()))\n                        == Binder.getCallingUid();\n            } catch (PackageManager.NameNotFoundException doesNotHappen) {\n                return;\n            }\n\n            boolean doesCallerHavePermission = mContext.checkPermission(\n                    android.Manifest.permission.GET_HISTORICAL_APP_OPS_STATS,\n                    Binder.getCallingPid(), Binder.getCallingUid())\n                    == PackageManager.PERMISSION_GRANTED;\n\n            if (!isCallerSystem && !isCallerInstrumented && !isCallerPermissionController\n                    && !doesCallerHavePermission) {\n                mHandler.post(() -> callback.sendResult(new Bundle()));\n                return;\n            }\n\n            mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS,\n                    Binder.getCallingPid(), Binder.getCallingUid(), \"getHistoricalOps\");\n        }\n\n        final String[] opNamesArray = (opNames != null)\n                ? opNames.toArray(new String[opNames.size()]) : null;\n\n        Set<String> attributionChainExemptPackages = null;\n        if ((dataType & HISTORY_FLAG_GET_ATTRIBUTION_CHAINS) != 0) {\n            attributionChainExemptPackages =\n                    PermissionManager.getIndicatorExemptedPackages(mContext);\n        }\n\n        final String[] chainExemptPkgArray = attributionChainExemptPackages != null\n                ? attributionChainExemptPackages.toArray(\n                        new String[attributionChainExemptPackages.size()]) : null;\n\n        // Must not hold the appops lock\n        mHandler.post(PooledLambda.obtainRunnable(HistoricalRegistry::getHistoricalOps,\n                mHistoricalRegistry, uid, packageName, attributionTag, opNamesArray, dataType,\n                filter, beginTimeMillis, endTimeMillis, flags, chainExemptPkgArray,\n                callback).recycleOnUse());\n    }\n\n    @Override\n    public void getHistoricalOpsFromDiskRaw(int uid, String packageName, String attributionTag,\n            List<String> opNames, int dataType, int filter, long beginTimeMillis,\n            long endTimeMillis, int flags, RemoteCallback callback) {\n        ensureHistoricalOpRequestIsValid(uid, packageName, attributionTag, opNames, filter,\n                beginTimeMillis, endTimeMillis, flags);\n        Objects.requireNonNull(callback, \"callback cannot be null\");\n\n        mContext.enforcePermission(Manifest.permission.MANAGE_APPOPS,\n                Binder.getCallingPid(), Binder.getCallingUid(), \"getHistoricalOps\");\n\n        final String[] opNamesArray = (opNames != null)\n                ? opNames.toArray(new String[opNames.size()]) : null;\n\n        Set<String> attributionChainExemptPackages = null;\n        if ((dataType & HISTORY_FLAG_GET_ATTRIBUTION_CHAINS) != 0) {\n            attributionChainExemptPackages =\n                    PermissionManager.getIndicatorExemptedPackages(mContext);\n        }\n\n        final String[] chainExemptPkgArray = attributionChainExemptPackages != null\n                ? attributionChainExemptPackages.toArray(\n                new String[attributionChainExemptPackages.size()]) : null;\n\n        // Must not hold the appops lock\n        mHandler.post(PooledLambda.obtainRunnable(HistoricalRegistry::getHistoricalOpsFromDiskRaw,\n                mHistoricalRegistry, uid, packageName, attributionTag, opNamesArray, dataType,\n                filter, beginTimeMillis, endTimeMillis, flags, chainExemptPkgArray,\n                callback).recycleOnUse());\n    }\n\n    @Override\n    public void reloadNonHistoricalState() {\n        mContext.enforcePermission(Manifest.permission.MANAGE_APPOPS,\n                Binder.getCallingPid(), Binder.getCallingUid(), \"reloadNonHistoricalState\");\n        writeState();\n        readState();\n    }\n\n    @Override\n    public List<AppOpsManager.PackageOps> getUidOps(int uid, int[] ops) {\n        mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n        synchronized (this) {\n            UidState uidState = getUidStateLocked(uid, false);\n            if (uidState == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.OpEntry> resOps = collectUidOps(uidState, ops);\n            if (resOps == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.PackageOps> res = new ArrayList<AppOpsManager.PackageOps>();\n            AppOpsManager.PackageOps resPackage = new AppOpsManager.PackageOps(\n                    null, uidState.uid, resOps);\n            res.add(resPackage);\n            return res;\n        }\n    }\n\n    private void pruneOpLocked(Op op, int uid, String packageName) {\n        op.removeAttributionsWithNoTime();\n\n        if (op.mAttributions.isEmpty()) {\n            Ops ops = getOpsLocked(uid, packageName, null, false, null, /* edit */ false);\n            if (ops != null) {\n                ops.remove(op.op);\n                if (ops.size() <= 0) {\n                    UidState uidState = ops.uidState;\n                    ArrayMap<String, Ops> pkgOps = uidState.pkgOps;\n                    if (pkgOps != null) {\n                        pkgOps.remove(ops.packageName);\n                        if (pkgOps.isEmpty()) {\n                            uidState.pkgOps = null;\n                        }\n                        if (uidState.isDefault()) {\n                            mUidStates.remove(uid);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    private void enforceManageAppOpsModes(int callingPid, int callingUid, int targetUid) {\n        if (callingPid == Process.myPid()) {\n            return;\n        }\n        final int callingUser = UserHandle.getUserId(callingUid);\n        synchronized (this) {\n            if (mProfileOwners != null && mProfileOwners.get(callingUser, -1) == callingUid) {\n                if (targetUid >= 0 && callingUser == UserHandle.getUserId(targetUid)) {\n                    // Profile owners are allowed to change modes but only for apps\n                    // within their user.\n                    return;\n                }\n            }\n        }\n        mContext.enforcePermission(android.Manifest.permission.MANAGE_APP_OPS_MODES,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n    }\n\n    @Override\n    public void setUidMode(int code, int uid, int mode) {\n        setUidMode(code, uid, mode, null);\n    }\n\n    private void setUidMode(int code, int uid, int mode,\n            @Nullable IAppOpsCallback permissionPolicyCallback) {\n        if (DEBUG) {\n            Slog.i(TAG, \"uid \" + uid + \" OP_\" + opToName(code) + \" := \" + modeToName(mode)\n                    + \" by uid \" + Binder.getCallingUid());\n        }\n\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), uid);\n        verifyIncomingOp(code);\n        code = AppOpsManager.opToSwitch(code);\n\n        if (permissionPolicyCallback == null) {\n            updatePermissionRevokedCompat(uid, code, mode);\n        }\n\n        int previousMode;\n        synchronized (this) {\n            final int defaultMode = AppOpsManager.opToDefaultMode(code);\n\n            UidState uidState = getUidStateLocked(uid, false);\n            if (uidState == null) {\n                if (mode == defaultMode) {\n                    return;\n                }\n                previousMode = MODE_DEFAULT;\n                uidState = new UidState(uid);\n                uidState.opModes = new SparseIntArray();\n                uidState.opModes.put(code, mode);\n                mUidStates.put(uid, uidState);\n                scheduleWriteLocked();\n            } else if (uidState.opModes == null) {\n                previousMode = MODE_DEFAULT;\n                if (mode != defaultMode) {\n                    uidState.opModes = new SparseIntArray();\n                    uidState.opModes.put(code, mode);\n                    scheduleWriteLocked();\n                }\n            } else {\n                if (uidState.opModes.indexOfKey(code) >= 0 && uidState.opModes.get(code) == mode) {\n                    return;\n                }\n                previousMode = uidState.opModes.get(code);\n                if (mode == defaultMode) {\n                    uidState.opModes.delete(code);\n                    if (uidState.opModes.size() <= 0) {\n                        uidState.opModes = null;\n                    }\n                } else {\n                    uidState.opModes.put(code, mode);\n                }\n                scheduleWriteLocked();\n            }\n            uidState.evalForegroundOps(mOpModeWatchers);\n            if (mode != MODE_ERRORED && mode != previousMode) {\n                updateStartedOpModeForUidLocked(code, mode == MODE_IGNORED, uid);\n            }\n        }\n\n        notifyOpChangedForAllPkgsInUid(code, uid, false, permissionPolicyCallback);\n        notifyOpChangedSync(code, uid, null, mode, previousMode);\n    }\n\n    /**\n     * Notify that an op changed for all packages in an uid.\n     *\n     * @param code The op that changed\n     * @param uid The uid the op was changed for\n     * @param onlyForeground Only notify watchers that watch for foreground changes\n     */\n    private void notifyOpChangedForAllPkgsInUid(int code, int uid, boolean onlyForeground,\n            @Nullable IAppOpsCallback callbackToIgnore) {\n        String[] uidPackageNames = getPackagesForUid(uid);\n        ArrayMap<ModeCallback, ArraySet<String>> callbackSpecs = null;\n\n        synchronized (this) {\n            ArraySet<ModeCallback> callbacks = mOpModeWatchers.get(code);\n            if (callbacks != null) {\n                final int callbackCount = callbacks.size();\n                for (int i = 0; i < callbackCount; i++) {\n                    ModeCallback callback = callbacks.valueAt(i);\n                    if (onlyForeground && (callback.mFlags & WATCH_FOREGROUND_CHANGES) == 0) {\n                        continue;\n                    }\n\n                    ArraySet<String> changedPackages = new ArraySet<>();\n                    Collections.addAll(changedPackages, uidPackageNames);\n                    if (callbackSpecs == null) {\n                        callbackSpecs = new ArrayMap<>();\n                    }\n                    callbackSpecs.put(callback, changedPackages);\n                }\n            }\n\n            for (String uidPackageName : uidPackageNames) {\n                callbacks = mPackageModeWatchers.get(uidPackageName);\n                if (callbacks != null) {\n                    if (callbackSpecs == null) {\n                        callbackSpecs = new ArrayMap<>();\n                    }\n                    final int callbackCount = callbacks.size();\n                    for (int i = 0; i < callbackCount; i++) {\n                        ModeCallback callback = callbacks.valueAt(i);\n                        if (onlyForeground && (callback.mFlags & WATCH_FOREGROUND_CHANGES) == 0) {\n                            continue;\n                        }\n\n                        ArraySet<String> changedPackages = callbackSpecs.get(callback);\n                        if (changedPackages == null) {\n                            changedPackages = new ArraySet<>();\n                            callbackSpecs.put(callback, changedPackages);\n                        }\n                        changedPackages.add(uidPackageName);\n                    }\n                }\n            }\n\n            if (callbackSpecs != null && callbackToIgnore != null) {\n                callbackSpecs.remove(mModeWatchers.get(callbackToIgnore.asBinder()));\n            }\n        }\n\n        if (callbackSpecs == null) {\n            return;\n        }\n\n        for (int i = 0; i < callbackSpecs.size(); i++) {\n            final ModeCallback callback = callbackSpecs.keyAt(i);\n            final ArraySet<String> reportedPackageNames = callbackSpecs.valueAt(i);\n            if (reportedPackageNames == null) {\n                mHandler.sendMessage(PooledLambda.obtainMessage(\n                        AppOpsService::notifyOpChanged,\n                        this, callback, code, uid, (String) null));\n\n            } else {\n                final int reportedPackageCount = reportedPackageNames.size();\n                for (int j = 0; j < reportedPackageCount; j++) {\n                    final String reportedPackageName = reportedPackageNames.valueAt(j);\n                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                            AppOpsService::notifyOpChanged,\n                            this, callback, code, uid, reportedPackageName));\n                }\n            }\n        }\n    }\n\n    private void updatePermissionRevokedCompat(int uid, int switchCode, int mode) {\n        PackageManager packageManager = mContext.getPackageManager();\n        if (packageManager == null) {\n            // This can only happen during early boot. At this time the permission state and appop\n            // state are in sync\n            return;\n        }\n\n        String[] packageNames = packageManager.getPackagesForUid(uid);\n        if (ArrayUtils.isEmpty(packageNames)) {\n            return;\n        }\n        String packageName = packageNames[0];\n\n        int[] ops = mSwitchedOps.get(switchCode);\n        for (int code : ops) {\n            String permissionName = AppOpsManager.opToPermission(code);\n            if (permissionName == null) {\n                continue;\n            }\n\n            if (packageManager.checkPermission(permissionName, packageName)\n                    != PackageManager.PERMISSION_GRANTED) {\n                continue;\n            }\n\n            PermissionInfo permissionInfo;\n            try {\n                permissionInfo = packageManager.getPermissionInfo(permissionName, 0);\n            } catch (PackageManager.NameNotFoundException e) {\n                e.printStackTrace();\n                continue;\n            }\n\n            if (!permissionInfo.isRuntime()) {\n                continue;\n            }\n\n            boolean supportsRuntimePermissions = getPackageManagerInternal()\n                    .getUidTargetSdkVersion(uid) >= Build.VERSION_CODES.M;\n\n            UserHandle user = UserHandle.getUserHandleForUid(uid);\n            boolean isRevokedCompat;\n            if (permissionInfo.backgroundPermission != null) {\n                if (packageManager.checkPermission(permissionInfo.backgroundPermission, packageName)\n                        == PackageManager.PERMISSION_GRANTED) {\n                    boolean isBackgroundRevokedCompat = mode != AppOpsManager.MODE_ALLOWED;\n\n                    if (isBackgroundRevokedCompat && supportsRuntimePermissions) {\n                        Slog.w(TAG, \"setUidMode() called with a mode inconsistent with runtime\"\n                                + \" permission state, this is discouraged and you should revoke the\"\n                                + \" runtime permission instead: uid=\" + uid + \", switchCode=\"\n                                + switchCode + \", mode=\" + mode + \", permission=\"\n                                + permissionInfo.backgroundPermission);\n                    }\n\n                    final long identity = Binder.clearCallingIdentity();\n                    try {\n                        packageManager.updatePermissionFlags(permissionInfo.backgroundPermission,\n                                packageName, PackageManager.FLAG_PERMISSION_REVOKED_COMPAT,\n                                isBackgroundRevokedCompat\n                                        ? PackageManager.FLAG_PERMISSION_REVOKED_COMPAT : 0, user);\n                    } finally {\n                        Binder.restoreCallingIdentity(identity);\n                    }\n                }\n\n                isRevokedCompat = mode != AppOpsManager.MODE_ALLOWED\n                        && mode != AppOpsManager.MODE_FOREGROUND;\n            } else {\n                isRevokedCompat = mode != AppOpsManager.MODE_ALLOWED;\n            }\n\n            if (isRevokedCompat && supportsRuntimePermissions) {\n                Slog.w(TAG, \"setUidMode() called with a mode inconsistent with runtime\"\n                        + \" permission state, this is discouraged and you should revoke the\"\n                        + \" runtime permission instead: uid=\" + uid + \", switchCode=\"\n                        + switchCode + \", mode=\" + mode + \", permission=\" + permissionName);\n            }\n\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                packageManager.updatePermissionFlags(permissionName, packageName,\n                        PackageManager.FLAG_PERMISSION_REVOKED_COMPAT, isRevokedCompat\n                                ? PackageManager.FLAG_PERMISSION_REVOKED_COMPAT : 0, user);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n    }\n\n    private void notifyOpChangedSync(int code, int uid, @NonNull String packageName, int mode,\n            int previousMode) {\n        final StorageManagerInternal storageManagerInternal =\n                LocalServices.getService(StorageManagerInternal.class);\n        if (storageManagerInternal != null) {\n            storageManagerInternal.onAppOpsChanged(code, uid, packageName, mode, previousMode);\n        }\n    }\n\n    /**\n     * Sets the mode for a certain op and uid.\n     *\n     * @param code The op code to set\n     * @param uid The UID for which to set\n     * @param packageName The package for which to set\n     * @param mode The new mode to set\n     */\n    @Override\n    public void setMode(int code, int uid, @NonNull String packageName, int mode) {\n        setMode(code, uid, packageName, mode, null);\n    }\n\n    private void setMode(int code, int uid, @NonNull String packageName, int mode,\n            @Nullable IAppOpsCallback permissionPolicyCallback) {\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), uid);\n        verifyIncomingOp(code);\n        verifyIncomingPackage(packageName, UserHandle.getUserId(uid));\n\n        ArraySet<ModeCallback> repCbs = null;\n        code = AppOpsManager.opToSwitch(code);\n\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, null);\n        } catch (SecurityException e) {\n            Slog.e(TAG, \"Cannot setMode\", e);\n            return;\n        }\n\n        int previousMode = MODE_DEFAULT;\n        synchronized (this) {\n            UidState uidState = getUidStateLocked(uid, false);\n            Op op = getOpLocked(code, uid, packageName, null, false, pvr.bypass, /* edit */ true);\n            if (op != null) {\n                if (op.mode != mode) {\n                    previousMode = op.mode;\n                    op.mode = mode;\n                    if (uidState != null) {\n                        uidState.evalForegroundOps(mOpModeWatchers);\n                    }\n                    ArraySet<ModeCallback> cbs = mOpModeWatchers.get(code);\n                    if (cbs != null) {\n                        if (repCbs == null) {\n                            repCbs = new ArraySet<>();\n                        }\n                        repCbs.addAll(cbs);\n                    }\n                    cbs = mPackageModeWatchers.get(packageName);\n                    if (cbs != null) {\n                        if (repCbs == null) {\n                            repCbs = new ArraySet<>();\n                        }\n                        repCbs.addAll(cbs);\n                    }\n                    if (repCbs != null && permissionPolicyCallback != null) {\n                        repCbs.remove(mModeWatchers.get(permissionPolicyCallback.asBinder()));\n                    }\n                    if (mode == AppOpsManager.opToDefaultMode(op.op)) {\n                        // If going into the default mode, prune this op\n                        // if there is nothing else interesting in it.\n                        pruneOpLocked(op, uid, packageName);\n                    }\n                    scheduleFastWriteLocked();\n                    if (mode != MODE_ERRORED) {\n                        updateStartedOpModeForUidLocked(code, mode == MODE_IGNORED, uid);\n                    }\n                }\n            }\n        }\n        if (repCbs != null) {\n            mHandler.sendMessage(PooledLambda.obtainMessage(\n                    AppOpsService::notifyOpChanged,\n                    this, repCbs, code, uid, packageName));\n        }\n\n        notifyOpChangedSync(code, uid, packageName, mode, previousMode);\n    }\n\n    private void notifyOpChanged(ArraySet<ModeCallback> callbacks, int code,\n            int uid, String packageName) {\n        for (int i = 0; i < callbacks.size(); i++) {\n            final ModeCallback callback = callbacks.valueAt(i);\n            notifyOpChanged(callback, code, uid, packageName);\n        }\n    }\n\n    private void notifyOpChanged(ModeCallback callback, int code,\n            int uid, String packageName) {\n        if (uid != UID_ANY && callback.mWatchingUid >= 0 && callback.mWatchingUid != uid) {\n            return;\n        }\n\n        // See CALL_BACK_ON_CHANGED_LISTENER_WITH_SWITCHED_OP_CHANGE\n        int[] switchedCodes;\n        if (callback.mWatchedOpCode == ALL_OPS) {\n            switchedCodes = mSwitchedOps.get(code);\n        } else if (callback.mWatchedOpCode == OP_NONE) {\n            switchedCodes = new int[]{code};\n        } else {\n            switchedCodes = new int[]{callback.mWatchedOpCode};\n        }\n\n        for (int switchedCode : switchedCodes) {\n            // There are features watching for mode changes such as window manager\n            // and location manager which are in our process. The callbacks in these\n            // features may require permissions our remote caller does not have.\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                if (shouldIgnoreCallback(switchedCode, callback.mCallingPid,\n                        callback.mCallingUid)) {\n                    continue;\n                }\n                callback.mCallback.opChanged(switchedCode, uid, packageName);\n            } catch (RemoteException e) {\n                /* ignore */\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n    }\n\n    private static ArrayList<ChangeRec> addChange(ArrayList<ChangeRec> reports,\n            int op, int uid, String packageName, int previousMode) {\n        boolean duplicate = false;\n        if (reports == null) {\n            reports = new ArrayList<>();\n        } else {\n            final int reportCount = reports.size();\n            for (int j = 0; j < reportCount; j++) {\n                ChangeRec report = reports.get(j);\n                if (report.op == op && report.pkg.equals(packageName)) {\n                    duplicate = true;\n                    break;\n                }\n            }\n        }\n        if (!duplicate) {\n            reports.add(new ChangeRec(op, uid, packageName, previousMode));\n        }\n\n        return reports;\n    }\n\n    private static HashMap<ModeCallback, ArrayList<ChangeRec>> addCallbacks(\n            HashMap<ModeCallback, ArrayList<ChangeRec>> callbacks,\n            int op, int uid, String packageName, int previousMode, ArraySet<ModeCallback> cbs) {\n        if (cbs == null) {\n            return callbacks;\n        }\n        if (callbacks == null) {\n            callbacks = new HashMap<>();\n        }\n        final int N = cbs.size();\n        for (int i=0; i<N; i++) {\n            ModeCallback cb = cbs.valueAt(i);\n            ArrayList<ChangeRec> reports = callbacks.get(cb);\n            ArrayList<ChangeRec> changed = addChange(reports, op, uid, packageName, previousMode);\n            if (changed != reports) {\n                callbacks.put(cb, changed);\n            }\n        }\n        return callbacks;\n    }\n\n    static final class ChangeRec {\n        final int op;\n        final int uid;\n        final String pkg;\n        final int previous_mode;\n\n        ChangeRec(int _op, int _uid, String _pkg, int _previous_mode) {\n            op = _op;\n            uid = _uid;\n            pkg = _pkg;\n            previous_mode = _previous_mode;\n        }\n    }\n\n    @Override\n    public void resetAllModes(int reqUserId, String reqPackageName) {\n        final int callingPid = Binder.getCallingPid();\n        final int callingUid = Binder.getCallingUid();\n        reqUserId = ActivityManager.handleIncomingUser(callingPid, callingUid, reqUserId,\n                true, true, \"resetAllModes\", null);\n\n        int reqUid = -1;\n        if (reqPackageName != null) {\n            try {\n                reqUid = AppGlobals.getPackageManager().getPackageUid(\n                        reqPackageName, PackageManager.MATCH_UNINSTALLED_PACKAGES, reqUserId);\n            } catch (RemoteException e) {\n                /* ignore - local call */\n            }\n        }\n\n        enforceManageAppOpsModes(callingPid, callingUid, reqUid);\n\n        HashMap<ModeCallback, ArrayList<ChangeRec>> callbacks = null;\n        ArrayList<ChangeRec> allChanges = new ArrayList<>();\n        synchronized (this) {\n            boolean changed = false;\n            for (int i = mUidStates.size() - 1; i >= 0; i--) {\n                UidState uidState = mUidStates.valueAt(i);\n\n                SparseIntArray opModes = uidState.opModes;\n                if (opModes != null && (uidState.uid == reqUid || reqUid == -1)) {\n                    final int uidOpCount = opModes.size();\n                    for (int j = uidOpCount - 1; j >= 0; j--) {\n                        final int code = opModes.keyAt(j);\n                        if (AppOpsManager.opAllowsReset(code)) {\n                            int previousMode = opModes.valueAt(j);\n                            opModes.removeAt(j);\n                            if (opModes.size() <= 0) {\n                                uidState.opModes = null;\n                            }\n                            for (String packageName : getPackagesForUid(uidState.uid)) {\n                                callbacks = addCallbacks(callbacks, code, uidState.uid, packageName,\n                                        previousMode, mOpModeWatchers.get(code));\n                                callbacks = addCallbacks(callbacks, code, uidState.uid, packageName,\n                                        previousMode, mPackageModeWatchers.get(packageName));\n\n                                allChanges = addChange(allChanges, code, uidState.uid,\n                                        packageName, previousMode);\n                            }\n                        }\n                    }\n                }\n\n                if (uidState.pkgOps == null) {\n                    continue;\n                }\n\n                if (reqUserId != UserHandle.USER_ALL\n                        && reqUserId != UserHandle.getUserId(uidState.uid)) {\n                    // Skip any ops for a different user\n                    continue;\n                }\n\n                Map<String, Ops> packages = uidState.pkgOps;\n                Iterator<Map.Entry<String, Ops>> it = packages.entrySet().iterator();\n                boolean uidChanged = false;\n                while (it.hasNext()) {\n                    Map.Entry<String, Ops> ent = it.next();\n                    String packageName = ent.getKey();\n                    if (reqPackageName != null && !reqPackageName.equals(packageName)) {\n                        // Skip any ops for a different package\n                        continue;\n                    }\n                    Ops pkgOps = ent.getValue();\n                    for (int j=pkgOps.size()-1; j>=0; j--) {\n                        Op curOp = pkgOps.valueAt(j);\n                        if (shouldDeferResetOpToDpm(curOp.op)) {\n                            deferResetOpToDpm(curOp.op, reqPackageName, reqUserId);\n                            continue;\n                        }\n                        if (AppOpsManager.opAllowsReset(curOp.op)\n                                && curOp.mode != AppOpsManager.opToDefaultMode(curOp.op)) {\n                            int previousMode = curOp.mode;\n                            curOp.mode = AppOpsManager.opToDefaultMode(curOp.op);\n                            changed = true;\n                            uidChanged = true;\n                            final int uid = curOp.uidState.uid;\n                            callbacks = addCallbacks(callbacks, curOp.op, uid, packageName,\n                                    previousMode, mOpModeWatchers.get(curOp.op));\n                            callbacks = addCallbacks(callbacks, curOp.op, uid, packageName,\n                                    previousMode, mPackageModeWatchers.get(packageName));\n\n                            allChanges = addChange(allChanges, curOp.op, uid, packageName,\n                                    previousMode);\n                            curOp.removeAttributionsWithNoTime();\n                            if (curOp.mAttributions.isEmpty()) {\n                                pkgOps.removeAt(j);\n                            }\n                        }\n                    }\n                    if (pkgOps.size() == 0) {\n                        it.remove();\n                    }\n                }\n                if (uidState.isDefault()) {\n                    mUidStates.remove(uidState.uid);\n                }\n                if (uidChanged) {\n                    uidState.evalForegroundOps(mOpModeWatchers);\n                }\n            }\n\n            if (changed) {\n                scheduleFastWriteLocked();\n            }\n        }\n        if (callbacks != null) {\n            for (Map.Entry<ModeCallback, ArrayList<ChangeRec>> ent : callbacks.entrySet()) {\n                ModeCallback cb = ent.getKey();\n                ArrayList<ChangeRec> reports = ent.getValue();\n                for (int i=0; i<reports.size(); i++) {\n                    ChangeRec rep = reports.get(i);\n                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                            AppOpsService::notifyOpChanged,\n                            this, cb, rep.op, rep.uid, rep.pkg));\n                }\n            }\n        }\n\n        int numChanges = allChanges.size();\n        for (int i = 0; i < numChanges; i++) {\n            ChangeRec change = allChanges.get(i);\n            notifyOpChangedSync(change.op, change.uid, change.pkg,\n                    AppOpsManager.opToDefaultMode(change.op), change.previous_mode);\n        }\n    }\n\n    private boolean shouldDeferResetOpToDpm(int op) {\n        // TODO(b/174582385): avoid special-casing app-op resets by migrating app-op permission\n        //  pre-grants to a role-based mechanism or another general-purpose mechanism.\n        return dpmi != null && dpmi.supportsResetOp(op);\n    }\n\n    /** Assumes {@link #shouldDeferResetOpToDpm(int)} is true. */\n    private void deferResetOpToDpm(int op, String packageName, @UserIdInt int userId) {\n        // TODO(b/174582385): avoid special-casing app-op resets by migrating app-op permission\n        //  pre-grants to a role-based mechanism or another general-purpose mechanism.\n        dpmi.resetOp(op, packageName, userId);\n    }\n\n    private void evalAllForegroundOpsLocked() {\n        for (int uidi = mUidStates.size() - 1; uidi >= 0; uidi--) {\n            final UidState uidState = mUidStates.valueAt(uidi);\n            if (uidState.foregroundOps != null) {\n                uidState.evalForegroundOps(mOpModeWatchers);\n            }\n        }\n    }\n\n    @Override\n    public void startWatchingMode(int op, String packageName, IAppOpsCallback callback) {\n        startWatchingModeWithFlags(op, packageName, 0, callback);\n    }\n\n    @Override\n    public void startWatchingModeWithFlags(int op, String packageName, int flags,\n            IAppOpsCallback callback) {\n        int watchedUid = -1;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        // TODO: should have a privileged permission to protect this.\n        // Also, if the caller has requested WATCH_FOREGROUND_CHANGES, should we require\n        // the USAGE_STATS permission since this can provide information about when an\n        // app is in the foreground?\n        Preconditions.checkArgumentInRange(op, AppOpsManager.OP_NONE,\n                AppOpsManager._NUM_OP - 1, \"Invalid op code: \" + op);\n        if (callback == null) {\n            return;\n        }\n        final boolean mayWatchPackageName =\n                packageName != null && !filterAppAccessUnlocked(packageName);\n        synchronized (this) {\n            int switchOp = (op != AppOpsManager.OP_NONE) ? AppOpsManager.opToSwitch(op) : op;\n\n            int notifiedOps;\n            if ((flags & CALL_BACK_ON_SWITCHED_OP) == 0) {\n                if (op == OP_NONE) {\n                    notifiedOps = ALL_OPS;\n                } else {\n                    notifiedOps = op;\n                }\n            } else {\n                notifiedOps = switchOp;\n            }\n\n            ModeCallback cb = mModeWatchers.get(callback.asBinder());\n            if (cb == null) {\n                cb = new ModeCallback(callback, watchedUid, flags, notifiedOps, callingUid,\n                        callingPid);\n                mModeWatchers.put(callback.asBinder(), cb);\n            }\n            if (switchOp != AppOpsManager.OP_NONE) {\n                ArraySet<ModeCallback> cbs = mOpModeWatchers.get(switchOp);\n                if (cbs == null) {\n                    cbs = new ArraySet<>();\n                    mOpModeWatchers.put(switchOp, cbs);\n                }\n                cbs.add(cb);\n            }\n            if (mayWatchPackageName) {\n                ArraySet<ModeCallback> cbs = mPackageModeWatchers.get(packageName);\n                if (cbs == null) {\n                    cbs = new ArraySet<>();\n                    mPackageModeWatchers.put(packageName, cbs);\n                }\n                cbs.add(cb);\n            }\n            evalAllForegroundOpsLocked();\n        }\n    }\n\n    @Override\n    public void stopWatchingMode(IAppOpsCallback callback) {\n        if (callback == null) {\n            return;\n        }\n        synchronized (this) {\n            ModeCallback cb = mModeWatchers.remove(callback.asBinder());\n            if (cb != null) {\n                cb.unlinkToDeath();\n                for (int i=mOpModeWatchers.size()-1; i>=0; i--) {\n                    ArraySet<ModeCallback> cbs = mOpModeWatchers.valueAt(i);\n                    cbs.remove(cb);\n                    if (cbs.size() <= 0) {\n                        mOpModeWatchers.removeAt(i);\n                    }\n                }\n                for (int i=mPackageModeWatchers.size()-1; i>=0; i--) {\n                    ArraySet<ModeCallback> cbs = mPackageModeWatchers.valueAt(i);\n                    cbs.remove(cb);\n                    if (cbs.size() <= 0) {\n                        mPackageModeWatchers.removeAt(i);\n                    }\n                }\n            }\n            evalAllForegroundOpsLocked();\n        }\n    }\n\n    public CheckOpsDelegate getAppOpsServiceDelegate() {\n        synchronized (AppOpsService.this) {\n            final CheckOpsDelegateDispatcher dispatcher = mCheckOpsDelegateDispatcher;\n            return (dispatcher != null) ? dispatcher.getCheckOpsDelegate() : null;\n        }\n    }\n\n    public void setAppOpsServiceDelegate(CheckOpsDelegate delegate) {\n        synchronized (AppOpsService.this) {\n            final CheckOpsDelegateDispatcher oldDispatcher = mCheckOpsDelegateDispatcher;\n            final CheckOpsDelegate policy = (oldDispatcher != null) ? oldDispatcher.mPolicy : null;\n            mCheckOpsDelegateDispatcher = new CheckOpsDelegateDispatcher(policy, delegate);\n        }\n    }\n\n    @Override\n    public int checkOperationRaw(int code, int uid, String packageName,\n            @Nullable String attributionTag) {\n        return mCheckOpsDelegateDispatcher.checkOperation(code, uid, packageName, attributionTag,\n                true /*raw*/);\n    }\n\n    @Override\n    public int checkOperation(int code, int uid, String packageName) {\n        return mCheckOpsDelegateDispatcher.checkOperation(code, uid, packageName, null,\n                false /*raw*/);\n    }\n\n    private int checkOperationImpl(int code, int uid, String packageName,\n            @Nullable String attributionTag, boolean raw) {\n        verifyIncomingOp(code);\n        verifyIncomingPackage(packageName, UserHandle.getUserId(uid));\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return AppOpsManager.MODE_IGNORED;\n        }\n        return checkOperationUnchecked(code, uid, resolvedPackageName, attributionTag, raw);\n    }\n\n    /**\n     * Get the mode of an app-op.\n     *\n     * @param code The code of the op\n     * @param uid The uid of the package the op belongs to\n     * @param packageName The package the op belongs to\n     * @param raw If the raw state of eval-ed state should be checked.\n     *\n     * @return The mode of the op\n     */\n    private @Mode int checkOperationUnchecked(int code, int uid, @NonNull String packageName,\n            @Nullable String attributionTag, boolean raw) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, null);\n        } catch (SecurityException e) {\n            Slog.e(TAG, \"checkOperation\", e);\n            return AppOpsManager.opToDefaultMode(code);\n        }\n\n        if (isOpRestrictedDueToSuspend(code, packageName, uid)) {\n            return AppOpsManager.MODE_IGNORED;\n        }\n        synchronized (this) {\n            if (isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass, true)) {\n                return AppOpsManager.MODE_IGNORED;\n            }\n            code = AppOpsManager.opToSwitch(code);\n            UidState uidState = getUidStateLocked(uid, false);\n            if (uidState != null && uidState.opModes != null\n                    && uidState.opModes.indexOfKey(code) >= 0) {\n                final int rawMode = uidState.opModes.get(code);\n                return raw ? rawMode : uidState.evalMode(code, rawMode);\n            }\n            Op op = getOpLocked(code, uid, packageName, null, false, pvr.bypass, /* edit */ false);\n            if (op == null) {\n                return AppOpsManager.opToDefaultMode(code);\n            }\n            return raw ? op.mode : op.evalMode();\n        }\n    }\n\n    @Override\n    public int checkAudioOperation(int code, int usage, int uid, String packageName) {\n        return mCheckOpsDelegateDispatcher.checkAudioOperation(code, usage, uid, packageName);\n    }\n\n    private int checkAudioOperationImpl(int code, int usage, int uid, String packageName) {\n        final int mode = mAudioRestrictionManager.checkAudioOperation(\n                code, usage, uid, packageName);\n        if (mode != AppOpsManager.MODE_ALLOWED) {\n            return mode;\n        }\n        return checkOperation(code, uid, packageName);\n    }\n\n    @Override\n    public void setAudioRestriction(int code, int usage, int uid, int mode,\n            String[] exceptionPackages) {\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), uid);\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n\n        mAudioRestrictionManager.setZenModeAudioRestriction(\n                code, usage, uid, mode, exceptionPackages);\n\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyWatchersOfChange, this, code, UID_ANY));\n    }\n\n\n    @Override\n    public void setCameraAudioRestriction(@CAMERA_AUDIO_RESTRICTION int mode) {\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), -1);\n\n        mAudioRestrictionManager.setCameraAudioRestriction(mode);\n\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyWatchersOfChange, this,\n                AppOpsManager.OP_PLAY_AUDIO, UID_ANY));\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyWatchersOfChange, this,\n                AppOpsManager.OP_VIBRATE, UID_ANY));\n    }\n\n    @Override\n    public int checkPackage(int uid, String packageName) {\n        Objects.requireNonNull(packageName);\n        try {\n            verifyAndGetBypass(uid, packageName, null);\n            // When the caller is the system, it's possible that the packageName is the special\n            // one (e.g., \"root\") which isn't actually existed.\n            if (resolveUid(packageName) == uid\n                    || (isPackageExisted(packageName) && !filterAppAccessUnlocked(packageName))) {\n                return AppOpsManager.MODE_ALLOWED;\n            }\n            return AppOpsManager.MODE_ERRORED;\n        } catch (SecurityException ignored) {\n            return AppOpsManager.MODE_ERRORED;\n        }\n    }\n\n    private boolean isPackageExisted(String packageName) {\n        return LocalServices.getService(PackageManagerInternal.class)\n                .getPackageStateInternal(packageName) != null;\n    }\n\n    /**\n     * This method will check with PackageManager to determine if the package provided should\n     * be visible to the {@link Binder#getCallingUid()}.\n     *\n     * NOTE: This must not be called while synchronized on {@code this} to avoid dead locks\n     */\n    private boolean filterAppAccessUnlocked(String packageName) {\n        final int callingUid = Binder.getCallingUid();\n        return LocalServices.getService(PackageManagerInternal.class)\n                .filterAppAccess(packageName, callingUid, UserHandle.getUserId(callingUid));\n    }\n\n    @Override\n    public SyncNotedAppOp noteProxyOperation(int code, AttributionSource attributionSource,\n            boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n            boolean skipProxyOperation) {\n        return mCheckOpsDelegateDispatcher.noteProxyOperation(code, attributionSource,\n                shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation);\n    }\n\n    private SyncNotedAppOp noteProxyOperationImpl(int code, AttributionSource attributionSource,\n            boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n            boolean skipProxyOperation) {\n        final int proxyUid = attributionSource.getUid();\n        final String proxyPackageName = attributionSource.getPackageName();\n        final String proxyAttributionTag = attributionSource.getAttributionTag();\n        final int proxiedUid = attributionSource.getNextUid();\n        final String proxiedPackageName = attributionSource.getNextPackageName();\n        final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n\n        verifyIncomingProxyUid(attributionSource);\n        verifyIncomingOp(code);\n        verifyIncomingPackage(proxiedPackageName, UserHandle.getUserId(proxiedUid));\n        verifyIncomingPackage(proxyPackageName, UserHandle.getUserId(proxyUid));\n\n        skipProxyOperation = skipProxyOperation\n                && isCallerAndAttributionTrusted(attributionSource);\n\n        String resolveProxyPackageName = AppOpsManager.resolvePackageName(proxyUid,\n                proxyPackageName);\n        if (resolveProxyPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code,\n                    proxiedAttributionTag, proxiedPackageName);\n        }\n\n        final boolean isSelfBlame = Binder.getCallingUid() == proxiedUid;\n        final boolean isProxyTrusted = mContext.checkPermission(\n                Manifest.permission.UPDATE_APP_OPS_STATS, -1, proxyUid)\n                == PackageManager.PERMISSION_GRANTED || isSelfBlame;\n\n        if (!skipProxyOperation) {\n            final int proxyFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXY\n                    : AppOpsManager.OP_FLAG_UNTRUSTED_PROXY;\n\n            final SyncNotedAppOp proxyReturn = noteOperationUnchecked(code, proxyUid,\n                    resolveProxyPackageName, proxyAttributionTag, Process.INVALID_UID, null, null,\n                    proxyFlags, !isProxyTrusted, \"proxy \" + message, shouldCollectMessage);\n            if (proxyReturn.getOpMode() != AppOpsManager.MODE_ALLOWED) {\n                return new SyncNotedAppOp(proxyReturn.getOpMode(), code, proxiedAttributionTag,\n                        proxiedPackageName);\n            }\n        }\n\n        String resolveProxiedPackageName = AppOpsManager.resolvePackageName(proxiedUid,\n                proxiedPackageName);\n        if (resolveProxiedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        final int proxiedFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXIED\n                : AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED;\n        return noteOperationUnchecked(code, proxiedUid, resolveProxiedPackageName,\n                proxiedAttributionTag, proxyUid, resolveProxyPackageName, proxyAttributionTag,\n                proxiedFlags, shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n    }\n\n    @Override\n    public SyncNotedAppOp noteOperation(int code, int uid, String packageName,\n            String attributionTag, boolean shouldCollectAsyncNotedOp, String message,\n            boolean shouldCollectMessage) {\n        return mCheckOpsDelegateDispatcher.noteOperation(code, uid, packageName,\n                attributionTag, shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n    }\n\n    private SyncNotedAppOp noteOperationImpl(int code, int uid, @Nullable String packageName,\n            @Nullable String attributionTag, boolean shouldCollectAsyncNotedOp,\n            @Nullable String message, boolean shouldCollectMessage) {\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n        verifyIncomingPackage(packageName, UserHandle.getUserId(uid));\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, attributionTag,\n                    packageName);\n        }\n        return noteOperationUnchecked(code, uid, resolvedPackageName, attributionTag,\n                Process.INVALID_UID, null, null, AppOpsManager.OP_FLAG_SELF,\n                shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n    }\n\n    private SyncNotedAppOp noteOperationUnchecked(int code, int uid, @NonNull String packageName,\n            @Nullable String attributionTag, int proxyUid, String proxyPackageName,\n            @Nullable String proxyAttributionTag, @OpFlags int flags,\n            boolean shouldCollectAsyncNotedOp, @Nullable String message,\n            boolean shouldCollectMessage) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n            boolean wasNull = attributionTag == null;\n            if (!pvr.isAttributionTagValid) {\n                attributionTag = null;\n            }\n        } catch (SecurityException e) {\n            Slog.e(TAG, \"noteOperation\", e);\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                    packageName);\n        }\n        if (proxyAttributionTag != null\n                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n            proxyAttributionTag = null;\n        }\n\n        synchronized (this) {\n            final Ops ops = getOpsLocked(uid, packageName, attributionTag,\n                    pvr.isAttributionTagValid, pvr.bypass, /* edit */ true);\n            if (ops == null) {\n                scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                        AppOpsManager.MODE_IGNORED);\n                if (DEBUG) Slog.d(TAG, \"noteOperation: no op for code \" + code + \" uid \" + uid\n                        + \" package \" + packageName + \"flags: \" +\n                        AppOpsManager.flagsToString(flags));\n                return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                        packageName);\n            }\n            final Op op = getOpLocked(ops, code, uid, true);\n            final AttributedOp attributedOp = op.getOrCreateAttribution(op, attributionTag);\n            if (attributedOp.isRunning()) {\n                Slog.w(TAG, \"Noting op not finished: uid \" + uid + \" pkg \" + packageName + \" code \"\n                        + code + \" startTime of in progress event=\"\n                        + attributedOp.mInProgressEvents.valueAt(0).getStartTime());\n            }\n\n            final int switchCode = AppOpsManager.opToSwitch(code);\n            final UidState uidState = ops.uidState;\n            if (isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass, false)) {\n                attributedOp.rejected(uidState.state, flags);\n                scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                        AppOpsManager.MODE_IGNORED);\n                return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, attributionTag,\n                        packageName);\n            }\n            // If there is a non-default per UID policy (we set UID op mode only if\n            // non-default) it takes over, otherwise use the per package policy.\n            if (uidState.opModes != null && uidState.opModes.indexOfKey(switchCode) >= 0) {\n                final int uidMode = uidState.evalMode(code, uidState.opModes.get(switchCode));\n                if (uidMode != AppOpsManager.MODE_ALLOWED) {\n                    if (DEBUG) Slog.d(TAG, \"noteOperation: uid reject #\" + uidMode + \" for code \"\n                            + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                            + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    attributedOp.rejected(uidState.state, flags);\n                    scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                            uidMode);\n                    return new SyncNotedAppOp(uidMode, code, attributionTag, packageName);\n                }\n            } else {\n                final Op switchOp = switchCode != code ? getOpLocked(ops, switchCode, uid, true)\n                        : op;\n                final int mode = switchOp.evalMode();\n                if (mode != AppOpsManager.MODE_ALLOWED) {\n                    if (DEBUG) Slog.d(TAG, \"noteOperation: reject #\" + mode + \" for code \"\n                            + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                            + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    attributedOp.rejected(uidState.state, flags);\n                    scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                            mode);\n                    return new SyncNotedAppOp(mode, code, attributionTag, packageName);\n                }\n            }\n            if (DEBUG) {\n                Slog.d(TAG,\n                        \"noteOperation: allowing code \" + code + \" uid \" + uid + \" package \"\n                                + packageName + (attributionTag == null ? \"\"\n                                : \".\" + attributionTag) + \" flags: \"\n                                + AppOpsManager.flagsToString(flags));\n            }\n            scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                    AppOpsManager.MODE_ALLOWED);\n            attributedOp.accessed(proxyUid, proxyPackageName, proxyAttributionTag, uidState.state,\n                    flags);\n\n            if (shouldCollectAsyncNotedOp) {\n                collectAsyncNotedOp(uid, packageName, code, attributionTag, flags, message,\n                        shouldCollectMessage);\n            }\n\n            return new SyncNotedAppOp(AppOpsManager.MODE_ALLOWED, code, attributionTag,\n                    packageName);\n        }\n    }\n\n    // TODO moltmann: Allow watching for attribution ops\n    @Override\n    public void startWatchingActive(int[] ops, IAppOpsActiveCallback callback) {\n        int watchedUid = Process.INVALID_UID;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                != PackageManager.PERMISSION_GRANTED) {\n            watchedUid = callingUid;\n        }\n        if (ops != null) {\n            Preconditions.checkArrayElementsInRange(ops, 0,\n                    AppOpsManager._NUM_OP - 1, \"Invalid op code in: \" + Arrays.toString(ops));\n        }\n        if (callback == null) {\n            return;\n        }\n        synchronized (this) {\n            SparseArray<ActiveCallback> callbacks = mActiveWatchers.get(callback.asBinder());\n            if (callbacks == null) {\n                callbacks = new SparseArray<>();\n                mActiveWatchers.put(callback.asBinder(), callbacks);\n            }\n            final ActiveCallback activeCallback = new ActiveCallback(callback, watchedUid,\n                    callingUid, callingPid);\n            for (int op : ops) {\n                callbacks.put(op, activeCallback);\n            }\n        }\n    }\n\n    @Override\n    public void stopWatchingActive(IAppOpsActiveCallback callback) {\n        if (callback == null) {\n            return;\n        }\n        synchronized (this) {\n            final SparseArray<ActiveCallback> activeCallbacks =\n                    mActiveWatchers.remove(callback.asBinder());\n            if (activeCallbacks == null) {\n                return;\n            }\n            final int callbackCount = activeCallbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                activeCallbacks.valueAt(i).destroy();\n            }\n        }\n    }\n\n    @Override\n    public void startWatchingStarted(int[] ops, @NonNull IAppOpsStartedCallback callback) {\n        int watchedUid = Process.INVALID_UID;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                != PackageManager.PERMISSION_GRANTED) {\n            watchedUid = callingUid;\n        }\n\n        Preconditions.checkArgument(!ArrayUtils.isEmpty(ops), \"Ops cannot be null or empty\");\n        Preconditions.checkArrayElementsInRange(ops, 0, AppOpsManager._NUM_OP - 1,\n                \"Invalid op code in: \" + Arrays.toString(ops));\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n\n        synchronized (this) {\n            SparseArray<StartedCallback> callbacks = mStartedWatchers.get(callback.asBinder());\n            if (callbacks == null) {\n                callbacks = new SparseArray<>();\n                mStartedWatchers.put(callback.asBinder(), callbacks);\n            }\n\n            final StartedCallback startedCallback = new StartedCallback(callback, watchedUid,\n                    callingUid, callingPid);\n            for (int op : ops) {\n                callbacks.put(op, startedCallback);\n            }\n        }\n    }\n\n    @Override\n    public void stopWatchingStarted(IAppOpsStartedCallback callback) {\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n\n        synchronized (this) {\n            final SparseArray<StartedCallback> startedCallbacks =\n                    mStartedWatchers.remove(callback.asBinder());\n            if (startedCallbacks == null) {\n                return;\n            }\n\n            final int callbackCount = startedCallbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                startedCallbacks.valueAt(i).destroy();\n            }\n        }\n    }\n\n    @Override\n    public void startWatchingNoted(@NonNull int[] ops, @NonNull IAppOpsNotedCallback callback) {\n        int watchedUid = Process.INVALID_UID;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                != PackageManager.PERMISSION_GRANTED) {\n            watchedUid = callingUid;\n        }\n        Preconditions.checkArgument(!ArrayUtils.isEmpty(ops), \"Ops cannot be null or empty\");\n        Preconditions.checkArrayElementsInRange(ops, 0, AppOpsManager._NUM_OP - 1,\n                \"Invalid op code in: \" + Arrays.toString(ops));\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n        synchronized (this) {\n            SparseArray<NotedCallback> callbacks = mNotedWatchers.get(callback.asBinder());\n            if (callbacks == null) {\n                callbacks = new SparseArray<>();\n                mNotedWatchers.put(callback.asBinder(), callbacks);\n            }\n            final NotedCallback notedCallback = new NotedCallback(callback, watchedUid,\n                    callingUid, callingPid);\n            for (int op : ops) {\n                callbacks.put(op, notedCallback);\n            }\n        }\n    }\n\n    @Override\n    public void stopWatchingNoted(IAppOpsNotedCallback callback) {\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n        synchronized (this) {\n            final SparseArray<NotedCallback> notedCallbacks =\n                    mNotedWatchers.remove(callback.asBinder());\n            if (notedCallbacks == null) {\n                return;\n            }\n            final int callbackCount = notedCallbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                notedCallbacks.valueAt(i).destroy();\n            }\n        }\n    }\n\n    /**\n     * Collect an {@link AsyncNotedAppOp}.\n     *\n     * @param uid The uid the op was noted for\n     * @param packageName The package the op was noted for\n     * @param opCode The code of the op noted\n     * @param attributionTag attribution tag the op was noted for\n     * @param message The message for the op noting\n     */\n    private void collectAsyncNotedOp(int uid, @NonNull String packageName, int opCode,\n            @Nullable String attributionTag, @OpFlags int flags, @NonNull String message,\n            boolean shouldCollectMessage) {\n        Objects.requireNonNull(message);\n\n        int callingUid = Binder.getCallingUid();\n\n        final long token = Binder.clearCallingIdentity();\n        try {\n            synchronized (this) {\n                Pair<String, Integer> key = getAsyncNotedOpsKey(packageName, uid);\n\n                RemoteCallbackList<IAppOpsAsyncNotedCallback> callbacks = mAsyncOpWatchers.get(key);\n                AsyncNotedAppOp asyncNotedOp = new AsyncNotedAppOp(opCode, callingUid,\n                        attributionTag, message, System.currentTimeMillis());\n                final boolean[] wasNoteForwarded = {false};\n\n                if ((flags & (OP_FLAG_SELF | OP_FLAG_TRUSTED_PROXIED)) != 0\n                        && shouldCollectMessage) {\n                    reportRuntimeAppOpAccessMessageAsyncLocked(uid, packageName, opCode,\n                            attributionTag, message);\n                }\n\n                if (callbacks != null) {\n                    callbacks.broadcast((cb) -> {\n                        try {\n                            cb.opNoted(asyncNotedOp);\n                            wasNoteForwarded[0] = true;\n                        } catch (RemoteException e) {\n                            Slog.e(TAG,\n                                    \"Could not forward noteOp of \" + opCode + \" to \" + packageName\n                                            + \"/\" + uid + \"(\" + attributionTag + \")\", e);\n                        }\n                    });\n                }\n\n                if (!wasNoteForwarded[0]) {\n                    ArrayList<AsyncNotedAppOp> unforwardedOps = mUnforwardedAsyncNotedOps.get(key);\n                    if (unforwardedOps == null) {\n                        unforwardedOps = new ArrayList<>(1);\n                        mUnforwardedAsyncNotedOps.put(key, unforwardedOps);\n                    }\n\n                    unforwardedOps.add(asyncNotedOp);\n                    if (unforwardedOps.size() > MAX_UNFORWARDED_OPS) {\n                        unforwardedOps.remove(0);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Compute a key to be used in {@link #mAsyncOpWatchers} and {@link #mUnforwardedAsyncNotedOps}\n     *\n     * @param packageName The package name of the app\n     * @param uid The uid of the app\n     *\n     * @return They key uniquely identifying the app\n     */\n    private @NonNull Pair<String, Integer> getAsyncNotedOpsKey(@NonNull String packageName,\n            int uid) {\n        return new Pair<>(packageName, uid);\n    }\n\n    @Override\n    public void startWatchingAsyncNoted(String packageName, IAppOpsAsyncNotedCallback callback) {\n        Objects.requireNonNull(packageName);\n        Objects.requireNonNull(callback);\n\n        int uid = Binder.getCallingUid();\n        Pair<String, Integer> key = getAsyncNotedOpsKey(packageName, uid);\n\n        verifyAndGetBypass(uid, packageName, null);\n\n        synchronized (this) {\n            RemoteCallbackList<IAppOpsAsyncNotedCallback> callbacks = mAsyncOpWatchers.get(key);\n            if (callbacks == null) {\n                callbacks = new RemoteCallbackList<IAppOpsAsyncNotedCallback>() {\n                    @Override\n                    public void onCallbackDied(IAppOpsAsyncNotedCallback callback) {\n                        synchronized (AppOpsService.this) {\n                            if (getRegisteredCallbackCount() == 0) {\n                                mAsyncOpWatchers.remove(key);\n                            }\n                        }\n                    }\n                };\n                mAsyncOpWatchers.put(key, callbacks);\n            }\n\n            callbacks.register(callback);\n        }\n    }\n\n    @Override\n    public void stopWatchingAsyncNoted(String packageName, IAppOpsAsyncNotedCallback callback) {\n        Objects.requireNonNull(packageName);\n        Objects.requireNonNull(callback);\n\n        int uid = Binder.getCallingUid();\n        Pair<String, Integer> key = getAsyncNotedOpsKey(packageName, uid);\n\n        verifyAndGetBypass(uid, packageName, null);\n\n        synchronized (this) {\n            RemoteCallbackList<IAppOpsAsyncNotedCallback> callbacks = mAsyncOpWatchers.get(key);\n            if (callbacks != null) {\n                callbacks.unregister(callback);\n                if (callbacks.getRegisteredCallbackCount() == 0) {\n                    mAsyncOpWatchers.remove(key);\n                }\n            }\n        }\n    }\n\n    @Override\n    public List<AsyncNotedAppOp> extractAsyncOps(String packageName) {\n        Objects.requireNonNull(packageName);\n\n        int uid = Binder.getCallingUid();\n\n        verifyAndGetBypass(uid, packageName, null);\n\n        synchronized (this) {\n            return mUnforwardedAsyncNotedOps.remove(getAsyncNotedOpsKey(packageName, uid));\n        }\n    }\n\n    @Override\n    public SyncNotedAppOp startOperation(IBinder token, int code, int uid,\n            @Nullable String packageName, @Nullable String attributionTag,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp,\n            String message, boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n            int attributionChainId) {\n        return mCheckOpsDelegateDispatcher.startOperation(token, code, uid, packageName,\n                attributionTag, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                shouldCollectMessage, attributionFlags, attributionChainId);\n    }\n\n    private SyncNotedAppOp startOperationImpl(@NonNull IBinder clientId, int code, int uid,\n            @Nullable String packageName, @Nullable String attributionTag,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, @NonNull String message,\n            boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n            int attributionChainId) {\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n        verifyIncomingPackage(packageName, UserHandle.getUserId(uid));\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, attributionTag,\n                    packageName);\n        }\n\n        // As a special case for OP_RECORD_AUDIO_HOTWORD, which we use only for attribution\n        // purposes and not as a check, also make sure that the caller is allowed to access\n        // the data gated by OP_RECORD_AUDIO.\n        //\n        // TODO: Revert this change before Android 12.\n        if (code == OP_RECORD_AUDIO_HOTWORD || code == OP_RECEIVE_AMBIENT_TRIGGER_AUDIO) {\n            int result = checkOperation(OP_RECORD_AUDIO, uid, packageName);\n            if (result != AppOpsManager.MODE_ALLOWED) {\n                return new SyncNotedAppOp(result, code, attributionTag, packageName);\n            }\n        }\n        return startOperationUnchecked(clientId, code, uid, packageName, attributionTag,\n                Process.INVALID_UID, null, null, OP_FLAG_SELF, startIfModeDefault,\n                shouldCollectAsyncNotedOp, message, shouldCollectMessage, attributionFlags,\n                attributionChainId, /*dryRun*/ false);\n    }\n\n    @Override\n    public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n            boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n            boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n            @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n        return mCheckOpsDelegateDispatcher.startProxyOperation(clientId, code, attributionSource,\n                startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlags,\n                attributionChainId);\n    }\n\n    private SyncNotedAppOp startProxyOperationImpl(@NonNull IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n            boolean shouldCollectMessage, boolean skipProxyOperation, @AttributionFlags\n            int proxyAttributionFlags, @AttributionFlags int proxiedAttributionFlags,\n            int attributionChainId) {\n        final int proxyUid = attributionSource.getUid();\n        final String proxyPackageName = attributionSource.getPackageName();\n        final String proxyAttributionTag = attributionSource.getAttributionTag();\n        final int proxiedUid = attributionSource.getNextUid();\n        final String proxiedPackageName = attributionSource.getNextPackageName();\n        final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n\n        verifyIncomingProxyUid(attributionSource);\n        verifyIncomingOp(code);\n        verifyIncomingPackage(proxyPackageName, UserHandle.getUserId(proxyUid));\n        verifyIncomingPackage(proxiedPackageName, UserHandle.getUserId(proxiedUid));\n\n        boolean isCallerTrusted = isCallerAndAttributionTrusted(attributionSource);\n        skipProxyOperation = isCallerTrusted && skipProxyOperation;\n\n        String resolvedProxyPackageName = AppOpsManager.resolvePackageName(proxyUid,\n                proxyPackageName);\n        if (resolvedProxyPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        final boolean isChainTrusted = isCallerTrusted\n                && attributionChainId != ATTRIBUTION_CHAIN_ID_NONE\n                && ((proxyAttributionFlags & ATTRIBUTION_FLAG_TRUSTED) != 0\n                || (proxiedAttributionFlags & ATTRIBUTION_FLAG_TRUSTED) != 0);\n        final boolean isSelfBlame = Binder.getCallingUid() == proxiedUid;\n        final boolean isProxyTrusted = mContext.checkPermission(\n                Manifest.permission.UPDATE_APP_OPS_STATS, -1, proxyUid)\n                == PackageManager.PERMISSION_GRANTED || isSelfBlame\n                || isChainTrusted;\n\n        String resolvedProxiedPackageName = AppOpsManager.resolvePackageName(proxiedUid,\n                proxiedPackageName);\n        if (resolvedProxiedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        final int proxiedFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXIED\n                : AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED;\n\n        if (!skipProxyOperation) {\n            // Test if the proxied operation will succeed before starting the proxy operation\n            final SyncNotedAppOp testProxiedOp = startOperationUnchecked(clientId, code,\n                    proxiedUid, resolvedProxiedPackageName, proxiedAttributionTag, proxyUid,\n                    resolvedProxyPackageName, proxyAttributionTag, proxiedFlags, startIfModeDefault,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    proxiedAttributionFlags, attributionChainId, /*dryRun*/ true);\n            if (!shouldStartForMode(testProxiedOp.getOpMode(), startIfModeDefault)) {\n                return testProxiedOp;\n            }\n\n            final int proxyFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXY\n                    : AppOpsManager.OP_FLAG_UNTRUSTED_PROXY;\n\n            final SyncNotedAppOp proxyAppOp = startOperationUnchecked(clientId, code, proxyUid,\n                    resolvedProxyPackageName, proxyAttributionTag, Process.INVALID_UID, null, null,\n                    proxyFlags, startIfModeDefault, !isProxyTrusted, \"proxy \" + message,\n                    shouldCollectMessage, proxyAttributionFlags, attributionChainId,\n                    /*dryRun*/ false);\n            if (!shouldStartForMode(proxyAppOp.getOpMode(), startIfModeDefault)) {\n                return proxyAppOp;\n            }\n        }\n\n        return startOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,\n                proxiedAttributionTag, proxyUid, resolvedProxyPackageName, proxyAttributionTag,\n                proxiedFlags, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                shouldCollectMessage, proxiedAttributionFlags, attributionChainId,\n                /*dryRun*/ false);\n    }\n\n    private boolean shouldStartForMode(int mode, boolean startIfModeDefault) {\n        return (mode == MODE_ALLOWED || (mode == MODE_DEFAULT && startIfModeDefault));\n    }\n\n    private SyncNotedAppOp startOperationUnchecked(IBinder clientId, int code, int uid,\n            @NonNull String packageName, @Nullable String attributionTag, int proxyUid,\n            String proxyPackageName, @Nullable String proxyAttributionTag, @OpFlags int flags,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, @Nullable String message,\n            boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n            int attributionChainId, boolean dryRun) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n            if (!pvr.isAttributionTagValid) {\n                attributionTag = null;\n            }\n        } catch (SecurityException e) {\n            Slog.e(TAG, \"startOperation\", e);\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                    packageName);\n        }\n        if (proxyAttributionTag != null\n                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n            proxyAttributionTag = null;\n        }\n\n        boolean isRestricted = false;\n        int startType = START_TYPE_FAILED;\n        synchronized (this) {\n            final Ops ops = getOpsLocked(uid, packageName, attributionTag,\n                    pvr.isAttributionTagValid, pvr.bypass, /* edit */ true);\n            if (ops == null) {\n                if (!dryRun) {\n                    scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag,\n                            flags, AppOpsManager.MODE_IGNORED, startType, attributionFlags,\n                            attributionChainId);\n                }\n                if (DEBUG) Slog.d(TAG, \"startOperation: no op for code \" + code + \" uid \" + uid\n                        + \" package \" + packageName + \" flags: \"\n                        + AppOpsManager.flagsToString(flags));\n                return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                        packageName);\n            }\n            final Op op = getOpLocked(ops, code, uid, true);\n            final AttributedOp attributedOp = op.getOrCreateAttribution(op, attributionTag);\n            final UidState uidState = ops.uidState;\n            isRestricted = isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass,\n                    false);\n            final int switchCode = AppOpsManager.opToSwitch(code);\n            // If there is a non-default per UID policy (we set UID op mode only if\n            // non-default) it takes over, otherwise use the per package policy.\n            if (uidState.opModes != null && uidState.opModes.indexOfKey(switchCode) >= 0) {\n                final int uidMode = uidState.evalMode(code, uidState.opModes.get(switchCode));\n                if (!shouldStartForMode(uidMode, startIfModeDefault)) {\n                    if (DEBUG) {\n                        Slog.d(TAG, \"startOperation: uid reject #\" + uidMode + \" for code \"\n                                + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                                + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    }\n                    if (!dryRun) {\n                        attributedOp.rejected(uidState.state, flags);\n                        scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag,\n                                flags, uidMode, startType, attributionFlags, attributionChainId);\n                    }\n                    return new SyncNotedAppOp(uidMode, code, attributionTag, packageName);\n                }\n            } else {\n                final Op switchOp = switchCode != code ? getOpLocked(ops, switchCode, uid, true)\n                        : op;\n                final int mode = switchOp.evalMode();\n                if (mode != AppOpsManager.MODE_ALLOWED\n                        && (!startIfModeDefault || mode != MODE_DEFAULT)) {\n                    if (DEBUG) Slog.d(TAG, \"startOperation: reject #\" + mode + \" for code \"\n                            + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                            + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    if (!dryRun) {\n                        attributedOp.rejected(uidState.state, flags);\n                        scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag,\n                                flags, mode, startType, attributionFlags, attributionChainId);\n                    }\n                    return new SyncNotedAppOp(mode, code, attributionTag, packageName);\n                }\n            }\n            if (DEBUG) Slog.d(TAG, \"startOperation: allowing code \" + code + \" uid \" + uid\n                    + \" package \" + packageName + \" restricted: \" + isRestricted\n                    + \" flags: \" + AppOpsManager.flagsToString(flags));\n            if (!dryRun) {\n                try {\n                    if (isRestricted) {\n                        attributedOp.createPaused(clientId, proxyUid, proxyPackageName,\n                                proxyAttributionTag, uidState.state, flags, attributionFlags,\n                                attributionChainId);\n                    } else {\n                        attributedOp.started(clientId, proxyUid, proxyPackageName,\n                                proxyAttributionTag, uidState.state, flags, attributionFlags,\n                                attributionChainId);\n                        startType = START_TYPE_STARTED;\n                    }\n                } catch (RemoteException e) {\n                    throw new RuntimeException(e);\n                }\n                scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                        isRestricted ? MODE_IGNORED : MODE_ALLOWED, startType, attributionFlags,\n                        attributionChainId);\n            }\n        }\n\n        if (shouldCollectAsyncNotedOp && !dryRun && !isRestricted) {\n            collectAsyncNotedOp(uid, packageName, code, attributionTag, AppOpsManager.OP_FLAG_SELF,\n                    message, shouldCollectMessage);\n        }\n\n        return new SyncNotedAppOp(isRestricted ? MODE_IGNORED : MODE_ALLOWED, code, attributionTag,\n                packageName);\n    }\n\n    @Override\n    public void finishOperation(IBinder clientId, int code, int uid, String packageName,\n            String attributionTag) {\n        mCheckOpsDelegateDispatcher.finishOperation(clientId, code, uid, packageName,\n                attributionTag);\n    }\n\n    private void finishOperationImpl(IBinder clientId, int code, int uid, String packageName,\n            String attributionTag) {\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n        verifyIncomingPackage(packageName, UserHandle.getUserId(uid));\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return;\n        }\n\n        finishOperationUnchecked(clientId, code, uid, resolvedPackageName, attributionTag);\n    }\n\n    @Override\n    public void finishProxyOperation(@NonNull IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n        mCheckOpsDelegateDispatcher.finishProxyOperation(clientId, code, attributionSource,\n                skipProxyOperation);\n    }\n\n    private Void finishProxyOperationImpl(IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n        final int proxyUid = attributionSource.getUid();\n        final String proxyPackageName = attributionSource.getPackageName();\n        final String proxyAttributionTag = attributionSource.getAttributionTag();\n        final int proxiedUid = attributionSource.getNextUid();\n        final String proxiedPackageName = attributionSource.getNextPackageName();\n        final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n\n        skipProxyOperation = skipProxyOperation\n                && isCallerAndAttributionTrusted(attributionSource);\n\n        verifyIncomingProxyUid(attributionSource);\n        verifyIncomingOp(code);\n        verifyIncomingPackage(proxyPackageName, UserHandle.getUserId(proxyUid));\n        verifyIncomingPackage(proxiedPackageName, UserHandle.getUserId(proxiedUid));\n\n        String resolvedProxyPackageName = AppOpsManager.resolvePackageName(proxyUid,\n                proxyPackageName);\n        if (resolvedProxyPackageName == null) {\n            return null;\n        }\n\n        if (!skipProxyOperation) {\n            finishOperationUnchecked(clientId, code, proxyUid, resolvedProxyPackageName,\n                    proxyAttributionTag);\n        }\n\n        String resolvedProxiedPackageName = AppOpsManager.resolvePackageName(proxiedUid,\n                proxiedPackageName);\n        if (resolvedProxiedPackageName == null) {\n            return null;\n        }\n\n        finishOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,\n                proxiedAttributionTag);\n\n        return null;\n    }\n\n    private void finishOperationUnchecked(IBinder clientId, int code, int uid, String packageName,\n            String attributionTag) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag);\n            if (!pvr.isAttributionTagValid) {\n                attributionTag = null;\n            }\n        } catch (SecurityException e) {\n            Slog.e(TAG, \"Cannot finishOperation\", e);\n            return;\n        }\n\n        synchronized (this) {\n            Op op = getOpLocked(code, uid, packageName, attributionTag, pvr.isAttributionTagValid,\n                    pvr.bypass, /* edit */ true);\n            if (op == null) {\n                Slog.e(TAG, \"Operation not found: uid=\" + uid + \" pkg=\" + packageName + \"(\"\n                        + attributionTag + \") op=\" + AppOpsManager.opToName(code));\n                return;\n            }\n            final AttributedOp attributedOp = op.mAttributions.get(attributionTag);\n            if (attributedOp == null) {\n                Slog.e(TAG, \"Attribution not found: uid=\" + uid + \" pkg=\" + packageName + \"(\"\n                        + attributionTag + \") op=\" + AppOpsManager.opToName(code));\n                return;\n            }\n\n            if (attributedOp.isRunning() || attributedOp.isPaused()) {\n                attributedOp.finished(clientId);\n            } else {\n                Slog.e(TAG, \"Operation not started: uid=\" + uid + \" pkg=\" + packageName + \"(\"\n                        + attributionTag + \") op=\" + AppOpsManager.opToName(code));\n            }\n        }\n    }\n\n    private void scheduleOpActiveChangedIfNeededLocked(int code, int uid, @NonNull\n            String packageName, @Nullable String attributionTag, boolean active, @AttributionFlags\n            int attributionFlags, int attributionChainId) {\n        ArraySet<ActiveCallback> dispatchedCallbacks = null;\n        final int callbackListCount = mActiveWatchers.size();\n        for (int i = 0; i < callbackListCount; i++) {\n            final SparseArray<ActiveCallback> callbacks = mActiveWatchers.valueAt(i);\n            ActiveCallback callback = callbacks.get(code);\n            if (callback != null) {\n                if (callback.mWatchingUid >= 0 && callback.mWatchingUid != uid) {\n                    continue;\n                }\n                if (dispatchedCallbacks == null) {\n                    dispatchedCallbacks = new ArraySet<>();\n                }\n                dispatchedCallbacks.add(callback);\n            }\n        }\n        if (dispatchedCallbacks == null) {\n            return;\n        }\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyOpActiveChanged,\n                this, dispatchedCallbacks, code, uid, packageName, attributionTag, active,\n                attributionFlags, attributionChainId));\n    }\n\n    private void notifyOpActiveChanged(ArraySet<ActiveCallback> callbacks,\n            int code, int uid, @NonNull String packageName, @Nullable String attributionTag,\n            boolean active, @AttributionFlags int attributionFlags, int attributionChainId) {\n        // There are features watching for mode changes such as window manager\n        // and location manager which are in our process. The callbacks in these\n        // features may require permissions our remote caller does not have.\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int callbackCount = callbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                final ActiveCallback callback = callbacks.valueAt(i);\n                try {\n                    if (shouldIgnoreCallback(code, callback.mCallingPid, callback.mCallingUid)) {\n                        continue;\n                    }\n                    callback.mCallback.opActiveChanged(code, uid, packageName, attributionTag,\n                            active, attributionFlags, attributionChainId);\n                } catch (RemoteException e) {\n                    /* do nothing */\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void scheduleOpStartedIfNeededLocked(int code, int uid, String pkgName,\n            String attributionTag, @OpFlags int flags, @Mode int result,\n            @AppOpsManager.OnOpStartedListener.StartedType int startedType,\n            @AttributionFlags int attributionFlags, int attributionChainId) {\n        ArraySet<StartedCallback> dispatchedCallbacks = null;\n        final int callbackListCount = mStartedWatchers.size();\n        for (int i = 0; i < callbackListCount; i++) {\n            final SparseArray<StartedCallback> callbacks = mStartedWatchers.valueAt(i);\n\n            StartedCallback callback = callbacks.get(code);\n            if (callback != null) {\n                if (callback.mWatchingUid >= 0 && callback.mWatchingUid != uid) {\n                    continue;\n                }\n\n                if (dispatchedCallbacks == null) {\n                    dispatchedCallbacks = new ArraySet<>();\n                }\n                dispatchedCallbacks.add(callback);\n            }\n        }\n\n        if (dispatchedCallbacks == null) {\n            return;\n        }\n\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyOpStarted,\n                this, dispatchedCallbacks, code, uid, pkgName, attributionTag, flags,\n                result, startedType, attributionFlags, attributionChainId));\n    }\n\n    private void notifyOpStarted(ArraySet<StartedCallback> callbacks,\n            int code, int uid, String packageName, String attributionTag, @OpFlags int flags,\n            @Mode int result, @AppOpsManager.OnOpStartedListener.StartedType int startedType,\n            @AttributionFlags int attributionFlags, int attributionChainId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int callbackCount = callbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                final StartedCallback callback = callbacks.valueAt(i);\n                try {\n                    if (shouldIgnoreCallback(code, callback.mCallingPid, callback.mCallingUid)) {\n                        continue;\n                    }\n                    callback.mCallback.opStarted(code, uid, packageName, attributionTag, flags,\n                            result, startedType, attributionFlags, attributionChainId);\n                } catch (RemoteException e) {\n                    /* do nothing */\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void scheduleOpNotedIfNeededLocked(int code, int uid, String packageName,\n            String attributionTag, @OpFlags int flags, @Mode int result) {\n        ArraySet<NotedCallback> dispatchedCallbacks = null;\n        final int callbackListCount = mNotedWatchers.size();\n        for (int i = 0; i < callbackListCount; i++) {\n            final SparseArray<NotedCallback> callbacks = mNotedWatchers.valueAt(i);\n            final NotedCallback callback = callbacks.get(code);\n            if (callback != null) {\n                if (callback.mWatchingUid >= 0 && callback.mWatchingUid != uid) {\n                    continue;\n                }\n                if (dispatchedCallbacks == null) {\n                    dispatchedCallbacks = new ArraySet<>();\n                }\n                dispatchedCallbacks.add(callback);\n            }\n        }\n        if (dispatchedCallbacks == null) {\n            return;\n        }\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyOpChecked,\n                this, dispatchedCallbacks, code, uid, packageName, attributionTag, flags,\n                result));\n    }\n\n    private void notifyOpChecked(ArraySet<NotedCallback> callbacks,\n            int code, int uid, String packageName, String attributionTag, @OpFlags int flags,\n            @Mode int result) {\n        // There are features watching for checks in our process. The callbacks in\n        // these features may require permissions our remote caller does not have.\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int callbackCount = callbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                final NotedCallback callback = callbacks.valueAt(i);\n                try {\n                    if (shouldIgnoreCallback(code, callback.mCallingPid, callback.mCallingUid)) {\n                        continue;\n                    }\n                    callback.mCallback.opNoted(code, uid, packageName, attributionTag, flags,\n                            result);\n                } catch (RemoteException e) {\n                    /* do nothing */\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    @Override\n    public int permissionToOpCode(String permission) {\n        if (permission == null) {\n            return AppOpsManager.OP_NONE;\n        }\n        return AppOpsManager.permissionToOpCode(permission);\n    }\n\n    @Override\n    public boolean shouldCollectNotes(int opCode) {\n        Preconditions.checkArgumentInRange(opCode, 0, _NUM_OP - 1, \"opCode\");\n\n        String perm = AppOpsManager.opToPermission(opCode);\n        if (perm == null) {\n            return false;\n        }\n\n        PermissionInfo permInfo;\n        try {\n            permInfo = mContext.getPackageManager().getPermissionInfo(perm, 0);\n        } catch (PackageManager.NameNotFoundException e) {\n            return false;\n        }\n\n        return permInfo.getProtection() == PROTECTION_DANGEROUS\n                || (permInfo.getProtectionFlags() & PROTECTION_FLAG_APPOP) != 0;\n    }\n\n    private void verifyIncomingProxyUid(@NonNull AttributionSource attributionSource) {\n        if (attributionSource.getUid() == Binder.getCallingUid()) {\n            return;\n        }\n        if (Binder.getCallingPid() == Process.myPid()) {\n            return;\n        }\n        if (attributionSource.isTrusted(mContext)) {\n            return;\n        }\n        mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n    }\n\n    private void verifyIncomingUid(int uid) {\n        if (uid == Binder.getCallingUid()) {\n            return;\n        }\n        if (Binder.getCallingPid() == Process.myPid()) {\n            return;\n        }\n        mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n    }\n\n    private boolean shouldIgnoreCallback(int op, int watcherPid, int watcherUid) {\n        // If it's a restricted read op, ignore it if watcher doesn't have manage ops permission,\n        // as watcher should not use this to signal if the value is changed.\n        return opRestrictsRead(op) && mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n                watcherPid, watcherUid) != PackageManager.PERMISSION_GRANTED;\n    }\n\n    private void verifyIncomingOp(int op) {\n        if (op >= 0 && op < AppOpsManager._NUM_OP) {\n            // Enforce privileged appops permission if it's a restricted read op.\n            if (opRestrictsRead(op)) {\n                if (!(mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n                        Manifest.permission.GET_APP_OPS_STATS,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n                        Manifest.permission.MANAGE_APP_OPS_MODES,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED)) {\n                    throw new SecurityException(\"verifyIncomingOp: uid \" + Binder.getCallingUid()\n                            + \" does not have any of {MANAGE_APPOPS, GET_APP_OPS_STATS, \"\n                            + \"MANAGE_APP_OPS_MODES}\");\n                }\n            }\n            return;\n        }\n        throw new IllegalArgumentException(\"Bad operation #\" + op);\n    }\n\n    private void verifyIncomingPackage(@Nullable String packageName, @UserIdInt int userId) {\n        if (packageName != null && getPackageManagerInternal().filterAppAccess(packageName,\n                Binder.getCallingUid(), userId)) {\n            throw new IllegalArgumentException(\n                    packageName + \" not found from \" + Binder.getCallingUid());\n        }\n    }\n\n    private boolean isCallerAndAttributionTrusted(@NonNull AttributionSource attributionSource) {\n        if (attributionSource.getUid() != Binder.getCallingUid()\n                && attributionSource.isTrusted(mContext)) {\n            return true;\n        }\n        return mContext.checkPermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null)\n                == PackageManager.PERMISSION_GRANTED;\n    }\n\n    private @Nullable UidState getUidStateLocked(int uid, boolean edit) {\n        UidState uidState = mUidStates.get(uid);\n        if (uidState == null) {\n            if (!edit) {\n                return null;\n            }\n            uidState = new UidState(uid);\n            mUidStates.put(uid, uidState);\n        } else {\n            updatePendingStateIfNeededLocked(uidState);\n        }\n        return uidState;\n    }\n\n    /**\n     * Check if the pending state should be updated and do so if needed\n     *\n     * @param uidState The uidState that might have a pending state\n     */\n    private void updatePendingStateIfNeededLocked(@NonNull UidState uidState) {\n        if (uidState != null) {\n            if (uidState.pendingStateCommitTime != 0) {\n                if (uidState.pendingStateCommitTime < mLastRealtime) {\n                    commitUidPendingStateLocked(uidState);\n                } else {\n                    mLastRealtime = SystemClock.elapsedRealtime();\n                    if (uidState.pendingStateCommitTime < mLastRealtime) {\n                        commitUidPendingStateLocked(uidState);\n                    }\n                }\n            }\n        }\n    }\n\n    private void commitUidPendingStateLocked(UidState uidState) {\n        if (uidState.hasForegroundWatchers) {\n            for (int fgi = uidState.foregroundOps.size() - 1; fgi >= 0; fgi--) {\n                if (!uidState.foregroundOps.valueAt(fgi)) {\n                    continue;\n                }\n                final int code = uidState.foregroundOps.keyAt(fgi);\n                // For location ops we consider fg state only if the fg service\n                // is of location type, for all other ops any fg service will do.\n                final long firstUnrestrictedUidState = resolveFirstUnrestrictedUidState(code);\n                final boolean resolvedLastFg = uidState.state <= firstUnrestrictedUidState;\n                final boolean resolvedNowFg = uidState.pendingState <= firstUnrestrictedUidState;\n                if (resolvedLastFg == resolvedNowFg\n                        && uidState.capability == uidState.pendingCapability\n                        && uidState.appWidgetVisible == uidState.pendingAppWidgetVisible) {\n                    continue;\n                }\n\n                if (uidState.opModes != null\n                        && uidState.opModes.indexOfKey(code) >= 0\n                        && uidState.opModes.get(code) == AppOpsManager.MODE_FOREGROUND) {\n                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                            AppOpsService::notifyOpChangedForAllPkgsInUid,\n                            this, code, uidState.uid, true, null));\n                } else if (uidState.pkgOps != null) {\n                    final ArraySet<ModeCallback> callbacks = mOpModeWatchers.get(code);\n                    if (callbacks != null) {\n                        for (int cbi = callbacks.size() - 1; cbi >= 0; cbi--) {\n                            final ModeCallback callback = callbacks.valueAt(cbi);\n                            if ((callback.mFlags & AppOpsManager.WATCH_FOREGROUND_CHANGES) == 0\n                                    || !callback.isWatchingUid(uidState.uid)) {\n                                continue;\n                            }\n                            for (int pkgi = uidState.pkgOps.size() - 1; pkgi >= 0; pkgi--) {\n                                final Op op = uidState.pkgOps.valueAt(pkgi).get(code);\n                                if (op == null) {\n                                    continue;\n                                }\n                                if (op.mode == AppOpsManager.MODE_FOREGROUND) {\n                                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                                            AppOpsService::notifyOpChanged,\n                                            this, callback, code, uidState.uid,\n                                            uidState.pkgOps.keyAt(pkgi)));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        uidState.state = uidState.pendingState;\n        uidState.capability = uidState.pendingCapability;\n        uidState.appWidgetVisible = uidState.pendingAppWidgetVisible;\n        uidState.pendingStateCommitTime = 0;\n    }\n\n    private void updateAppWidgetVisibility(SparseArray<String> uidPackageNames, boolean visible) {\n        synchronized (this) {\n            for (int i = uidPackageNames.size() - 1; i >= 0; i--) {\n                final int uid = uidPackageNames.keyAt(i);\n                final UidState uidState = getUidStateLocked(uid, true);\n                if (uidState != null && (uidState.pendingAppWidgetVisible != visible)) {\n                    uidState.pendingAppWidgetVisible = visible;\n                    if (uidState.pendingAppWidgetVisible != uidState.appWidgetVisible) {\n                        commitUidPendingStateLocked(uidState);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @return {@link PackageManagerInternal}\n     */\n    private @NonNull PackageManagerInternal getPackageManagerInternal() {\n        if (mPackageManagerInternal == null) {\n            mPackageManagerInternal = LocalServices.getService(PackageManagerInternal.class);\n        }\n\n        return mPackageManagerInternal;\n    }\n\n    /**\n     * Create a restriction description matching the properties of the package.\n     *\n     * @param pkg The package to create the restriction description for\n     *\n     * @return The restriction matching the package\n     */\n    private RestrictionBypass getBypassforPackage(@NonNull AndroidPackage pkg) {\n        return new RestrictionBypass(pkg.getUid() == Process.SYSTEM_UID, pkg.isPrivileged(),\n                mContext.checkPermission(android.Manifest.permission\n                        .EXEMPT_FROM_AUDIO_RECORD_RESTRICTIONS, -1, pkg.getUid())\n                == PackageManager.PERMISSION_GRANTED);\n    }\n\n    /**\n     * @see #verifyAndGetBypass(int, String, String, String)\n     */\n    private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n            @Nullable String attributionTag) {\n        return verifyAndGetBypass(uid, packageName, attributionTag, null);\n    }\n\n    /**\n     * Verify that package belongs to uid and return the {@link RestrictionBypass bypass\n     * description} for the package, along with a boolean indicating whether the attribution tag is\n     * valid.\n     *\n     * @param uid The uid the package belongs to\n     * @param packageName The package the might belong to the uid\n     * @param attributionTag attribution tag or {@code null} if no need to verify\n     * @param proxyPackageName The proxy package, from which the attribution tag is to be pulled\n     *\n     * @return PackageVerificationResult containing {@link RestrictionBypass} and whether the\n     *         attribution tag is valid\n     */\n    private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n            @Nullable String attributionTag, @Nullable String proxyPackageName) {\n        if (uid == Process.ROOT_UID) {\n            // For backwards compatibility, don't check package name for root UID.\n            return new PackageVerificationResult(null,\n                    /* isAttributionTagValid */ true);\n        }\n        if (Process.isSdkSandboxUid(uid)) {\n            // SDK sandbox processes run in their own UID range, but their associated\n            // UID for checks should always be the UID of the package implementing SDK sandbox\n            // service.\n            // TODO: We will need to modify the callers of this function instead, so\n            // modifications and checks against the app ops state are done with the\n            // correct UID.\n            try {\n                final PackageManager pm = mContext.getPackageManager();\n                final String supplementalPackageName = pm.getSdkSandboxPackageName();\n                if (Objects.equals(packageName, supplementalPackageName)) {\n                    int supplementalAppId = pm.getPackageUid(supplementalPackageName,\n                            PackageManager.PackageInfoFlags.of(0));\n                    uid = UserHandle.getUid(UserHandle.getUserId(uid), supplementalAppId);\n                }\n            } catch (PackageManager.NameNotFoundException e) {\n                // Shouldn't happen for the supplemental package\n                e.printStackTrace();\n            }\n        }\n\n\n        // Do not check if uid/packageName/attributionTag is already known.\n        synchronized (this) {\n            UidState uidState = mUidStates.get(uid);\n            if (uidState != null && uidState.pkgOps != null) {\n                Ops ops = uidState.pkgOps.get(packageName);\n\n                if (ops != null && (attributionTag == null || ops.knownAttributionTags.contains(\n                        attributionTag)) && ops.bypass != null) {\n                    return new PackageVerificationResult(ops.bypass,\n                            ops.validAttributionTags.contains(attributionTag));\n                }\n            }\n        }\n\n        int callingUid = Binder.getCallingUid();\n\n        // Allow any attribution tag for resolvable uids\n        int pkgUid;\n        if (Objects.equals(packageName, \"com.android.shell\")) {\n            // Special case for the shell which is a package but should be able\n            // to bypass app attribution tag restrictions.\n            pkgUid = Process.SHELL_UID;\n        } else {\n            pkgUid = resolveUid(packageName);\n        }\n        if (pkgUid != Process.INVALID_UID) {\n            if (pkgUid != UserHandle.getAppId(uid)) {\n                Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n                        + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid + \".\");\n                String otherUidMessage = DEBUG ? \" but it is really \" + pkgUid : \" but it is not\";\n                throw new SecurityException(\"Specified package \\\"\" + packageName + \"\\\" under uid \"\n                        +  UserHandle.getAppId(uid) + otherUidMessage);\n            }\n            return new PackageVerificationResult(RestrictionBypass.UNRESTRICTED,\n                    /* isAttributionTagValid */ true);\n        }\n\n        int userId = UserHandle.getUserId(uid);\n        RestrictionBypass bypass = null;\n        boolean isAttributionTagValid = false;\n\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n            AndroidPackage pkg = pmInt.getPackage(packageName);\n            if (pkg != null) {\n                isAttributionTagValid = isAttributionInPackage(pkg, attributionTag);\n                pkgUid = UserHandle.getUid(userId, UserHandle.getAppId(pkg.getUid()));\n                bypass = getBypassforPackage(pkg);\n            }\n            if (!isAttributionTagValid) {\n                AndroidPackage proxyPkg = proxyPackageName != null\n                        ? pmInt.getPackage(proxyPackageName) : null;\n                // Re-check in proxy.\n                isAttributionTagValid = isAttributionInPackage(proxyPkg, attributionTag);\n                String msg;\n                if (pkg != null && isAttributionTagValid) {\n                    msg = \"attributionTag \" + attributionTag + \" declared in manifest of the proxy\"\n                            + \" package \" + proxyPackageName + \", this is not advised\";\n                } else if (pkg != null) {\n                    msg = \"attributionTag \" + attributionTag + \" not declared in manifest of \"\n                            + packageName;\n                } else {\n                    msg = \"package \" + packageName + \" not found, can't check for \"\n                            + \"attributionTag \" + attributionTag;\n                }\n\n                try {\n                    if (!mPlatformCompat.isChangeEnabledByPackageName(\n                            SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE, packageName,\n                            userId) || !mPlatformCompat.isChangeEnabledByUid(\n                                    SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE,\n                            callingUid)) {\n                        // Do not override tags if overriding is not enabled for this package\n                        isAttributionTagValid = true;\n                    }\n                    Slog.e(TAG, msg);\n                } catch (RemoteException neverHappens) {\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n\n        if (pkgUid != uid) {\n            Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n                    + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid + \".\");\n            String otherUidMessage = DEBUG ? \" but it is really \" + pkgUid : \" but it is not\";\n            throw new SecurityException(\"Specified package \\\"\" + packageName + \"\\\" under uid \" + uid\n                    + otherUidMessage);\n        }\n\n        return new PackageVerificationResult(bypass, isAttributionTagValid);\n    }\n\n    private boolean isAttributionInPackage(@Nullable AndroidPackage pkg,\n            @Nullable String attributionTag) {\n        if (pkg == null) {\n            return false;\n        } else if (attributionTag == null) {\n            return true;\n        }\n        if (pkg.getAttributions() != null) {\n            int numAttributions = pkg.getAttributions().size();\n            for (int i = 0; i < numAttributions; i++) {\n                if (pkg.getAttributions().get(i).getTag().equals(attributionTag)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n     * This method is intended for ProxyAttributionTag validation and returns false\n     * if it does not exist in either one of them.\n     *\n     * @param packageName Name of the package\n     * @param proxyPackageName Name of the proxy package\n     * @param attributionTag attribution tag to be checked\n     *\n     * @return boolean specifying if attribution tag is valid or not\n     */\n    private boolean isAttributionTagDefined(@Nullable String packageName,\n                                            @Nullable String proxyPackageName,\n                                            @Nullable String attributionTag) {\n        if (packageName == null) {\n            return false;\n        } else if (attributionTag == null) {\n            return true;\n        }\n        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n        if (proxyPackageName != null) {\n            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n                return true;\n            }\n        }\n        AndroidPackage pkg = pmInt.getPackage(packageName);\n        return isAttributionInPackage(pkg, attributionTag);\n    }\n\n    /**\n     * Get (and potentially create) ops.\n     *\n     * @param uid The uid the package belongs to\n     * @param packageName The name of the package\n     * @param attributionTag attribution tag\n     * @param isAttributionTagValid whether the given attribution tag is valid\n     * @param bypass When to bypass certain op restrictions (can be null if edit == false)\n     * @param edit If an ops does not exist, create the ops?\n\n     * @return The ops\n     */\n    private Ops getOpsLocked(int uid, String packageName, @Nullable String attributionTag,\n            boolean isAttributionTagValid, @Nullable RestrictionBypass bypass, boolean edit) {\n        UidState uidState = getUidStateLocked(uid, edit);\n        if (uidState == null) {\n            return null;\n        }\n\n        if (uidState.pkgOps == null) {\n            if (!edit) {\n                return null;\n            }\n            uidState.pkgOps = new ArrayMap<>();\n        }\n\n        Ops ops = uidState.pkgOps.get(packageName);\n        if (ops == null) {\n            if (!edit) {\n                return null;\n            }\n            ops = new Ops(packageName, uidState);\n            uidState.pkgOps.put(packageName, ops);\n        }\n\n        if (edit) {\n            if (bypass != null) {\n                ops.bypass = bypass;\n            }\n\n            if (attributionTag != null) {\n                ops.knownAttributionTags.add(attributionTag);\n                if (isAttributionTagValid) {\n                    ops.validAttributionTags.add(attributionTag);\n                } else {\n                    ops.validAttributionTags.remove(attributionTag);\n                }\n            }\n        }\n\n        return ops;\n    }\n\n    private void scheduleWriteLocked() {\n        if (!mWriteScheduled) {\n            mWriteScheduled = true;\n            mHandler.postDelayed(mWriteRunner, WRITE_DELAY);\n        }\n    }\n\n    private void scheduleFastWriteLocked() {\n        if (!mFastWriteScheduled) {\n            mWriteScheduled = true;\n            mFastWriteScheduled = true;\n            mHandler.removeCallbacks(mWriteRunner);\n            mHandler.postDelayed(mWriteRunner, 10*1000);\n        }\n    }\n\n    /**\n     * Get the state of an op for a uid.\n     *\n     * @param code The code of the op\n     * @param uid The uid the of the package\n     * @param packageName The package name for which to get the state for\n     * @param attributionTag The attribution tag\n     * @param isAttributionTagValid Whether the given attribution tag is valid\n     * @param bypass When to bypass certain op restrictions (can be null if edit == false)\n     * @param edit Iff {@code true} create the {@link Op} object if not yet created\n     *\n     * @return The {@link Op state} of the op\n     */\n    private @Nullable Op getOpLocked(int code, int uid, @NonNull String packageName,\n            @Nullable String attributionTag, boolean isAttributionTagValid,\n            @Nullable RestrictionBypass bypass, boolean edit) {\n        Ops ops = getOpsLocked(uid, packageName, attributionTag, isAttributionTagValid, bypass,\n                edit);\n        if (ops == null) {\n            return null;\n        }\n        return getOpLocked(ops, code, uid, edit);\n    }\n\n    private Op getOpLocked(Ops ops, int code, int uid, boolean edit) {\n        Op op = ops.get(code);\n        if (op == null) {\n            if (!edit) {\n                return null;\n            }\n            op = new Op(ops.uidState, ops.packageName, code, uid);\n            ops.put(code, op);\n        }\n        if (edit) {\n            scheduleWriteLocked();\n        }\n        return op;\n    }\n\n    private boolean isOpRestrictedDueToSuspend(int code, String packageName, int uid) {\n        if (!ArrayUtils.contains(OPS_RESTRICTED_ON_SUSPEND, code)) {\n            return false;\n        }\n        final PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n        return pmi.isPackageSuspended(packageName, UserHandle.getUserId(uid));\n    }\n\n    private boolean isOpRestrictedLocked(int uid, int code, String packageName,\n            String attributionTag, @Nullable RestrictionBypass appBypass, boolean isCheckOp) {\n        int restrictionSetCount = mOpGlobalRestrictions.size();\n\n        for (int i = 0; i < restrictionSetCount; i++) {\n            ClientGlobalRestrictionState restrictionState = mOpGlobalRestrictions.valueAt(i);\n            if (restrictionState.hasRestriction(code)) {\n                return true;\n            }\n        }\n\n        int userHandle = UserHandle.getUserId(uid);\n        restrictionSetCount = mOpUserRestrictions.size();\n\n        for (int i = 0; i < restrictionSetCount; i++) {\n            // For each client, check that the given op is not restricted, or that the given\n            // package is exempt from the restriction.\n            ClientUserRestrictionState restrictionState = mOpUserRestrictions.valueAt(i);\n            if (restrictionState.hasRestriction(code, packageName, attributionTag, userHandle,\n                    isCheckOp)) {\n                RestrictionBypass opBypass = opAllowSystemBypassRestriction(code);\n                if (opBypass != null) {\n                    // If we are the system, bypass user restrictions for certain codes\n                    synchronized (this) {\n                        if (opBypass.isSystemUid && appBypass != null && appBypass.isSystemUid) {\n                            return false;\n                        }\n                        if (opBypass.isPrivileged && appBypass != null && appBypass.isPrivileged) {\n                            return false;\n                        }\n                        if (opBypass.isRecordAudioRestrictionExcept && appBypass != null\n                                && appBypass.isRecordAudioRestrictionExcept) {\n                            return false;\n                        }\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    void readState() {\n        int oldVersion = NO_VERSION;\n        synchronized (mFile) {\n            synchronized (this) {\n                FileInputStream stream;\n                try {\n                    stream = mFile.openRead();\n                } catch (FileNotFoundException e) {\n                    Slog.i(TAG, \"No existing app ops \" + mFile.getBaseFile() + \"; starting empty\");\n                    return;\n                }\n                boolean success = false;\n                mUidStates.clear();\n                try {\n                    TypedXmlPullParser parser = Xml.resolvePullParser(stream);\n                    int type;\n                    while ((type = parser.next()) != XmlPullParser.START_TAG\n                            && type != XmlPullParser.END_DOCUMENT) {\n                        ;\n                    }\n\n                    if (type != XmlPullParser.START_TAG) {\n                        throw new IllegalStateException(\"no start tag found\");\n                    }\n\n                    oldVersion = parser.getAttributeInt(null, \"v\", NO_VERSION);\n\n                    int outerDepth = parser.getDepth();\n                    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                            && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n                        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                            continue;\n                        }\n\n                        String tagName = parser.getName();\n                        if (tagName.equals(\"pkg\")) {\n                            readPackage(parser);\n                        } else if (tagName.equals(\"uid\")) {\n                            readUidOps(parser);\n                        } else {\n                            Slog.w(TAG, \"Unknown element under <app-ops>: \"\n                                    + parser.getName());\n                            XmlUtils.skipCurrentTag(parser);\n                        }\n                    }\n                    success = true;\n                } catch (IllegalStateException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (NullPointerException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (NumberFormatException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (XmlPullParserException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (IOException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (IndexOutOfBoundsException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } finally {\n                    if (!success) {\n                        mUidStates.clear();\n                    }\n                    try {\n                        stream.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n        synchronized (this) {\n            upgradeLocked(oldVersion);\n        }\n    }\n\n    private void upgradeRunAnyInBackgroundLocked() {\n        for (int i = 0; i < mUidStates.size(); i++) {\n            final UidState uidState = mUidStates.valueAt(i);\n            if (uidState == null) {\n                continue;\n            }\n            if (uidState.opModes != null) {\n                final int idx = uidState.opModes.indexOfKey(AppOpsManager.OP_RUN_IN_BACKGROUND);\n                if (idx >= 0) {\n                    uidState.opModes.put(AppOpsManager.OP_RUN_ANY_IN_BACKGROUND,\n                        uidState.opModes.valueAt(idx));\n                }\n            }\n            if (uidState.pkgOps == null) {\n                continue;\n            }\n            boolean changed = false;\n            for (int j = 0; j < uidState.pkgOps.size(); j++) {\n                Ops ops = uidState.pkgOps.valueAt(j);\n                if (ops != null) {\n                    final Op op = ops.get(AppOpsManager.OP_RUN_IN_BACKGROUND);\n                    if (op != null && op.mode != AppOpsManager.opToDefaultMode(op.op)) {\n                        final Op copy = new Op(op.uidState, op.packageName,\n                                AppOpsManager.OP_RUN_ANY_IN_BACKGROUND, uidState.uid);\n                        copy.mode = op.mode;\n                        ops.put(AppOpsManager.OP_RUN_ANY_IN_BACKGROUND, copy);\n                        changed = true;\n                    }\n                }\n            }\n            if (changed) {\n                uidState.evalForegroundOps(mOpModeWatchers);\n            }\n        }\n    }\n\n    private void upgradeLocked(int oldVersion) {\n        if (oldVersion >= CURRENT_VERSION) {\n            return;\n        }\n        Slog.d(TAG, \"Upgrading app-ops xml from version \" + oldVersion + \" to \" + CURRENT_VERSION);\n        switch (oldVersion) {\n            case NO_VERSION:\n                upgradeRunAnyInBackgroundLocked();\n                // fall through\n            case 1:\n                // for future upgrades\n        }\n        scheduleFastWriteLocked();\n    }\n\n    private void readUidOps(TypedXmlPullParser parser) throws NumberFormatException,\n            XmlPullParserException, IOException {\n        final int uid = parser.getAttributeInt(null, \"n\");\n        int outerDepth = parser.getDepth();\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                continue;\n            }\n\n            String tagName = parser.getName();\n            if (tagName.equals(\"op\")) {\n                final int code = parser.getAttributeInt(null, \"n\");\n                final int mode = parser.getAttributeInt(null, \"m\");\n                setUidMode(code, uid, mode);\n            } else {\n                Slog.w(TAG, \"Unknown element under <uid-ops>: \"\n                        + parser.getName());\n                XmlUtils.skipCurrentTag(parser);\n            }\n        }\n    }\n\n    private void readPackage(TypedXmlPullParser parser)\n            throws NumberFormatException, XmlPullParserException, IOException {\n        String pkgName = parser.getAttributeValue(null, \"n\");\n        int outerDepth = parser.getDepth();\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                continue;\n            }\n\n            String tagName = parser.getName();\n            if (tagName.equals(\"uid\")) {\n                readUid(parser, pkgName);\n            } else {\n                Slog.w(TAG, \"Unknown element under <pkg>: \"\n                        + parser.getName());\n                XmlUtils.skipCurrentTag(parser);\n            }\n        }\n    }\n\n    private void readUid(TypedXmlPullParser parser, String pkgName)\n            throws NumberFormatException, XmlPullParserException, IOException {\n        int uid = parser.getAttributeInt(null, \"n\");\n        final UidState uidState = getUidStateLocked(uid, true);\n        int outerDepth = parser.getDepth();\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                continue;\n            }\n            String tagName = parser.getName();\n            if (tagName.equals(\"op\")) {\n                readOp(parser, uidState, pkgName);\n            } else {\n                Slog.w(TAG, \"Unknown element under <pkg>: \"\n                        + parser.getName());\n                XmlUtils.skipCurrentTag(parser);\n            }\n        }\n        uidState.evalForegroundOps(mOpModeWatchers);\n    }\n\n    private void readAttributionOp(TypedXmlPullParser parser, @NonNull Op parent,\n            @Nullable String attribution)\n            throws NumberFormatException, IOException, XmlPullParserException {\n        final AttributedOp attributedOp = parent.getOrCreateAttribution(parent, attribution);\n\n        final long key = parser.getAttributeLong(null, \"n\");\n        final int uidState = extractUidStateFromKey(key);\n        final int opFlags = extractFlagsFromKey(key);\n\n        final long accessTime = parser.getAttributeLong(null, \"t\", 0);\n        final long rejectTime = parser.getAttributeLong(null, \"r\", 0);\n        final long accessDuration = parser.getAttributeLong(null, \"d\", -1);\n        final String proxyPkg = XmlUtils.readStringAttribute(parser, \"pp\");\n        final int proxyUid = parser.getAttributeInt(null, \"pu\", Process.INVALID_UID);\n        final String proxyAttributionTag = XmlUtils.readStringAttribute(parser, \"pc\");\n\n        if (accessTime > 0) {\n            attributedOp.accessed(accessTime, accessDuration, proxyUid, proxyPkg,\n                    proxyAttributionTag, uidState, opFlags);\n        }\n        if (rejectTime > 0) {\n            attributedOp.rejected(rejectTime, uidState, opFlags);\n        }\n    }\n\n    private void readOp(TypedXmlPullParser parser,\n            @NonNull UidState uidState, @NonNull String pkgName)\n            throws NumberFormatException, XmlPullParserException, IOException {\n        int opCode = parser.getAttributeInt(null, \"n\");\n        Op op = new Op(uidState, pkgName, opCode, uidState.uid);\n\n        final int mode = parser.getAttributeInt(null, \"m\", AppOpsManager.opToDefaultMode(op.op));\n        op.mode = mode;\n\n        int outerDepth = parser.getDepth();\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                continue;\n            }\n            String tagName = parser.getName();\n            if (tagName.equals(\"st\")) {\n                readAttributionOp(parser, op, XmlUtils.readStringAttribute(parser, \"id\"));\n            } else {\n                Slog.w(TAG, \"Unknown element under <op>: \"\n                        + parser.getName());\n                XmlUtils.skipCurrentTag(parser);\n            }\n        }\n\n        if (uidState.pkgOps == null) {\n            uidState.pkgOps = new ArrayMap<>();\n        }\n        Ops ops = uidState.pkgOps.get(pkgName);\n        if (ops == null) {\n            ops = new Ops(pkgName, uidState);\n            uidState.pkgOps.put(pkgName, ops);\n        }\n        ops.put(op.op, op);\n    }\n\n    void writeState() {\n        synchronized (mFile) {\n            FileOutputStream stream;\n            try {\n                stream = mFile.startWrite();\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to write state: \" + e);\n                return;\n            }\n\n            List<AppOpsManager.PackageOps> allOps = getPackagesForOps(null);\n\n            try {\n                TypedXmlSerializer out = Xml.resolveSerializer(stream);\n                out.startDocument(null, true);\n                out.startTag(null, \"app-ops\");\n                out.attributeInt(null, \"v\", CURRENT_VERSION);\n\n                SparseArray<SparseIntArray> uidStatesClone;\n                synchronized (this) {\n                    uidStatesClone = new SparseArray<>(mUidStates.size());\n\n                    final int uidStateCount = mUidStates.size();\n                    for (int uidStateNum = 0; uidStateNum < uidStateCount; uidStateNum++) {\n                        UidState uidState = mUidStates.valueAt(uidStateNum);\n                        int uid = mUidStates.keyAt(uidStateNum);\n\n                        SparseIntArray opModes = uidState.opModes;\n                        if (opModes != null && opModes.size() > 0) {\n                            uidStatesClone.put(uid, new SparseIntArray(opModes.size()));\n\n                            final int opCount = opModes.size();\n                            for (int opCountNum = 0; opCountNum < opCount; opCountNum++) {\n                                uidStatesClone.get(uid).put(\n                                        opModes.keyAt(opCountNum),\n                                        opModes.valueAt(opCountNum));\n                            }\n                        }\n                    }\n                }\n\n                final int uidStateCount = uidStatesClone.size();\n                for (int uidStateNum = 0; uidStateNum < uidStateCount; uidStateNum++) {\n                    SparseIntArray opModes = uidStatesClone.valueAt(uidStateNum);\n                    if (opModes != null && opModes.size() > 0) {\n                        out.startTag(null, \"uid\");\n                        out.attributeInt(null, \"n\", uidStatesClone.keyAt(uidStateNum));\n                        final int opCount = opModes.size();\n                        for (int opCountNum = 0; opCountNum < opCount; opCountNum++) {\n                            final int op = opModes.keyAt(opCountNum);\n                            final int mode = opModes.valueAt(opCountNum);\n                            out.startTag(null, \"op\");\n                            out.attributeInt(null, \"n\", op);\n                            out.attributeInt(null, \"m\", mode);\n                            out.endTag(null, \"op\");\n                        }\n                        out.endTag(null, \"uid\");\n                    }\n                }\n\n                if (allOps != null) {\n                    String lastPkg = null;\n                    for (int i=0; i<allOps.size(); i++) {\n                        AppOpsManager.PackageOps pkg = allOps.get(i);\n                        if (!Objects.equals(pkg.getPackageName(), lastPkg)) {\n                            if (lastPkg != null) {\n                                out.endTag(null, \"pkg\");\n                            }\n                            lastPkg = pkg.getPackageName();\n                            if (lastPkg != null) {\n                                out.startTag(null, \"pkg\");\n                                out.attribute(null, \"n\", lastPkg);\n                            }\n                        }\n                        out.startTag(null, \"uid\");\n                        out.attributeInt(null, \"n\", pkg.getUid());\n                        List<AppOpsManager.OpEntry> ops = pkg.getOps();\n                        for (int j=0; j<ops.size(); j++) {\n                            AppOpsManager.OpEntry op = ops.get(j);\n                            out.startTag(null, \"op\");\n                            out.attributeInt(null, \"n\", op.getOp());\n                            if (op.getMode() != AppOpsManager.opToDefaultMode(op.getOp())) {\n                                out.attributeInt(null, \"m\", op.getMode());\n                            }\n\n                            for (String attributionTag : op.getAttributedOpEntries().keySet()) {\n                                final AttributedOpEntry attribution =\n                                        op.getAttributedOpEntries().get(attributionTag);\n\n                                final ArraySet<Long> keys = attribution.collectKeys();\n\n                                final int keyCount = keys.size();\n                                for (int k = 0; k < keyCount; k++) {\n                                    final long key = keys.valueAt(k);\n\n                                    final int uidState = AppOpsManager.extractUidStateFromKey(key);\n                                    final int flags = AppOpsManager.extractFlagsFromKey(key);\n\n                                    final long accessTime = attribution.getLastAccessTime(uidState,\n                                            uidState, flags);\n                                    final long rejectTime = attribution.getLastRejectTime(uidState,\n                                            uidState, flags);\n                                    final long accessDuration = attribution.getLastDuration(\n                                            uidState, uidState, flags);\n                                    // Proxy information for rejections is not backed up\n                                    final OpEventProxyInfo proxy = attribution.getLastProxyInfo(\n                                            uidState, uidState, flags);\n\n                                    if (accessTime <= 0 && rejectTime <= 0 && accessDuration <= 0\n                                            && proxy == null) {\n                                        continue;\n                                    }\n\n                                    String proxyPkg = null;\n                                    String proxyAttributionTag = null;\n                                    int proxyUid = Process.INVALID_UID;\n                                    if (proxy != null) {\n                                        proxyPkg = proxy.getPackageName();\n                                        proxyAttributionTag = proxy.getAttributionTag();\n                                        proxyUid = proxy.getUid();\n                                    }\n\n                                    out.startTag(null, \"st\");\n                                    if (attributionTag != null) {\n                                        out.attribute(null, \"id\", attributionTag);\n                                    }\n                                    out.attributeLong(null, \"n\", key);\n                                    if (accessTime > 0) {\n                                        out.attributeLong(null, \"t\", accessTime);\n                                    }\n                                    if (rejectTime > 0) {\n                                        out.attributeLong(null, \"r\", rejectTime);\n                                    }\n                                    if (accessDuration > 0) {\n                                        out.attributeLong(null, \"d\", accessDuration);\n                                    }\n                                    if (proxyPkg != null) {\n                                        out.attribute(null, \"pp\", proxyPkg);\n                                    }\n                                    if (proxyAttributionTag != null) {\n                                        out.attribute(null, \"pc\", proxyAttributionTag);\n                                    }\n                                    if (proxyUid >= 0) {\n                                        out.attributeInt(null, \"pu\", proxyUid);\n                                    }\n                                    out.endTag(null, \"st\");\n                                }\n                            }\n\n                            out.endTag(null, \"op\");\n                        }\n                        out.endTag(null, \"uid\");\n                    }\n                    if (lastPkg != null) {\n                        out.endTag(null, \"pkg\");\n                    }\n                }\n\n                out.endTag(null, \"app-ops\");\n                out.endDocument();\n                mFile.finishWrite(stream);\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to write state, restoring backup.\", e);\n                mFile.failWrite(stream);\n            }\n        }\n        mHistoricalRegistry.writeAndClearDiscreteHistory();\n    }\n\n    static class Shell extends ShellCommand {\n        final IAppOpsService mInterface;\n        final AppOpsService mInternal;\n\n        int userId = UserHandle.USER_SYSTEM;\n        String packageName;\n        String attributionTag;\n        String opStr;\n        String modeStr;\n        int op;\n        int mode;\n        int packageUid;\n        int nonpackageUid;\n        final static Binder sBinder = new Binder();\n        IBinder mToken;\n        boolean targetsUid;\n\n        Shell(IAppOpsService iface, AppOpsService internal) {\n            mInterface = iface;\n            mInternal = internal;\n            mToken = AppOpsManager.getClientId();\n        }\n\n        @Override\n        public int onCommand(String cmd) {\n            return onShellCommand(this, cmd);\n        }\n\n        @Override\n        public void onHelp() {\n            PrintWriter pw = getOutPrintWriter();\n            dumpCommandHelp(pw);\n        }\n\n        static private int strOpToOp(String op, PrintWriter err) {\n            try {\n                return AppOpsManager.strOpToOp(op);\n            } catch (IllegalArgumentException e) {\n            }\n            try {\n                return Integer.parseInt(op);\n            } catch (NumberFormatException e) {\n            }\n            try {\n                return AppOpsManager.strDebugOpToOp(op);\n            } catch (IllegalArgumentException e) {\n                err.println(\"Error: \" + e.getMessage());\n                return -1;\n            }\n        }\n\n        static int strModeToMode(String modeStr, PrintWriter err) {\n            for (int i = AppOpsManager.MODE_NAMES.length - 1; i >= 0; i--) {\n                if (AppOpsManager.MODE_NAMES[i].equals(modeStr)) {\n                    return i;\n                }\n            }\n            try {\n                return Integer.parseInt(modeStr);\n            } catch (NumberFormatException e) {\n            }\n            err.println(\"Error: Mode \" + modeStr + \" is not valid\");\n            return -1;\n        }\n\n        int parseUserOpMode(int defMode, PrintWriter err) throws RemoteException {\n            userId = UserHandle.USER_CURRENT;\n            opStr = null;\n            modeStr = null;\n            for (String argument; (argument = getNextArg()) != null;) {\n                if (\"--user\".equals(argument)) {\n                    userId = UserHandle.parseUserArg(getNextArgRequired());\n                } else {\n                    if (opStr == null) {\n                        opStr = argument;\n                    } else if (modeStr == null) {\n                        modeStr = argument;\n                        break;\n                    }\n                }\n            }\n            if (opStr == null) {\n                err.println(\"Error: Operation not specified.\");\n                return -1;\n            }\n            op = strOpToOp(opStr, err);\n            if (op < 0) {\n                return -1;\n            }\n            if (modeStr != null) {\n                if ((mode=strModeToMode(modeStr, err)) < 0) {\n                    return -1;\n                }\n            } else {\n                mode = defMode;\n            }\n            return 0;\n        }\n\n        int parseUserPackageOp(boolean reqOp, PrintWriter err) throws RemoteException {\n            userId = UserHandle.USER_CURRENT;\n            packageName = null;\n            opStr = null;\n            for (String argument; (argument = getNextArg()) != null;) {\n                if (\"--user\".equals(argument)) {\n                    userId = UserHandle.parseUserArg(getNextArgRequired());\n                } else if (\"--uid\".equals(argument)) {\n                    targetsUid = true;\n                } else if (\"--attribution\".equals(argument)) {\n                    attributionTag = getNextArgRequired();\n                } else {\n                    if (packageName == null) {\n                        packageName = argument;\n                    } else if (opStr == null) {\n                        opStr = argument;\n                        break;\n                    }\n                }\n            }\n            if (packageName == null) {\n                err.println(\"Error: Package name not specified.\");\n                return -1;\n            } else if (opStr == null && reqOp) {\n                err.println(\"Error: Operation not specified.\");\n                return -1;\n            }\n            if (opStr != null) {\n                op = strOpToOp(opStr, err);\n                if (op < 0) {\n                    return -1;\n                }\n            } else {\n                op = AppOpsManager.OP_NONE;\n            }\n            if (userId == UserHandle.USER_CURRENT) {\n                userId = ActivityManager.getCurrentUser();\n            }\n            nonpackageUid = -1;\n            try {\n                nonpackageUid = Integer.parseInt(packageName);\n            } catch (NumberFormatException e) {\n            }\n            if (nonpackageUid == -1 && packageName.length() > 1 && packageName.charAt(0) == 'u'\n                    && packageName.indexOf('.') < 0) {\n                int i = 1;\n                while (i < packageName.length() && packageName.charAt(i) >= '0'\n                        && packageName.charAt(i) <= '9') {\n                    i++;\n                }\n                if (i > 1 && i < packageName.length()) {\n                    String userStr = packageName.substring(1, i);\n                    try {\n                        int user = Integer.parseInt(userStr);\n                        char type = packageName.charAt(i);\n                        i++;\n                        int startTypeVal = i;\n                        while (i < packageName.length() && packageName.charAt(i) >= '0'\n                                && packageName.charAt(i) <= '9') {\n                            i++;\n                        }\n                        if (i > startTypeVal) {\n                            String typeValStr = packageName.substring(startTypeVal, i);\n                            try {\n                                int typeVal = Integer.parseInt(typeValStr);\n                                if (type == 'a') {\n                                    nonpackageUid = UserHandle.getUid(user,\n                                            typeVal + Process.FIRST_APPLICATION_UID);\n                                } else if (type == 's') {\n                                    nonpackageUid = UserHandle.getUid(user, typeVal);\n                                }\n                            } catch (NumberFormatException e) {\n                            }\n                        }\n                    } catch (NumberFormatException e) {\n                    }\n                }\n            }\n            if (nonpackageUid != -1) {\n                packageName = null;\n            } else {\n                packageUid = resolveUid(packageName);\n                if (packageUid < 0) {\n                    packageUid = AppGlobals.getPackageManager().getPackageUid(packageName,\n                            PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);\n                }\n                if (packageUid < 0) {\n                    err.println(\"Error: No UID for \" + packageName + \" in user \" + userId);\n                    return -1;\n                }\n            }\n            return 0;\n        }\n    }\n\n    @Override public void onShellCommand(FileDescriptor in, FileDescriptor out,\n            FileDescriptor err, String[] args, ShellCallback callback,\n            ResultReceiver resultReceiver) {\n        (new Shell(this, this)).exec(this, in, out, err, args, callback, resultReceiver);\n    }\n\n    static void dumpCommandHelp(PrintWriter pw) {\n        pw.println(\"AppOps service (appops) commands:\");\n        pw.println(\"  help\");\n        pw.println(\"    Print this help text.\");\n        pw.println(\"  start [--user <USER_ID>] [--attribution <ATTRIBUTION_TAG>] <PACKAGE | UID> \"\n                + \"<OP> \");\n        pw.println(\"    Starts a given operation for a particular application.\");\n        pw.println(\"  stop [--user <USER_ID>] [--attribution <ATTRIBUTION_TAG>] <PACKAGE | UID> \"\n                + \"<OP> \");\n        pw.println(\"    Stops a given operation for a particular application.\");\n        pw.println(\"  set [--user <USER_ID>] <[--uid] PACKAGE | UID> <OP> <MODE>\");\n        pw.println(\"    Set the mode for a particular application and operation.\");\n        pw.println(\"  get [--user <USER_ID>] [--attribution <ATTRIBUTION_TAG>] <PACKAGE | UID> \"\n                + \"[<OP>]\");\n        pw.println(\"    Return the mode for a particular application and optional operation.\");\n        pw.println(\"  query-op [--user <USER_ID>] <OP> [<MODE>]\");\n        pw.println(\"    Print all packages that currently have the given op in the given mode.\");\n        pw.println(\"  reset [--user <USER_ID>] [<PACKAGE>]\");\n        pw.println(\"    Reset the given application or all applications to default modes.\");\n        pw.println(\"  write-settings\");\n        pw.println(\"    Immediately write pending changes to storage.\");\n        pw.println(\"  read-settings\");\n        pw.println(\"    Read the last written settings, replacing current state in RAM.\");\n        pw.println(\"  options:\");\n        pw.println(\"    <PACKAGE> an Android package name or its UID if prefixed by --uid\");\n        pw.println(\"    <OP>      an AppOps operation.\");\n        pw.println(\"    <MODE>    one of allow, ignore, deny, or default\");\n        pw.println(\"    <USER_ID> the user id under which the package is installed. If --user is\");\n        pw.println(\"              not specified, the current user is assumed.\");\n    }\n\n    static int onShellCommand(Shell shell, String cmd) {\n        if (cmd == null) {\n            return shell.handleDefaultCommands(cmd);\n        }\n        PrintWriter pw = shell.getOutPrintWriter();\n        PrintWriter err = shell.getErrPrintWriter();\n        try {\n            switch (cmd) {\n                case \"set\": {\n                    int res = shell.parseUserPackageOp(true, err);\n                    if (res < 0) {\n                        return res;\n                    }\n                    String modeStr = shell.getNextArg();\n                    if (modeStr == null) {\n                        err.println(\"Error: Mode not specified.\");\n                        return -1;\n                    }\n\n                    final int mode = shell.strModeToMode(modeStr, err);\n                    if (mode < 0) {\n                        return -1;\n                    }\n\n                    if (!shell.targetsUid && shell.packageName != null) {\n                        shell.mInterface.setMode(shell.op, shell.packageUid, shell.packageName,\n                                mode);\n                    } else if (shell.targetsUid && shell.packageName != null) {\n                        try {\n                            final int uid = shell.mInternal.mContext.getPackageManager()\n                                    .getPackageUidAsUser(shell.packageName, shell.userId);\n                            shell.mInterface.setUidMode(shell.op, uid, mode);\n                        } catch (PackageManager.NameNotFoundException e) {\n                            return -1;\n                        }\n                    } else {\n                        shell.mInterface.setUidMode(shell.op, shell.nonpackageUid, mode);\n                    }\n                    return 0;\n                }\n                case \"get\": {\n                    int res = shell.parseUserPackageOp(false, err);\n                    if (res < 0) {\n                        return res;\n                    }\n\n                    List<AppOpsManager.PackageOps> ops = new ArrayList<>();\n                    if (shell.packageName != null) {\n                        // Uid mode overrides package mode, so make sure it's also reported\n                        List<AppOpsManager.PackageOps> r = shell.mInterface.getUidOps(\n                                shell.packageUid,\n                                shell.op != AppOpsManager.OP_NONE ? new int[]{shell.op} : null);\n                        if (r != null) {\n                            ops.addAll(r);\n                        }\n                        r = shell.mInterface.getOpsForPackage(\n                                shell.packageUid, shell.packageName,\n                                shell.op != AppOpsManager.OP_NONE ? new int[]{shell.op} : null);\n                        if (r != null) {\n                            ops.addAll(r);\n                        }\n                    } else {\n                        ops = shell.mInterface.getUidOps(\n                                shell.nonpackageUid,\n                                shell.op != AppOpsManager.OP_NONE ? new int[]{shell.op} : null);\n                    }\n                    if (ops == null || ops.size() <= 0) {\n                        pw.println(\"No operations.\");\n                        if (shell.op > AppOpsManager.OP_NONE && shell.op < AppOpsManager._NUM_OP) {\n                            pw.println(\"Default mode: \" + AppOpsManager.modeToName(\n                                    AppOpsManager.opToDefaultMode(shell.op)));\n                        }\n                        return 0;\n                    }\n                    final long now = System.currentTimeMillis();\n                    for (int i=0; i<ops.size(); i++) {\n                        AppOpsManager.PackageOps packageOps = ops.get(i);\n                        if (packageOps.getPackageName() == null) {\n                            pw.print(\"Uid mode: \");\n                        }\n                        List<AppOpsManager.OpEntry> entries = packageOps.getOps();\n                        for (int j=0; j<entries.size(); j++) {\n                            AppOpsManager.OpEntry ent = entries.get(j);\n                            pw.print(AppOpsManager.opToName(ent.getOp()));\n                            pw.print(\": \");\n                            pw.print(AppOpsManager.modeToName(ent.getMode()));\n                            if (shell.attributionTag == null) {\n                                if (ent.getLastAccessTime(OP_FLAGS_ALL) != -1) {\n                                    pw.print(\"; time=\");\n                                    TimeUtils.formatDuration(\n                                            now - ent.getLastAccessTime(OP_FLAGS_ALL), pw);\n                                    pw.print(\" ago\");\n                                }\n                                if (ent.getLastRejectTime(OP_FLAGS_ALL) != -1) {\n                                    pw.print(\"; rejectTime=\");\n                                    TimeUtils.formatDuration(\n                                            now - ent.getLastRejectTime(OP_FLAGS_ALL), pw);\n                                    pw.print(\" ago\");\n                                }\n                                if (ent.isRunning()) {\n                                    pw.print(\" (running)\");\n                                } else if (ent.getLastDuration(OP_FLAGS_ALL) != -1) {\n                                    pw.print(\"; duration=\");\n                                    TimeUtils.formatDuration(ent.getLastDuration(OP_FLAGS_ALL), pw);\n                                }\n                            } else {\n                                final AppOpsManager.AttributedOpEntry attributionEnt =\n                                        ent.getAttributedOpEntries().get(shell.attributionTag);\n                                if (attributionEnt != null) {\n                                    if (attributionEnt.getLastAccessTime(OP_FLAGS_ALL) != -1) {\n                                        pw.print(\"; time=\");\n                                        TimeUtils.formatDuration(\n                                                now - attributionEnt.getLastAccessTime(\n                                                        OP_FLAGS_ALL), pw);\n                                        pw.print(\" ago\");\n                                    }\n                                    if (attributionEnt.getLastRejectTime(OP_FLAGS_ALL) != -1) {\n                                        pw.print(\"; rejectTime=\");\n                                        TimeUtils.formatDuration(\n                                                now - attributionEnt.getLastRejectTime(\n                                                        OP_FLAGS_ALL), pw);\n                                        pw.print(\" ago\");\n                                    }\n                                    if (attributionEnt.isRunning()) {\n                                        pw.print(\" (running)\");\n                                    } else if (attributionEnt.getLastDuration(OP_FLAGS_ALL)\n                                            != -1) {\n                                        pw.print(\"; duration=\");\n                                        TimeUtils.formatDuration(\n                                                attributionEnt.getLastDuration(OP_FLAGS_ALL), pw);\n                                    }\n                                }\n                            }\n                            pw.println();\n                        }\n                    }\n                    return 0;\n                }\n                case \"query-op\": {\n                    int res = shell.parseUserOpMode(AppOpsManager.MODE_IGNORED, err);\n                    if (res < 0) {\n                        return res;\n                    }\n                    List<AppOpsManager.PackageOps> ops = shell.mInterface.getPackagesForOps(\n                            new int[] {shell.op});\n                    if (ops == null || ops.size() <= 0) {\n                        pw.println(\"No operations.\");\n                        return 0;\n                    }\n                    for (int i=0; i<ops.size(); i++) {\n                        final AppOpsManager.PackageOps pkg = ops.get(i);\n                        boolean hasMatch = false;\n                        final List<AppOpsManager.OpEntry> entries = ops.get(i).getOps();\n                        for (int j=0; j<entries.size(); j++) {\n                            AppOpsManager.OpEntry ent = entries.get(j);\n                            if (ent.getOp() == shell.op && ent.getMode() == shell.mode) {\n                                hasMatch = true;\n                                break;\n                            }\n                        }\n                        if (hasMatch) {\n                            pw.println(pkg.getPackageName());\n                        }\n                    }\n                    return 0;\n                }\n                case \"reset\": {\n                    String packageName = null;\n                    int userId = UserHandle.USER_CURRENT;\n                    for (String argument; (argument = shell.getNextArg()) != null;) {\n                        if (\"--user\".equals(argument)) {\n                            String userStr = shell.getNextArgRequired();\n                            userId = UserHandle.parseUserArg(userStr);\n                        } else {\n                            if (packageName == null) {\n                                packageName = argument;\n                            } else {\n                                err.println(\"Error: Unsupported argument: \" + argument);\n                                return -1;\n                            }\n                        }\n                    }\n\n                    if (userId == UserHandle.USER_CURRENT) {\n                        userId = ActivityManager.getCurrentUser();\n                    }\n\n                    shell.mInterface.resetAllModes(userId, packageName);\n                    pw.print(\"Reset all modes for: \");\n                    if (userId == UserHandle.USER_ALL) {\n                        pw.print(\"all users\");\n                    } else {\n                        pw.print(\"user \"); pw.print(userId);\n                    }\n                    pw.print(\", \");\n                    if (packageName == null) {\n                        pw.println(\"all packages\");\n                    } else {\n                        pw.print(\"package \"); pw.println(packageName);\n                    }\n                    return 0;\n                }\n                case \"write-settings\": {\n                    shell.mInternal.enforceManageAppOpsModes(Binder.getCallingPid(),\n                            Binder.getCallingUid(), -1);\n                    final long token = Binder.clearCallingIdentity();\n                    try {\n                        synchronized (shell.mInternal) {\n                            shell.mInternal.mHandler.removeCallbacks(shell.mInternal.mWriteRunner);\n                        }\n                        shell.mInternal.writeState();\n                        pw.println(\"Current settings written.\");\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                    return 0;\n                }\n                case \"read-settings\": {\n                    shell.mInternal.enforceManageAppOpsModes(Binder.getCallingPid(),\n                            Binder.getCallingUid(), -1);\n                    final long token = Binder.clearCallingIdentity();\n                    try {\n                        shell.mInternal.readState();\n                        pw.println(\"Last settings read.\");\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                    return 0;\n                }\n                case \"start\": {\n                    int res = shell.parseUserPackageOp(true, err);\n                    if (res < 0) {\n                        return res;\n                    }\n\n                    if (shell.packageName != null) {\n                        shell.mInterface.startOperation(shell.mToken, shell.op, shell.packageUid,\n                                shell.packageName, shell.attributionTag, true, true,\n                                \"appops start shell command\", true,\n                                AppOpsManager.ATTRIBUTION_FLAG_ACCESSOR, ATTRIBUTION_CHAIN_ID_NONE);\n                    } else {\n                        return -1;\n                    }\n                    return 0;\n                }\n                case \"stop\": {\n                    int res = shell.parseUserPackageOp(true, err);\n                    if (res < 0) {\n                        return res;\n                    }\n\n                    if (shell.packageName != null) {\n                        shell.mInterface.finishOperation(shell.mToken, shell.op, shell.packageUid,\n                                shell.packageName, shell.attributionTag);\n                    } else {\n                        return -1;\n                    }\n                    return 0;\n                }\n                default:\n                    return shell.handleDefaultCommands(cmd);\n            }\n        } catch (RemoteException e) {\n            pw.println(\"Remote exception: \" + e);\n        }\n        return -1;\n    }\n\n    private void dumpHelp(PrintWriter pw) {\n        pw.println(\"AppOps service (appops) dump options:\");\n        pw.println(\"  -h\");\n        pw.println(\"    Print this help text.\");\n        pw.println(\"  --op [OP]\");\n        pw.println(\"    Limit output to data associated with the given app op code.\");\n        pw.println(\"  --mode [MODE]\");\n        pw.println(\"    Limit output to data associated with the given app op mode.\");\n        pw.println(\"  --package [PACKAGE]\");\n        pw.println(\"    Limit output to data associated with the given package name.\");\n        pw.println(\"  --attributionTag [attributionTag]\");\n        pw.println(\"    Limit output to data associated with the given attribution tag.\");\n        pw.println(\"  --include-discrete [n]\");\n        pw.println(\"    Include discrete ops limited to n per dimension. Use zero for no limit.\");\n        pw.println(\"  --watchers\");\n        pw.println(\"    Only output the watcher sections.\");\n        pw.println(\"  --history\");\n        pw.println(\"    Only output history.\");\n    }\n\n    private void dumpStatesLocked(@NonNull PrintWriter pw, @Nullable String filterAttributionTag,\n            @HistoricalOpsRequestFilter int filter, long nowElapsed, @NonNull Op op, long now,\n            @NonNull SimpleDateFormat sdf, @NonNull Date date, @NonNull String prefix) {\n        final int numAttributions = op.mAttributions.size();\n        for (int i = 0; i < numAttributions; i++) {\n            if ((filter & FILTER_BY_ATTRIBUTION_TAG) != 0 && !Objects.equals(\n                    op.mAttributions.keyAt(i), filterAttributionTag)) {\n                continue;\n            }\n\n            pw.print(prefix + op.mAttributions.keyAt(i) + \"=[\\n\");\n            dumpStatesLocked(pw, nowElapsed, op, op.mAttributions.keyAt(i), now, sdf, date,\n                    prefix + \"  \");\n            pw.print(prefix + \"]\\n\");\n        }\n    }\n\n    private void dumpStatesLocked(@NonNull PrintWriter pw, long nowElapsed, @NonNull Op op,\n            @Nullable String attributionTag, long now, @NonNull SimpleDateFormat sdf,\n            @NonNull Date date, @NonNull String prefix) {\n\n        final AttributedOpEntry entry = op.createSingleAttributionEntryLocked(\n                attributionTag).getAttributedOpEntries().get(attributionTag);\n\n        final ArraySet<Long> keys = entry.collectKeys();\n\n        final int keyCount = keys.size();\n        for (int k = 0; k < keyCount; k++) {\n            final long key = keys.valueAt(k);\n\n            final int uidState = AppOpsManager.extractUidStateFromKey(key);\n            final int flags = AppOpsManager.extractFlagsFromKey(key);\n\n            final long accessTime = entry.getLastAccessTime(uidState, uidState, flags);\n            final long rejectTime = entry.getLastRejectTime(uidState, uidState, flags);\n            final long accessDuration = entry.getLastDuration(uidState, uidState, flags);\n            final OpEventProxyInfo proxy = entry.getLastProxyInfo(uidState, uidState, flags);\n\n            String proxyPkg = null;\n            String proxyAttributionTag = null;\n            int proxyUid = Process.INVALID_UID;\n            if (proxy != null) {\n                proxyPkg = proxy.getPackageName();\n                proxyAttributionTag = proxy.getAttributionTag();\n                proxyUid = proxy.getUid();\n            }\n\n            if (accessTime > 0) {\n                pw.print(prefix);\n                pw.print(\"Access: \");\n                pw.print(AppOpsManager.keyToString(key));\n                pw.print(\" \");\n                date.setTime(accessTime);\n                pw.print(sdf.format(date));\n                pw.print(\" (\");\n                TimeUtils.formatDuration(accessTime - now, pw);\n                pw.print(\")\");\n                if (accessDuration > 0) {\n                    pw.print(\" duration=\");\n                    TimeUtils.formatDuration(accessDuration, pw);\n                }\n                if (proxyUid >= 0) {\n                    pw.print(\" proxy[\");\n                    pw.print(\"uid=\");\n                    pw.print(proxyUid);\n                    pw.print(\", pkg=\");\n                    pw.print(proxyPkg);\n                    pw.print(\", attributionTag=\");\n                    pw.print(proxyAttributionTag);\n                    pw.print(\"]\");\n                }\n                pw.println();\n            }\n\n            if (rejectTime > 0) {\n                pw.print(prefix);\n                pw.print(\"Reject: \");\n                pw.print(AppOpsManager.keyToString(key));\n                date.setTime(rejectTime);\n                pw.print(sdf.format(date));\n                pw.print(\" (\");\n                TimeUtils.formatDuration(rejectTime - now, pw);\n                pw.print(\")\");\n                if (proxyUid >= 0) {\n                    pw.print(\" proxy[\");\n                    pw.print(\"uid=\");\n                    pw.print(proxyUid);\n                    pw.print(\", pkg=\");\n                    pw.print(proxyPkg);\n                    pw.print(\", attributionTag=\");\n                    pw.print(proxyAttributionTag);\n                    pw.print(\"]\");\n                }\n                pw.println();\n            }\n        }\n\n        final AttributedOp attributedOp = op.mAttributions.get(attributionTag);\n        if (attributedOp.isRunning()) {\n            long earliestElapsedTime = Long.MAX_VALUE;\n            long maxNumStarts = 0;\n            int numInProgressEvents = attributedOp.mInProgressEvents.size();\n            for (int i = 0; i < numInProgressEvents; i++) {\n                InProgressStartOpEvent event = attributedOp.mInProgressEvents.valueAt(i);\n\n                earliestElapsedTime = Math.min(earliestElapsedTime, event.getStartElapsedTime());\n                maxNumStarts = Math.max(maxNumStarts, event.numUnfinishedStarts);\n            }\n\n            pw.print(prefix + \"Running start at: \");\n            TimeUtils.formatDuration(nowElapsed - earliestElapsedTime, pw);\n            pw.println();\n\n            if (maxNumStarts > 1) {\n                pw.print(prefix + \"startNesting=\");\n                pw.println(maxNumStarts);\n            }\n        }\n    }\n\n    @NeverCompile // Avoid size overhead of debugging code.\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {\n        if (!DumpUtils.checkDumpAndUsageStatsPermission(mContext, TAG, pw)) return;\n\n        int dumpOp = OP_NONE;\n        String dumpPackage = null;\n        String dumpAttributionTag = null;\n        int dumpUid = Process.INVALID_UID;\n        int dumpMode = -1;\n        boolean dumpWatchers = false;\n        // TODO ntmyren: Remove the dumpHistory and dumpFilter\n        boolean dumpHistory = false;\n        boolean includeDiscreteOps = false;\n        int nDiscreteOps = 10;\n        @HistoricalOpsRequestFilter int dumpFilter = 0;\n\n        if (args != null) {\n            for (int i = 0; i < args.length; i++) {\n                String arg = args[i];\n                if (\"-h\".equals(arg)) {\n                    dumpHelp(pw);\n                    return;\n                } else if (\"-a\".equals(arg)) {\n                    // dump all data\n                } else if (\"--op\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --op option\");\n                        return;\n                    }\n                    dumpOp = Shell.strOpToOp(args[i], pw);\n                    dumpFilter |= FILTER_BY_OP_NAMES;\n                    if (dumpOp < 0) {\n                        return;\n                    }\n                } else if (\"--package\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --package option\");\n                        return;\n                    }\n                    dumpPackage = args[i];\n                    dumpFilter |= FILTER_BY_PACKAGE_NAME;\n                    try {\n                        dumpUid = AppGlobals.getPackageManager().getPackageUid(dumpPackage,\n                                PackageManager.MATCH_KNOWN_PACKAGES | PackageManager.MATCH_INSTANT,\n                                0);\n                    } catch (RemoteException e) {\n                    }\n                    if (dumpUid < 0) {\n                        pw.println(\"Unknown package: \" + dumpPackage);\n                        return;\n                    }\n                    dumpUid = UserHandle.getAppId(dumpUid);\n                    dumpFilter |= FILTER_BY_UID;\n                } else if (\"--attributionTag\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --attributionTag option\");\n                        return;\n                    }\n                    dumpAttributionTag = args[i];\n                    dumpFilter |= FILTER_BY_ATTRIBUTION_TAG;\n                } else if (\"--mode\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --mode option\");\n                        return;\n                    }\n                    dumpMode = Shell.strModeToMode(args[i], pw);\n                    if (dumpMode < 0) {\n                        return;\n                    }\n                } else if (\"--watchers\".equals(arg)) {\n                    dumpWatchers = true;\n                } else if (\"--include-discrete\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --include-discrete option\");\n                        return;\n                    }\n                    try {\n                        nDiscreteOps = Integer.valueOf(args[i]);\n                    } catch (NumberFormatException e) {\n                        pw.println(\"Wrong parameter: \" + args[i]);\n                        return;\n                    }\n                    includeDiscreteOps = true;\n                } else if (\"--history\".equals(arg)) {\n                    dumpHistory = true;\n                } else if (arg.length() > 0 && arg.charAt(0) == '-') {\n                    pw.println(\"Unknown option: \" + arg);\n                    return;\n                } else {\n                    pw.println(\"Unknown command: \" + arg);\n                    return;\n                }\n            }\n        }\n\n        final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\");\n        final Date date = new Date();\n        synchronized (this) {\n            pw.println(\"Current AppOps Service state:\");\n            if (!dumpHistory && !dumpWatchers) {\n                mConstants.dump(pw);\n            }\n            pw.println();\n            final long now = System.currentTimeMillis();\n            final long nowElapsed = SystemClock.elapsedRealtime();\n            final long nowUptime = SystemClock.uptimeMillis();\n            boolean needSep = false;\n            if (dumpFilter == 0 && dumpMode < 0 && mProfileOwners != null && !dumpWatchers\n                    && !dumpHistory) {\n                pw.println(\"  Profile owners:\");\n                for (int poi = 0; poi < mProfileOwners.size(); poi++) {\n                    pw.print(\"    User #\");\n                    pw.print(mProfileOwners.keyAt(poi));\n                    pw.print(\": \");\n                    UserHandle.formatUid(pw, mProfileOwners.valueAt(poi));\n                    pw.println();\n                }\n                pw.println();\n            }\n            if (mOpModeWatchers.size() > 0 && !dumpHistory) {\n                boolean printedHeader = false;\n                for (int i=0; i<mOpModeWatchers.size(); i++) {\n                    if (dumpOp >= 0 && dumpOp != mOpModeWatchers.keyAt(i)) {\n                        continue;\n                    }\n                    boolean printedOpHeader = false;\n                    ArraySet<ModeCallback> callbacks = mOpModeWatchers.valueAt(i);\n                    for (int j=0; j<callbacks.size(); j++) {\n                        final ModeCallback cb = callbacks.valueAt(j);\n                        if (dumpPackage != null\n                                && dumpUid != UserHandle.getAppId(cb.mWatchingUid)) {\n                            continue;\n                        }\n                        needSep = true;\n                        if (!printedHeader) {\n                            pw.println(\"  Op mode watchers:\");\n                            printedHeader = true;\n                        }\n                        if (!printedOpHeader) {\n                            pw.print(\"    Op \");\n                            pw.print(AppOpsManager.opToName(mOpModeWatchers.keyAt(i)));\n                            pw.println(\":\");\n                            printedOpHeader = true;\n                        }\n                        pw.print(\"      #\"); pw.print(j); pw.print(\": \");\n                        pw.println(cb);\n                    }\n                }\n            }\n            if (mPackageModeWatchers.size() > 0 && dumpOp < 0 && !dumpHistory) {\n                boolean printedHeader = false;\n                for (int i=0; i<mPackageModeWatchers.size(); i++) {\n                    if (dumpPackage != null && !dumpPackage.equals(mPackageModeWatchers.keyAt(i))) {\n                        continue;\n                    }\n                    needSep = true;\n                    if (!printedHeader) {\n                        pw.println(\"  Package mode watchers:\");\n                        printedHeader = true;\n                    }\n                    pw.print(\"    Pkg \"); pw.print(mPackageModeWatchers.keyAt(i));\n                    pw.println(\":\");\n                    ArraySet<ModeCallback> callbacks = mPackageModeWatchers.valueAt(i);\n                    for (int j=0; j<callbacks.size(); j++) {\n                        pw.print(\"      #\"); pw.print(j); pw.print(\": \");\n                        pw.println(callbacks.valueAt(j));\n                    }\n                }\n            }\n            if (mModeWatchers.size() > 0 && dumpOp < 0 && !dumpHistory) {\n                boolean printedHeader = false;\n                for (int i=0; i<mModeWatchers.size(); i++) {\n                    final ModeCallback cb = mModeWatchers.valueAt(i);\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.mWatchingUid)) {\n                        continue;\n                    }\n                    needSep = true;\n                    if (!printedHeader) {\n                        pw.println(\"  All op mode watchers:\");\n                        printedHeader = true;\n                    }\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(mModeWatchers.keyAt(i))));\n                    pw.print(\": \"); pw.println(cb);\n                }\n            }\n            if (mActiveWatchers.size() > 0 && dumpMode < 0) {\n                needSep = true;\n                boolean printedHeader = false;\n                for (int watcherNum = 0; watcherNum < mActiveWatchers.size(); watcherNum++) {\n                    final SparseArray<ActiveCallback> activeWatchers =\n                            mActiveWatchers.valueAt(watcherNum);\n                    if (activeWatchers.size() <= 0) {\n                        continue;\n                    }\n                    final ActiveCallback cb = activeWatchers.valueAt(0);\n                    if (dumpOp >= 0 && activeWatchers.indexOfKey(dumpOp) < 0) {\n                        continue;\n                    }\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.mWatchingUid)) {\n                        continue;\n                    }\n                    if (!printedHeader) {\n                        pw.println(\"  All op active watchers:\");\n                        printedHeader = true;\n                    }\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(\n                            mActiveWatchers.keyAt(watcherNum))));\n                    pw.println(\" ->\");\n                    pw.print(\"        [\");\n                    final int opCount = activeWatchers.size();\n                    for (int opNum = 0; opNum < opCount; opNum++) {\n                        if (opNum > 0) {\n                            pw.print(' ');\n                        }\n                        pw.print(AppOpsManager.opToName(activeWatchers.keyAt(opNum)));\n                        if (opNum < opCount - 1) {\n                            pw.print(',');\n                        }\n                    }\n                    pw.println(\"]\");\n                    pw.print(\"        \");\n                    pw.println(cb);\n                }\n            }\n            if (mStartedWatchers.size() > 0 && dumpMode < 0) {\n                needSep = true;\n                boolean printedHeader = false;\n\n                final int watchersSize = mStartedWatchers.size();\n                for (int watcherNum = 0; watcherNum < watchersSize; watcherNum++) {\n                    final SparseArray<StartedCallback> startedWatchers =\n                            mStartedWatchers.valueAt(watcherNum);\n                    if (startedWatchers.size() <= 0) {\n                        continue;\n                    }\n\n                    final StartedCallback cb = startedWatchers.valueAt(0);\n                    if (dumpOp >= 0 && startedWatchers.indexOfKey(dumpOp) < 0) {\n                        continue;\n                    }\n\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.mWatchingUid)) {\n                        continue;\n                    }\n\n                    if (!printedHeader) {\n                        pw.println(\"  All op started watchers:\");\n                        printedHeader = true;\n                    }\n\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(\n                            mStartedWatchers.keyAt(watcherNum))));\n                    pw.println(\" ->\");\n\n                    pw.print(\"        [\");\n                    final int opCount = startedWatchers.size();\n                    for (int opNum = 0; opNum < opCount; opNum++) {\n                        if (opNum > 0) {\n                            pw.print(' ');\n                        }\n\n                        pw.print(AppOpsManager.opToName(startedWatchers.keyAt(opNum)));\n                        if (opNum < opCount - 1) {\n                            pw.print(',');\n                        }\n                    }\n                    pw.println(\"]\");\n\n                    pw.print(\"        \");\n                    pw.println(cb);\n                }\n            }\n            if (mNotedWatchers.size() > 0 && dumpMode < 0) {\n                needSep = true;\n                boolean printedHeader = false;\n                for (int watcherNum = 0; watcherNum < mNotedWatchers.size(); watcherNum++) {\n                    final SparseArray<NotedCallback> notedWatchers =\n                            mNotedWatchers.valueAt(watcherNum);\n                    if (notedWatchers.size() <= 0) {\n                        continue;\n                    }\n                    final NotedCallback cb = notedWatchers.valueAt(0);\n                    if (dumpOp >= 0 && notedWatchers.indexOfKey(dumpOp) < 0) {\n                        continue;\n                    }\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.mWatchingUid)) {\n                        continue;\n                    }\n                    if (!printedHeader) {\n                        pw.println(\"  All op noted watchers:\");\n                        printedHeader = true;\n                    }\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(\n                            mNotedWatchers.keyAt(watcherNum))));\n                    pw.println(\" ->\");\n                    pw.print(\"        [\");\n                    final int opCount = notedWatchers.size();\n                    for (int opNum = 0; opNum < opCount; opNum++) {\n                        if (opNum > 0) {\n                            pw.print(' ');\n                        }\n                        pw.print(AppOpsManager.opToName(notedWatchers.keyAt(opNum)));\n                        if (opNum < opCount - 1) {\n                            pw.print(',');\n                        }\n                    }\n                    pw.println(\"]\");\n                    pw.print(\"        \");\n                    pw.println(cb);\n                }\n            }\n            if (mAudioRestrictionManager.hasActiveRestrictions() && dumpOp < 0\n                    && dumpPackage != null && dumpMode < 0 && !dumpWatchers) {\n                needSep = mAudioRestrictionManager.dump(pw) || needSep;\n            }\n            if (needSep) {\n                pw.println();\n            }\n            for (int i=0; i<mUidStates.size(); i++) {\n                UidState uidState = mUidStates.valueAt(i);\n                final SparseIntArray opModes = uidState.opModes;\n                final ArrayMap<String, Ops> pkgOps = uidState.pkgOps;\n\n                if (dumpWatchers || dumpHistory) {\n                    continue;\n                }\n                if (dumpOp >= 0 || dumpPackage != null || dumpMode >= 0) {\n                    boolean hasOp = dumpOp < 0 || (uidState.opModes != null\n                            && uidState.opModes.indexOfKey(dumpOp) >= 0);\n                    boolean hasPackage = dumpPackage == null || dumpUid == mUidStates.keyAt(i);\n                    boolean hasMode = dumpMode < 0;\n                    if (!hasMode && opModes != null) {\n                        for (int opi = 0; !hasMode && opi < opModes.size(); opi++) {\n                            if (opModes.valueAt(opi) == dumpMode) {\n                                hasMode = true;\n                            }\n                        }\n                    }\n                    if (pkgOps != null) {\n                        for (int pkgi = 0;\n                                 (!hasOp || !hasPackage || !hasMode) && pkgi < pkgOps.size();\n                                 pkgi++) {\n                            Ops ops = pkgOps.valueAt(pkgi);\n                            if (!hasOp && ops != null && ops.indexOfKey(dumpOp) >= 0) {\n                                hasOp = true;\n                            }\n                            if (!hasMode) {\n                                for (int opi = 0; !hasMode && opi < ops.size(); opi++) {\n                                    if (ops.valueAt(opi).mode == dumpMode) {\n                                        hasMode = true;\n                                    }\n                                }\n                            }\n                            if (!hasPackage && dumpPackage.equals(ops.packageName)) {\n                                hasPackage = true;\n                            }\n                        }\n                    }\n                    if (uidState.foregroundOps != null && !hasOp) {\n                        if (uidState.foregroundOps.indexOfKey(dumpOp) > 0) {\n                            hasOp = true;\n                        }\n                    }\n                    if (!hasOp || !hasPackage || !hasMode) {\n                        continue;\n                    }\n                }\n\n                pw.print(\"  Uid \"); UserHandle.formatUid(pw, uidState.uid); pw.println(\":\");\n                pw.print(\"    state=\");\n                pw.println(AppOpsManager.getUidStateName(uidState.state));\n                if (uidState.state != uidState.pendingState) {\n                    pw.print(\"    pendingState=\");\n                    pw.println(AppOpsManager.getUidStateName(uidState.pendingState));\n                }\n                pw.print(\"    capability=\");\n                ActivityManager.printCapabilitiesFull(pw, uidState.capability);\n                pw.println();\n                if (uidState.capability != uidState.pendingCapability) {\n                    pw.print(\"    pendingCapability=\");\n                    ActivityManager.printCapabilitiesFull(pw, uidState.pendingCapability);\n                    pw.println();\n                }\n                pw.print(\"    appWidgetVisible=\");\n                pw.println(uidState.appWidgetVisible);\n                if (uidState.appWidgetVisible != uidState.pendingAppWidgetVisible) {\n                    pw.print(\"    pendingAppWidgetVisible=\");\n                    pw.println(uidState.pendingAppWidgetVisible);\n                }\n                if (uidState.pendingStateCommitTime != 0) {\n                    pw.print(\"    pendingStateCommitTime=\");\n                    TimeUtils.formatDuration(uidState.pendingStateCommitTime, nowElapsed, pw);\n                    pw.println();\n                }\n                if (uidState.foregroundOps != null && (dumpMode < 0\n                        || dumpMode == AppOpsManager.MODE_FOREGROUND)) {\n                    pw.println(\"    foregroundOps:\");\n                    for (int j = 0; j < uidState.foregroundOps.size(); j++) {\n                        if (dumpOp >= 0 && dumpOp != uidState.foregroundOps.keyAt(j)) {\n                            continue;\n                        }\n                        pw.print(\"      \");\n                        pw.print(AppOpsManager.opToName(uidState.foregroundOps.keyAt(j)));\n                        pw.print(\": \");\n                        pw.println(uidState.foregroundOps.valueAt(j) ? \"WATCHER\" : \"SILENT\");\n                    }\n                    pw.print(\"    hasForegroundWatchers=\");\n                    pw.println(uidState.hasForegroundWatchers);\n                }\n                needSep = true;\n\n                if (opModes != null) {\n                    final int opModeCount = opModes.size();\n                    for (int j = 0; j < opModeCount; j++) {\n                        final int code = opModes.keyAt(j);\n                        final int mode = opModes.valueAt(j);\n                        if (dumpOp >= 0 && dumpOp != code) {\n                            continue;\n                        }\n                        if (dumpMode >= 0 && dumpMode != mode) {\n                            continue;\n                        }\n                        pw.print(\"      \"); pw.print(AppOpsManager.opToName(code));\n                        pw.print(\": mode=\"); pw.println(AppOpsManager.modeToName(mode));\n                    }\n                }\n\n                if (pkgOps == null) {\n                    continue;\n                }\n\n                for (int pkgi = 0; pkgi < pkgOps.size(); pkgi++) {\n                    final Ops ops = pkgOps.valueAt(pkgi);\n                    if (dumpPackage != null && !dumpPackage.equals(ops.packageName)) {\n                        continue;\n                    }\n                    boolean printedPackage = false;\n                    for (int j=0; j<ops.size(); j++) {\n                        final Op op = ops.valueAt(j);\n                        final int opCode = op.op;\n                        if (dumpOp >= 0 && dumpOp != opCode) {\n                            continue;\n                        }\n                        if (dumpMode >= 0 && dumpMode != op.mode) {\n                            continue;\n                        }\n                        if (!printedPackage) {\n                            pw.print(\"    Package \"); pw.print(ops.packageName); pw.println(\":\");\n                            printedPackage = true;\n                        }\n                        pw.print(\"      \"); pw.print(AppOpsManager.opToName(opCode));\n                        pw.print(\" (\"); pw.print(AppOpsManager.modeToName(op.mode));\n                        final int switchOp = AppOpsManager.opToSwitch(opCode);\n                        if (switchOp != opCode) {\n                            pw.print(\" / switch \");\n                            pw.print(AppOpsManager.opToName(switchOp));\n                            final Op switchObj = ops.get(switchOp);\n                            int mode = switchObj != null ? switchObj.mode\n                                    : AppOpsManager.opToDefaultMode(switchOp);\n                            pw.print(\"=\"); pw.print(AppOpsManager.modeToName(mode));\n                        }\n                        pw.println(\"): \");\n                        dumpStatesLocked(pw, dumpAttributionTag, dumpFilter, nowElapsed, op, now,\n                                sdf, date, \"        \");\n                    }\n                }\n            }\n            if (needSep) {\n                pw.println();\n            }\n\n            final int globalRestrictionCount = mOpGlobalRestrictions.size();\n            for (int i = 0; i < globalRestrictionCount; i++) {\n                IBinder token = mOpGlobalRestrictions.keyAt(i);\n                ClientGlobalRestrictionState restrictionState = mOpGlobalRestrictions.valueAt(i);\n                ArraySet<Integer> restrictedOps = restrictionState.mRestrictedOps;\n\n                pw.println(\"  Global restrictions for token \" + token + \":\");\n                StringBuilder restrictedOpsValue = new StringBuilder();\n                restrictedOpsValue.append(\"[\");\n                final int restrictedOpCount = restrictedOps.size();\n                for (int j = 0; j < restrictedOpCount; j++) {\n                    if (restrictedOpsValue.length() > 1) {\n                        restrictedOpsValue.append(\", \");\n                    }\n                    restrictedOpsValue.append(AppOpsManager.opToName(restrictedOps.valueAt(j)));\n                }\n                restrictedOpsValue.append(\"]\");\n                pw.println(\"      Restricted ops: \" + restrictedOpsValue);\n\n            }\n\n            final int userRestrictionCount = mOpUserRestrictions.size();\n            for (int i = 0; i < userRestrictionCount; i++) {\n                IBinder token = mOpUserRestrictions.keyAt(i);\n                ClientUserRestrictionState restrictionState = mOpUserRestrictions.valueAt(i);\n                boolean printedTokenHeader = false;\n\n                if (dumpMode >= 0 || dumpWatchers || dumpHistory) {\n                    continue;\n                }\n\n                final int restrictionCount = restrictionState.perUserRestrictions != null\n                        ? restrictionState.perUserRestrictions.size() : 0;\n                if (restrictionCount > 0 && dumpPackage == null) {\n                    boolean printedOpsHeader = false;\n                    for (int j = 0; j < restrictionCount; j++) {\n                        int userId = restrictionState.perUserRestrictions.keyAt(j);\n                        boolean[] restrictedOps = restrictionState.perUserRestrictions.valueAt(j);\n                        if (restrictedOps == null) {\n                            continue;\n                        }\n                        if (dumpOp >= 0 && (dumpOp >= restrictedOps.length\n                                || !restrictedOps[dumpOp])) {\n                            continue;\n                        }\n                        if (!printedTokenHeader) {\n                            pw.println(\"  User restrictions for token \" + token + \":\");\n                            printedTokenHeader = true;\n                        }\n                        if (!printedOpsHeader) {\n                            pw.println(\"      Restricted ops:\");\n                            printedOpsHeader = true;\n                        }\n                        StringBuilder restrictedOpsValue = new StringBuilder();\n                        restrictedOpsValue.append(\"[\");\n                        final int restrictedOpCount = restrictedOps.length;\n                        for (int k = 0; k < restrictedOpCount; k++) {\n                            if (restrictedOps[k]) {\n                                if (restrictedOpsValue.length() > 1) {\n                                    restrictedOpsValue.append(\", \");\n                                }\n                                restrictedOpsValue.append(AppOpsManager.opToName(k));\n                            }\n                        }\n                        restrictedOpsValue.append(\"]\");\n                        pw.print(\"        \"); pw.print(\"user: \"); pw.print(userId);\n                                pw.print(\" restricted ops: \"); pw.println(restrictedOpsValue);\n                    }\n                }\n\n                final int excludedPackageCount = restrictionState.perUserExcludedPackageTags != null\n                        ? restrictionState.perUserExcludedPackageTags.size() : 0;\n                if (excludedPackageCount > 0 && dumpOp < 0) {\n                    IndentingPrintWriter ipw = new IndentingPrintWriter(pw);\n                    ipw.increaseIndent();\n                    boolean printedPackagesHeader = false;\n                    for (int j = 0; j < excludedPackageCount; j++) {\n                        int userId = restrictionState.perUserExcludedPackageTags.keyAt(j);\n                        PackageTagsList packageNames =\n                                restrictionState.perUserExcludedPackageTags.valueAt(j);\n                        if (packageNames == null) {\n                            continue;\n                        }\n                        boolean hasPackage;\n                        if (dumpPackage != null) {\n                            hasPackage = packageNames.includes(dumpPackage);\n                        } else {\n                            hasPackage = true;\n                        }\n                        if (!hasPackage) {\n                            continue;\n                        }\n                        if (!printedTokenHeader) {\n                            ipw.println(\"User restrictions for token \" + token + \":\");\n                            printedTokenHeader = true;\n                        }\n\n                        ipw.increaseIndent();\n                        if (!printedPackagesHeader) {\n                            ipw.println(\"Excluded packages:\");\n                            printedPackagesHeader = true;\n                        }\n\n                        ipw.increaseIndent();\n                        ipw.print(\"user: \");\n                        ipw.print(userId);\n                        ipw.println(\" packages: \");\n\n                        ipw.increaseIndent();\n                        packageNames.dump(ipw);\n\n                        ipw.decreaseIndent();\n                        ipw.decreaseIndent();\n                        ipw.decreaseIndent();\n                    }\n                    ipw.decreaseIndent();\n                }\n            }\n\n            if (!dumpHistory && !dumpWatchers) {\n                pw.println();\n                if (mCheckOpsDelegateDispatcher.mPolicy != null\n                        && mCheckOpsDelegateDispatcher.mPolicy instanceof AppOpsPolicy) {\n                    AppOpsPolicy policy = (AppOpsPolicy) mCheckOpsDelegateDispatcher.mPolicy;\n                    policy.dumpTags(pw);\n                } else {\n                    pw.println(\"  AppOps policy not set.\");\n                }\n            }\n        }\n\n        // Must not hold the appops lock\n        if (dumpHistory && !dumpWatchers) {\n            mHistoricalRegistry.dump(\"  \", pw, dumpUid, dumpPackage, dumpAttributionTag, dumpOp,\n                    dumpFilter);\n        }\n        if (includeDiscreteOps) {\n            pw.println(\"Discrete accesses: \");\n            mHistoricalRegistry.dumpDiscreteData(pw, dumpUid, dumpPackage, dumpAttributionTag,\n                    dumpFilter, dumpOp, sdf, date, \"  \", nDiscreteOps);\n        }\n    }\n\n    @Override\n    public void setUserRestrictions(Bundle restrictions, IBinder token, int userHandle) {\n        checkSystemUid(\"setUserRestrictions\");\n        Objects.requireNonNull(restrictions);\n        Objects.requireNonNull(token);\n        for (int i = 0; i < AppOpsManager._NUM_OP; i++) {\n            String restriction = AppOpsManager.opToRestriction(i);\n            if (restriction != null) {\n                setUserRestrictionNoCheck(i, restrictions.getBoolean(restriction, false), token,\n                        userHandle, null);\n            }\n        }\n    }\n\n    @Override\n    public void setUserRestriction(int code, boolean restricted, IBinder token, int userHandle,\n            PackageTagsList excludedPackageTags) {\n        if (Binder.getCallingPid() != Process.myPid()) {\n            mContext.enforcePermission(Manifest.permission.MANAGE_APP_OPS_RESTRICTIONS,\n                    Binder.getCallingPid(), Binder.getCallingUid(), null);\n        }\n        if (userHandle != UserHandle.getCallingUserId()) {\n            if (mContext.checkCallingOrSelfPermission(Manifest.permission\n                    .INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED\n                && mContext.checkCallingOrSelfPermission(Manifest.permission\n                    .INTERACT_ACROSS_USERS) != PackageManager.PERMISSION_GRANTED) {\n                throw new SecurityException(\"Need INTERACT_ACROSS_USERS_FULL or\"\n                        + \" INTERACT_ACROSS_USERS to interact cross user \");\n            }\n        }\n        verifyIncomingOp(code);\n        Objects.requireNonNull(token);\n        setUserRestrictionNoCheck(code, restricted, token, userHandle, excludedPackageTags);\n    }\n\n    private void setUserRestrictionNoCheck(int code, boolean restricted, IBinder token,\n            int userHandle, PackageTagsList excludedPackageTags) {\n        synchronized (AppOpsService.this) {\n            ClientUserRestrictionState restrictionState = mOpUserRestrictions.get(token);\n\n            if (restrictionState == null) {\n                try {\n                    restrictionState = new ClientUserRestrictionState(token);\n                } catch (RemoteException e) {\n                    return;\n                }\n                mOpUserRestrictions.put(token, restrictionState);\n            }\n\n            if (restrictionState.setRestriction(code, restricted, excludedPackageTags,\n                    userHandle)) {\n                mHandler.sendMessage(PooledLambda.obtainMessage(\n                        AppOpsService::notifyWatchersOfChange, this, code, UID_ANY));\n                mHandler.sendMessage(PooledLambda.obtainMessage(\n                        AppOpsService::updateStartedOpModeForUser, this, code, restricted,\n                        userHandle));\n            }\n\n            if (restrictionState.isDefault()) {\n                mOpUserRestrictions.remove(token);\n                restrictionState.destroy();\n            }\n        }\n    }\n\n    private void updateStartedOpModeForUser(int code, boolean restricted, int userId) {\n        synchronized (AppOpsService.this) {\n            int numUids = mUidStates.size();\n            for (int uidNum = 0; uidNum < numUids; uidNum++) {\n                int uid = mUidStates.keyAt(uidNum);\n                if (userId != UserHandle.USER_ALL && UserHandle.getUserId(uid) != userId) {\n                    continue;\n                }\n                updateStartedOpModeForUidLocked(code, restricted, uid);\n            }\n        }\n    }\n\n    private void updateStartedOpModeForUidLocked(int code, boolean restricted, int uid) {\n        UidState uidState = mUidStates.get(uid);\n        if (uidState == null || uidState.pkgOps == null) {\n            return;\n        }\n\n        int numPkgOps = uidState.pkgOps.size();\n        for (int pkgNum = 0; pkgNum < numPkgOps; pkgNum++) {\n            Ops ops = uidState.pkgOps.valueAt(pkgNum);\n            Op op = ops != null ? ops.get(code) : null;\n            if (op == null || (op.mode != MODE_ALLOWED && op.mode != MODE_FOREGROUND)) {\n                continue;\n            }\n            int numAttrTags = op.mAttributions.size();\n            for (int attrNum = 0; attrNum < numAttrTags; attrNum++) {\n                AttributedOp attrOp = op.mAttributions.valueAt(attrNum);\n                if (restricted && attrOp.isRunning()) {\n                    attrOp.pause();\n                } else if (attrOp.isPaused()) {\n                    attrOp.resume();\n                }\n            }\n        }\n    }\n\n    private void notifyWatchersOfChange(int code, int uid) {\n        final ArraySet<ModeCallback> clonedCallbacks;\n        synchronized (this) {\n            ArraySet<ModeCallback> callbacks = mOpModeWatchers.get(code);\n            if (callbacks == null) {\n                return;\n            }\n            clonedCallbacks = new ArraySet<>(callbacks);\n        }\n\n        notifyOpChanged(clonedCallbacks,  code, uid, null);\n    }\n\n    @Override\n    public void removeUser(int userHandle) throws RemoteException {\n        checkSystemUid(\"removeUser\");\n        synchronized (AppOpsService.this) {\n            final int tokenCount = mOpUserRestrictions.size();\n            for (int i = tokenCount - 1; i >= 0; i--) {\n                ClientUserRestrictionState opRestrictions = mOpUserRestrictions.valueAt(i);\n                opRestrictions.removeUser(userHandle);\n            }\n            removeUidsForUserLocked(userHandle);\n        }\n    }\n\n    @Override\n    public boolean isOperationActive(int code, int uid, String packageName) {\n        if (Binder.getCallingUid() != uid) {\n            if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                    != PackageManager.PERMISSION_GRANTED) {\n                return false;\n            }\n        }\n        verifyIncomingOp(code);\n        verifyIncomingPackage(packageName, UserHandle.getUserId(uid));\n\n        final String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return false;\n        }\n        // TODO moltmann: Allow to check for attribution op activeness\n        synchronized (AppOpsService.this) {\n            Ops pkgOps = getOpsLocked(uid, resolvedPackageName, null, false, null, false);\n            if (pkgOps == null) {\n                return false;\n            }\n\n            Op op = pkgOps.get(code);\n            if (op == null) {\n                return false;\n            }\n\n            return op.isRunning();\n        }\n    }\n\n    @Override\n    public boolean isProxying(int op, @NonNull String proxyPackageName,\n            @NonNull String proxyAttributionTag, int proxiedUid,\n            @NonNull String proxiedPackageName) {\n        Objects.requireNonNull(proxyPackageName);\n        Objects.requireNonNull(proxiedPackageName);\n        final long callingUid = Binder.getCallingUid();\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final List<AppOpsManager.PackageOps> packageOps = getOpsForPackage(proxiedUid,\n                    proxiedPackageName, new int[] {op});\n            if (packageOps == null || packageOps.isEmpty()) {\n                return false;\n            }\n            final List<OpEntry> opEntries = packageOps.get(0).getOps();\n            if (opEntries.isEmpty()) {\n                return false;\n            }\n            final OpEntry opEntry = opEntries.get(0);\n            if (!opEntry.isRunning()) {\n                return false;\n            }\n            final OpEventProxyInfo proxyInfo = opEntry.getLastProxyInfo(\n                    OP_FLAG_TRUSTED_PROXIED | AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED);\n            return proxyInfo != null && callingUid == proxyInfo.getUid()\n                    && proxyPackageName.equals(proxyInfo.getPackageName())\n                    && Objects.equals(proxyAttributionTag, proxyInfo.getAttributionTag());\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    @Override\n    public void resetPackageOpsNoHistory(@NonNull String packageName) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"resetPackageOpsNoHistory\");\n        synchronized (AppOpsService.this) {\n            final int uid = mPackageManagerInternal.getPackageUid(packageName, 0,\n                    UserHandle.getCallingUserId());\n            if (uid == Process.INVALID_UID) {\n                return;\n            }\n            UidState uidState = mUidStates.get(uid);\n            if (uidState == null || uidState.pkgOps == null) {\n                return;\n            }\n            Ops removedOps = uidState.pkgOps.remove(packageName);\n            if (removedOps != null) {\n                scheduleFastWriteLocked();\n            }\n        }\n    }\n\n    @Override\n    public void setHistoryParameters(@AppOpsManager.HistoricalMode int mode,\n            long baseSnapshotInterval, int compressionStep) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"setHistoryParameters\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.setHistoryParameters(mode, baseSnapshotInterval, compressionStep);\n    }\n\n    @Override\n    public void offsetHistory(long offsetMillis) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"offsetHistory\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.offsetHistory(offsetMillis);\n        mHistoricalRegistry.offsetDiscreteHistory(offsetMillis);\n    }\n\n    @Override\n    public void addHistoricalOps(HistoricalOps ops) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"addHistoricalOps\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.addHistoricalOps(ops);\n    }\n\n    @Override\n    public void resetHistoryParameters() {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"resetHistoryParameters\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.resetHistoryParameters();\n    }\n\n    @Override\n    public void clearHistory() {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"clearHistory\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.clearAllHistory();\n    }\n\n    @Override\n    public void rebootHistory(long offlineDurationMillis) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"rebootHistory\");\n\n        Preconditions.checkArgument(offlineDurationMillis >= 0);\n\n        // Must not hold the appops lock\n        mHistoricalRegistry.shutdown();\n\n        if (offlineDurationMillis > 0) {\n            SystemClock.sleep(offlineDurationMillis);\n        }\n\n        mHistoricalRegistry = new HistoricalRegistry(mHistoricalRegistry);\n        mHistoricalRegistry.systemReady(mContext.getContentResolver());\n        mHistoricalRegistry.persistPendingHistory();\n    }\n\n    /**\n     * Report runtime access to AppOp together with message (including stack trace)\n     *\n     * @param packageName The package which reported the op\n     * @param notedAppOp contains code of op and attributionTag provided by developer\n     * @param message Message describing AppOp access (can be stack trace)\n     *\n     * @return Config for future sampling to reduce amount of reporting\n     */\n    @Override\n    public MessageSamplingConfig reportRuntimeAppOpAccessMessageAndGetConfig(\n            String packageName, SyncNotedAppOp notedAppOp, String message) {\n        int uid = Binder.getCallingUid();\n        Objects.requireNonNull(packageName);\n        synchronized (this) {\n            switchPackageIfBootTimeOrRarelyUsedLocked(packageName);\n            if (!packageName.equals(mSampledPackage)) {\n                return new MessageSamplingConfig(OP_NONE, 0,\n                        Instant.now().plus(1, ChronoUnit.HOURS).toEpochMilli());\n            }\n\n            Objects.requireNonNull(notedAppOp);\n            Objects.requireNonNull(message);\n\n            reportRuntimeAppOpAccessMessageInternalLocked(uid, packageName,\n                    AppOpsManager.strOpToOp(notedAppOp.getOp()),\n                    notedAppOp.getAttributionTag(), message);\n\n            return new MessageSamplingConfig(mSampledAppOpCode, mAcceptableLeftDistance,\n                    Instant.now().plus(1, ChronoUnit.HOURS).toEpochMilli());\n        }\n    }\n\n    /**\n     * Report runtime access to AppOp together with message (entry point for reporting\n     * asynchronous access)\n     * @param uid Uid of the package which reported the op\n     * @param packageName The package which reported the op\n     * @param opCode Code of AppOp\n     * @param attributionTag FeautreId of AppOp reported\n     * @param message Message describing AppOp access (can be stack trace)\n     */\n    private void reportRuntimeAppOpAccessMessageAsyncLocked(int uid,\n            @NonNull String packageName, int opCode, @Nullable String attributionTag,\n            @NonNull String message) {\n        switchPackageIfBootTimeOrRarelyUsedLocked(packageName);\n        if (!Objects.equals(mSampledPackage, packageName)) {\n            return;\n        }\n        reportRuntimeAppOpAccessMessageInternalLocked(uid, packageName, opCode, attributionTag,\n                message);\n    }\n\n    /**\n     * Decides whether reported message is within the range of watched AppOps and picks it for\n     * reporting uniformly at random across all received messages.\n     */\n    private void reportRuntimeAppOpAccessMessageInternalLocked(int uid,\n            @NonNull String packageName, int opCode, @Nullable String attributionTag,\n            @NonNull String message) {\n        int newLeftDistance = AppOpsManager.leftCircularDistance(opCode,\n                mSampledAppOpCode, _NUM_OP);\n\n        if (mAcceptableLeftDistance < newLeftDistance\n                && mSamplingStrategy != SAMPLING_STRATEGY_UNIFORM_OPS) {\n            return;\n        }\n\n        if (mAcceptableLeftDistance > newLeftDistance\n                && mSamplingStrategy != SAMPLING_STRATEGY_UNIFORM_OPS) {\n            mAcceptableLeftDistance = newLeftDistance;\n            mMessagesCollectedCount = 0.0f;\n        }\n\n        mMessagesCollectedCount += 1.0f;\n        if (ThreadLocalRandom.current().nextFloat() <= 1.0f / mMessagesCollectedCount) {\n            mCollectedRuntimePermissionMessage = new RuntimeAppOpAccessMessage(uid, opCode,\n                    packageName, attributionTag, message, mSamplingStrategy);\n        }\n        return;\n    }\n\n    /** Pulls current AppOps access report and resamples package and app op to watch */\n    @Override\n    public @Nullable RuntimeAppOpAccessMessage collectRuntimeAppOpAccessMessage() {\n        ActivityManagerInternal ami = LocalServices.getService(ActivityManagerInternal.class);\n        boolean isCallerInstrumented =\n                ami.getInstrumentationSourceUid(Binder.getCallingUid()) != Process.INVALID_UID;\n        boolean isCallerSystem = Binder.getCallingPid() == Process.myPid();\n        if (!isCallerSystem && !isCallerInstrumented) {\n            return null;\n        }\n        mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n        RuntimeAppOpAccessMessage result;\n        synchronized (this) {\n            result = mCollectedRuntimePermissionMessage;\n            mCollectedRuntimePermissionMessage = null;\n        }\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::getPackageListAndResample,\n                this));\n        return result;\n    }\n\n    /**\n     * Checks if package is in the list of rarely used package and starts watching the new package\n     * to collect incoming message or if collection is happening in first minutes since boot.\n     * @param packageName\n     */\n    private void switchPackageIfBootTimeOrRarelyUsedLocked(@NonNull String packageName) {\n        if (mSampledPackage == null) {\n            if (ThreadLocalRandom.current().nextFloat() < 0.5f) {\n                mSamplingStrategy = SAMPLING_STRATEGY_BOOT_TIME_SAMPLING;\n                resampleAppOpForPackageLocked(packageName, true);\n            }\n        } else if (mRarelyUsedPackages.contains(packageName)) {\n            mRarelyUsedPackages.remove(packageName);\n            if (ThreadLocalRandom.current().nextFloat() < 0.5f) {\n                mSamplingStrategy = SAMPLING_STRATEGY_RARELY_USED;\n                resampleAppOpForPackageLocked(packageName, true);\n            }\n        }\n    }\n\n    /** Obtains package list and resamples package and appop to watch. */\n    private List<String> getPackageListAndResample() {\n        List<String> packageNames = getPackageNamesForSampling();\n        synchronized (this) {\n            resamplePackageAndAppOpLocked(packageNames);\n        }\n        return packageNames;\n    }\n\n    /** Resamples package and appop to watch from the list provided. */\n    private void resamplePackageAndAppOpLocked(@NonNull List<String> packageNames) {\n        if (!packageNames.isEmpty()) {\n            if (ThreadLocalRandom.current().nextFloat() < 0.5f) {\n                mSamplingStrategy = SAMPLING_STRATEGY_UNIFORM;\n                resampleAppOpForPackageLocked(packageNames.get(\n                        ThreadLocalRandom.current().nextInt(packageNames.size())), true);\n            } else {\n                mSamplingStrategy = SAMPLING_STRATEGY_UNIFORM_OPS;\n                resampleAppOpForPackageLocked(packageNames.get(\n                        ThreadLocalRandom.current().nextInt(packageNames.size())), false);\n            }\n        }\n    }\n\n    /** Resamples appop for the chosen package and initializes sampling state */\n    private void resampleAppOpForPackageLocked(@NonNull String packageName, boolean pickOp) {\n        mMessagesCollectedCount = 0.0f;\n        mSampledAppOpCode = pickOp ? ThreadLocalRandom.current().nextInt(_NUM_OP) : OP_NONE;\n        mAcceptableLeftDistance = _NUM_OP - 1;\n        mSampledPackage = packageName;\n    }\n\n    /**\n     * Creates list of rarely used packages - packages which were not used over last week or\n     * which declared but did not use permissions over last week.\n     *  */\n    private void initializeRarelyUsedPackagesList(@NonNull ArraySet<String> candidates) {\n        AppOpsManager appOps = mContext.getSystemService(AppOpsManager.class);\n        List<String> runtimeAppOpsList = getRuntimeAppOpsList();\n        AppOpsManager.HistoricalOpsRequest histOpsRequest =\n                new AppOpsManager.HistoricalOpsRequest.Builder(\n                        Math.max(Instant.now().minus(7, ChronoUnit.DAYS).toEpochMilli(), 0),\n                        Long.MAX_VALUE).setOpNames(runtimeAppOpsList).setFlags(\n                        OP_FLAG_SELF | OP_FLAG_TRUSTED_PROXIED).build();\n        appOps.getHistoricalOps(histOpsRequest, AsyncTask.THREAD_POOL_EXECUTOR,\n                new Consumer<HistoricalOps>() {\n                    @Override\n                    public void accept(HistoricalOps histOps) {\n                        int uidCount = histOps.getUidCount();\n                        for (int uidIdx = 0; uidIdx < uidCount; uidIdx++) {\n                            final AppOpsManager.HistoricalUidOps uidOps = histOps.getUidOpsAt(\n                                    uidIdx);\n                            int pkgCount = uidOps.getPackageCount();\n                            for (int pkgIdx = 0; pkgIdx < pkgCount; pkgIdx++) {\n                                String packageName = uidOps.getPackageOpsAt(\n                                        pkgIdx).getPackageName();\n                                if (!candidates.contains(packageName)) {\n                                    continue;\n                                }\n                                AppOpsManager.HistoricalPackageOps packageOps =\n                                        uidOps.getPackageOpsAt(pkgIdx);\n                                if (packageOps.getOpCount() != 0) {\n                                    candidates.remove(packageName);\n                                }\n                            }\n                        }\n                        synchronized (this) {\n                            int numPkgs = mRarelyUsedPackages.size();\n                            for (int i = 0; i < numPkgs; i++) {\n                                candidates.add(mRarelyUsedPackages.valueAt(i));\n                            }\n                            mRarelyUsedPackages = candidates;\n                        }\n                    }\n                });\n    }\n\n    /** List of app ops related to runtime permissions */\n    private List<String> getRuntimeAppOpsList() {\n        ArrayList<String> result = new ArrayList();\n        for (int i = 0; i < _NUM_OP; i++) {\n            if (shouldCollectNotes(i)) {\n                result.add(opToPublicName(i));\n            }\n        }\n        return result;\n    }\n\n    /** Returns list of packages to be used for package sampling */\n    private @NonNull List<String> getPackageNamesForSampling() {\n        List<String> packageNames = new ArrayList<>();\n        PackageManagerInternal packageManagerInternal = LocalServices.getService(\n                PackageManagerInternal.class);\n        PackageList packages = packageManagerInternal.getPackageList();\n        for (String packageName : packages.getPackageNames()) {\n            PackageInfo pkg = packageManagerInternal.getPackageInfo(packageName,\n                    PackageManager.GET_PERMISSIONS, Process.myUid(), mContext.getUserId());\n            if (isSamplingTarget(pkg)) {\n                packageNames.add(pkg.packageName);\n            }\n        }\n        return packageNames;\n    }\n\n    /** Checks whether package should be included in sampling pool */\n    private boolean isSamplingTarget(@Nullable PackageInfo pkg) {\n        if (pkg == null) {\n            return false;\n        }\n        String[] requestedPermissions = pkg.requestedPermissions;\n        if (requestedPermissions == null) {\n            return false;\n        }\n        for (String permission : requestedPermissions) {\n            PermissionInfo permissionInfo;\n            try {\n                permissionInfo = mContext.getPackageManager().getPermissionInfo(permission, 0);\n            } catch (PackageManager.NameNotFoundException ignored) {\n                continue;\n            }\n            if (permissionInfo.getProtection() == PROTECTION_DANGEROUS) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void removeUidsForUserLocked(int userHandle) {\n        for (int i = mUidStates.size() - 1; i >= 0; --i) {\n            final int uid = mUidStates.keyAt(i);\n            if (UserHandle.getUserId(uid) == userHandle) {\n                mUidStates.removeAt(i);\n            }\n        }\n    }\n\n    private void checkSystemUid(String function) {\n        int uid = Binder.getCallingUid();\n        if (uid != Process.SYSTEM_UID) {\n            throw new SecurityException(function + \" must by called by the system\");\n        }\n    }\n\n    private static int resolveUid(String packageName)  {\n        if (packageName == null) {\n            return -1;\n        }\n        switch (packageName) {\n            case \"root\":\n                return Process.ROOT_UID;\n            case \"shell\":\n            case \"dumpstate\":\n                return Process.SHELL_UID;\n            case \"media\":\n                return Process.MEDIA_UID;\n            case \"audioserver\":\n                return Process.AUDIOSERVER_UID;\n            case \"cameraserver\":\n                return Process.CAMERASERVER_UID;\n        }\n        return -1;\n    }\n\n    private static String[] getPackagesForUid(int uid) {\n        String[] packageNames = null;\n\n        // Very early during boot the package manager is not yet or not yet fully started. At this\n        // time there are no packages yet.\n        if (AppGlobals.getPackageManager() != null) {\n            try {\n                packageNames = AppGlobals.getPackageManager().getPackagesForUid(uid);\n            } catch (RemoteException e) {\n                /* ignore - local call */\n            }\n        }\n        if (packageNames == null) {\n            return EmptyArray.STRING;\n        }\n        return packageNames;\n    }\n\n    private final class ClientUserRestrictionState implements DeathRecipient {\n        private final IBinder token;\n        SparseArray<boolean[]> perUserRestrictions;\n        SparseArray<PackageTagsList> perUserExcludedPackageTags;\n\n        ClientUserRestrictionState(IBinder token)\n                throws RemoteException {\n            token.linkToDeath(this, 0);\n            this.token = token;\n        }\n\n        public boolean setRestriction(int code, boolean restricted,\n                PackageTagsList excludedPackageTags, int userId) {\n            boolean changed = false;\n\n            if (perUserRestrictions == null && restricted) {\n                perUserRestrictions = new SparseArray<>();\n            }\n\n            int[] users;\n            if (userId == UserHandle.USER_ALL) {\n                // TODO(b/162888972): this call is returning all users, not just live ones - we\n                // need to either fix the method called, or rename the variable\n                List<UserInfo> liveUsers = UserManager.get(mContext).getUsers();\n\n                users = new int[liveUsers.size()];\n                for (int i = 0; i < liveUsers.size(); i++) {\n                    users[i] = liveUsers.get(i).id;\n                }\n            } else {\n                users = new int[]{userId};\n            }\n\n            if (perUserRestrictions != null) {\n                int numUsers = users.length;\n\n                for (int i = 0; i < numUsers; i++) {\n                    int thisUserId = users[i];\n\n                    boolean[] userRestrictions = perUserRestrictions.get(thisUserId);\n                    if (userRestrictions == null && restricted) {\n                        userRestrictions = new boolean[AppOpsManager._NUM_OP];\n                        perUserRestrictions.put(thisUserId, userRestrictions);\n                    }\n                    if (userRestrictions != null && userRestrictions[code] != restricted) {\n                        userRestrictions[code] = restricted;\n                        if (!restricted && isDefault(userRestrictions)) {\n                            perUserRestrictions.remove(thisUserId);\n                            userRestrictions = null;\n                        }\n                        changed = true;\n                    }\n\n                    if (userRestrictions != null) {\n                        final boolean noExcludedPackages =\n                                excludedPackageTags == null || excludedPackageTags.isEmpty();\n                        if (perUserExcludedPackageTags == null && !noExcludedPackages) {\n                            perUserExcludedPackageTags = new SparseArray<>();\n                        }\n                        if (perUserExcludedPackageTags != null) {\n                            if (noExcludedPackages) {\n                                perUserExcludedPackageTags.remove(thisUserId);\n                                if (perUserExcludedPackageTags.size() <= 0) {\n                                    perUserExcludedPackageTags = null;\n                                }\n                            } else {\n                                perUserExcludedPackageTags.put(thisUserId, excludedPackageTags);\n                            }\n                            changed = true;\n                        }\n                    }\n                }\n            }\n\n            return changed;\n        }\n\n        public boolean hasRestriction(int restriction, String packageName, String attributionTag,\n                int userId, boolean isCheckOp) {\n            if (perUserRestrictions == null) {\n                return false;\n            }\n            boolean[] restrictions = perUserRestrictions.get(userId);\n            if (restrictions == null) {\n                return false;\n            }\n            if (!restrictions[restriction]) {\n                return false;\n            }\n            if (perUserExcludedPackageTags == null) {\n                return true;\n            }\n            PackageTagsList perUserExclusions = perUserExcludedPackageTags.get(userId);\n            if (perUserExclusions == null) {\n                return true;\n            }\n\n            if (isCheckOp) {\n                return !perUserExclusions.includes(packageName);\n            }\n            return !perUserExclusions.contains(packageName, attributionTag);\n        }\n\n        public void removeUser(int userId) {\n            if (perUserExcludedPackageTags != null) {\n                perUserExcludedPackageTags.remove(userId);\n                if (perUserExcludedPackageTags.size() <= 0) {\n                    perUserExcludedPackageTags = null;\n                }\n            }\n            if (perUserRestrictions != null) {\n                perUserRestrictions.remove(userId);\n                if (perUserRestrictions.size() <= 0) {\n                    perUserRestrictions = null;\n                }\n            }\n        }\n\n        public boolean isDefault() {\n            return perUserRestrictions == null || perUserRestrictions.size() <= 0;\n        }\n\n        @Override\n        public void binderDied() {\n            synchronized (AppOpsService.this) {\n                mOpUserRestrictions.remove(token);\n                if (perUserRestrictions == null) {\n                    return;\n                }\n                final int userCount = perUserRestrictions.size();\n                for (int i = 0; i < userCount; i++) {\n                    final boolean[] restrictions = perUserRestrictions.valueAt(i);\n                    final int restrictionCount = restrictions.length;\n                    for (int j = 0; j < restrictionCount; j++) {\n                        if (restrictions[j]) {\n                            final int changedCode = j;\n                            mHandler.post(() -> notifyWatchersOfChange(changedCode, UID_ANY));\n                        }\n                    }\n                }\n                destroy();\n            }\n        }\n\n        public void destroy() {\n            token.unlinkToDeath(this, 0);\n        }\n\n        private boolean isDefault(boolean[] array) {\n            if (ArrayUtils.isEmpty(array)) {\n                return true;\n            }\n            for (boolean value : array) {\n                if (value) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    private final class ClientGlobalRestrictionState implements DeathRecipient {\n        final IBinder mToken;\n        final ArraySet<Integer> mRestrictedOps = new ArraySet<>();\n\n        ClientGlobalRestrictionState(IBinder token)\n                throws RemoteException {\n            token.linkToDeath(this, 0);\n            this.mToken = token;\n        }\n\n        boolean setRestriction(int code, boolean restricted) {\n            if (restricted) {\n                return mRestrictedOps.add(code);\n            } else {\n                return mRestrictedOps.remove(code);\n            }\n        }\n\n        boolean hasRestriction(int code) {\n            return mRestrictedOps.contains(code);\n        }\n\n        boolean isDefault() {\n            return mRestrictedOps.isEmpty();\n        }\n\n        @Override\n        public void binderDied() {\n            destroy();\n        }\n\n        void destroy() {\n            mToken.unlinkToDeath(this, 0);\n        }\n    }\n\n    private final class AppOpsManagerInternalImpl extends AppOpsManagerInternal {\n        @Override public void setDeviceAndProfileOwners(SparseIntArray owners) {\n            synchronized (AppOpsService.this) {\n                mProfileOwners = owners;\n            }\n        }\n\n        @Override\n        public void updateAppWidgetVisibility(SparseArray<String> uidPackageNames,\n                boolean visible) {\n            AppOpsService.this.updateAppWidgetVisibility(uidPackageNames, visible);\n        }\n\n        @Override\n        public void setUidModeFromPermissionPolicy(int code, int uid, int mode,\n                @Nullable IAppOpsCallback callback) {\n            setUidMode(code, uid, mode, callback);\n        }\n\n        @Override\n        public void setModeFromPermissionPolicy(int code, int uid, @NonNull String packageName,\n                int mode, @Nullable IAppOpsCallback callback) {\n            setMode(code, uid, packageName, mode, callback);\n        }\n\n\n        @Override\n        public void setGlobalRestriction(int code, boolean restricted, IBinder token) {\n            if (Binder.getCallingPid() != Process.myPid()) {\n                // TODO instead of this enforcement put in AppOpsManagerInternal\n                throw new SecurityException(\"Only the system can set global restrictions\");\n            }\n\n            synchronized (AppOpsService.this) {\n                ClientGlobalRestrictionState restrictionState = mOpGlobalRestrictions.get(token);\n\n                if (restrictionState == null) {\n                    try {\n                        restrictionState = new ClientGlobalRestrictionState(token);\n                    } catch (RemoteException  e) {\n                        return;\n                    }\n                    mOpGlobalRestrictions.put(token, restrictionState);\n                }\n\n                if (restrictionState.setRestriction(code, restricted)) {\n                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                            AppOpsService::notifyWatchersOfChange, AppOpsService.this, code,\n                            UID_ANY));\n                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                            AppOpsService::updateStartedOpModeForUser, AppOpsService.this,\n                            code, restricted, UserHandle.USER_ALL));\n                }\n\n                if (restrictionState.isDefault()) {\n                    mOpGlobalRestrictions.remove(token);\n                    restrictionState.destroy();\n                }\n            }\n        }\n\n        @Override\n        public int getOpRestrictionCount(int code, UserHandle user, String pkg,\n                String attributionTag) {\n            int number = 0;\n            synchronized (AppOpsService.this) {\n                int numRestrictions = mOpUserRestrictions.size();\n                for (int i = 0; i < numRestrictions; i++) {\n                    if (mOpUserRestrictions.valueAt(i)\n                            .hasRestriction(code, pkg, attributionTag, user.getIdentifier(),\n                                    false)) {\n                        number++;\n                    }\n                }\n\n                numRestrictions = mOpGlobalRestrictions.size();\n                for (int i = 0; i < numRestrictions; i++) {\n                    if (mOpGlobalRestrictions.valueAt(i).hasRestriction(code)) {\n                        number++;\n                    }\n                }\n            }\n\n            return number;\n        }\n    }\n\n    /**\n     * Async task for writing note op stack trace, op code, package name and version to file\n     * More specifically, writes all the collected ops from {@link #mNoteOpCallerStacktraces}\n     */\n    private void writeNoteOps() {\n        synchronized (this) {\n            mWriteNoteOpsScheduled = false;\n        }\n        synchronized (mNoteOpCallerStacktracesFile) {\n            try (FileWriter writer = new FileWriter(mNoteOpCallerStacktracesFile)) {\n                int numTraces = mNoteOpCallerStacktraces.size();\n                for (int i = 0; i < numTraces; i++) {\n                    // Writing json formatted string into file\n                    writer.write(mNoteOpCallerStacktraces.valueAt(i).asJson());\n                    // Comma separation, so we can wrap the entire log as a JSON object\n                    // when all results are collected\n                    writer.write(\",\");\n                }\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to load opsValidation file for FileWriter\", e);\n            }\n        }\n    }\n\n    /**\n     * This class represents a NoteOp Trace object amd contains the necessary fields that will\n     * be written to file to use for permissions data validation in JSON format\n     */\n    @Immutable\n    static class NoteOpTrace {\n        static final String STACKTRACE = \"stackTrace\";\n        static final String OP = \"op\";\n        static final String PACKAGENAME = \"packageName\";\n        static final String VERSION = \"version\";\n\n        private final @NonNull String mStackTrace;\n        private final int mOp;\n        private final @Nullable String mPackageName;\n        private final long mVersion;\n\n        /**\n         * Initialize a NoteOp object using a JSON object containing the necessary fields\n         *\n         * @param jsonTrace JSON object represented as a string\n         *\n         * @return NoteOpTrace object initialized with JSON fields\n         */\n        static NoteOpTrace fromJson(String jsonTrace) {\n            try {\n                // Re-add closing bracket which acted as a delimiter by the reader\n                JSONObject obj = new JSONObject(jsonTrace.concat(\"}\"));\n                return new NoteOpTrace(obj.getString(STACKTRACE), obj.getInt(OP),\n                        obj.getString(PACKAGENAME), obj.getLong(VERSION));\n            } catch (JSONException e) {\n                // Swallow error, only meant for logging ops, should not affect flow of the code\n                Slog.e(TAG, \"Error constructing NoteOpTrace object \"\n                        + \"JSON trace format incorrect\", e);\n                return null;\n            }\n        }\n\n        NoteOpTrace(String stackTrace, int op, String packageName, long version) {\n            mStackTrace = stackTrace;\n            mOp = op;\n            mPackageName = packageName;\n            mVersion = version;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            NoteOpTrace that = (NoteOpTrace) o;\n            return mOp == that.mOp\n                    && mVersion == that.mVersion\n                    && mStackTrace.equals(that.mStackTrace)\n                    && Objects.equals(mPackageName, that.mPackageName);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(mStackTrace, mOp, mPackageName, mVersion);\n        }\n\n        /**\n         * The object is formatted as a JSON object and returned as a String\n         *\n         * @return JSON formatted string\n         */\n        public String asJson() {\n            return  \"{\"\n                    + \"\\\"\" + STACKTRACE + \"\\\":\\\"\" + mStackTrace.replace(\"\\n\", \"\\\\n\")\n                    + '\\\"' + \",\\\"\" + OP + \"\\\":\" + mOp\n                    + \",\\\"\" + PACKAGENAME + \"\\\":\\\"\" + mPackageName + '\\\"'\n                    + \",\\\"\" + VERSION + \"\\\":\" + mVersion\n                    + '}';\n        }\n    }\n\n    /**\n     * Collects noteOps, noteProxyOps and startOps from AppOpsManager and writes it into a file\n     * which will be used for permissions data validation, the given parameters to this method\n     * will be logged in json format\n     *\n     * @param stackTrace stacktrace from the most recent call in AppOpsManager\n     * @param op op code\n     * @param packageName package making call\n     * @param version android version for this call\n     */\n    @Override\n    public void collectNoteOpCallsForValidation(String stackTrace, int op, String packageName,\n            long version) {\n        if (!AppOpsManager.NOTE_OP_COLLECTION_ENABLED) {\n            return;\n        }\n\n        Objects.requireNonNull(stackTrace);\n        Preconditions.checkArgument(op >= 0);\n        Preconditions.checkArgument(op < AppOpsManager._NUM_OP);\n        Objects.requireNonNull(version);\n\n        NoteOpTrace noteOpTrace = new NoteOpTrace(stackTrace, op, packageName, version);\n\n        boolean noteOpSetWasChanged;\n        synchronized (this) {\n            noteOpSetWasChanged = mNoteOpCallerStacktraces.add(noteOpTrace);\n            if (noteOpSetWasChanged && !mWriteNoteOpsScheduled) {\n                mWriteNoteOpsScheduled = true;\n                mHandler.postDelayed(PooledLambda.obtainRunnable((that) -> {\n                    AsyncTask.execute(() -> {\n                        that.writeNoteOps();\n                    });\n                }, this), 2500);\n            }\n        }\n    }\n\n    @Immutable\n    private final class CheckOpsDelegateDispatcher {\n        private final @Nullable CheckOpsDelegate mPolicy;\n        private final @Nullable CheckOpsDelegate mCheckOpsDelegate;\n\n        CheckOpsDelegateDispatcher(@Nullable CheckOpsDelegate policy,\n                @Nullable CheckOpsDelegate checkOpsDelegate) {\n            mPolicy = policy;\n            mCheckOpsDelegate = checkOpsDelegate;\n        }\n\n        public @NonNull CheckOpsDelegate getCheckOpsDelegate() {\n            return mCheckOpsDelegate;\n        }\n\n        public int checkOperation(int code, int uid, String packageName,\n                @Nullable String attributionTag, boolean raw) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.checkOperation(code, uid, packageName, attributionTag, raw,\n                            this::checkDelegateOperationImpl);\n                } else {\n                    return mPolicy.checkOperation(code, uid, packageName, attributionTag, raw,\n                            AppOpsService.this::checkOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return checkDelegateOperationImpl(code, uid, packageName, attributionTag, raw);\n            }\n            return checkOperationImpl(code, uid, packageName, attributionTag, raw);\n        }\n\n        private int checkDelegateOperationImpl(int code, int uid, String packageName,\n                @Nullable String attributionTag, boolean raw) {\n            return mCheckOpsDelegate.checkOperation(code, uid, packageName, attributionTag, raw,\n                    AppOpsService.this::checkOperationImpl);\n        }\n\n        public int checkAudioOperation(int code, int usage, int uid, String packageName) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.checkAudioOperation(code, usage, uid, packageName,\n                            this::checkDelegateAudioOperationImpl);\n                } else {\n                    return mPolicy.checkAudioOperation(code, usage, uid, packageName,\n                            AppOpsService.this::checkAudioOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return checkDelegateAudioOperationImpl(code, usage, uid, packageName);\n            }\n            return checkAudioOperationImpl(code, usage, uid, packageName);\n        }\n\n        private int checkDelegateAudioOperationImpl(int code, int usage, int uid,\n                String packageName) {\n            return mCheckOpsDelegate.checkAudioOperation(code, usage, uid, packageName,\n                    AppOpsService.this::checkAudioOperationImpl);\n        }\n\n        public SyncNotedAppOp noteOperation(int code, int uid, String packageName,\n                String attributionTag, boolean shouldCollectAsyncNotedOp, String message,\n                boolean shouldCollectMessage) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.noteOperation(code, uid, packageName, attributionTag,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            this::noteDelegateOperationImpl);\n                } else {\n                    return mPolicy.noteOperation(code, uid, packageName, attributionTag,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            AppOpsService.this::noteOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return noteDelegateOperationImpl(code, uid, packageName,\n                        attributionTag, shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n            }\n            return noteOperationImpl(code, uid, packageName, attributionTag,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n        }\n\n        private SyncNotedAppOp noteDelegateOperationImpl(int code, int uid,\n                @Nullable String packageName, @Nullable String featureId,\n                boolean shouldCollectAsyncNotedOp, @Nullable String message,\n                boolean shouldCollectMessage) {\n            return mCheckOpsDelegate.noteOperation(code, uid, packageName, featureId,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    AppOpsService.this::noteOperationImpl);\n        }\n\n        public SyncNotedAppOp noteProxyOperation(int code, AttributionSource attributionSource,\n                boolean shouldCollectAsyncNotedOp, @Nullable String message,\n                boolean shouldCollectMessage, boolean skipProxyOperation) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.noteProxyOperation(code, attributionSource,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            skipProxyOperation, this::noteDelegateProxyOperationImpl);\n                } else {\n                    return mPolicy.noteProxyOperation(code, attributionSource,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            skipProxyOperation, AppOpsService.this::noteProxyOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return noteDelegateProxyOperationImpl(code,\n                        attributionSource, shouldCollectAsyncNotedOp, message,\n                        shouldCollectMessage, skipProxyOperation);\n            }\n            return noteProxyOperationImpl(code, attributionSource, shouldCollectAsyncNotedOp,\n                    message, shouldCollectMessage,skipProxyOperation);\n        }\n\n        private SyncNotedAppOp noteDelegateProxyOperationImpl(int code,\n                @NonNull AttributionSource attributionSource, boolean shouldCollectAsyncNotedOp,\n                @Nullable String message, boolean shouldCollectMessage,\n                boolean skipProxyOperation) {\n            return mCheckOpsDelegate.noteProxyOperation(code, attributionSource,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n                    AppOpsService.this::noteProxyOperationImpl);\n        }\n\n        public SyncNotedAppOp startOperation(IBinder token, int code, int uid,\n                @Nullable String packageName, @NonNull String attributionTag,\n                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp,\n                @Nullable String message, boolean shouldCollectMessage,\n                @AttributionFlags int attributionFlags, int attributionChainId) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.startOperation(token, code, uid, packageName,\n                            attributionTag, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                            shouldCollectMessage, attributionFlags, attributionChainId,\n                            this::startDelegateOperationImpl);\n                } else {\n                    return mPolicy.startOperation(token, code, uid, packageName, attributionTag,\n                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                            shouldCollectMessage, attributionFlags, attributionChainId,\n                            AppOpsService.this::startOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return startDelegateOperationImpl(token, code, uid, packageName, attributionTag,\n                        startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                        shouldCollectMessage, attributionFlags, attributionChainId);\n            }\n            return startOperationImpl(token, code, uid, packageName, attributionTag,\n                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    attributionFlags, attributionChainId);\n        }\n\n        private SyncNotedAppOp startDelegateOperationImpl(IBinder token, int code, int uid,\n                @Nullable String packageName, @Nullable String attributionTag,\n                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n                boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n                int attributionChainId) {\n            return mCheckOpsDelegate.startOperation(token, code, uid, packageName, attributionTag,\n                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    attributionFlags, attributionChainId, AppOpsService.this::startOperationImpl);\n        }\n\n        public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                            shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                            proxiedAttributionFlags, attributionChainId,\n                            this::startDelegateProxyOperationImpl);\n                } else {\n                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                            shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                            proxiedAttributionFlags, attributionChainId,\n                            AppOpsService.this::startProxyOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return startDelegateProxyOperationImpl(clientId, code, attributionSource,\n                        startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                        shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                        proxiedAttributionFlags, attributionChainId);\n            }\n            return startProxyOperationImpl(clientId, code, attributionSource, startIfModeDefault,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n                    proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n        }\n\n        private SyncNotedAppOp startDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                @AttributionFlags int proxiedAttributionFlsgs, int attributionChainId) {\n            return mCheckOpsDelegate.startProxyOperation(clientId, code, attributionSource,\n                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlsgs,\n                    attributionChainId, AppOpsService.this::startProxyOperationImpl);\n        }\n\n        public void finishOperation(IBinder clientId, int code, int uid, String packageName,\n                String attributionTag) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    mPolicy.finishOperation(clientId, code, uid, packageName, attributionTag,\n                            this::finishDelegateOperationImpl);\n                } else {\n                    mPolicy.finishOperation(clientId, code, uid, packageName, attributionTag,\n                            AppOpsService.this::finishOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                finishDelegateOperationImpl(clientId, code, uid, packageName, attributionTag);\n            } else {\n                finishOperationImpl(clientId, code, uid, packageName, attributionTag);\n            }\n        }\n\n        private void finishDelegateOperationImpl(IBinder clientId, int code, int uid,\n                String packageName, String attributionTag) {\n            mCheckOpsDelegate.finishOperation(clientId, code, uid, packageName, attributionTag,\n                    AppOpsService.this::finishOperationImpl);\n        }\n\n        public void finishProxyOperation(@NonNull IBinder clientId, int code,\n                @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n                            skipProxyOperation, this::finishDelegateProxyOperationImpl);\n                } else {\n                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n                            skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                finishDelegateProxyOperationImpl(clientId, code, attributionSource,\n                        skipProxyOperation);\n            } else {\n                finishProxyOperationImpl(clientId, code, attributionSource, skipProxyOperation);\n            }\n        }\n\n        private Void finishDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n                @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n            mCheckOpsDelegate.finishProxyOperation(clientId, code, attributionSource,\n                    skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n            return null;\n        }\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 66078,
                                        "general": {
                                            "word_based": 25197,
                                            "char_based": 86697
                                        },
                                        "gemini": 77419
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "e31c33ea3586531ca99dd4c6d68a34ce07c1cebb",
                            "repo_path": "android_repos/base",
                            "result": "failure",
                            "downstream_patch_content": "commit e31c33ea3586531ca99dd4c6d68a34ce07c1cebb\nAuthor: Hao Ke <haok@google.com>\nDate:   Mon Apr 22 15:13:58 2024 +0000\n\n    Fix READ/WRITE operation access issues on Restricted appOps.\n    \n    Problems were identified around read and write access to the restricted appOps, this change includes:\n    \n    - Filter out restricted appOps status for unprivileged readers.\n    - Allow additional privileged appOps permission holder reading restricted appOps status.\n    \n    Bug: 336273802\n    Bug: 336323279\n    Test: Local test see b/336273802#comment3\n    Test: atest AppOpsTest#testRestrictedSettingsOpsRead\n    Change-Id: I09008b365e36b2c20c9a1fe5a1d52699ddb17d35\n    Merged-In: I09008b365e36b2c20c9a1fe5a1d52699ddb17d35\n\ndiff --git a/core/java/android/app/AppOpInfo.java b/core/java/android/app/AppOpInfo.java\nindex 5268ec42e21c..a0f0ccaec58c 100644\n--- a/core/java/android/app/AppOpInfo.java\n+++ b/core/java/android/app/AppOpInfo.java\n@@ -88,7 +88,7 @@ class AppOpInfo {\n \n     /**\n      * This specifies whether each option is only allowed to be read\n-     * by apps with manage appops permission.\n+     * by apps with privileged appops permission.\n      */\n     public final boolean restrictRead;\n \ndiff --git a/core/java/android/app/AppOpsManager.java b/core/java/android/app/AppOpsManager.java\nindex ccd83f756730..2ec54535cdb9 100644\n--- a/core/java/android/app/AppOpsManager.java\n+++ b/core/java/android/app/AppOpsManager.java\n@@ -2985,7 +2985,7 @@ public class AppOpsManager {\n     }\n \n     /**\n-     * Retrieve whether the op can be read by apps with manage appops permission.\n+     * Retrieve whether the op can be read by apps with privileged appops permission.\n      * @hide\n      */\n     public static boolean opRestrictsRead(int op) {\ndiff --git a/services/core/java/com/android/server/appop/AppOpsService.java b/services/core/java/com/android/server/appop/AppOpsService.java\nindex 33655f748230..e2388e2918ab 100644\n--- a/services/core/java/com/android/server/appop/AppOpsService.java\n+++ b/services/core/java/com/android/server/appop/AppOpsService.java\n@@ -1430,16 +1430,26 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n     private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops) {\n         ArrayList<AppOpsManager.OpEntry> resOps = null;\n+        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n+                Manifest.permission.GET_APP_OPS_STATS,\n+                Binder.getCallingPid(), Binder.getCallingUid())\n+                == PackageManager.PERMISSION_GRANTED;\n         if (ops == null) {\n             resOps = new ArrayList<>();\n-            for (int j=0; j<pkgOps.size(); j++) {\n+            for (int j = 0; j < pkgOps.size(); j++) {\n                 Op curOp = pkgOps.valueAt(j);\n+                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                    continue;\n+                }\n                 resOps.add(getOpEntryForResult(curOp));\n             }\n         } else {\n-            for (int j=0; j<ops.length; j++) {\n+            for (int j = 0; j < ops.length; j++) {\n                 Op curOp = pkgOps.get(ops[j]);\n                 if (curOp != null) {\n+                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                        continue;\n+                    }\n                     if (resOps == null) {\n                         resOps = new ArrayList<>();\n                     }\n@@ -3615,10 +3625,21 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n     private void verifyIncomingOp(int op) {\n         if (op >= 0 && op < AppOpsManager._NUM_OP) {\n-            // Enforce manage appops permission if it's a restricted read op.\n+            // Enforce privileged appops permission if it's a restricted read op.\n             if (opRestrictsRead(op)) {\n-                mContext.enforcePermission(Manifest.permission.MANAGE_APPOPS,\n-                        Binder.getCallingPid(), Binder.getCallingUid(), \"verifyIncomingOp\");\n+                if (!(mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n+                        Manifest.permission.GET_APP_OPS_STATS,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n+                        Manifest.permission.MANAGE_APP_OPS_MODES,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED)) {\n+                    throw new SecurityException(\"verifyIncomingOp: uid \" + Binder.getCallingUid()\n+                            + \" does not have any of {MANAGE_APPOPS, GET_APP_OPS_STATS, \"\n+                            + \"MANAGE_APP_OPS_MODES}\");\n+                }\n             }\n             return;\n         }\n",
                            "downstream_patch_tokens": {
                                "openai": 1193,
                                "general": {
                                    "word_based": 485,
                                    "char_based": 1247
                                },
                                "gemini": 1534
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
                                    "total_hunks": 2,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n                if (!(mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n                        Manifest.permission.GET_APP_OPS_STATS,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n                        Manifest.permission.MANAGE_APP_OPS_MODES,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED)) {\n                    throw new SecurityException(\"verifyIncomingOp: uid \" + Binder.getCallingUid()\n                            + \" does not have any of {MANAGE_APPOPS, GET_APP_OPS_STATS, \"\n                            + \"MANAGE_APP_OPS_MODES}\");\n                }\n            }\n            return;\n        }\n>>>>>>> UPSTREAM PATCH (commit 955e78071ec49139583056e21f612edba6439436)",
                                            "merge_conflict_tokens": {
                                                "openai": 193,
                                                "general": {
                                                    "word_based": 57,
                                                    "char_based": 272
                                                },
                                                "gemini": 258
                                            }
                                        }
                                    ],
                                    "inline_merge_token_summary": {
                                        "gemini": 32508,
                                        "openai": 24511,
                                        "general_word": 7239,
                                        "general_char": 34544
                                    },
                                    "rej_file_content": "```diff\n--- services/core/java/com/android/server/appop/AppOpsService.java\n+++ services/core/java/com/android/server/appop/AppOpsService.java\n@@ -1563,19 +1563,29 @@ public class AppOpsService extends IAppOpsService.Stub {\n     private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops,\n             String persistentDeviceId) {\n         ArrayList<AppOpsManager.OpEntry> resOps = null;\n+        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n+                Manifest.permission.GET_APP_OPS_STATS,\n+                Binder.getCallingPid(), Binder.getCallingUid())\n+                == PackageManager.PERMISSION_GRANTED;\n         if (ops == null) {\n             resOps = new ArrayList<>();\n-            for (int j=0; j<pkgOps.size(); j++) {\n+            for (int j = 0; j < pkgOps.size(); j++) {\n                 Op curOp = pkgOps.valueAt(j);\n+                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                    continue;\n+                }\n                 resOps.add(getOpEntryForResult(curOp, persistentDeviceId));\n             }\n         } else {\n-            for (int j=0; j<ops.length; j++) {\n+            for (int j = 0; j < ops.length; j++) {\n                 Op curOp = pkgOps.get(ops[j]);\n                 if (curOp != null) {\n                     if (resOps == null) {\n                         resOps = new ArrayList<>();\n                     }\n+                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                        continue;\n+                    }\n                     resOps.add(getOpEntryForResult(curOp, persistentDeviceId));\n                 }\n             }\n```",
                                    "rej_file_tokens": {
                                        "openai": 368,
                                        "general": {
                                            "word_based": 138,
                                            "char_based": 418
                                        },
                                        "gemini": 450
                                    },
                                    "patch_apply_output": "patching file services/core/java/com/android/server/appop/AppOpsService.java\nHunk #1 FAILED at 1563.\nHunk #2 succeeded at 3615 (offset -627 lines).\n1 out of 2 hunks FAILED -- saving rejects to file services/core/java/com/android/server/appop/AppOpsService.java.rej",
                                    "inline_merge_output": "patching file services/core/java/com/android/server/appop/AppOpsService.java\nHunk #1 already applied at 1566-1569,1572,1574-1576,1580, merged at 1589-1591.\nHunk #2 already applied at 4258, NOT MERGED at 4260-4278.",
                                    "upstream_file_tokens": {
                                        "openai": 63381,
                                        "general": {
                                            "word_based": 23827,
                                            "char_based": 83324
                                        },
                                        "gemini": 74277
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.appop;\n\nimport static android.app.AppOpsManager.ATTRIBUTION_CHAIN_ID_NONE;\nimport static android.app.AppOpsManager.ATTRIBUTION_FLAG_TRUSTED;\nimport static android.app.AppOpsManager.CALL_BACK_ON_SWITCHED_OP;\nimport static android.app.AppOpsManager.FILTER_BY_ATTRIBUTION_TAG;\nimport static android.app.AppOpsManager.FILTER_BY_OP_NAMES;\nimport static android.app.AppOpsManager.FILTER_BY_PACKAGE_NAME;\nimport static android.app.AppOpsManager.FILTER_BY_UID;\nimport static android.app.AppOpsManager.HISTORY_FLAG_GET_ATTRIBUTION_CHAINS;\nimport static android.app.AppOpsManager.HistoricalOpsRequestFilter;\nimport static android.app.AppOpsManager.KEY_BG_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.KEY_FG_SERVICE_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.KEY_TOP_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.MODE_ALLOWED;\nimport static android.app.AppOpsManager.MODE_DEFAULT;\nimport static android.app.AppOpsManager.MODE_ERRORED;\nimport static android.app.AppOpsManager.MODE_FOREGROUND;\nimport static android.app.AppOpsManager.MODE_IGNORED;\nimport static android.app.AppOpsManager.OP_CAMERA;\nimport static android.app.AppOpsManager.OP_CAMERA_SANDBOXED;\nimport static android.app.AppOpsManager.OP_FLAGS_ALL;\nimport static android.app.AppOpsManager.OP_FLAG_SELF;\nimport static android.app.AppOpsManager.OP_FLAG_TRUSTED_PROXIED;\nimport static android.app.AppOpsManager.OP_NONE;\nimport static android.app.AppOpsManager.OP_PLAY_AUDIO;\nimport static android.app.AppOpsManager.OP_RECEIVE_AMBIENT_TRIGGER_AUDIO;\nimport static android.app.AppOpsManager.OP_RECORD_AUDIO;\nimport static android.app.AppOpsManager.OP_RECORD_AUDIO_HOTWORD;\nimport static android.app.AppOpsManager.OP_RECORD_AUDIO_SANDBOXED;\nimport static android.app.AppOpsManager.OP_VIBRATE;\nimport static android.app.AppOpsManager.OnOpStartedListener.START_TYPE_FAILED;\nimport static android.app.AppOpsManager.OnOpStartedListener.START_TYPE_STARTED;\nimport static android.app.AppOpsManager.OpEventProxyInfo;\nimport static android.app.AppOpsManager.RestrictionBypass;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_BOOT_TIME_SAMPLING;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_RARELY_USED;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_UNIFORM;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_UNIFORM_OPS;\nimport static android.app.AppOpsManager.SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE;\nimport static android.app.AppOpsManager._NUM_OP;\nimport static android.app.AppOpsManager.extractFlagsFromKey;\nimport static android.app.AppOpsManager.extractUidStateFromKey;\nimport static android.app.AppOpsManager.modeToName;\nimport static android.app.AppOpsManager.opAllowSystemBypassRestriction;\nimport static android.app.AppOpsManager.opRestrictsRead;\nimport static android.app.AppOpsManager.opToName;\nimport static android.app.AppOpsManager.opToPublicName;\nimport static android.content.pm.PermissionInfo.PROTECTION_DANGEROUS;\nimport static android.content.pm.PermissionInfo.PROTECTION_FLAG_APPOP;\n\nimport static com.android.server.appop.AppOpsService.ModeCallback.ALL_OPS;\n\nimport android.Manifest;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.UserIdInt;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.AppOpsManager.AttributedOpEntry;\nimport android.app.AppOpsManager.AttributionFlags;\nimport android.app.AppOpsManager.HistoricalOps;\nimport android.app.AppOpsManager.Mode;\nimport android.app.AppOpsManager.OpEntry;\nimport android.app.AppOpsManager.OpFlags;\nimport android.app.AppOpsManagerInternal;\nimport android.app.AppOpsManagerInternal.CheckOpsDelegate;\nimport android.app.AsyncNotedAppOp;\nimport android.app.RuntimeAppOpAccessMessage;\nimport android.app.SyncNotedAppOp;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.content.AttributionSource;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.PermissionInfo;\nimport android.content.pm.UserInfo;\nimport android.database.ContentObserver;\nimport android.hardware.camera2.CameraDevice.CAMERA_AUDIO_RESTRICTION;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.HandlerExecutor;\nimport android.os.IBinder;\nimport android.os.PackageTagsList;\nimport android.os.Process;\nimport android.os.RemoteCallback;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.ServiceManager;\nimport android.os.ShellCallback;\nimport android.os.ShellCommand;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.os.storage.StorageManagerInternal;\nimport android.permission.PermissionManager;\nimport android.provider.Settings;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.KeyValueListParser;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\nimport android.util.SparseIntArray;\nimport android.util.TimeUtils;\nimport android.util.Xml;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.Immutable;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.app.IAppOpsActiveCallback;\nimport com.android.internal.app.IAppOpsAsyncNotedCallback;\nimport com.android.internal.app.IAppOpsCallback;\nimport com.android.internal.app.IAppOpsNotedCallback;\nimport com.android.internal.app.IAppOpsService;\nimport com.android.internal.app.IAppOpsStartedCallback;\nimport com.android.internal.app.MessageSamplingConfig;\nimport com.android.internal.compat.IPlatformCompat;\nimport com.android.internal.os.Clock;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.Preconditions;\nimport com.android.internal.util.XmlUtils;\nimport com.android.internal.util.function.pooled.PooledLambda;\nimport com.android.modules.utils.TypedXmlPullParser;\nimport com.android.modules.utils.TypedXmlSerializer;\nimport com.android.server.LocalManagerRegistry;\nimport com.android.server.LocalServices;\nimport com.android.server.LockGuard;\nimport com.android.server.SystemServerInitThreadPool;\nimport com.android.server.SystemServiceManager;\nimport com.android.server.pm.PackageList;\nimport com.android.server.pm.PackageManagerLocal;\nimport com.android.server.pm.UserManagerInternal;\nimport com.android.server.pm.pkg.AndroidPackage;\nimport com.android.server.pm.pkg.PackageState;\nimport com.android.server.pm.pkg.component.ParsedAttribution;\nimport com.android.server.policy.AppOpsPolicy;\n\nimport dalvik.annotation.optimization.NeverCompile;\n\nimport libcore.util.EmptyArray;\n\nimport org.json.JSONException;\nimport org.json.JSONObject;\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.text.SimpleDateFormat;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Consumer;\n\npublic class AppOpsService extends IAppOpsService.Stub {\n    static final String TAG = \"AppOps\";\n    static final boolean DEBUG = false;\n\n    /**\n     * Used for data access validation collection, we wish to only log a specific access once\n     */\n    private final ArraySet<NoteOpTrace> mNoteOpCallerStacktraces = new ArraySet<>();\n\n    /**\n     * Version of the mRecentAccessesFile.\n     * Increment by one every time an upgrade step is added at boot, none currently exists.\n     */\n    private static final int CURRENT_VERSION = 1;\n\n    // Write at most every 30 minutes.\n    static final long WRITE_DELAY = DEBUG ? 1000 : 30*60*1000;\n\n    // Constant meaning that any UID should be matched when dispatching callbacks\n    private static final int UID_ANY = -2;\n\n    private static final int[] OPS_RESTRICTED_ON_SUSPEND = {\n            OP_PLAY_AUDIO,\n            OP_RECORD_AUDIO,\n            OP_CAMERA,\n            OP_VIBRATE,\n    };\n\n    private static final int MAX_UNFORWARDED_OPS = 10;\n    private static final int MAX_UNUSED_POOLED_OBJECTS = 3;\n    private static final int RARELY_USED_PACKAGES_INITIALIZATION_DELAY_MILLIS = 300000;\n\n    final Context mContext;\n    final AtomicFile mStorageFile;\n    final AtomicFile mRecentAccessesFile;\n    private final @Nullable File mNoteOpCallerStacktracesFile;\n    final Handler mHandler;\n\n    /**\n     * Pool for {@link AttributedOp.OpEventProxyInfoPool} to avoid to constantly reallocate new\n     * objects\n     */\n    @GuardedBy(\"this\")\n    final AttributedOp.OpEventProxyInfoPool mOpEventProxyInfoPool =\n            new AttributedOp.OpEventProxyInfoPool(MAX_UNUSED_POOLED_OBJECTS);\n\n    /**\n     * Pool for {@link AttributedOp.InProgressStartOpEventPool} to avoid to constantly reallocate\n     * new objects\n     */\n    @GuardedBy(\"this\")\n    final AttributedOp.InProgressStartOpEventPool mInProgressStartOpEventPool =\n            new AttributedOp.InProgressStartOpEventPool(mOpEventProxyInfoPool,\n                    MAX_UNUSED_POOLED_OBJECTS);\n\n    private final AppOpsManagerInternalImpl mAppOpsManagerInternal\n            = new AppOpsManagerInternalImpl();\n    @Nullable private final DevicePolicyManagerInternal dpmi =\n            LocalServices.getService(DevicePolicyManagerInternal.class);\n\n    private final IPlatformCompat mPlatformCompat = IPlatformCompat.Stub.asInterface(\n            ServiceManager.getService(Context.PLATFORM_COMPAT_SERVICE));\n\n    /**\n     * Registered callbacks, called from {@link #collectAsyncNotedOp}.\n     *\n     * <p>(package name, uid) -> callbacks\n     *\n     * @see #getAsyncNotedOpsKey(String, int)\n     */\n    @GuardedBy(\"this\")\n    private final ArrayMap<Pair<String, Integer>, RemoteCallbackList<IAppOpsAsyncNotedCallback>>\n            mAsyncOpWatchers = new ArrayMap<>();\n\n    /**\n     * Async note-ops collected from {@link #collectAsyncNotedOp} that have not been delivered to a\n     * callback yet.\n     *\n     * <p>(package name, uid) -> list&lt;ops&gt;\n     *\n     * @see #getAsyncNotedOpsKey(String, int)\n     */\n    @GuardedBy(\"this\")\n    private final ArrayMap<Pair<String, Integer>, ArrayList<AsyncNotedAppOp>>\n            mUnforwardedAsyncNotedOps = new ArrayMap<>();\n\n    boolean mWriteNoteOpsScheduled;\n\n    boolean mWriteScheduled;\n    boolean mFastWriteScheduled;\n    final Runnable mWriteRunner = new Runnable() {\n        public void run() {\n            synchronized (AppOpsService.this) {\n                mWriteScheduled = false;\n                mFastWriteScheduled = false;\n                AsyncTask<Void, Void, Void> task = new AsyncTask<Void, Void, Void>() {\n                    @Override protected Void doInBackground(Void... params) {\n                        writeRecentAccesses();\n                        return null;\n                    }\n                };\n                task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void[])null);\n            }\n        }\n    };\n\n    @GuardedBy(\"this\")\n    @VisibleForTesting\n    final SparseArray<UidState> mUidStates = new SparseArray<>();\n\n    volatile @NonNull HistoricalRegistry mHistoricalRegistry = new HistoricalRegistry(this);\n\n    /*\n     * These are app op restrictions imposed per user from various parties.\n     */\n    private final ArrayMap<IBinder, ClientUserRestrictionState> mOpUserRestrictions =\n            new ArrayMap<>();\n\n    /*\n     * These are app op restrictions imposed globally from various parties within the system.\n     */\n    private final ArrayMap<IBinder, ClientGlobalRestrictionState> mOpGlobalRestrictions =\n            new ArrayMap<>();\n\n    SparseIntArray mProfileOwners;\n\n    private volatile CheckOpsDelegateDispatcher mCheckOpsDelegateDispatcher =\n            new CheckOpsDelegateDispatcher(/*policy*/ null, /*delegate*/ null);\n\n    /**\n      * Reverse lookup for {@link AppOpsManager#opToSwitch(int)}. Initialized once and never\n      * changed\n      */\n    private final SparseArray<int[]> mSwitchedOps = new SparseArray<>();\n\n    private ActivityManagerInternal mActivityManagerInternal;\n\n    /** Package sampled for message collection in the current session */\n    @GuardedBy(\"this\")\n    private String mSampledPackage = null;\n\n    /** Appop sampled for message collection in the current session */\n    @GuardedBy(\"this\")\n    private int mSampledAppOpCode = OP_NONE;\n\n    /** Maximum distance for appop to be considered for message collection in the current session */\n    @GuardedBy(\"this\")\n    private int mAcceptableLeftDistance = 0;\n\n    /** Number of messages collected for sampled package and appop in the current session */\n    @GuardedBy(\"this\")\n    private float mMessagesCollectedCount;\n\n    /** List of rarely used packages priorities for message collection */\n    @GuardedBy(\"this\")\n    private ArraySet<String> mRarelyUsedPackages = new ArraySet<>();\n\n    /** Sampling strategy used for current session */\n    @GuardedBy(\"this\")\n    @AppOpsManager.SamplingStrategy\n    private int mSamplingStrategy;\n\n    /** Last runtime permission access message collected and ready for reporting */\n    @GuardedBy(\"this\")\n    private RuntimeAppOpAccessMessage mCollectedRuntimePermissionMessage;\n\n    /** Package Manager internal. Access via {@link #getPackageManagerInternal()} */\n    private @Nullable PackageManagerInternal mPackageManagerInternal;\n\n    /** Package Manager local. Access via {@link #getPackageManagerLocal()} */\n    private @Nullable PackageManagerLocal mPackageManagerLocal;\n\n    /** User Manager internal. Access via {@link #getUserManagerInternal()} */\n    private @Nullable UserManagerInternal mUserManagerInternal;\n\n    /** Interface for app-op modes.*/\n    @VisibleForTesting\n    AppOpsCheckingServiceInterface mAppOpsCheckingService;\n\n    /** Interface for app-op restrictions.*/\n    @VisibleForTesting AppOpsRestrictions mAppOpsRestrictions;\n\n    private AppOpsUidStateTracker mUidStateTracker;\n\n    /** Hands the definition of foreground and uid states */\n    @GuardedBy(\"this\")\n    public AppOpsUidStateTracker getUidStateTracker() {\n        if (mUidStateTracker == null) {\n            mUidStateTracker = new AppOpsUidStateTrackerImpl(\n                    LocalServices.getService(ActivityManagerInternal.class),\n                    mHandler,\n                    r -> {\n                        synchronized (AppOpsService.this) {\n                            r.run();\n                        }\n                    },\n                    Clock.SYSTEM_CLOCK, mConstants);\n\n            mUidStateTracker.addUidStateChangedCallback(new HandlerExecutor(mHandler),\n                    this::onUidStateChanged);\n        }\n        return mUidStateTracker;\n    }\n\n    /**\n     * All times are in milliseconds. These constants are kept synchronized with the system\n     * global Settings. Any access to this class or its fields should be done while\n     * holding the AppOpsService lock.\n     */\n    final class Constants extends ContentObserver {\n\n        /**\n         * How long we want for a drop in uid state from top to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_TOP_STATE_SETTLE_TIME\n         */\n        public long TOP_STATE_SETTLE_TIME;\n\n        /**\n         * How long we want for a drop in uid state from foreground to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_FG_SERVICE_STATE_SETTLE_TIME\n         */\n        public long FG_SERVICE_STATE_SETTLE_TIME;\n\n        /**\n         * How long we want for a drop in uid state from background to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_BG_STATE_SETTLE_TIME\n         */\n        public long BG_STATE_SETTLE_TIME;\n\n        private final KeyValueListParser mParser = new KeyValueListParser(',');\n        private ContentResolver mResolver;\n\n        public Constants(Handler handler) {\n            super(handler);\n            updateConstants();\n        }\n\n        public void startMonitoring(ContentResolver resolver) {\n            mResolver = resolver;\n            mResolver.registerContentObserver(\n                    Settings.Global.getUriFor(Settings.Global.APP_OPS_CONSTANTS),\n                    false, this);\n            updateConstants();\n        }\n\n        @Override\n        public void onChange(boolean selfChange, Uri uri) {\n            updateConstants();\n        }\n\n        private void updateConstants() {\n            String value = mResolver != null ? Settings.Global.getString(mResolver,\n                    Settings.Global.APP_OPS_CONSTANTS) : \"\";\n\n            synchronized (AppOpsService.this) {\n                try {\n                    mParser.setString(value);\n                } catch (IllegalArgumentException e) {\n                    // Failed to parse the settings string, log this and move on\n                    // with defaults.\n                    Slog.e(TAG, \"Bad app ops settings\", e);\n                }\n                TOP_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_TOP_STATE_SETTLE_TIME, 5 * 1000L);\n                FG_SERVICE_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_FG_SERVICE_STATE_SETTLE_TIME, 5 * 1000L);\n                BG_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_BG_STATE_SETTLE_TIME, 1 * 1000L);\n            }\n        }\n\n        void dump(PrintWriter pw) {\n            pw.println(\"  Settings:\");\n\n            pw.print(\"    \"); pw.print(KEY_TOP_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(TOP_STATE_SETTLE_TIME, pw);\n            pw.println();\n            pw.print(\"    \"); pw.print(KEY_FG_SERVICE_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(FG_SERVICE_STATE_SETTLE_TIME, pw);\n            pw.println();\n            pw.print(\"    \"); pw.print(KEY_BG_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(BG_STATE_SETTLE_TIME, pw);\n            pw.println();\n        }\n    }\n\n    @VisibleForTesting\n    final Constants mConstants;\n\n    @VisibleForTesting\n    final class UidState {\n        public final int uid;\n\n        @NonNull\n        public final ArrayMap<String, Ops> pkgOps = new ArrayMap<>();\n\n        // true indicates there is an interested observer, false there isn't but it has such an op\n        //TODO: Move foregroundOps and hasForegroundWatchers into the AppOpsServiceInterface.\n        public SparseBooleanArray foregroundOps;\n        public boolean hasForegroundWatchers;\n\n        public UidState(int uid) {\n            this.uid = uid;\n        }\n\n        public void clear() {\n            mAppOpsCheckingService.removeUid(uid);\n            for (int i = 0; i < pkgOps.size(); i++) {\n                String packageName = pkgOps.keyAt(i);\n                mAppOpsCheckingService.removePackage(packageName, UserHandle.getUserId(uid));\n            }\n        }\n\n        // Functions for uid mode access and manipulation.\n        public SparseIntArray getNonDefaultUidModes() {\n            return mAppOpsCheckingService.getNonDefaultUidModes(uid);\n        }\n\n        public int getUidMode(int op) {\n            return mAppOpsCheckingService.getUidMode(uid, op);\n        }\n\n        public boolean setUidMode(int op, int mode) {\n            return mAppOpsCheckingService.setUidMode(uid, op, mode);\n        }\n\n        @SuppressWarnings(\"GuardedBy\")\n        int evalMode(int op, int mode) {\n            return getUidStateTracker().evalMode(uid, op, mode);\n        }\n\n        public void evalForegroundOps() {\n            foregroundOps = null;\n            foregroundOps = mAppOpsCheckingService.evalForegroundUidOps(uid, foregroundOps);\n            for (int i = pkgOps.size() - 1; i >= 0; i--) {\n                foregroundOps = mAppOpsCheckingService\n                        .evalForegroundPackageOps(pkgOps.valueAt(i).packageName, foregroundOps,\n                                UserHandle.getUserId(uid));\n            }\n            hasForegroundWatchers = false;\n            if (foregroundOps != null) {\n                for (int i = 0;  i < foregroundOps.size(); i++) {\n                    if (foregroundOps.valueAt(i)) {\n                        hasForegroundWatchers = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        @SuppressWarnings(\"GuardedBy\")\n        public int getState() {\n            return getUidStateTracker().getUidState(uid);\n        }\n\n        @SuppressWarnings(\"GuardedBy\")\n        public void dump(PrintWriter pw, long nowElapsed) {\n            getUidStateTracker().dumpUidState(pw, uid, nowElapsed);\n        }\n    }\n\n    final static class Ops extends SparseArray<Op> {\n        final String packageName;\n        final UidState uidState;\n\n        /**\n         * The restriction properties of the package. If {@code null} it could not have been read\n         * yet and has to be refreshed.\n         */\n        @Nullable RestrictionBypass bypass;\n\n        /** Lazily populated cache of attributionTags of this package */\n        final @NonNull ArraySet<String> knownAttributionTags = new ArraySet<>();\n\n        /**\n         * Lazily populated cache of <b>valid</b> attributionTags of this package, a set smaller\n         * than or equal to {@link #knownAttributionTags}.\n         */\n        final @NonNull ArraySet<String> validAttributionTags = new ArraySet<>();\n\n        Ops(String _packageName, UidState _uidState) {\n            packageName = _packageName;\n            uidState = _uidState;\n        }\n    }\n\n    /** Returned from {@link #verifyAndGetBypass(int, String, String, String, boolean)}. */\n    private static final class PackageVerificationResult {\n\n        final RestrictionBypass bypass;\n        final boolean isAttributionTagValid;\n\n        PackageVerificationResult(RestrictionBypass bypass, boolean isAttributionTagValid) {\n            this.bypass = bypass;\n            this.isAttributionTagValid = isAttributionTagValid;\n        }\n    }\n\n    final class Op {\n        int op;\n        int uid;\n        final UidState uidState;\n        final @NonNull String packageName;\n\n        /** attributionTag -> AttributedOp */\n        final ArrayMap<String, AttributedOp> mAttributions = new ArrayMap<>(1);\n\n        Op(UidState uidState, String packageName, int op, int uid) {\n            this.op = op;\n            this.uid = uid;\n            this.uidState = uidState;\n            this.packageName = packageName;\n        }\n\n        @Mode int getMode() {\n            return mAppOpsCheckingService.getPackageMode(packageName, this.op,\n                    UserHandle.getUserId(this.uid));\n        }\n        void setMode(@Mode int mode) {\n            mAppOpsCheckingService.setPackageMode(packageName, this.op, mode,\n                    UserHandle.getUserId(this.uid));\n        }\n\n        void removeAttributionsWithNoTime() {\n            for (int i = mAttributions.size() - 1; i >= 0; i--) {\n                if (!mAttributions.valueAt(i).hasAnyTime()) {\n                    mAttributions.removeAt(i);\n                }\n            }\n        }\n\n        private @NonNull AttributedOp getOrCreateAttribution(@NonNull Op parent,\n                @Nullable String attributionTag) {\n            AttributedOp attributedOp;\n\n            attributedOp = mAttributions.get(attributionTag);\n            if (attributedOp == null) {\n                attributedOp = new AttributedOp(AppOpsService.this, attributionTag, parent);\n                mAttributions.put(attributionTag, attributedOp);\n            }\n\n            return attributedOp;\n        }\n\n        @NonNull OpEntry createEntryLocked() {\n            final int numAttributions = mAttributions.size();\n\n            final ArrayMap<String, AppOpsManager.AttributedOpEntry> attributionEntries =\n                    new ArrayMap<>(numAttributions);\n            for (int i = 0; i < numAttributions; i++) {\n                attributionEntries.put(mAttributions.keyAt(i),\n                        mAttributions.valueAt(i).createAttributedOpEntryLocked());\n            }\n\n            return new OpEntry(op, getMode(), attributionEntries);\n        }\n\n        @NonNull OpEntry createSingleAttributionEntryLocked(@Nullable String attributionTag) {\n            final int numAttributions = mAttributions.size();\n\n            final ArrayMap<String, AttributedOpEntry> attributionEntries = new ArrayMap<>(1);\n            for (int i = 0; i < numAttributions; i++) {\n                if (Objects.equals(mAttributions.keyAt(i), attributionTag)) {\n                    attributionEntries.put(mAttributions.keyAt(i),\n                            mAttributions.valueAt(i).createAttributedOpEntryLocked());\n                    break;\n                }\n            }\n\n            return new OpEntry(op, getMode(), attributionEntries);\n        }\n\n        boolean isRunning() {\n            final int numAttributions = mAttributions.size();\n            for (int i = 0; i < numAttributions; i++) {\n                if (mAttributions.valueAt(i).isRunning()) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n\n    final ArrayMap<IBinder, ModeCallback> mModeWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<ActiveCallback>> mActiveWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<StartedCallback>> mStartedWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<NotedCallback>> mNotedWatchers = new ArrayMap<>();\n    final AudioRestrictionManager mAudioRestrictionManager = new AudioRestrictionManager();\n\n    final class ModeCallback extends OnOpModeChangedListener implements DeathRecipient  {\n        /** If mWatchedOpCode==ALL_OPS notify for ops affected by the switch-op */\n        public static final int ALL_OPS = -2;\n\n        // Need to keep this only because stopWatchingMode needs an IAppOpsCallback.\n        // Otherwise we can just use the IBinder object.\n        private final IAppOpsCallback mCallback;\n\n        ModeCallback(IAppOpsCallback callback, int watchingUid, int flags, int watchedOpCode,\n                int callingUid, int callingPid) {\n            super(watchingUid, flags, watchedOpCode, callingUid, callingPid);\n            this.mCallback = callback;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"ModeCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, getWatchingUid());\n            sb.append(\" flags=0x\");\n            sb.append(Integer.toHexString(getFlags()));\n            switch (getWatchedOpCode()) {\n                case OP_NONE:\n                    break;\n                case ALL_OPS:\n                    sb.append(\" op=(all)\");\n                    break;\n                default:\n                    sb.append(\" op=\");\n                    sb.append(opToName(getWatchedOpCode()));\n                    break;\n            }\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, getCallingUid());\n            sb.append(\" pid=\");\n            sb.append(getCallingPid());\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void unlinkToDeath() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingMode(mCallback);\n        }\n\n        @Override\n        public void onOpModeChanged(int op, int uid, String packageName) throws RemoteException {\n            mCallback.opChanged(op, uid, packageName);\n        }\n    }\n\n    final class ActiveCallback implements DeathRecipient {\n        final IAppOpsActiveCallback mCallback;\n        final int mWatchingUid;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        ActiveCallback(IAppOpsActiveCallback callback, int watchingUid, int callingUid,\n                int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"ActiveCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void destroy() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingActive(mCallback);\n        }\n    }\n\n    final class StartedCallback implements DeathRecipient {\n        final IAppOpsStartedCallback mCallback;\n        final int mWatchingUid;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        StartedCallback(IAppOpsStartedCallback callback, int watchingUid, int callingUid,\n                int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"StartedCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void destroy() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingStarted(mCallback);\n        }\n    }\n\n    final class NotedCallback implements DeathRecipient {\n        final IAppOpsNotedCallback mCallback;\n        final int mWatchingUid;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        NotedCallback(IAppOpsNotedCallback callback, int watchingUid, int callingUid,\n                int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"NotedCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void destroy() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingNoted(mCallback);\n        }\n    }\n\n    /**\n     * Call {@link AttributedOp#onClientDeath attributedOp.onClientDeath(clientId)}.\n     */\n    static void onClientDeath(@NonNull AttributedOp attributedOp,\n            @NonNull IBinder clientId) {\n        attributedOp.onClientDeath(clientId);\n    }\n\n\n    /**\n     * Loads the OpsValidation file results into a hashmap {@link #mNoteOpCallerStacktraces}\n     * so that we do not log the same operation twice between instances\n     */\n    private void readNoteOpCallerStackTraces() {\n        try {\n            if (!mNoteOpCallerStacktracesFile.exists()) {\n                mNoteOpCallerStacktracesFile.createNewFile();\n                return;\n            }\n\n            try (Scanner read = new Scanner(mNoteOpCallerStacktracesFile)) {\n                read.useDelimiter(\"\\\\},\");\n                while (read.hasNext()) {\n                    String jsonOps = read.next();\n                    mNoteOpCallerStacktraces.add(NoteOpTrace.fromJson(jsonOps));\n                }\n            }\n        } catch (Exception e) {\n            Slog.e(TAG, \"Cannot parse traces noteOps\", e);\n        }\n    }\n\n    @VisibleForTesting\n    public AppOpsService(File recentAccessesFile, File storageFile, Handler handler,\n            Context context) {\n        mContext = context;\n\n        for (int switchedCode = 0; switchedCode < _NUM_OP; switchedCode++) {\n            int switchCode = AppOpsManager.opToSwitch(switchedCode);\n            mSwitchedOps.put(switchCode,\n                    ArrayUtils.appendInt(mSwitchedOps.get(switchCode), switchedCode));\n        }\n        mAppOpsCheckingService = new AppOpsCheckingServiceTracingDecorator(\n                new AppOpsCheckingServiceImpl(\n                        storageFile, this, handler, context,  mSwitchedOps));\n        //mAppOpsCheckingService = new AppOpsCheckingServiceLoggingDecorator(\n        //        LocalServices.getService(AppOpsCheckingServiceInterface.class));\n        mAppOpsRestrictions = new AppOpsRestrictionsImpl(context, handler, mAppOpsCheckingService);\n\n        LockGuard.installLock(this, LockGuard.INDEX_APP_OPS);\n        mStorageFile = new AtomicFile(storageFile, \"appops_legacy\");\n        mRecentAccessesFile = new AtomicFile(recentAccessesFile, \"appops_accesses\");\n\n        if (AppOpsManager.NOTE_OP_COLLECTION_ENABLED) {\n            mNoteOpCallerStacktracesFile = new File(SystemServiceManager.ensureSystemDir(),\n                    \"noteOpStackTraces.json\");\n            readNoteOpCallerStackTraces();\n        } else {\n            mNoteOpCallerStacktracesFile = null;\n        }\n        mHandler = handler;\n        mConstants = new Constants(mHandler);\n        // To migrate storageFile to recentAccessesFile, these reads must be called in this order.\n        readRecentAccesses();\n        mAppOpsCheckingService.readState();\n    }\n\n    public void publish() {\n        ServiceManager.addService(Context.APP_OPS_SERVICE, asBinder());\n        LocalServices.addService(AppOpsManagerInternal.class, mAppOpsManagerInternal);\n        LocalManagerRegistry.addManager(AppOpsManagerLocal.class, new AppOpsManagerLocalImpl());\n    }\n\n    /** Handler for work when packages are updated */\n    private BroadcastReceiver mOnPackageUpdatedReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            String pkgName = intent.getData().getEncodedSchemeSpecificPart();\n            int uid = intent.getIntExtra(Intent.EXTRA_UID, Process.INVALID_UID);\n\n            if (action.equals(Intent.ACTION_PACKAGE_REPLACED)) {\n                AndroidPackage pkg = getPackageManagerInternal().getPackage(pkgName);\n                if (pkg == null) {\n                    return;\n                }\n\n                ArrayMap<String, String> dstAttributionTags = new ArrayMap<>();\n                ArraySet<String> attributionTags = new ArraySet<>();\n                attributionTags.add(null);\n                if (pkg.getAttributions() != null) {\n                    int numAttributions = pkg.getAttributions().size();\n                    for (int attributionNum = 0; attributionNum < numAttributions;\n                            attributionNum++) {\n                        ParsedAttribution attribution = pkg.getAttributions().get(attributionNum);\n                        attributionTags.add(attribution.getTag());\n\n                        int numInheritFrom = attribution.getInheritFrom().size();\n                        for (int inheritFromNum = 0; inheritFromNum < numInheritFrom;\n                                inheritFromNum++) {\n                            dstAttributionTags.put(attribution.getInheritFrom().get(inheritFromNum),\n                                    attribution.getTag());\n                        }\n                    }\n                }\n\n                synchronized (AppOpsService.this) {\n                    UidState uidState = mUidStates.get(uid);\n                    if (uidState == null) {\n                        return;\n                    }\n\n                    Ops ops = uidState.pkgOps.get(pkgName);\n                    if (ops == null) {\n                        return;\n                    }\n\n                    // Reset cached package properties to re-initialize when needed\n                    ops.bypass = null;\n                    ops.knownAttributionTags.clear();\n\n                    // Merge data collected for removed attributions into their successor\n                    // attributions\n                    int numOps = ops.size();\n                    for (int opNum = 0; opNum < numOps; opNum++) {\n                        Op op = ops.valueAt(opNum);\n\n                        int numAttributions = op.mAttributions.size();\n                        for (int attributionNum = numAttributions - 1; attributionNum >= 0;\n                                attributionNum--) {\n                            String attributionTag = op.mAttributions.keyAt(attributionNum);\n\n                            if (attributionTags.contains(attributionTag)) {\n                                // attribution still exist after upgrade\n                                continue;\n                            }\n\n                            String newAttributionTag = dstAttributionTags.get(attributionTag);\n\n                            AttributedOp newAttributedOp = op.getOrCreateAttribution(op,\n                                    newAttributionTag);\n                            newAttributedOp.add(op.mAttributions.valueAt(attributionNum));\n                            op.mAttributions.removeAt(attributionNum);\n\n                            scheduleFastWriteLocked();\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    public void systemReady() {\n        mAppOpsCheckingService.systemReady();\n        initializeUidStates();\n\n        mConstants.startMonitoring(mContext.getContentResolver());\n        mHistoricalRegistry.systemReady(mContext.getContentResolver());\n\n        IntentFilter packageUpdateFilter = new IntentFilter();\n        packageUpdateFilter.addAction(Intent.ACTION_PACKAGE_REPLACED);\n        packageUpdateFilter.addDataScheme(\"package\");\n\n        mContext.registerReceiverAsUser(mOnPackageUpdatedReceiver, UserHandle.ALL,\n                packageUpdateFilter, null, null);\n\n        synchronized (this) {\n            for (int uidNum = mUidStates.size() - 1; uidNum >= 0; uidNum--) {\n                int uid = mUidStates.keyAt(uidNum);\n                UidState uidState = mUidStates.valueAt(uidNum);\n\n                String[] pkgsInUid = getPackagesForUid(uidState.uid);\n                if (ArrayUtils.isEmpty(pkgsInUid)) {\n                    uidState.clear();\n                    mUidStates.removeAt(uidNum);\n                    scheduleFastWriteLocked();\n                    continue;\n                }\n\n                ArrayMap<String, Ops> pkgs = uidState.pkgOps;\n\n                int numPkgs = pkgs.size();\n                for (int pkgNum = 0; pkgNum < numPkgs; pkgNum++) {\n                    String pkg = pkgs.keyAt(pkgNum);\n\n                    String action;\n                    if (!ArrayUtils.contains(pkgsInUid, pkg)) {\n                        action = Intent.ACTION_PACKAGE_REMOVED;\n                    } else {\n                        action = Intent.ACTION_PACKAGE_REPLACED;\n                    }\n\n                    SystemServerInitThreadPool.submit(\n                            () -> mOnPackageUpdatedReceiver.onReceive(mContext, new Intent(action)\n                                    .setData(Uri.fromParts(\"package\", pkg, null))\n                                    .putExtra(Intent.EXTRA_UID, uid)),\n                            \"Update app-ops uidState in case package \" + pkg + \" changed\");\n                }\n            }\n        }\n\n        getUserManagerInternal().addUserLifecycleListener(\n                new UserManagerInternal.UserLifecycleListener() {\n                    @Override\n                    public void onUserCreated(UserInfo user, Object token) {\n                        initializeUserUidStates(user.id);\n                    }\n\n                    // onUserRemoved handled by #removeUser\n                });\n\n        getPackageManagerInternal().getPackageList(\n                new PackageManagerInternal.PackageListObserver() {\n                    @Override\n                    public void onPackageAdded(String packageName, int appId) {\n                        PackageInfo pi = getPackageManagerInternal().getPackageInfo(packageName,\n                                PackageManager.GET_PERMISSIONS, Process.myUid(),\n                                mContext.getUserId());\n                        boolean isSamplingTarget = isSamplingTarget(pi);\n                        int[] userIds = getUserManagerInternal().getUserIds();\n                        synchronized (AppOpsService.this) {\n                            if (isSamplingTarget) {\n                                mRarelyUsedPackages.add(packageName);\n                            }\n                            for (int i = 0; i < userIds.length; i++) {\n                                int uid = UserHandle.getUid(userIds[i], appId);\n                                UidState uidState = getUidStateLocked(uid, true);\n                                if (!uidState.pkgOps.containsKey(packageName)) {\n                                    uidState.pkgOps.put(packageName,\n                                            new Ops(packageName, uidState));\n                                }\n                            }\n                        }\n                    }\n\n                    @Override\n                    public void onPackageRemoved(String packageName, int appId) {\n                        int[] userIds = getUserManagerInternal().getUserIds();\n                        synchronized (AppOpsService.this) {\n                            for (int i = 0; i < userIds.length; i++) {\n                                int uid = UserHandle.getUid(userIds[i], appId);\n                                packageRemovedLocked(uid, packageName);\n                            }\n                        }\n                    }\n                });\n\n        final IntentFilter packageSuspendFilter = new IntentFilter();\n        packageSuspendFilter.addAction(Intent.ACTION_PACKAGES_UNSUSPENDED);\n        packageSuspendFilter.addAction(Intent.ACTION_PACKAGES_SUSPENDED);\n        mContext.registerReceiverAsUser(new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                final int[] changedUids = intent.getIntArrayExtra(Intent.EXTRA_CHANGED_UID_LIST);\n                final String[] changedPkgs = intent.getStringArrayExtra(\n                        Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                for (int code : OPS_RESTRICTED_ON_SUSPEND) {\n                    ArraySet<OnOpModeChangedListener> onModeChangedListeners;\n                    synchronized (AppOpsService.this) {\n                        onModeChangedListeners =\n                                mAppOpsCheckingService.getOpModeChangedListeners(code);\n                        if (onModeChangedListeners == null) {\n                            continue;\n                        }\n                    }\n                    for (int i = 0; i < changedUids.length; i++) {\n                        final int changedUid = changedUids[i];\n                        final String changedPkg = changedPkgs[i];\n                        // We trust packagemanager to insert matching uid and packageNames in the\n                        // extras\n                        notifyOpChanged(onModeChangedListeners, code, changedUid, changedPkg);\n                    }\n                }\n            }\n        }, UserHandle.ALL, packageSuspendFilter, null, null);\n\n        mHandler.postDelayed(new Runnable() {\n            @Override\n            public void run() {\n                List<String> packageNames = getPackageListAndResample();\n                initializeRarelyUsedPackagesList(new ArraySet<>(packageNames));\n            }\n        }, RARELY_USED_PACKAGES_INITIALIZATION_DELAY_MILLIS);\n\n        getPackageManagerInternal().setExternalSourcesPolicy(\n                new PackageManagerInternal.ExternalSourcesPolicy() {\n                    @Override\n                    public int getPackageTrustedToInstallApps(String packageName, int uid) {\n                        int appOpMode = checkOperation(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                                uid, packageName);\n                        switch (appOpMode) {\n                            case AppOpsManager.MODE_ALLOWED:\n                                return PackageManagerInternal.ExternalSourcesPolicy.USER_TRUSTED;\n                            case AppOpsManager.MODE_ERRORED:\n                                return PackageManagerInternal.ExternalSourcesPolicy.USER_BLOCKED;\n                            default:\n                                return PackageManagerInternal.ExternalSourcesPolicy.USER_DEFAULT;\n                        }\n                    }\n                });\n\n        mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);\n    }\n\n    /**\n     * Initialize uid state objects for state contained in the checking service.\n     */\n    @VisibleForTesting\n    void initializeUidStates() {\n        UserManagerInternal umi = getUserManagerInternal();\n        synchronized (this) {\n            int[] userIds = umi.getUserIds();\n            try (PackageManagerLocal.UnfilteredSnapshot snapshot =\n                         getPackageManagerLocal().withUnfilteredSnapshot()) {\n                Map<String, PackageState> packageStates = snapshot.getPackageStates();\n                for (int i = 0; i < userIds.length; i++) {\n                    int userId = userIds[i];\n                    initializeUserUidStatesLocked(userId, packageStates);\n                }\n            }\n        }\n    }\n\n    private void initializeUserUidStates(int userId) {\n        synchronized (this) {\n            try (PackageManagerLocal.UnfilteredSnapshot snapshot =\n                    getPackageManagerLocal().withUnfilteredSnapshot()) {\n                initializeUserUidStatesLocked(userId, snapshot.getPackageStates());\n            }\n        }\n    }\n\n    private void initializeUserUidStatesLocked(int userId, Map<String,\n            PackageState> packageStates) {\n        for (Map.Entry<String, PackageState> entry : packageStates.entrySet()) {\n            int appId = entry.getValue().getAppId();\n            String packageName = entry.getKey();\n\n            initializePackageUidStateLocked(userId, appId, packageName);\n        }\n    }\n\n    /*\n      Be careful not to clear any existing data; only want to add objects that don't already exist.\n     */\n    private void initializePackageUidStateLocked(int userId, int appId, String packageName) {\n        int uid = UserHandle.getUid(userId, appId);\n        UidState uidState = getUidStateLocked(uid, true);\n        Ops ops = uidState.pkgOps.get(packageName);\n        if (ops == null) {\n            ops = new Ops(packageName, uidState);\n            uidState.pkgOps.put(packageName, ops);\n        }\n\n        SparseIntArray packageModes =\n                mAppOpsCheckingService.getNonDefaultPackageModes(packageName, userId);\n        for (int k = 0; k < packageModes.size(); k++) {\n            int code = packageModes.keyAt(k);\n\n            if (ops.indexOfKey(code) < 0) {\n                ops.put(code, new Op(uidState, packageName, code, uid));\n            }\n        }\n\n        uidState.evalForegroundOps();\n    }\n\n    /**\n     * Sets a policy for handling app ops.\n     *\n     * @param policy The policy.\n     */\n    public void setAppOpsPolicy(@Nullable CheckOpsDelegate policy) {\n        final CheckOpsDelegateDispatcher oldDispatcher = mCheckOpsDelegateDispatcher;\n        final CheckOpsDelegate delegate = (oldDispatcher != null)\n                ? oldDispatcher.mCheckOpsDelegate : null;\n        mCheckOpsDelegateDispatcher = new CheckOpsDelegateDispatcher(policy, delegate);\n    }\n\n    @VisibleForTesting\n    void packageRemoved(int uid, String packageName) {\n        synchronized (this) {\n            packageRemovedLocked(uid, packageName);\n        }\n    }\n\n    @GuardedBy(\"this\")\n    private void packageRemovedLocked(int uid, String packageName) {\n        UidState uidState = mUidStates.get(uid);\n        if (uidState == null) {\n            return;\n        }\n\n        Ops removedOps = null;\n\n        // Remove any package state if such.\n        removedOps = uidState.pkgOps.remove(packageName);\n        mAppOpsCheckingService.removePackage(packageName, UserHandle.getUserId(uid));\n\n        if (removedOps != null) {\n            scheduleFastWriteLocked();\n\n            final int numOps = removedOps.size();\n            for (int opNum = 0; opNum < numOps; opNum++) {\n                final Op op = removedOps.valueAt(opNum);\n\n                final int numAttributions = op.mAttributions.size();\n                for (int attributionNum = 0; attributionNum < numAttributions;\n                        attributionNum++) {\n                    AttributedOp attributedOp = op.mAttributions.valueAt(attributionNum);\n\n                    while (attributedOp.isRunning()) {\n                        attributedOp.finished(attributedOp.mInProgressEvents.keyAt(0));\n                    }\n                    while (attributedOp.isPaused()) {\n                        attributedOp.finished(attributedOp.mPausedInProgressEvents.keyAt(0));\n                    }\n                }\n            }\n        }\n\n        mHandler.post(PooledLambda.obtainRunnable(HistoricalRegistry::clearHistory,\n                    mHistoricalRegistry, uid, packageName));\n    }\n\n    public void uidRemoved(int uid) {\n        synchronized (this) {\n            if (mUidStates.indexOfKey(uid) >= 0) {\n                mUidStates.get(uid).clear();\n                mUidStates.remove(uid);\n                scheduleFastWriteLocked();\n            }\n        }\n    }\n\n    // The callback method from AppOpsUidStateTracker\n    private void onUidStateChanged(int uid, int state, boolean foregroundModeMayChange) {\n        synchronized (this) {\n            UidState uidState = getUidStateLocked(uid, true);\n\n            if (uidState != null && foregroundModeMayChange && uidState.hasForegroundWatchers) {\n                for (int fgi = uidState.foregroundOps.size() - 1; fgi >= 0; fgi--) {\n                    if (!uidState.foregroundOps.valueAt(fgi)) {\n                        continue;\n                    }\n                    final int code = uidState.foregroundOps.keyAt(fgi);\n\n                    if (uidState.getUidMode(code) != AppOpsManager.opToDefaultMode(code)\n                            && uidState.getUidMode(code) == AppOpsManager.MODE_FOREGROUND) {\n                        mHandler.sendMessage(PooledLambda.obtainMessage(\n                                AppOpsService::notifyOpChangedForAllPkgsInUid,\n                                this, code, uidState.uid, true, null));\n                    } else if (!uidState.pkgOps.isEmpty()) {\n                        final ArraySet<OnOpModeChangedListener> listenerSet =\n                                mAppOpsCheckingService.getOpModeChangedListeners(code);\n                        if (listenerSet != null) {\n                            for (int cbi = listenerSet.size() - 1; cbi >= 0; cbi--) {\n                                final OnOpModeChangedListener listener = listenerSet.valueAt(cbi);\n                                if ((listener.getFlags()\n                                        & AppOpsManager.WATCH_FOREGROUND_CHANGES) == 0\n                                        || !listener.isWatchingUid(uidState.uid)) {\n                                    continue;\n                                }\n                                for (int pkgi = uidState.pkgOps.size() - 1; pkgi >= 0; pkgi--) {\n                                    final Op op = uidState.pkgOps.valueAt(pkgi).get(code);\n                                    if (op == null) {\n                                        continue;\n                                    }\n                                    if (op.getMode() == AppOpsManager.MODE_FOREGROUND) {\n                                        mHandler.sendMessage(PooledLambda.obtainMessage(\n                                                AppOpsService::notifyOpChanged,\n                                                this, listenerSet.valueAt(cbi), code, uidState.uid,\n                                                uidState.pkgOps.keyAt(pkgi)));\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (uidState != null) {\n                int numPkgs = uidState.pkgOps.size();\n                for (int pkgNum = 0; pkgNum < numPkgs; pkgNum++) {\n                    Ops ops = uidState.pkgOps.valueAt(pkgNum);\n\n                    int numOps = ops.size();\n                    for (int opNum = 0; opNum < numOps; opNum++) {\n                        Op op = ops.valueAt(opNum);\n\n                        int numAttributions = op.mAttributions.size();\n                        for (int attributionNum = 0; attributionNum < numAttributions;\n                                attributionNum++) {\n                            AttributedOp attributedOp = op.mAttributions.valueAt(\n                                    attributionNum);\n\n                            attributedOp.onUidStateChanged(state);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Notify the proc state or capability has changed for a certain UID.\n     */\n    public void updateUidProcState(int uid, int procState,\n            @ActivityManager.ProcessCapability int capability) {\n        synchronized (this) {\n            getUidStateTracker().updateUidProcState(uid, procState, capability);\n            if (!mUidStates.contains(uid)) {\n                UidState uidState = new UidState(uid);\n                mUidStates.put(uid, uidState);\n                onUidStateChanged(uid,\n                        AppOpsUidStateTracker.processStateToUidState(procState), false);\n            }\n        }\n    }\n\n    public void shutdown() {\n        Slog.w(TAG, \"Writing app ops before shutdown...\");\n        boolean doWrite = false;\n        synchronized (this) {\n            if (mWriteScheduled) {\n                mWriteScheduled = false;\n                mFastWriteScheduled = false;\n                mHandler.removeCallbacks(mWriteRunner);\n                doWrite = true;\n            }\n        }\n        if (doWrite) {\n            writeRecentAccesses();\n        }\n        mAppOpsCheckingService.shutdown();\n        if (AppOpsManager.NOTE_OP_COLLECTION_ENABLED && mWriteNoteOpsScheduled) {\n            writeNoteOps();\n        }\n        mHistoricalRegistry.shutdown();\n    }\n\n    private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops) {\n        ArrayList<AppOpsManager.OpEntry> resOps = null;\n        if (ops == null) {\n            resOps = new ArrayList<>();\n            for (int j=0; j<pkgOps.size(); j++) {\n                Op curOp = pkgOps.valueAt(j);\n                resOps.add(getOpEntryForResult(curOp));\n            }\n        } else {\n            for (int j=0; j<ops.length; j++) {\n                Op curOp = pkgOps.get(ops[j]);\n                if (curOp != null) {\n                    if (resOps == null) {\n                        resOps = new ArrayList<>();\n                    }\n                    resOps.add(getOpEntryForResult(curOp));\n                }\n            }\n        }\n        return resOps;\n    }\n\n    @Nullable\n    private ArrayList<AppOpsManager.OpEntry> collectUidOps(@NonNull UidState uidState,\n            @Nullable int[] ops) {\n        final SparseIntArray opModes = uidState.getNonDefaultUidModes();\n        if (opModes == null) {\n            return null;\n        }\n\n        int opModeCount = opModes.size();\n        if (opModeCount == 0) {\n            return null;\n        }\n        ArrayList<AppOpsManager.OpEntry> resOps = null;\n        if (ops == null) {\n            resOps = new ArrayList<>();\n            for (int i = 0; i < opModeCount; i++) {\n                int code = opModes.keyAt(i);\n                resOps.add(new OpEntry(code, opModes.get(code), Collections.emptyMap()));\n            }\n        } else {\n            for (int j=0; j<ops.length; j++) {\n                int code = ops[j];\n                if (opModes.indexOfKey(code) >= 0) {\n                    if (resOps == null) {\n                        resOps = new ArrayList<>();\n                    }\n                    resOps.add(new OpEntry(code, opModes.get(code), Collections.emptyMap()));\n                }\n            }\n        }\n        return resOps;\n    }\n\n    private static @NonNull OpEntry getOpEntryForResult(@NonNull Op op) {\n        return op.createEntryLocked();\n    }\n\n    @Override\n    public List<AppOpsManager.PackageOps> getPackagesForOps(int[] ops) {\n        final int callingUid = Binder.getCallingUid();\n        final boolean hasAllPackageAccess = mContext.checkPermission(\n                Manifest.permission.GET_APP_OPS_STATS, Binder.getCallingPid(),\n                Binder.getCallingUid(), null) == PackageManager.PERMISSION_GRANTED;\n        ArrayList<AppOpsManager.PackageOps> res = null;\n        synchronized (this) {\n            final int uidStateCount = mUidStates.size();\n            for (int i = 0; i < uidStateCount; i++) {\n                UidState uidState = mUidStates.valueAt(i);\n                if (uidState.pkgOps.isEmpty()) {\n                    continue;\n                }\n                ArrayMap<String, Ops> packages = uidState.pkgOps;\n                final int packageCount = packages.size();\n                for (int j = 0; j < packageCount; j++) {\n                    Ops pkgOps = packages.valueAt(j);\n                    ArrayList<AppOpsManager.OpEntry> resOps = collectOps(pkgOps, ops);\n                    if (resOps != null) {\n                        if (res == null) {\n                            res = new ArrayList<>();\n                        }\n                        AppOpsManager.PackageOps resPackage = new AppOpsManager.PackageOps(\n                                pkgOps.packageName, pkgOps.uidState.uid, resOps);\n                        // Caller can always see their packages and with a permission all.\n                        if (hasAllPackageAccess || callingUid == pkgOps.uidState.uid) {\n                            res.add(resPackage);\n                        }\n                    }\n                }\n            }\n        }\n        return res;\n    }\n\n    @Override\n    public List<AppOpsManager.PackageOps> getOpsForPackage(int uid, String packageName,\n            int[] ops) {\n        enforceGetAppOpsStatsPermissionIfNeeded(uid,packageName);\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return Collections.emptyList();\n        }\n        synchronized (this) {\n            Ops pkgOps = getOpsLocked(uid, resolvedPackageName, null, false, null,\n                    /* edit */ false);\n            if (pkgOps == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.OpEntry> resOps = collectOps(pkgOps, ops);\n            if (resOps == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.PackageOps> res = new ArrayList<AppOpsManager.PackageOps>();\n            AppOpsManager.PackageOps resPackage = new AppOpsManager.PackageOps(\n                    pkgOps.packageName, pkgOps.uidState.uid, resOps);\n            res.add(resPackage);\n            return res;\n        }\n    }\n\n    private void enforceGetAppOpsStatsPermissionIfNeeded(int uid, String packageName) {\n        // We get to access everything\n        final int callingPid = Binder.getCallingPid();\n        if (callingPid == Process.myPid()) {\n            return;\n        }\n        // Apps can access their own data\n        final int callingUid = Binder.getCallingUid();\n        if (uid == callingUid && packageName != null\n                && checkPackage(uid, packageName) == MODE_ALLOWED) {\n            return;\n        }\n        // Otherwise, you need a permission...\n        mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS, callingPid,\n                callingUid, null);\n    }\n\n    /**\n     * Verify that historical appop request arguments are valid.\n     */\n    private void ensureHistoricalOpRequestIsValid(int uid, String packageName,\n            String attributionTag, List<String> opNames, int filter, long beginTimeMillis,\n            long endTimeMillis, int flags) {\n        if ((filter & FILTER_BY_UID) != 0) {\n            Preconditions.checkArgument(uid != Process.INVALID_UID);\n        } else {\n            Preconditions.checkArgument(uid == Process.INVALID_UID);\n        }\n\n        if ((filter & FILTER_BY_PACKAGE_NAME) != 0) {\n            Objects.requireNonNull(packageName);\n        } else {\n            Preconditions.checkArgument(packageName == null);\n        }\n\n        if ((filter & FILTER_BY_ATTRIBUTION_TAG) == 0) {\n            Preconditions.checkArgument(attributionTag == null);\n        }\n\n        if ((filter & FILTER_BY_OP_NAMES) != 0) {\n            Objects.requireNonNull(opNames);\n        } else {\n            Preconditions.checkArgument(opNames == null);\n        }\n\n        Preconditions.checkFlagsArgument(filter,\n                FILTER_BY_UID | FILTER_BY_PACKAGE_NAME | FILTER_BY_ATTRIBUTION_TAG\n                        | FILTER_BY_OP_NAMES);\n        Preconditions.checkArgumentNonnegative(beginTimeMillis);\n        Preconditions.checkArgument(endTimeMillis > beginTimeMillis);\n        Preconditions.checkFlagsArgument(flags, OP_FLAGS_ALL);\n    }\n\n    @Override\n    public void getHistoricalOps(int uid, String packageName, String attributionTag,\n            List<String> opNames, int dataType, int filter, long beginTimeMillis,\n            long endTimeMillis, int flags, RemoteCallback callback) {\n        PackageManager pm = mContext.getPackageManager();\n\n        ensureHistoricalOpRequestIsValid(uid, packageName, attributionTag, opNames, filter,\n                beginTimeMillis, endTimeMillis, flags);\n        Objects.requireNonNull(callback, \"callback cannot be null\");\n        ActivityManagerInternal ami = LocalServices.getService(ActivityManagerInternal.class);\n        boolean isSelfRequest = (filter & FILTER_BY_UID) != 0 && uid == Binder.getCallingUid();\n        if (!isSelfRequest) {\n            boolean isCallerInstrumented =\n                    ami.getInstrumentationSourceUid(Binder.getCallingUid()) != Process.INVALID_UID;\n            boolean isCallerSystem = Binder.getCallingPid() == Process.myPid();\n            boolean isCallerPermissionController;\n            try {\n                isCallerPermissionController = pm.getPackageUidAsUser(\n                        mContext.getPackageManager().getPermissionControllerPackageName(), 0,\n                        UserHandle.getUserId(Binder.getCallingUid()))\n                        == Binder.getCallingUid();\n            } catch (PackageManager.NameNotFoundException doesNotHappen) {\n                return;\n            }\n\n            boolean doesCallerHavePermission = mContext.checkPermission(\n                    android.Manifest.permission.GET_HISTORICAL_APP_OPS_STATS,\n                    Binder.getCallingPid(), Binder.getCallingUid())\n                    == PackageManager.PERMISSION_GRANTED;\n\n            if (!isCallerSystem && !isCallerInstrumented && !isCallerPermissionController\n                    && !doesCallerHavePermission) {\n                mHandler.post(() -> callback.sendResult(new Bundle()));\n                return;\n            }\n\n            mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS,\n                    Binder.getCallingPid(), Binder.getCallingUid(), \"getHistoricalOps\");\n        }\n\n        final String[] opNamesArray = (opNames != null)\n                ? opNames.toArray(new String[opNames.size()]) : null;\n\n        Set<String> attributionChainExemptPackages = null;\n        if ((dataType & HISTORY_FLAG_GET_ATTRIBUTION_CHAINS) != 0) {\n            attributionChainExemptPackages =\n                    PermissionManager.getIndicatorExemptedPackages(mContext);\n        }\n\n        final String[] chainExemptPkgArray = attributionChainExemptPackages != null\n                ? attributionChainExemptPackages.toArray(\n                        new String[attributionChainExemptPackages.size()]) : null;\n\n        // Must not hold the appops lock\n        mHandler.post(PooledLambda.obtainRunnable(HistoricalRegistry::getHistoricalOps,\n                mHistoricalRegistry, uid, packageName, attributionTag, opNamesArray, dataType,\n                filter, beginTimeMillis, endTimeMillis, flags, chainExemptPkgArray,\n                callback).recycleOnUse());\n    }\n\n    @Override\n    public void getHistoricalOpsFromDiskRaw(int uid, String packageName, String attributionTag,\n            List<String> opNames, int dataType, int filter, long beginTimeMillis,\n            long endTimeMillis, int flags, RemoteCallback callback) {\n        ensureHistoricalOpRequestIsValid(uid, packageName, attributionTag, opNames, filter,\n                beginTimeMillis, endTimeMillis, flags);\n        Objects.requireNonNull(callback, \"callback cannot be null\");\n\n        mContext.enforcePermission(Manifest.permission.MANAGE_APPOPS,\n                Binder.getCallingPid(), Binder.getCallingUid(), \"getHistoricalOps\");\n\n        final String[] opNamesArray = (opNames != null)\n                ? opNames.toArray(new String[opNames.size()]) : null;\n\n        Set<String> attributionChainExemptPackages = null;\n        if ((dataType & HISTORY_FLAG_GET_ATTRIBUTION_CHAINS) != 0) {\n            attributionChainExemptPackages =\n                    PermissionManager.getIndicatorExemptedPackages(mContext);\n        }\n\n        final String[] chainExemptPkgArray = attributionChainExemptPackages != null\n                ? attributionChainExemptPackages.toArray(\n                new String[attributionChainExemptPackages.size()]) : null;\n\n        // Must not hold the appops lock\n        mHandler.post(PooledLambda.obtainRunnable(HistoricalRegistry::getHistoricalOpsFromDiskRaw,\n                mHistoricalRegistry, uid, packageName, attributionTag, opNamesArray, dataType,\n                filter, beginTimeMillis, endTimeMillis, flags, chainExemptPkgArray,\n                callback).recycleOnUse());\n    }\n\n    @Override\n    public void reloadNonHistoricalState() {\n        mContext.enforcePermission(Manifest.permission.MANAGE_APPOPS,\n                Binder.getCallingPid(), Binder.getCallingUid(), \"reloadNonHistoricalState\");\n        mAppOpsCheckingService.writeState();\n        mAppOpsCheckingService.readState();\n    }\n\n    @VisibleForTesting\n    void readState() {\n        mAppOpsCheckingService.readState();\n    }\n\n    @Override\n    public List<AppOpsManager.PackageOps> getUidOps(int uid, int[] ops) {\n        mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n        synchronized (this) {\n            UidState uidState = getUidStateLocked(uid, false);\n            if (uidState == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.OpEntry> resOps = collectUidOps(uidState, ops);\n            if (resOps == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.PackageOps> res = new ArrayList<AppOpsManager.PackageOps>();\n            AppOpsManager.PackageOps resPackage = new AppOpsManager.PackageOps(\n                    null, uidState.uid, resOps);\n            res.add(resPackage);\n            return res;\n        }\n    }\n\n    private void pruneOpLocked(Op op, int uid, String packageName) {\n        op.removeAttributionsWithNoTime();\n\n        if (op.mAttributions.isEmpty()) {\n            Ops ops = getOpsLocked(uid, packageName, null, false, null, /* edit */ false);\n            if (ops != null) {\n                ops.remove(op.op);\n                op.setMode(AppOpsManager.opToDefaultMode(op.op));\n                if (ops.size() <= 0) {\n                    UidState uidState = ops.uidState;\n                    ArrayMap<String, Ops> pkgOps = uidState.pkgOps;\n                    if (pkgOps != null) {\n                        pkgOps.remove(ops.packageName);\n                        mAppOpsCheckingService.removePackage(ops.packageName,\n                                UserHandle.getUserId(uidState.uid));\n                    }\n                }\n            }\n        }\n    }\n\n    private void enforceManageAppOpsModes(int callingPid, int callingUid, int targetUid) {\n        if (callingPid == Process.myPid()) {\n            return;\n        }\n        final int callingUser = UserHandle.getUserId(callingUid);\n        synchronized (this) {\n            if (mProfileOwners != null && mProfileOwners.get(callingUser, -1) == callingUid) {\n                if (targetUid >= 0 && callingUser == UserHandle.getUserId(targetUid)) {\n                    // Profile owners are allowed to change modes but only for apps\n                    // within their user.\n                    return;\n                }\n            }\n        }\n        mContext.enforcePermission(android.Manifest.permission.MANAGE_APP_OPS_MODES,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n    }\n\n    @Override\n    public void setUidMode(int code, int uid, int mode) {\n        setUidMode(code, uid, mode, null);\n    }\n\n    private void setUidMode(int code, int uid, int mode,\n            @Nullable IAppOpsCallback permissionPolicyCallback) {\n        if (DEBUG) {\n            Slog.i(TAG, \"uid \" + uid + \" OP_\" + opToName(code) + \" := \" + modeToName(mode)\n                    + \" by uid \" + Binder.getCallingUid());\n        }\n\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), uid);\n        verifyIncomingOp(code);\n        code = AppOpsManager.opToSwitch(code);\n\n        if (permissionPolicyCallback == null) {\n            updatePermissionRevokedCompat(uid, code, mode);\n        }\n\n        int previousMode;\n        synchronized (this) {\n            final int defaultMode = AppOpsManager.opToDefaultMode(code);\n\n            UidState uidState = getUidStateLocked(uid, false);\n            if (uidState == null) {\n                if (mode == defaultMode) {\n                    return;\n                }\n                uidState = new UidState(uid);\n                mUidStates.put(uid, uidState);\n            }\n            if (uidState.getUidMode(code) != AppOpsManager.opToDefaultMode(code)) {\n                previousMode = uidState.getUidMode(code);\n            } else {\n                // doesn't look right but is legacy behavior.\n                previousMode = MODE_DEFAULT;\n            }\n\n            if (!uidState.setUidMode(code, mode)) {\n                return;\n            }\n            uidState.evalForegroundOps();\n            if (mode != MODE_ERRORED && mode != previousMode) {\n                updateStartedOpModeForUidLocked(code, mode == MODE_IGNORED, uid);\n            }\n        }\n\n        notifyOpChangedForAllPkgsInUid(code, uid, false, permissionPolicyCallback);\n        notifyOpChangedSync(code, uid, null, mode, previousMode);\n    }\n\n    /**\n     * Notify that an op changed for all packages in an uid.\n     *\n     * @param code The op that changed\n     * @param uid The uid the op was changed for\n     * @param onlyForeground Only notify watchers that watch for foreground changes\n     */\n    private void notifyOpChangedForAllPkgsInUid(int code, int uid, boolean onlyForeground,\n            @Nullable IAppOpsCallback callbackToIgnore) {\n        ModeCallback listenerToIgnore = callbackToIgnore != null\n                ? mModeWatchers.get(callbackToIgnore.asBinder()) : null;\n        mAppOpsCheckingService.notifyOpChangedForAllPkgsInUid(code, uid, onlyForeground,\n                listenerToIgnore);\n    }\n\n    private void updatePermissionRevokedCompat(int uid, int switchCode, int mode) {\n        PackageManager packageManager = mContext.getPackageManager();\n        if (packageManager == null) {\n            // This can only happen during early boot. At this time the permission state and appop\n            // state are in sync\n            return;\n        }\n\n        String[] packageNames = packageManager.getPackagesForUid(uid);\n        if (ArrayUtils.isEmpty(packageNames)) {\n            return;\n        }\n        String packageName = packageNames[0];\n\n        int[] ops = mSwitchedOps.get(switchCode);\n        for (int code : ops) {\n            String permissionName = AppOpsManager.opToPermission(code);\n            if (permissionName == null) {\n                continue;\n            }\n\n            if (packageManager.checkPermission(permissionName, packageName)\n                    != PackageManager.PERMISSION_GRANTED) {\n                continue;\n            }\n\n            PermissionInfo permissionInfo;\n            try {\n                permissionInfo = packageManager.getPermissionInfo(permissionName, 0);\n            } catch (PackageManager.NameNotFoundException e) {\n                e.printStackTrace();\n                continue;\n            }\n\n            if (!permissionInfo.isRuntime()) {\n                continue;\n            }\n\n            boolean supportsRuntimePermissions = getPackageManagerInternal()\n                    .getUidTargetSdkVersion(uid) >= Build.VERSION_CODES.M;\n\n            UserHandle user = UserHandle.getUserHandleForUid(uid);\n            boolean isRevokedCompat;\n            if (permissionInfo.backgroundPermission != null) {\n                if (packageManager.checkPermission(permissionInfo.backgroundPermission, packageName)\n                        == PackageManager.PERMISSION_GRANTED) {\n                    boolean isBackgroundRevokedCompat = mode != AppOpsManager.MODE_ALLOWED;\n\n                    if (isBackgroundRevokedCompat && supportsRuntimePermissions) {\n                        Slog.w(TAG, \"setUidMode() called with a mode inconsistent with runtime\"\n                                + \" permission state, this is discouraged and you should revoke the\"\n                                + \" runtime permission instead: uid=\" + uid + \", switchCode=\"\n                                + switchCode + \", mode=\" + mode + \", permission=\"\n                                + permissionInfo.backgroundPermission);\n                    }\n\n                    final long identity = Binder.clearCallingIdentity();\n                    try {\n                        packageManager.updatePermissionFlags(permissionInfo.backgroundPermission,\n                                packageName, PackageManager.FLAG_PERMISSION_REVOKED_COMPAT,\n                                isBackgroundRevokedCompat\n                                        ? PackageManager.FLAG_PERMISSION_REVOKED_COMPAT : 0, user);\n                    } finally {\n                        Binder.restoreCallingIdentity(identity);\n                    }\n                }\n\n                isRevokedCompat = mode != AppOpsManager.MODE_ALLOWED\n                        && mode != AppOpsManager.MODE_FOREGROUND;\n            } else {\n                isRevokedCompat = mode != AppOpsManager.MODE_ALLOWED;\n            }\n\n            if (isRevokedCompat && supportsRuntimePermissions) {\n                Slog.w(TAG, \"setUidMode() called with a mode inconsistent with runtime\"\n                        + \" permission state, this is discouraged and you should revoke the\"\n                        + \" runtime permission instead: uid=\" + uid + \", switchCode=\"\n                        + switchCode + \", mode=\" + mode + \", permission=\" + permissionName);\n            }\n\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                packageManager.updatePermissionFlags(permissionName, packageName,\n                        PackageManager.FLAG_PERMISSION_REVOKED_COMPAT, isRevokedCompat\n                                ? PackageManager.FLAG_PERMISSION_REVOKED_COMPAT : 0, user);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n    }\n\n    private void notifyOpChangedSync(int code, int uid, @NonNull String packageName, int mode,\n            int previousMode) {\n        final StorageManagerInternal storageManagerInternal =\n                LocalServices.getService(StorageManagerInternal.class);\n        if (storageManagerInternal != null) {\n            storageManagerInternal.onAppOpsChanged(code, uid, packageName, mode, previousMode);\n        }\n    }\n\n    /**\n     * Sets the mode for a certain op and uid.\n     *\n     * @param code The op code to set\n     * @param uid The UID for which to set\n     * @param packageName The package for which to set\n     * @param mode The new mode to set\n     */\n    @Override\n    public void setMode(int code, int uid, @NonNull String packageName, int mode) {\n        setMode(code, uid, packageName, mode, null);\n    }\n\n    void setMode(int code, int uid, @NonNull String packageName, int mode,\n            @Nullable IAppOpsCallback permissionPolicyCallback) {\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), uid);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return;\n        }\n\n        ArraySet<OnOpModeChangedListener> repCbs = null;\n        code = AppOpsManager.opToSwitch(code);\n\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, null);\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot setMode: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot setMode\", e);\n            }\n            return;\n        }\n\n        int previousMode = MODE_DEFAULT;\n        synchronized (this) {\n            UidState uidState = getUidStateLocked(uid, false);\n            Op op = getOpLocked(code, uid, packageName, null, false, pvr.bypass, /* edit */ true);\n            if (op != null) {\n                if (op.getMode() != mode) {\n                    previousMode = op.getMode();\n                    op.setMode(mode);\n\n                    if (uidState != null) {\n                        uidState.evalForegroundOps();\n                    }\n                    ArraySet<OnOpModeChangedListener> cbs =\n                            mAppOpsCheckingService.getOpModeChangedListeners(code);\n                    if (cbs != null) {\n                        if (repCbs == null) {\n                            repCbs = new ArraySet<>();\n                        }\n                        repCbs.addAll(cbs);\n                    }\n                    cbs = mAppOpsCheckingService.getPackageModeChangedListeners(packageName);\n                    if (cbs != null) {\n                        if (repCbs == null) {\n                            repCbs = new ArraySet<>();\n                        }\n                        repCbs.addAll(cbs);\n                    }\n                    if (repCbs != null && permissionPolicyCallback != null) {\n                        repCbs.remove(mModeWatchers.get(permissionPolicyCallback.asBinder()));\n                    }\n                    if (mode == AppOpsManager.opToDefaultMode(op.op)) {\n                        // If going into the default mode, prune this op\n                        // if there is nothing else interesting in it.\n                        pruneOpLocked(op, uid, packageName);\n                    }\n                    scheduleFastWriteLocked();\n                    if (mode != MODE_ERRORED) {\n                        updateStartedOpModeForUidLocked(code, mode == MODE_IGNORED, uid);\n                    }\n                }\n            }\n        }\n        if (repCbs != null) {\n            mHandler.sendMessage(PooledLambda.obtainMessage(\n                    AppOpsService::notifyOpChanged,\n                    this, repCbs, code, uid, packageName));\n        }\n\n        notifyOpChangedSync(code, uid, packageName, mode, previousMode);\n    }\n\n    private void notifyOpChanged(ArraySet<OnOpModeChangedListener> callbacks, int code,\n            int uid, String packageName) {\n        for (int i = 0; i < callbacks.size(); i++) {\n            final OnOpModeChangedListener callback = callbacks.valueAt(i);\n            notifyOpChanged(callback, code, uid, packageName);\n        }\n    }\n\n    private void notifyOpChanged(OnOpModeChangedListener callback, int code,\n            int uid, String packageName) {\n        mAppOpsCheckingService.notifyOpChanged(callback, code, uid, packageName);\n    }\n\n    private static ArrayList<ChangeRec> addChange(ArrayList<ChangeRec> reports,\n            int op, int uid, String packageName, int previousMode) {\n        boolean duplicate = false;\n        if (reports == null) {\n            reports = new ArrayList<>();\n        } else {\n            final int reportCount = reports.size();\n            for (int j = 0; j < reportCount; j++) {\n                ChangeRec report = reports.get(j);\n                if (report.op == op && report.pkg.equals(packageName)) {\n                    duplicate = true;\n                    break;\n                }\n            }\n        }\n        if (!duplicate) {\n            reports.add(new ChangeRec(op, uid, packageName, previousMode));\n        }\n\n        return reports;\n    }\n\n    private static HashMap<OnOpModeChangedListener, ArrayList<ChangeRec>> addCallbacks(\n            HashMap<OnOpModeChangedListener, ArrayList<ChangeRec>> callbacks,\n            int op, int uid, String packageName, int previousMode,\n            ArraySet<OnOpModeChangedListener> cbs) {\n        if (cbs == null) {\n            return callbacks;\n        }\n        if (callbacks == null) {\n            callbacks = new HashMap<>();\n        }\n        final int N = cbs.size();\n        for (int i=0; i<N; i++) {\n            OnOpModeChangedListener cb = cbs.valueAt(i);\n            ArrayList<ChangeRec> reports = callbacks.get(cb);\n            ArrayList<ChangeRec> changed = addChange(reports, op, uid, packageName, previousMode);\n            if (changed != reports) {\n                callbacks.put(cb, changed);\n            }\n        }\n        return callbacks;\n    }\n\n    static final class ChangeRec {\n        final int op;\n        final int uid;\n        final String pkg;\n        final int previous_mode;\n\n        ChangeRec(int _op, int _uid, String _pkg, int _previous_mode) {\n            op = _op;\n            uid = _uid;\n            pkg = _pkg;\n            previous_mode = _previous_mode;\n        }\n    }\n\n    @Override\n    public void resetAllModes(int reqUserId, String reqPackageName) {\n        final int callingPid = Binder.getCallingPid();\n        final int callingUid = Binder.getCallingUid();\n        reqUserId = ActivityManager.handleIncomingUser(callingPid, callingUid, reqUserId,\n                true, true, \"resetAllModes\", null);\n\n        int reqUid = -1;\n        if (reqPackageName != null) {\n            try {\n                reqUid = AppGlobals.getPackageManager().getPackageUid(\n                        reqPackageName, PackageManager.MATCH_UNINSTALLED_PACKAGES, reqUserId);\n            } catch (RemoteException e) {\n                /* ignore - local call */\n            }\n        }\n\n        enforceManageAppOpsModes(callingPid, callingUid, reqUid);\n\n        HashMap<OnOpModeChangedListener, ArrayList<ChangeRec>> callbacks = null;\n        ArrayList<ChangeRec> allChanges = new ArrayList<>();\n        synchronized (this) {\n            boolean changed = false;\n            for (int i = mUidStates.size() - 1; i >= 0; i--) {\n                UidState uidState = mUidStates.valueAt(i);\n\n                SparseIntArray opModes = uidState.getNonDefaultUidModes();\n                if (opModes != null && (uidState.uid == reqUid || reqUid == -1)) {\n                    final int uidOpCount = opModes.size();\n                    for (int j = uidOpCount - 1; j >= 0; j--) {\n                        final int code = opModes.keyAt(j);\n                        if (AppOpsManager.opAllowsReset(code)) {\n                            int previousMode = opModes.valueAt(j);\n                            int newMode = isUidOpGrantedByRole(uidState.uid, code) ? MODE_ALLOWED :\n                                    AppOpsManager.opToDefaultMode(code);\n                            uidState.setUidMode(code, newMode);\n                            for (String packageName : getPackagesForUid(uidState.uid)) {\n                                callbacks = addCallbacks(callbacks, code, uidState.uid, packageName,\n                                        previousMode,\n                                        mAppOpsCheckingService.getOpModeChangedListeners(code));\n                                callbacks = addCallbacks(callbacks, code, uidState.uid, packageName,\n                                        previousMode, mAppOpsCheckingService\n                                                .getPackageModeChangedListeners(packageName));\n\n                                allChanges = addChange(allChanges, code, uidState.uid,\n                                        packageName, previousMode);\n                            }\n                        }\n                    }\n                }\n\n                if (uidState.pkgOps.isEmpty()) {\n                    continue;\n                }\n\n                if (reqUserId != UserHandle.USER_ALL\n                        && reqUserId != UserHandle.getUserId(uidState.uid)) {\n                    // Skip any ops for a different user\n                    continue;\n                }\n\n                Map<String, Ops> packages = uidState.pkgOps;\n                Iterator<Map.Entry<String, Ops>> it = packages.entrySet().iterator();\n                boolean uidChanged = false;\n                while (it.hasNext()) {\n                    Map.Entry<String, Ops> ent = it.next();\n                    String packageName = ent.getKey();\n                    if (reqPackageName != null && !reqPackageName.equals(packageName)) {\n                        // Skip any ops for a different package\n                        continue;\n                    }\n                    Ops pkgOps = ent.getValue();\n                    for (int j=pkgOps.size()-1; j>=0; j--) {\n                        Op curOp = pkgOps.valueAt(j);\n                        if (shouldDeferResetOpToDpm(curOp.op)) {\n                            deferResetOpToDpm(curOp.op, reqPackageName, reqUserId);\n                            continue;\n                        }\n                        if (AppOpsManager.opAllowsReset(curOp.op)) {\n                            int previousMode = curOp.getMode();\n                            int newMode = isPackageOpGrantedByRole(packageName, uidState.uid,\n                                    curOp.op) ? MODE_ALLOWED : AppOpsManager.opToDefaultMode(\n                                    curOp.op);\n                            if (previousMode == newMode) {\n                                continue;\n                            }\n                            curOp.setMode(newMode);\n                            changed = true;\n                            uidChanged = true;\n                            final int uid = curOp.uidState.uid;\n                            callbacks = addCallbacks(callbacks, curOp.op, uid, packageName,\n                                    previousMode,\n                                    mAppOpsCheckingService.getOpModeChangedListeners(curOp.op));\n                            callbacks = addCallbacks(callbacks, curOp.op, uid, packageName,\n                                    previousMode, mAppOpsCheckingService\n                                            .getPackageModeChangedListeners(packageName));\n\n                            allChanges = addChange(allChanges, curOp.op, uid, packageName,\n                                    previousMode);\n                            curOp.removeAttributionsWithNoTime();\n                            if (curOp.mAttributions.isEmpty()) {\n                                pkgOps.removeAt(j);\n                            }\n                        }\n                    }\n                    if (pkgOps.size() == 0) {\n                        it.remove();\n                        mAppOpsCheckingService.removePackage(packageName,\n                                UserHandle.getUserId(uidState.uid));\n                    }\n                }\n                if (uidChanged) {\n                    uidState.evalForegroundOps();\n                }\n            }\n\n            if (changed) {\n                scheduleFastWriteLocked();\n            }\n        }\n        if (callbacks != null) {\n            for (Map.Entry<OnOpModeChangedListener, ArrayList<ChangeRec>> ent\n                    : callbacks.entrySet()) {\n                OnOpModeChangedListener cb = ent.getKey();\n                ArrayList<ChangeRec> reports = ent.getValue();\n                for (int i=0; i<reports.size(); i++) {\n                    ChangeRec rep = reports.get(i);\n                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                            AppOpsService::notifyOpChanged,\n                            this, cb, rep.op, rep.uid, rep.pkg));\n                }\n            }\n        }\n\n        int numChanges = allChanges.size();\n        for (int i = 0; i < numChanges; i++) {\n            ChangeRec change = allChanges.get(i);\n            notifyOpChangedSync(change.op, change.uid, change.pkg,\n                    AppOpsManager.opToDefaultMode(change.op), change.previous_mode);\n        }\n    }\n\n    private boolean isUidOpGrantedByRole(int uid, int code) {\n        if (!AppOpsManager.opIsUidAppOpPermission(code)) {\n            return false;\n        }\n        PackageManager packageManager = mContext.getPackageManager();\n        long token = Binder.clearCallingIdentity();\n        try {\n            // Permissions are managed by UIDs, but unfortunately a package name is required in API.\n            String packageName = ArrayUtils.firstOrNull(packageManager.getPackagesForUid(uid));\n            if (packageName == null) {\n                return false;\n            }\n            int permissionFlags = packageManager.getPermissionFlags(AppOpsManager.opToPermission(\n                    code), packageName, UserHandle.getUserHandleForUid(uid));\n            return (permissionFlags & PackageManager.FLAG_PERMISSION_GRANTED_BY_ROLE) != 0;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private boolean isPackageOpGrantedByRole(@NonNull String packageName, int uid, int code) {\n        if (!AppOpsManager.opIsPackageAppOpPermission(code)) {\n            return false;\n        }\n        PackageManager packageManager = mContext.getPackageManager();\n        long token = Binder.clearCallingIdentity();\n        try {\n            int permissionFlags = packageManager.getPermissionFlags(AppOpsManager.opToPermission(\n                    code), packageName, UserHandle.getUserHandleForUid(uid));\n            return (permissionFlags & PackageManager.FLAG_PERMISSION_GRANTED_BY_ROLE) != 0;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private boolean shouldDeferResetOpToDpm(int op) {\n        // TODO(b/174582385): avoid special-casing app-op resets by migrating app-op permission\n        //  pre-grants to a role-based mechanism or another general-purpose mechanism.\n        return dpmi != null && dpmi.supportsResetOp(op);\n    }\n\n    /** Assumes {@link #shouldDeferResetOpToDpm(int)} is true. */\n    private void deferResetOpToDpm(int op, String packageName, @UserIdInt int userId) {\n        // TODO(b/174582385): avoid special-casing app-op resets by migrating app-op permission\n        //  pre-grants to a role-based mechanism or another general-purpose mechanism.\n        dpmi.resetOp(op, packageName, userId);\n    }\n\n    private void evalAllForegroundOpsLocked() {\n        for (int uidi = mUidStates.size() - 1; uidi >= 0; uidi--) {\n            final UidState uidState = mUidStates.valueAt(uidi);\n            if (uidState.foregroundOps != null) {\n                uidState.evalForegroundOps();\n            }\n        }\n    }\n\n    @Override\n    public void startWatchingMode(int op, String packageName, IAppOpsCallback callback) {\n        startWatchingModeWithFlags(op, packageName, 0, callback);\n    }\n\n    @Override\n    public void startWatchingModeWithFlags(int op, String packageName, int flags,\n            IAppOpsCallback callback) {\n        int watchedUid = -1;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        // TODO: should have a privileged permission to protect this.\n        // Also, if the caller has requested WATCH_FOREGROUND_CHANGES, should we require\n        // the USAGE_STATS permission since this can provide information about when an\n        // app is in the foreground?\n        Preconditions.checkArgumentInRange(op, AppOpsManager.OP_NONE,\n                AppOpsManager._NUM_OP - 1, \"Invalid op code: \" + op);\n        if (callback == null) {\n            return;\n        }\n        final boolean mayWatchPackageName = packageName != null\n                && !filterAppAccessUnlocked(packageName, UserHandle.getUserId(callingUid));\n        synchronized (this) {\n            int switchOp = (op != AppOpsManager.OP_NONE) ? AppOpsManager.opToSwitch(op) : op;\n\n            int notifiedOps;\n            if ((flags & CALL_BACK_ON_SWITCHED_OP) == 0) {\n                if (op == OP_NONE) {\n                    notifiedOps = ALL_OPS;\n                } else {\n                    notifiedOps = op;\n                }\n            } else {\n                notifiedOps = switchOp;\n            }\n\n            ModeCallback cb = mModeWatchers.get(callback.asBinder());\n            if (cb == null) {\n                cb = new ModeCallback(callback, watchedUid, flags, notifiedOps, callingUid,\n                        callingPid);\n                mModeWatchers.put(callback.asBinder(), cb);\n            }\n            if (switchOp != AppOpsManager.OP_NONE) {\n                mAppOpsCheckingService.startWatchingOpModeChanged(cb, switchOp);\n            }\n            if (mayWatchPackageName) {\n                mAppOpsCheckingService.startWatchingPackageModeChanged(cb, packageName);\n            }\n            evalAllForegroundOpsLocked();\n        }\n    }\n\n    @Override\n    public void stopWatchingMode(IAppOpsCallback callback) {\n        if (callback == null) {\n            return;\n        }\n        synchronized (this) {\n            ModeCallback cb = mModeWatchers.remove(callback.asBinder());\n            if (cb != null) {\n                cb.unlinkToDeath();\n                mAppOpsCheckingService.removeListener(cb);\n            }\n\n            evalAllForegroundOpsLocked();\n        }\n    }\n\n    public CheckOpsDelegate getAppOpsServiceDelegate() {\n        synchronized (AppOpsService.this) {\n            final CheckOpsDelegateDispatcher dispatcher = mCheckOpsDelegateDispatcher;\n            return (dispatcher != null) ? dispatcher.getCheckOpsDelegate() : null;\n        }\n    }\n\n    public void setAppOpsServiceDelegate(CheckOpsDelegate delegate) {\n        synchronized (AppOpsService.this) {\n            final CheckOpsDelegateDispatcher oldDispatcher = mCheckOpsDelegateDispatcher;\n            final CheckOpsDelegate policy = (oldDispatcher != null) ? oldDispatcher.mPolicy : null;\n            mCheckOpsDelegateDispatcher = new CheckOpsDelegateDispatcher(policy, delegate);\n        }\n    }\n\n    @Override\n    public int checkOperationRaw(int code, int uid, String packageName,\n            @Nullable String attributionTag) {\n        return mCheckOpsDelegateDispatcher.checkOperation(code, uid, packageName, attributionTag,\n                true /*raw*/);\n    }\n\n    @Override\n    public int checkOperation(int code, int uid, String packageName) {\n        return mCheckOpsDelegateDispatcher.checkOperation(code, uid, packageName, null,\n                false /*raw*/);\n    }\n\n    private int checkOperationImpl(int code, int uid, String packageName,\n            @Nullable String attributionTag, boolean raw) {\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return AppOpsManager.opToDefaultMode(code);\n        }\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return AppOpsManager.MODE_IGNORED;\n        }\n        return checkOperationUnchecked(code, uid, resolvedPackageName, attributionTag, raw);\n    }\n\n    /**\n     * Get the mode of an app-op.\n     *\n     * @param code The code of the op\n     * @param uid The uid of the package the op belongs to\n     * @param packageName The package the op belongs to\n     * @param raw If the raw state of eval-ed state should be checked.\n     *\n     * @return The mode of the op\n     */\n    private @Mode int checkOperationUnchecked(int code, int uid, @NonNull String packageName,\n            @Nullable String attributionTag, boolean raw) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, null);\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot checkOperation: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot checkOperation\", e);\n            }\n            return AppOpsManager.opToDefaultMode(code);\n        }\n\n        if (isOpRestrictedDueToSuspend(code, packageName, uid)) {\n            return AppOpsManager.MODE_IGNORED;\n        }\n        synchronized (this) {\n            if (isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass, true)) {\n                return AppOpsManager.MODE_IGNORED;\n            }\n            code = AppOpsManager.opToSwitch(code);\n            UidState uidState = getUidStateLocked(uid, false);\n            if (uidState != null\n                    && uidState.getUidMode(code) != AppOpsManager.opToDefaultMode(code)) {\n                final int rawMode = uidState.getUidMode(code);\n                return raw ? rawMode : uidState.evalMode(code, rawMode);\n            }\n            Op op = getOpLocked(code, uid, packageName, null, false, pvr.bypass, /* edit */ false);\n            if (op == null) {\n                return AppOpsManager.opToDefaultMode(code);\n            }\n            return raw ? op.getMode() : op.uidState.evalMode(op.op, op.getMode());\n        }\n    }\n\n    @Override\n    public int checkAudioOperation(int code, int usage, int uid, String packageName) {\n        return mCheckOpsDelegateDispatcher.checkAudioOperation(code, usage, uid, packageName);\n    }\n\n    private int checkAudioOperationImpl(int code, int usage, int uid, String packageName) {\n        final int mode = mAudioRestrictionManager.checkAudioOperation(\n                code, usage, uid, packageName);\n        if (mode != AppOpsManager.MODE_ALLOWED) {\n            return mode;\n        }\n        return checkOperation(code, uid, packageName);\n    }\n\n    @Override\n    public void setAudioRestriction(int code, int usage, int uid, int mode,\n            String[] exceptionPackages) {\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), uid);\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n\n        mAudioRestrictionManager.setZenModeAudioRestriction(\n                code, usage, uid, mode, exceptionPackages);\n\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyWatchersOfChange, this, code, UID_ANY));\n    }\n\n\n    @Override\n    public void setCameraAudioRestriction(@CAMERA_AUDIO_RESTRICTION int mode) {\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), -1);\n\n        mAudioRestrictionManager.setCameraAudioRestriction(mode);\n\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyWatchersOfChange, this,\n                AppOpsManager.OP_PLAY_AUDIO, UID_ANY));\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyWatchersOfChange, this,\n                AppOpsManager.OP_VIBRATE, UID_ANY));\n    }\n\n    @Override\n    public int checkPackage(int uid, String packageName) {\n        Objects.requireNonNull(packageName);\n        try {\n            verifyAndGetBypass(uid, packageName, null, null, true);\n            // When the caller is the system, it's possible that the packageName is the special\n            // one (e.g., \"root\") which isn't actually existed.\n            if (resolveUid(packageName) == uid\n                    || (isPackageExisted(packageName)\n                            && !filterAppAccessUnlocked(packageName, UserHandle.getUserId(uid)))) {\n                return AppOpsManager.MODE_ALLOWED;\n            }\n            return AppOpsManager.MODE_ERRORED;\n        } catch (SecurityException ignored) {\n            return AppOpsManager.MODE_ERRORED;\n        }\n    }\n\n    private boolean isPackageExisted(String packageName) {\n        return getPackageManagerInternal().getPackageStateInternal(packageName) != null;\n    }\n\n    /**\n     * This method will check with PackageManager to determine if the package provided should\n     * be visible to the {@link Binder#getCallingUid()}.\n     *\n     * NOTE: This must not be called while synchronized on {@code this} to avoid dead locks\n     */\n    private boolean filterAppAccessUnlocked(String packageName, int userId) {\n        final int callingUid = Binder.getCallingUid();\n        return LocalServices.getService(PackageManagerInternal.class)\n                .filterAppAccess(packageName, callingUid, userId);\n    }\n\n    @Override\n    public SyncNotedAppOp noteProxyOperation(int code, AttributionSource attributionSource,\n            boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n            boolean skipProxyOperation) {\n        return mCheckOpsDelegateDispatcher.noteProxyOperation(code, attributionSource,\n                shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation);\n    }\n\n    private SyncNotedAppOp noteProxyOperationImpl(int code, AttributionSource attributionSource,\n            boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n            boolean skipProxyOperation) {\n        final int proxyUid = attributionSource.getUid();\n        final String proxyPackageName = attributionSource.getPackageName();\n        final String proxyAttributionTag = attributionSource.getAttributionTag();\n        final int proxiedUid = attributionSource.getNextUid();\n        final String proxiedPackageName = attributionSource.getNextPackageName();\n        final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n\n        verifyIncomingProxyUid(attributionSource);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(proxiedPackageName, UserHandle.getUserId(proxiedUid))\n                || !isIncomingPackageValid(proxyPackageName, UserHandle.getUserId(proxyUid))) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        skipProxyOperation = skipProxyOperation\n                && isCallerAndAttributionTrusted(attributionSource);\n\n        String resolveProxyPackageName = AppOpsManager.resolvePackageName(proxyUid,\n                proxyPackageName);\n        if (resolveProxyPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code,\n                    proxiedAttributionTag, proxiedPackageName);\n        }\n\n        final boolean isSelfBlame = Binder.getCallingUid() == proxiedUid;\n        final boolean isProxyTrusted = mContext.checkPermission(\n                Manifest.permission.UPDATE_APP_OPS_STATS, -1, proxyUid)\n                == PackageManager.PERMISSION_GRANTED || isSelfBlame;\n\n        if (!skipProxyOperation) {\n            final int proxyFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXY\n                    : AppOpsManager.OP_FLAG_UNTRUSTED_PROXY;\n\n            final SyncNotedAppOp proxyReturn = noteOperationUnchecked(code, proxyUid,\n                    resolveProxyPackageName, proxyAttributionTag, Process.INVALID_UID, null, null,\n                    proxyFlags, !isProxyTrusted, \"proxy \" + message, shouldCollectMessage);\n            if (proxyReturn.getOpMode() != AppOpsManager.MODE_ALLOWED) {\n                return new SyncNotedAppOp(proxyReturn.getOpMode(), code, proxiedAttributionTag,\n                        proxiedPackageName);\n            }\n        }\n\n        String resolveProxiedPackageName = AppOpsManager.resolvePackageName(proxiedUid,\n                proxiedPackageName);\n        if (resolveProxiedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        final int proxiedFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXIED\n                : AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED;\n        return noteOperationUnchecked(code, proxiedUid, resolveProxiedPackageName,\n                proxiedAttributionTag, proxyUid, resolveProxyPackageName, proxyAttributionTag,\n                proxiedFlags, shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n    }\n\n    @Override\n    public SyncNotedAppOp noteOperation(int code, int uid, String packageName,\n            String attributionTag, boolean shouldCollectAsyncNotedOp, String message,\n            boolean shouldCollectMessage) {\n        return mCheckOpsDelegateDispatcher.noteOperation(code, uid, packageName,\n                attributionTag, shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n    }\n\n    private SyncNotedAppOp noteOperationImpl(int code, int uid, @Nullable String packageName,\n            @Nullable String attributionTag, boolean shouldCollectAsyncNotedOp,\n            @Nullable String message, boolean shouldCollectMessage) {\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                    packageName);\n        }\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, attributionTag,\n                    packageName);\n        }\n        return noteOperationUnchecked(code, uid, resolvedPackageName, attributionTag,\n                Process.INVALID_UID, null, null, AppOpsManager.OP_FLAG_SELF,\n                shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n    }\n\n    private SyncNotedAppOp noteOperationUnchecked(int code, int uid, @NonNull String packageName,\n            @Nullable String attributionTag, int proxyUid, String proxyPackageName,\n            @Nullable String proxyAttributionTag, @OpFlags int flags,\n            boolean shouldCollectAsyncNotedOp, @Nullable String message,\n            boolean shouldCollectMessage) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n            boolean wasNull = attributionTag == null;\n            if (!pvr.isAttributionTagValid) {\n                attributionTag = null;\n            }\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot noteOperation: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot noteOperation\", e);\n            }\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                    packageName);\n        }\n        if (proxyAttributionTag != null\n                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n            proxyAttributionTag = null;\n        }\n\n        synchronized (this) {\n            final Ops ops = getOpsLocked(uid, packageName, attributionTag,\n                    pvr.isAttributionTagValid, pvr.bypass, /* edit */ true);\n            if (ops == null) {\n                scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                        AppOpsManager.MODE_IGNORED);\n                if (DEBUG) Slog.d(TAG, \"noteOperation: no op for code \" + code + \" uid \" + uid\n                        + \" package \" + packageName + \"flags: \" +\n                        AppOpsManager.flagsToString(flags));\n                return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                        packageName);\n            }\n            final Op op = getOpLocked(ops, code, uid, true);\n            final AttributedOp attributedOp = op.getOrCreateAttribution(op, attributionTag);\n            if (attributedOp.isRunning()) {\n                Slog.w(TAG, \"Noting op not finished: uid \" + uid + \" pkg \" + packageName + \" code \"\n                        + code + \" startTime of in progress event=\"\n                        + attributedOp.mInProgressEvents.valueAt(0).getStartTime());\n            }\n\n            final int switchCode = AppOpsManager.opToSwitch(code);\n            final UidState uidState = ops.uidState;\n            if (isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass, false)) {\n                attributedOp.rejected(uidState.getState(), flags);\n                scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                        AppOpsManager.MODE_IGNORED);\n                return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, attributionTag,\n                        packageName);\n            }\n            // If there is a non-default per UID policy (we set UID op mode only if\n            // non-default) it takes over, otherwise use the per package policy.\n            if (uidState.getUidMode(switchCode) != AppOpsManager.opToDefaultMode(switchCode)) {\n                final int uidMode = uidState.evalMode(code, uidState.getUidMode(switchCode));\n                if (uidMode != AppOpsManager.MODE_ALLOWED) {\n                    if (DEBUG) Slog.d(TAG, \"noteOperation: uid reject #\" + uidMode + \" for code \"\n                            + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                            + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    attributedOp.rejected(uidState.getState(), flags);\n                    scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                            uidMode);\n                    return new SyncNotedAppOp(uidMode, code, attributionTag, packageName);\n                }\n            } else {\n                final Op switchOp = switchCode != code ? getOpLocked(ops, switchCode, uid, true)\n                        : op;\n                final int mode = switchOp.uidState.evalMode(switchOp.op, switchOp.getMode());\n                if (mode != AppOpsManager.MODE_ALLOWED) {\n                    if (DEBUG) Slog.d(TAG, \"noteOperation: reject #\" + mode + \" for code \"\n                            + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                            + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    attributedOp.rejected(uidState.getState(), flags);\n                    scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                            mode);\n                    return new SyncNotedAppOp(mode, code, attributionTag, packageName);\n                }\n            }\n            if (DEBUG) {\n                Slog.d(TAG,\n                        \"noteOperation: allowing code \" + code + \" uid \" + uid + \" package \"\n                                + packageName + (attributionTag == null ? \"\"\n                                : \".\" + attributionTag) + \" flags: \"\n                                + AppOpsManager.flagsToString(flags));\n            }\n            scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                    AppOpsManager.MODE_ALLOWED);\n            attributedOp.accessed(proxyUid, proxyPackageName, proxyAttributionTag,\n                    uidState.getState(),\n                    flags);\n\n            if (shouldCollectAsyncNotedOp) {\n                collectAsyncNotedOp(uid, packageName, code, attributionTag, flags, message,\n                        shouldCollectMessage);\n            }\n\n            return new SyncNotedAppOp(AppOpsManager.MODE_ALLOWED, code, attributionTag,\n                    packageName);\n        }\n    }\n\n    // TODO moltmann: Allow watching for attribution ops\n    @Override\n    public void startWatchingActive(int[] ops, IAppOpsActiveCallback callback) {\n        int watchedUid = Process.INVALID_UID;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                != PackageManager.PERMISSION_GRANTED) {\n            watchedUid = callingUid;\n        }\n        if (ops != null) {\n            Preconditions.checkArrayElementsInRange(ops, 0,\n                    AppOpsManager._NUM_OP - 1, \"Invalid op code in: \" + Arrays.toString(ops));\n        }\n        if (callback == null) {\n            return;\n        }\n        synchronized (this) {\n            SparseArray<ActiveCallback> callbacks = mActiveWatchers.get(callback.asBinder());\n            if (callbacks == null) {\n                callbacks = new SparseArray<>();\n                mActiveWatchers.put(callback.asBinder(), callbacks);\n            }\n            final ActiveCallback activeCallback = new ActiveCallback(callback, watchedUid,\n                    callingUid, callingPid);\n            for (int op : ops) {\n                callbacks.put(op, activeCallback);\n            }\n        }\n    }\n\n    @Override\n    public void stopWatchingActive(IAppOpsActiveCallback callback) {\n        if (callback == null) {\n            return;\n        }\n        synchronized (this) {\n            final SparseArray<ActiveCallback> activeCallbacks =\n                    mActiveWatchers.remove(callback.asBinder());\n            if (activeCallbacks == null) {\n                return;\n            }\n            final int callbackCount = activeCallbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                activeCallbacks.valueAt(i).destroy();\n            }\n        }\n    }\n\n    @Override\n    public void startWatchingStarted(int[] ops, @NonNull IAppOpsStartedCallback callback) {\n        int watchedUid = Process.INVALID_UID;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                != PackageManager.PERMISSION_GRANTED) {\n            watchedUid = callingUid;\n        }\n\n        Preconditions.checkArgument(!ArrayUtils.isEmpty(ops), \"Ops cannot be null or empty\");\n        Preconditions.checkArrayElementsInRange(ops, 0, AppOpsManager._NUM_OP - 1,\n                \"Invalid op code in: \" + Arrays.toString(ops));\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n\n        synchronized (this) {\n            SparseArray<StartedCallback> callbacks = mStartedWatchers.get(callback.asBinder());\n            if (callbacks == null) {\n                callbacks = new SparseArray<>();\n                mStartedWatchers.put(callback.asBinder(), callbacks);\n            }\n\n            final StartedCallback startedCallback = new StartedCallback(callback, watchedUid,\n                    callingUid, callingPid);\n            for (int op : ops) {\n                callbacks.put(op, startedCallback);\n            }\n        }\n    }\n\n    @Override\n    public void stopWatchingStarted(IAppOpsStartedCallback callback) {\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n\n        synchronized (this) {\n            final SparseArray<StartedCallback> startedCallbacks =\n                    mStartedWatchers.remove(callback.asBinder());\n            if (startedCallbacks == null) {\n                return;\n            }\n\n            final int callbackCount = startedCallbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                startedCallbacks.valueAt(i).destroy();\n            }\n        }\n    }\n\n    @Override\n    public void startWatchingNoted(@NonNull int[] ops, @NonNull IAppOpsNotedCallback callback) {\n        int watchedUid = Process.INVALID_UID;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                != PackageManager.PERMISSION_GRANTED) {\n            watchedUid = callingUid;\n        }\n        Preconditions.checkArgument(!ArrayUtils.isEmpty(ops), \"Ops cannot be null or empty\");\n        Preconditions.checkArrayElementsInRange(ops, 0, AppOpsManager._NUM_OP - 1,\n                \"Invalid op code in: \" + Arrays.toString(ops));\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n        synchronized (this) {\n            SparseArray<NotedCallback> callbacks = mNotedWatchers.get(callback.asBinder());\n            if (callbacks == null) {\n                callbacks = new SparseArray<>();\n                mNotedWatchers.put(callback.asBinder(), callbacks);\n            }\n            final NotedCallback notedCallback = new NotedCallback(callback, watchedUid,\n                    callingUid, callingPid);\n            for (int op : ops) {\n                callbacks.put(op, notedCallback);\n            }\n        }\n    }\n\n    @Override\n    public void stopWatchingNoted(IAppOpsNotedCallback callback) {\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n        synchronized (this) {\n            final SparseArray<NotedCallback> notedCallbacks =\n                    mNotedWatchers.remove(callback.asBinder());\n            if (notedCallbacks == null) {\n                return;\n            }\n            final int callbackCount = notedCallbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                notedCallbacks.valueAt(i).destroy();\n            }\n        }\n    }\n\n    /**\n     * Collect an {@link AsyncNotedAppOp}.\n     *\n     * @param uid The uid the op was noted for\n     * @param packageName The package the op was noted for\n     * @param opCode The code of the op noted\n     * @param attributionTag attribution tag the op was noted for\n     * @param message The message for the op noting\n     */\n    private void collectAsyncNotedOp(int uid, @NonNull String packageName, int opCode,\n            @Nullable String attributionTag, @OpFlags int flags, @NonNull String message,\n            boolean shouldCollectMessage) {\n        Objects.requireNonNull(message);\n\n        int callingUid = Binder.getCallingUid();\n\n        final long token = Binder.clearCallingIdentity();\n        try {\n            synchronized (this) {\n                Pair<String, Integer> key = getAsyncNotedOpsKey(packageName, uid);\n\n                RemoteCallbackList<IAppOpsAsyncNotedCallback> callbacks = mAsyncOpWatchers.get(key);\n                AsyncNotedAppOp asyncNotedOp = new AsyncNotedAppOp(opCode, callingUid,\n                        attributionTag, message, System.currentTimeMillis());\n                final boolean[] wasNoteForwarded = {false};\n\n                if ((flags & (OP_FLAG_SELF | OP_FLAG_TRUSTED_PROXIED)) != 0\n                        && shouldCollectMessage) {\n                    reportRuntimeAppOpAccessMessageAsyncLocked(uid, packageName, opCode,\n                            attributionTag, message);\n                }\n\n                if (callbacks != null) {\n                    callbacks.broadcast((cb) -> {\n                        try {\n                            cb.opNoted(asyncNotedOp);\n                            wasNoteForwarded[0] = true;\n                        } catch (RemoteException e) {\n                            Slog.e(TAG,\n                                    \"Could not forward noteOp of \" + opCode + \" to \" + packageName\n                                            + \"/\" + uid + \"(\" + attributionTag + \")\", e);\n                        }\n                    });\n                }\n\n                if (!wasNoteForwarded[0]) {\n                    ArrayList<AsyncNotedAppOp> unforwardedOps = mUnforwardedAsyncNotedOps.get(key);\n                    if (unforwardedOps == null) {\n                        unforwardedOps = new ArrayList<>(1);\n                        mUnforwardedAsyncNotedOps.put(key, unforwardedOps);\n                    }\n\n                    unforwardedOps.add(asyncNotedOp);\n                    if (unforwardedOps.size() > MAX_UNFORWARDED_OPS) {\n                        unforwardedOps.remove(0);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Compute a key to be used in {@link #mAsyncOpWatchers} and {@link #mUnforwardedAsyncNotedOps}\n     *\n     * @param packageName The package name of the app\n     * @param uid The uid of the app\n     *\n     * @return They key uniquely identifying the app\n     */\n    private @NonNull Pair<String, Integer> getAsyncNotedOpsKey(@NonNull String packageName,\n            int uid) {\n        return new Pair<>(packageName, uid);\n    }\n\n    @Override\n    public void startWatchingAsyncNoted(String packageName, IAppOpsAsyncNotedCallback callback) {\n        Objects.requireNonNull(packageName);\n        Objects.requireNonNull(callback);\n\n        int uid = Binder.getCallingUid();\n        Pair<String, Integer> key = getAsyncNotedOpsKey(packageName, uid);\n\n        verifyAndGetBypass(uid, packageName, null);\n\n        synchronized (this) {\n            RemoteCallbackList<IAppOpsAsyncNotedCallback> callbacks = mAsyncOpWatchers.get(key);\n            if (callbacks == null) {\n                callbacks = new RemoteCallbackList<IAppOpsAsyncNotedCallback>() {\n                    @Override\n                    public void onCallbackDied(IAppOpsAsyncNotedCallback callback) {\n                        synchronized (AppOpsService.this) {\n                            if (getRegisteredCallbackCount() == 0) {\n                                mAsyncOpWatchers.remove(key);\n                            }\n                        }\n                    }\n                };\n                mAsyncOpWatchers.put(key, callbacks);\n            }\n\n            callbacks.register(callback);\n        }\n    }\n\n    @Override\n    public void stopWatchingAsyncNoted(String packageName, IAppOpsAsyncNotedCallback callback) {\n        Objects.requireNonNull(packageName);\n        Objects.requireNonNull(callback);\n\n        int uid = Binder.getCallingUid();\n        Pair<String, Integer> key = getAsyncNotedOpsKey(packageName, uid);\n\n        verifyAndGetBypass(uid, packageName, null);\n\n        synchronized (this) {\n            RemoteCallbackList<IAppOpsAsyncNotedCallback> callbacks = mAsyncOpWatchers.get(key);\n            if (callbacks != null) {\n                callbacks.unregister(callback);\n                if (callbacks.getRegisteredCallbackCount() == 0) {\n                    mAsyncOpWatchers.remove(key);\n                }\n            }\n        }\n    }\n\n    @Override\n    public List<AsyncNotedAppOp> extractAsyncOps(String packageName) {\n        Objects.requireNonNull(packageName);\n\n        int uid = Binder.getCallingUid();\n\n        verifyAndGetBypass(uid, packageName, null);\n\n        synchronized (this) {\n            return mUnforwardedAsyncNotedOps.remove(getAsyncNotedOpsKey(packageName, uid));\n        }\n    }\n\n    @Override\n    public SyncNotedAppOp startOperation(IBinder token, int code, int uid,\n            @Nullable String packageName, @Nullable String attributionTag,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp,\n            String message, boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n            int attributionChainId) {\n        return mCheckOpsDelegateDispatcher.startOperation(token, code, uid, packageName,\n                attributionTag, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                shouldCollectMessage, attributionFlags, attributionChainId);\n    }\n\n    private SyncNotedAppOp startOperationImpl(@NonNull IBinder clientId, int code, int uid,\n            @Nullable String packageName, @Nullable String attributionTag,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, @NonNull String message,\n            boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n            int attributionChainId) {\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                    packageName);\n        }\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, attributionTag,\n                    packageName);\n        }\n\n        // As a special case for OP_RECORD_AUDIO_HOTWORD, OP_RECEIVE_AMBIENT_TRIGGER_AUDIO and\n        // OP_RECORD_AUDIO_SANDBOXED which we use only for attribution purposes and not as a check,\n        // also make sure that the caller is allowed to access the data gated by OP_RECORD_AUDIO.\n        //\n        // TODO: Revert this change before Android 12.\n        int result = MODE_DEFAULT;\n        if (code == OP_RECORD_AUDIO_HOTWORD || code == OP_RECEIVE_AMBIENT_TRIGGER_AUDIO\n                || code == OP_RECORD_AUDIO_SANDBOXED) {\n            result = checkOperation(OP_RECORD_AUDIO, uid, packageName);\n            // Check result\n            if (result != AppOpsManager.MODE_ALLOWED) {\n                return new SyncNotedAppOp(result, code, attributionTag, packageName);\n            }\n        }\n        // As a special case for OP_CAMERA_SANDBOXED.\n        if (code == OP_CAMERA_SANDBOXED) {\n            result = checkOperation(OP_CAMERA, uid, packageName);\n            // Check result\n            if (result != AppOpsManager.MODE_ALLOWED) {\n                return new SyncNotedAppOp(result, code, attributionTag, packageName);\n            }\n        }\n\n        return startOperationUnchecked(clientId, code, uid, packageName, attributionTag,\n                Process.INVALID_UID, null, null, OP_FLAG_SELF, startIfModeDefault,\n                shouldCollectAsyncNotedOp, message, shouldCollectMessage, attributionFlags,\n                attributionChainId, /*dryRun*/ false);\n    }\n\n    @Override\n    public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n            boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n            boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n            @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n        return mCheckOpsDelegateDispatcher.startProxyOperation(clientId, code, attributionSource,\n                startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlags,\n                attributionChainId);\n    }\n\n    private SyncNotedAppOp startProxyOperationImpl(@NonNull IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n            boolean shouldCollectMessage, boolean skipProxyOperation, @AttributionFlags\n            int proxyAttributionFlags, @AttributionFlags int proxiedAttributionFlags,\n            int attributionChainId) {\n        final int proxyUid = attributionSource.getUid();\n        final String proxyPackageName = attributionSource.getPackageName();\n        final String proxyAttributionTag = attributionSource.getAttributionTag();\n        final int proxiedUid = attributionSource.getNextUid();\n        final String proxiedPackageName = attributionSource.getNextPackageName();\n        final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n\n        verifyIncomingProxyUid(attributionSource);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(proxyPackageName, UserHandle.getUserId(proxyUid))\n                || !isIncomingPackageValid(proxiedPackageName, UserHandle.getUserId(proxiedUid))) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        boolean isCallerTrusted = isCallerAndAttributionTrusted(attributionSource);\n        skipProxyOperation = isCallerTrusted && skipProxyOperation;\n\n        String resolvedProxyPackageName = AppOpsManager.resolvePackageName(proxyUid,\n                proxyPackageName);\n        if (resolvedProxyPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        final boolean isChainTrusted = isCallerTrusted\n                && attributionChainId != ATTRIBUTION_CHAIN_ID_NONE\n                && ((proxyAttributionFlags & ATTRIBUTION_FLAG_TRUSTED) != 0\n                || (proxiedAttributionFlags & ATTRIBUTION_FLAG_TRUSTED) != 0);\n        final boolean isSelfBlame = Binder.getCallingUid() == proxiedUid;\n        final boolean isProxyTrusted = mContext.checkPermission(\n                Manifest.permission.UPDATE_APP_OPS_STATS, -1, proxyUid)\n                == PackageManager.PERMISSION_GRANTED || isSelfBlame\n                || isChainTrusted;\n\n        String resolvedProxiedPackageName = AppOpsManager.resolvePackageName(proxiedUid,\n                proxiedPackageName);\n        if (resolvedProxiedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        final int proxiedFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXIED\n                : AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED;\n\n        if (!skipProxyOperation) {\n            // Test if the proxied operation will succeed before starting the proxy operation\n            final SyncNotedAppOp testProxiedOp = startOperationUnchecked(clientId, code,\n                    proxiedUid, resolvedProxiedPackageName, proxiedAttributionTag, proxyUid,\n                    resolvedProxyPackageName, proxyAttributionTag, proxiedFlags, startIfModeDefault,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    proxiedAttributionFlags, attributionChainId, /*dryRun*/ true);\n            if (!shouldStartForMode(testProxiedOp.getOpMode(), startIfModeDefault)) {\n                return testProxiedOp;\n            }\n\n            final int proxyFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXY\n                    : AppOpsManager.OP_FLAG_UNTRUSTED_PROXY;\n\n            final SyncNotedAppOp proxyAppOp = startOperationUnchecked(clientId, code, proxyUid,\n                    resolvedProxyPackageName, proxyAttributionTag, Process.INVALID_UID, null, null,\n                    proxyFlags, startIfModeDefault, !isProxyTrusted, \"proxy \" + message,\n                    shouldCollectMessage, proxyAttributionFlags, attributionChainId,\n                    /*dryRun*/ false);\n            if (!shouldStartForMode(proxyAppOp.getOpMode(), startIfModeDefault)) {\n                return proxyAppOp;\n            }\n        }\n\n        return startOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,\n                proxiedAttributionTag, proxyUid, resolvedProxyPackageName, proxyAttributionTag,\n                proxiedFlags, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                shouldCollectMessage, proxiedAttributionFlags, attributionChainId,\n                /*dryRun*/ false);\n    }\n\n    private boolean shouldStartForMode(int mode, boolean startIfModeDefault) {\n        return (mode == MODE_ALLOWED || (mode == MODE_DEFAULT && startIfModeDefault));\n    }\n\n    private SyncNotedAppOp startOperationUnchecked(IBinder clientId, int code, int uid,\n            @NonNull String packageName, @Nullable String attributionTag, int proxyUid,\n            String proxyPackageName, @Nullable String proxyAttributionTag, @OpFlags int flags,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, @Nullable String message,\n            boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n            int attributionChainId, boolean dryRun) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n            if (!pvr.isAttributionTagValid) {\n                attributionTag = null;\n            }\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot startOperation: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot startOperation\", e);\n            }\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                    packageName);\n        }\n        if (proxyAttributionTag != null\n                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n            proxyAttributionTag = null;\n        }\n\n        boolean isRestricted = false;\n        int startType = START_TYPE_FAILED;\n        synchronized (this) {\n            final Ops ops = getOpsLocked(uid, packageName, attributionTag,\n                    pvr.isAttributionTagValid, pvr.bypass, /* edit */ true);\n            if (ops == null) {\n                if (!dryRun) {\n                    scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag,\n                            flags, AppOpsManager.MODE_IGNORED, startType, attributionFlags,\n                            attributionChainId);\n                }\n                if (DEBUG) Slog.d(TAG, \"startOperation: no op for code \" + code + \" uid \" + uid\n                        + \" package \" + packageName + \" flags: \"\n                        + AppOpsManager.flagsToString(flags));\n                return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                        packageName);\n            }\n            final Op op = getOpLocked(ops, code, uid, true);\n            final AttributedOp attributedOp = op.getOrCreateAttribution(op, attributionTag);\n            final UidState uidState = ops.uidState;\n            isRestricted = isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass,\n                    false);\n            final int switchCode = AppOpsManager.opToSwitch(code);\n            // If there is a non-default per UID policy (we set UID op mode only if\n            // non-default) it takes over, otherwise use the per package policy.\n            if (uidState.getUidMode(switchCode) != AppOpsManager.opToDefaultMode(switchCode)) {\n                final int uidMode = uidState.evalMode(code, uidState.getUidMode(switchCode));\n                if (!shouldStartForMode(uidMode, startIfModeDefault)) {\n                    if (DEBUG) {\n                        Slog.d(TAG, \"startOperation: uid reject #\" + uidMode + \" for code \"\n                                + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                                + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    }\n                    if (!dryRun) {\n                        attributedOp.rejected(uidState.getState(), flags);\n                        scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag,\n                                flags, uidMode, startType, attributionFlags, attributionChainId);\n                    }\n                    return new SyncNotedAppOp(uidMode, code, attributionTag, packageName);\n                }\n            } else {\n                final Op switchOp = switchCode != code ? getOpLocked(ops, switchCode, uid, true)\n                        : op;\n                final int mode = switchOp.uidState.evalMode(switchOp.op, switchOp.getMode());\n                if (mode != AppOpsManager.MODE_ALLOWED\n                        && (!startIfModeDefault || mode != MODE_DEFAULT)) {\n                    if (DEBUG) Slog.d(TAG, \"startOperation: reject #\" + mode + \" for code \"\n                            + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                            + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    if (!dryRun) {\n                        attributedOp.rejected(uidState.getState(), flags);\n                        scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag,\n                                flags, mode, startType, attributionFlags, attributionChainId);\n                    }\n                    return new SyncNotedAppOp(mode, code, attributionTag, packageName);\n                }\n            }\n            if (DEBUG) Slog.d(TAG, \"startOperation: allowing code \" + code + \" uid \" + uid\n                    + \" package \" + packageName + \" restricted: \" + isRestricted\n                    + \" flags: \" + AppOpsManager.flagsToString(flags));\n            if (!dryRun) {\n                try {\n                    if (isRestricted) {\n                        attributedOp.createPaused(clientId, proxyUid, proxyPackageName,\n                                proxyAttributionTag, uidState.getState(), flags,\n                                attributionFlags, attributionChainId);\n                    } else {\n                        attributedOp.started(clientId, proxyUid, proxyPackageName,\n                                proxyAttributionTag, uidState.getState(), flags,\n                                attributionFlags, attributionChainId);\n                        startType = START_TYPE_STARTED;\n                    }\n                } catch (RemoteException e) {\n                    throw new RuntimeException(e);\n                }\n                scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                        isRestricted ? MODE_IGNORED : MODE_ALLOWED, startType, attributionFlags,\n                        attributionChainId);\n            }\n        }\n\n        if (shouldCollectAsyncNotedOp && !dryRun && !isRestricted) {\n            collectAsyncNotedOp(uid, packageName, code, attributionTag, AppOpsManager.OP_FLAG_SELF,\n                    message, shouldCollectMessage);\n        }\n\n        return new SyncNotedAppOp(isRestricted ? MODE_IGNORED : MODE_ALLOWED, code, attributionTag,\n                packageName);\n    }\n\n    @Override\n    public void finishOperation(IBinder clientId, int code, int uid, String packageName,\n            String attributionTag) {\n        mCheckOpsDelegateDispatcher.finishOperation(clientId, code, uid, packageName,\n                attributionTag);\n    }\n\n    private void finishOperationImpl(IBinder clientId, int code, int uid, String packageName,\n            String attributionTag) {\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return;\n        }\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return;\n        }\n\n        finishOperationUnchecked(clientId, code, uid, resolvedPackageName, attributionTag);\n    }\n\n    @Override\n    public void finishProxyOperation(@NonNull IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n        mCheckOpsDelegateDispatcher.finishProxyOperation(clientId, code, attributionSource,\n                skipProxyOperation);\n    }\n\n    private Void finishProxyOperationImpl(IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n        final int proxyUid = attributionSource.getUid();\n        final String proxyPackageName = attributionSource.getPackageName();\n        final String proxyAttributionTag = attributionSource.getAttributionTag();\n        final int proxiedUid = attributionSource.getNextUid();\n        final String proxiedPackageName = attributionSource.getNextPackageName();\n        final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n\n        skipProxyOperation = skipProxyOperation\n                && isCallerAndAttributionTrusted(attributionSource);\n\n        verifyIncomingProxyUid(attributionSource);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(proxyPackageName, UserHandle.getUserId(proxyUid))\n                || !isIncomingPackageValid(proxiedPackageName, UserHandle.getUserId(proxiedUid))) {\n            return null;\n        }\n\n        String resolvedProxyPackageName = AppOpsManager.resolvePackageName(proxyUid,\n                proxyPackageName);\n        if (resolvedProxyPackageName == null) {\n            return null;\n        }\n\n        if (!skipProxyOperation) {\n            finishOperationUnchecked(clientId, code, proxyUid, resolvedProxyPackageName,\n                    proxyAttributionTag);\n        }\n\n        String resolvedProxiedPackageName = AppOpsManager.resolvePackageName(proxiedUid,\n                proxiedPackageName);\n        if (resolvedProxiedPackageName == null) {\n            return null;\n        }\n\n        finishOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,\n                proxiedAttributionTag);\n\n        return null;\n    }\n\n    private void finishOperationUnchecked(IBinder clientId, int code, int uid, String packageName,\n            String attributionTag) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag);\n            if (!pvr.isAttributionTagValid) {\n                attributionTag = null;\n            }\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot finishOperation: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot finishOperation\", e);\n            }\n            return;\n        }\n\n        synchronized (this) {\n            Op op = getOpLocked(code, uid, packageName, attributionTag, pvr.isAttributionTagValid,\n                    pvr.bypass, /* edit */ true);\n            if (op == null) {\n                Slog.e(TAG, \"Operation not found: uid=\" + uid + \" pkg=\" + packageName + \"(\"\n                        + attributionTag + \") op=\" + AppOpsManager.opToName(code));\n                return;\n            }\n            final AttributedOp attributedOp = op.mAttributions.get(attributionTag);\n            if (attributedOp == null) {\n                Slog.e(TAG, \"Attribution not found: uid=\" + uid + \" pkg=\" + packageName + \"(\"\n                        + attributionTag + \") op=\" + AppOpsManager.opToName(code));\n                return;\n            }\n\n            if (attributedOp.isRunning() || attributedOp.isPaused()) {\n                attributedOp.finished(clientId);\n            } else {\n                Slog.e(TAG, \"Operation not started: uid=\" + uid + \" pkg=\" + packageName + \"(\"\n                        + attributionTag + \") op=\" + AppOpsManager.opToName(code));\n            }\n        }\n    }\n\n    void scheduleOpActiveChangedIfNeededLocked(int code, int uid, @NonNull\n            String packageName, @Nullable String attributionTag, boolean active, @AttributionFlags\n            int attributionFlags, int attributionChainId) {\n        ArraySet<ActiveCallback> dispatchedCallbacks = null;\n        final int callbackListCount = mActiveWatchers.size();\n        for (int i = 0; i < callbackListCount; i++) {\n            final SparseArray<ActiveCallback> callbacks = mActiveWatchers.valueAt(i);\n            ActiveCallback callback = callbacks.get(code);\n            if (callback != null) {\n                if (callback.mWatchingUid >= 0 && callback.mWatchingUid != uid) {\n                    continue;\n                }\n                if (dispatchedCallbacks == null) {\n                    dispatchedCallbacks = new ArraySet<>();\n                }\n                dispatchedCallbacks.add(callback);\n            }\n        }\n        if (dispatchedCallbacks == null) {\n            return;\n        }\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyOpActiveChanged,\n                this, dispatchedCallbacks, code, uid, packageName, attributionTag, active,\n                attributionFlags, attributionChainId));\n    }\n\n    private void notifyOpActiveChanged(ArraySet<ActiveCallback> callbacks,\n            int code, int uid, @NonNull String packageName, @Nullable String attributionTag,\n            boolean active, @AttributionFlags int attributionFlags, int attributionChainId) {\n        // There are features watching for mode changes such as window manager\n        // and location manager which are in our process. The callbacks in these\n        // features may require permissions our remote caller does not have.\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int callbackCount = callbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                final ActiveCallback callback = callbacks.valueAt(i);\n                try {\n                    if (shouldIgnoreCallback(code, callback.mCallingPid, callback.mCallingUid)) {\n                        continue;\n                    }\n                    callback.mCallback.opActiveChanged(code, uid, packageName, attributionTag,\n                            active, attributionFlags, attributionChainId);\n                } catch (RemoteException e) {\n                    /* do nothing */\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    void scheduleOpStartedIfNeededLocked(int code, int uid, String pkgName,\n            String attributionTag, @OpFlags int flags, @Mode int result,\n            @AppOpsManager.OnOpStartedListener.StartedType int startedType,\n            @AttributionFlags int attributionFlags, int attributionChainId) {\n        ArraySet<StartedCallback> dispatchedCallbacks = null;\n        final int callbackListCount = mStartedWatchers.size();\n        for (int i = 0; i < callbackListCount; i++) {\n            final SparseArray<StartedCallback> callbacks = mStartedWatchers.valueAt(i);\n\n            StartedCallback callback = callbacks.get(code);\n            if (callback != null) {\n                if (callback.mWatchingUid >= 0 && callback.mWatchingUid != uid) {\n                    continue;\n                }\n\n                if (dispatchedCallbacks == null) {\n                    dispatchedCallbacks = new ArraySet<>();\n                }\n                dispatchedCallbacks.add(callback);\n            }\n        }\n\n        if (dispatchedCallbacks == null) {\n            return;\n        }\n\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyOpStarted,\n                this, dispatchedCallbacks, code, uid, pkgName, attributionTag, flags,\n                result, startedType, attributionFlags, attributionChainId));\n    }\n\n    private void notifyOpStarted(ArraySet<StartedCallback> callbacks,\n            int code, int uid, String packageName, String attributionTag, @OpFlags int flags,\n            @Mode int result, @AppOpsManager.OnOpStartedListener.StartedType int startedType,\n            @AttributionFlags int attributionFlags, int attributionChainId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int callbackCount = callbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                final StartedCallback callback = callbacks.valueAt(i);\n                try {\n                    if (shouldIgnoreCallback(code, callback.mCallingPid, callback.mCallingUid)) {\n                        continue;\n                    }\n                    callback.mCallback.opStarted(code, uid, packageName, attributionTag, flags,\n                            result, startedType, attributionFlags, attributionChainId);\n                } catch (RemoteException e) {\n                    /* do nothing */\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void scheduleOpNotedIfNeededLocked(int code, int uid, String packageName,\n            String attributionTag, @OpFlags int flags, @Mode int result) {\n        ArraySet<NotedCallback> dispatchedCallbacks = null;\n        final int callbackListCount = mNotedWatchers.size();\n        for (int i = 0; i < callbackListCount; i++) {\n            final SparseArray<NotedCallback> callbacks = mNotedWatchers.valueAt(i);\n            final NotedCallback callback = callbacks.get(code);\n            if (callback != null) {\n                if (callback.mWatchingUid >= 0 && callback.mWatchingUid != uid) {\n                    continue;\n                }\n                if (dispatchedCallbacks == null) {\n                    dispatchedCallbacks = new ArraySet<>();\n                }\n                dispatchedCallbacks.add(callback);\n            }\n        }\n        if (dispatchedCallbacks == null) {\n            return;\n        }\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyOpChecked,\n                this, dispatchedCallbacks, code, uid, packageName, attributionTag, flags,\n                result));\n    }\n\n    private void notifyOpChecked(ArraySet<NotedCallback> callbacks,\n            int code, int uid, String packageName, String attributionTag, @OpFlags int flags,\n            @Mode int result) {\n        // There are features watching for checks in our process. The callbacks in\n        // these features may require permissions our remote caller does not have.\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int callbackCount = callbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                final NotedCallback callback = callbacks.valueAt(i);\n                try {\n                    if (shouldIgnoreCallback(code, callback.mCallingPid, callback.mCallingUid)) {\n                        continue;\n                    }\n                    callback.mCallback.opNoted(code, uid, packageName, attributionTag, flags,\n                            result);\n                } catch (RemoteException e) {\n                    /* do nothing */\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    @Override\n    public int permissionToOpCode(String permission) {\n        if (permission == null) {\n            return AppOpsManager.OP_NONE;\n        }\n        return AppOpsManager.permissionToOpCode(permission);\n    }\n\n    @Override\n    public boolean shouldCollectNotes(int opCode) {\n        Preconditions.checkArgumentInRange(opCode, 0, _NUM_OP - 1, \"opCode\");\n\n        if (AppOpsManager.shouldForceCollectNoteForOp(opCode)) {\n            return true;\n        }\n\n        String perm = AppOpsManager.opToPermission(opCode);\n        if (perm == null) {\n            return false;\n        }\n\n        PermissionInfo permInfo;\n        try {\n            permInfo = mContext.getPackageManager().getPermissionInfo(perm, 0);\n        } catch (PackageManager.NameNotFoundException e) {\n            return false;\n        }\n\n        return permInfo.getProtection() == PROTECTION_DANGEROUS\n                || (permInfo.getProtectionFlags() & PROTECTION_FLAG_APPOP) != 0;\n    }\n\n    private void verifyIncomingProxyUid(@NonNull AttributionSource attributionSource) {\n        if (attributionSource.getUid() == Binder.getCallingUid()) {\n            return;\n        }\n        if (Binder.getCallingPid() == Process.myPid()) {\n            return;\n        }\n        if (attributionSource.isTrusted(mContext)) {\n            return;\n        }\n        mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n    }\n\n    private void verifyIncomingUid(int uid) {\n        if (uid == Binder.getCallingUid()) {\n            return;\n        }\n        if (Binder.getCallingPid() == Process.myPid()) {\n            return;\n        }\n        mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n    }\n\n    private boolean shouldIgnoreCallback(int op, int watcherPid, int watcherUid) {\n        // If it's a restricted read op, ignore it if watcher doesn't have manage ops permission,\n        // as watcher should not use this to signal if the value is changed.\n        return opRestrictsRead(op) && mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n                watcherPid, watcherUid) != PackageManager.PERMISSION_GRANTED;\n    }\n\n    private void verifyIncomingOp(int op) {\n        if (op >= 0 && op < AppOpsManager._NUM_OP) {\n            // Enforce privileged appops permission if it's a restricted read op.\n            if (opRestrictsRead(op)) {\n                if (!(mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n                        Manifest.permission.GET_APP_OPS_STATS,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n                        Manifest.permission.MANAGE_APP_OPS_MODES,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED)) {\n                    throw new SecurityException(\"verifyIncomingOp: uid \" + Binder.getCallingUid()\n                            + \" does not have any of {MANAGE_APPOPS, GET_APP_OPS_STATS, \"\n                            + \"MANAGE_APP_OPS_MODES}\");\n                }\n            }\n            return;\n        }\n        throw new IllegalArgumentException(\"Bad operation #\" + op);\n    }\n\n    private boolean isIncomingPackageValid(@Nullable String packageName, @UserIdInt int userId) {\n        final int callingUid = Binder.getCallingUid();\n        // Handle the special UIDs that don't have actual packages (audioserver, cameraserver, etc).\n        if (packageName == null || isSpecialPackage(callingUid, packageName)) {\n            return true;\n        }\n\n        // If the package doesn't exist, #verifyAndGetBypass would throw a SecurityException in\n        // the end. Although that exception would be caught and return, we could make it return\n        // early.\n        if (!isPackageExisted(packageName)) {\n            return false;\n        }\n\n        if (getPackageManagerInternal().filterAppAccess(packageName, callingUid, userId)) {\n            Slog.w(TAG, packageName + \" not found from \" + callingUid);\n            return false;\n        }\n\n        return true;\n    }\n\n    private boolean isSpecialPackage(int callingUid, @Nullable String packageName) {\n        final String resolvedPackage = AppOpsManager.resolvePackageName(callingUid, packageName);\n        return callingUid == Process.SYSTEM_UID\n                || resolveUid(resolvedPackage) != Process.INVALID_UID;\n    }\n\n    private boolean isCallerAndAttributionTrusted(@NonNull AttributionSource attributionSource) {\n        if (attributionSource.getUid() != Binder.getCallingUid()\n                && attributionSource.isTrusted(mContext)) {\n            return true;\n        }\n        return mContext.checkPermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null)\n                == PackageManager.PERMISSION_GRANTED;\n    }\n\n    private @Nullable UidState getUidStateLocked(int uid, boolean edit) {\n        UidState uidState = mUidStates.get(uid);\n        if (uidState == null) {\n            if (!edit) {\n                return null;\n            }\n            uidState = new UidState(uid);\n            mUidStates.put(uid, uidState);\n        }\n\n        return uidState;\n    }\n\n    private void updateAppWidgetVisibility(SparseArray<String> uidPackageNames, boolean visible) {\n        synchronized (this) {\n            getUidStateTracker().updateAppWidgetVisibility(uidPackageNames, visible);\n        }\n    }\n\n    /**\n     * @return {@link PackageManagerInternal}\n     */\n    private @NonNull PackageManagerInternal getPackageManagerInternal() {\n        if (mPackageManagerInternal == null) {\n            mPackageManagerInternal = LocalServices.getService(PackageManagerInternal.class);\n        }\n        if (mPackageManagerInternal == null) {\n            throw new IllegalStateException(\"PackageManagerInternal not loaded\");\n        }\n\n        return mPackageManagerInternal;\n    }\n\n    /**\n     * @return {@link PackageManagerLocal}\n     */\n    private @NonNull PackageManagerLocal getPackageManagerLocal() {\n        if (mPackageManagerLocal == null) {\n            mPackageManagerLocal = LocalManagerRegistry.getManager(PackageManagerLocal.class);\n        }\n        if (mPackageManagerLocal == null) {\n            throw new IllegalStateException(\"PackageManagerLocal not loaded\");\n        }\n\n        return mPackageManagerLocal;\n    }\n\n    /**\n     * @return {@link UserManagerInternal}\n     */\n    private @NonNull UserManagerInternal getUserManagerInternal() {\n        if (mUserManagerInternal == null) {\n            mUserManagerInternal = LocalServices.getService(UserManagerInternal.class);\n        }\n        if (mUserManagerInternal == null) {\n            throw new IllegalStateException(\"UserManagerInternal not loaded\");\n        }\n\n        return mUserManagerInternal;\n    }\n\n    /**\n     * Create a restriction description matching the properties of the package.\n     *\n     * @param pkg The package to create the restriction description for\n     *\n     * @return The restriction matching the package\n     */\n    private RestrictionBypass getBypassforPackage(@NonNull PackageState packageState) {\n        return new RestrictionBypass(packageState.getAppId() == Process.SYSTEM_UID,\n                packageState.isPrivileged(), mContext.checkPermission(\n                android.Manifest.permission.EXEMPT_FROM_AUDIO_RECORD_RESTRICTIONS, -1,\n                packageState.getAppId()) == PackageManager.PERMISSION_GRANTED);\n    }\n\n    /**\n     * @see #verifyAndGetBypass(int, String, String, String, boolean)\n     */\n    private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n            @Nullable String attributionTag) {\n        return verifyAndGetBypass(uid, packageName, attributionTag, null);\n    }\n\n    /**\n     * @see #verifyAndGetBypass(int, String, String, String, boolean)\n     */\n    private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n            @Nullable String attributionTag, @Nullable String proxyPackageName) {\n        return verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName, false);\n    }\n\n    /**\n     * Verify that package belongs to uid and return the {@link RestrictionBypass bypass\n     * description} for the package, along with a boolean indicating whether the attribution tag is\n     * valid.\n     *\n     * @param uid The uid the package belongs to\n     * @param packageName The package the might belong to the uid\n     * @param attributionTag attribution tag or {@code null} if no need to verify\n     * @param proxyPackageName The proxy package, from which the attribution tag is to be pulled\n     * @param suppressErrorLogs Whether to print to logcat about nonmatching parameters\n     *\n     * @return PackageVerificationResult containing {@link RestrictionBypass} and whether the\n     *         attribution tag is valid\n     */\n    private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n            @Nullable String attributionTag, @Nullable String proxyPackageName,\n            boolean suppressErrorLogs) {\n        if (uid == Process.ROOT_UID) {\n            // For backwards compatibility, don't check package name for root UID.\n            return new PackageVerificationResult(null,\n                    /* isAttributionTagValid */ true);\n        }\n        if (Process.isSdkSandboxUid(uid)) {\n            // SDK sandbox processes run in their own UID range, but their associated\n            // UID for checks should always be the UID of the package implementing SDK sandbox\n            // service.\n            // TODO: We will need to modify the callers of this function instead, so\n            // modifications and checks against the app ops state are done with the\n            // correct UID.\n            try {\n                final PackageManager pm = mContext.getPackageManager();\n                final String supplementalPackageName = pm.getSdkSandboxPackageName();\n                if (Objects.equals(packageName, supplementalPackageName)) {\n                    uid = pm.getPackageUidAsUser(supplementalPackageName,\n                            PackageManager.PackageInfoFlags.of(0), UserHandle.getUserId(uid));\n                }\n            } catch (PackageManager.NameNotFoundException e) {\n                // Shouldn't happen for the supplemental package\n                e.printStackTrace();\n            }\n        }\n\n\n        // Do not check if uid/packageName/attributionTag is already known.\n        synchronized (this) {\n            UidState uidState = mUidStates.get(uid);\n            if (uidState != null && !uidState.pkgOps.isEmpty()) {\n                Ops ops = uidState.pkgOps.get(packageName);\n\n                if (ops != null && (attributionTag == null || ops.knownAttributionTags.contains(\n                        attributionTag)) && ops.bypass != null) {\n                    return new PackageVerificationResult(ops.bypass,\n                            ops.validAttributionTags.contains(attributionTag));\n                }\n            }\n        }\n\n        int callingUid = Binder.getCallingUid();\n\n        // Allow any attribution tag for resolvable uids\n        int pkgUid;\n        if (Objects.equals(packageName, \"com.android.shell\")) {\n            // Special case for the shell which is a package but should be able\n            // to bypass app attribution tag restrictions.\n            pkgUid = Process.SHELL_UID;\n        } else {\n            pkgUid = resolveUid(packageName);\n        }\n        if (pkgUid != Process.INVALID_UID) {\n            if (pkgUid != UserHandle.getAppId(uid)) {\n                if (!suppressErrorLogs) {\n                    Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n                            + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid\n                            + \".\");\n                }\n                String otherUidMessage = DEBUG ? \" but it is really \" + pkgUid : \" but it is not\";\n                throw new SecurityException(\"Specified package \\\"\" + packageName + \"\\\" under uid \"\n                        +  UserHandle.getAppId(uid) + otherUidMessage);\n            }\n            return new PackageVerificationResult(RestrictionBypass.UNRESTRICTED,\n                    /* isAttributionTagValid */ true);\n        }\n\n        int userId = UserHandle.getUserId(uid);\n        RestrictionBypass bypass = null;\n        boolean isAttributionTagValid = false;\n\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n            var pkgState = pmInt.getPackageStateInternal(packageName);\n            var pkg = pkgState == null ? null : pkgState.getAndroidPackage();\n            if (pkg != null) {\n                isAttributionTagValid = isAttributionInPackage(pkg, attributionTag);\n                pkgUid = UserHandle.getUid(userId, pkgState.getAppId());\n                bypass = getBypassforPackage(pkgState);\n            }\n            if (!isAttributionTagValid) {\n                AndroidPackage proxyPkg = proxyPackageName != null\n                        ? pmInt.getPackage(proxyPackageName) : null;\n                // Re-check in proxy.\n                isAttributionTagValid = isAttributionInPackage(proxyPkg, attributionTag);\n                String msg;\n                if (pkg != null && isAttributionTagValid) {\n                    msg = \"attributionTag \" + attributionTag + \" declared in manifest of the proxy\"\n                            + \" package \" + proxyPackageName + \", this is not advised\";\n                } else if (pkg != null) {\n                    msg = \"attributionTag \" + attributionTag + \" not declared in manifest of \"\n                            + packageName;\n                } else {\n                    msg = \"package \" + packageName + \" not found, can't check for \"\n                            + \"attributionTag \" + attributionTag;\n                }\n\n                try {\n                    if (!mPlatformCompat.isChangeEnabledByPackageName(\n                            SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE, packageName,\n                            userId) || !mPlatformCompat.isChangeEnabledByUid(\n                                    SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE,\n                            callingUid)) {\n                        // Do not override tags if overriding is not enabled for this package\n                        isAttributionTagValid = true;\n                    }\n                    Slog.e(TAG, msg);\n                } catch (RemoteException neverHappens) {\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n\n        if (pkgUid != uid) {\n            if (!suppressErrorLogs) {\n                Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n                        + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid + \".\");\n            }\n            String otherUidMessage = DEBUG ? \" but it is really \" + pkgUid : \" but it is not\";\n            throw new SecurityException(\"Specified package \\\"\" + packageName + \"\\\" under uid \" + uid\n                    + otherUidMessage);\n        }\n\n        return new PackageVerificationResult(bypass, isAttributionTagValid);\n    }\n\n    private boolean isAttributionInPackage(@Nullable AndroidPackage pkg,\n            @Nullable String attributionTag) {\n        if (pkg == null) {\n            return false;\n        } else if (attributionTag == null) {\n            return true;\n        }\n        if (pkg.getAttributions() != null) {\n            int numAttributions = pkg.getAttributions().size();\n            for (int i = 0; i < numAttributions; i++) {\n                if (pkg.getAttributions().get(i).getTag().equals(attributionTag)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n     * This method is intended for ProxyAttributionTag validation and returns false\n     * if it does not exist in either one of them.\n     *\n     * @param packageName Name of the package\n     * @param proxyPackageName Name of the proxy package\n     * @param attributionTag attribution tag to be checked\n     *\n     * @return boolean specifying if attribution tag is valid or not\n     */\n    private boolean isAttributionTagDefined(@Nullable String packageName,\n                                            @Nullable String proxyPackageName,\n                                            @Nullable String attributionTag) {\n        if (packageName == null) {\n            return false;\n        } else if (attributionTag == null) {\n            return true;\n        }\n        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n        if (proxyPackageName != null) {\n            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n                return true;\n            }\n        }\n        AndroidPackage pkg = pmInt.getPackage(packageName);\n        return isAttributionInPackage(pkg, attributionTag);\n    }\n\n    /**\n     * Get (and potentially create) ops.\n     *\n     * @param uid The uid the package belongs to\n     * @param packageName The name of the package\n     * @param attributionTag attribution tag\n     * @param isAttributionTagValid whether the given attribution tag is valid\n     * @param bypass When to bypass certain op restrictions (can be null if edit == false)\n     * @param edit If an ops does not exist, create the ops?\n\n     * @return The ops\n     */\n    private Ops getOpsLocked(int uid, String packageName, @Nullable String attributionTag,\n            boolean isAttributionTagValid, @Nullable RestrictionBypass bypass, boolean edit) {\n        UidState uidState = getUidStateLocked(uid, edit);\n        if (uidState == null) {\n            return null;\n        }\n\n        Ops ops = uidState.pkgOps.get(packageName);\n        if (ops == null) {\n            if (!edit) {\n                return null;\n            }\n            ops = new Ops(packageName, uidState);\n            uidState.pkgOps.put(packageName, ops);\n        }\n\n        if (edit) {\n            if (bypass != null) {\n                ops.bypass = bypass;\n            }\n\n            if (attributionTag != null) {\n                ops.knownAttributionTags.add(attributionTag);\n                if (isAttributionTagValid) {\n                    ops.validAttributionTags.add(attributionTag);\n                } else {\n                    ops.validAttributionTags.remove(attributionTag);\n                }\n            }\n        }\n\n        return ops;\n    }\n\n    private void scheduleWriteLocked() {\n        if (!mWriteScheduled) {\n            mWriteScheduled = true;\n            mHandler.postDelayed(mWriteRunner, WRITE_DELAY);\n        }\n    }\n\n    private void scheduleFastWriteLocked() {\n        if (!mFastWriteScheduled) {\n            mWriteScheduled = true;\n            mFastWriteScheduled = true;\n            mHandler.removeCallbacks(mWriteRunner);\n            mHandler.postDelayed(mWriteRunner, 10*1000);\n        }\n    }\n\n    /**\n     * Get the state of an op for a uid.\n     *\n     * @param code The code of the op\n     * @param uid The uid the of the package\n     * @param packageName The package name for which to get the state for\n     * @param attributionTag The attribution tag\n     * @param isAttributionTagValid Whether the given attribution tag is valid\n     * @param bypass When to bypass certain op restrictions (can be null if edit == false)\n     * @param edit Iff {@code true} create the {@link Op} object if not yet created\n     *\n     * @return The {@link Op state} of the op\n     */\n    private @Nullable Op getOpLocked(int code, int uid, @NonNull String packageName,\n            @Nullable String attributionTag, boolean isAttributionTagValid,\n            @Nullable RestrictionBypass bypass, boolean edit) {\n        Ops ops = getOpsLocked(uid, packageName, attributionTag, isAttributionTagValid, bypass,\n                edit);\n        if (ops == null) {\n            return null;\n        }\n        return getOpLocked(ops, code, uid, edit);\n    }\n\n    private Op getOpLocked(Ops ops, int code, int uid, boolean edit) {\n        Op op = ops.get(code);\n        if (op == null) {\n            if (!edit) {\n                return null;\n            }\n            op = new Op(ops.uidState, ops.packageName, code, uid);\n            ops.put(code, op);\n        }\n        if (edit) {\n            scheduleWriteLocked();\n        }\n        return op;\n    }\n\n    private boolean isOpRestrictedDueToSuspend(int code, String packageName, int uid) {\n        if (!ArrayUtils.contains(OPS_RESTRICTED_ON_SUSPEND, code)) {\n            return false;\n        }\n        final PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n        return pmi.isPackageSuspended(packageName, UserHandle.getUserId(uid));\n    }\n\n    private boolean isOpRestrictedLocked(int uid, int code, String packageName,\n            String attributionTag, @Nullable RestrictionBypass appBypass, boolean isCheckOp) {\n        int restrictionSetCount = mOpGlobalRestrictions.size();\n\n        for (int i = 0; i < restrictionSetCount; i++) {\n            ClientGlobalRestrictionState restrictionState = mOpGlobalRestrictions.valueAt(i);\n            if (restrictionState.hasRestriction(code)) {\n                return true;\n            }\n        }\n\n        int userHandle = UserHandle.getUserId(uid);\n        restrictionSetCount = mOpUserRestrictions.size();\n\n        for (int i = 0; i < restrictionSetCount; i++) {\n            // For each client, check that the given op is not restricted, or that the given\n            // package is exempt from the restriction.\n            ClientUserRestrictionState restrictionState = mOpUserRestrictions.valueAt(i);\n            if (restrictionState.hasRestriction(code, packageName, attributionTag, userHandle,\n                    isCheckOp)) {\n                RestrictionBypass opBypass = opAllowSystemBypassRestriction(code);\n                if (opBypass != null) {\n                    // If we are the system, bypass user restrictions for certain codes\n                    synchronized (this) {\n                        if (opBypass.isSystemUid && appBypass != null && appBypass.isSystemUid) {\n                            return false;\n                        }\n                        if (opBypass.isPrivileged && appBypass != null && appBypass.isPrivileged) {\n                            return false;\n                        }\n                        if (opBypass.isRecordAudioRestrictionExcept && appBypass != null\n                                && appBypass.isRecordAudioRestrictionExcept) {\n                            return false;\n                        }\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Read recent accesses from persistence (mRecentAccessesFile).\n     * If there is no mRecentAccessesFile yet, we'll need migrate from mStorageFile: first read from\n     * mStorageFile, then all subsequent reads/writes will use mRecentAccessesFile.\n     * If neither file exists, there's nothing to migrate.\n     */\n    private void readRecentAccesses() {\n        if (!mRecentAccessesFile.exists()) {\n            readRecentAccesses(mStorageFile);\n        } else {\n            readRecentAccesses(mRecentAccessesFile);\n        }\n    }\n\n    private void readRecentAccesses(AtomicFile file) {\n        synchronized (file) {\n            synchronized (this) {\n                FileInputStream stream;\n                try {\n                    stream = file.openRead();\n                } catch (FileNotFoundException e) {\n                    Slog.i(TAG, \"No existing app ops \" + file.getBaseFile() + \"; starting empty\");\n                    return;\n                }\n                boolean success = false;\n                mUidStates.clear();\n                mAppOpsCheckingService.clearAllModes();\n                try {\n                    TypedXmlPullParser parser = Xml.resolvePullParser(stream);\n                    int type;\n                    while ((type = parser.next()) != XmlPullParser.START_TAG\n                            && type != XmlPullParser.END_DOCUMENT) {\n                        // Parse next until we reach the start or end\n                    }\n\n                    if (type != XmlPullParser.START_TAG) {\n                        throw new IllegalStateException(\"no start tag found\");\n                    }\n\n                    int outerDepth = parser.getDepth();\n                    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                            && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n                        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                            continue;\n                        }\n\n                        String tagName = parser.getName();\n                        if (tagName.equals(\"pkg\")) {\n                            readPackage(parser);\n                        } else if (tagName.equals(\"uid\")) {\n                            // uid tag may be present during migration, don't print warning.\n                            XmlUtils.skipCurrentTag(parser);\n                        } else {\n                            Slog.w(TAG, \"Unknown element under <app-ops>: \"\n                                    + parser.getName());\n                            XmlUtils.skipCurrentTag(parser);\n                        }\n                    }\n\n                    success = true;\n                } catch (IllegalStateException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (NullPointerException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (NumberFormatException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (XmlPullParserException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (IOException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (IndexOutOfBoundsException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } finally {\n                    if (!success) {\n                        mUidStates.clear();\n                        mAppOpsCheckingService.clearAllModes();\n                    }\n                    try {\n                        stream.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n    }\n\n    private void readPackage(TypedXmlPullParser parser)\n            throws NumberFormatException, XmlPullParserException, IOException {\n        String pkgName = parser.getAttributeValue(null, \"n\");\n        int outerDepth = parser.getDepth();\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                continue;\n            }\n\n            String tagName = parser.getName();\n            if (tagName.equals(\"uid\")) {\n                readUid(parser, pkgName);\n            } else {\n                Slog.w(TAG, \"Unknown element under <pkg>: \"\n                        + parser.getName());\n                XmlUtils.skipCurrentTag(parser);\n            }\n        }\n    }\n\n    private void readUid(TypedXmlPullParser parser, String pkgName)\n            throws NumberFormatException, XmlPullParserException, IOException {\n        int uid = parser.getAttributeInt(null, \"n\");\n        final UidState uidState = getUidStateLocked(uid, true);\n        int outerDepth = parser.getDepth();\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                continue;\n            }\n            String tagName = parser.getName();\n            if (tagName.equals(\"op\")) {\n                readOp(parser, uidState, pkgName);\n            } else {\n                Slog.w(TAG, \"Unknown element under <pkg>: \"\n                        + parser.getName());\n                XmlUtils.skipCurrentTag(parser);\n            }\n        }\n    }\n\n    private void readAttributionOp(TypedXmlPullParser parser, @NonNull Op parent,\n            @Nullable String attribution)\n            throws NumberFormatException, IOException, XmlPullParserException {\n        final AttributedOp attributedOp = parent.getOrCreateAttribution(parent, attribution);\n\n        final long key = parser.getAttributeLong(null, \"n\");\n        final int uidState = extractUidStateFromKey(key);\n        final int opFlags = extractFlagsFromKey(key);\n\n        final long accessTime = parser.getAttributeLong(null, \"t\", 0);\n        final long rejectTime = parser.getAttributeLong(null, \"r\", 0);\n        final long accessDuration = parser.getAttributeLong(null, \"d\", -1);\n        final String proxyPkg = XmlUtils.readStringAttribute(parser, \"pp\");\n        final int proxyUid = parser.getAttributeInt(null, \"pu\", Process.INVALID_UID);\n        final String proxyAttributionTag = XmlUtils.readStringAttribute(parser, \"pc\");\n\n        if (accessTime > 0) {\n            attributedOp.accessed(accessTime, accessDuration, proxyUid, proxyPkg,\n                    proxyAttributionTag, uidState, opFlags);\n        }\n        if (rejectTime > 0) {\n            attributedOp.rejected(rejectTime, uidState, opFlags);\n        }\n    }\n\n    private void readOp(TypedXmlPullParser parser,\n            @NonNull UidState uidState, @NonNull String pkgName)\n            throws NumberFormatException, XmlPullParserException, IOException {\n        int opCode = parser.getAttributeInt(null, \"n\");\n        Op op = new Op(uidState, pkgName, opCode, uidState.uid);\n\n        int outerDepth = parser.getDepth();\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                continue;\n            }\n            String tagName = parser.getName();\n            if (tagName.equals(\"st\")) {\n                readAttributionOp(parser, op, XmlUtils.readStringAttribute(parser, \"id\"));\n            } else {\n                Slog.w(TAG, \"Unknown element under <op>: \"\n                        + parser.getName());\n                XmlUtils.skipCurrentTag(parser);\n            }\n        }\n\n        Ops ops = uidState.pkgOps.get(pkgName);\n        if (ops == null) {\n            ops = new Ops(pkgName, uidState);\n            uidState.pkgOps.put(pkgName, ops);\n        }\n        ops.put(op.op, op);\n    }\n\n    @VisibleForTesting\n    void writeRecentAccesses() {\n        synchronized (mRecentAccessesFile) {\n            FileOutputStream stream;\n            try {\n                stream = mRecentAccessesFile.startWrite();\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to write state: \" + e);\n                return;\n            }\n\n            List<AppOpsManager.PackageOps> allOps = getPackagesForOps(null);\n\n            try {\n                TypedXmlSerializer out = Xml.resolveSerializer(stream);\n                out.startDocument(null, true);\n                out.startTag(null, \"app-ops\");\n                out.attributeInt(null, \"v\", CURRENT_VERSION);\n\n                if (allOps != null) {\n                    String lastPkg = null;\n                    for (int i=0; i<allOps.size(); i++) {\n                        AppOpsManager.PackageOps pkg = allOps.get(i);\n                        if (!Objects.equals(pkg.getPackageName(), lastPkg)) {\n                            if (lastPkg != null) {\n                                out.endTag(null, \"pkg\");\n                            }\n                            lastPkg = pkg.getPackageName();\n                            if (lastPkg != null) {\n                                out.startTag(null, \"pkg\");\n                                out.attribute(null, \"n\", lastPkg);\n                            }\n                        }\n                        out.startTag(null, \"uid\");\n                        out.attributeInt(null, \"n\", pkg.getUid());\n                        List<AppOpsManager.OpEntry> ops = pkg.getOps();\n                        for (int j=0; j<ops.size(); j++) {\n                            AppOpsManager.OpEntry op = ops.get(j);\n                            out.startTag(null, \"op\");\n                            out.attributeInt(null, \"n\", op.getOp());\n                            if (op.getMode() != AppOpsManager.opToDefaultMode(op.getOp())) {\n                                out.attributeInt(null, \"m\", op.getMode());\n                            }\n\n                            for (String attributionTag : op.getAttributedOpEntries().keySet()) {\n                                final AttributedOpEntry attribution =\n                                        op.getAttributedOpEntries().get(attributionTag);\n\n                                final ArraySet<Long> keys = attribution.collectKeys();\n\n                                final int keyCount = keys.size();\n                                for (int k = 0; k < keyCount; k++) {\n                                    final long key = keys.valueAt(k);\n\n                                    final int uidState = AppOpsManager.extractUidStateFromKey(key);\n                                    final int flags = AppOpsManager.extractFlagsFromKey(key);\n\n                                    final long accessTime = attribution.getLastAccessTime(uidState,\n                                            uidState, flags);\n                                    final long rejectTime = attribution.getLastRejectTime(uidState,\n                                            uidState, flags);\n                                    final long accessDuration = attribution.getLastDuration(\n                                            uidState, uidState, flags);\n                                    // Proxy information for rejections is not backed up\n                                    final OpEventProxyInfo proxy = attribution.getLastProxyInfo(\n                                            uidState, uidState, flags);\n\n                                    if (accessTime <= 0 && rejectTime <= 0 && accessDuration <= 0\n                                            && proxy == null) {\n                                        continue;\n                                    }\n\n                                    String proxyPkg = null;\n                                    String proxyAttributionTag = null;\n                                    int proxyUid = Process.INVALID_UID;\n                                    if (proxy != null) {\n                                        proxyPkg = proxy.getPackageName();\n                                        proxyAttributionTag = proxy.getAttributionTag();\n                                        proxyUid = proxy.getUid();\n                                    }\n\n                                    out.startTag(null, \"st\");\n                                    if (attributionTag != null) {\n                                        out.attribute(null, \"id\", attributionTag);\n                                    }\n                                    out.attributeLong(null, \"n\", key);\n                                    if (accessTime > 0) {\n                                        out.attributeLong(null, \"t\", accessTime);\n                                    }\n                                    if (rejectTime > 0) {\n                                        out.attributeLong(null, \"r\", rejectTime);\n                                    }\n                                    if (accessDuration > 0) {\n                                        out.attributeLong(null, \"d\", accessDuration);\n                                    }\n                                    if (proxyPkg != null) {\n                                        out.attribute(null, \"pp\", proxyPkg);\n                                    }\n                                    if (proxyAttributionTag != null) {\n                                        out.attribute(null, \"pc\", proxyAttributionTag);\n                                    }\n                                    if (proxyUid >= 0) {\n                                        out.attributeInt(null, \"pu\", proxyUid);\n                                    }\n                                    out.endTag(null, \"st\");\n                                }\n                            }\n\n                            out.endTag(null, \"op\");\n                        }\n                        out.endTag(null, \"uid\");\n                    }\n                    if (lastPkg != null) {\n                        out.endTag(null, \"pkg\");\n                    }\n                }\n\n                out.endTag(null, \"app-ops\");\n                out.endDocument();\n                mRecentAccessesFile.finishWrite(stream);\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to write state, restoring backup.\", e);\n                mRecentAccessesFile.failWrite(stream);\n            }\n        }\n        mHistoricalRegistry.writeAndClearDiscreteHistory();\n    }\n\n    static class Shell extends ShellCommand {\n        final IAppOpsService mInterface;\n        final AppOpsService mInternal;\n\n        int userId = UserHandle.USER_SYSTEM;\n        String packageName;\n        String attributionTag;\n        String opStr;\n        String modeStr;\n        int op;\n        int mode;\n        int packageUid;\n        int nonpackageUid;\n        final static Binder sBinder = new Binder();\n        IBinder mToken;\n        boolean targetsUid;\n\n        Shell(IAppOpsService iface, AppOpsService internal) {\n            mInterface = iface;\n            mInternal = internal;\n            mToken = AppOpsManager.getClientId();\n        }\n\n        @Override\n        public int onCommand(String cmd) {\n            return onShellCommand(this, cmd);\n        }\n\n        @Override\n        public void onHelp() {\n            PrintWriter pw = getOutPrintWriter();\n            dumpCommandHelp(pw);\n        }\n\n        static private int strOpToOp(String op, PrintWriter err) {\n            try {\n                return AppOpsManager.strOpToOp(op);\n            } catch (IllegalArgumentException e) {\n            }\n            try {\n                return Integer.parseInt(op);\n            } catch (NumberFormatException e) {\n            }\n            try {\n                return AppOpsManager.strDebugOpToOp(op);\n            } catch (IllegalArgumentException e) {\n                err.println(\"Error: \" + e.getMessage());\n                return -1;\n            }\n        }\n\n        static int strModeToMode(String modeStr, PrintWriter err) {\n            for (int i = AppOpsManager.MODE_NAMES.length - 1; i >= 0; i--) {\n                if (AppOpsManager.MODE_NAMES[i].equals(modeStr)) {\n                    return i;\n                }\n            }\n            try {\n                return Integer.parseInt(modeStr);\n            } catch (NumberFormatException e) {\n            }\n            err.println(\"Error: Mode \" + modeStr + \" is not valid\");\n            return -1;\n        }\n\n        int parseUserOpMode(int defMode, PrintWriter err) throws RemoteException {\n            userId = UserHandle.USER_CURRENT;\n            opStr = null;\n            modeStr = null;\n            for (String argument; (argument = getNextArg()) != null;) {\n                if (\"--user\".equals(argument)) {\n                    userId = UserHandle.parseUserArg(getNextArgRequired());\n                } else {\n                    if (opStr == null) {\n                        opStr = argument;\n                    } else if (modeStr == null) {\n                        modeStr = argument;\n                        break;\n                    }\n                }\n            }\n            if (opStr == null) {\n                err.println(\"Error: Operation not specified.\");\n                return -1;\n            }\n            op = strOpToOp(opStr, err);\n            if (op < 0) {\n                return -1;\n            }\n            if (modeStr != null) {\n                if ((mode=strModeToMode(modeStr, err)) < 0) {\n                    return -1;\n                }\n            } else {\n                mode = defMode;\n            }\n            return 0;\n        }\n\n        int parseUserPackageOp(boolean reqOp, PrintWriter err) throws RemoteException {\n            userId = UserHandle.USER_CURRENT;\n            packageName = null;\n            opStr = null;\n            for (String argument; (argument = getNextArg()) != null;) {\n                if (\"--user\".equals(argument)) {\n                    userId = UserHandle.parseUserArg(getNextArgRequired());\n                } else if (\"--uid\".equals(argument)) {\n                    targetsUid = true;\n                } else if (\"--attribution\".equals(argument)) {\n                    attributionTag = getNextArgRequired();\n                } else {\n                    if (packageName == null) {\n                        packageName = argument;\n                    } else if (opStr == null) {\n                        opStr = argument;\n                        break;\n                    }\n                }\n            }\n            if (packageName == null) {\n                err.println(\"Error: Package name not specified.\");\n                return -1;\n            } else if (opStr == null && reqOp) {\n                err.println(\"Error: Operation not specified.\");\n                return -1;\n            }\n            if (opStr != null) {\n                op = strOpToOp(opStr, err);\n                if (op < 0) {\n                    return -1;\n                }\n            } else {\n                op = AppOpsManager.OP_NONE;\n            }\n            if (userId == UserHandle.USER_CURRENT) {\n                userId = ActivityManager.getCurrentUser();\n            }\n            nonpackageUid = -1;\n            try {\n                nonpackageUid = Integer.parseInt(packageName);\n            } catch (NumberFormatException e) {\n            }\n            if (nonpackageUid == -1 && packageName.length() > 1 && packageName.charAt(0) == 'u'\n                    && packageName.indexOf('.') < 0) {\n                int i = 1;\n                while (i < packageName.length() && packageName.charAt(i) >= '0'\n                        && packageName.charAt(i) <= '9') {\n                    i++;\n                }\n                if (i > 1 && i < packageName.length()) {\n                    String userStr = packageName.substring(1, i);\n                    try {\n                        int user = Integer.parseInt(userStr);\n                        char type = packageName.charAt(i);\n                        i++;\n                        int startTypeVal = i;\n                        while (i < packageName.length() && packageName.charAt(i) >= '0'\n                                && packageName.charAt(i) <= '9') {\n                            i++;\n                        }\n                        if (i > startTypeVal) {\n                            String typeValStr = packageName.substring(startTypeVal, i);\n                            try {\n                                int typeVal = Integer.parseInt(typeValStr);\n                                if (type == 'a') {\n                                    nonpackageUid = UserHandle.getUid(user,\n                                            typeVal + Process.FIRST_APPLICATION_UID);\n                                } else if (type == 's') {\n                                    nonpackageUid = UserHandle.getUid(user, typeVal);\n                                }\n                            } catch (NumberFormatException e) {\n                            }\n                        }\n                    } catch (NumberFormatException e) {\n                    }\n                }\n            }\n            if (nonpackageUid != -1) {\n                packageName = null;\n            } else {\n                packageUid = resolveUid(packageName);\n                if (packageUid < 0) {\n                    packageUid = AppGlobals.getPackageManager().getPackageUid(packageName,\n                            PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);\n                }\n                if (packageUid < 0) {\n                    err.println(\"Error: No UID for \" + packageName + \" in user \" + userId);\n                    return -1;\n                }\n            }\n            return 0;\n        }\n    }\n\n    @Override public void onShellCommand(FileDescriptor in, FileDescriptor out,\n            FileDescriptor err, String[] args, ShellCallback callback,\n            ResultReceiver resultReceiver) {\n        (new Shell(this, this)).exec(this, in, out, err, args, callback, resultReceiver);\n    }\n\n    static void dumpCommandHelp(PrintWriter pw) {\n        pw.println(\"AppOps service (appops) commands:\");\n        pw.println(\"  help\");\n        pw.println(\"    Print this help text.\");\n        pw.println(\"  start [--user <USER_ID>] [--attribution <ATTRIBUTION_TAG>] <PACKAGE | UID> \"\n                + \"<OP> \");\n        pw.println(\"    Starts a given operation for a particular application.\");\n        pw.println(\"  stop [--user <USER_ID>] [--attribution <ATTRIBUTION_TAG>] <PACKAGE | UID> \"\n                + \"<OP> \");\n        pw.println(\"    Stops a given operation for a particular application.\");\n        pw.println(\"  set [--user <USER_ID>] <[--uid] PACKAGE | UID> <OP> <MODE>\");\n        pw.println(\"    Set the mode for a particular application and operation.\");\n        pw.println(\"  get [--user <USER_ID>] [--attribution <ATTRIBUTION_TAG>] <PACKAGE | UID> \"\n                + \"[<OP>]\");\n        pw.println(\"    Return the mode for a particular application and optional operation.\");\n        pw.println(\"  query-op [--user <USER_ID>] <OP> [<MODE>]\");\n        pw.println(\"    Print all packages that currently have the given op in the given mode.\");\n        pw.println(\"  reset [--user <USER_ID>] [<PACKAGE>]\");\n        pw.println(\"    Reset the given application or all applications to default modes.\");\n        pw.println(\"  write-settings\");\n        pw.println(\"    Immediately write pending changes to storage.\");\n        pw.println(\"  read-settings\");\n        pw.println(\"    Read the last written settings, replacing current state in RAM.\");\n        pw.println(\"  options:\");\n        pw.println(\"    <PACKAGE> an Android package name or its UID if prefixed by --uid\");\n        pw.println(\"    <OP>      an AppOps operation.\");\n        pw.println(\"    <MODE>    one of allow, ignore, deny, or default\");\n        pw.println(\"    <USER_ID> the user id under which the package is installed. If --user is\");\n        pw.println(\"              not specified, the current user is assumed.\");\n    }\n\n    static int onShellCommand(Shell shell, String cmd) {\n        if (cmd == null) {\n            return shell.handleDefaultCommands(cmd);\n        }\n        PrintWriter pw = shell.getOutPrintWriter();\n        PrintWriter err = shell.getErrPrintWriter();\n        try {\n            switch (cmd) {\n                case \"set\": {\n                    int res = shell.parseUserPackageOp(true, err);\n                    if (res < 0) {\n                        return res;\n                    }\n                    String modeStr = shell.getNextArg();\n                    if (modeStr == null) {\n                        err.println(\"Error: Mode not specified.\");\n                        return -1;\n                    }\n\n                    final int mode = shell.strModeToMode(modeStr, err);\n                    if (mode < 0) {\n                        return -1;\n                    }\n\n                    if (!shell.targetsUid && shell.packageName != null) {\n                        shell.mInterface.setMode(shell.op, shell.packageUid, shell.packageName,\n                                mode);\n                    } else if (shell.targetsUid && shell.packageName != null) {\n                        try {\n                            final int uid = shell.mInternal.mContext.getPackageManager()\n                                    .getPackageUidAsUser(shell.packageName, shell.userId);\n                            shell.mInterface.setUidMode(shell.op, uid, mode);\n                        } catch (PackageManager.NameNotFoundException e) {\n                            return -1;\n                        }\n                    } else {\n                        shell.mInterface.setUidMode(shell.op, shell.nonpackageUid, mode);\n                    }\n                    return 0;\n                }\n                case \"get\": {\n                    int res = shell.parseUserPackageOp(false, err);\n                    if (res < 0) {\n                        return res;\n                    }\n\n                    List<AppOpsManager.PackageOps> ops = new ArrayList<>();\n                    if (shell.packageName != null) {\n                        // Uid mode overrides package mode, so make sure it's also reported\n                        List<AppOpsManager.PackageOps> r = shell.mInterface.getUidOps(\n                                shell.packageUid,\n                                shell.op != AppOpsManager.OP_NONE ? new int[]{shell.op} : null);\n                        if (r != null) {\n                            ops.addAll(r);\n                        }\n                        r = shell.mInterface.getOpsForPackage(\n                                shell.packageUid, shell.packageName,\n                                shell.op != AppOpsManager.OP_NONE ? new int[]{shell.op} : null);\n                        if (r != null) {\n                            ops.addAll(r);\n                        }\n                    } else {\n                        ops = shell.mInterface.getUidOps(\n                                shell.nonpackageUid,\n                                shell.op != AppOpsManager.OP_NONE ? new int[]{shell.op} : null);\n                    }\n                    if (ops == null || ops.size() <= 0) {\n                        pw.println(\"No operations.\");\n                        if (shell.op > AppOpsManager.OP_NONE && shell.op < AppOpsManager._NUM_OP) {\n                            pw.println(\"Default mode: \" + AppOpsManager.modeToName(\n                                    AppOpsManager.opToDefaultMode(shell.op)));\n                        }\n                        return 0;\n                    }\n                    final long now = System.currentTimeMillis();\n                    for (int i=0; i<ops.size(); i++) {\n                        AppOpsManager.PackageOps packageOps = ops.get(i);\n                        if (packageOps.getPackageName() == null) {\n                            pw.print(\"Uid mode: \");\n                        }\n                        List<AppOpsManager.OpEntry> entries = packageOps.getOps();\n                        for (int j=0; j<entries.size(); j++) {\n                            AppOpsManager.OpEntry ent = entries.get(j);\n                            pw.print(AppOpsManager.opToName(ent.getOp()));\n                            pw.print(\": \");\n                            pw.print(AppOpsManager.modeToName(ent.getMode()));\n                            if (shell.attributionTag == null) {\n                                if (ent.getLastAccessTime(OP_FLAGS_ALL) != -1) {\n                                    pw.print(\"; time=\");\n                                    TimeUtils.formatDuration(\n                                            now - ent.getLastAccessTime(OP_FLAGS_ALL), pw);\n                                    pw.print(\" ago\");\n                                }\n                                if (ent.getLastRejectTime(OP_FLAGS_ALL) != -1) {\n                                    pw.print(\"; rejectTime=\");\n                                    TimeUtils.formatDuration(\n                                            now - ent.getLastRejectTime(OP_FLAGS_ALL), pw);\n                                    pw.print(\" ago\");\n                                }\n                                if (ent.isRunning()) {\n                                    pw.print(\" (running)\");\n                                } else if (ent.getLastDuration(OP_FLAGS_ALL) != -1) {\n                                    pw.print(\"; duration=\");\n                                    TimeUtils.formatDuration(ent.getLastDuration(OP_FLAGS_ALL), pw);\n                                }\n                            } else {\n                                final AppOpsManager.AttributedOpEntry attributionEnt =\n                                        ent.getAttributedOpEntries().get(shell.attributionTag);\n                                if (attributionEnt != null) {\n                                    if (attributionEnt.getLastAccessTime(OP_FLAGS_ALL) != -1) {\n                                        pw.print(\"; time=\");\n                                        TimeUtils.formatDuration(\n                                                now - attributionEnt.getLastAccessTime(\n                                                        OP_FLAGS_ALL), pw);\n                                        pw.print(\" ago\");\n                                    }\n                                    if (attributionEnt.getLastRejectTime(OP_FLAGS_ALL) != -1) {\n                                        pw.print(\"; rejectTime=\");\n                                        TimeUtils.formatDuration(\n                                                now - attributionEnt.getLastRejectTime(\n                                                        OP_FLAGS_ALL), pw);\n                                        pw.print(\" ago\");\n                                    }\n                                    if (attributionEnt.isRunning()) {\n                                        pw.print(\" (running)\");\n                                    } else if (attributionEnt.getLastDuration(OP_FLAGS_ALL)\n                                            != -1) {\n                                        pw.print(\"; duration=\");\n                                        TimeUtils.formatDuration(\n                                                attributionEnt.getLastDuration(OP_FLAGS_ALL), pw);\n                                    }\n                                }\n                            }\n                            pw.println();\n                        }\n                    }\n                    return 0;\n                }\n                case \"query-op\": {\n                    int res = shell.parseUserOpMode(AppOpsManager.MODE_IGNORED, err);\n                    if (res < 0) {\n                        return res;\n                    }\n                    List<AppOpsManager.PackageOps> ops = shell.mInterface.getPackagesForOps(\n                            new int[] {shell.op});\n                    if (ops == null || ops.size() <= 0) {\n                        pw.println(\"No operations.\");\n                        return 0;\n                    }\n                    for (int i=0; i<ops.size(); i++) {\n                        final AppOpsManager.PackageOps pkg = ops.get(i);\n                        boolean hasMatch = false;\n                        final List<AppOpsManager.OpEntry> entries = ops.get(i).getOps();\n                        for (int j=0; j<entries.size(); j++) {\n                            AppOpsManager.OpEntry ent = entries.get(j);\n                            if (ent.getOp() == shell.op && ent.getMode() == shell.mode) {\n                                hasMatch = true;\n                                break;\n                            }\n                        }\n                        if (hasMatch) {\n                            pw.println(pkg.getPackageName());\n                        }\n                    }\n                    return 0;\n                }\n                case \"reset\": {\n                    String packageName = null;\n                    int userId = UserHandle.USER_CURRENT;\n                    for (String argument; (argument = shell.getNextArg()) != null;) {\n                        if (\"--user\".equals(argument)) {\n                            String userStr = shell.getNextArgRequired();\n                            userId = UserHandle.parseUserArg(userStr);\n                        } else {\n                            if (packageName == null) {\n                                packageName = argument;\n                            } else {\n                                err.println(\"Error: Unsupported argument: \" + argument);\n                                return -1;\n                            }\n                        }\n                    }\n\n                    if (userId == UserHandle.USER_CURRENT) {\n                        userId = ActivityManager.getCurrentUser();\n                    }\n\n                    shell.mInterface.resetAllModes(userId, packageName);\n                    pw.print(\"Reset all modes for: \");\n                    if (userId == UserHandle.USER_ALL) {\n                        pw.print(\"all users\");\n                    } else {\n                        pw.print(\"user \"); pw.print(userId);\n                    }\n                    pw.print(\", \");\n                    if (packageName == null) {\n                        pw.println(\"all packages\");\n                    } else {\n                        pw.print(\"package \"); pw.println(packageName);\n                    }\n                    return 0;\n                }\n                case \"write-settings\": {\n                    shell.mInternal.enforceManageAppOpsModes(Binder.getCallingPid(),\n                            Binder.getCallingUid(), -1);\n                    final long token = Binder.clearCallingIdentity();\n                    try {\n                        synchronized (shell.mInternal) {\n                            shell.mInternal.mHandler.removeCallbacks(shell.mInternal.mWriteRunner);\n                        }\n                        shell.mInternal.writeRecentAccesses();\n                        shell.mInternal.mAppOpsCheckingService.writeState();\n                        pw.println(\"Current settings written.\");\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                    return 0;\n                }\n                case \"read-settings\": {\n                    shell.mInternal.enforceManageAppOpsModes(Binder.getCallingPid(),\n                            Binder.getCallingUid(), -1);\n                    final long token = Binder.clearCallingIdentity();\n                    try {\n                        shell.mInternal.readRecentAccesses();\n                        shell.mInternal.mAppOpsCheckingService.readState();\n                        pw.println(\"Last settings read.\");\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                    return 0;\n                }\n                case \"start\": {\n                    int res = shell.parseUserPackageOp(true, err);\n                    if (res < 0) {\n                        return res;\n                    }\n\n                    if (shell.packageName != null) {\n                        shell.mInterface.startOperation(shell.mToken, shell.op, shell.packageUid,\n                                shell.packageName, shell.attributionTag, true, true,\n                                \"appops start shell command\", true,\n                                AppOpsManager.ATTRIBUTION_FLAG_ACCESSOR, ATTRIBUTION_CHAIN_ID_NONE);\n                    } else {\n                        return -1;\n                    }\n                    return 0;\n                }\n                case \"stop\": {\n                    int res = shell.parseUserPackageOp(true, err);\n                    if (res < 0) {\n                        return res;\n                    }\n\n                    if (shell.packageName != null) {\n                        shell.mInterface.finishOperation(shell.mToken, shell.op, shell.packageUid,\n                                shell.packageName, shell.attributionTag);\n                    } else {\n                        return -1;\n                    }\n                    return 0;\n                }\n                default:\n                    return shell.handleDefaultCommands(cmd);\n            }\n        } catch (RemoteException e) {\n            pw.println(\"Remote exception: \" + e);\n        }\n        return -1;\n    }\n\n    private void dumpHelp(PrintWriter pw) {\n        pw.println(\"AppOps service (appops) dump options:\");\n        pw.println(\"  -h\");\n        pw.println(\"    Print this help text.\");\n        pw.println(\"  --op [OP]\");\n        pw.println(\"    Limit output to data associated with the given app op code.\");\n        pw.println(\"  --mode [MODE]\");\n        pw.println(\"    Limit output to data associated with the given app op mode.\");\n        pw.println(\"  --package [PACKAGE]\");\n        pw.println(\"    Limit output to data associated with the given package name.\");\n        pw.println(\"  --attributionTag [attributionTag]\");\n        pw.println(\"    Limit output to data associated with the given attribution tag.\");\n        pw.println(\"  --include-discrete [n]\");\n        pw.println(\"    Include discrete ops limited to n per dimension. Use zero for no limit.\");\n        pw.println(\"  --watchers\");\n        pw.println(\"    Only output the watcher sections.\");\n        pw.println(\"  --history\");\n        pw.println(\"    Only output history.\");\n        pw.println(\"  --uid-state-changes\");\n        pw.println(\"    Include logs about uid state changes.\");\n    }\n\n    private void dumpStatesLocked(@NonNull PrintWriter pw, @Nullable String filterAttributionTag,\n            @HistoricalOpsRequestFilter int filter, long nowElapsed, @NonNull Op op, long now,\n            @NonNull SimpleDateFormat sdf, @NonNull Date date, @NonNull String prefix) {\n        final int numAttributions = op.mAttributions.size();\n        for (int i = 0; i < numAttributions; i++) {\n            if ((filter & FILTER_BY_ATTRIBUTION_TAG) != 0 && !Objects.equals(\n                    op.mAttributions.keyAt(i), filterAttributionTag)) {\n                continue;\n            }\n\n            pw.print(prefix + op.mAttributions.keyAt(i) + \"=[\\n\");\n            dumpStatesLocked(pw, nowElapsed, op, op.mAttributions.keyAt(i), now, sdf, date,\n                    prefix + \"  \");\n            pw.print(prefix + \"]\\n\");\n        }\n    }\n\n    private void dumpStatesLocked(@NonNull PrintWriter pw, long nowElapsed, @NonNull Op op,\n            @Nullable String attributionTag, long now, @NonNull SimpleDateFormat sdf,\n            @NonNull Date date, @NonNull String prefix) {\n\n        final AttributedOpEntry entry = op.createSingleAttributionEntryLocked(\n                attributionTag).getAttributedOpEntries().get(attributionTag);\n\n        final ArraySet<Long> keys = entry.collectKeys();\n\n        final int keyCount = keys.size();\n        for (int k = 0; k < keyCount; k++) {\n            final long key = keys.valueAt(k);\n\n            final int uidState = AppOpsManager.extractUidStateFromKey(key);\n            final int flags = AppOpsManager.extractFlagsFromKey(key);\n\n            final long accessTime = entry.getLastAccessTime(uidState, uidState, flags);\n            final long rejectTime = entry.getLastRejectTime(uidState, uidState, flags);\n            final long accessDuration = entry.getLastDuration(uidState, uidState, flags);\n            final OpEventProxyInfo proxy = entry.getLastProxyInfo(uidState, uidState, flags);\n\n            String proxyPkg = null;\n            String proxyAttributionTag = null;\n            int proxyUid = Process.INVALID_UID;\n            if (proxy != null) {\n                proxyPkg = proxy.getPackageName();\n                proxyAttributionTag = proxy.getAttributionTag();\n                proxyUid = proxy.getUid();\n            }\n\n            if (accessTime > 0) {\n                pw.print(prefix);\n                pw.print(\"Access: \");\n                pw.print(AppOpsManager.keyToString(key));\n                pw.print(\" \");\n                date.setTime(accessTime);\n                pw.print(sdf.format(date));\n                pw.print(\" (\");\n                TimeUtils.formatDuration(accessTime - now, pw);\n                pw.print(\")\");\n                if (accessDuration > 0) {\n                    pw.print(\" duration=\");\n                    TimeUtils.formatDuration(accessDuration, pw);\n                }\n                if (proxyUid >= 0) {\n                    pw.print(\" proxy[\");\n                    pw.print(\"uid=\");\n                    pw.print(proxyUid);\n                    pw.print(\", pkg=\");\n                    pw.print(proxyPkg);\n                    pw.print(\", attributionTag=\");\n                    pw.print(proxyAttributionTag);\n                    pw.print(\"]\");\n                }\n                pw.println();\n            }\n\n            if (rejectTime > 0) {\n                pw.print(prefix);\n                pw.print(\"Reject: \");\n                pw.print(AppOpsManager.keyToString(key));\n                date.setTime(rejectTime);\n                pw.print(sdf.format(date));\n                pw.print(\" (\");\n                TimeUtils.formatDuration(rejectTime - now, pw);\n                pw.print(\")\");\n                if (proxyUid >= 0) {\n                    pw.print(\" proxy[\");\n                    pw.print(\"uid=\");\n                    pw.print(proxyUid);\n                    pw.print(\", pkg=\");\n                    pw.print(proxyPkg);\n                    pw.print(\", attributionTag=\");\n                    pw.print(proxyAttributionTag);\n                    pw.print(\"]\");\n                }\n                pw.println();\n            }\n        }\n\n        final AttributedOp attributedOp = op.mAttributions.get(attributionTag);\n        if (attributedOp.isRunning()) {\n            long earliestElapsedTime = Long.MAX_VALUE;\n            long maxNumStarts = 0;\n            int numInProgressEvents = attributedOp.mInProgressEvents.size();\n            for (int i = 0; i < numInProgressEvents; i++) {\n                AttributedOp.InProgressStartOpEvent event =\n                        attributedOp.mInProgressEvents.valueAt(i);\n\n                earliestElapsedTime = Math.min(earliestElapsedTime, event.getStartElapsedTime());\n                maxNumStarts = Math.max(maxNumStarts, event.mNumUnfinishedStarts);\n            }\n\n            pw.print(prefix + \"Running start at: \");\n            TimeUtils.formatDuration(nowElapsed - earliestElapsedTime, pw);\n            pw.println();\n\n            if (maxNumStarts > 1) {\n                pw.print(prefix + \"startNesting=\");\n                pw.println(maxNumStarts);\n            }\n        }\n    }\n\n    @NeverCompile // Avoid size overhead of debugging code.\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {\n        if (!DumpUtils.checkDumpAndUsageStatsPermission(mContext, TAG, pw)) return;\n\n        int dumpOp = OP_NONE;\n        String dumpPackage = null;\n        String dumpAttributionTag = null;\n        int dumpUid = Process.INVALID_UID;\n        int dumpMode = -1;\n        boolean dumpWatchers = false;\n        // TODO ntmyren: Remove the dumpHistory and dumpFilter\n        boolean dumpHistory = false;\n        boolean includeDiscreteOps = false;\n        boolean dumpUidStateChangeLogs = false;\n        int nDiscreteOps = 10;\n        @HistoricalOpsRequestFilter int dumpFilter = 0;\n        boolean dumpAll = false;\n\n        if (args != null) {\n            for (int i = 0; i < args.length; i++) {\n                String arg = args[i];\n                if (\"-h\".equals(arg)) {\n                    dumpHelp(pw);\n                    return;\n                } else if (\"-a\".equals(arg)) {\n                    // dump all data\n                    dumpAll = true;\n                } else if (\"--op\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --op option\");\n                        return;\n                    }\n                    dumpOp = Shell.strOpToOp(args[i], pw);\n                    dumpFilter |= FILTER_BY_OP_NAMES;\n                    if (dumpOp < 0) {\n                        return;\n                    }\n                } else if (\"--package\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --package option\");\n                        return;\n                    }\n                    dumpPackage = args[i];\n                    dumpFilter |= FILTER_BY_PACKAGE_NAME;\n                    try {\n                        dumpUid = AppGlobals.getPackageManager().getPackageUid(dumpPackage,\n                                PackageManager.MATCH_KNOWN_PACKAGES | PackageManager.MATCH_INSTANT,\n                                0);\n                    } catch (RemoteException e) {\n                    }\n                    if (dumpUid < 0) {\n                        pw.println(\"Unknown package: \" + dumpPackage);\n                        return;\n                    }\n                    dumpUid = UserHandle.getAppId(dumpUid);\n                    dumpFilter |= FILTER_BY_UID;\n                } else if (\"--attributionTag\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --attributionTag option\");\n                        return;\n                    }\n                    dumpAttributionTag = args[i];\n                    dumpFilter |= FILTER_BY_ATTRIBUTION_TAG;\n                } else if (\"--mode\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --mode option\");\n                        return;\n                    }\n                    dumpMode = Shell.strModeToMode(args[i], pw);\n                    if (dumpMode < 0) {\n                        return;\n                    }\n                } else if (\"--watchers\".equals(arg)) {\n                    dumpWatchers = true;\n                } else if (\"--include-discrete\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --include-discrete option\");\n                        return;\n                    }\n                    try {\n                        nDiscreteOps = Integer.valueOf(args[i]);\n                    } catch (NumberFormatException e) {\n                        pw.println(\"Wrong parameter: \" + args[i]);\n                        return;\n                    }\n                    includeDiscreteOps = true;\n                } else if (\"--history\".equals(arg)) {\n                    dumpHistory = true;\n                } else if (arg.length() > 0 && arg.charAt(0) == '-') {\n                    pw.println(\"Unknown option: \" + arg);\n                    return;\n                } else if (\"--uid-state-changes\".equals(arg)) {\n                    dumpUidStateChangeLogs = true;\n                } else {\n                    pw.println(\"Unknown command: \" + arg);\n                    return;\n                }\n            }\n        }\n\n        final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\");\n        final Date date = new Date();\n        synchronized (this) {\n            pw.println(\"Current AppOps Service state:\");\n            if (!dumpHistory && !dumpWatchers) {\n                mConstants.dump(pw);\n            }\n            pw.println();\n            final long now = System.currentTimeMillis();\n            final long nowElapsed = SystemClock.elapsedRealtime();\n            final long nowUptime = SystemClock.uptimeMillis();\n            boolean needSep = false;\n            if (dumpFilter == 0 && dumpMode < 0 && mProfileOwners != null && !dumpWatchers\n                    && !dumpHistory) {\n                pw.println(\"  Profile owners:\");\n                for (int poi = 0; poi < mProfileOwners.size(); poi++) {\n                    pw.print(\"    User #\");\n                    pw.print(mProfileOwners.keyAt(poi));\n                    pw.print(\": \");\n                    UserHandle.formatUid(pw, mProfileOwners.valueAt(poi));\n                    pw.println();\n                }\n                pw.println();\n            }\n\n            if (!dumpHistory) {\n                needSep |= mAppOpsCheckingService.dumpListeners(dumpOp, dumpUid, dumpPackage, pw);\n            }\n\n            if (mModeWatchers.size() > 0 && dumpOp < 0 && !dumpHistory) {\n                boolean printedHeader = false;\n                for (int i = 0; i < mModeWatchers.size(); i++) {\n                    final ModeCallback cb = mModeWatchers.valueAt(i);\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.getWatchingUid())) {\n                        continue;\n                    }\n                    needSep = true;\n                    if (!printedHeader) {\n                        pw.println(\"  All op mode watchers:\");\n                        printedHeader = true;\n                    }\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(mModeWatchers.keyAt(i))));\n                    pw.print(\": \"); pw.println(cb);\n                }\n            }\n            if (mActiveWatchers.size() > 0 && dumpMode < 0) {\n                needSep = true;\n                boolean printedHeader = false;\n                for (int watcherNum = 0; watcherNum < mActiveWatchers.size(); watcherNum++) {\n                    final SparseArray<ActiveCallback> activeWatchers =\n                            mActiveWatchers.valueAt(watcherNum);\n                    if (activeWatchers.size() <= 0) {\n                        continue;\n                    }\n                    final ActiveCallback cb = activeWatchers.valueAt(0);\n                    if (dumpOp >= 0 && activeWatchers.indexOfKey(dumpOp) < 0) {\n                        continue;\n                    }\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.mWatchingUid)) {\n                        continue;\n                    }\n                    if (!printedHeader) {\n                        pw.println(\"  All op active watchers:\");\n                        printedHeader = true;\n                    }\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(\n                            mActiveWatchers.keyAt(watcherNum))));\n                    pw.println(\" ->\");\n                    pw.print(\"        [\");\n                    final int opCount = activeWatchers.size();\n                    for (int opNum = 0; opNum < opCount; opNum++) {\n                        if (opNum > 0) {\n                            pw.print(' ');\n                        }\n                        pw.print(AppOpsManager.opToName(activeWatchers.keyAt(opNum)));\n                        if (opNum < opCount - 1) {\n                            pw.print(',');\n                        }\n                    }\n                    pw.println(\"]\");\n                    pw.print(\"        \");\n                    pw.println(cb);\n                }\n            }\n            if (mStartedWatchers.size() > 0 && dumpMode < 0) {\n                needSep = true;\n                boolean printedHeader = false;\n\n                final int watchersSize = mStartedWatchers.size();\n                for (int watcherNum = 0; watcherNum < watchersSize; watcherNum++) {\n                    final SparseArray<StartedCallback> startedWatchers =\n                            mStartedWatchers.valueAt(watcherNum);\n                    if (startedWatchers.size() <= 0) {\n                        continue;\n                    }\n\n                    final StartedCallback cb = startedWatchers.valueAt(0);\n                    if (dumpOp >= 0 && startedWatchers.indexOfKey(dumpOp) < 0) {\n                        continue;\n                    }\n\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.mWatchingUid)) {\n                        continue;\n                    }\n\n                    if (!printedHeader) {\n                        pw.println(\"  All op started watchers:\");\n                        printedHeader = true;\n                    }\n\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(\n                            mStartedWatchers.keyAt(watcherNum))));\n                    pw.println(\" ->\");\n\n                    pw.print(\"        [\");\n                    final int opCount = startedWatchers.size();\n                    for (int opNum = 0; opNum < opCount; opNum++) {\n                        if (opNum > 0) {\n                            pw.print(' ');\n                        }\n\n                        pw.print(AppOpsManager.opToName(startedWatchers.keyAt(opNum)));\n                        if (opNum < opCount - 1) {\n                            pw.print(',');\n                        }\n                    }\n                    pw.println(\"]\");\n\n                    pw.print(\"        \");\n                    pw.println(cb);\n                }\n            }\n            if (mNotedWatchers.size() > 0 && dumpMode < 0) {\n                needSep = true;\n                boolean printedHeader = false;\n                for (int watcherNum = 0; watcherNum < mNotedWatchers.size(); watcherNum++) {\n                    final SparseArray<NotedCallback> notedWatchers =\n                            mNotedWatchers.valueAt(watcherNum);\n                    if (notedWatchers.size() <= 0) {\n                        continue;\n                    }\n                    final NotedCallback cb = notedWatchers.valueAt(0);\n                    if (dumpOp >= 0 && notedWatchers.indexOfKey(dumpOp) < 0) {\n                        continue;\n                    }\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.mWatchingUid)) {\n                        continue;\n                    }\n                    if (!printedHeader) {\n                        pw.println(\"  All op noted watchers:\");\n                        printedHeader = true;\n                    }\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(\n                            mNotedWatchers.keyAt(watcherNum))));\n                    pw.println(\" ->\");\n                    pw.print(\"        [\");\n                    final int opCount = notedWatchers.size();\n                    for (int opNum = 0; opNum < opCount; opNum++) {\n                        if (opNum > 0) {\n                            pw.print(' ');\n                        }\n                        pw.print(AppOpsManager.opToName(notedWatchers.keyAt(opNum)));\n                        if (opNum < opCount - 1) {\n                            pw.print(',');\n                        }\n                    }\n                    pw.println(\"]\");\n                    pw.print(\"        \");\n                    pw.println(cb);\n                }\n            }\n            if (mAudioRestrictionManager.hasActiveRestrictions() && dumpOp < 0\n                    && dumpPackage != null && dumpMode < 0 && !dumpWatchers) {\n                needSep = mAudioRestrictionManager.dump(pw) || needSep;\n            }\n            if (needSep) {\n                pw.println();\n            }\n            for (int i=0; i<mUidStates.size(); i++) {\n                UidState uidState = mUidStates.valueAt(i);\n                final SparseIntArray opModes = uidState.getNonDefaultUidModes();\n                final ArrayMap<String, Ops> pkgOps = uidState.pkgOps;\n\n                if (dumpWatchers || dumpHistory) {\n                    continue;\n                }\n                if (dumpOp >= 0 || dumpPackage != null || dumpMode >= 0) {\n                    boolean hasOp = dumpOp < 0 || (opModes != null\n                            && opModes.indexOfKey(dumpOp) >= 0);\n                    boolean hasPackage = dumpPackage == null || dumpUid == mUidStates.keyAt(i);\n                    boolean hasMode = dumpMode < 0;\n                    if (!hasMode && opModes != null) {\n                        for (int opi = 0; !hasMode && opi < opModes.size(); opi++) {\n                            if (opModes.valueAt(opi) == dumpMode) {\n                                hasMode = true;\n                            }\n                        }\n                    }\n                    if (pkgOps != null) {\n                        for (int pkgi = 0;\n                                 (!hasOp || !hasPackage || !hasMode) && pkgi < pkgOps.size();\n                                 pkgi++) {\n                            Ops ops = pkgOps.valueAt(pkgi);\n                            if (!hasOp && ops != null && ops.indexOfKey(dumpOp) >= 0) {\n                                hasOp = true;\n                            }\n                            if (!hasMode) {\n                                for (int opi = 0; !hasMode && opi < ops.size(); opi++) {\n                                    if (ops.valueAt(opi).getMode() == dumpMode) {\n                                        hasMode = true;\n                                    }\n                                }\n                            }\n                            if (!hasPackage && dumpPackage.equals(ops.packageName)) {\n                                hasPackage = true;\n                            }\n                        }\n                    }\n                    if (uidState.foregroundOps != null && !hasOp) {\n                        if (uidState.foregroundOps.indexOfKey(dumpOp) > 0) {\n                            hasOp = true;\n                        }\n                    }\n                    if (!hasOp || !hasPackage || !hasMode) {\n                        continue;\n                    }\n                }\n\n                pw.print(\"  Uid \"); UserHandle.formatUid(pw, uidState.uid); pw.println(\":\");\n                uidState.dump(pw, nowElapsed);\n                if (uidState.foregroundOps != null && (dumpMode < 0\n                        || dumpMode == AppOpsManager.MODE_FOREGROUND)) {\n                    pw.println(\"    foregroundOps:\");\n                    for (int j = 0; j < uidState.foregroundOps.size(); j++) {\n                        if (dumpOp >= 0 && dumpOp != uidState.foregroundOps.keyAt(j)) {\n                            continue;\n                        }\n                        pw.print(\"      \");\n                        pw.print(AppOpsManager.opToName(uidState.foregroundOps.keyAt(j)));\n                        pw.print(\": \");\n                        pw.println(uidState.foregroundOps.valueAt(j) ? \"WATCHER\" : \"SILENT\");\n                    }\n                    pw.print(\"    hasForegroundWatchers=\");\n                    pw.println(uidState.hasForegroundWatchers);\n                }\n                needSep = true;\n\n                if (opModes != null) {\n                    final int opModeCount = opModes.size();\n                    for (int j = 0; j < opModeCount; j++) {\n                        final int code = opModes.keyAt(j);\n                        final int mode = opModes.valueAt(j);\n                        if (dumpOp >= 0 && dumpOp != code) {\n                            continue;\n                        }\n                        if (dumpMode >= 0 && dumpMode != mode) {\n                            continue;\n                        }\n                        pw.print(\"      \"); pw.print(AppOpsManager.opToName(code));\n                        pw.print(\": mode=\"); pw.println(AppOpsManager.modeToName(mode));\n                    }\n                }\n\n                if (pkgOps == null) {\n                    continue;\n                }\n\n                for (int pkgi = 0; pkgi < pkgOps.size(); pkgi++) {\n                    final Ops ops = pkgOps.valueAt(pkgi);\n                    if (dumpPackage != null && !dumpPackage.equals(ops.packageName)) {\n                        continue;\n                    }\n                    boolean printedPackage = false;\n                    for (int j=0; j<ops.size(); j++) {\n                        final Op op = ops.valueAt(j);\n                        final int opCode = op.op;\n                        if (dumpOp >= 0 && dumpOp != opCode) {\n                            continue;\n                        }\n                        if (dumpMode >= 0 && dumpMode != op.getMode()) {\n                            continue;\n                        }\n                        if (!printedPackage) {\n                            pw.print(\"    Package \"); pw.print(ops.packageName); pw.println(\":\");\n                            printedPackage = true;\n                        }\n                        pw.print(\"      \"); pw.print(AppOpsManager.opToName(opCode));\n                        pw.print(\" (\"); pw.print(AppOpsManager.modeToName(op.getMode()));\n                        final int switchOp = AppOpsManager.opToSwitch(opCode);\n                        if (switchOp != opCode) {\n                            pw.print(\" / switch \");\n                            pw.print(AppOpsManager.opToName(switchOp));\n                            final Op switchObj = ops.get(switchOp);\n                            int mode = switchObj == null\n                                    ? AppOpsManager.opToDefaultMode(switchOp) : switchObj.getMode();\n                            pw.print(\"=\"); pw.print(AppOpsManager.modeToName(mode));\n                        }\n                        pw.println(\"): \");\n                        dumpStatesLocked(pw, dumpAttributionTag, dumpFilter, nowElapsed, op, now,\n                                sdf, date, \"        \");\n                    }\n                }\n            }\n            if (needSep) {\n                pw.println();\n            }\n\n            boolean showUserRestrictions = !(dumpMode < 0 && !dumpWatchers && !dumpHistory);\n            mAppOpsRestrictions.dumpRestrictions(pw, dumpOp, dumpPackage, showUserRestrictions);\n\n            if (!dumpHistory && !dumpWatchers) {\n                pw.println();\n                if (mCheckOpsDelegateDispatcher.mPolicy != null\n                        && mCheckOpsDelegateDispatcher.mPolicy instanceof AppOpsPolicy) {\n                    AppOpsPolicy policy = (AppOpsPolicy) mCheckOpsDelegateDispatcher.mPolicy;\n                    policy.dumpTags(pw);\n                } else {\n                    pw.println(\"  AppOps policy not set.\");\n                }\n            }\n\n            if (dumpAll || dumpUidStateChangeLogs) {\n                pw.println();\n                pw.println(\"Uid State Changes Event Log:\");\n                getUidStateTracker().dumpEvents(pw);\n            }\n        }\n\n        // Must not hold the appops lock\n        if (dumpHistory && !dumpWatchers) {\n            mHistoricalRegistry.dump(\"  \", pw, dumpUid, dumpPackage, dumpAttributionTag, dumpOp,\n                    dumpFilter);\n        }\n        if (includeDiscreteOps) {\n            pw.println(\"Discrete accesses: \");\n            mHistoricalRegistry.dumpDiscreteData(pw, dumpUid, dumpPackage, dumpAttributionTag,\n                    dumpFilter, dumpOp, sdf, date, \"  \", nDiscreteOps);\n        }\n    }\n\n    @Override\n    public void setUserRestrictions(Bundle restrictions, IBinder token, int userHandle) {\n        checkSystemUid(\"setUserRestrictions\");\n        Objects.requireNonNull(restrictions);\n        Objects.requireNonNull(token);\n        for (int i = 0; i < AppOpsManager._NUM_OP; i++) {\n            String restriction = AppOpsManager.opToRestriction(i);\n            if (restriction != null) {\n                setUserRestrictionNoCheck(i, restrictions.getBoolean(restriction, false), token,\n                        userHandle, null);\n            }\n        }\n    }\n\n    @Override\n    public void setUserRestriction(int code, boolean restricted, IBinder token, int userHandle,\n            PackageTagsList excludedPackageTags) {\n        if (Binder.getCallingPid() != Process.myPid()) {\n            mContext.enforcePermission(Manifest.permission.MANAGE_APP_OPS_RESTRICTIONS,\n                    Binder.getCallingPid(), Binder.getCallingUid(), null);\n        }\n        if (userHandle != UserHandle.getCallingUserId()) {\n            if (mContext.checkCallingOrSelfPermission(Manifest.permission\n                    .INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED\n                && mContext.checkCallingOrSelfPermission(Manifest.permission\n                    .INTERACT_ACROSS_USERS) != PackageManager.PERMISSION_GRANTED) {\n                throw new SecurityException(\"Need INTERACT_ACROSS_USERS_FULL or\"\n                        + \" INTERACT_ACROSS_USERS to interact cross user \");\n            }\n        }\n        verifyIncomingOp(code);\n        Objects.requireNonNull(token);\n        setUserRestrictionNoCheck(code, restricted, token, userHandle, excludedPackageTags);\n    }\n\n    private void setUserRestrictionNoCheck(int code, boolean restricted, IBinder token,\n            int userHandle, PackageTagsList excludedPackageTags) {\n        synchronized (AppOpsService.this) {\n            ClientUserRestrictionState restrictionState = mOpUserRestrictions.get(token);\n\n            if (restrictionState == null) {\n                try {\n                    restrictionState = new ClientUserRestrictionState(token);\n                } catch (RemoteException e) {\n                    return;\n                }\n                mOpUserRestrictions.put(token, restrictionState);\n            }\n\n            if (restrictionState.setRestriction(code, restricted, excludedPackageTags,\n                    userHandle)) {\n                mHandler.sendMessage(PooledLambda.obtainMessage(\n                        AppOpsService::notifyWatchersOfChange, this, code, UID_ANY));\n                mHandler.sendMessage(PooledLambda.obtainMessage(\n                        AppOpsService::updateStartedOpModeForUser, this, code, restricted,\n                        userHandle));\n            }\n\n            if (restrictionState.isDefault()) {\n                mOpUserRestrictions.remove(token);\n                restrictionState.destroy();\n            }\n        }\n    }\n\n    private void updateStartedOpModeForUser(int code, boolean restricted, int userId) {\n        synchronized (AppOpsService.this) {\n            int numUids = mUidStates.size();\n            for (int uidNum = 0; uidNum < numUids; uidNum++) {\n                int uid = mUidStates.keyAt(uidNum);\n                if (userId != UserHandle.USER_ALL && UserHandle.getUserId(uid) != userId) {\n                    continue;\n                }\n                updateStartedOpModeForUidLocked(code, restricted, uid);\n            }\n        }\n    }\n\n    private void updateStartedOpModeForUidLocked(int code, boolean restricted, int uid) {\n        UidState uidState = mUidStates.get(uid);\n        if (uidState == null) {\n            return;\n        }\n\n        int numPkgOps = uidState.pkgOps.size();\n        for (int pkgNum = 0; pkgNum < numPkgOps; pkgNum++) {\n            Ops ops = uidState.pkgOps.valueAt(pkgNum);\n            Op op = ops != null ? ops.get(code) : null;\n            if (op == null || (op.getMode() != MODE_ALLOWED && op.getMode() != MODE_FOREGROUND)) {\n                continue;\n            }\n            int numAttrTags = op.mAttributions.size();\n            for (int attrNum = 0; attrNum < numAttrTags; attrNum++) {\n                AttributedOp attrOp = op.mAttributions.valueAt(attrNum);\n                if (restricted && attrOp.isRunning()) {\n                    attrOp.pause();\n                } else if (attrOp.isPaused()) {\n                    attrOp.resume();\n                }\n            }\n        }\n    }\n\n    private void notifyWatchersOfChange(int code, int uid) {\n        final ArraySet<OnOpModeChangedListener> modeChangedListenerSet;\n        synchronized (this) {\n            modeChangedListenerSet = mAppOpsCheckingService.getOpModeChangedListeners(code);\n            if (modeChangedListenerSet == null) {\n                return;\n            }\n        }\n\n        notifyOpChanged(modeChangedListenerSet,  code, uid, null);\n    }\n\n    @Override\n    public void removeUser(int userHandle) throws RemoteException {\n        checkSystemUid(\"removeUser\");\n        synchronized (AppOpsService.this) {\n            final int tokenCount = mOpUserRestrictions.size();\n            for (int i = tokenCount - 1; i >= 0; i--) {\n                ClientUserRestrictionState opRestrictions = mOpUserRestrictions.valueAt(i);\n                opRestrictions.removeUser(userHandle);\n            }\n            removeUidsForUserLocked(userHandle);\n        }\n    }\n\n    @Override\n    public boolean isOperationActive(int code, int uid, String packageName) {\n        if (Binder.getCallingUid() != uid) {\n            if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                    != PackageManager.PERMISSION_GRANTED) {\n                return false;\n            }\n        }\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return false;\n        }\n\n        final String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return false;\n        }\n        // TODO moltmann: Allow to check for attribution op activeness\n        synchronized (AppOpsService.this) {\n            Ops pkgOps = getOpsLocked(uid, resolvedPackageName, null, false, null, false);\n            if (pkgOps == null) {\n                return false;\n            }\n\n            Op op = pkgOps.get(code);\n            if (op == null) {\n                return false;\n            }\n\n            return op.isRunning();\n        }\n    }\n\n    @Override\n    public boolean isProxying(int op, @NonNull String proxyPackageName,\n            @NonNull String proxyAttributionTag, int proxiedUid,\n            @NonNull String proxiedPackageName) {\n        Objects.requireNonNull(proxyPackageName);\n        Objects.requireNonNull(proxiedPackageName);\n        final long callingUid = Binder.getCallingUid();\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final List<AppOpsManager.PackageOps> packageOps = getOpsForPackage(proxiedUid,\n                    proxiedPackageName, new int[] {op});\n            if (packageOps == null || packageOps.isEmpty()) {\n                return false;\n            }\n            final List<OpEntry> opEntries = packageOps.get(0).getOps();\n            if (opEntries.isEmpty()) {\n                return false;\n            }\n            final OpEntry opEntry = opEntries.get(0);\n            if (!opEntry.isRunning()) {\n                return false;\n            }\n            final OpEventProxyInfo proxyInfo = opEntry.getLastProxyInfo(\n                    OP_FLAG_TRUSTED_PROXIED | AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED);\n            return proxyInfo != null && callingUid == proxyInfo.getUid()\n                    && proxyPackageName.equals(proxyInfo.getPackageName())\n                    && Objects.equals(proxyAttributionTag, proxyInfo.getAttributionTag());\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    @Override\n    public void resetPackageOpsNoHistory(@NonNull String packageName) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"resetPackageOpsNoHistory\");\n        synchronized (AppOpsService.this) {\n            final int uid = mPackageManagerInternal.getPackageUid(packageName, 0,\n                    UserHandle.getCallingUserId());\n            if (uid == Process.INVALID_UID) {\n                return;\n            }\n            UidState uidState = mUidStates.get(uid);\n            if (uidState == null) {\n                return;\n            }\n            Ops removedOps = uidState.pkgOps.remove(packageName);\n            mAppOpsCheckingService.removePackage(packageName, UserHandle.getUserId(uid));\n            if (removedOps != null) {\n                scheduleFastWriteLocked();\n            }\n        }\n    }\n\n    @Override\n    public void setHistoryParameters(@AppOpsManager.HistoricalMode int mode,\n            long baseSnapshotInterval, int compressionStep) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"setHistoryParameters\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.setHistoryParameters(mode, baseSnapshotInterval, compressionStep);\n    }\n\n    @Override\n    public void offsetHistory(long offsetMillis) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"offsetHistory\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.offsetHistory(offsetMillis);\n        mHistoricalRegistry.offsetDiscreteHistory(offsetMillis);\n    }\n\n    @Override\n    public void addHistoricalOps(HistoricalOps ops) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"addHistoricalOps\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.addHistoricalOps(ops);\n    }\n\n    @Override\n    public void resetHistoryParameters() {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"resetHistoryParameters\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.resetHistoryParameters();\n    }\n\n    @Override\n    public void clearHistory() {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"clearHistory\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.clearAllHistory();\n    }\n\n    @Override\n    public void rebootHistory(long offlineDurationMillis) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"rebootHistory\");\n\n        Preconditions.checkArgument(offlineDurationMillis >= 0);\n\n        // Must not hold the appops lock\n        mHistoricalRegistry.shutdown();\n\n        if (offlineDurationMillis > 0) {\n            SystemClock.sleep(offlineDurationMillis);\n        }\n\n        mHistoricalRegistry = new HistoricalRegistry(mHistoricalRegistry);\n        mHistoricalRegistry.systemReady(mContext.getContentResolver());\n        mHistoricalRegistry.persistPendingHistory();\n    }\n\n    /**\n     * Report runtime access to AppOp together with message (including stack trace)\n     *\n     * @param packageName The package which reported the op\n     * @param notedAppOp contains code of op and attributionTag provided by developer\n     * @param message Message describing AppOp access (can be stack trace)\n     *\n     * @return Config for future sampling to reduce amount of reporting\n     */\n    @Override\n    public MessageSamplingConfig reportRuntimeAppOpAccessMessageAndGetConfig(\n            String packageName, SyncNotedAppOp notedAppOp, String message) {\n        int uid = Binder.getCallingUid();\n        Objects.requireNonNull(packageName);\n        synchronized (this) {\n            switchPackageIfBootTimeOrRarelyUsedLocked(packageName);\n            if (!packageName.equals(mSampledPackage)) {\n                return new MessageSamplingConfig(OP_NONE, 0,\n                        Instant.now().plus(1, ChronoUnit.HOURS).toEpochMilli());\n            }\n\n            Objects.requireNonNull(notedAppOp);\n            Objects.requireNonNull(message);\n\n            reportRuntimeAppOpAccessMessageInternalLocked(uid, packageName,\n                    AppOpsManager.strOpToOp(notedAppOp.getOp()),\n                    notedAppOp.getAttributionTag(), message);\n\n            return new MessageSamplingConfig(mSampledAppOpCode, mAcceptableLeftDistance,\n                    Instant.now().plus(1, ChronoUnit.HOURS).toEpochMilli());\n        }\n    }\n\n    /**\n     * Report runtime access to AppOp together with message (entry point for reporting\n     * asynchronous access)\n     * @param uid Uid of the package which reported the op\n     * @param packageName The package which reported the op\n     * @param opCode Code of AppOp\n     * @param attributionTag FeautreId of AppOp reported\n     * @param message Message describing AppOp access (can be stack trace)\n     */\n    private void reportRuntimeAppOpAccessMessageAsyncLocked(int uid,\n            @NonNull String packageName, int opCode, @Nullable String attributionTag,\n            @NonNull String message) {\n        switchPackageIfBootTimeOrRarelyUsedLocked(packageName);\n        if (!Objects.equals(mSampledPackage, packageName)) {\n            return;\n        }\n        reportRuntimeAppOpAccessMessageInternalLocked(uid, packageName, opCode, attributionTag,\n                message);\n    }\n\n    /**\n     * Decides whether reported message is within the range of watched AppOps and picks it for\n     * reporting uniformly at random across all received messages.\n     */\n    private void reportRuntimeAppOpAccessMessageInternalLocked(int uid,\n            @NonNull String packageName, int opCode, @Nullable String attributionTag,\n            @NonNull String message) {\n        int newLeftDistance = AppOpsManager.leftCircularDistance(opCode,\n                mSampledAppOpCode, _NUM_OP);\n\n        if (mAcceptableLeftDistance < newLeftDistance\n                && mSamplingStrategy != SAMPLING_STRATEGY_UNIFORM_OPS) {\n            return;\n        }\n\n        if (mAcceptableLeftDistance > newLeftDistance\n                && mSamplingStrategy != SAMPLING_STRATEGY_UNIFORM_OPS) {\n            mAcceptableLeftDistance = newLeftDistance;\n            mMessagesCollectedCount = 0.0f;\n        }\n\n        mMessagesCollectedCount += 1.0f;\n        if (ThreadLocalRandom.current().nextFloat() <= 1.0f / mMessagesCollectedCount) {\n            mCollectedRuntimePermissionMessage = new RuntimeAppOpAccessMessage(uid, opCode,\n                    packageName, attributionTag, message, mSamplingStrategy);\n        }\n        return;\n    }\n\n    /** Pulls current AppOps access report and resamples package and app op to watch */\n    @Override\n    public @Nullable RuntimeAppOpAccessMessage collectRuntimeAppOpAccessMessage() {\n        ActivityManagerInternal ami = LocalServices.getService(ActivityManagerInternal.class);\n        boolean isCallerInstrumented =\n                ami.getInstrumentationSourceUid(Binder.getCallingUid()) != Process.INVALID_UID;\n        boolean isCallerSystem = Binder.getCallingPid() == Process.myPid();\n        if (!isCallerSystem && !isCallerInstrumented) {\n            return null;\n        }\n        mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n        RuntimeAppOpAccessMessage result;\n        synchronized (this) {\n            result = mCollectedRuntimePermissionMessage;\n            mCollectedRuntimePermissionMessage = null;\n        }\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::getPackageListAndResample,\n                this));\n        return result;\n    }\n\n    /**\n     * Checks if package is in the list of rarely used package and starts watching the new package\n     * to collect incoming message or if collection is happening in first minutes since boot.\n     * @param packageName\n     */\n    private void switchPackageIfBootTimeOrRarelyUsedLocked(@NonNull String packageName) {\n        if (mSampledPackage == null) {\n            if (ThreadLocalRandom.current().nextFloat() < 0.5f) {\n                mSamplingStrategy = SAMPLING_STRATEGY_BOOT_TIME_SAMPLING;\n                resampleAppOpForPackageLocked(packageName, true);\n            }\n        } else if (mRarelyUsedPackages.contains(packageName)) {\n            mRarelyUsedPackages.remove(packageName);\n            if (ThreadLocalRandom.current().nextFloat() < 0.5f) {\n                mSamplingStrategy = SAMPLING_STRATEGY_RARELY_USED;\n                resampleAppOpForPackageLocked(packageName, true);\n            }\n        }\n    }\n\n    /** Obtains package list and resamples package and appop to watch. */\n    private List<String> getPackageListAndResample() {\n        List<String> packageNames = getPackageNamesForSampling();\n        synchronized (this) {\n            resamplePackageAndAppOpLocked(packageNames);\n        }\n        return packageNames;\n    }\n\n    /** Resamples package and appop to watch from the list provided. */\n    private void resamplePackageAndAppOpLocked(@NonNull List<String> packageNames) {\n        if (!packageNames.isEmpty()) {\n            if (ThreadLocalRandom.current().nextFloat() < 0.5f) {\n                mSamplingStrategy = SAMPLING_STRATEGY_UNIFORM;\n                resampleAppOpForPackageLocked(packageNames.get(\n                        ThreadLocalRandom.current().nextInt(packageNames.size())), true);\n            } else {\n                mSamplingStrategy = SAMPLING_STRATEGY_UNIFORM_OPS;\n                resampleAppOpForPackageLocked(packageNames.get(\n                        ThreadLocalRandom.current().nextInt(packageNames.size())), false);\n            }\n        }\n    }\n\n    /** Resamples appop for the chosen package and initializes sampling state */\n    private void resampleAppOpForPackageLocked(@NonNull String packageName, boolean pickOp) {\n        mMessagesCollectedCount = 0.0f;\n        mSampledAppOpCode = pickOp ? ThreadLocalRandom.current().nextInt(_NUM_OP) : OP_NONE;\n        mAcceptableLeftDistance = _NUM_OP - 1;\n        mSampledPackage = packageName;\n    }\n\n    /**\n     * Creates list of rarely used packages - packages which were not used over last week or\n     * which declared but did not use permissions over last week.\n     *  */\n    private void initializeRarelyUsedPackagesList(@NonNull ArraySet<String> candidates) {\n        AppOpsManager appOps = mContext.getSystemService(AppOpsManager.class);\n        List<String> runtimeAppOpsList = getRuntimeAppOpsList();\n        AppOpsManager.HistoricalOpsRequest histOpsRequest =\n                new AppOpsManager.HistoricalOpsRequest.Builder(\n                        Math.max(Instant.now().minus(7, ChronoUnit.DAYS).toEpochMilli(), 0),\n                        Long.MAX_VALUE).setOpNames(runtimeAppOpsList).setFlags(\n                        OP_FLAG_SELF | OP_FLAG_TRUSTED_PROXIED).build();\n        appOps.getHistoricalOps(histOpsRequest, AsyncTask.THREAD_POOL_EXECUTOR,\n                new Consumer<HistoricalOps>() {\n                    @Override\n                    public void accept(HistoricalOps histOps) {\n                        int uidCount = histOps.getUidCount();\n                        for (int uidIdx = 0; uidIdx < uidCount; uidIdx++) {\n                            final AppOpsManager.HistoricalUidOps uidOps = histOps.getUidOpsAt(\n                                    uidIdx);\n                            int pkgCount = uidOps.getPackageCount();\n                            for (int pkgIdx = 0; pkgIdx < pkgCount; pkgIdx++) {\n                                String packageName = uidOps.getPackageOpsAt(\n                                        pkgIdx).getPackageName();\n                                if (!candidates.contains(packageName)) {\n                                    continue;\n                                }\n                                AppOpsManager.HistoricalPackageOps packageOps =\n                                        uidOps.getPackageOpsAt(pkgIdx);\n                                if (packageOps.getOpCount() != 0) {\n                                    candidates.remove(packageName);\n                                }\n                            }\n                        }\n                        synchronized (this) {\n                            int numPkgs = mRarelyUsedPackages.size();\n                            for (int i = 0; i < numPkgs; i++) {\n                                candidates.add(mRarelyUsedPackages.valueAt(i));\n                            }\n                            mRarelyUsedPackages = candidates;\n                        }\n                    }\n                });\n    }\n\n    /** List of app ops related to runtime permissions */\n    private List<String> getRuntimeAppOpsList() {\n        ArrayList<String> result = new ArrayList();\n        for (int i = 0; i < _NUM_OP; i++) {\n            if (shouldCollectNotes(i)) {\n                result.add(opToPublicName(i));\n            }\n        }\n        return result;\n    }\n\n    /** Returns list of packages to be used for package sampling */\n    private @NonNull List<String> getPackageNamesForSampling() {\n        List<String> packageNames = new ArrayList<>();\n        PackageManagerInternal packageManagerInternal = LocalServices.getService(\n                PackageManagerInternal.class);\n        PackageList packages = packageManagerInternal.getPackageList();\n        for (String packageName : packages.getPackageNames()) {\n            PackageInfo pkg = packageManagerInternal.getPackageInfo(packageName,\n                    PackageManager.GET_PERMISSIONS, Process.myUid(), mContext.getUserId());\n            if (isSamplingTarget(pkg)) {\n                packageNames.add(pkg.packageName);\n            }\n        }\n        return packageNames;\n    }\n\n    /** Checks whether package should be included in sampling pool */\n    private boolean isSamplingTarget(@Nullable PackageInfo pkg) {\n        if (pkg == null) {\n            return false;\n        }\n        String[] requestedPermissions = pkg.requestedPermissions;\n        if (requestedPermissions == null) {\n            return false;\n        }\n        for (String permission : requestedPermissions) {\n            PermissionInfo permissionInfo;\n            try {\n                permissionInfo = mContext.getPackageManager().getPermissionInfo(permission, 0);\n            } catch (PackageManager.NameNotFoundException ignored) {\n                continue;\n            }\n            if (permissionInfo.getProtection() == PROTECTION_DANGEROUS) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @GuardedBy(\"this\")\n    private void removeUidsForUserLocked(int userHandle) {\n        for (int i = mUidStates.size() - 1; i >= 0; --i) {\n            final int uid = mUidStates.keyAt(i);\n            if (UserHandle.getUserId(uid) == userHandle) {\n                mUidStates.valueAt(i).clear();\n                mUidStates.removeAt(i);\n            }\n        }\n    }\n\n    private void checkSystemUid(String function) {\n        int uid = Binder.getCallingUid();\n        if (uid != Process.SYSTEM_UID) {\n            throw new SecurityException(function + \" must by called by the system\");\n        }\n    }\n\n    private static int resolveUid(String packageName)  {\n        if (packageName == null) {\n            return Process.INVALID_UID;\n        }\n        switch (packageName) {\n            case \"root\":\n                return Process.ROOT_UID;\n            case \"shell\":\n            case \"dumpstate\":\n                return Process.SHELL_UID;\n            case \"media\":\n                return Process.MEDIA_UID;\n            case \"audioserver\":\n                return Process.AUDIOSERVER_UID;\n            case \"cameraserver\":\n                return Process.CAMERASERVER_UID;\n        }\n        return Process.INVALID_UID;\n    }\n\n    private static String[] getPackagesForUid(int uid) {\n        String[] packageNames = null;\n\n        // Very early during boot the package manager is not yet or not yet fully started. At this\n        // time there are no packages yet.\n        if (AppGlobals.getPackageManager() != null) {\n            try {\n                packageNames = AppGlobals.getPackageManager().getPackagesForUid(uid);\n            } catch (RemoteException e) {\n                /* ignore - local call */\n            }\n        }\n        if (packageNames == null) {\n            return EmptyArray.STRING;\n        }\n        return packageNames;\n    }\n\n    private final class ClientUserRestrictionState implements DeathRecipient {\n        private final IBinder token;\n\n        ClientUserRestrictionState(IBinder token)\n                throws RemoteException {\n            token.linkToDeath(this, 0);\n            this.token = token;\n        }\n\n        public boolean setRestriction(int code, boolean restricted,\n                PackageTagsList excludedPackageTags, int userId) {\n            return mAppOpsRestrictions.setUserRestriction(token, userId, code,\n                    restricted, excludedPackageTags);\n        }\n\n        public boolean hasRestriction(int code, String packageName, String attributionTag,\n                int userId, boolean isCheckOp) {\n            return mAppOpsRestrictions.getUserRestriction(token, userId, code, packageName,\n                    attributionTag, isCheckOp);\n        }\n\n        public void removeUser(int userId) {\n            mAppOpsRestrictions.clearUserRestrictions(token, userId);\n        }\n\n        public boolean isDefault() {\n            return !mAppOpsRestrictions.hasUserRestrictions(token);\n        }\n\n        @Override\n        public void binderDied() {\n            synchronized (AppOpsService.this) {\n                mAppOpsRestrictions.clearUserRestrictions(token);\n                mOpUserRestrictions.remove(token);\n                destroy();\n            }\n        }\n\n        public void destroy() {\n            token.unlinkToDeath(this, 0);\n        }\n    }\n\n    private final class ClientGlobalRestrictionState implements DeathRecipient {\n        final IBinder mToken;\n\n        ClientGlobalRestrictionState(IBinder token)\n                throws RemoteException {\n            token.linkToDeath(this, 0);\n            this.mToken = token;\n        }\n\n        boolean setRestriction(int code, boolean restricted) {\n            return mAppOpsRestrictions.setGlobalRestriction(mToken, code, restricted);\n        }\n\n        boolean hasRestriction(int code) {\n            return mAppOpsRestrictions.getGlobalRestriction(mToken, code);\n        }\n\n        boolean isDefault() {\n            return !mAppOpsRestrictions.hasGlobalRestrictions(mToken);\n        }\n\n        @Override\n        public void binderDied() {\n            mAppOpsRestrictions.clearGlobalRestrictions(mToken);\n            mOpGlobalRestrictions.remove(mToken);\n            destroy();\n        }\n\n        void destroy() {\n            mToken.unlinkToDeath(this, 0);\n        }\n    }\n\n    private final class AppOpsManagerLocalImpl implements AppOpsManagerLocal {\n        @Override\n        public boolean isUidInForeground(int uid) {\n            synchronized (AppOpsService.this) {\n                return mUidStateTracker.isUidInForeground(uid);\n            }\n        }\n    }\n\n    private final class AppOpsManagerInternalImpl extends AppOpsManagerInternal {\n        @Override public void setDeviceAndProfileOwners(SparseIntArray owners) {\n            synchronized (AppOpsService.this) {\n                mProfileOwners = owners;\n            }\n        }\n\n        @Override\n        public void updateAppWidgetVisibility(SparseArray<String> uidPackageNames,\n                boolean visible) {\n            AppOpsService.this.updateAppWidgetVisibility(uidPackageNames, visible);\n        }\n\n        @Override\n        public void setUidModeFromPermissionPolicy(int code, int uid, int mode,\n                @Nullable IAppOpsCallback callback) {\n            setUidMode(code, uid, mode, callback);\n        }\n\n        @Override\n        public void setModeFromPermissionPolicy(int code, int uid, @NonNull String packageName,\n                int mode, @Nullable IAppOpsCallback callback) {\n            setMode(code, uid, packageName, mode, callback);\n        }\n\n\n        @Override\n        public void setGlobalRestriction(int code, boolean restricted, IBinder token) {\n            if (Binder.getCallingPid() != Process.myPid()) {\n                // TODO instead of this enforcement put in AppOpsManagerInternal\n                throw new SecurityException(\"Only the system can set global restrictions\");\n            }\n\n            synchronized (AppOpsService.this) {\n                ClientGlobalRestrictionState restrictionState = mOpGlobalRestrictions.get(token);\n\n                if (restrictionState == null) {\n                    try {\n                        restrictionState = new ClientGlobalRestrictionState(token);\n                    } catch (RemoteException  e) {\n                        return;\n                    }\n                    mOpGlobalRestrictions.put(token, restrictionState);\n                }\n\n                if (restrictionState.setRestriction(code, restricted)) {\n                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                            AppOpsService::notifyWatchersOfChange, AppOpsService.this, code,\n                            UID_ANY));\n                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                            AppOpsService::updateStartedOpModeForUser, AppOpsService.this,\n                            code, restricted, UserHandle.USER_ALL));\n                }\n\n                if (restrictionState.isDefault()) {\n                    mOpGlobalRestrictions.remove(token);\n                    restrictionState.destroy();\n                }\n            }\n        }\n\n        @Override\n        public int getOpRestrictionCount(int code, UserHandle user, String pkg,\n                String attributionTag) {\n            int number = 0;\n            synchronized (AppOpsService.this) {\n                int numRestrictions = mOpUserRestrictions.size();\n                for (int i = 0; i < numRestrictions; i++) {\n                    if (mOpUserRestrictions.valueAt(i)\n                            .hasRestriction(code, pkg, attributionTag, user.getIdentifier(),\n                                    false)) {\n                        number++;\n                    }\n                }\n\n                numRestrictions = mOpGlobalRestrictions.size();\n                for (int i = 0; i < numRestrictions; i++) {\n                    if (mOpGlobalRestrictions.valueAt(i).hasRestriction(code)) {\n                        number++;\n                    }\n                }\n            }\n\n            return number;\n        }\n    }\n\n    /**\n     * Async task for writing note op stack trace, op code, package name and version to file\n     * More specifically, writes all the collected ops from {@link #mNoteOpCallerStacktraces}\n     */\n    private void writeNoteOps() {\n        synchronized (this) {\n            mWriteNoteOpsScheduled = false;\n        }\n        synchronized (mNoteOpCallerStacktracesFile) {\n            try (FileWriter writer = new FileWriter(mNoteOpCallerStacktracesFile)) {\n                int numTraces = mNoteOpCallerStacktraces.size();\n                for (int i = 0; i < numTraces; i++) {\n                    // Writing json formatted string into file\n                    writer.write(mNoteOpCallerStacktraces.valueAt(i).asJson());\n                    // Comma separation, so we can wrap the entire log as a JSON object\n                    // when all results are collected\n                    writer.write(\",\");\n                }\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to load opsValidation file for FileWriter\", e);\n            }\n        }\n    }\n\n    /**\n     * This class represents a NoteOp Trace object amd contains the necessary fields that will\n     * be written to file to use for permissions data validation in JSON format\n     */\n    @Immutable\n    static class NoteOpTrace {\n        static final String STACKTRACE = \"stackTrace\";\n        static final String OP = \"op\";\n        static final String PACKAGENAME = \"packageName\";\n        static final String VERSION = \"version\";\n\n        private final @NonNull String mStackTrace;\n        private final int mOp;\n        private final @Nullable String mPackageName;\n        private final long mVersion;\n\n        /**\n         * Initialize a NoteOp object using a JSON object containing the necessary fields\n         *\n         * @param jsonTrace JSON object represented as a string\n         *\n         * @return NoteOpTrace object initialized with JSON fields\n         */\n        static NoteOpTrace fromJson(String jsonTrace) {\n            try {\n                // Re-add closing bracket which acted as a delimiter by the reader\n                JSONObject obj = new JSONObject(jsonTrace.concat(\"}\"));\n                return new NoteOpTrace(obj.getString(STACKTRACE), obj.getInt(OP),\n                        obj.getString(PACKAGENAME), obj.getLong(VERSION));\n            } catch (JSONException e) {\n                // Swallow error, only meant for logging ops, should not affect flow of the code\n                Slog.e(TAG, \"Error constructing NoteOpTrace object \"\n                        + \"JSON trace format incorrect\", e);\n                return null;\n            }\n        }\n\n        NoteOpTrace(String stackTrace, int op, String packageName, long version) {\n            mStackTrace = stackTrace;\n            mOp = op;\n            mPackageName = packageName;\n            mVersion = version;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            NoteOpTrace that = (NoteOpTrace) o;\n            return mOp == that.mOp\n                    && mVersion == that.mVersion\n                    && mStackTrace.equals(that.mStackTrace)\n                    && Objects.equals(mPackageName, that.mPackageName);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(mStackTrace, mOp, mPackageName, mVersion);\n        }\n\n        /**\n         * The object is formatted as a JSON object and returned as a String\n         *\n         * @return JSON formatted string\n         */\n        public String asJson() {\n            return  \"{\"\n                    + \"\\\"\" + STACKTRACE + \"\\\":\\\"\" + mStackTrace.replace(\"\\n\", \"\\\\n\")\n                    + '\\\"' + \",\\\"\" + OP + \"\\\":\" + mOp\n                    + \",\\\"\" + PACKAGENAME + \"\\\":\\\"\" + mPackageName + '\\\"'\n                    + \",\\\"\" + VERSION + \"\\\":\" + mVersion\n                    + '}';\n        }\n    }\n\n    /**\n     * Collects noteOps, noteProxyOps and startOps from AppOpsManager and writes it into a file\n     * which will be used for permissions data validation, the given parameters to this method\n     * will be logged in json format\n     *\n     * @param stackTrace stacktrace from the most recent call in AppOpsManager\n     * @param op op code\n     * @param packageName package making call\n     * @param version android version for this call\n     */\n    @Override\n    public void collectNoteOpCallsForValidation(String stackTrace, int op, String packageName,\n            long version) {\n        if (!AppOpsManager.NOTE_OP_COLLECTION_ENABLED) {\n            return;\n        }\n\n        Objects.requireNonNull(stackTrace);\n        Preconditions.checkArgument(op >= 0);\n        Preconditions.checkArgument(op < AppOpsManager._NUM_OP);\n\n        NoteOpTrace noteOpTrace = new NoteOpTrace(stackTrace, op, packageName, version);\n\n        boolean noteOpSetWasChanged;\n        synchronized (this) {\n            noteOpSetWasChanged = mNoteOpCallerStacktraces.add(noteOpTrace);\n            if (noteOpSetWasChanged && !mWriteNoteOpsScheduled) {\n                mWriteNoteOpsScheduled = true;\n                mHandler.postDelayed(PooledLambda.obtainRunnable((that) -> {\n                    AsyncTask.execute(() -> {\n                        that.writeNoteOps();\n                    });\n                }, this), 2500);\n            }\n        }\n    }\n\n    @Immutable\n    private final class CheckOpsDelegateDispatcher {\n        private final @Nullable CheckOpsDelegate mPolicy;\n        private final @Nullable CheckOpsDelegate mCheckOpsDelegate;\n\n        CheckOpsDelegateDispatcher(@Nullable CheckOpsDelegate policy,\n                @Nullable CheckOpsDelegate checkOpsDelegate) {\n            mPolicy = policy;\n            mCheckOpsDelegate = checkOpsDelegate;\n        }\n\n        public @NonNull CheckOpsDelegate getCheckOpsDelegate() {\n            return mCheckOpsDelegate;\n        }\n\n        public int checkOperation(int code, int uid, String packageName,\n                @Nullable String attributionTag, boolean raw) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.checkOperation(code, uid, packageName, attributionTag, raw,\n                            this::checkDelegateOperationImpl);\n                } else {\n                    return mPolicy.checkOperation(code, uid, packageName, attributionTag, raw,\n                            AppOpsService.this::checkOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return checkDelegateOperationImpl(code, uid, packageName, attributionTag, raw);\n            }\n            return checkOperationImpl(code, uid, packageName, attributionTag, raw);\n        }\n\n        private int checkDelegateOperationImpl(int code, int uid, String packageName,\n                @Nullable String attributionTag, boolean raw) {\n            return mCheckOpsDelegate.checkOperation(code, uid, packageName, attributionTag, raw,\n                    AppOpsService.this::checkOperationImpl);\n        }\n\n        public int checkAudioOperation(int code, int usage, int uid, String packageName) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.checkAudioOperation(code, usage, uid, packageName,\n                            this::checkDelegateAudioOperationImpl);\n                } else {\n                    return mPolicy.checkAudioOperation(code, usage, uid, packageName,\n                            AppOpsService.this::checkAudioOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return checkDelegateAudioOperationImpl(code, usage, uid, packageName);\n            }\n            return checkAudioOperationImpl(code, usage, uid, packageName);\n        }\n\n        private int checkDelegateAudioOperationImpl(int code, int usage, int uid,\n                String packageName) {\n            return mCheckOpsDelegate.checkAudioOperation(code, usage, uid, packageName,\n                    AppOpsService.this::checkAudioOperationImpl);\n        }\n\n        public SyncNotedAppOp noteOperation(int code, int uid, String packageName,\n                String attributionTag, boolean shouldCollectAsyncNotedOp, String message,\n                boolean shouldCollectMessage) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.noteOperation(code, uid, packageName, attributionTag,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            this::noteDelegateOperationImpl);\n                } else {\n                    return mPolicy.noteOperation(code, uid, packageName, attributionTag,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            AppOpsService.this::noteOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return noteDelegateOperationImpl(code, uid, packageName,\n                        attributionTag, shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n            }\n            return noteOperationImpl(code, uid, packageName, attributionTag,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n        }\n\n        private SyncNotedAppOp noteDelegateOperationImpl(int code, int uid,\n                @Nullable String packageName, @Nullable String featureId,\n                boolean shouldCollectAsyncNotedOp, @Nullable String message,\n                boolean shouldCollectMessage) {\n            return mCheckOpsDelegate.noteOperation(code, uid, packageName, featureId,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    AppOpsService.this::noteOperationImpl);\n        }\n\n        public SyncNotedAppOp noteProxyOperation(int code, AttributionSource attributionSource,\n                boolean shouldCollectAsyncNotedOp, @Nullable String message,\n                boolean shouldCollectMessage, boolean skipProxyOperation) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.noteProxyOperation(code, attributionSource,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            skipProxyOperation, this::noteDelegateProxyOperationImpl);\n                } else {\n                    return mPolicy.noteProxyOperation(code, attributionSource,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            skipProxyOperation, AppOpsService.this::noteProxyOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return noteDelegateProxyOperationImpl(code,\n                        attributionSource, shouldCollectAsyncNotedOp, message,\n                        shouldCollectMessage, skipProxyOperation);\n            }\n            return noteProxyOperationImpl(code, attributionSource, shouldCollectAsyncNotedOp,\n                    message, shouldCollectMessage,skipProxyOperation);\n        }\n\n        private SyncNotedAppOp noteDelegateProxyOperationImpl(int code,\n                @NonNull AttributionSource attributionSource, boolean shouldCollectAsyncNotedOp,\n                @Nullable String message, boolean shouldCollectMessage,\n                boolean skipProxyOperation) {\n            return mCheckOpsDelegate.noteProxyOperation(code, attributionSource,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n                    AppOpsService.this::noteProxyOperationImpl);\n        }\n\n        public SyncNotedAppOp startOperation(IBinder token, int code, int uid,\n                @Nullable String packageName, @NonNull String attributionTag,\n                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp,\n                @Nullable String message, boolean shouldCollectMessage,\n                @AttributionFlags int attributionFlags, int attributionChainId) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.startOperation(token, code, uid, packageName,\n                            attributionTag, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                            shouldCollectMessage, attributionFlags, attributionChainId,\n                            this::startDelegateOperationImpl);\n                } else {\n                    return mPolicy.startOperation(token, code, uid, packageName, attributionTag,\n                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                            shouldCollectMessage, attributionFlags, attributionChainId,\n                            AppOpsService.this::startOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return startDelegateOperationImpl(token, code, uid, packageName, attributionTag,\n                        startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                        shouldCollectMessage, attributionFlags, attributionChainId);\n            }\n            return startOperationImpl(token, code, uid, packageName, attributionTag,\n                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    attributionFlags, attributionChainId);\n        }\n\n        private SyncNotedAppOp startDelegateOperationImpl(IBinder token, int code, int uid,\n                @Nullable String packageName, @Nullable String attributionTag,\n                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n                boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n                int attributionChainId) {\n            return mCheckOpsDelegate.startOperation(token, code, uid, packageName, attributionTag,\n                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    attributionFlags, attributionChainId, AppOpsService.this::startOperationImpl);\n        }\n\n        public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                            shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                            proxiedAttributionFlags, attributionChainId,\n                            this::startDelegateProxyOperationImpl);\n                } else {\n                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                            shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                            proxiedAttributionFlags, attributionChainId,\n                            AppOpsService.this::startProxyOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return startDelegateProxyOperationImpl(clientId, code, attributionSource,\n                        startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                        shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                        proxiedAttributionFlags, attributionChainId);\n            }\n            return startProxyOperationImpl(clientId, code, attributionSource, startIfModeDefault,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n                    proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n        }\n\n        private SyncNotedAppOp startDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                @AttributionFlags int proxiedAttributionFlsgs, int attributionChainId) {\n            return mCheckOpsDelegate.startProxyOperation(clientId, code, attributionSource,\n                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlsgs,\n                    attributionChainId, AppOpsService.this::startProxyOperationImpl);\n        }\n\n        public void finishOperation(IBinder clientId, int code, int uid, String packageName,\n                String attributionTag) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    mPolicy.finishOperation(clientId, code, uid, packageName, attributionTag,\n                            this::finishDelegateOperationImpl);\n                } else {\n                    mPolicy.finishOperation(clientId, code, uid, packageName, attributionTag,\n                            AppOpsService.this::finishOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                finishDelegateOperationImpl(clientId, code, uid, packageName, attributionTag);\n            } else {\n                finishOperationImpl(clientId, code, uid, packageName, attributionTag);\n            }\n        }\n\n        private void finishDelegateOperationImpl(IBinder clientId, int code, int uid,\n                String packageName, String attributionTag) {\n            mCheckOpsDelegate.finishOperation(clientId, code, uid, packageName, attributionTag,\n                    AppOpsService.this::finishOperationImpl);\n        }\n\n        public void finishProxyOperation(@NonNull IBinder clientId, int code,\n                @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n                            skipProxyOperation, this::finishDelegateProxyOperationImpl);\n                } else {\n                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n                            skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                finishDelegateProxyOperationImpl(clientId, code, attributionSource,\n                        skipProxyOperation);\n            } else {\n                finishProxyOperationImpl(clientId, code, attributionSource, skipProxyOperation);\n            }\n        }\n\n        private Void finishDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n                @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n            mCheckOpsDelegate.finishProxyOperation(clientId, code, attributionSource,\n                    skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n            return null;\n        }\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 55811,
                                        "general": {
                                            "word_based": 21179,
                                            "char_based": 73071
                                        },
                                        "gemini": 65511
                                    }
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-328068777",
            "aliases": [
                "A-328068777",
                "CVE-2024-23706"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-328068777",
            "severity": "Critical",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "dcb9791c2ed95b06a2ab9656f10fba3a35933ac5"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From dcb9791c2ed95b06a2ab9656f10fba3a35933ac5 Mon Sep 17 00:00:00 2001\nFrom: Pratyush More <pratyushmore@google.com>\nDate: Tue, 27 Feb 2024 18:38:29 +0000\nSubject: [PATCH] Throw exception when trying to instantiate a change log token\n with no record types.\n\nNote that this does mean that any developers that were previously\nrequesting change logs without specifying record types will no longer be\nable to. However, the APK doesn't allow this anyway, so it is likely ok.\n\nTest: atest CtsHealthFitnessDeviceTestCases:HealthConnectChangeLogsTests#testGetChangeLogToken_emptyRecordTypes_throwsException\nBug: 327332482\nChange-Id: I5dd49131fbe5eaa8bc138be03550f7fc739786d9\n---\n .../changelog/ChangeLogTokenRequest.java      |  7 ++-\n .../HealthConnectServiceImpl.java             | 16 +++++\n .../HealthConnectServiceLogsTests.java        |  6 +-\n .../cts/device/HealthConnectDeviceTest.java   |  8 +++\n .../cts/HealthConnectManagerTest.java         |  3 +-\n .../healthconnect/cts/SharedMemoryTest.java   |  7 ++-\n .../HealthConnectChangeLogsTests.java         | 61 ++++++++++++-------\n .../HistoricAccessLimitTest.java              |  7 ++-\n ...HistoricAccessLimitWithPermissionTest.java |  7 ++-\n .../healthconnect/cts/utils/DataFactory.java  |  9 +++\n 10 files changed, 102 insertions(+), 29 deletions(-)\n\ndiff --git a/framework/java/android/health/connect/changelog/ChangeLogTokenRequest.java b/framework/java/android/health/connect/changelog/ChangeLogTokenRequest.java\nindex 28241f88a..e630e3c53 100644\n--- a/framework/java/android/health/connect/changelog/ChangeLogTokenRequest.java\n+++ b/framework/java/android/health/connect/changelog/ChangeLogTokenRequest.java\n@@ -49,6 +49,9 @@ public final class ChangeLogTokenRequest implements Parcelable {\n     private ChangeLogTokenRequest(\n             @NonNull Set<DataOrigin> dataOriginFilters,\n             @NonNull Set<Class<? extends Record>> recordTypes) {\n+        if (recordTypes.isEmpty()) {\n+            throw new IllegalArgumentException(\"Requested record types must not be empty\");\n+        }\n         Objects.requireNonNull(recordTypes);\n         Objects.requireNonNull(dataOriginFilters);\n \n@@ -161,8 +164,8 @@ public final class ChangeLogTokenRequest implements Parcelable {\n         private final Set<DataOrigin> mDataOriginFilters = new ArraySet<>();\n \n         /**\n-         * @param recordType type of record for which change log is required. If not set includes\n-         *     all record types\n+         * @param recordType type of record for which change log is required. At least one record\n+         *     type must be set.\n          */\n         @NonNull\n         public Builder addRecordType(@NonNull Class<? extends Record> recordType) {\ndiff --git a/service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java b/service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java\nindex 439c97d87..c1c1ada78 100644\n--- a/service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java\n+++ b/service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java\n@@ -939,6 +939,10 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n                                 mAppOpsManagerLocal.isUidInForeground(uid),\n                                 logger);\n                         throwExceptionIfDataSyncInProgress();\n+                        if (request.getRecordTypes().isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Requested record types must not be empty.\");\n+                        }\n                         mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                 request.getRecordTypesList(), attributionSource);\n                         callback.onResult(\n@@ -957,6 +961,14 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n                         logger.setHealthDataServiceApiStatusError(ERROR_SECURITY);\n                         Slog.e(TAG, \"SecurityException: \", securityException);\n                         tryAndThrowException(callback, securityException, ERROR_SECURITY);\n+                    } catch (IllegalArgumentException illegalArgumentException) {\n+                        logger.setHealthDataServiceApiStatusError(\n+                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n+                        Slog.e(TAG, \"IllegalArgumentException: \", illegalArgumentException);\n+                        tryAndThrowException(\n+                                callback,\n+                                illegalArgumentException,\n+                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n                     } catch (HealthConnectException healthConnectException) {\n                         logger.setHealthDataServiceApiStatusError(\n                                 healthConnectException.getErrorCode());\n@@ -1019,6 +1031,10 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n                                         callerPackageName, request.getToken());\n                         tryAcquireApiCallQuota(\n                                 uid, QuotaCategory.QUOTA_CATEGORY_READ, isInForeground, logger);\n+                        if (changeLogsTokenRequest.getRecordTypes().isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Requested record types must not be empty.\");\n+                        }\n                         mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                 changeLogsTokenRequest.getRecordTypes(), attributionSource);\n                         long startDateAccessEpochMilli = DEFAULT_LONG;\ndiff --git a/tests/cts/hostsidetests/healthconnect/HealthConnectTestHelper/src/android/healthconnect/cts/testhelper/HealthConnectServiceLogsTests.java b/tests/cts/hostsidetests/healthconnect/HealthConnectTestHelper/src/android/healthconnect/cts/testhelper/HealthConnectServiceLogsTests.java\nindex 9bb194785..409153316 100644\n--- a/tests/cts/hostsidetests/healthconnect/HealthConnectTestHelper/src/android/healthconnect/cts/testhelper/HealthConnectServiceLogsTests.java\n+++ b/tests/cts/hostsidetests/healthconnect/HealthConnectTestHelper/src/android/healthconnect/cts/testhelper/HealthConnectServiceLogsTests.java\n@@ -45,6 +45,7 @@ import android.health.connect.changelog.ChangeLogsRequest;\n import android.health.connect.changelog.ChangeLogsResponse;\n import android.health.connect.datatypes.BloodPressureRecord;\n import android.health.connect.datatypes.DataOrigin;\n+import android.health.connect.datatypes.HeartRateRecord;\n import android.health.connect.datatypes.HeightRecord;\n import android.health.connect.datatypes.Record;\n import android.health.connect.datatypes.StepsRecord;\n@@ -360,7 +361,10 @@ public class HealthConnectServiceLogsTests {\n         CountDownLatch latch = new CountDownLatch(1);\n         assertThat(mHealthConnectManager).isNotNull();\n         mHealthConnectManager.getChangeLogToken(\n-                new ChangeLogTokenRequest.Builder().build(),\n+                new ChangeLogTokenRequest.Builder()\n+                        .addRecordType(BloodPressureRecord.class)\n+                        .addRecordType(HeartRateRecord.class)\n+                        .build(),\n                 Executors.newSingleThreadExecutor(),\n                 new OutcomeReceiver<>() {\n \ndiff --git a/tests/cts/hostsidetests/healthconnect/device/src/android/healthconnect/cts/device/HealthConnectDeviceTest.java b/tests/cts/hostsidetests/healthconnect/device/src/android/healthconnect/cts/device/HealthConnectDeviceTest.java\nindex 74b7e4120..6bc5e8c48 100644\n--- a/tests/cts/hostsidetests/healthconnect/device/src/android/healthconnect/cts/device/HealthConnectDeviceTest.java\n+++ b/tests/cts/hostsidetests/healthconnect/device/src/android/healthconnect/cts/device/HealthConnectDeviceTest.java\n@@ -572,12 +572,20 @@ public class HealthConnectDeviceTest {\n         String changeLogTokenForAppB =\n                 APP_B_WITH_READ_WRITE_PERMS.getChangeLogToken(\n                         new ChangeLogTokenRequest.Builder()\n+                                .addRecordType(StepsRecord.class)\n+                                .addRecordType(HeartRateRecord.class)\n+                                .addRecordType(BasalMetabolicRateRecord.class)\n+                                .addRecordType(ExerciseSessionRecord.class)\n                                 .addDataOriginFilter(\n                                         getDataOrigin(APP_A_WITH_READ_WRITE_PERMS.getPackageName()))\n                                 .build());\n         String changeLogTokenForAppA =\n                 APP_A_WITH_READ_WRITE_PERMS.getChangeLogToken(\n                         new ChangeLogTokenRequest.Builder()\n+                                .addRecordType(StepsRecord.class)\n+                                .addRecordType(HeartRateRecord.class)\n+                                .addRecordType(BasalMetabolicRateRecord.class)\n+                                .addRecordType(ExerciseSessionRecord.class)\n                                 .addDataOriginFilter(\n                                         getDataOrigin(APP_B_WITH_READ_WRITE_PERMS.getPackageName()))\n                                 .build());\ndiff --git a/tests/cts/src/android/healthconnect/cts/HealthConnectManagerTest.java b/tests/cts/src/android/healthconnect/cts/HealthConnectManagerTest.java\nindex c0a16d3f3..5cda01ca4 100644\n--- a/tests/cts/src/android/healthconnect/cts/HealthConnectManagerTest.java\n+++ b/tests/cts/src/android/healthconnect/cts/HealthConnectManagerTest.java\n@@ -1633,7 +1633,8 @@ public class HealthConnectManagerTest {\n         }\n \n         try {\n-            TestUtils.getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+            TestUtils.getChangeLogToken(\n+                    new ChangeLogTokenRequest.Builder().addRecordType(StepsRecord.class).build());\n             Assert.fail();\n         } catch (HealthConnectException exception) {\n             assertThat(exception).isNotNull();\ndiff --git a/tests/cts/src/android/healthconnect/cts/SharedMemoryTest.java b/tests/cts/src/android/healthconnect/cts/SharedMemoryTest.java\nindex b4ec367d0..5e46888b6 100644\n--- a/tests/cts/src/android/healthconnect/cts/SharedMemoryTest.java\n+++ b/tests/cts/src/android/healthconnect/cts/SharedMemoryTest.java\n@@ -234,7 +234,12 @@ public class SharedMemoryTest {\n         Instant now = Instant.now();\n \n         String changeLogToken =\n-                TestUtils.getChangeLogToken(new ChangeLogTokenRequest.Builder().build()).getToken();\n+                TestUtils.getChangeLogToken(\n+                                new ChangeLogTokenRequest.Builder()\n+                                        .addRecordType(HeightRecord.class)\n+                                        .addRecordType(WeightRecord.class)\n+                                        .build())\n+                        .getToken();\n \n         List<HeightRecord> heightRecords = new ArrayList<>(recordsToDeleteCount);\n         for (int i = 0; i < recordsToDeleteCount; i++) {\ndiff --git a/tests/cts/src/android/healthconnect/cts/changelogs/HealthConnectChangeLogsTests.java b/tests/cts/src/android/healthconnect/cts/changelogs/HealthConnectChangeLogsTests.java\nindex 5300e40c7..df6f2d586 100644\n--- a/tests/cts/src/android/healthconnect/cts/changelogs/HealthConnectChangeLogsTests.java\n+++ b/tests/cts/src/android/healthconnect/cts/changelogs/HealthConnectChangeLogsTests.java\n@@ -25,6 +25,7 @@ import static android.healthconnect.cts.utils.DataFactory.getHeartRateRecord;\n import static android.healthconnect.cts.utils.DataFactory.getMetadataForId;\n import static android.healthconnect.cts.utils.DataFactory.getStepsRecord;\n import static android.healthconnect.cts.utils.DataFactory.getTestRecords;\n+import static android.healthconnect.cts.utils.DataFactory.getChangeLogTokenRequestForTestRecordTypes;\n import static android.healthconnect.cts.utils.TestUtils.deleteAllStagedRemoteData;\n import static android.healthconnect.cts.utils.TestUtils.deleteRecords;\n import static android.healthconnect.cts.utils.TestUtils.deleteRecordsByIdFilter;\n@@ -38,6 +39,8 @@ import static android.healthconnect.cts.utils.TestUtils.verifyDeleteRecords;\n \n import static com.google.common.truth.Truth.assertThat;\n \n+import static org.junit.Assert.assertThrows;\n+\n import static java.time.temporal.ChronoUnit.HOURS;\n import static java.time.temporal.ChronoUnit.MILLIS;\n import static java.time.temporal.ChronoUnit.MINUTES;\n@@ -127,16 +130,17 @@ public class HealthConnectChangeLogsTests {\n \n     @Test\n     public void testBuildChangeLogTokenRequest_hasFieldsSet() {\n-        ChangeLogTokenRequest changeLogTokenRequest = new ChangeLogTokenRequest.Builder().build();\n+        ChangeLogTokenRequest changeLogTokenRequest =\n+                new ChangeLogTokenRequest.Builder().addRecordType(StepsRecord.class).build();\n \n-        assertThat(changeLogTokenRequest.getRecordTypes()).isEmpty();\n+        assertThat(changeLogTokenRequest.getRecordTypes()).containsExactly(StepsRecord.class);\n         assertThat(changeLogTokenRequest.getDataOriginFilters()).isEmpty();\n     }\n \n     @Test\n     public void testBuildChangeLogsRequest_hasFieldsSet() throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n \n@@ -147,7 +151,7 @@ public class HealthConnectChangeLogsTests {\n     @Test\n     public void testChangeLogs_noOperations_returnsEmptyChangelogs() throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n \n@@ -160,7 +164,7 @@ public class HealthConnectChangeLogsTests {\n     @Test\n     public void testChangeLogs_insert_returnsUpsertedLogsOnly() throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n \n@@ -176,7 +180,7 @@ public class HealthConnectChangeLogsTests {\n             throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n                 getChangeLogToken(\n-                        new ChangeLogTokenRequest.Builder()\n+                        getChangeLogTokenRequestForTestRecordTypes()\n                                 .addDataOriginFilter(\n                                         new DataOrigin.Builder().setPackageName(\"random\").build())\n                                 .build());\n@@ -196,7 +200,7 @@ public class HealthConnectChangeLogsTests {\n         Context context = ApplicationProvider.getApplicationContext();\n         ChangeLogTokenResponse tokenResponse =\n                 getChangeLogToken(\n-                        new ChangeLogTokenRequest.Builder()\n+                        getChangeLogTokenRequestForTestRecordTypes()\n                                 .addDataOriginFilter(\n                                         new DataOrigin.Builder()\n                                                 .setPackageName(context.getPackageName())\n@@ -238,7 +242,7 @@ public class HealthConnectChangeLogsTests {\n     public void testChangeLogs_insertAndDeleteDataById_returnsDeletedLogsOnly()\n             throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n \n@@ -256,7 +260,7 @@ public class HealthConnectChangeLogsTests {\n     public void testChangeLogs_insertAndDeleteByClientId_returnsDeletedLogsOnly()\n             throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n \n@@ -276,7 +280,7 @@ public class HealthConnectChangeLogsTests {\n     public void testChangeLogs_insertOldRecords_onlyReturnsUpsertedLogsAfterHistoricalAccess()\n             throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n \n@@ -302,7 +306,7 @@ public class HealthConnectChangeLogsTests {\n     public void testChangeLogs_insertAndDeleteOldRecords_returnsAllDeletedLogs()\n             throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n \n@@ -325,7 +329,7 @@ public class HealthConnectChangeLogsTests {\n             throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n                 getChangeLogToken(\n-                        new ChangeLogTokenRequest.Builder()\n+                        getChangeLogTokenRequestForTestRecordTypes()\n                                 .addDataOriginFilter(\n                                         new DataOrigin.Builder().setPackageName(\"random\").build())\n                                 .build());\n@@ -348,7 +352,7 @@ public class HealthConnectChangeLogsTests {\n         Context context = ApplicationProvider.getApplicationContext();\n         ChangeLogTokenResponse tokenResponse =\n                 getChangeLogToken(\n-                        new ChangeLogTokenRequest.Builder()\n+                        getChangeLogTokenRequestForTestRecordTypes()\n                                 .addDataOriginFilter(\n                                         new DataOrigin.Builder()\n                                                 .setPackageName(context.getPackageName())\n@@ -400,7 +404,7 @@ public class HealthConnectChangeLogsTests {\n     public void testChangeLogs_insertAndUpdateById_returnsUpdateChangeLogOnly()\n             throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n \n@@ -425,7 +429,7 @@ public class HealthConnectChangeLogsTests {\n     public void testChangeLogs_insertAndUpdateByClientId_returnsUpdateChangeLogOnly()\n             throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n \n@@ -446,7 +450,7 @@ public class HealthConnectChangeLogsTests {\n     public void testChangeLogs_insertUpdateAndDeleteById_returnsDeleteChangeLogOnly()\n             throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n \n@@ -472,7 +476,7 @@ public class HealthConnectChangeLogsTests {\n     public void testChangeLogs_insertUpdateAndDeleteByClientId_returnsDeleteChangeLogOnly()\n             throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n \n@@ -492,7 +496,7 @@ public class HealthConnectChangeLogsTests {\n     public void testChangeLogs_noOperations_withPageSize_returnsEmptyChangeLogs()\n             throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).setPageSize(1).build();\n \n@@ -505,7 +509,7 @@ public class HealthConnectChangeLogsTests {\n     public void testChangeLogs_insert_withPageSize_doesNotExceedPageSize()\n             throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).setPageSize(1).build();\n \n@@ -519,7 +523,7 @@ public class HealthConnectChangeLogsTests {\n     public void testChangeLogs_insert_withPageSize_paginatesThroughAllChangeLogs()\n             throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).setPageSize(1).build();\n \n@@ -560,7 +564,7 @@ public class HealthConnectChangeLogsTests {\n     @Test\n     public void testChangeLogs_checkToken_hasMorePages_False() throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n \n@@ -582,6 +586,15 @@ public class HealthConnectChangeLogsTests {\n         assertThat(newResponse.getNextChangesToken()).isEqualTo(newChangeLogsRequest.getToken());\n     }\n \n+    @Test\n+    public void testGetChangeLogToken_emptyRecordTypes_throwsException() throws Exception {\n+        Throwable thrown =\n+                assertThrows(\n+                        IllegalArgumentException.class,\n+                        () -> getChangeLogToken(new ChangeLogTokenRequest.Builder().build()));\n+        assertThat(thrown).hasMessageThat().contains(\"Requested record types must not be empty\");\n+    }\n+\n     @Test\n     public void testChangeLogs_operationCombinations_expectCorrectChangeLogs() throws Exception {\n         Instant yesterday = Instant.now().minus(1, ChronoUnit.DAYS).truncatedTo(MILLIS);\n@@ -605,7 +618,11 @@ public class HealthConnectChangeLogsTests {\n         String preExistingRecordId = insertRecordAndGetId(getDistanceRecord());\n         // then get changes token. The above records shouldn't be included in the change logs.\n         String changeToken =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build()).getToken();\n+                getChangeLogToken(\n+                                getChangeLogTokenRequestForTestRecordTypes()\n+                                        .addRecordType(DistanceRecord.class)\n+                                        .build())\n+                        .getToken();\n \n         ImmutableList.Builder<Record> recordBuilder = ImmutableList.builder();\n         for (int i = 0; i < 50; i++) {\ndiff --git a/tests/cts/src/android/healthconnect/cts/historicaccess/HistoricAccessLimitTest.java b/tests/cts/src/android/healthconnect/cts/historicaccess/HistoricAccessLimitTest.java\nindex b8ba29062..4b6f520fd 100644\n--- a/tests/cts/src/android/healthconnect/cts/historicaccess/HistoricAccessLimitTest.java\n+++ b/tests/cts/src/android/healthconnect/cts/historicaccess/HistoricAccessLimitTest.java\n@@ -264,7 +264,12 @@ public class HistoricAccessLimitTest {\n \n     @Test\n     public void testGetChangeLogs_expectCorrectResponse() throws InterruptedException {\n-        String token = getChangeLogToken(new ChangeLogTokenRequest.Builder().build()).getToken();\n+        String token =\n+                getChangeLogToken(\n+                                new ChangeLogTokenRequest.Builder()\n+                                        .addRecordType(WeightRecord.class)\n+                                        .build())\n+                        .getToken();\n         List<String> insertedRecentRecordIds =\n                 List.of(\n                         insertWeightRecord(daysBeforeNow(10), 10),\ndiff --git a/tests/cts/src/android/healthconnect/cts/historicaccess/HistoricAccessLimitWithPermissionTest.java b/tests/cts/src/android/healthconnect/cts/historicaccess/HistoricAccessLimitWithPermissionTest.java\nindex eea88db12..5f971e649 100644\n--- a/tests/cts/src/android/healthconnect/cts/historicaccess/HistoricAccessLimitWithPermissionTest.java\n+++ b/tests/cts/src/android/healthconnect/cts/historicaccess/HistoricAccessLimitWithPermissionTest.java\n@@ -251,7 +251,12 @@ public class HistoricAccessLimitWithPermissionTest {\n \n     @Test\n     public void testGetChangeLogs_expectCorrectResponse() throws InterruptedException {\n-        String token = getChangeLogToken(new ChangeLogTokenRequest.Builder().build()).getToken();\n+        String token =\n+                getChangeLogToken(\n+                                new ChangeLogTokenRequest.Builder()\n+                                        .addRecordType(WeightRecord.class)\n+                                        .build())\n+                        .getToken();\n         List<String> insertedRecordIds =\n                 List.of(\n                         insertWeightRecord(daysBeforeNow(10), 10),\ndiff --git a/tests/cts/utils/HealthConnectTestUtils/src/android/healthconnect/cts/utils/DataFactory.java b/tests/cts/utils/HealthConnectTestUtils/src/android/healthconnect/cts/utils/DataFactory.java\nindex e44e3f7ef..519c07143 100644\n--- a/tests/cts/utils/HealthConnectTestUtils/src/android/healthconnect/cts/utils/DataFactory.java\n+++ b/tests/cts/utils/HealthConnectTestUtils/src/android/healthconnect/cts/utils/DataFactory.java\n@@ -24,6 +24,7 @@ import static android.health.connect.datatypes.RecordTypeIdentifier.RECORD_TYPE_\n import static com.google.common.truth.Truth.assertThat;\n \n import android.content.Context;\n+import android.health.connect.changelog.ChangeLogTokenRequest;\n import android.health.connect.datatypes.BasalMetabolicRateRecord;\n import android.health.connect.datatypes.DataOrigin;\n import android.health.connect.datatypes.Device;\n@@ -469,6 +470,14 @@ public final class DataFactory {\n                 buildExerciseSession());\n     }\n \n+    public static ChangeLogTokenRequest.Builder getChangeLogTokenRequestForTestRecordTypes() {\n+        return new ChangeLogTokenRequest.Builder()\n+                .addRecordType(StepsRecord.class)\n+                .addRecordType(HeartRateRecord.class)\n+                .addRecordType(BasalMetabolicRateRecord.class)\n+                .addRecordType(ExerciseSessionRecord.class);\n+    }\n+\n     public static List<RecordAndIdentifier> getRecordsAndIdentifiers() {\n         return Arrays.asList(\n                 new RecordAndIdentifier(RECORD_TYPE_STEPS, getStepsRecord()),\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 5701,
                        "general": {
                            "word_based": 2049,
                            "char_based": 7199
                        },
                        "gemini": 6985
                    },
                    "total_downstream_versions_tested": 1,
                    "successful_patches": 0,
                    "failed_patches": 1,
                    "patch_results": [
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "cd228a3e21c9c8df83bc3851736d6f4e19956e46",
                            "repo_path": "android_repos/HealthFitness",
                            "result": "failure",
                            "downstream_patch_content": "commit cd228a3e21c9c8df83bc3851736d6f4e19956e46\nAuthor: Pratyush More <pratyushmore@google.com>\nDate:   Tue Feb 27 18:38:29 2024 +0000\n\n    Throw exception when trying to instantiate a change log token with no\n    record types.\n    \n    Note that this does mean that any developers that were previously\n    requesting change logs without specifying record types will no longer be\n    able to. However, the APK doesn't allow this anyway, so it is likely ok.\n    \n    \n    Test: atest CtsHealthFitnessDeviceTestCases:HealthConnectChangeLogsTests#testGetChangeLogToken_emptyRecordTypes_throwsException\n    Bug: 327332482\n    Change-Id: I5dd49131fbe5eaa8bc138be03550f7fc739786d9\n    Merged-In: I5dd49131fbe5eaa8bc138be03550f7fc739786d9\n\ndiff --git a/framework/java/android/health/connect/changelog/ChangeLogTokenRequest.java b/framework/java/android/health/connect/changelog/ChangeLogTokenRequest.java\nindex 28241f88a..e630e3c53 100644\n--- a/framework/java/android/health/connect/changelog/ChangeLogTokenRequest.java\n+++ b/framework/java/android/health/connect/changelog/ChangeLogTokenRequest.java\n@@ -49,6 +49,9 @@ public final class ChangeLogTokenRequest implements Parcelable {\n     private ChangeLogTokenRequest(\n             @NonNull Set<DataOrigin> dataOriginFilters,\n             @NonNull Set<Class<? extends Record>> recordTypes) {\n+        if (recordTypes.isEmpty()) {\n+            throw new IllegalArgumentException(\"Requested record types must not be empty\");\n+        }\n         Objects.requireNonNull(recordTypes);\n         Objects.requireNonNull(dataOriginFilters);\n \n@@ -161,8 +164,8 @@ public final class ChangeLogTokenRequest implements Parcelable {\n         private final Set<DataOrigin> mDataOriginFilters = new ArraySet<>();\n \n         /**\n-         * @param recordType type of record for which change log is required. If not set includes\n-         *     all record types\n+         * @param recordType type of record for which change log is required. At least one record\n+         *     type must be set.\n          */\n         @NonNull\n         public Builder addRecordType(@NonNull Class<? extends Record> recordType) {\ndiff --git a/service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java b/service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java\nindex 578db3397..9becd0c39 100644\n--- a/service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java\n+++ b/service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java\n@@ -798,6 +798,10 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n                                 mAppOpsManagerLocal.isUidInForeground(uid),\n                                 builder);\n                         throwExceptionIfDataSyncInProgress();\n+                        if (request.getRecordTypes().isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Requested record types must not be empty.\");\n+                        }\n                         mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                 request.getRecordTypesList(), attributionSource);\n                         callback.onResult(\n@@ -816,6 +820,14 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n                         builder.setHealthDataServiceApiStatusError(ERROR_SECURITY);\n                         Slog.e(TAG, \"SecurityException: \", securityException);\n                         tryAndThrowException(callback, securityException, ERROR_SECURITY);\n+                    } catch (IllegalArgumentException illegalArgumentException) {\n+                        builder.setHealthDataServiceApiStatusError(\n+                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n+                        Slog.e(TAG, \"IllegalArgumentException: \", illegalArgumentException);\n+                        tryAndThrowException(\n+                                callback,\n+                                illegalArgumentException,\n+                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n                     } catch (HealthConnectException healthConnectException) {\n                         builder.setHealthDataServiceApiStatusError(\n                                 healthConnectException.getErrorCode());\n@@ -862,6 +874,10 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n                         ChangeLogsRequestHelper.TokenRequest changeLogsTokenRequest =\n                                 ChangeLogsRequestHelper.getRequest(\n                                         attributionSource.getPackageName(), token.getToken());\n+                        if (changeLogsTokenRequest.getRecordTypes().isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Requested record types must not be empty.\");\n+                        }\n                         mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                 changeLogsTokenRequest.getRecordTypes(), attributionSource);\n                         boolean isInForeground = mAppOpsManagerLocal.isUidInForeground(uid);\ndiff --git a/tests/cts/hostsidetests/healthconnect/HealthConnectTestHelper/src/android/healthconnect/cts/testhelper/HealthConnectServiceLogsTests.java b/tests/cts/hostsidetests/healthconnect/HealthConnectTestHelper/src/android/healthconnect/cts/testhelper/HealthConnectServiceLogsTests.java\nindex 4c55b2b71..502e7990d 100644\n--- a/tests/cts/hostsidetests/healthconnect/HealthConnectTestHelper/src/android/healthconnect/cts/testhelper/HealthConnectServiceLogsTests.java\n+++ b/tests/cts/hostsidetests/healthconnect/HealthConnectTestHelper/src/android/healthconnect/cts/testhelper/HealthConnectServiceLogsTests.java\n@@ -44,6 +44,7 @@ import android.health.connect.changelog.ChangeLogsRequest;\n import android.health.connect.changelog.ChangeLogsResponse;\n import android.health.connect.datatypes.BloodPressureRecord;\n import android.health.connect.datatypes.DataOrigin;\n+import android.health.connect.datatypes.HeartRateRecord;\n import android.health.connect.datatypes.HeightRecord;\n import android.health.connect.datatypes.Record;\n import android.health.connect.datatypes.StepsRecord;\n@@ -359,7 +360,10 @@ public class HealthConnectServiceLogsTests {\n         CountDownLatch latch = new CountDownLatch(1);\n         assertThat(mHealthConnectManager).isNotNull();\n         mHealthConnectManager.getChangeLogToken(\n-                new ChangeLogTokenRequest.Builder().build(),\n+                new ChangeLogTokenRequest.Builder()\n+                        .addRecordType(BloodPressureRecord.class)\n+                        .addRecordType(HeartRateRecord.class)\n+                        .build(),\n                 Executors.newSingleThreadExecutor(),\n                 new OutcomeReceiver<>() {\n \ndiff --git a/tests/cts/hostsidetests/healthconnect/device/src/android/healthconnect/cts/device/HealthConnectDeviceTest.java b/tests/cts/hostsidetests/healthconnect/device/src/android/healthconnect/cts/device/HealthConnectDeviceTest.java\nindex da31eb241..f9ff1120c 100644\n--- a/tests/cts/hostsidetests/healthconnect/device/src/android/healthconnect/cts/device/HealthConnectDeviceTest.java\n+++ b/tests/cts/hostsidetests/healthconnect/device/src/android/healthconnect/cts/device/HealthConnectDeviceTest.java\n@@ -266,70 +266,4 @@ public class HealthConnectDeviceTest {\n                         APP_A_WITH_READ_WRITE_PERMS, recordClassesToRead);\n         assertThat(bundle.getInt(READ_RECORDS_SIZE)).isEqualTo(noOfRecordsInsertedByAppA);\n     }\n-\n-    @Test\n-    public void testAppCanReadChangeLogsUsingDataOriginFilters() throws Exception {\n-        Bundle bundle =\n-                getChangeLogTokenAs(\n-                        APP_B_WITH_READ_WRITE_PERMS, APP_A_WITH_READ_WRITE_PERMS.getPackageName());\n-        String changeLogTokenForAppB = bundle.getString(CHANGE_LOG_TOKEN);\n-\n-        bundle =\n-                getChangeLogTokenAs(\n-                        APP_A_WITH_READ_WRITE_PERMS, APP_B_WITH_READ_WRITE_PERMS.getPackageName());\n-        String changeLogTokenForAppA = bundle.getString(CHANGE_LOG_TOKEN);\n-\n-        bundle = insertRecordAs(APP_A_WITH_READ_WRITE_PERMS);\n-        assertThat(bundle.getBoolean(SUCCESS)).isTrue();\n-\n-        List<TestUtils.RecordTypeAndRecordIds> listOfRecordIdsAndClass =\n-                (List<TestUtils.RecordTypeAndRecordIds>) bundle.getSerializable(RECORD_IDS);\n-\n-        List<String> listOfRecordIdsInsertedByAppA = new ArrayList<>();\n-        int noOfRecordsInsertedByAppA = 0;\n-        for (TestUtils.RecordTypeAndRecordIds recordTypeAndRecordIds : listOfRecordIdsAndClass) {\n-            noOfRecordsInsertedByAppA += recordTypeAndRecordIds.getRecordIds().size();\n-            listOfRecordIdsInsertedByAppA.addAll(recordTypeAndRecordIds.getRecordIds());\n-        }\n-\n-        updateRecordsAs(APP_A_WITH_READ_WRITE_PERMS, listOfRecordIdsAndClass);\n-\n-        bundle = insertRecordAs(APP_B_WITH_READ_WRITE_PERMS);\n-        assertThat(bundle.getBoolean(SUCCESS)).isTrue();\n-\n-        listOfRecordIdsAndClass =\n-                (List<TestUtils.RecordTypeAndRecordIds>) bundle.getSerializable(RECORD_IDS);\n-\n-        int noOfRecordsInsertedByAppB = 0;\n-        for (TestUtils.RecordTypeAndRecordIds recordTypeAndRecordIds : listOfRecordIdsAndClass) {\n-            noOfRecordsInsertedByAppB += recordTypeAndRecordIds.getRecordIds().size();\n-        }\n-\n-        deleteRecordsAs(APP_B_WITH_READ_WRITE_PERMS, listOfRecordIdsAndClass);\n-\n-        bundle =\n-                readChangeLogsUsingDataOriginFiltersAs(\n-                        APP_B_WITH_READ_WRITE_PERMS, changeLogTokenForAppB);\n-\n-        ChangeLogsResponse response = bundle.getParcelable(CHANGE_LOGS_RESPONSE);\n-\n-        assertThat(response.getUpsertedRecords().size()).isEqualTo(noOfRecordsInsertedByAppA);\n-        assertThat(\n-                        response.getUpsertedRecords().stream()\n-                                .map(Record::getMetadata)\n-                                .map(Metadata::getId)\n-                                .toList())\n-                .containsExactlyElementsIn(listOfRecordIdsInsertedByAppA);\n-\n-        assertThat(response.getDeletedLogs().size()).isEqualTo(0);\n-\n-        bundle =\n-                readChangeLogsUsingDataOriginFiltersAs(\n-                        APP_A_WITH_READ_WRITE_PERMS, changeLogTokenForAppA);\n-\n-        response = bundle.getParcelable(CHANGE_LOGS_RESPONSE);\n-\n-        assertThat(response.getUpsertedRecords().size()).isEqualTo(0);\n-        assertThat(response.getDeletedLogs().size()).isEqualTo(noOfRecordsInsertedByAppB);\n-    }\n }\ndiff --git a/tests/cts/src/android/healthconnect/cts/HealthConnectChangeLogsTests.java b/tests/cts/src/android/healthconnect/cts/HealthConnectChangeLogsTests.java\nindex 71e38ef57..c58bae239 100644\n--- a/tests/cts/src/android/healthconnect/cts/HealthConnectChangeLogsTests.java\n+++ b/tests/cts/src/android/healthconnect/cts/HealthConnectChangeLogsTests.java\n@@ -18,6 +18,8 @@ package android.healthconnect.cts;\n \n import static com.google.common.truth.Truth.assertThat;\n \n+import static org.junit.Assert.assertThrows;\n+\n import android.content.Context;\n import android.health.connect.changelog.ChangeLogTokenRequest;\n import android.health.connect.changelog.ChangeLogTokenResponse;\n@@ -53,7 +55,8 @@ public class HealthConnectChangeLogsTests {\n \n     @Test\n     public void testGetChangeLogToken() throws InterruptedException {\n-        ChangeLogTokenRequest changeLogTokenRequest = new ChangeLogTokenRequest.Builder().build();\n+        ChangeLogTokenRequest changeLogTokenRequest =\n+                new ChangeLogTokenRequest.Builder().addRecordType(StepsRecord.class).build();\n         assertThat(TestUtils.getChangeLogToken(changeLogTokenRequest)).isNotNull();\n         assertThat(changeLogTokenRequest.getRecordTypes()).isNotNull();\n         assertThat(changeLogTokenRequest.getDataOriginFilters()).isNotNull();\n@@ -62,7 +65,8 @@ public class HealthConnectChangeLogsTests {\n     @Test\n     public void testChangeLogs_insert_default() throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                TestUtils.getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                TestUtils.getChangeLogToken(\n+                        TestUtils.getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n         assertThat(changeLogsRequest.getToken()).isNotNull();\n@@ -82,7 +86,7 @@ public class HealthConnectChangeLogsTests {\n     public void testChangeLogs_insert_dataOrigin_filter_incorrect() throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n                 TestUtils.getChangeLogToken(\n-                        new ChangeLogTokenRequest.Builder()\n+                        TestUtils.getChangeLogTokenRequestForTestRecordTypes()\n                                 .addDataOriginFilter(\n                                         new DataOrigin.Builder().setPackageName(\"random\").build())\n                                 .build());\n@@ -106,7 +110,7 @@ public class HealthConnectChangeLogsTests {\n         Context context = ApplicationProvider.getApplicationContext();\n         ChangeLogTokenResponse tokenResponse =\n                 TestUtils.getChangeLogToken(\n-                        new ChangeLogTokenRequest.Builder()\n+                        TestUtils.getChangeLogTokenRequestForTestRecordTypes()\n                                 .addDataOriginFilter(\n                                         new DataOrigin.Builder()\n                                                 .setPackageName(context.getPackageName())\n@@ -160,7 +164,8 @@ public class HealthConnectChangeLogsTests {\n     @Test\n     public void testChangeLogs_insertAndDelete_default() throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                TestUtils.getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                TestUtils.getChangeLogToken(\n+                        TestUtils.getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n         ChangeLogsResponse response = TestUtils.getChangeLogs(changeLogsRequest);\n@@ -186,7 +191,8 @@ public class HealthConnectChangeLogsTests {\n     @Test\n     public void testChangeLogs_insertAndDelete_beforePermission() throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                TestUtils.getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                TestUtils.getChangeLogToken(new ChangeLogTokenRequest.Builder().addRecordType(\n+                        StepsRecord.class).build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n         ChangeLogsResponse response = TestUtils.getChangeLogs(changeLogsRequest);\n@@ -212,7 +218,7 @@ public class HealthConnectChangeLogsTests {\n             throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n                 TestUtils.getChangeLogToken(\n-                        new ChangeLogTokenRequest.Builder()\n+                        TestUtils.getChangeLogTokenRequestForTestRecordTypes()\n                                 .addDataOriginFilter(\n                                         new DataOrigin.Builder().setPackageName(\"random\").build())\n                                 .build());\n@@ -237,7 +243,7 @@ public class HealthConnectChangeLogsTests {\n         Context context = ApplicationProvider.getApplicationContext();\n         ChangeLogTokenResponse tokenResponse =\n                 TestUtils.getChangeLogToken(\n-                        new ChangeLogTokenRequest.Builder()\n+                        TestUtils.getChangeLogTokenRequestForTestRecordTypes()\n                                 .addDataOriginFilter(\n                                         new DataOrigin.Builder()\n                                                 .setPackageName(context.getPackageName())\n@@ -295,7 +301,8 @@ public class HealthConnectChangeLogsTests {\n     @Test\n     public void testChangeLogs_insert_default_withPageSize() throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                TestUtils.getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                TestUtils.getChangeLogToken(\n+                        TestUtils.getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).setPageSize(1).build();\n         ChangeLogsResponse response = TestUtils.getChangeLogs(changeLogsRequest);\n@@ -310,7 +317,8 @@ public class HealthConnectChangeLogsTests {\n     @Test\n     public void testChangeLogs_insert_default_withNextPageToken() throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                TestUtils.getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                TestUtils.getChangeLogToken(\n+                        TestUtils.getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).setPageSize(1).build();\n         ChangeLogsResponse response = TestUtils.getChangeLogs(changeLogsRequest);\n@@ -340,7 +348,8 @@ public class HealthConnectChangeLogsTests {\n     @Test\n     public void testChangeLogs_insert_default_withSamePageToken() throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                TestUtils.getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                TestUtils.getChangeLogToken(\n+                        TestUtils.getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n         ChangeLogsResponse response = TestUtils.getChangeLogs(changeLogsRequest);\n@@ -358,7 +367,8 @@ public class HealthConnectChangeLogsTests {\n     @Test\n     public void testChangeLogs_checkToken_hasMorePages_False() throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                TestUtils.getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                TestUtils.getChangeLogToken(\n+                        TestUtils.getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n         ChangeLogsResponse response = TestUtils.getChangeLogs(changeLogsRequest);\ndiff --git a/tests/cts/src/android/healthconnect/cts/HealthConnectManagerTest.java b/tests/cts/src/android/healthconnect/cts/HealthConnectManagerTest.java\nindex c76dd1e2e..ca8d225cf 100644\n--- a/tests/cts/src/android/healthconnect/cts/HealthConnectManagerTest.java\n+++ b/tests/cts/src/android/healthconnect/cts/HealthConnectManagerTest.java\n@@ -1560,7 +1560,8 @@ public class HealthConnectManagerTest {\n         }\n \n         try {\n-            TestUtils.getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+            TestUtils.getChangeLogToken(\n+                    new ChangeLogTokenRequest.Builder().addRecordType(StepsRecord.class).build());\n             Assert.fail();\n         } catch (HealthConnectException exception) {\n             assertThat(exception).isNotNull();\ndiff --git a/tests/cts/src/android/healthconnect/cts/TestUtils.java b/tests/cts/src/android/healthconnect/cts/TestUtils.java\nindex 2fcbbd0b9..552756ffb 100644\n--- a/tests/cts/src/android/healthconnect/cts/TestUtils.java\n+++ b/tests/cts/src/android/healthconnect/cts/TestUtils.java\n@@ -305,6 +305,14 @@ public class TestUtils {\n                 buildExerciseSession());\n     }\n \n+    public static ChangeLogTokenRequest.Builder getChangeLogTokenRequestForTestRecordTypes() {\n+        return new ChangeLogTokenRequest.Builder()\n+                .addRecordType(StepsRecord.class)\n+                .addRecordType(HeartRateRecord.class)\n+                .addRecordType(BasalMetabolicRateRecord.class)\n+                .addRecordType(ExerciseSessionRecord.class);\n+    }\n+\n     public static List<RecordAndIdentifier> getRecordsAndIdentifiers() {\n         return Arrays.asList(\n                 new RecordAndIdentifier(RECORD_TYPE_STEPS, getStepsRecord()),\n",
                            "downstream_patch_tokens": {
                                "openai": 4079,
                                "general": {
                                    "word_based": 1431,
                                    "char_based": 5169
                                },
                                "gemini": 5056
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java",
                                    "total_hunks": 3,
                                    "failed_hunks": [
                                        3
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n                        if (request.getRecordTypes().isEmpty()) {\n                            throw new IllegalArgumentException(\n                                    \"Requested record types must not be empty.\");\n                        }\n                        mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                request.getRecordTypesList(), attributionSource);\n                        callback.onResult(\n>>>>>>> UPSTREAM PATCH (commit dcb9791c2ed95b06a2ab9656f10fba3a35933ac5)",
                                            "merge_conflict_tokens": {
                                                "openai": 96,
                                                "general": {
                                                    "word_based": 28,
                                                    "char_based": 139
                                                },
                                                "gemini": 121
                                            }
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n                                        callerPackageName, request.getToken());\n                        tryAcquireApiCallQuota(\n                                uid, QuotaCategory.QUOTA_CATEGORY_READ, isInForeground, logger);\n                        if (changeLogsTokenRequest.getRecordTypes().isEmpty()) {\n                            throw new IllegalArgumentException(\n                                    \"Requested record types must not be empty.\");\n                        }\n                        mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                changeLogsTokenRequest.getRecordTypes(), attributionSource);\n                        long startDateAccessEpochMilli = DEFAULT_LONG;\n>>>>>>> UPSTREAM PATCH (commit dcb9791c2ed95b06a2ab9656f10fba3a35933ac5)",
                                            "merge_conflict_tokens": {
                                                "openai": 140,
                                                "general": {
                                                    "word_based": 38,
                                                    "char_based": 209
                                                },
                                                "gemini": 168
                                            }
                                        }
                                    ],
                                    "inline_merge_token_summary": {
                                        "gemini": 35258,
                                        "openai": 29028,
                                        "general_word": 8118,
                                        "general_char": 42804
                                    },
                                    "rej_file_content": "```diff\n--- service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java\n+++ service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java\n@@ -1031,6 +1043,10 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n                                         callerPackageName, request.getToken());\n                         tryAcquireApiCallQuota(\n                                 uid, QuotaCategory.QUOTA_CATEGORY_READ, isInForeground, logger);\n+                        if (changeLogsTokenRequest.getRecordTypes().isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Requested record types must not be empty.\");\n+                        }\n                         mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                 changeLogsTokenRequest.getRecordTypes(), attributionSource);\n                         long startDateAccessEpochMilli = DEFAULT_LONG;\n```",
                                    "rej_file_tokens": {
                                        "openai": 158,
                                        "general": {
                                            "word_based": 57,
                                            "char_based": 247
                                        },
                                        "gemini": 191
                                    },
                                    "patch_apply_output": "patching file framework/java/android/health/connect/changelog/ChangeLogTokenRequest.java\npatching file service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java\nHunk #1 succeeded at 798 with fuzz 2 (offset -141 lines).\nHunk #2 succeeded at 820 with fuzz 2 (offset -141 lines).\nHunk #3 FAILED at 1031.\n1 out of 3 hunks FAILED -- saving rejects to file service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java.rej\ncan't find file to patch at input line 71\nPerhaps you used the wrong -p or --strip option?\nThe text leading up to this was:\n--------------------------\n|diff --git a/tests/cts/utils/HealthConnectTestUtils/src/android/healthconnect/cts/utils/DataFactory.java b/tests/cts/utils/HealthConnectTestUtils/src/android/healthconnect/cts/utils/DataFactory.java\n|index e44e3f7ef..519c07143 100644\n|--- a/tests/cts/utils/HealthConnectTestUtils/src/android/healthconnect/cts/utils/DataFactory.java\n|+++ b/tests/cts/utils/HealthConnectTestUtils/src/android/healthconnect/cts/utils/DataFactory.java\n--------------------------\nFile to patch: \nSkip this patch? [y] \nSkipping patch.\n2 out of 2 hunks ignored",
                                    "inline_merge_output": "patching file service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java\nHunk #1 NOT MERGED at 942-951.\nHunk #3 NOT MERGED at 1276-1288.",
                                    "upstream_file_tokens": {
                                        "openai": 20596,
                                        "general": {
                                            "word_based": 7441,
                                            "char_based": 33394
                                        },
                                        "gemini": 24937
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2023 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.healthconnect;\n\nimport static android.Manifest.permission.MIGRATE_HEALTH_CONNECT_DATA;\nimport static android.content.pm.PackageManager.PERMISSION_GRANTED;\nimport static android.health.connect.Constants.DEFAULT_LONG;\nimport static android.health.connect.Constants.READ;\nimport static android.health.connect.HealthConnectException.ERROR_INTERNAL;\nimport static android.health.connect.HealthConnectException.ERROR_SECURITY;\nimport static android.health.connect.HealthPermissions.MANAGE_HEALTH_DATA_PERMISSION;\n\nimport static com.android.server.healthconnect.logging.HealthConnectServiceLogger.ApiMethods.DELETE_DATA;\nimport static com.android.server.healthconnect.logging.HealthConnectServiceLogger.ApiMethods.GET_CHANGES;\nimport static com.android.server.healthconnect.logging.HealthConnectServiceLogger.ApiMethods.GET_CHANGES_TOKEN;\nimport static com.android.server.healthconnect.logging.HealthConnectServiceLogger.ApiMethods.INSERT_DATA;\nimport static com.android.server.healthconnect.logging.HealthConnectServiceLogger.ApiMethods.READ_AGGREGATED_DATA;\nimport static com.android.server.healthconnect.logging.HealthConnectServiceLogger.ApiMethods.READ_DATA;\nimport static com.android.server.healthconnect.logging.HealthConnectServiceLogger.ApiMethods.UPDATE_DATA;\n\nimport android.Manifest;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.content.AttributionSource;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.database.sqlite.SQLiteException;\nimport android.health.connect.Constants;\nimport android.health.connect.FetchDataOriginsPriorityOrderResponse;\nimport android.health.connect.HealthConnectDataState;\nimport android.health.connect.HealthConnectException;\nimport android.health.connect.HealthConnectManager;\nimport android.health.connect.HealthConnectManager.DataDownloadState;\nimport android.health.connect.HealthDataCategory;\nimport android.health.connect.HealthPermissions;\nimport android.health.connect.RecordTypeInfoResponse;\nimport android.health.connect.accesslog.AccessLog;\nimport android.health.connect.accesslog.AccessLogsResponseParcel;\nimport android.health.connect.aidl.ActivityDatesRequestParcel;\nimport android.health.connect.aidl.ActivityDatesResponseParcel;\nimport android.health.connect.aidl.AggregateDataRequestParcel;\nimport android.health.connect.aidl.ApplicationInfoResponseParcel;\nimport android.health.connect.aidl.DeleteUsingFiltersRequestParcel;\nimport android.health.connect.aidl.GetPriorityResponseParcel;\nimport android.health.connect.aidl.HealthConnectExceptionParcel;\nimport android.health.connect.aidl.IAccessLogsResponseCallback;\nimport android.health.connect.aidl.IActivityDatesResponseCallback;\nimport android.health.connect.aidl.IAggregateRecordsResponseCallback;\nimport android.health.connect.aidl.IApplicationInfoResponseCallback;\nimport android.health.connect.aidl.IChangeLogsResponseCallback;\nimport android.health.connect.aidl.IDataStagingFinishedCallback;\nimport android.health.connect.aidl.IEmptyResponseCallback;\nimport android.health.connect.aidl.IGetChangeLogTokenCallback;\nimport android.health.connect.aidl.IGetHealthConnectDataStateCallback;\nimport android.health.connect.aidl.IGetHealthConnectMigrationUiStateCallback;\nimport android.health.connect.aidl.IGetPriorityResponseCallback;\nimport android.health.connect.aidl.IHealthConnectService;\nimport android.health.connect.aidl.IInsertRecordsResponseCallback;\nimport android.health.connect.aidl.IMigrationCallback;\nimport android.health.connect.aidl.IReadRecordsResponseCallback;\nimport android.health.connect.aidl.IRecordTypeInfoResponseCallback;\nimport android.health.connect.aidl.InsertRecordsResponseParcel;\nimport android.health.connect.aidl.ReadRecordsRequestParcel;\nimport android.health.connect.aidl.ReadRecordsResponseParcel;\nimport android.health.connect.aidl.RecordIdFiltersParcel;\nimport android.health.connect.aidl.RecordTypeInfoResponseParcel;\nimport android.health.connect.aidl.RecordsParcel;\nimport android.health.connect.aidl.UpdatePriorityRequestParcel;\nimport android.health.connect.changelog.ChangeLogTokenRequest;\nimport android.health.connect.changelog.ChangeLogTokenResponse;\nimport android.health.connect.changelog.ChangeLogsRequest;\nimport android.health.connect.changelog.ChangeLogsResponse;\nimport android.health.connect.changelog.ChangeLogsResponse.DeletedLog;\nimport android.health.connect.datatypes.AppInfo;\nimport android.health.connect.datatypes.DataOrigin;\nimport android.health.connect.datatypes.Record;\nimport android.health.connect.internal.datatypes.RecordInternal;\nimport android.health.connect.internal.datatypes.utils.AggregationTypeIdMapper;\nimport android.health.connect.internal.datatypes.utils.RecordMapper;\nimport android.health.connect.internal.datatypes.utils.RecordTypePermissionCategoryMapper;\nimport android.health.connect.migration.HealthConnectMigrationUiState;\nimport android.health.connect.migration.MigrationEntityParcel;\nimport android.health.connect.migration.MigrationException;\nimport android.health.connect.ratelimiter.RateLimiter;\nimport android.health.connect.ratelimiter.RateLimiter.QuotaCategory;\nimport android.health.connect.ratelimiter.RateLimiterException;\nimport android.health.connect.restore.BackupFileNamesSet;\nimport android.health.connect.restore.StageRemoteDataException;\nimport android.health.connect.restore.StageRemoteDataRequest;\nimport android.os.Binder;\nimport android.os.ParcelFileDescriptor;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.permission.PermissionManager;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.Log;\nimport android.util.Pair;\nimport android.util.Slog;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.server.LocalManagerRegistry;\nimport com.android.server.appop.AppOpsManagerLocal;\nimport com.android.server.healthconnect.backuprestore.BackupRestore;\nimport com.android.server.healthconnect.logging.HealthConnectServiceLogger;\nimport com.android.server.healthconnect.migration.DataMigrationManager;\nimport com.android.server.healthconnect.migration.MigrationCleaner;\nimport com.android.server.healthconnect.migration.MigrationStateManager;\nimport com.android.server.healthconnect.migration.MigrationUiStateManager;\nimport com.android.server.healthconnect.migration.PriorityMigrationHelper;\nimport com.android.server.healthconnect.permission.DataPermissionEnforcer;\nimport com.android.server.healthconnect.permission.FirstGrantTimeManager;\nimport com.android.server.healthconnect.permission.HealthConnectPermissionHelper;\nimport com.android.server.healthconnect.storage.AutoDeleteService;\nimport com.android.server.healthconnect.storage.TransactionManager;\nimport com.android.server.healthconnect.storage.datatypehelpers.AccessLogsHelper;\nimport com.android.server.healthconnect.storage.datatypehelpers.ActivityDateHelper;\nimport com.android.server.healthconnect.storage.datatypehelpers.AppInfoHelper;\nimport com.android.server.healthconnect.storage.datatypehelpers.ChangeLogsHelper;\nimport com.android.server.healthconnect.storage.datatypehelpers.ChangeLogsRequestHelper;\nimport com.android.server.healthconnect.storage.datatypehelpers.DeviceInfoHelper;\nimport com.android.server.healthconnect.storage.datatypehelpers.HealthDataCategoryPriorityHelper;\nimport com.android.server.healthconnect.storage.datatypehelpers.MigrationEntityHelper;\nimport com.android.server.healthconnect.storage.datatypehelpers.RecordHelper;\nimport com.android.server.healthconnect.storage.request.AggregateTransactionRequest;\nimport com.android.server.healthconnect.storage.request.DeleteTransactionRequest;\nimport com.android.server.healthconnect.storage.request.ReadTransactionRequest;\nimport com.android.server.healthconnect.storage.request.UpsertTransactionRequest;\nimport com.android.server.healthconnect.storage.utils.RecordHelperProvider;\n\nimport java.io.IOException;\nimport java.time.Instant;\nimport java.time.LocalDate;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.stream.Collectors;\n\n/**\n * IHealthConnectService's implementation\n *\n * @hide\n */\nfinal class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n    private static final String TAG = \"HealthConnectService\";\n    // Permission for test api for deleting staged data\n    private static final String DELETE_STAGED_HEALTH_CONNECT_REMOTE_DATA_PERMISSION =\n            \"android.permission.DELETE_STAGED_HEALTH_CONNECT_REMOTE_DATA\";\n    // Allows an application to act as a backup inter-agent to send and receive HealthConnect data\n    private static final String HEALTH_CONNECT_BACKUP_INTER_AGENT_PERMISSION =\n            \"android.permission.HEALTH_CONNECT_BACKUP_INTER_AGENT\";\n\n    private static final String TAG_INSERT = \"HealthConnectInsert\";\n    private static final String TAG_READ = \"HealthConnectRead\";\n    private static final String TAG_GRANT_PERMISSION = \"HealthConnectGrantReadPermissions\";\n    private static final String TAG_READ_PERMISSION = \"HealthConnectReadPermission\";\n    private static final String TAG_INSERT_SUBTASKS = \"HealthConnectInsertSubtasks\";\n\n    private static final String TAG_DELETE_SUBTASKS = \"HealthConnectDeleteSubtasks\";\n    private static final String TAG_READ_SUBTASKS = \"HealthConnectReadSubtasks\";\n    private static final int TRACE_TAG_INSERT = TAG_INSERT.hashCode();\n    private static final int TRACE_TAG_READ = TAG_READ.hashCode();\n    private static final int TRACE_TAG_GRANT_PERMISSION = TAG_GRANT_PERMISSION.hashCode();\n    private static final int TRACE_TAG_READ_PERMISSION = TAG_READ_PERMISSION.hashCode();\n    private static final int TRACE_TAG_INSERT_SUBTASKS = TAG_INSERT_SUBTASKS.hashCode();\n    private static final int TRACE_TAG_DELETE_SUBTASKS = TAG_DELETE_SUBTASKS.hashCode();\n    private static final int TRACE_TAG_READ_SUBTASKS = TAG_READ_SUBTASKS.hashCode();\n\n    private final TransactionManager mTransactionManager;\n    private final HealthConnectPermissionHelper mPermissionHelper;\n    private final FirstGrantTimeManager mFirstGrantTimeManager;\n    private final Context mContext;\n    private final PermissionManager mPermissionManager;\n\n    private final BackupRestore mBackupRestore;\n    private final MigrationStateManager mMigrationStateManager;\n\n    private final DataPermissionEnforcer mDataPermissionEnforcer;\n\n    private final AppOpsManagerLocal mAppOpsManagerLocal;\n    private final MigrationUiStateManager mMigrationUiStateManager;\n\n    private volatile UserHandle mCurrentForegroundUser;\n\n    HealthConnectServiceImpl(\n            TransactionManager transactionManager,\n            HealthConnectPermissionHelper permissionHelper,\n            MigrationCleaner migrationCleaner,\n            FirstGrantTimeManager firstGrantTimeManager,\n            MigrationStateManager migrationStateManager,\n            MigrationUiStateManager migrationUiStateManager,\n            Context context) {\n        mTransactionManager = transactionManager;\n        mPermissionHelper = permissionHelper;\n        mFirstGrantTimeManager = firstGrantTimeManager;\n        mContext = context;\n        mCurrentForegroundUser = context.getUser();\n        mPermissionManager = mContext.getSystemService(PermissionManager.class);\n        mMigrationStateManager = migrationStateManager;\n        mDataPermissionEnforcer = new DataPermissionEnforcer(mPermissionManager, mContext);\n        mAppOpsManagerLocal = LocalManagerRegistry.getManager(AppOpsManagerLocal.class);\n        mBackupRestore =\n                new BackupRestore(mFirstGrantTimeManager, mMigrationStateManager, mContext);\n        mMigrationUiStateManager = migrationUiStateManager;\n        migrationCleaner.attachTo(migrationStateManager);\n        mMigrationUiStateManager.attachTo(migrationStateManager);\n    }\n\n    public void onUserSwitching(UserHandle currentForegroundUser) {\n        mCurrentForegroundUser = currentForegroundUser;\n        mBackupRestore.setupForUser(currentForegroundUser);\n    }\n\n    @Override\n    public void grantHealthPermission(\n            @NonNull String packageName, @NonNull String permissionName, @NonNull UserHandle user) {\n        throwIllegalStateExceptionIfDataSyncInProgress();\n        Trace.traceBegin(TRACE_TAG_GRANT_PERMISSION, TAG_GRANT_PERMISSION);\n        mPermissionHelper.grantHealthPermission(packageName, permissionName, user);\n        Trace.traceEnd(TRACE_TAG_GRANT_PERMISSION);\n    }\n\n    @Override\n    public void revokeHealthPermission(\n            @NonNull String packageName,\n            @NonNull String permissionName,\n            @Nullable String reason,\n            @NonNull UserHandle user) {\n        throwIllegalStateExceptionIfDataSyncInProgress();\n        mPermissionHelper.revokeHealthPermission(packageName, permissionName, reason, user);\n    }\n\n    @Override\n    public void revokeAllHealthPermissions(\n            @NonNull String packageName, @Nullable String reason, @NonNull UserHandle user) {\n        throwIllegalStateExceptionIfDataSyncInProgress();\n        mPermissionHelper.revokeAllHealthPermissions(packageName, reason, user);\n    }\n\n    @Override\n    public List<String> getGrantedHealthPermissions(\n            @NonNull String packageName, @NonNull UserHandle user) {\n        throwIllegalStateExceptionIfDataSyncInProgress();\n        Trace.traceBegin(TRACE_TAG_READ_PERMISSION, TAG_READ_PERMISSION);\n        List<String> grantedPermissions =\n                mPermissionHelper.getGrantedHealthPermissions(packageName, user);\n        Trace.traceEnd(TRACE_TAG_READ_PERMISSION);\n        return grantedPermissions;\n    }\n\n    @Override\n    public long getHistoricalAccessStartDateInMilliseconds(\n            @NonNull String packageName, @NonNull UserHandle userHandle) {\n        throwIllegalStateExceptionIfDataSyncInProgress();\n        Instant date = mPermissionHelper.getHealthDataStartDateAccess(packageName, userHandle);\n        if (date == null) {\n            return Constants.DEFAULT_LONG;\n        } else {\n            return date.toEpochMilli();\n        }\n    }\n\n    /**\n     * Inserts {@code recordsParcel} into the HealthConnect database.\n     *\n     * @param recordsParcel parcel for list of records to be inserted.\n     * @param callback Callback to receive result of performing this operation. The keys returned in\n     *     {@link InsertRecordsResponseParcel} are the unique IDs of the input records. The values\n     *     are in same order as {@code record}. In case of an error or a permission failure the\n     *     HealthConnect service, {@link IInsertRecordsResponseCallback#onError} will be invoked\n     *     with a {@link HealthConnectExceptionParcel}.\n     */\n    @Override\n    public void insertRecords(\n            @NonNull AttributionSource attributionSource,\n            @NonNull RecordsParcel recordsParcel,\n            @NonNull IInsertRecordsResponseCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n        final HealthConnectServiceLogger.Builder builder =\n                new HealthConnectServiceLogger.Builder(false, INSERT_DATA)\n                        .setPackageName(attributionSource.getPackageName());\n\n        HealthConnectThreadScheduler.schedule(\n                mContext,\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        verifyPackageNameFromUid(uid, attributionSource);\n                        if (hasDataManagementPermission(uid, pid)) {\n                            throw new SecurityException(\n                                    \"Apps with android.permission.MANAGE_HEALTH_DATA permission are\"\n                                            + \" not allowed to insert records\");\n                        }\n                        enforceMemoryRateLimit(\n                                recordsParcel.getRecordsSize(),\n                                recordsParcel.getRecordsChunkSize());\n                        final List<RecordInternal<?>> recordInternals = recordsParcel.getRecords();\n                        builder.setNumberOfRecords(recordInternals.size());\n                        throwExceptionIfDataSyncInProgress();\n                        mDataPermissionEnforcer.enforceRecordsWritePermissions(\n                                recordInternals, attributionSource);\n                        boolean isInForeground = mAppOpsManagerLocal.isUidInForeground(uid);\n                        tryAcquireApiCallQuota(\n                                uid, QuotaCategory.QUOTA_CATEGORY_WRITE, isInForeground, builder);\n                        Trace.traceBegin(TRACE_TAG_INSERT, TAG_INSERT);\n                        UpsertTransactionRequest insertRequest =\n                                new UpsertTransactionRequest(\n                                        attributionSource.getPackageName(),\n                                        recordInternals,\n                                        mContext,\n                                        /* isInsertRequest */ true,\n                                        mDataPermissionEnforcer\n                                                .collectExtraWritePermissionStateMapping(\n                                                        recordInternals, attributionSource));\n                        List<String> uuids = mTransactionManager.insertAll(insertRequest);\n                        tryAndReturnResult(callback, uuids, builder);\n\n                        HealthConnectThreadScheduler.scheduleInternalTask(\n                                () -> postInsertTasks(attributionSource, recordsParcel));\n\n                        finishDataDeliveryWriteRecords(recordInternals, attributionSource);\n                        logRecordTypeSpecificUpsertMetrics(\n                                recordInternals, attributionSource.getPackageName());\n                        builder.setDataTypesFromRecordInternals(recordInternals);\n                    } catch (SQLiteException sqLiteException) {\n                        builder.setHealthDataServiceApiStatusError(HealthConnectException.ERROR_IO);\n                        Slog.e(TAG, \"SQLiteException: \", sqLiteException);\n                        tryAndThrowException(\n                                callback, sqLiteException, HealthConnectException.ERROR_IO);\n                    } catch (SecurityException securityException) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_SECURITY);\n                        Slog.e(TAG, \"SecurityException: \", securityException);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (HealthConnectException healthConnectException) {\n                        builder.setHealthDataServiceApiStatusError(\n                                healthConnectException.getErrorCode());\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception e) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n                        Slog.e(TAG, \"Exception: \", e);\n                        tryAndThrowException(callback, e, ERROR_INTERNAL);\n                    } finally {\n                        Trace.traceEnd(TRACE_TAG_INSERT);\n                        builder.build().log();\n                    }\n                },\n                uid,\n                false);\n    }\n\n    private void postInsertTasks(\n            @NonNull AttributionSource attributionSource, @NonNull RecordsParcel recordsParcel) {\n        Trace.traceBegin(TRACE_TAG_INSERT_SUBTASKS, TAG_INSERT.concat(\"PostInsertTasks\"));\n\n        ActivityDateHelper.getInstance().insertRecordDate(recordsParcel.getRecords());\n        Set<Integer> recordsTypesInsertedSet =\n                recordsParcel.getRecords().stream()\n                        .map(RecordInternal::getRecordType)\n                        .collect(Collectors.toSet());\n        // Update AppInfo table with the record types of records inserted in the request for the\n        // current package.\n        AppInfoHelper.getInstance()\n                .updateAppInfoRecordTypesUsedOnInsert(\n                        recordsTypesInsertedSet, attributionSource.getPackageName());\n\n        Trace.traceEnd(TRACE_TAG_INSERT_SUBTASKS);\n    }\n\n    /**\n     * Returns aggregation results based on the {@code request} into the HealthConnect database.\n     *\n     * @param request represents the request using which the aggregation is to be performed.\n     * @param callback Callback to receive result of performing this operation.\n     */\n    public void aggregateRecords(\n            @NonNull AttributionSource attributionSource,\n            AggregateDataRequestParcel request,\n            IAggregateRecordsResponseCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n        final boolean holdsDataManagementPermission = hasDataManagementPermission(uid, pid);\n        final HealthConnectServiceLogger.Builder builder =\n                new HealthConnectServiceLogger.Builder(\n                                holdsDataManagementPermission, READ_AGGREGATED_DATA)\n                        .setPackageName(attributionSource.getPackageName());\n\n        HealthConnectThreadScheduler.schedule(\n                mContext,\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        verifyPackageNameFromUid(uid, attributionSource);\n                        builder.setNumberOfRecords(request.getAggregateIds().length);\n                        throwExceptionIfDataSyncInProgress();\n                        List<Integer> recordTypesToTest = new ArrayList<>();\n                        for (int aggregateId : request.getAggregateIds()) {\n                            recordTypesToTest.addAll(\n                                    AggregationTypeIdMapper.getInstance()\n                                            .getAggregationTypeFor(aggregateId)\n                                            .getApplicableRecordTypeIds());\n                        }\n\n                        if (!holdsDataManagementPermission) {\n                            boolean isInForeground = mAppOpsManagerLocal.isUidInForeground(uid);\n                            if (!isInForeground) {\n                                throwSecurityException(\n                                        attributionSource.getPackageName()\n                                                + \"must be in foreground to call aggregate method\");\n                            }\n                            mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                    recordTypesToTest, attributionSource);\n                            tryAcquireApiCallQuota(\n                                    uid,\n                                    RateLimiter.QuotaCategory.QUOTA_CATEGORY_READ,\n                                    isInForeground,\n                                    builder);\n                        }\n                        callback.onResult(\n                                new AggregateTransactionRequest(\n                                                attributionSource.getPackageName(), request)\n                                        .getAggregateDataResponseParcel());\n                        finishDataDeliveryRead(recordTypesToTest, attributionSource);\n                        builder.setDataTypesFromRecordTypes(recordTypesToTest)\n                                .setHealthDataServiceApiStatusSuccess();\n                    } catch (SQLiteException sqLiteException) {\n                        builder.setHealthDataServiceApiStatusError(HealthConnectException.ERROR_IO);\n                        Slog.e(TAG, \"SQLiteException: \", sqLiteException);\n                        tryAndThrowException(\n                                callback, sqLiteException, HealthConnectException.ERROR_IO);\n                    } catch (SecurityException securityException) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_SECURITY);\n                        Slog.e(TAG, \"SecurityException: \", securityException);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (HealthConnectException healthConnectException) {\n                        builder.setHealthDataServiceApiStatusError(\n                                healthConnectException.getErrorCode());\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception e) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n                        Slog.e(TAG, \"Exception: \", e);\n                        tryAndThrowException(callback, e, ERROR_INTERNAL);\n                    } finally {\n                        builder.build().log();\n                    }\n                },\n                uid,\n                holdsDataManagementPermission);\n    }\n\n    /**\n     * Read records {@code recordsParcel} from HealthConnect database.\n     *\n     * @param request ReadRecordsRequestParcel is parcel for the request object containing {@link\n     *     RecordIdFiltersParcel}.\n     * @param callback Callback to receive result of performing this operation. The records are\n     *     returned in {@link RecordsParcel} . In case of an error or a permission failure the\n     *     HealthConnect service, {@link IReadRecordsResponseCallback#onError} will be invoked with\n     *     a {@link HealthConnectExceptionParcel}.\n     */\n    @Override\n    public void readRecords(\n            @NonNull AttributionSource attributionSource,\n            @NonNull ReadRecordsRequestParcel request,\n            @NonNull IReadRecordsResponseCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n        final boolean holdsDataManagementPermission = hasDataManagementPermission(uid, pid);\n        final HealthConnectServiceLogger.Builder builder =\n                new HealthConnectServiceLogger.Builder(holdsDataManagementPermission, READ_DATA)\n                        .setPackageName(attributionSource.getPackageName());\n\n        HealthConnectThreadScheduler.schedule(\n                mContext,\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        verifyPackageNameFromUid(uid, attributionSource);\n                        throwExceptionIfDataSyncInProgress();\n                        AtomicBoolean enforceSelfRead = new AtomicBoolean();\n                        if (!holdsDataManagementPermission) {\n                            boolean isInForeground = mAppOpsManagerLocal.isUidInForeground(uid);\n                            // If requesting app has only write permission allowed but no read\n                            // permission for the record type or if app is not in foreground then\n                            // allow to read its own records.\n                            enforceSelfRead.set(\n                                    mDataPermissionEnforcer.enforceReadAccessAndGetEnforceSelfRead(\n                                                    request.getRecordType(), attributionSource)\n                                            || !isInForeground);\n                            if (Constants.DEBUG) {\n                                Slog.d(\n                                        TAG,\n                                        \"Enforce self read for package \"\n                                                + attributionSource.getPackageName()\n                                                + \":\"\n                                                + enforceSelfRead.get());\n                            }\n                            tryAcquireApiCallQuota(\n                                    uid,\n                                    QuotaCategory.QUOTA_CATEGORY_READ,\n                                    isInForeground,\n                                    builder);\n                        }\n                        final Map<String, Boolean> extraReadPermsToGrantState =\n                                Collections.unmodifiableMap(\n                                        mDataPermissionEnforcer\n                                                .collectExtraReadPermissionToStateMapping(\n                                                        Set.of(request.getRecordType()),\n                                                        attributionSource));\n\n                        Trace.traceBegin(TRACE_TAG_READ, TAG_READ);\n                        try {\n                            long startDateAccess = request.getStartTime();\n                            if (!holdsDataManagementPermission) {\n                                Instant startInstant =\n                                        mPermissionHelper.getHealthDataStartDateAccess(\n                                                attributionSource.getPackageName(), userHandle);\n                                if (startInstant == null) {\n                                    throwExceptionIncorrectPermissionState();\n                                }\n\n                                // Always set the startDateAccess for local time filter, as for\n                                // local date time we use it in conjunction with the time filter\n                                // start-time\n                                if (request.usesLocalTimeFilter()\n                                        || startInstant.toEpochMilli() > startDateAccess) {\n                                    startDateAccess = startInstant.toEpochMilli();\n                                }\n                            }\n                            Pair<List<RecordInternal<?>>, Long> readRecordsResponse =\n                                    mTransactionManager.readRecordsAndGetNextToken(\n                                            new ReadTransactionRequest(\n                                                    attributionSource.getPackageName(),\n                                                    request,\n                                                    startDateAccess,\n                                                    enforceSelfRead.get(),\n                                                    extraReadPermsToGrantState));\n                            builder.setNumberOfRecords(readRecordsResponse.first.size());\n                            long pageToken =\n                                    request.getRecordIdFiltersParcel() == null\n                                            ? readRecordsResponse.second\n                                            : DEFAULT_LONG;\n                            if (pageToken != DEFAULT_LONG) {\n                                // pagetoken is used here to store sorting order of the result.\n                                // An even pagetoken indicate ascending and Odd page token indicate\n                                // descending sort order. This detail from page token will be used\n                                // in next read request to have same sort order.\n                                pageToken =\n                                        request.isAscending() ? pageToken * 2 : pageToken * 2 + 1;\n                            }\n\n                            if (Constants.DEBUG) {\n                                Slog.d(TAG, \"pageToken: \" + pageToken);\n                            }\n\n                            final String packageName = attributionSource.getPackageName();\n                            final List<Integer> recordTypes =\n                                    Collections.singletonList(request.getRecordType());\n                            // Calls from controller APK should not be recorded in access logs\n                            // If an app is reading only its own data then it is not recorded in\n                            // access logs.\n                            boolean requiresLogging =\n                                    !holdsDataManagementPermission && !enforceSelfRead.get();\n                            if (requiresLogging) {\n                                Trace.traceBegin(\n                                        TRACE_TAG_READ_SUBTASKS, TAG_READ.concat(\"AddAccessLog\"));\n                                AccessLogsHelper.getInstance()\n                                        .addAccessLog(packageName, recordTypes, READ);\n                                Trace.traceEnd(TRACE_TAG_READ_SUBTASKS);\n                            }\n                            callback.onResult(\n                                    new ReadRecordsResponseParcel(\n                                            new RecordsParcel(readRecordsResponse.first),\n                                            pageToken));\n                            finishDataDeliveryRead(request.getRecordType(), attributionSource);\n                            if (requiresLogging) {\n                                logRecordTypeSpecificReadMetrics(\n                                        readRecordsResponse.first, packageName);\n                            }\n                            builder.setDataTypesFromRecordInternals(readRecordsResponse.first)\n                                    .setHealthDataServiceApiStatusSuccess();\n                        } catch (TypeNotPresentException exception) {\n                            // All the requested package names are not present, so simply\n                            // return an empty list\n                            if (ReadTransactionRequest.TYPE_NOT_PRESENT_PACKAGE_NAME.equals(\n                                    exception.typeName())) {\n                                if (Constants.DEBUG) {\n                                    Slog.d(\n                                            TAG,\n                                            \"No app info recorded for \"\n                                                    + attributionSource.getPackageName());\n                                }\n                                callback.onResult(\n                                        new ReadRecordsResponseParcel(\n                                                new RecordsParcel(new ArrayList<>()),\n                                                DEFAULT_LONG));\n                                builder.setHealthDataServiceApiStatusSuccess();\n                            } else {\n                                builder.setHealthDataServiceApiStatusError(\n                                        HealthConnectException.ERROR_UNKNOWN);\n                                throw exception;\n                            }\n                        }\n                    } catch (SQLiteException sqLiteException) {\n                        builder.setHealthDataServiceApiStatusError(HealthConnectException.ERROR_IO);\n                        Slog.e(TAG, \"SQLiteException: \", sqLiteException);\n                        tryAndThrowException(\n                                callback, sqLiteException, HealthConnectException.ERROR_IO);\n                    } catch (SecurityException securityException) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_SECURITY);\n                        Slog.e(TAG, \"SecurityException: \", securityException);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (IllegalStateException illegalStateException) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n                        Slog.e(TAG, \"IllegalStateException: \", illegalStateException);\n                        tryAndThrowException(callback, illegalStateException, ERROR_INTERNAL);\n                    } catch (HealthConnectException healthConnectException) {\n                        builder.setHealthDataServiceApiStatusError(\n                                healthConnectException.getErrorCode());\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception e) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n                        Slog.e(TAG, \"Exception: \", e);\n                        tryAndThrowException(callback, e, ERROR_INTERNAL);\n                    } finally {\n                        Trace.traceEnd(TRACE_TAG_READ);\n                        builder.build().log();\n                    }\n                },\n                uid,\n                holdsDataManagementPermission);\n    }\n\n    /**\n     * Updates {@code recordsParcel} into the HealthConnect database.\n     *\n     * @param recordsParcel parcel for list of records to be updated.\n     * @param callback Callback to receive result of performing this operation. In case of an error\n     *     or a permission failure the HealthConnect service, {@link IEmptyResponseCallback#onError}\n     *     will be invoked with a {@link HealthConnectException}.\n     */\n    @Override\n    public void updateRecords(\n            @NonNull AttributionSource attributionSource,\n            @NonNull RecordsParcel recordsParcel,\n            @NonNull IEmptyResponseCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n        final HealthConnectServiceLogger.Builder builder =\n                new HealthConnectServiceLogger.Builder(false, UPDATE_DATA)\n                        .setPackageName(attributionSource.getPackageName());\n        HealthConnectThreadScheduler.schedule(\n                mContext,\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        verifyPackageNameFromUid(uid, attributionSource);\n                        if (hasDataManagementPermission(uid, pid)) {\n                            throw new SecurityException(\n                                    \"Apps with android.permission.MANAGE_HEALTH_DATA permission are\"\n                                            + \" not allowed to insert records\");\n                        }\n                        enforceMemoryRateLimit(\n                                recordsParcel.getRecordsSize(),\n                                recordsParcel.getRecordsChunkSize());\n                        final List<RecordInternal<?>> recordInternals = recordsParcel.getRecords();\n                        builder.setNumberOfRecords(recordInternals.size());\n                        throwExceptionIfDataSyncInProgress();\n                        mDataPermissionEnforcer.enforceRecordsWritePermissions(\n                                recordInternals, attributionSource);\n                        boolean isInForeground = mAppOpsManagerLocal.isUidInForeground(uid);\n                        tryAcquireApiCallQuota(\n                                uid, QuotaCategory.QUOTA_CATEGORY_WRITE, isInForeground, builder);\n                        UpsertTransactionRequest request =\n                                new UpsertTransactionRequest(\n                                        attributionSource.getPackageName(),\n                                        recordInternals,\n                                        mContext,\n                                        /* isInsertRequest */ false,\n                                        mDataPermissionEnforcer\n                                                .collectExtraWritePermissionStateMapping(\n                                                        recordInternals, attributionSource));\n                        mTransactionManager.updateAll(request);\n                        tryAndReturnResult(callback, builder);\n                        finishDataDeliveryWriteRecords(recordInternals, attributionSource);\n                        logRecordTypeSpecificUpsertMetrics(\n                                recordInternals, attributionSource.getPackageName());\n                        builder.setDataTypesFromRecordInternals(recordInternals);\n                        // Update activity dates table\n                        HealthConnectThreadScheduler.scheduleInternalTask(\n                                () ->\n                                        ActivityDateHelper.getInstance()\n                                                .reSyncByRecordTypeIds(\n                                                        recordInternals.stream()\n                                                                .map(RecordInternal::getRecordType)\n                                                                .toList()));\n                    } catch (SecurityException securityException) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_SECURITY);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (SQLiteException sqLiteException) {\n                        builder.setHealthDataServiceApiStatusError(HealthConnectException.ERROR_IO);\n                        Slog.e(TAG, \"SqlException: \", sqLiteException);\n                        tryAndThrowException(\n                                callback, sqLiteException, HealthConnectException.ERROR_IO);\n                    } catch (IllegalArgumentException illegalArgumentException) {\n                        builder.setHealthDataServiceApiStatusError(\n                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n\n                        Slog.e(TAG, \"IllegalArgumentException: \", illegalArgumentException);\n                        tryAndThrowException(\n                                callback,\n                                illegalArgumentException,\n                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n                    } catch (HealthConnectException healthConnectException) {\n                        builder.setHealthDataServiceApiStatusError(\n                                healthConnectException.getErrorCode());\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception e) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n\n                        Slog.e(TAG, \"Exception: \", e);\n                        tryAndThrowException(callback, e, ERROR_INTERNAL);\n                    } finally {\n                        builder.build().log();\n                    }\n                },\n                uid,\n                false);\n    }\n\n    /**\n     * @see HealthConnectManager#getChangeLogToken\n     */\n    @Override\n    public void getChangeLogToken(\n            @NonNull AttributionSource attributionSource,\n            @NonNull ChangeLogTokenRequest request,\n            @NonNull IGetChangeLogTokenCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n        final HealthConnectServiceLogger.Builder builder =\n                new HealthConnectServiceLogger.Builder(false, GET_CHANGES_TOKEN)\n                        .setPackageName(attributionSource.getPackageName());\n        HealthConnectThreadScheduler.schedule(\n                mContext,\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        verifyPackageNameFromUid(uid, attributionSource);\n                        tryAcquireApiCallQuota(\n                                uid,\n                                QuotaCategory.QUOTA_CATEGORY_READ,\n                                mAppOpsManagerLocal.isUidInForeground(uid),\n                                builder);\n                        throwExceptionIfDataSyncInProgress();\n                        if (request.getRecordTypes().isEmpty()) {\n                            throw new IllegalArgumentException(\n                                    \"Requested record types must not be empty.\");\n                        }\n                        mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                request.getRecordTypesList(), attributionSource);\n                        callback.onResult(\n                                new ChangeLogTokenResponse(\n                                        ChangeLogsRequestHelper.getInstance()\n                                                .getToken(\n                                                        attributionSource.getPackageName(),\n                                                        request)));\n                        builder.setHealthDataServiceApiStatusSuccess();\n                    } catch (SQLiteException sqLiteException) {\n                        builder.setHealthDataServiceApiStatusError(HealthConnectException.ERROR_IO);\n                        Slog.e(TAG, \"SQLiteException: \", sqLiteException);\n                        tryAndThrowException(\n                                callback, sqLiteException, HealthConnectException.ERROR_IO);\n                    } catch (SecurityException securityException) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_SECURITY);\n                        Slog.e(TAG, \"SecurityException: \", securityException);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (IllegalArgumentException illegalArgumentException) {\n                        logger.setHealthDataServiceApiStatusError(\n                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n                        Slog.e(TAG, \"IllegalArgumentException: \", illegalArgumentException);\n                        tryAndThrowException(\n                                callback,\n                                illegalArgumentException,\n                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n                    } catch (HealthConnectException healthConnectException) {\n                        builder.setHealthDataServiceApiStatusError(\n                                healthConnectException.getErrorCode());\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception e) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n                        tryAndThrowException(callback, e, ERROR_INTERNAL);\n                    }\n                    {\n                        builder.build().log();\n                    }\n                },\n                uid,\n                false);\n    }\n\n    /**\n     * @hide\n     * @see HealthConnectManager#getChangeLogs\n     */\n    @Override\n    public void getChangeLogs(\n            @NonNull AttributionSource attributionSource,\n            @NonNull ChangeLogsRequest token,\n            IChangeLogsResponseCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n        final String callerPackageName = Objects.requireNonNull(attributionSource.getPackageName());\n        final HealthConnectServiceLogger.Builder builder =\n                new HealthConnectServiceLogger.Builder(false, GET_CHANGES)\n                        .setPackageName(callerPackageName);\n\n        HealthConnectThreadScheduler.schedule(\n                mContext,\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        verifyPackageNameFromUid(uid, attributionSource);\n                        throwExceptionIfDataSyncInProgress();\n                        ChangeLogsRequestHelper.TokenRequest changeLogsTokenRequest =\n                                ChangeLogsRequestHelper.getRequest(\n                                        attributionSource.getPackageName(), token.getToken());\n                        mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                changeLogsTokenRequest.getRecordTypes(), attributionSource);\n                        boolean isInForeground = mAppOpsManagerLocal.isUidInForeground(uid);\n                        if (!isInForeground) {\n                            throwSecurityException(\n                                    attributionSource.getPackageName()\n                                            + \" must be in foreground to read the change logs\");\n                        }\n                        tryAcquireApiCallQuota(\n                                uid, QuotaCategory.QUOTA_CATEGORY_READ, isInForeground, builder);\n                        Instant startDateInstant =\n                                mPermissionHelper.getHealthDataStartDateAccess(\n                                        attributionSource.getPackageName(), userHandle);\n                        if (startDateInstant == null) {\n                            throwExceptionIncorrectPermissionState();\n                        }\n                        long startDateAccess = startDateInstant.toEpochMilli();\n                        final ChangeLogsHelper.ChangeLogsResponse changeLogsResponse =\n                                ChangeLogsHelper.getInstance()\n                                        .getChangeLogs(changeLogsTokenRequest, token);\n\n                        Map<Integer, List<UUID>> recordTypeToInsertedUuids =\n                                ChangeLogsHelper.getRecordTypeToInsertedUuids(\n                                        changeLogsResponse.getChangeLogsMap());\n\n                        Map<String, Boolean> extraReadPermsToGrantState =\n                                mDataPermissionEnforcer.collectExtraReadPermissionToStateMapping(\n                                        recordTypeToInsertedUuids.keySet(), attributionSource);\n\n                        List<RecordInternal<?>> recordInternals =\n                                mTransactionManager.readRecords(\n                                        new ReadTransactionRequest(\n                                                callerPackageName,\n                                                recordTypeToInsertedUuids,\n                                                startDateAccess,\n                                                extraReadPermsToGrantState));\n\n                        List<DeletedLog> deletedLogs =\n                                ChangeLogsHelper.getDeletedLogs(\n                                        changeLogsResponse.getChangeLogsMap());\n\n                        callback.onResult(\n                                new ChangeLogsResponse(\n                                        new RecordsParcel(recordInternals),\n                                        deletedLogs,\n                                        changeLogsResponse.getNextPageToken(),\n                                        changeLogsResponse.hasMorePages()));\n                        finishDataDeliveryRead(\n                                changeLogsTokenRequest.getRecordTypes(), attributionSource);\n                        builder.setHealthDataServiceApiStatusSuccess()\n                                .setNumberOfRecords(recordInternals.size() + deletedLogs.size())\n                                .setDataTypesFromRecordInternals(recordInternals);\n                    } catch (IllegalArgumentException illegalArgumentException) {\n                        builder.setHealthDataServiceApiStatusError(\n                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n                        Slog.e(TAG, \"IllegalArgumentException: \", illegalArgumentException);\n                        tryAndThrowException(\n                                callback,\n                                illegalArgumentException,\n                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n                    } catch (SQLiteException sqLiteException) {\n                        builder.setHealthDataServiceApiStatusError(HealthConnectException.ERROR_IO);\n                        Slog.e(TAG, \"SQLiteException: \", sqLiteException);\n                        tryAndThrowException(\n                                callback, sqLiteException, HealthConnectException.ERROR_IO);\n                    } catch (SecurityException securityException) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_SECURITY);\n                        Slog.e(TAG, \"SecurityException: \", securityException);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (IllegalStateException illegalStateException) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n                        Slog.e(TAG, \"IllegalStateException: \", illegalStateException);\n                        tryAndThrowException(callback, illegalStateException, ERROR_INTERNAL);\n                    } catch (HealthConnectException healthConnectException) {\n                        builder.setHealthDataServiceApiStatusError(\n                                healthConnectException.getErrorCode());\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception exception) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n                        Slog.e(TAG, \"Exception: \", exception);\n                        tryAndThrowException(callback, exception, ERROR_INTERNAL);\n                    } finally {\n                        builder.build().log();\n                    }\n                },\n                uid,\n                false);\n    }\n\n    /**\n     * API to delete records based on {@code request}\n     *\n     * <p>NOTE: Though internally we only need a single API to handle deletes as SDK code transform\n     * all its delete requests to {@link DeleteUsingFiltersRequestParcel}, we have this separation\n     * to make sure no non-controller APIs can use {@link\n     * HealthConnectServiceImpl#deleteUsingFilters} API\n     */\n    @Override\n    public void deleteUsingFiltersForSelf(\n            @NonNull AttributionSource attributionSource,\n            @NonNull DeleteUsingFiltersRequestParcel request,\n            @NonNull IEmptyResponseCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n        final boolean holdsDataManagementPermission = hasDataManagementPermission(uid, pid);\n        final HealthConnectServiceLogger.Builder builder =\n                new HealthConnectServiceLogger.Builder(holdsDataManagementPermission, DELETE_DATA)\n                        .setPackageName(attributionSource.getPackageName());\n\n        HealthConnectThreadScheduler.schedule(\n                mContext,\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        verifyPackageNameFromUid(uid, attributionSource);\n                        throwExceptionIfDataSyncInProgress();\n                        List<Integer> recordTypeIdsToDelete =\n                                (!request.getRecordTypeFilters().isEmpty())\n                                        ? request.getRecordTypeFilters()\n                                        : new ArrayList<>(\n                                                RecordMapper.getInstance()\n                                                        .getRecordIdToExternalRecordClassMap()\n                                                        .keySet());\n                        // Requests from non controller apps are not allowed to use non-id\n                        // filters\n                        request.setPackageNameFilters(\n                                Collections.singletonList(attributionSource.getPackageName()));\n\n                        if (!holdsDataManagementPermission) {\n                            mDataPermissionEnforcer.enforceRecordIdsWritePermissions(\n                                    recordTypeIdsToDelete, attributionSource);\n                            tryAcquireApiCallQuota(\n                                    uid,\n                                    QuotaCategory.QUOTA_CATEGORY_WRITE,\n                                    mAppOpsManagerLocal.isUidInForeground(uid),\n                                    builder);\n                        }\n\n                        deleteUsingFiltersInternal(\n                                attributionSource,\n                                request,\n                                callback,\n                                builder,\n                                recordTypeIdsToDelete,\n                                uid,\n                                pid);\n                    } catch (SQLiteException sqLiteException) {\n                        builder.setHealthDataServiceApiStatusError(HealthConnectException.ERROR_IO);\n                        tryAndThrowException(\n                                callback, sqLiteException, HealthConnectException.ERROR_IO);\n                    } catch (IllegalArgumentException illegalArgumentException) {\n                        builder.setHealthDataServiceApiStatusError(\n                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n                        Slog.e(TAG, \"IllegalArgumentException: \", illegalArgumentException);\n                        tryAndThrowException(\n                                callback,\n                                illegalArgumentException,\n                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n                    } catch (SecurityException securityException) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_SECURITY);\n                        Slog.e(TAG, \"SecurityException: \", securityException);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (HealthConnectException healthConnectException) {\n                        builder.setHealthDataServiceApiStatusError(\n                                healthConnectException.getErrorCode());\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception exception) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n                        Slog.e(TAG, \"Exception: \", exception);\n                        tryAndThrowException(callback, exception, ERROR_INTERNAL);\n                    } finally {\n                        builder.build().log();\n                    }\n                },\n                uid,\n                holdsDataManagementPermission);\n    }\n\n    /**\n     * API to delete records based on {@code request}\n     *\n     * <p>NOTE: Though internally we only need a single API to handle deletes as SDK code transform\n     * all its delete requests to {@link DeleteUsingFiltersRequestParcel}, we have this separation\n     * to make sure no non-controller APIs can use this API\n     */\n    @Override\n    public void deleteUsingFilters(\n            @NonNull AttributionSource attributionSource,\n            @NonNull DeleteUsingFiltersRequestParcel request,\n            @NonNull IEmptyResponseCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n        final boolean holdsDataManagementPermission = hasDataManagementPermission(uid, pid);\n        final HealthConnectServiceLogger.Builder builder =\n                new HealthConnectServiceLogger.Builder(holdsDataManagementPermission, DELETE_DATA)\n                        .setPackageName(attributionSource.getPackageName());\n\n        HealthConnectThreadScheduler.schedule(\n                mContext,\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        verifyPackageNameFromUid(uid, attributionSource);\n                        throwExceptionIfDataSyncInProgress();\n                        mContext.enforcePermission(MANAGE_HEALTH_DATA_PERMISSION, pid, uid, null);\n                        List<Integer> recordTypeIdsToDelete =\n                                (!request.getRecordTypeFilters().isEmpty())\n                                        ? request.getRecordTypeFilters()\n                                        : new ArrayList<>(\n                                                RecordMapper.getInstance()\n                                                        .getRecordIdToExternalRecordClassMap()\n                                                        .keySet());\n\n                        deleteUsingFiltersInternal(\n                                attributionSource,\n                                request,\n                                callback,\n                                builder,\n                                recordTypeIdsToDelete,\n                                uid,\n                                pid);\n                    } catch (SQLiteException sqLiteException) {\n                        builder.setHealthDataServiceApiStatusError(HealthConnectException.ERROR_IO);\n                        tryAndThrowException(\n                                callback, sqLiteException, HealthConnectException.ERROR_IO);\n                    } catch (IllegalArgumentException illegalArgumentException) {\n                        builder.setHealthDataServiceApiStatusError(\n                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n                        Slog.e(TAG, \"IllegalArgumentException: \", illegalArgumentException);\n                        tryAndThrowException(\n                                callback,\n                                illegalArgumentException,\n                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n                    } catch (SecurityException securityException) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_SECURITY);\n                        Slog.e(TAG, \"SecurityException: \", securityException);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (HealthConnectException healthConnectException) {\n                        builder.setHealthDataServiceApiStatusError(\n                                healthConnectException.getErrorCode());\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception exception) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n                        Slog.e(TAG, \"Exception: \", exception);\n                        tryAndThrowException(callback, exception, ERROR_INTERNAL);\n                    } finally {\n                        builder.build().log();\n                    }\n                },\n                uid,\n                holdsDataManagementPermission);\n    }\n\n    private void deleteUsingFiltersInternal(\n            @NonNull AttributionSource attributionSource,\n            @NonNull DeleteUsingFiltersRequestParcel request,\n            @NonNull IEmptyResponseCallback callback,\n            @NonNull HealthConnectServiceLogger.Builder builder,\n            List<Integer> recordTypeIdsToDelete,\n            int uid,\n            int pid) {\n        if (request.usesIdFilters() && request.usesNonIdFilters()) {\n            throw new IllegalArgumentException(\n                    \"Requests with both id and non-id filters are not\" + \" supported\");\n        }\n        int numberOfRecordsDeleted =\n                mTransactionManager.deleteAll(\n                        new DeleteTransactionRequest(attributionSource.getPackageName(), request)\n                                .setHasManageHealthDataPermission(\n                                        hasDataManagementPermission(uid, pid)));\n        tryAndReturnResult(callback, builder);\n        finishDataDeliveryWrite(recordTypeIdsToDelete, attributionSource);\n        HealthConnectThreadScheduler.scheduleInternalTask(\n                () -> postDeleteTasks(recordTypeIdsToDelete));\n\n        builder.setNumberOfRecords(numberOfRecordsDeleted)\n                .setDataTypesFromRecordTypes(recordTypeIdsToDelete);\n    }\n\n    /** API to get Priority for {@code dataCategory} */\n    @Override\n    public void getCurrentPriority(\n            @NonNull String packageName,\n            @HealthDataCategory.Type int dataCategory,\n            @NonNull IGetPriorityResponseCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n        HealthConnectThreadScheduler.scheduleControllerTask(\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        mContext.enforcePermission(MANAGE_HEALTH_DATA_PERMISSION, pid, uid, null);\n                        throwExceptionIfDataSyncInProgress();\n                        List<DataOrigin> dataOriginInPriorityOrder =\n                                HealthDataCategoryPriorityHelper.getInstance()\n                                        .getPriorityOrder(dataCategory)\n                                        .stream()\n                                        .map(\n                                                (name) ->\n                                                        new DataOrigin.Builder()\n                                                                .setPackageName(name)\n                                                                .build())\n                                        .collect(Collectors.toList());\n                        callback.onResult(\n                                new GetPriorityResponseParcel(\n                                        new FetchDataOriginsPriorityOrderResponse(\n                                                dataOriginInPriorityOrder)));\n                    } catch (SQLiteException sqLiteException) {\n                        Slog.e(TAG, \"SQLiteException: \", sqLiteException);\n                        tryAndThrowException(\n                                callback, sqLiteException, HealthConnectException.ERROR_IO);\n                    } catch (SecurityException securityException) {\n                        Slog.e(TAG, \"SecurityException: \", securityException);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (HealthConnectException healthConnectException) {\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception exception) {\n                        Slog.e(TAG, \"Exception: \", exception);\n                        tryAndThrowException(callback, exception, ERROR_INTERNAL);\n                    }\n                });\n    }\n\n    /** API to update priority for permission category(ies) */\n    @Override\n    public void updatePriority(\n            @NonNull String packageName,\n            @NonNull UpdatePriorityRequestParcel updatePriorityRequest,\n            @NonNull IEmptyResponseCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n        HealthConnectThreadScheduler.scheduleControllerTask(\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        mContext.enforcePermission(MANAGE_HEALTH_DATA_PERMISSION, pid, uid, null);\n                        throwExceptionIfDataSyncInProgress();\n                        HealthDataCategoryPriorityHelper.getInstance()\n                                .setPriorityOrder(\n                                        updatePriorityRequest.getDataCategory(),\n                                        updatePriorityRequest.getPackagePriorityOrder());\n                        callback.onResult();\n                    } catch (SQLiteException sqLiteException) {\n                        Slog.e(TAG, \"SQLiteException: \", sqLiteException);\n                        tryAndThrowException(\n                                callback, sqLiteException, HealthConnectException.ERROR_IO);\n                    } catch (SecurityException securityException) {\n                        Slog.e(TAG, \"SecurityException: \", securityException);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (HealthConnectException healthConnectException) {\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception exception) {\n                        Slog.e(TAG, \"Exception: \", exception);\n                        tryAndThrowException(callback, exception, ERROR_INTERNAL);\n                    }\n                });\n    }\n\n    @Override\n    public void setRecordRetentionPeriodInDays(\n            int days, @NonNull UserHandle user, IEmptyResponseCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n        HealthConnectThreadScheduler.scheduleControllerTask(\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        mContext.enforcePermission(MANAGE_HEALTH_DATA_PERMISSION, pid, uid, null);\n                        throwExceptionIfDataSyncInProgress();\n                        AutoDeleteService.setRecordRetentionPeriodInDays(days);\n                        callback.onResult();\n                    } catch (SQLiteException sqLiteException) {\n                        Slog.e(TAG, \"SQLiteException: \", sqLiteException);\n                        tryAndThrowException(\n                                callback, sqLiteException, HealthConnectException.ERROR_IO);\n                    } catch (SecurityException securityException) {\n                        Slog.e(TAG, \"SecurityException: \", securityException);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (HealthConnectException healthConnectException) {\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception exception) {\n                        Slog.e(TAG, \"Exception: \", exception);\n                        tryAndThrowException(callback, exception, ERROR_INTERNAL);\n                    }\n                });\n    }\n\n    @Override\n    public int getRecordRetentionPeriodInDays(@NonNull UserHandle user) {\n        enforceIsForegroundUser(getCallingUserHandle());\n        throwExceptionIfDataSyncInProgress();\n        try {\n            mContext.enforceCallingPermission(MANAGE_HEALTH_DATA_PERMISSION, null);\n            return AutoDeleteService.getRecordRetentionPeriodInDays();\n        } catch (Exception e) {\n            if (e instanceof SecurityException) {\n                throw e;\n            }\n            Slog.e(TAG, \"Unable to get record retention period for \" + user);\n        }\n\n        throw new RuntimeException();\n    }\n\n    /**\n     * Returns information, represented by {@code ApplicationInfoResponse}, for all the packages\n     * that have contributed to the health connect DB.\n     *\n     * @param callback Callback to receive result of performing this operation. In case of an error\n     *     or a permission failure the HealthConnect service, {@link IEmptyResponseCallback#onError}\n     *     will be invoked with a {@link HealthConnectException}.\n     */\n    @Override\n    public void getContributorApplicationsInfo(@NonNull IApplicationInfoResponseCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n        HealthConnectThreadScheduler.scheduleControllerTask(\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        mContext.enforcePermission(MANAGE_HEALTH_DATA_PERMISSION, pid, uid, null);\n                        throwExceptionIfDataSyncInProgress();\n                        List<AppInfo> applicationInfos =\n                                AppInfoHelper.getInstance().getApplicationInfosWithRecordTypes();\n\n                        callback.onResult(new ApplicationInfoResponseParcel(applicationInfos));\n                    } catch (SQLiteException sqLiteException) {\n                        Slog.e(TAG, \"SqlException: \", sqLiteException);\n                        tryAndThrowException(\n                                callback, sqLiteException, HealthConnectException.ERROR_IO);\n                    } catch (SecurityException securityException) {\n                        Slog.e(TAG, \"SecurityException: \", securityException);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (HealthConnectException healthConnectException) {\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception e) {\n                        Slog.e(TAG, \"Exception: \", e);\n                        tryAndThrowException(callback, e, ERROR_INTERNAL);\n                    }\n                });\n    }\n\n    /** Retrieves {@link RecordTypeInfoResponse} for each RecordType. */\n    @Override\n    public void queryAllRecordTypesInfo(@NonNull IRecordTypeInfoResponseCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n        HealthConnectThreadScheduler.scheduleControllerTask(\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        mContext.enforcePermission(MANAGE_HEALTH_DATA_PERMISSION, pid, uid, null);\n                        throwExceptionIfDataSyncInProgress();\n                        callback.onResult(\n                                new RecordTypeInfoResponseParcel(\n                                        getPopulatedRecordTypeInfoResponses()));\n                    } catch (SQLiteException sqLiteException) {\n                        tryAndThrowException(\n                                callback, sqLiteException, HealthConnectException.ERROR_IO);\n                    } catch (SecurityException securityException) {\n                        Slog.e(TAG, \"SecurityException: \", securityException);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (HealthConnectException healthConnectException) {\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception exception) {\n                        tryAndThrowException(callback, exception, ERROR_INTERNAL);\n                    }\n                });\n    }\n\n    /**\n     * @see HealthConnectManager#queryAccessLogs\n     */\n    @Override\n    public void queryAccessLogs(@NonNull String packageName, IAccessLogsResponseCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n\n        HealthConnectThreadScheduler.scheduleControllerTask(\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        mContext.enforcePermission(MANAGE_HEALTH_DATA_PERMISSION, pid, uid, null);\n                        throwExceptionIfDataSyncInProgress();\n                        final List<AccessLog> accessLogsList =\n                                AccessLogsHelper.getInstance().queryAccessLogs();\n                        callback.onResult(new AccessLogsResponseParcel(accessLogsList));\n                    } catch (SecurityException securityException) {\n                        Slog.e(TAG, \"SecurityException: \", securityException);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (HealthConnectException healthConnectException) {\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception exception) {\n                        Slog.e(TAG, \"Exception: \", exception);\n                        tryAndThrowException(callback, exception, ERROR_INTERNAL);\n                    }\n                });\n    }\n\n    /**\n     * Returns a list of unique dates for which the database has at least one entry\n     *\n     * @param activityDatesRequestParcel Parcel request containing records classes\n     * @param callback Callback to receive result of performing this operation. The results are\n     *     returned in {@link List<LocalDate>} . In case of an error or a permission failure the\n     *     HealthConnect service, {@link IActivityDatesResponseCallback#onError} will be invoked\n     *     with a {@link HealthConnectExceptionParcel}.\n     */\n    @Override\n    public void getActivityDates(\n            @NonNull ActivityDatesRequestParcel activityDatesRequestParcel,\n            IActivityDatesResponseCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n\n        HealthConnectThreadScheduler.scheduleControllerTask(\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        mContext.enforcePermission(MANAGE_HEALTH_DATA_PERMISSION, pid, uid, null);\n                        throwExceptionIfDataSyncInProgress();\n                        List<LocalDate> localDates =\n                                ActivityDateHelper.getInstance()\n                                        .getActivityDates(\n                                                activityDatesRequestParcel.getRecordTypes());\n\n                        callback.onResult(new ActivityDatesResponseParcel(localDates));\n                    } catch (SQLiteException sqLiteException) {\n                        Slog.e(TAG, \"SqlException: \", sqLiteException);\n                        tryAndThrowException(\n                                callback, sqLiteException, HealthConnectException.ERROR_IO);\n                    } catch (SecurityException securityException) {\n                        Slog.e(TAG, \"SecurityException: \", securityException);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (HealthConnectException healthConnectException) {\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception e) {\n                        Slog.e(TAG, \"Exception: \", e);\n                        tryAndThrowException(callback, e, ERROR_INTERNAL);\n                    }\n                });\n    }\n\n    // TODO(b/265780725): Update javadocs and ensure that the caller handles SHOW_MIGRATION_INFO\n    // intent.\n    @Override\n    public void startMigration(@NonNull String packageName, IMigrationCallback callback) {\n        int uid = Binder.getCallingUid();\n        int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n\n        HealthConnectThreadScheduler.scheduleInternalTask(\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        mContext.enforcePermission(\n                                MIGRATE_HEALTH_CONNECT_DATA,\n                                pid,\n                                uid,\n                                \"Caller does not have \" + MIGRATE_HEALTH_CONNECT_DATA);\n                        enforceShowMigrationInfoIntent(packageName, uid);\n                        mBackupRestore.runWithStatesReadLock(\n                                () -> {\n                                    if (mBackupRestore.isRestoreMergingInProgress()) {\n                                        throw new MigrationException(\n                                                \"Cannot start data migration. Backup and restore in\"\n                                                        + \" progress.\",\n                                                MigrationException.ERROR_INTERNAL,\n                                                null);\n                                    }\n                                    mMigrationStateManager.startMigration(mContext);\n                                });\n                        PriorityMigrationHelper.getInstance().populatePreMigrationPriority();\n                        callback.onSuccess();\n                    } catch (Exception e) {\n                        Slog.e(TAG, \"Exception: \", e);\n                        tryAndThrowException(callback, e, MigrationException.ERROR_INTERNAL, null);\n                    }\n                });\n    }\n\n    // TODO(b/265780725): Update javadocs and ensure that the caller handles SHOW_MIGRATION_INFO\n    // intent.\n    @Override\n    public void finishMigration(@NonNull String packageName, IMigrationCallback callback) {\n        int uid = Binder.getCallingUid();\n        int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n\n        HealthConnectThreadScheduler.scheduleInternalTask(\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        mContext.enforcePermission(\n                                MIGRATE_HEALTH_CONNECT_DATA,\n                                pid,\n                                uid,\n                                \"Caller does not have \" + MIGRATE_HEALTH_CONNECT_DATA);\n                        enforceShowMigrationInfoIntent(packageName, uid);\n                        mMigrationStateManager.finishMigration(mContext);\n                        AppInfoHelper.getInstance().syncAppInfoRecordTypesUsed();\n                        callback.onSuccess();\n                    } catch (Exception e) {\n                        Slog.e(TAG, \"Exception: \", e);\n                        // TODO(b/263897830): Verify migration state and send errors properly\n                        tryAndThrowException(callback, e, MigrationException.ERROR_INTERNAL, null);\n                    }\n                });\n    }\n\n    // TODO(b/265780725): Update javadocs and ensure that the caller handles SHOW_MIGRATION_INFO\n    // intent.\n    @Override\n    public void writeMigrationData(\n            @NonNull String packageName,\n            MigrationEntityParcel parcel,\n            IMigrationCallback callback) {\n        int uid = Binder.getCallingUid();\n        int pid = Binder.getCallingPid();\n        UserHandle callingUserHandle = getCallingUserHandle();\n\n        HealthConnectThreadScheduler.scheduleInternalTask(\n                () -> {\n                    try {\n                        enforceIsForegroundUser(callingUserHandle);\n                        mContext.enforcePermission(\n                                MIGRATE_HEALTH_CONNECT_DATA,\n                                pid,\n                                uid,\n                                \"Caller does not have \" + MIGRATE_HEALTH_CONNECT_DATA);\n                        enforceShowMigrationInfoIntent(packageName, uid);\n                        mMigrationStateManager.validateWriteMigrationData();\n                        getDataMigrationManager(callingUserHandle)\n                                .apply(parcel.getMigrationEntities());\n                        callback.onSuccess();\n                    } catch (DataMigrationManager.EntityWriteException e) {\n                        Slog.e(TAG, \"Exception: \", e);\n                        tryAndThrowException(\n                                callback,\n                                e,\n                                MigrationException.ERROR_MIGRATE_ENTITY,\n                                e.getEntityId());\n                    } catch (Exception e) {\n                        Slog.e(TAG, \"Exception: \", e);\n                        tryAndThrowException(callback, e, MigrationException.ERROR_INTERNAL, null);\n                    }\n                });\n    }\n\n    public void insertMinDataMigrationSdkExtensionVersion(\n            @NonNull String packageName, int requiredSdkExtension, IMigrationCallback callback) {\n        int uid = Binder.getCallingUid();\n        int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n\n        HealthConnectThreadScheduler.scheduleInternalTask(\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        mContext.enforcePermission(\n                                MIGRATE_HEALTH_CONNECT_DATA,\n                                pid,\n                                uid,\n                                \"Caller does not have \" + MIGRATE_HEALTH_CONNECT_DATA);\n                        enforceShowMigrationInfoIntent(packageName, uid);\n                        mMigrationStateManager.validateSetMinSdkVersion();\n                        mMigrationStateManager.setMinDataMigrationSdkExtensionVersion(\n                                mContext, requiredSdkExtension);\n\n                        callback.onSuccess();\n                    } catch (Exception e) {\n                        Slog.e(TAG, \"Exception: \", e);\n                        tryAndThrowException(callback, e, MigrationException.ERROR_INTERNAL, null);\n                    }\n                });\n    }\n\n    /**\n     * @see HealthConnectManager#stageAllHealthConnectRemoteData\n     */\n    @Override\n    public void stageAllHealthConnectRemoteData(\n            @NonNull StageRemoteDataRequest stageRemoteDataRequest,\n            @NonNull UserHandle userHandle,\n            @NonNull IDataStagingFinishedCallback callback) {\n        Map<String, ParcelFileDescriptor> origPfdsByFileName =\n                stageRemoteDataRequest.getPfdsByFileName();\n        Map<String, HealthConnectException> exceptionsByFileName =\n                new ArrayMap<>(origPfdsByFileName.size());\n        Map<String, ParcelFileDescriptor> pfdsByFileName =\n                new ArrayMap<>(origPfdsByFileName.size());\n\n        try {\n            mDataPermissionEnforcer.enforceAnyOfPermissions(\n                    Manifest.permission.STAGE_HEALTH_CONNECT_REMOTE_DATA,\n                    HEALTH_CONNECT_BACKUP_INTER_AGENT_PERMISSION);\n\n            enforceIsForegroundUser(Binder.getCallingUserHandle());\n\n            for (Entry<String, ParcelFileDescriptor> entry : origPfdsByFileName.entrySet()) {\n                try {\n                    pfdsByFileName.put(entry.getKey(), entry.getValue().dup());\n                } catch (IOException e) {\n                    Slog.e(TAG, \"IOException: \", e);\n                    exceptionsByFileName.put(\n                            entry.getKey(),\n                            new HealthConnectException(\n                                    HealthConnectException.ERROR_IO, e.getMessage()));\n                }\n            }\n\n            HealthConnectThreadScheduler.scheduleInternalTask(\n                    () -> {\n                        if (!mBackupRestore.prepForStagingIfNotAlreadyDone()) {\n                            try {\n                                callback.onResult();\n                            } catch (RemoteException e) {\n                                Log.e(TAG, \"Restore response could not be sent to the caller.\", e);\n                            }\n                            return;\n                        }\n                        mBackupRestore.stageAllHealthConnectRemoteData(\n                                pfdsByFileName,\n                                exceptionsByFileName,\n                                userHandle.getIdentifier(),\n                                callback);\n                    });\n        } catch (SecurityException | IllegalStateException e) {\n            Log.e(TAG, \"Exception encountered while staging\", e);\n            try {\n                @HealthConnectException.ErrorCode\n                int errorCode = (e instanceof SecurityException) ? ERROR_SECURITY : ERROR_INTERNAL;\n                exceptionsByFileName.put(\"\", new HealthConnectException(errorCode, e.getMessage()));\n\n                callback.onError(new StageRemoteDataException(exceptionsByFileName));\n            } catch (RemoteException remoteException) {\n                Log.e(TAG, \"Restore permission response could not be sent to the caller.\", e);\n            }\n        }\n    }\n\n    /**\n     * @see HealthConnectManager#getAllDataForBackup\n     */\n    @Override\n    public void getAllDataForBackup(\n            @NonNull StageRemoteDataRequest stageRemoteDataRequest,\n            @NonNull UserHandle userHandle) {\n        mContext.enforceCallingPermission(HEALTH_CONNECT_BACKUP_INTER_AGENT_PERMISSION, null);\n        mBackupRestore.getAllDataForBackup(stageRemoteDataRequest, userHandle);\n    }\n\n    /**\n     * @see HealthConnectManager#getAllBackupFileNames\n     */\n    @Override\n    public BackupFileNamesSet getAllBackupFileNames(boolean forDeviceToDevice) {\n        mContext.enforceCallingPermission(HEALTH_CONNECT_BACKUP_INTER_AGENT_PERMISSION, null);\n        return mBackupRestore.getAllBackupFileNames(forDeviceToDevice);\n    }\n\n    /**\n     * @see HealthConnectManager#deleteAllStagedRemoteData\n     */\n    @Override\n    public void deleteAllStagedRemoteData(@NonNull UserHandle userHandle) {\n        mContext.enforceCallingPermission(\n                DELETE_STAGED_HEALTH_CONNECT_REMOTE_DATA_PERMISSION, null);\n        mBackupRestore.deleteAndResetEverything(userHandle);\n        mMigrationStateManager.clearCaches(mContext);\n        AppInfoHelper.getInstance().clearData(mTransactionManager);\n        ActivityDateHelper.getInstance().clearData(mTransactionManager);\n        MigrationEntityHelper.getInstance().clearData(mTransactionManager);\n        HealthDataCategoryPriorityHelper.getInstance().clearData(mTransactionManager);\n        PriorityMigrationHelper.getInstance().clearData(mTransactionManager);\n        RateLimiter.clearCache();\n        String[] packageNames = mContext.getPackageManager().getPackagesForUid(getCallingUid());\n        for (String packageName : packageNames) {\n            mFirstGrantTimeManager.setFirstGrantTime(packageName, Instant.now(), userHandle);\n        }\n    }\n\n    /**\n     * @see HealthConnectManager#updateDataDownloadState\n     */\n    @Override\n    public void updateDataDownloadState(@DataDownloadState int downloadState) {\n        mContext.enforceCallingPermission(\n                Manifest.permission.STAGE_HEALTH_CONNECT_REMOTE_DATA, null);\n        enforceIsForegroundUser(getCallingUserHandle());\n        mBackupRestore.updateDataDownloadState(downloadState);\n    }\n\n    /**\n     * @see HealthConnectManager#getHealthConnectDataState\n     */\n    @Override\n    public void getHealthConnectDataState(@NonNull IGetHealthConnectDataStateCallback callback) {\n        try {\n            mDataPermissionEnforcer.enforceAnyOfPermissions(\n                    MANAGE_HEALTH_DATA_PERMISSION, Manifest.permission.MIGRATE_HEALTH_CONNECT_DATA);\n            final UserHandle userHandle = Binder.getCallingUserHandle();\n            enforceIsForegroundUser(userHandle);\n            HealthConnectThreadScheduler.scheduleInternalTask(\n                    () -> {\n                        try {\n                            @HealthConnectDataState.DataRestoreError\n                            int dataRestoreError = mBackupRestore.getDataRestoreError();\n                            @HealthConnectDataState.DataRestoreState\n                            int dataRestoreState = mBackupRestore.getDataRestoreState();\n\n                            try {\n                                callback.onResult(\n                                        new HealthConnectDataState(\n                                                dataRestoreState,\n                                                dataRestoreError,\n                                                mMigrationStateManager.getMigrationState()));\n                            } catch (RemoteException remoteException) {\n                                Log.e(\n                                        TAG,\n                                        \"HealthConnectDataState could not be sent to the caller.\",\n                                        remoteException);\n                            }\n                        } catch (RuntimeException e) {\n                            // exception getting the state from the disk\n                            try {\n                                callback.onError(\n                                        new HealthConnectExceptionParcel(\n                                                new HealthConnectException(\n                                                        HealthConnectException.ERROR_IO,\n                                                        e.getMessage())));\n                            } catch (RemoteException remoteException) {\n                                Log.e(\n                                        TAG,\n                                        \"Exception for getHealthConnectDataState could not be sent\"\n                                                + \" to the caller.\",\n                                        remoteException);\n                            }\n                        }\n                    });\n        } catch (SecurityException | IllegalStateException e) {\n            Log.e(TAG, \"getHealthConnectDataState: Exception encountered\", e);\n            @HealthConnectException.ErrorCode\n            int errorCode = (e instanceof SecurityException) ? ERROR_SECURITY : ERROR_INTERNAL;\n            try {\n                callback.onError(\n                        new HealthConnectExceptionParcel(\n                                new HealthConnectException(errorCode, e.getMessage())));\n            } catch (RemoteException remoteException) {\n                Log.e(TAG, \"getHealthConnectDataState error could not be sent\", e);\n            }\n        }\n    }\n\n    /**\n     * @see HealthConnectManager#getHealthConnectMigrationUiState\n     */\n    @Override\n    public void getHealthConnectMigrationUiState(\n            @NonNull IGetHealthConnectMigrationUiStateCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n        HealthConnectThreadScheduler.scheduleInternalTask(\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        mContext.enforcePermission(MANAGE_HEALTH_DATA_PERMISSION, pid, uid, null);\n\n                        try {\n                            callback.onResult(\n                                    new HealthConnectMigrationUiState(\n                                            mMigrationUiStateManager\n                                                    .getHealthConnectMigrationUiState()));\n                        } catch (RemoteException remoteException) {\n                            Log.e(\n                                    TAG,\n                                    \"HealthConnectMigrationUiState could not be sent to the\"\n                                            + \" caller.\",\n                                    remoteException);\n                        }\n                    } catch (SecurityException securityException) {\n                        try {\n                            callback.onError(\n                                    new HealthConnectExceptionParcel(\n                                            new HealthConnectException(\n                                                    ERROR_SECURITY,\n                                                    securityException.getMessage())));\n                        } catch (RemoteException remoteException) {\n                            Log.e(\n                                    TAG,\n                                    \"Exception for HealthConnectMigrationUiState could not be sent\"\n                                            + \" to the caller.\",\n                                    remoteException);\n                        }\n                    } catch (RuntimeException e) {\n                        // exception getting the state from the disk\n                        try {\n                            callback.onError(\n                                    new HealthConnectExceptionParcel(\n                                            new HealthConnectException(\n                                                    HealthConnectException.ERROR_IO,\n                                                    e.getMessage())));\n                        } catch (RemoteException remoteException) {\n                            Log.e(\n                                    TAG,\n                                    \"Exception for HealthConnectMigrationUiState could not be sent\"\n                                            + \" to the caller.\",\n                                    remoteException);\n                        }\n                    }\n                });\n    }\n\n    // Cancel BR timeouts - this might be needed when a user is going into background.\n    void cancelBackupRestoreTimeouts() {\n        mBackupRestore.cancelAllJobs();\n    }\n\n    private void tryAcquireApiCallQuota(\n            int uid,\n            @QuotaCategory.Type int quotaCategory,\n            boolean isInForeground,\n            HealthConnectServiceLogger.Builder builder) {\n        try {\n            RateLimiter.tryAcquireApiCallQuota(uid, quotaCategory, isInForeground);\n        } catch (RateLimiterException rateLimiterException) {\n            builder.setRateLimit(\n                    rateLimiterException.getRateLimiterQuotaBucket(),\n                    rateLimiterException.getRateLimiterQuotaLimit());\n            throw new HealthConnectException(\n                    rateLimiterException.getErrorCode(), rateLimiterException.getMessage());\n        }\n    }\n\n    private void enforceMemoryRateLimit(List<Long> recordsSize, long recordsChunkSize) {\n        recordsSize.forEach(RateLimiter::checkMaxRecordMemoryUsage);\n        RateLimiter.checkMaxChunkMemoryUsage(recordsChunkSize);\n    }\n\n    private void enforceIsForegroundUser(UserHandle callingUserHandle) {\n        if (!callingUserHandle.equals(mCurrentForegroundUser)) {\n            throw new IllegalStateException(\n                    \"Calling user: \"\n                            + callingUserHandle.getIdentifier()\n                            + \"is not the current foreground user: \"\n                            + mCurrentForegroundUser.getIdentifier()\n                            + \". HC request must be called\"\n                            + \" from the current foreground user.\");\n        }\n    }\n\n    private boolean isDataSyncInProgress() {\n        return mMigrationStateManager.isMigrationInProgress()\n                || mBackupRestore.isRestoreMergingInProgress();\n    }\n\n    @VisibleForTesting\n    Set<String> getStagedRemoteFileNames(int userId) {\n        return mBackupRestore.getStagedRemoteFileNames(userId);\n    }\n\n    @NonNull\n    private DataMigrationManager getDataMigrationManager(@NonNull UserHandle userHandle) {\n        final Context userContext = mContext.createContextAsUser(userHandle, 0);\n\n        return new DataMigrationManager(\n                userContext,\n                mTransactionManager,\n                mPermissionHelper,\n                mFirstGrantTimeManager,\n                DeviceInfoHelper.getInstance(),\n                AppInfoHelper.getInstance(),\n                MigrationEntityHelper.getInstance(),\n                RecordHelperProvider.getInstance(),\n                HealthDataCategoryPriorityHelper.getInstance(),\n                PriorityMigrationHelper.getInstance(),\n                ActivityDateHelper.getInstance());\n    }\n\n    private void enforceCallingPackageBelongsToUid(String packageName, int callingUid) {\n        int packageUid;\n        try {\n            packageUid =\n                    mContext.getPackageManager()\n                            .getPackageUid(\n                                    packageName, /* flags */ PackageManager.PackageInfoFlags.of(0));\n        } catch (PackageManager.NameNotFoundException e) {\n            throw new IllegalStateException(packageName + \" not found\");\n        }\n        if (UserHandle.getAppId(packageUid) != UserHandle.getAppId(callingUid)) {\n            throwSecurityException(packageName + \" does not belong to uid \" + callingUid);\n        }\n    }\n\n    /**\n     * Verify various aspects of the calling user.\n     *\n     * @param callingUid Uid of the caller, usually retrieved from Binder for authenticity.\n     * @param callerAttributionSource The permission identity of the caller\n     */\n    private void verifyPackageNameFromUid(\n            int callingUid, @NonNull AttributionSource callerAttributionSource) {\n        // Check does the attribution source is one for the calling app.\n        callerAttributionSource.enforceCallingUid();\n        // Obtain the user where the client is running in.\n        UserHandle callingUserHandle = UserHandle.getUserHandleForUid(callingUid);\n        Context callingUserContext = mContext.createContextAsUser(callingUserHandle, 0);\n        String callingPackageName =\n                Objects.requireNonNull(callerAttributionSource.getPackageName());\n        verifyCallingPackage(callingUserContext, callingUid, callingPackageName);\n    }\n\n    /**\n     * Check that the caller's supposed package name matches the uid making the call.\n     *\n     * @throws SecurityException if the package name and uid don't match.\n     */\n    private void verifyCallingPackage(\n            @NonNull Context actualCallingUserContext,\n            int actualCallingUid,\n            @NonNull String claimedCallingPackage) {\n        int claimedCallingUid = getPackageUid(actualCallingUserContext, claimedCallingPackage);\n        if (claimedCallingUid != actualCallingUid) {\n            throwSecurityException(\n                    claimedCallingPackage + \" does not belong to uid \" + actualCallingUid);\n        }\n    }\n\n    /** Finds the UID of the {@code packageName} in the given {@code context}. */\n    private int getPackageUid(@NonNull Context context, @NonNull String packageName) {\n        try {\n            return context.getPackageManager().getPackageUid(packageName, /* flags= */ 0);\n        } catch (PackageManager.NameNotFoundException e) {\n            return Process.INVALID_UID;\n        }\n    }\n\n    private void enforceShowMigrationInfoIntent(String packageName, int callingUid) {\n        enforceCallingPackageBelongsToUid(packageName, callingUid);\n\n        Intent intentToCheck =\n                new Intent(HealthConnectManager.ACTION_SHOW_MIGRATION_INFO).setPackage(packageName);\n\n        ResolveInfo resolveResult =\n                mContext.getPackageManager()\n                        .resolveActivity(\n                                intentToCheck,\n                                PackageManager.ResolveInfoFlags.of(PackageManager.MATCH_ALL));\n\n        if (Objects.isNull(resolveResult)) {\n            throw new IllegalArgumentException(\n                    packageName\n                            + \" does not handle intent \"\n                            + HealthConnectManager.ACTION_SHOW_MIGRATION_INFO);\n        }\n    }\n\n    private Map<Integer, List<DataOrigin>> getPopulatedRecordTypeInfoResponses() {\n        Map<Integer, Class<? extends Record>> recordIdToExternalRecordClassMap =\n                RecordMapper.getInstance().getRecordIdToExternalRecordClassMap();\n        AppInfoHelper appInfoHelper = AppInfoHelper.getInstance();\n        Map<Integer, List<DataOrigin>> recordTypeInfoResponses =\n                new ArrayMap<>(recordIdToExternalRecordClassMap.size());\n        Map<Integer, Set<String>> recordTypeToContributingPackagesMap =\n                appInfoHelper.getRecordTypesToContributingPackagesMap();\n        recordIdToExternalRecordClassMap\n                .keySet()\n                .forEach(\n                        (recordType) -> {\n                            if (recordTypeToContributingPackagesMap.containsKey(recordType)) {\n                                List<DataOrigin> packages =\n                                        recordTypeToContributingPackagesMap.get(recordType).stream()\n                                                .map(\n                                                        (packageName) ->\n                                                                new DataOrigin.Builder()\n                                                                        .setPackageName(packageName)\n                                                                        .build())\n                                                .toList();\n                                recordTypeInfoResponses.put(recordType, packages);\n                            } else {\n                                recordTypeInfoResponses.put(recordType, Collections.emptyList());\n                            }\n                        });\n        return recordTypeInfoResponses;\n    }\n\n    private boolean hasDataManagementPermission(int uid, int pid) {\n        return mContext.checkPermission(MANAGE_HEALTH_DATA_PERMISSION, pid, uid)\n                == PERMISSION_GRANTED;\n    }\n\n    private void finishDataDeliveryRead(int recordTypeId, AttributionSource attributionSource) {\n        finishDataDeliveryRead(Collections.singletonList(recordTypeId), attributionSource);\n    }\n\n    private void finishDataDeliveryRead(\n            List<Integer> recordTypeIds, AttributionSource attributionSource) {\n        Trace.traceBegin(TRACE_TAG_READ_SUBTASKS, TAG_READ.concat(\"FinishDataDeliveryRead\"));\n\n        try {\n            for (Integer recordTypeId : recordTypeIds) {\n                String permissionName =\n                        HealthPermissions.getHealthReadPermission(\n                                RecordTypePermissionCategoryMapper\n                                        .getHealthPermissionCategoryForRecordType(recordTypeId));\n                mPermissionManager.finishDataDelivery(permissionName, attributionSource);\n            }\n        } catch (Exception exception) {\n            // Ignore: HC API has already fulfilled the result, ignore any exception we hit here\n        }\n        Trace.traceEnd(TRACE_TAG_READ_SUBTASKS);\n    }\n\n    private void finishDataDeliveryWriteRecords(\n            List<RecordInternal<?>> recordInternals, AttributionSource attributionSource) {\n        Trace.traceBegin(TRACE_TAG_READ_SUBTASKS, TAG_READ.concat(\".FinishDataDeliveryWrite\"));\n        Set<Integer> recordTypeIdsToEnforce = new ArraySet<>();\n        for (RecordInternal<?> recordInternal : recordInternals) {\n            recordTypeIdsToEnforce.add(recordInternal.getRecordType());\n        }\n\n        finishDataDeliveryWrite(recordTypeIdsToEnforce.stream().toList(), attributionSource);\n        Trace.traceEnd(TRACE_TAG_READ_SUBTASKS);\n    }\n\n    private void finishDataDeliveryWrite(\n            List<Integer> recordTypeIds, AttributionSource attributionSource) {\n        try {\n            for (Integer recordTypeId : recordTypeIds) {\n                String permissionName =\n                        HealthPermissions.getHealthWritePermission(\n                                RecordTypePermissionCategoryMapper\n                                        .getHealthPermissionCategoryForRecordType(recordTypeId));\n                mPermissionManager.finishDataDelivery(permissionName, attributionSource);\n            }\n        } catch (Exception exception) {\n            // Ignore: HC API has already fulfilled the result, ignore any exception we hit here\n        }\n    }\n\n    private void enforceBinderUidIsSameAsAttributionSourceUid(\n            int binderUid, int attributionSourceUid) {\n        if (binderUid != attributionSourceUid) {\n            throw new SecurityException(\"Binder uid must be equal to attribution source uid.\");\n        }\n    }\n\n    private void throwExceptionIncorrectPermissionState() {\n        throw new IllegalStateException(\n                \"Incorrect health permission state, likely\"\n                        + \" because the calling application's manifest does not specify handling \"\n                        + Intent.ACTION_VIEW_PERMISSION_USAGE\n                        + \" with \"\n                        + HealthConnectManager.CATEGORY_HEALTH_PERMISSIONS);\n    }\n\n    private void logRecordTypeSpecificUpsertMetrics(\n            @NonNull List<RecordInternal<?>> recordInternals, @NonNull String packageName) {\n        Objects.requireNonNull(recordInternals);\n        Objects.requireNonNull(packageName);\n\n        Map<Integer, List<RecordInternal<?>>> recordTypeToRecordInternals =\n                getRecordTypeToListOfRecords(recordInternals);\n        for (Entry<Integer, List<RecordInternal<?>>> recordTypeToRecordInternalsEntry :\n                recordTypeToRecordInternals.entrySet()) {\n            RecordHelper<?> recordHelper =\n                    RecordHelperProvider.getInstance()\n                            .getRecordHelper(recordTypeToRecordInternalsEntry.getKey());\n            recordHelper.logUpsertMetrics(recordTypeToRecordInternalsEntry.getValue(), packageName);\n        }\n    }\n\n    private void logRecordTypeSpecificReadMetrics(\n            @NonNull List<RecordInternal<?>> recordInternals, @NonNull String packageName) {\n        Objects.requireNonNull(recordInternals);\n        Objects.requireNonNull(packageName);\n\n        Map<Integer, List<RecordInternal<?>>> recordTypeToRecordInternals =\n                getRecordTypeToListOfRecords(recordInternals);\n        for (Entry<Integer, List<RecordInternal<?>>> recordTypeToRecordInternalsEntry :\n                recordTypeToRecordInternals.entrySet()) {\n            RecordHelper<?> recordHelper =\n                    RecordHelperProvider.getInstance()\n                            .getRecordHelper(recordTypeToRecordInternalsEntry.getKey());\n            recordHelper.logReadMetrics(recordTypeToRecordInternalsEntry.getValue(), packageName);\n        }\n    }\n\n    private Map<Integer, List<RecordInternal<?>>> getRecordTypeToListOfRecords(\n            List<RecordInternal<?>> recordInternals) {\n\n        return recordInternals.stream()\n                .collect(Collectors.groupingBy(RecordInternal::getRecordType));\n    }\n\n    private void throwSecurityException(String message) {\n        throw new SecurityException(message);\n    }\n\n    private void throwExceptionIfDataSyncInProgress() {\n        if (isDataSyncInProgress()) {\n            throw new HealthConnectException(\n                    HealthConnectException.ERROR_DATA_SYNC_IN_PROGRESS,\n                    \"Storage data sync in progress. API calls are blocked\");\n        }\n    }\n\n    /**\n     * Throws an IllegalState Exception if data migration or restore is in process. This is only\n     * used by HealthConnect synchronous APIs as {@link HealthConnectException} is lost between\n     * processes on synchronous APIs and can only be returned to the caller for the APIs with a\n     * callback.\n     */\n    private void throwIllegalStateExceptionIfDataSyncInProgress() {\n        if (isDataSyncInProgress()) {\n            throw new IllegalStateException(\"Storage data sync in progress. API calls are blocked\");\n        }\n    }\n\n    private static void postDeleteTasks(List<Integer> recordTypeIdsToDelete) {\n        Trace.traceBegin(TRACE_TAG_DELETE_SUBTASKS, TAG_INSERT.concat(\"PostDeleteTasks\"));\n        if (recordTypeIdsToDelete != null && !recordTypeIdsToDelete.isEmpty()) {\n            AppInfoHelper.getInstance()\n                    .syncAppInfoRecordTypesUsed(new HashSet<>(recordTypeIdsToDelete));\n            ActivityDateHelper.getInstance().reSyncByRecordTypeIds(recordTypeIdsToDelete);\n        }\n        Trace.traceEnd(TRACE_TAG_DELETE_SUBTASKS);\n    }\n\n    private static void tryAndReturnResult(\n            IEmptyResponseCallback callback, HealthConnectServiceLogger.Builder builder) {\n        try {\n            callback.onResult();\n            builder.setHealthDataServiceApiStatusSuccess();\n        } catch (RemoteException e) {\n            Slog.e(TAG, \"Remote call failed\", e);\n            builder.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n        }\n    }\n\n    private static void tryAndReturnResult(\n            IInsertRecordsResponseCallback callback,\n            List<String> uuids,\n            HealthConnectServiceLogger.Builder builder) {\n        try {\n            callback.onResult(new InsertRecordsResponseParcel(uuids));\n            builder.setHealthDataServiceApiStatusSuccess();\n        } catch (RemoteException e) {\n            Slog.e(TAG, \"Remote call failed\", e);\n            builder.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n        }\n    }\n\n    private static void tryAndThrowException(\n            @NonNull IInsertRecordsResponseCallback callback,\n            @NonNull Exception exception,\n            @HealthConnectException.ErrorCode int errorCode) {\n        try {\n            callback.onError(\n                    new HealthConnectExceptionParcel(\n                            new HealthConnectException(errorCode, exception.toString())));\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Unable to send result to the callback\", e);\n        }\n    }\n\n    private static void tryAndThrowException(\n            @NonNull IAggregateRecordsResponseCallback callback,\n            @NonNull Exception exception,\n            @HealthConnectException.ErrorCode int errorCode) {\n        try {\n            callback.onError(\n                    new HealthConnectExceptionParcel(\n                            new HealthConnectException(errorCode, exception.toString())));\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Unable to send result to the callback\", e);\n        }\n    }\n\n    private static void tryAndThrowException(\n            @NonNull IReadRecordsResponseCallback callback,\n            @NonNull Exception exception,\n            @HealthConnectException.ErrorCode int errorCode) {\n        try {\n            callback.onError(\n                    new HealthConnectExceptionParcel(\n                            new HealthConnectException(errorCode, exception.toString())));\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Unable to send result to the callback\", e);\n        }\n    }\n\n    private static void tryAndThrowException(\n            @NonNull IActivityDatesResponseCallback callback,\n            @NonNull Exception exception,\n            @HealthConnectException.ErrorCode int errorCode) {\n        try {\n            callback.onError(\n                    new HealthConnectExceptionParcel(\n                            new HealthConnectException(errorCode, exception.toString())));\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Unable to send result to the callback\", e);\n        }\n    }\n\n    private static void tryAndThrowException(\n            @NonNull IGetChangeLogTokenCallback callback,\n            @NonNull Exception exception,\n            @HealthConnectException.ErrorCode int errorCode) {\n        try {\n            callback.onError(\n                    new HealthConnectExceptionParcel(\n                            new HealthConnectException(errorCode, exception.toString())));\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Unable to send result to the callback\", e);\n        }\n    }\n\n    private static void tryAndThrowException(\n            @NonNull IAccessLogsResponseCallback callback,\n            @NonNull Exception exception,\n            @HealthConnectException.ErrorCode int errorCode) {\n        try {\n            callback.onError(\n                    new HealthConnectExceptionParcel(\n                            new HealthConnectException(errorCode, exception.toString())));\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Unable to send result to the callback\", e);\n        }\n    }\n\n    private static void tryAndThrowException(\n            @NonNull IEmptyResponseCallback callback,\n            @NonNull Exception exception,\n            @HealthConnectException.ErrorCode int errorCode) {\n        try {\n            callback.onError(\n                    new HealthConnectExceptionParcel(\n                            new HealthConnectException(errorCode, exception.toString())));\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Unable to send result to the callback\", e);\n        }\n    }\n\n    private static void tryAndThrowException(\n            @NonNull IApplicationInfoResponseCallback callback,\n            @NonNull Exception exception,\n            @HealthConnectException.ErrorCode int errorCode) {\n        try {\n            callback.onError(\n                    new HealthConnectExceptionParcel(\n                            new HealthConnectException(errorCode, exception.toString())));\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Unable to send result to the callback\", e);\n        }\n    }\n\n    private static void tryAndThrowException(\n            @NonNull IChangeLogsResponseCallback callback,\n            @NonNull Exception exception,\n            @HealthConnectException.ErrorCode int errorCode) {\n        try {\n            callback.onError(\n                    new HealthConnectExceptionParcel(\n                            new HealthConnectException(errorCode, exception.toString())));\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Unable to send result to the callback\", e);\n        }\n    }\n\n    private static void tryAndThrowException(\n            @NonNull IRecordTypeInfoResponseCallback callback,\n            @NonNull Exception exception,\n            @HealthConnectException.ErrorCode int errorCode) {\n        try {\n            callback.onError(\n                    new HealthConnectExceptionParcel(\n                            new HealthConnectException(errorCode, exception.toString())));\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Unable to send result to the callback\", e);\n        }\n    }\n\n    private static void tryAndThrowException(\n            @NonNull IGetPriorityResponseCallback callback,\n            @NonNull Exception exception,\n            @HealthConnectException.ErrorCode int errorCode) {\n        try {\n            callback.onError(\n                    new HealthConnectExceptionParcel(\n                            new HealthConnectException(errorCode, exception.toString())));\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Unable to send result to the callback\", e);\n        }\n    }\n\n    private static void tryAndThrowException(\n            @NonNull IMigrationCallback callback,\n            @NonNull Exception exception,\n            @MigrationException.ErrorCode int errorCode,\n            @Nullable String failedEntityId) {\n        try {\n            callback.onError(\n                    new MigrationException(exception.toString(), errorCode, failedEntityId));\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Unable to send result to the callback\", e);\n        }\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 19007,
                                        "general": {
                                            "word_based": 6872,
                                            "char_based": 30932
                                        },
                                        "gemini": 23071
                                    }
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-313428840",
            "aliases": [
                "A-313428840",
                "CVE-2024-31318"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-313428840",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "1f31bb181fc56f3deab5ce0d199220404991c438"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 1f31bb181fc56f3deab5ce0d199220404991c438 Mon Sep 17 00:00:00 2001\nFrom: Guojing Yuan <guojing@google.com>\nDate: Thu, 14 Dec 2023 19:30:04 +0000\nSubject: [PATCH] [CDM][CMD] Check permissions for CDM shell commands\n\nOverride handleShellCommand instead of onShellCommand because\nBinder.onShellCommand checks the necessary permissions of the caller.\n\nBug: 313428840\n\nTest: manually tested CDM shell commands\nChange-Id: I5539b3594feb5544c458c0fd1061b51a0a808900\nMerged-In: I5539b3594feb5544c458c0fd1061b51a0a808900\n(cherry picked from commit 1761a0fee9c2cd9787bbb7fbdbe30b4c2b03396e)\n---\n .../CompanionDeviceManagerService.java          | 17 ++++++++---------\n 1 file changed, 8 insertions(+), 9 deletions(-)\n\ndiff --git a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\nindex 0c6d053d4f3f..a3f66655795e 100644\n--- a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n+++ b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n@@ -84,9 +84,7 @@ import android.os.ParcelFileDescriptor;\n import android.os.PowerWhitelistManager;\n import android.os.RemoteCallbackList;\n import android.os.RemoteException;\n-import android.os.ResultReceiver;\n import android.os.ServiceManager;\n-import android.os.ShellCallback;\n import android.os.SystemProperties;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -951,13 +949,14 @@ public class CompanionDeviceManagerService extends SystemService {\n         }\n \n         @Override\n-        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n-                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n-                throws RemoteException {\n-            new CompanionDeviceShellCommand(CompanionDeviceManagerService.this, mAssociationStore,\n-                    mDevicePresenceMonitor, mTransportManager, mSystemDataTransferProcessor,\n-                    mAssociationRequestsProcessor)\n-                    .exec(this, in, out, err, args, callback, resultReceiver);\n+        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n+                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n+                @NonNull String[] args) {\n+            return new CompanionDeviceShellCommand(CompanionDeviceManagerService.this,\n+                    mAssociationStore, mDevicePresenceMonitor, mTransportManager,\n+                    mSystemDataTransferProcessor, mAssociationRequestsProcessor)\n+                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n+                            err.getFileDescriptor(), args);\n         }\n \n         @Override\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 679,
                        "general": {
                            "word_based": 253,
                            "char_based": 709
                        },
                        "gemini": 847
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 0,
                    "failed_patches": 4,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "8d008c61451dba86aa9f14c6bcd661db2cea4856",
                            "repo_path": "android_repos/base",
                            "result": "failure",
                            "downstream_patch_content": "commit 8d008c61451dba86aa9f14c6bcd661db2cea4856\nAuthor: Guojing Yuan <guojing@google.com>\nDate:   Thu Dec 14 19:30:04 2023 +0000\n\n    [CDM][CMD] Check permissions for CDM shell commands\n    \n    Override handleShellCommand instead of onShellCommand because\n    Binder.onShellCommand checks the necessary permissions of the caller.\n    \n    Bug: 313428840\n    \n    Test: manually tested CDM shell commands\n    Change-Id: I5539b3594feb5544c458c0fd1061b51a0a808900\n    Merged-In: I5539b3594feb5544c458c0fd1061b51a0a808900\n    (cherry picked from commit 1761a0fee9c2cd9787bbb7fbdbe30b4c2b03396e)\n\ndiff --git a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\nindex eccfe2ecb0b2..f31ba03e3b5f 100644\n--- a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n+++ b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n@@ -86,12 +86,11 @@ import android.os.Handler;\n import android.os.IBinder;\n import android.os.IInterface;\n import android.os.Parcel;\n+import android.os.ParcelFileDescriptor;\n import android.os.PowerWhitelistManager;\n import android.os.Process;\n import android.os.RemoteException;\n-import android.os.ResultReceiver;\n import android.os.ServiceManager;\n-import android.os.ShellCallback;\n import android.os.ShellCommand;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -699,10 +698,12 @@ public class CompanionDeviceManagerService extends SystemService implements Bind\n         }\n \n         @Override\n-        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n-                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n-                throws RemoteException {\n-            new ShellCmd().exec(this, in, out, err, args, callback, resultReceiver);\n+        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n+                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n+                @NonNull String[] args) {\n+            return new ShellCmd()\n+                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n+                            err.getFileDescriptor(), args);\n         }\n \n         @Override\n",
                            "downstream_patch_tokens": {
                                "openai": 570,
                                "general": {
                                    "word_based": 232,
                                    "char_based": 587
                                },
                                "gemini": 727
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java",
                                    "total_hunks": 2,
                                    "failed_hunks": [
                                        1,
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12)\n        public void enableSecureTransport(boolean enabled) {\n            mTransportManager.enableSecureTransport(enabled);\n=======\n        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n                @NonNull String[] args) {\n            return new CompanionDeviceShellCommand(CompanionDeviceManagerService.this,\n                    mAssociationStore, mDevicePresenceMonitor, mTransportManager,\n                    mSystemDataTransferProcessor, mAssociationRequestsProcessor)\n                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n                            err.getFileDescriptor(), args);\n>>>>>>> UPSTREAM PATCH (commit 1f31bb181fc56f3deab5ce0d199220404991c438)",
                                            "merge_conflict_tokens": {
                                                "openai": 154,
                                                "general": {
                                                    "word_based": 49,
                                                    "char_based": 206
                                                },
                                                "gemini": 185
                                            }
                                        }
                                    ],
                                    "inline_merge_token_summary": {
                                        "gemini": 17020,
                                        "openai": 14322,
                                        "general_word": 4557,
                                        "general_char": 19158
                                    },
                                    "rej_file_content": "```diff\n--- services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n+++ services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n@@ -84,9 +84,7 @@ import android.os.ParcelFileDescriptor;\n import android.os.PowerWhitelistManager;\n import android.os.RemoteCallbackList;\n import android.os.RemoteException;\n-import android.os.ResultReceiver;\n import android.os.ServiceManager;\n-import android.os.ShellCallback;\n import android.os.SystemProperties;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -951,13 +949,14 @@ public class CompanionDeviceManagerService extends SystemService {\n         }\n \n         @Override\n-        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n-                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n-                throws RemoteException {\n-            new CompanionDeviceShellCommand(CompanionDeviceManagerService.this, mAssociationStore,\n-                    mDevicePresenceMonitor, mTransportManager, mSystemDataTransferProcessor,\n-                    mAssociationRequestsProcessor)\n-                    .exec(this, in, out, err, args, callback, resultReceiver);\n+        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n+                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n+                @NonNull String[] args) {\n+            return new CompanionDeviceShellCommand(CompanionDeviceManagerService.this,\n+                    mAssociationStore, mDevicePresenceMonitor, mTransportManager,\n+                    mSystemDataTransferProcessor, mAssociationRequestsProcessor)\n+                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n+                            err.getFileDescriptor(), args);\n         }\n \n         @Override\n```",
                                    "rej_file_tokens": {
                                        "openai": 351,
                                        "general": {
                                            "word_based": 141,
                                            "char_based": 466
                                        },
                                        "gemini": 416
                                    },
                                    "patch_apply_output": "patching file services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\nHunk #1 FAILED at 84.\nHunk #2 FAILED at 951.\n2 out of 2 hunks FAILED -- saving rejects to file services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java.rej",
                                    "inline_merge_output": "patching file services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\nHunk #1 already applied at 87,88.\nHunk #2 NOT MERGED at 817-829.",
                                    "upstream_file_tokens": {
                                        "openai": 13480,
                                        "general": {
                                            "word_based": 5482,
                                            "char_based": 18027
                                        },
                                        "gemini": 15497
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\npackage com.android.server.companion;\n\nimport static android.Manifest.permission.BIND_COMPANION_DEVICE_SERVICE;\nimport static android.bluetooth.le.ScanSettings.CALLBACK_TYPE_ALL_MATCHES;\nimport static android.bluetooth.le.ScanSettings.SCAN_MODE_BALANCED;\nimport static android.content.Context.BIND_IMPORTANT;\nimport static android.content.pm.PackageManager.CERT_INPUT_SHA256;\nimport static android.content.pm.PackageManager.MATCH_ALL;\nimport static android.content.pm.PackageManager.PERMISSION_GRANTED;\n\nimport static com.android.internal.util.CollectionUtils.any;\nimport static com.android.internal.util.CollectionUtils.emptyIfNull;\nimport static com.android.internal.util.CollectionUtils.filter;\nimport static com.android.internal.util.CollectionUtils.find;\nimport static com.android.internal.util.CollectionUtils.forEach;\nimport static com.android.internal.util.CollectionUtils.map;\nimport static com.android.internal.util.FunctionalUtils.uncheckExceptions;\nimport static com.android.internal.util.Preconditions.checkArgument;\nimport static com.android.internal.util.Preconditions.checkNotNull;\nimport static com.android.internal.util.Preconditions.checkState;\nimport static com.android.internal.util.function.pooled.PooledLambda.obtainMessage;\nimport static com.android.internal.util.function.pooled.PooledLambda.obtainRunnable;\n\nimport static java.util.Objects.requireNonNull;\nimport static java.util.concurrent.TimeUnit.MINUTES;\n\nimport android.Manifest;\nimport android.annotation.CheckResult;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.SuppressLint;\nimport android.app.ActivityManagerInternal;\nimport android.app.AppOpsManager;\nimport android.app.PendingIntent;\nimport android.app.role.RoleManager;\nimport android.bluetooth.BluetoothAdapter;\nimport android.bluetooth.BluetoothDevice;\nimport android.bluetooth.le.BluetoothLeScanner;\nimport android.bluetooth.le.ScanCallback;\nimport android.bluetooth.le.ScanFilter;\nimport android.bluetooth.le.ScanResult;\nimport android.bluetooth.le.ScanSettings;\nimport android.companion.Association;\nimport android.companion.AssociationRequest;\nimport android.companion.CompanionDeviceManager;\nimport android.companion.CompanionDeviceService;\nimport android.companion.DeviceNotAssociatedException;\nimport android.companion.ICompanionDeviceDiscoveryService;\nimport android.companion.ICompanionDeviceManager;\nimport android.companion.ICompanionDeviceService;\nimport android.companion.IFindDeviceCallback;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.FeatureInfo;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.Signature;\nimport android.content.pm.UserInfo;\nimport android.net.NetworkPolicyManager;\nimport android.os.Binder;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.IInterface;\nimport android.os.Parcel;\nimport android.os.PowerWhitelistManager;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.ServiceManager;\nimport android.os.ShellCallback;\nimport android.os.ShellCommand;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.permission.PermissionControllerManager;\nimport android.provider.Settings;\nimport android.provider.SettingsStringUtil.ComponentNameSet;\nimport android.text.BidiFormatter;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.ExceptionUtils;\nimport android.util.Log;\nimport android.util.PackageUtils;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.Xml;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.app.IAppOpsService;\nimport com.android.internal.content.PackageMonitor;\nimport com.android.internal.infra.AndroidFuture;\nimport com.android.internal.infra.PerUser;\nimport com.android.internal.infra.ServiceConnector;\nimport com.android.internal.notification.NotificationAccessConfirmationActivityContract;\nimport com.android.internal.os.BackgroundThread;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.CollectionUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.function.pooled.PooledLambda;\nimport com.android.server.FgThread;\nimport com.android.server.LocalServices;\nimport com.android.server.SystemService;\nimport com.android.server.pm.UserManagerInternal;\nimport com.android.server.wm.ActivityTaskManagerInternal;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\nimport org.xmlpull.v1.XmlSerializer;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.function.Function;\n\n/** @hide */\n@SuppressLint(\"LongLogTag\")\npublic class CompanionDeviceManagerService extends SystemService implements Binder.DeathRecipient {\n\n    private static final ComponentName SERVICE_TO_BIND_TO = ComponentName.createRelative(\n            CompanionDeviceManager.COMPANION_DEVICE_DISCOVERY_PACKAGE_NAME,\n            \".CompanionDeviceDiscoveryService\");\n\n    private static final long DEVICE_DISAPPEARED_TIMEOUT_MS = 10 * 1000;\n    private static final long DEVICE_DISAPPEARED_UNBIND_TIMEOUT_MS = 10 * 60 * 1000;\n\n    private static final long DEVICE_LISTENER_DIED_REBIND_TIMEOUT_MS = 10 * 1000;\n\n    private static final boolean DEBUG = false;\n    private static final String LOG_TAG = \"CompanionDeviceManagerService\";\n\n    private static final long PAIR_WITHOUT_PROMPT_WINDOW_MS = 10 * 60 * 1000; // 10 min\n\n    private static final String PREF_FILE_NAME = \"companion_device_preferences.xml\";\n    private static final String PREF_KEY_AUTO_REVOKE_GRANTS_DONE = \"auto_revoke_grants_done\";\n\n    private static final int ASSOCIATE_WITHOUT_PROMPT_MAX_PER_TIME_WINDOW = 5;\n    private static final long ASSOCIATE_WITHOUT_PROMPT_WINDOW_MS = 60 * 60 * 1000; // 60 min;\n    private static final int MAX_CN_LENGTH = 500;\n\n    private static final String XML_TAG_ASSOCIATIONS = \"associations\";\n    private static final String XML_TAG_ASSOCIATION = \"association\";\n    private static final String XML_ATTR_PACKAGE = \"package\";\n    private static final String XML_ATTR_DEVICE = \"device\";\n    private static final String XML_ATTR_PROFILE = \"profile\";\n    private static final String XML_ATTR_NOTIFY_DEVICE_NEARBY = \"notify_device_nearby\";\n    private static final String XML_ATTR_TIME_APPROVED = \"time_approved\";\n    private static final String XML_FILE_NAME = \"companion_device_manager_associations.xml\";\n\n    private final CompanionDeviceManagerImpl mImpl;\n    private final ConcurrentMap<Integer, AtomicFile> mUidToStorage = new ConcurrentHashMap<>();\n    private PowerWhitelistManager mPowerWhitelistManager;\n    private PerUser<ServiceConnector<ICompanionDeviceDiscoveryService>> mServiceConnectors;\n    /** userId -> packageName -> serviceConnector */\n    private PerUser<ArrayMap<String, ServiceConnector<ICompanionDeviceService>>>\n            mDeviceListenerServiceConnectors;\n    private IAppOpsService mAppOpsManager;\n    private RoleManager mRoleManager;\n    private BluetoothAdapter mBluetoothAdapter;\n    private UserManager mUserManager;\n\n    private IFindDeviceCallback mFindDeviceCallback;\n    private ScanCallback mBleScanCallback = new BleScanCallback();\n    private AssociationRequest mRequest;\n    private String mCallingPackage;\n    private AndroidFuture<Association> mOngoingDeviceDiscovery;\n    private PermissionControllerManager mPermissionControllerManager;\n\n    private BluetoothDeviceConnectedListener mBluetoothDeviceConnectedListener =\n            new BluetoothDeviceConnectedListener();\n    private BleStateBroadcastReceiver mBleStateBroadcastReceiver = new BleStateBroadcastReceiver();\n    private List<String> mCurrentlyConnectedDevices = new ArrayList<>();\n    private ArrayMap<String, Date> mDevicesLastNearby = new ArrayMap<>();\n    private UnbindDeviceListenersRunnable\n            mUnbindDeviceListenersRunnable = new UnbindDeviceListenersRunnable();\n    private ArrayMap<String, TriggerDeviceDisappearedRunnable> mTriggerDeviceDisappearedRunnables =\n            new ArrayMap<>();\n\n    private final Object mLock = new Object();\n    private final Handler mMainHandler = Handler.getMain();\n\n    /** userId -> [association] */\n    @GuardedBy(\"mLock\")\n    private @Nullable SparseArray<Set<Association>> mCachedAssociations = new SparseArray<>();\n\n    ActivityTaskManagerInternal mAtmInternal;\n    ActivityManagerInternal mAmInternal;\n    PackageManagerInternal mPackageManagerInternal;\n\n    public CompanionDeviceManagerService(Context context) {\n        super(context);\n        mImpl = new CompanionDeviceManagerImpl();\n        mPowerWhitelistManager = context.getSystemService(PowerWhitelistManager.class);\n        mRoleManager = context.getSystemService(RoleManager.class);\n        mAppOpsManager = IAppOpsService.Stub.asInterface(\n                ServiceManager.getService(Context.APP_OPS_SERVICE));\n        mAtmInternal = LocalServices.getService(ActivityTaskManagerInternal.class);\n        mAmInternal = LocalServices.getService(ActivityManagerInternal.class);\n        mPackageManagerInternal = LocalServices.getService(PackageManagerInternal.class);\n        mPermissionControllerManager = requireNonNull(\n                context.getSystemService(PermissionControllerManager.class));\n        mUserManager = context.getSystemService(UserManager.class);\n\n        Intent serviceIntent = new Intent().setComponent(SERVICE_TO_BIND_TO);\n        mServiceConnectors = new PerUser<ServiceConnector<ICompanionDeviceDiscoveryService>>() {\n            @Override\n            protected ServiceConnector<ICompanionDeviceDiscoveryService> create(int userId) {\n                return new ServiceConnector.Impl<>(\n                        getContext(),\n                        serviceIntent, 0/* bindingFlags */, userId,\n                        ICompanionDeviceDiscoveryService.Stub::asInterface);\n            }\n        };\n\n        mDeviceListenerServiceConnectors = new PerUser<ArrayMap<String,\n                ServiceConnector<ICompanionDeviceService>>>() {\n            @NonNull\n            @Override\n            protected ArrayMap<String, ServiceConnector<ICompanionDeviceService>> create(\n                    int userId) {\n                return new ArrayMap<>();\n            }\n        };\n\n        registerPackageMonitor();\n    }\n\n    private void registerPackageMonitor() {\n        new PackageMonitor() {\n            @Override\n            public void onPackageRemoved(String packageName, int uid) {\n                Slog.d(LOG_TAG, \"onPackageRemoved(packageName = \" + packageName\n                        + \", uid = \" + uid + \")\");\n                int userId = getChangingUserId();\n                updateAssociations(\n                        as -> CollectionUtils.filter(as,\n                                a -> !Objects.equals(a.getPackageName(), packageName)),\n                        userId);\n\n                unbindDevicePresenceListener(packageName, userId);\n            }\n\n            @Override\n            public void onPackageModified(String packageName) {\n                Slog.d(LOG_TAG, \"onPackageModified(packageName = \" + packageName + \")\");\n                int userId = getChangingUserId();\n                forEach(getAllAssociations(userId, packageName), association -> {\n                    updateSpecialAccessPermissionForAssociatedPackage(association);\n                });\n            }\n\n        }.register(getContext(), FgThread.get().getLooper(), UserHandle.ALL, true);\n    }\n\n    private void unbindDevicePresenceListener(String packageName, int userId) {\n        ServiceConnector<ICompanionDeviceService> deviceListener =\n                mDeviceListenerServiceConnectors.forUser(userId)\n                        .remove(packageName);\n        if (deviceListener != null) {\n            deviceListener.unbind();\n        }\n    }\n\n    @Override\n    public void onStart() {\n        publishBinderService(Context.COMPANION_DEVICE_SERVICE, mImpl);\n    }\n\n    @Override\n    public void onBootPhase(int phase) {\n        if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {\n            // Init Bluetooth\n            mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();\n            if (mBluetoothAdapter != null) {\n                mBluetoothAdapter.registerBluetoothConnectionCallback(\n                        getContext().getMainExecutor(),\n                        mBluetoothDeviceConnectedListener);\n                getContext().registerReceiver(\n                        mBleStateBroadcastReceiver, mBleStateBroadcastReceiver.mIntentFilter);\n                initBleScanning();\n            } else {\n                Slog.w(LOG_TAG, \"No BluetoothAdapter available\");\n            }\n        }\n    }\n\n    @Override\n    public void onUserUnlocking(@NonNull TargetUser user) {\n        int userHandle = user.getUserIdentifier();\n        Set<Association> associations = getAllAssociations(userHandle);\n        if (associations == null || associations.isEmpty()) {\n            return;\n        }\n        updateAtm(userHandle, associations);\n\n        BackgroundThread.getHandler().sendMessageDelayed(\n                obtainMessage(CompanionDeviceManagerService::maybeGrantAutoRevokeExemptions, this),\n                MINUTES.toMillis(10));\n    }\n\n    void maybeGrantAutoRevokeExemptions() {\n        Slog.d(LOG_TAG, \"maybeGrantAutoRevokeExemptions()\");\n        PackageManager pm = getContext().getPackageManager();\n        for (int userId : LocalServices.getService(UserManagerInternal.class).getUserIds()) {\n            SharedPreferences pref = getContext().getSharedPreferences(\n                    new File(Environment.getUserSystemDirectory(userId), PREF_FILE_NAME),\n                    Context.MODE_PRIVATE);\n            if (pref.getBoolean(PREF_KEY_AUTO_REVOKE_GRANTS_DONE, false)) {\n                continue;\n            }\n\n            try {\n                Set<Association> associations = getAllAssociations(userId);\n                if (associations == null) {\n                    continue;\n                }\n                for (Association a : associations) {\n                    try {\n                        int uid = pm.getPackageUidAsUser(a.getPackageName(), userId);\n                        exemptFromAutoRevoke(a.getPackageName(), uid);\n                    } catch (PackageManager.NameNotFoundException e) {\n                        Slog.w(LOG_TAG, \"Unknown companion package: \" + a.getPackageName(), e);\n                    }\n                }\n            } finally {\n                pref.edit().putBoolean(PREF_KEY_AUTO_REVOKE_GRANTS_DONE, true).apply();\n            }\n        }\n    }\n\n    @Override\n    public void binderDied() {\n        Slog.w(LOG_TAG, \"binderDied()\");\n        mMainHandler.post(this::cleanup);\n    }\n\n    private void cleanup() {\n        Slog.d(LOG_TAG, \"cleanup(); discovery = \"\n                + mOngoingDeviceDiscovery + \", request = \" + mRequest);\n        synchronized (mLock) {\n            AndroidFuture<Association> ongoingDeviceDiscovery = mOngoingDeviceDiscovery;\n            if (ongoingDeviceDiscovery != null && !ongoingDeviceDiscovery.isDone()) {\n                ongoingDeviceDiscovery.cancel(true);\n            }\n            mFindDeviceCallback = unlinkToDeath(mFindDeviceCallback, this, 0);\n            mRequest = null;\n            mCallingPackage = null;\n        }\n    }\n\n    /**\n     * Usage: {@code a = unlinkToDeath(a, deathRecipient, flags); }\n     */\n    @Nullable\n    @CheckResult\n    private static <T extends IInterface> T unlinkToDeath(T iinterface,\n            IBinder.DeathRecipient deathRecipient, int flags) {\n        if (iinterface != null) {\n            iinterface.asBinder().unlinkToDeath(deathRecipient, flags);\n        }\n        return null;\n    }\n\n    class CompanionDeviceManagerImpl extends ICompanionDeviceManager.Stub {\n\n        @Override\n        public boolean onTransact(int code, Parcel data, Parcel reply, int flags)\n                throws RemoteException {\n            try {\n                return super.onTransact(code, data, reply, flags);\n            } catch (Throwable e) {\n                Slog.e(LOG_TAG, \"Error during IPC\", e);\n                throw ExceptionUtils.propagate(e, RemoteException.class);\n            }\n        }\n\n        @Override\n        public void associate(\n                AssociationRequest request,\n                IFindDeviceCallback callback,\n                String callingPackage) throws RemoteException {\n            Slog.i(LOG_TAG, \"associate(request = \" + request + \", callback = \" + callback\n                    + \", callingPackage = \" + callingPackage + \")\");\n            checkNotNull(request, \"Request cannot be null\");\n            checkNotNull(callback, \"Callback cannot be null\");\n            checkCallerIsSystemOr(callingPackage);\n            int userId = getCallingUserId();\n            checkUsesFeature(callingPackage, userId);\n            checkProfilePermissions(request);\n\n            mFindDeviceCallback = callback;\n            mRequest = request;\n            mCallingPackage = callingPackage;\n            request.setCallingPackage(callingPackage);\n\n            if (mayAssociateWithoutPrompt(callingPackage, userId)) {\n                Slog.i(LOG_TAG, \"setSkipPrompt(true)\");\n                request.setSkipPrompt(true);\n            }\n            callback.asBinder().linkToDeath(CompanionDeviceManagerService.this /* recipient */, 0);\n\n            AndroidFuture<String> fetchProfileDescription =\n                    request.getDeviceProfile() == null\n                            ? AndroidFuture.completedFuture(null)\n                            : getDeviceProfilePermissionDescription(\n                                    request.getDeviceProfile());\n\n            mOngoingDeviceDiscovery = fetchProfileDescription.thenComposeAsync(description -> {\n                Slog.d(LOG_TAG, \"fetchProfileDescription done: \" + description);\n\n                request.setDeviceProfilePrivilegesDescription(description);\n\n                return mServiceConnectors.forUser(userId).postAsync(service -> {\n                    Slog.d(LOG_TAG, \"Connected to CDM service; starting discovery for \" + request);\n\n                    AndroidFuture<Association> future = new AndroidFuture<>();\n                    service.startDiscovery(request, callingPackage, callback, future);\n                    return future;\n                }).cancelTimeout();\n\n            }, FgThread.getExecutor()).whenComplete(uncheckExceptions((association, err) -> {\n                if (err == null) {\n                    addAssociation(association, userId);\n                } else {\n                    Slog.e(LOG_TAG, \"Failed to discover device(s)\", err);\n                    callback.onFailure(\"No devices found: \" + err.getMessage());\n                }\n                cleanup();\n            }));\n        }\n\n        @Override\n        public void stopScan(AssociationRequest request,\n                IFindDeviceCallback callback,\n                String callingPackage) {\n            Slog.d(LOG_TAG, \"stopScan(request = \" + request + \")\");\n            if (Objects.equals(request, mRequest)\n                    && Objects.equals(callback, mFindDeviceCallback)\n                    && Objects.equals(callingPackage, mCallingPackage)) {\n                cleanup();\n            }\n        }\n\n        @Override\n        public List<String> getAssociations(String callingPackage, int userId)\n                throws RemoteException {\n            if (!callerCanManageCompanionDevices()) {\n                checkCallerIsSystemOr(callingPackage, userId);\n                checkUsesFeature(callingPackage, getCallingUserId());\n            }\n            return new ArrayList<>(map(\n                    getAllAssociations(userId, callingPackage),\n                    a -> a.getDeviceMacAddress()));\n        }\n\n        @Override\n        public List<Association> getAssociationsForUser(int userId) {\n            if (!callerCanManageCompanionDevices()) {\n                throw new SecurityException(\"Caller must hold \"\n                        + android.Manifest.permission.MANAGE_COMPANION_DEVICES);\n            }\n\n            return new ArrayList<>(getAllAssociations(userId, null /* packageFilter */));\n        }\n\n        //TODO also revoke notification access\n        @Override\n        public void disassociate(String deviceMacAddress, String callingPackage)\n                throws RemoteException {\n            checkNotNull(deviceMacAddress);\n            checkCallerIsSystemOr(callingPackage);\n            checkUsesFeature(callingPackage, getCallingUserId());\n            removeAssociation(getCallingUserId(), callingPackage, deviceMacAddress);\n        }\n\n        private boolean callerCanManageCompanionDevices() {\n            return getContext().checkCallingOrSelfPermission(\n                    android.Manifest.permission.MANAGE_COMPANION_DEVICES)\n                    == PERMISSION_GRANTED;\n        }\n\n        private void checkCallerIsSystemOr(String pkg) throws RemoteException {\n            checkCallerIsSystemOr(pkg, getCallingUserId());\n        }\n\n        private void checkCallerIsSystemOr(String pkg, int userId) throws RemoteException {\n            if (isCallerSystem()) {\n                return;\n            }\n\n            checkArgument(getCallingUserId() == userId,\n                    \"Must be called by either same user or system\");\n            int callingUid = Binder.getCallingUid();\n            if (mAppOpsManager.checkPackage(callingUid, pkg) != AppOpsManager.MODE_ALLOWED) {\n                throw new SecurityException(pkg + \" doesn't belong to uid \" + callingUid);\n            }\n        }\n\n        private void checkProfilePermissions(AssociationRequest request) {\n            checkProfilePermission(request,\n                    AssociationRequest.DEVICE_PROFILE_WATCH,\n                    Manifest.permission.REQUEST_COMPANION_PROFILE_WATCH);\n        }\n\n        private void checkProfilePermission(\n                AssociationRequest request, String profile, String permission) {\n            if (profile.equals(request.getDeviceProfile())\n                    && getContext().checkCallingOrSelfPermission(permission)\n                            != PackageManager.PERMISSION_GRANTED) {\n                throw new SecurityException(\"Using \" + profile + \" requires \" + permission);\n            }\n        }\n\n        @Override\n        public PendingIntent requestNotificationAccess(ComponentName component)\n                throws RemoteException {\n            String callingPackage = component.getPackageName();\n            checkCanCallNotificationApi(callingPackage);\n            int userId = getCallingUserId();\n            if (component.flattenToString().length() > MAX_CN_LENGTH) {\n                throw new IllegalArgumentException(\"Component name is too long.\");\n            }\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return PendingIntent.getActivityAsUser(getContext(),\n                        0 /* request code */,\n                        NotificationAccessConfirmationActivityContract.launcherIntent(\n                                getContext(), userId, component),\n                        PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_ONE_SHOT\n                                | PendingIntent.FLAG_CANCEL_CURRENT,\n                        null /* options */,\n                        new UserHandle(userId));\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n\n        @Override\n        public boolean hasNotificationAccess(ComponentName component) throws RemoteException {\n            checkCanCallNotificationApi(component.getPackageName());\n            String setting = Settings.Secure.getString(getContext().getContentResolver(),\n                    Settings.Secure.ENABLED_NOTIFICATION_LISTENERS);\n            return new ComponentNameSet(setting).contains(component);\n        }\n\n        @Override\n        public boolean isDeviceAssociatedForWifiConnection(String packageName, String macAddress,\n                int userId) {\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.MANAGE_COMPANION_DEVICES, \"isDeviceAssociated\");\n\n            boolean bypassMacPermission = getContext().getPackageManager().checkPermission(\n                    android.Manifest.permission.COMPANION_APPROVE_WIFI_CONNECTIONS, packageName)\n                    == PERMISSION_GRANTED;\n            if (bypassMacPermission) {\n                return true;\n            }\n\n            return any(\n                    getAllAssociations(userId, packageName),\n                    a -> Objects.equals(a.getDeviceMacAddress(), macAddress));\n        }\n\n        @Override\n        public void registerDevicePresenceListenerService(\n                String packageName, String deviceAddress)\n                throws RemoteException {\n            registerDevicePresenceListenerActive(packageName, deviceAddress, true);\n        }\n\n        @Override\n        public void unregisterDevicePresenceListenerService(\n                String packageName, String deviceAddress)\n                throws RemoteException {\n            registerDevicePresenceListenerActive(packageName, deviceAddress, false);\n        }\n\n        private void registerDevicePresenceListenerActive(String packageName, String deviceAddress,\n                boolean active) throws RemoteException {\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.REQUEST_OBSERVE_COMPANION_DEVICE_PRESENCE,\n                    \"[un]registerDevicePresenceListenerService\");\n            checkCallerIsSystemOr(packageName);\n\n            int userId = getCallingUserId();\n            Set<Association> deviceAssociations = CollectionUtils.filter(\n                    getAllAssociations(userId, packageName),\n                    association -> deviceAddress.equals(association.getDeviceMacAddress()));\n\n            if (deviceAssociations.isEmpty()) {\n                throw new RemoteException(new DeviceNotAssociatedException(\"App \" + packageName\n                        + \" is not associated with device \" + deviceAddress\n                        + \" for user \" + userId));\n            }\n\n            updateAssociations(associations -> map(associations, association -> {\n                if (Objects.equals(association.getPackageName(), packageName)\n                        && Objects.equals(association.getDeviceMacAddress(), deviceAddress)) {\n                    return new Association(\n                            association.getUserId(),\n                            association.getDeviceMacAddress(),\n                            association.getPackageName(),\n                            association.getDeviceProfile(),\n                            active, /* notifyOnDeviceNearby */\n                            association.getTimeApprovedMs());\n                } else {\n                    return association;\n                }\n            }), userId);\n\n            restartBleScan();\n        }\n\n        @Override\n        public void createAssociation(String packageName, String macAddress, int userId,\n                byte[] certificate) {\n            if (!getContext().getPackageManager().hasSigningCertificate(\n                    packageName, certificate, CERT_INPUT_SHA256)) {\n                Slog.e(LOG_TAG, \"Given certificate doesn't match the package certificate.\");\n                return;\n            }\n\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.ASSOCIATE_COMPANION_DEVICES, \"createAssociation\");\n\n            addAssociation(new Association(\n                    userId, macAddress, packageName, null, false,\n                    System.currentTimeMillis()), userId);\n        }\n\n        private void checkCanCallNotificationApi(String callingPackage) throws RemoteException {\n            checkCallerIsSystemOr(callingPackage);\n            int userId = getCallingUserId();\n            checkState(!ArrayUtils.isEmpty(getAllAssociations(userId, callingPackage)),\n                    \"App must have an association before calling this API\");\n            checkUsesFeature(callingPackage, userId);\n        }\n\n        private void checkUsesFeature(String pkg, int userId) {\n            if (isCallerSystem()) {\n                // Drop the requirement for calls from system process\n                return;\n            }\n\n            FeatureInfo[] reqFeatures = getPackageInfo(pkg, userId).reqFeatures;\n            String requiredFeature = PackageManager.FEATURE_COMPANION_DEVICE_SETUP;\n            int numFeatures = ArrayUtils.size(reqFeatures);\n            for (int i = 0; i < numFeatures; i++) {\n                if (requiredFeature.equals(reqFeatures[i].name)) return;\n            }\n            throw new IllegalStateException(\"Must declare uses-feature \"\n                    + requiredFeature\n                    + \" in manifest to use this API\");\n        }\n\n        @Override\n        public boolean canPairWithoutPrompt(\n                String packageName, String deviceMacAddress, int userId) {\n            return CollectionUtils.any(\n                    getAllAssociations(userId, packageName, deviceMacAddress),\n                    a -> System.currentTimeMillis() - a.getTimeApprovedMs()\n                            < PAIR_WITHOUT_PROMPT_WINDOW_MS);\n        }\n\n        @Override\n        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n                throws RemoteException {\n            new ShellCmd().exec(this, in, out, err, args, callback, resultReceiver);\n        }\n\n        @Override\n        public void dump(@NonNull FileDescriptor fd,\n                @NonNull PrintWriter fout,\n                @Nullable String[] args) {\n            if (!DumpUtils.checkDumpAndUsageStatsPermission(getContext(), LOG_TAG, fout)) {\n                return;\n            }\n\n            fout.append(\"Companion Device Associations:\").append('\\n');\n            synchronized (mLock) {\n                for (UserInfo user : getAllUsers()) {\n                    forEach(mCachedAssociations.get(user.id), a -> {\n                        fout.append(\"  \")\n                                .append(\"u\").append(\"\" + a.getUserId()).append(\": \")\n                                .append(a.getPackageName()).append(\" - \")\n                                .append(a.getDeviceMacAddress()).append('\\n');\n                    });\n                }\n            }\n        }\n    }\n\n    private static int getCallingUserId() {\n        return UserHandle.getUserId(Binder.getCallingUid());\n    }\n\n    private static boolean isCallerSystem() {\n        return Binder.getCallingUid() == Process.SYSTEM_UID;\n    }\n\n    void addAssociation(Association association, int userId) {\n        updateSpecialAccessPermissionForAssociatedPackage(association);\n        recordAssociation(association, userId);\n    }\n\n    void removeAssociation(int userId, String pkg, String deviceMacAddress) {\n        updateAssociations(associations -> CollectionUtils.filter(associations, association -> {\n            boolean notMatch = association.getUserId() != userId\n                    || !Objects.equals(association.getDeviceMacAddress(), deviceMacAddress)\n                    || !Objects.equals(association.getPackageName(), pkg);\n            if (!notMatch) {\n                onAssociationPreRemove(association);\n            }\n            return notMatch;\n        }), userId);\n        restartBleScan();\n    }\n\n    void onAssociationPreRemove(Association association) {\n        if (association.isNotifyOnDeviceNearby()) {\n            ServiceConnector<ICompanionDeviceService> serviceConnector =\n                    mDeviceListenerServiceConnectors.forUser(association.getUserId())\n                            .get(association.getPackageName());\n            if (serviceConnector != null) {\n                serviceConnector.unbind();\n            }\n        }\n\n        String deviceProfile = association.getDeviceProfile();\n        if (deviceProfile != null) {\n            Association otherAssociationWithDeviceProfile = find(\n                    getAllAssociations(association.getUserId()),\n                    a -> !a.equals(association) && deviceProfile.equals(a.getDeviceProfile()));\n            if (otherAssociationWithDeviceProfile != null) {\n                Slog.i(LOG_TAG, \"Not revoking \" + deviceProfile\n                        + \" for \" + association\n                        + \" - profile still present in \" + otherAssociationWithDeviceProfile);\n            } else {\n                long identity = Binder.clearCallingIdentity();\n                try {\n                    mRoleManager.removeRoleHolderAsUser(\n                            association.getDeviceProfile(),\n                            association.getPackageName(),\n                            RoleManager.MANAGE_HOLDERS_FLAG_DONT_KILL_APP,\n                            UserHandle.of(association.getUserId()),\n                            getContext().getMainExecutor(),\n                            success -> {\n                                if (!success) {\n                                    Slog.e(LOG_TAG, \"Failed to revoke device profile role \"\n                                            + association.getDeviceProfile()\n                                            + \" to \" + association.getPackageName()\n                                            + \" for user \" + association.getUserId());\n                                }\n                            });\n                } finally {\n                    Binder.restoreCallingIdentity(identity);\n                }\n            }\n        }\n    }\n\n    private void updateSpecialAccessPermissionForAssociatedPackage(Association association) {\n        PackageInfo packageInfo = getPackageInfo(\n                association.getPackageName(),\n                association.getUserId());\n        if (packageInfo == null) {\n            return;\n        }\n\n        Binder.withCleanCallingIdentity(obtainRunnable(CompanionDeviceManagerService::\n                updateSpecialAccessPermissionAsSystem, this, association, packageInfo)\n                .recycleOnUse());\n    }\n\n    private void updateSpecialAccessPermissionAsSystem(\n            Association association, PackageInfo packageInfo) {\n        if (containsEither(packageInfo.requestedPermissions,\n                android.Manifest.permission.RUN_IN_BACKGROUND,\n                android.Manifest.permission.REQUEST_COMPANION_RUN_IN_BACKGROUND)) {\n            mPowerWhitelistManager.addToWhitelist(packageInfo.packageName);\n        } else {\n            mPowerWhitelistManager.removeFromWhitelist(packageInfo.packageName);\n        }\n\n        NetworkPolicyManager networkPolicyManager = NetworkPolicyManager.from(getContext());\n        if (containsEither(packageInfo.requestedPermissions,\n                android.Manifest.permission.USE_DATA_IN_BACKGROUND,\n                android.Manifest.permission.REQUEST_COMPANION_USE_DATA_IN_BACKGROUND)) {\n            networkPolicyManager.addUidPolicy(\n                    packageInfo.applicationInfo.uid,\n                    NetworkPolicyManager.POLICY_ALLOW_METERED_BACKGROUND);\n        } else {\n            networkPolicyManager.removeUidPolicy(\n                    packageInfo.applicationInfo.uid,\n                    NetworkPolicyManager.POLICY_ALLOW_METERED_BACKGROUND);\n        }\n\n        exemptFromAutoRevoke(packageInfo.packageName, packageInfo.applicationInfo.uid);\n\n        if (mCurrentlyConnectedDevices.contains(association.getDeviceMacAddress())) {\n            grantDeviceProfile(association);\n        }\n\n        if (association.isNotifyOnDeviceNearby()) {\n            restartBleScan();\n        }\n    }\n\n    private void exemptFromAutoRevoke(String packageName, int uid) {\n        try {\n            mAppOpsManager.setMode(\n                    AppOpsManager.OP_AUTO_REVOKE_PERMISSIONS_IF_UNUSED,\n                    uid,\n                    packageName,\n                    AppOpsManager.MODE_IGNORED);\n        } catch (RemoteException e) {\n            Slog.w(LOG_TAG,\n                    \"Error while granting auto revoke exemption for \" + packageName, e);\n        }\n    }\n\n    private Set<String> getSameOemPackageCerts(\n            String packageName, String[] oemPackages, String[] sameOemCerts) {\n        Set<String> sameOemPackageCerts = new HashSet<>();\n\n        // Assume OEM may enter same package name in the parallel string array with\n        // multiple APK certs corresponding to it\n        for (int i = 0; i < oemPackages.length; i++) {\n            if (oemPackages[i].equals(packageName)) {\n                sameOemPackageCerts.add(sameOemCerts[i].replaceAll(\":\", \"\"));\n            }\n        }\n\n        return sameOemPackageCerts;\n    }\n\n    boolean mayAssociateWithoutPrompt(String packageName, int userId) {\n        String[] sameOemPackages = getContext()\n                .getResources()\n                .getStringArray(com.android.internal.R.array.config_companionDevicePackages);\n        if (!ArrayUtils.contains(sameOemPackages, packageName)) {\n            Slog.w(LOG_TAG, packageName\n                    + \" can not silently create associations due to no package found.\"\n                    + \" Packages from OEM: \" + Arrays.toString(sameOemPackages)\n            );\n            return false;\n        }\n\n        // Throttle frequent associations\n        long now = System.currentTimeMillis();\n        Set<Association> recentAssociations = filter(\n                getAllAssociations(userId, packageName),\n                a -> now - a.getTimeApprovedMs() < ASSOCIATE_WITHOUT_PROMPT_WINDOW_MS);\n\n        if (recentAssociations.size() >= ASSOCIATE_WITHOUT_PROMPT_MAX_PER_TIME_WINDOW) {\n            Slog.w(LOG_TAG, \"Too many associations. \" + packageName\n                    + \" already associated \" + recentAssociations.size()\n                    + \" devices within the last \" + ASSOCIATE_WITHOUT_PROMPT_WINDOW_MS\n                    + \"ms: \" + recentAssociations);\n            return false;\n        }\n        String[] sameOemCerts = getContext()\n                .getResources()\n                .getStringArray(com.android.internal.R.array.config_companionDeviceCerts);\n\n        Signature[] signatures = mPackageManagerInternal\n                .getPackage(packageName).getSigningDetails().signatures;\n        String[] apkCerts = PackageUtils.computeSignaturesSha256Digests(signatures);\n\n        Set<String> sameOemPackageCerts =\n                getSameOemPackageCerts(packageName, sameOemPackages, sameOemCerts);\n\n        for (String cert : apkCerts) {\n            if (sameOemPackageCerts.contains(cert)) {\n                return true;\n            }\n        }\n\n        Slog.w(LOG_TAG, packageName\n                + \" can not silently create associations. \" + packageName\n                + \" has SHA256 certs from APK: \" + Arrays.toString(apkCerts)\n                + \" and from OEM: \" + Arrays.toString(sameOemCerts)\n        );\n\n        return false;\n    }\n\n    private static <T> boolean containsEither(T[] array, T a, T b) {\n        return ArrayUtils.contains(array, a) || ArrayUtils.contains(array, b);\n    }\n\n    @Nullable\n    private PackageInfo getPackageInfo(String packageName, int userId) {\n        return Binder.withCleanCallingIdentity(PooledLambda.obtainSupplier((context, pkg, id) -> {\n            try {\n                return context.getPackageManager().getPackageInfoAsUser(\n                        pkg,\n                        PackageManager.GET_PERMISSIONS | PackageManager.GET_CONFIGURATIONS,\n                        id);\n            } catch (PackageManager.NameNotFoundException e) {\n                Slog.e(LOG_TAG, \"Failed to get PackageInfo for package \" + pkg, e);\n                return null;\n            }\n        }, getContext(), packageName, userId).recycleOnUse());\n    }\n\n    private void recordAssociation(Association association, int userId) {\n        Slog.i(LOG_TAG, \"recordAssociation(\" + association + \")\");\n        updateAssociations(associations -> CollectionUtils.add(associations, association), userId);\n    }\n\n    private void updateAssociations(Function<Set<Association>, Set<Association>> update,\n            int userId) {\n        synchronized (mLock) {\n            final Set<Association> old = getAllAssociations(userId);\n            Set<Association> associations = new ArraySet<>(old);\n            associations = update.apply(associations);\n            Slog.i(LOG_TAG, \"Updating associations: \" + old + \"  -->  \" + associations);\n            mCachedAssociations.put(userId, Collections.unmodifiableSet(associations));\n            BackgroundThread.getHandler().sendMessage(PooledLambda.obtainMessage(\n                    CompanionDeviceManagerService::persistAssociations,\n                    this, associations, userId));\n\n            updateAtm(userId, associations);\n        }\n    }\n\n    private void updateAtm(int userId, Set<Association> associations) {\n        final Set<Integer> companionAppUids = new ArraySet<>();\n        for (Association association : associations) {\n            final int uid = mPackageManagerInternal.getPackageUid(association.getPackageName(),\n                    0, userId);\n            if (uid >= 0) {\n                companionAppUids.add(uid);\n            }\n        }\n        if (mAtmInternal != null) {\n            mAtmInternal.setCompanionAppUids(userId, companionAppUids);\n        }\n        if (mAmInternal != null) {\n            // Make a copy of companionAppUids and send it to ActivityManager.\n            mAmInternal.setCompanionAppUids(userId, new ArraySet<>(companionAppUids));\n        }\n    }\n\n    private void persistAssociations(Set<Association> associations, int userId) {\n        Slog.i(LOG_TAG, \"Writing associations to disk: \" + associations);\n        final AtomicFile file = getStorageFileForUser(userId);\n        synchronized (file) {\n            file.write(out -> {\n                XmlSerializer xml = Xml.newSerializer();\n                try {\n                    xml.setOutput(out, StandardCharsets.UTF_8.name());\n                    xml.setFeature(\"http://xmlpull.org/v1/doc/features.html#indent-output\", true);\n                    xml.startDocument(null, true);\n                    xml.startTag(null, XML_TAG_ASSOCIATIONS);\n\n                    forEach(associations, association -> {\n                        XmlSerializer tag = xml.startTag(null, XML_TAG_ASSOCIATION)\n                                .attribute(null, XML_ATTR_PACKAGE, association.getPackageName())\n                                .attribute(null, XML_ATTR_DEVICE,\n                                        association.getDeviceMacAddress());\n                        if (association.getDeviceProfile() != null) {\n                            tag.attribute(null, XML_ATTR_PROFILE, association.getDeviceProfile());\n                            tag.attribute(null, XML_ATTR_NOTIFY_DEVICE_NEARBY,\n                                    Boolean.toString(\n                                            association.isNotifyOnDeviceNearby()));\n                        }\n                        tag.attribute(null, XML_ATTR_TIME_APPROVED,\n                                Long.toString(association.getTimeApprovedMs()));\n                        tag.endTag(null, XML_TAG_ASSOCIATION);\n                    });\n\n                    xml.endTag(null, XML_TAG_ASSOCIATIONS);\n                    xml.endDocument();\n                } catch (Exception e) {\n                    Slog.e(LOG_TAG, \"Error while writing associations file\", e);\n                    throw ExceptionUtils.propagate(e);\n                }\n            });\n        }\n    }\n\n    private AtomicFile getStorageFileForUser(int userId) {\n        return mUidToStorage.computeIfAbsent(userId, (u) ->\n                new AtomicFile(new File(\n                        //TODO deprecated method - what's the right replacement?\n                        Environment.getUserSystemDirectory(u),\n                        XML_FILE_NAME)));\n    }\n\n    @Nullable\n    private Set<Association> getAllAssociations(int userId) {\n        synchronized (mLock) {\n            if (mCachedAssociations.get(userId) == null) {\n                mCachedAssociations.put(userId, Collections.unmodifiableSet(\n                        emptyIfNull(readAllAssociations(userId))));\n                Slog.i(LOG_TAG, \"Read associations from disk: \" + mCachedAssociations);\n            }\n            return mCachedAssociations.get(userId);\n        }\n    }\n\n    private List<UserInfo> getAllUsers() {\n        long identity = Binder.clearCallingIdentity();\n        try {\n            return mUserManager.getUsers();\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private Set<Association> getAllAssociations(int userId, @Nullable String packageFilter) {\n        return CollectionUtils.filter(\n                getAllAssociations(userId),\n                // Null filter == get all associations\n                a -> packageFilter == null || Objects.equals(packageFilter, a.getPackageName()));\n    }\n\n    private Set<Association> getAllAssociations() {\n        long identity = Binder.clearCallingIdentity();\n        try {\n            ArraySet<Association> result = new ArraySet<>();\n            for (UserInfo user : mUserManager.getAliveUsers()) {\n                result.addAll(getAllAssociations(user.id));\n            }\n            return result;\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private Set<Association> getAllAssociations(\n            int userId, @Nullable String packageFilter, @Nullable String addressFilter) {\n        return CollectionUtils.filter(\n                getAllAssociations(userId),\n                // Null filter == get all associations\n                a -> (packageFilter == null || Objects.equals(packageFilter, a.getPackageName()))\n                        && (addressFilter == null\n                                || Objects.equals(addressFilter, a.getDeviceMacAddress())));\n    }\n\n    private Set<Association> readAllAssociations(int userId) {\n        final AtomicFile file = getStorageFileForUser(userId);\n\n        if (!file.getBaseFile().exists()) return null;\n\n        ArraySet<Association> result = null;\n        final XmlPullParser parser = Xml.newPullParser();\n        synchronized (file) {\n            try (FileInputStream in = file.openRead()) {\n                parser.setInput(in, StandardCharsets.UTF_8.name());\n                int type;\n                while ((type = parser.next()) != XmlPullParser.END_DOCUMENT) {\n                    if (type != XmlPullParser.START_TAG\n                            && !XML_TAG_ASSOCIATIONS.equals(parser.getName())) continue;\n\n                    final String appPackage = parser.getAttributeValue(null, XML_ATTR_PACKAGE);\n                    final String deviceAddress = parser.getAttributeValue(null, XML_ATTR_DEVICE);\n\n                    final String profile = parser.getAttributeValue(null, XML_ATTR_PROFILE);\n                    final boolean persistentGrants = Boolean.valueOf(\n                            parser.getAttributeValue(null, XML_ATTR_NOTIFY_DEVICE_NEARBY));\n                    final long timeApproved = parseLongOrDefault(\n                            parser.getAttributeValue(null, XML_ATTR_TIME_APPROVED), 0L);\n\n                    if (appPackage == null || deviceAddress == null) continue;\n\n                    result = ArrayUtils.add(result,\n                            new Association(userId, deviceAddress, appPackage,\n                                    profile, persistentGrants, timeApproved));\n                }\n                return result;\n            } catch (XmlPullParserException | IOException e) {\n                Slog.e(LOG_TAG, \"Error while reading associations file\", e);\n                return null;\n            }\n        }\n    }\n\n    void onDeviceConnected(String address) {\n        Slog.d(LOG_TAG, \"onDeviceConnected(address = \" + address + \")\");\n\n        mCurrentlyConnectedDevices.add(address);\n\n        for (UserInfo user : getAllUsers()) {\n            for (Association association : getAllAssociations(user.id)) {\n                if (Objects.equals(address, association.getDeviceMacAddress())) {\n                    if (association.getDeviceProfile() != null) {\n                        Slog.i(LOG_TAG, \"Granting role \" + association.getDeviceProfile()\n                                + \" to \" + association.getPackageName()\n                                + \" due to device connected: \" + association.getDeviceMacAddress());\n                        grantDeviceProfile(association);\n                    }\n                }\n            }\n        }\n\n        onDeviceNearby(address);\n    }\n\n    private void grantDeviceProfile(Association association) {\n        Slog.i(LOG_TAG, \"grantDeviceProfile(association = \" + association + \")\");\n\n        if (association.getDeviceProfile() != null) {\n            mRoleManager.addRoleHolderAsUser(\n                    association.getDeviceProfile(),\n                    association.getPackageName(),\n                    RoleManager.MANAGE_HOLDERS_FLAG_DONT_KILL_APP,\n                    UserHandle.of(association.getUserId()),\n                    getContext().getMainExecutor(),\n                    success -> {\n                        if (!success) {\n                            Slog.e(LOG_TAG, \"Failed to grant device profile role \"\n                                    + association.getDeviceProfile()\n                                    + \" to \" + association.getPackageName()\n                                    + \" for user \" + association.getUserId());\n                        }\n                    });\n        }\n    }\n\n    void onDeviceDisconnected(String address) {\n        Slog.d(LOG_TAG, \"onDeviceDisconnected(address = \" + address + \")\");\n\n        mCurrentlyConnectedDevices.remove(address);\n\n        Date lastSeen = mDevicesLastNearby.get(address);\n        if (isDeviceDisappeared(lastSeen)) {\n            onDeviceDisappeared(address);\n            unscheduleTriggerDeviceDisappearedRunnable(address);\n        }\n    }\n\n    private boolean isDeviceDisappeared(Date lastSeen) {\n        return lastSeen == null || System.currentTimeMillis() - lastSeen.getTime()\n                >= DEVICE_DISAPPEARED_UNBIND_TIMEOUT_MS;\n    }\n\n    private ServiceConnector<ICompanionDeviceService> getDeviceListenerServiceConnector(\n            Association a) {\n        return mDeviceListenerServiceConnectors.forUser(a.getUserId()).computeIfAbsent(\n                a.getPackageName(),\n                pkg -> createDeviceListenerServiceConnector(a));\n    }\n\n    private ServiceConnector<ICompanionDeviceService> createDeviceListenerServiceConnector(\n            Association a) {\n        List<ResolveInfo> resolveInfos = getContext().getPackageManager().queryIntentServicesAsUser(\n                new Intent(CompanionDeviceService.SERVICE_INTERFACE), MATCH_ALL, a.getUserId());\n        List<ResolveInfo> packageResolveInfos = filter(resolveInfos,\n                info -> Objects.equals(info.serviceInfo.packageName, a.getPackageName()));\n        if (packageResolveInfos.size() != 1) {\n            Slog.w(LOG_TAG, \"Device presence listener package must have exactly one \"\n                    + \"CompanionDeviceService, but \" + a.getPackageName()\n                    + \" has \" + packageResolveInfos.size());\n            return new ServiceConnector.NoOp<>();\n        }\n        String servicePermission = packageResolveInfos.get(0).serviceInfo.permission;\n        if (!BIND_COMPANION_DEVICE_SERVICE.equals(servicePermission)) {\n            Slog.w(LOG_TAG, \"Binding CompanionDeviceService must have \"\n                    + BIND_COMPANION_DEVICE_SERVICE + \" permission.\");\n            return new ServiceConnector.NoOp<>();\n        }\n        ComponentName componentName = packageResolveInfos.get(0).serviceInfo.getComponentName();\n        Slog.i(LOG_TAG, \"Initializing CompanionDeviceService binding for \" + componentName);\n        return new ServiceConnector.Impl<ICompanionDeviceService>(getContext(),\n                new Intent(CompanionDeviceService.SERVICE_INTERFACE).setComponent(componentName),\n                BIND_IMPORTANT,\n                a.getUserId(),\n                ICompanionDeviceService.Stub::asInterface) {\n\n            @Override\n            protected long getAutoDisconnectTimeoutMs() {\n                // Service binding is managed manually based on corresponding device being nearby\n                return Long.MAX_VALUE;\n            }\n\n            @Override\n            public void binderDied() {\n                super.binderDied();\n\n                // Re-connect to the service if process gets killed\n                mMainHandler.postDelayed(this::connect, DEVICE_LISTENER_DIED_REBIND_TIMEOUT_MS);\n            }\n        };\n    }\n\n    private class BleScanCallback extends ScanCallback {\n        @Override\n        public void onScanResult(int callbackType, ScanResult result) {\n            if (DEBUG) {\n                Slog.i(LOG_TAG, \"onScanResult(callbackType = \"\n                        + callbackType + \", result = \" + result + \")\");\n            }\n\n            onDeviceNearby(result.getDevice().getAddress());\n        }\n\n        @Override\n        public void onBatchScanResults(List<ScanResult> results) {\n            for (int i = 0, size = results.size(); i < size; i++) {\n                onScanResult(CALLBACK_TYPE_ALL_MATCHES, results.get(i));\n            }\n        }\n\n        @Override\n        public void onScanFailed(int errorCode) {\n            if (errorCode == SCAN_FAILED_ALREADY_STARTED) {\n                // ignore - this might happen if BT tries to auto-restore scans for us in the\n                // future\n                Slog.i(LOG_TAG, \"Ignoring BLE scan error: SCAN_FAILED_ALREADY_STARTED\");\n            } else {\n                Slog.w(LOG_TAG, \"Failed to start BLE scan: error \" + errorCode);\n            }\n        }\n    }\n\n    private class BleStateBroadcastReceiver extends BroadcastReceiver {\n\n        final IntentFilter mIntentFilter =\n                new IntentFilter(BluetoothAdapter.ACTION_BLE_STATE_CHANGED);\n\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            int previousState = intent.getIntExtra(BluetoothAdapter.EXTRA_PREVIOUS_STATE, -1);\n            int newState = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, -1);\n            Slog.d(LOG_TAG, \"Received BT state transition broadcast: \"\n                    + BluetoothAdapter.nameForState(previousState)\n                    + \" -> \" + BluetoothAdapter.nameForState(newState));\n\n            boolean bleOn = newState == BluetoothAdapter.STATE_ON\n                    || newState == BluetoothAdapter.STATE_BLE_ON;\n            if (bleOn) {\n                if (mBluetoothAdapter.getBluetoothLeScanner() != null) {\n                    startBleScan();\n                } else {\n                    Slog.wtf(LOG_TAG, \"BLE on, but BluetoothLeScanner == null\");\n                }\n            }\n        }\n    }\n\n    private class UnbindDeviceListenersRunnable implements Runnable {\n\n        public String getJobId(String address) {\n            return \"CDM_deviceGone_unbind_\" + address;\n        }\n\n        @Override\n        public void run() {\n            Slog.i(LOG_TAG, \"UnbindDeviceListenersRunnable.run(); devicesNearby = \"\n                    + mDevicesLastNearby);\n            int size = mDevicesLastNearby.size();\n            for (int i = 0; i < size; i++) {\n                String address = mDevicesLastNearby.keyAt(i);\n                Date lastNearby = mDevicesLastNearby.valueAt(i);\n\n                if (isDeviceDisappeared(lastNearby)) {\n                    for (Association association : getAllAssociations(address)) {\n                        if (association.isNotifyOnDeviceNearby()) {\n                            getDeviceListenerServiceConnector(association).unbind();\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    private class TriggerDeviceDisappearedRunnable implements Runnable {\n\n        private final String mAddress;\n\n        TriggerDeviceDisappearedRunnable(String address) {\n            mAddress = address;\n        }\n\n        public void schedule() {\n            mMainHandler.removeCallbacks(this);\n            mMainHandler.postDelayed(this, this, DEVICE_DISAPPEARED_TIMEOUT_MS);\n        }\n\n        @Override\n        public void run() {\n            Slog.d(LOG_TAG, \"TriggerDeviceDisappearedRunnable.run(address = \" + mAddress + \")\");\n            if (!mCurrentlyConnectedDevices.contains(mAddress)) {\n                onDeviceDisappeared(mAddress);\n            }\n        }\n    }\n\n    private void unscheduleTriggerDeviceDisappearedRunnable(String address) {\n        Runnable r = mTriggerDeviceDisappearedRunnables.get(address);\n        if (r != null) {\n            Slog.d(LOG_TAG,\n                    \"unscheduling TriggerDeviceDisappearedRunnable(address = \" + address + \")\");\n            mMainHandler.removeCallbacks(r);\n        }\n    }\n\n    private Set<Association> getAllAssociations(String deviceAddress) {\n        List<UserInfo> aliveUsers = mUserManager.getAliveUsers();\n        Set<Association> result = new ArraySet<>();\n        for (int i = 0, size = aliveUsers.size(); i < size; i++) {\n            UserInfo user = aliveUsers.get(i);\n            for (Association association : getAllAssociations(user.id)) {\n                if (Objects.equals(association.getDeviceMacAddress(), deviceAddress)) {\n                    result.add(association);\n                }\n            }\n        }\n        return result;\n    }\n\n    private void onDeviceNearby(String address) {\n        Date timestamp = new Date();\n        Date oldTimestamp = mDevicesLastNearby.put(address, timestamp);\n\n        cancelUnbindDeviceListener(address);\n\n        mTriggerDeviceDisappearedRunnables\n                .computeIfAbsent(address, addr -> new TriggerDeviceDisappearedRunnable(address))\n                .schedule();\n\n        // Avoid spamming the app if device is already known to be nearby\n        boolean justAppeared = oldTimestamp == null\n                || timestamp.getTime() - oldTimestamp.getTime() >= DEVICE_DISAPPEARED_TIMEOUT_MS;\n        if (justAppeared) {\n            Slog.i(LOG_TAG, \"onDeviceNearby(justAppeared, address = \" + address + \")\");\n            for (Association association : getAllAssociations(address)) {\n                if (association.isNotifyOnDeviceNearby()) {\n                    Slog.i(LOG_TAG,\n                            \"Sending onDeviceAppeared to \" + association.getPackageName() + \")\");\n                    getDeviceListenerServiceConnector(association).run(\n                            service -> service.onDeviceAppeared(association.getDeviceMacAddress()));\n                }\n            }\n        }\n    }\n\n    private void onDeviceDisappeared(String address) {\n        Slog.i(LOG_TAG, \"onDeviceDisappeared(address = \" + address + \")\");\n\n        boolean hasDeviceListeners = false;\n        for (Association association : getAllAssociations(address)) {\n            if (association.isNotifyOnDeviceNearby()) {\n                Slog.i(LOG_TAG,\n                        \"Sending onDeviceDisappeared to \" + association.getPackageName() + \")\");\n                getDeviceListenerServiceConnector(association).run(\n                        service -> service.onDeviceDisappeared(address));\n                hasDeviceListeners = true;\n            }\n        }\n\n        cancelUnbindDeviceListener(address);\n        if (hasDeviceListeners) {\n            mMainHandler.postDelayed(\n                    mUnbindDeviceListenersRunnable,\n                    mUnbindDeviceListenersRunnable.getJobId(address),\n                    DEVICE_DISAPPEARED_UNBIND_TIMEOUT_MS);\n        }\n    }\n\n    private void cancelUnbindDeviceListener(String address) {\n        mMainHandler.removeCallbacks(\n                mUnbindDeviceListenersRunnable, mUnbindDeviceListenersRunnable.getJobId(address));\n    }\n\n    private void initBleScanning() {\n        Slog.i(LOG_TAG, \"initBleScanning()\");\n\n        boolean bluetoothReady = mBluetoothAdapter.registerServiceLifecycleCallback(\n                new BluetoothAdapter.ServiceLifecycleCallback() {\n                    @Override\n                    public void onBluetoothServiceUp() {\n                        Slog.i(LOG_TAG, \"Bluetooth stack is up\");\n                        startBleScan();\n                    }\n\n                    @Override\n                    public void onBluetoothServiceDown() {\n                        Slog.w(LOG_TAG, \"Bluetooth stack is down\");\n                    }\n                });\n        if (bluetoothReady) {\n            startBleScan();\n        }\n    }\n\n    void startBleScan() {\n        Slog.i(LOG_TAG, \"startBleScan()\");\n\n        List<ScanFilter> filters = getBleScanFilters();\n        if (filters.isEmpty()) {\n            return;\n        }\n        BluetoothLeScanner scanner = mBluetoothAdapter.getBluetoothLeScanner();\n        if (scanner == null) {\n            Slog.w(LOG_TAG, \"scanner == null (likely BLE isn't ON yet)\");\n        } else {\n            scanner.startScan(\n                    filters,\n                    new ScanSettings.Builder().setScanMode(SCAN_MODE_BALANCED).build(),\n                    mBleScanCallback);\n        }\n    }\n\n    void restartBleScan() {\n        mBluetoothAdapter.getBluetoothLeScanner().stopScan(mBleScanCallback);\n        startBleScan();\n    }\n\n    private List<ScanFilter> getBleScanFilters() {\n        ArrayList<ScanFilter> result = new ArrayList<>();\n        ArraySet<String> addressesSeen = new ArraySet<>();\n        for (Association association : getAllAssociations()) {\n            String address = association.getDeviceMacAddress();\n            if (addressesSeen.contains(address)) {\n                continue;\n            }\n            if (association.isNotifyOnDeviceNearby()) {\n                result.add(new ScanFilter.Builder().setDeviceAddress(address).build());\n                addressesSeen.add(address);\n            }\n        }\n        return result;\n    }\n\n    private AndroidFuture<String> getDeviceProfilePermissionDescription(String deviceProfile) {\n        AndroidFuture<String> result = new AndroidFuture<>();\n        mPermissionControllerManager.getPrivilegesDescriptionStringForProfile(\n                deviceProfile, FgThread.getExecutor(), desc -> {\n                        try {\n                            result.complete(String.valueOf(desc));\n                        } catch (Exception e) {\n                            result.completeExceptionally(e);\n                        }\n                });\n        return result;\n    }\n\n    private static long parseLongOrDefault(String str, long def) {\n        try {\n            return Long.parseLong(str);\n        } catch (NumberFormatException e) {\n            Slog.w(LOG_TAG, \"Failed to parse\", e);\n            return def;\n        }\n    }\n\n    private class ShellCmd extends ShellCommand {\n        public static final String USAGE = \"help\\n\"\n                + \"list USER_ID\\n\"\n                + \"associate USER_ID PACKAGE MAC_ADDRESS\\n\"\n                + \"disassociate USER_ID PACKAGE MAC_ADDRESS\";\n\n        ShellCmd() {\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.MANAGE_COMPANION_DEVICES, \"ShellCmd\");\n        }\n\n        @Override\n        public int onCommand(String cmd) {\n            try {\n                switch (cmd) {\n                    case \"list\": {\n                        forEach(\n                                getAllAssociations(getNextArgInt()),\n                                a -> getOutPrintWriter()\n                                        .println(a.getPackageName() + \" \"\n                                                + a.getDeviceMacAddress()));\n                    }\n                    break;\n\n                    case \"associate\": {\n                        int userId = getNextArgInt();\n                        String pkg = getNextArgRequired();\n                        String address = getNextArgRequired();\n                        addAssociation(new Association(userId, address, pkg, null, false,\n                                System.currentTimeMillis()), userId);\n                    }\n                    break;\n\n                    case \"disassociate\": {\n                        removeAssociation(getNextArgInt(), getNextArgRequired(),\n                                getNextArgRequired());\n                    }\n                    break;\n\n                    case \"simulate_connect\": {\n                        onDeviceConnected(getNextArgRequired());\n                    }\n                    break;\n\n                    case \"simulate_disconnect\": {\n                        onDeviceDisconnected(getNextArgRequired());\n                    }\n                    break;\n\n                    default:\n                        return handleDefaultCommands(cmd);\n                }\n                return 0;\n            } catch (Throwable t) {\n                Slog.e(LOG_TAG, \"Error running a command: $ \" + cmd, t);\n                getErrPrintWriter().println(Log.getStackTraceString(t));\n                return 1;\n            }\n        }\n\n        private int getNextArgInt() {\n            return Integer.parseInt(getNextArgRequired());\n        }\n\n        @Override\n        public void onHelp() {\n            getOutPrintWriter().println(USAGE);\n        }\n    }\n\n\n    private class BluetoothDeviceConnectedListener\n            extends BluetoothAdapter.BluetoothConnectionCallback {\n        @Override\n        public void onDeviceConnected(BluetoothDevice device) {\n            CompanionDeviceManagerService.this.onDeviceConnected(device.getAddress());\n        }\n\n        @Override\n        public void onDeviceDisconnected(BluetoothDevice device, @DisconnectReason int reason) {\n            Slog.d(LOG_TAG, device.getAddress() + \" disconnected w/ reason: (\" + reason + \") \"\n                    + BluetoothAdapter.BluetoothConnectionCallback.disconnectReasonText(reason));\n            CompanionDeviceManagerService.this.onDeviceDisconnected(device.getAddress());\n        }\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 12137,
                                        "general": {
                                            "word_based": 4647,
                                            "char_based": 16878
                                        },
                                        "gemini": 14632
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "eb68b0d423afb55159b1c02b0897f597c0905916",
                            "repo_path": "android_repos/base",
                            "result": "failure",
                            "downstream_patch_content": "commit eb68b0d423afb55159b1c02b0897f597c0905916\nAuthor: Guojing Yuan <guojing@google.com>\nDate:   Thu Dec 14 19:30:04 2023 +0000\n\n    [CDM][CMD] Check permissions for CDM shell commands\n    \n    Override handleShellCommand instead of onShellCommand because\n    Binder.onShellCommand checks the necessary permissions of the caller.\n    \n    Bug: 313428840\n    \n    Test: manually tested CDM shell commands\n    Change-Id: I5539b3594feb5544c458c0fd1061b51a0a808900\n    Merged-In: I5539b3594feb5544c458c0fd1061b51a0a808900\n    (cherry picked from commit 1761a0fee9c2cd9787bbb7fbdbe30b4c2b03396e)\n\ndiff --git a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\nindex 5445b63a4e20..5e8f4ef18901 100644\n--- a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n+++ b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n@@ -86,12 +86,11 @@ import android.os.Handler;\n import android.os.IBinder;\n import android.os.IInterface;\n import android.os.Parcel;\n+import android.os.ParcelFileDescriptor;\n import android.os.PowerWhitelistManager;\n import android.os.Process;\n import android.os.RemoteException;\n-import android.os.ResultReceiver;\n import android.os.ServiceManager;\n-import android.os.ShellCallback;\n import android.os.ShellCommand;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -702,10 +701,12 @@ public class CompanionDeviceManagerService extends SystemService implements Bind\n         }\n \n         @Override\n-        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n-                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n-                throws RemoteException {\n-            new ShellCmd().exec(this, in, out, err, args, callback, resultReceiver);\n+        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n+                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n+                @NonNull String[] args) {\n+            return new ShellCmd()\n+                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n+                            err.getFileDescriptor(), args);\n         }\n \n         @Override\n",
                            "downstream_patch_tokens": {
                                "openai": 570,
                                "general": {
                                    "word_based": 232,
                                    "char_based": 587
                                },
                                "gemini": 737
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java",
                                    "total_hunks": 2,
                                    "failed_hunks": [
                                        1,
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12L)\n        public void enableSecureTransport(boolean enabled) {\n            mTransportManager.enableSecureTransport(enabled);\n=======\n        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n                @NonNull String[] args) {\n            return new CompanionDeviceShellCommand(CompanionDeviceManagerService.this,\n                    mAssociationStore, mDevicePresenceMonitor, mTransportManager,\n                    mSystemDataTransferProcessor, mAssociationRequestsProcessor)\n                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n                            err.getFileDescriptor(), args);\n>>>>>>> UPSTREAM PATCH (commit 1f31bb181fc56f3deab5ce0d199220404991c438)",
                                            "merge_conflict_tokens": {
                                                "openai": 155,
                                                "general": {
                                                    "word_based": 49,
                                                    "char_based": 206
                                                },
                                                "gemini": 186
                                            }
                                        }
                                    ],
                                    "inline_merge_token_summary": {
                                        "gemini": 17112,
                                        "openai": 14415,
                                        "general_word": 4557,
                                        "general_char": 19158
                                    },
                                    "rej_file_content": "```diff\n--- services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n+++ services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n@@ -84,9 +84,7 @@ import android.os.ParcelFileDescriptor;\n import android.os.PowerWhitelistManager;\n import android.os.RemoteCallbackList;\n import android.os.RemoteException;\n-import android.os.ResultReceiver;\n import android.os.ServiceManager;\n-import android.os.ShellCallback;\n import android.os.SystemProperties;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -951,13 +949,14 @@ public class CompanionDeviceManagerService extends SystemService {\n         }\n \n         @Override\n-        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n-                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n-                throws RemoteException {\n-            new CompanionDeviceShellCommand(CompanionDeviceManagerService.this, mAssociationStore,\n-                    mDevicePresenceMonitor, mTransportManager, mSystemDataTransferProcessor,\n-                    mAssociationRequestsProcessor)\n-                    .exec(this, in, out, err, args, callback, resultReceiver);\n+        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n+                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n+                @NonNull String[] args) {\n+            return new CompanionDeviceShellCommand(CompanionDeviceManagerService.this,\n+                    mAssociationStore, mDevicePresenceMonitor, mTransportManager,\n+                    mSystemDataTransferProcessor, mAssociationRequestsProcessor)\n+                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n+                            err.getFileDescriptor(), args);\n         }\n \n         @Override\n```",
                                    "rej_file_tokens": {
                                        "openai": 351,
                                        "general": {
                                            "word_based": 141,
                                            "char_based": 466
                                        },
                                        "gemini": 416
                                    },
                                    "patch_apply_output": "patching file services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\nHunk #1 FAILED at 84.\nHunk #2 FAILED at 951.\n2 out of 2 hunks FAILED -- saving rejects to file services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java.rej",
                                    "inline_merge_output": "patching file services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\nHunk #1 already applied at 87,88.\nHunk #2 NOT MERGED at 817-829.",
                                    "upstream_file_tokens": {
                                        "openai": 13480,
                                        "general": {
                                            "word_based": 5482,
                                            "char_based": 18027
                                        },
                                        "gemini": 15497
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\npackage com.android.server.companion;\n\nimport static android.Manifest.permission.BIND_COMPANION_DEVICE_SERVICE;\nimport static android.bluetooth.le.ScanSettings.CALLBACK_TYPE_ALL_MATCHES;\nimport static android.bluetooth.le.ScanSettings.SCAN_MODE_BALANCED;\nimport static android.content.Context.BIND_IMPORTANT;\nimport static android.content.pm.PackageManager.CERT_INPUT_SHA256;\nimport static android.content.pm.PackageManager.MATCH_ALL;\nimport static android.content.pm.PackageManager.PERMISSION_GRANTED;\n\nimport static com.android.internal.util.CollectionUtils.any;\nimport static com.android.internal.util.CollectionUtils.emptyIfNull;\nimport static com.android.internal.util.CollectionUtils.filter;\nimport static com.android.internal.util.CollectionUtils.find;\nimport static com.android.internal.util.CollectionUtils.forEach;\nimport static com.android.internal.util.CollectionUtils.map;\nimport static com.android.internal.util.FunctionalUtils.uncheckExceptions;\nimport static com.android.internal.util.Preconditions.checkArgument;\nimport static com.android.internal.util.Preconditions.checkNotNull;\nimport static com.android.internal.util.Preconditions.checkState;\nimport static com.android.internal.util.function.pooled.PooledLambda.obtainMessage;\nimport static com.android.internal.util.function.pooled.PooledLambda.obtainRunnable;\n\nimport static java.util.Objects.requireNonNull;\nimport static java.util.concurrent.TimeUnit.MINUTES;\n\nimport android.Manifest;\nimport android.annotation.CheckResult;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.SuppressLint;\nimport android.app.ActivityManagerInternal;\nimport android.app.AppOpsManager;\nimport android.app.PendingIntent;\nimport android.app.role.RoleManager;\nimport android.bluetooth.BluetoothAdapter;\nimport android.bluetooth.BluetoothDevice;\nimport android.bluetooth.le.BluetoothLeScanner;\nimport android.bluetooth.le.ScanCallback;\nimport android.bluetooth.le.ScanFilter;\nimport android.bluetooth.le.ScanResult;\nimport android.bluetooth.le.ScanSettings;\nimport android.companion.Association;\nimport android.companion.AssociationRequest;\nimport android.companion.CompanionDeviceManager;\nimport android.companion.CompanionDeviceService;\nimport android.companion.DeviceNotAssociatedException;\nimport android.companion.ICompanionDeviceDiscoveryService;\nimport android.companion.ICompanionDeviceManager;\nimport android.companion.ICompanionDeviceService;\nimport android.companion.IFindDeviceCallback;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.FeatureInfo;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.Signature;\nimport android.content.pm.UserInfo;\nimport android.net.NetworkPolicyManager;\nimport android.os.Binder;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.IInterface;\nimport android.os.Parcel;\nimport android.os.PowerWhitelistManager;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.ServiceManager;\nimport android.os.ShellCallback;\nimport android.os.ShellCommand;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.permission.PermissionControllerManager;\nimport android.provider.Settings;\nimport android.provider.SettingsStringUtil.ComponentNameSet;\nimport android.text.BidiFormatter;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.ExceptionUtils;\nimport android.util.Log;\nimport android.util.PackageUtils;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.Xml;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.app.IAppOpsService;\nimport com.android.internal.content.PackageMonitor;\nimport com.android.internal.infra.AndroidFuture;\nimport com.android.internal.infra.PerUser;\nimport com.android.internal.infra.ServiceConnector;\nimport com.android.internal.notification.NotificationAccessConfirmationActivityContract;\nimport com.android.internal.os.BackgroundThread;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.CollectionUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.function.pooled.PooledLambda;\nimport com.android.server.FgThread;\nimport com.android.server.LocalServices;\nimport com.android.server.SystemService;\nimport com.android.server.pm.UserManagerInternal;\nimport com.android.server.wm.ActivityTaskManagerInternal;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\nimport org.xmlpull.v1.XmlSerializer;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.function.Function;\n\n/** @hide */\n@SuppressLint(\"LongLogTag\")\npublic class CompanionDeviceManagerService extends SystemService implements Binder.DeathRecipient {\n\n    private static final ComponentName SERVICE_TO_BIND_TO = ComponentName.createRelative(\n            CompanionDeviceManager.COMPANION_DEVICE_DISCOVERY_PACKAGE_NAME,\n            \".CompanionDeviceDiscoveryService\");\n\n    private static final long DEVICE_DISAPPEARED_TIMEOUT_MS = 10 * 1000;\n    private static final long DEVICE_DISAPPEARED_UNBIND_TIMEOUT_MS = 10 * 60 * 1000;\n\n    private static final long DEVICE_LISTENER_DIED_REBIND_TIMEOUT_MS = 10 * 1000;\n\n    private static final boolean DEBUG = false;\n    private static final String LOG_TAG = \"CompanionDeviceManagerService\";\n\n    private static final long PAIR_WITHOUT_PROMPT_WINDOW_MS = 10 * 60 * 1000; // 10 min\n\n    private static final String PREF_FILE_NAME = \"companion_device_preferences.xml\";\n    private static final String PREF_KEY_AUTO_REVOKE_GRANTS_DONE = \"auto_revoke_grants_done\";\n\n    private static final int ASSOCIATE_WITHOUT_PROMPT_MAX_PER_TIME_WINDOW = 5;\n    private static final long ASSOCIATE_WITHOUT_PROMPT_WINDOW_MS = 60 * 60 * 1000; // 60 min;\n    private static final int MAX_CN_LENGTH = 500;\n\n    private static final String XML_TAG_ASSOCIATIONS = \"associations\";\n    private static final String XML_TAG_ASSOCIATION = \"association\";\n    private static final String XML_ATTR_PACKAGE = \"package\";\n    private static final String XML_ATTR_DEVICE = \"device\";\n    private static final String XML_ATTR_PROFILE = \"profile\";\n    private static final String XML_ATTR_NOTIFY_DEVICE_NEARBY = \"notify_device_nearby\";\n    private static final String XML_ATTR_TIME_APPROVED = \"time_approved\";\n    private static final String XML_FILE_NAME = \"companion_device_manager_associations.xml\";\n\n    private final CompanionDeviceManagerImpl mImpl;\n    private final ConcurrentMap<Integer, AtomicFile> mUidToStorage = new ConcurrentHashMap<>();\n    private PowerWhitelistManager mPowerWhitelistManager;\n    private PerUser<ServiceConnector<ICompanionDeviceDiscoveryService>> mServiceConnectors;\n    /** userId -> packageName -> serviceConnector */\n    private PerUser<ArrayMap<String, ServiceConnector<ICompanionDeviceService>>>\n            mDeviceListenerServiceConnectors;\n    private IAppOpsService mAppOpsManager;\n    private RoleManager mRoleManager;\n    private BluetoothAdapter mBluetoothAdapter;\n    private UserManager mUserManager;\n\n    private IFindDeviceCallback mFindDeviceCallback;\n    private ScanCallback mBleScanCallback = new BleScanCallback();\n    private AssociationRequest mRequest;\n    private String mCallingPackage;\n    private AndroidFuture<Association> mOngoingDeviceDiscovery;\n    private PermissionControllerManager mPermissionControllerManager;\n\n    private BluetoothDeviceConnectedListener mBluetoothDeviceConnectedListener =\n            new BluetoothDeviceConnectedListener();\n    private BleStateBroadcastReceiver mBleStateBroadcastReceiver = new BleStateBroadcastReceiver();\n    private List<String> mCurrentlyConnectedDevices = new ArrayList<>();\n    private ArrayMap<String, Date> mDevicesLastNearby = new ArrayMap<>();\n    private UnbindDeviceListenersRunnable\n            mUnbindDeviceListenersRunnable = new UnbindDeviceListenersRunnable();\n    private ArrayMap<String, TriggerDeviceDisappearedRunnable> mTriggerDeviceDisappearedRunnables =\n            new ArrayMap<>();\n\n    private final Object mLock = new Object();\n    private final Handler mMainHandler = Handler.getMain();\n\n    /** userId -> [association] */\n    @GuardedBy(\"mLock\")\n    private @Nullable SparseArray<Set<Association>> mCachedAssociations = new SparseArray<>();\n\n    ActivityTaskManagerInternal mAtmInternal;\n    ActivityManagerInternal mAmInternal;\n    PackageManagerInternal mPackageManagerInternal;\n\n    public CompanionDeviceManagerService(Context context) {\n        super(context);\n        mImpl = new CompanionDeviceManagerImpl();\n        mPowerWhitelistManager = context.getSystemService(PowerWhitelistManager.class);\n        mRoleManager = context.getSystemService(RoleManager.class);\n        mAppOpsManager = IAppOpsService.Stub.asInterface(\n                ServiceManager.getService(Context.APP_OPS_SERVICE));\n        mAtmInternal = LocalServices.getService(ActivityTaskManagerInternal.class);\n        mAmInternal = LocalServices.getService(ActivityManagerInternal.class);\n        mPackageManagerInternal = LocalServices.getService(PackageManagerInternal.class);\n        mPermissionControllerManager = requireNonNull(\n                context.getSystemService(PermissionControllerManager.class));\n        mUserManager = context.getSystemService(UserManager.class);\n\n        Intent serviceIntent = new Intent().setComponent(SERVICE_TO_BIND_TO);\n        mServiceConnectors = new PerUser<ServiceConnector<ICompanionDeviceDiscoveryService>>() {\n            @Override\n            protected ServiceConnector<ICompanionDeviceDiscoveryService> create(int userId) {\n                return new ServiceConnector.Impl<>(\n                        getContext(),\n                        serviceIntent, 0/* bindingFlags */, userId,\n                        ICompanionDeviceDiscoveryService.Stub::asInterface);\n            }\n        };\n\n        mDeviceListenerServiceConnectors = new PerUser<ArrayMap<String,\n                ServiceConnector<ICompanionDeviceService>>>() {\n            @NonNull\n            @Override\n            protected ArrayMap<String, ServiceConnector<ICompanionDeviceService>> create(\n                    int userId) {\n                return new ArrayMap<>();\n            }\n        };\n\n        registerPackageMonitor();\n    }\n\n    private void registerPackageMonitor() {\n        new PackageMonitor() {\n            @Override\n            public void onPackageRemoved(String packageName, int uid) {\n                Slog.d(LOG_TAG, \"onPackageRemoved(packageName = \" + packageName\n                        + \", uid = \" + uid + \")\");\n                int userId = getChangingUserId();\n                updateAssociations(\n                        as -> CollectionUtils.filter(as,\n                                a -> !Objects.equals(a.getPackageName(), packageName)),\n                        userId);\n\n                unbindDevicePresenceListener(packageName, userId);\n            }\n\n            @Override\n            public void onPackageModified(String packageName) {\n                Slog.d(LOG_TAG, \"onPackageModified(packageName = \" + packageName + \")\");\n                int userId = getChangingUserId();\n                forEach(getAllAssociations(userId, packageName), association -> {\n                    updateSpecialAccessPermissionForAssociatedPackage(association);\n                });\n            }\n\n        }.register(getContext(), FgThread.get().getLooper(), UserHandle.ALL, true);\n    }\n\n    private void unbindDevicePresenceListener(String packageName, int userId) {\n        ServiceConnector<ICompanionDeviceService> deviceListener =\n                mDeviceListenerServiceConnectors.forUser(userId)\n                        .remove(packageName);\n        if (deviceListener != null) {\n            deviceListener.unbind();\n        }\n    }\n\n    @Override\n    public void onStart() {\n        publishBinderService(Context.COMPANION_DEVICE_SERVICE, mImpl);\n    }\n\n    @Override\n    public void onBootPhase(int phase) {\n        if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {\n            // Init Bluetooth\n            mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();\n            if (mBluetoothAdapter != null) {\n                mBluetoothAdapter.registerBluetoothConnectionCallback(\n                        getContext().getMainExecutor(),\n                        mBluetoothDeviceConnectedListener);\n                getContext().registerReceiver(\n                        mBleStateBroadcastReceiver, mBleStateBroadcastReceiver.mIntentFilter);\n                initBleScanning();\n            } else {\n                Slog.w(LOG_TAG, \"No BluetoothAdapter available\");\n            }\n        }\n    }\n\n    @Override\n    public void onUserUnlocking(@NonNull TargetUser user) {\n        int userHandle = user.getUserIdentifier();\n        Set<Association> associations = getAllAssociations(userHandle);\n        if (associations == null || associations.isEmpty()) {\n            return;\n        }\n        updateAtm(userHandle, associations);\n\n        BackgroundThread.getHandler().sendMessageDelayed(\n                obtainMessage(CompanionDeviceManagerService::maybeGrantAutoRevokeExemptions, this),\n                MINUTES.toMillis(10));\n    }\n\n    void maybeGrantAutoRevokeExemptions() {\n        Slog.d(LOG_TAG, \"maybeGrantAutoRevokeExemptions()\");\n        PackageManager pm = getContext().getPackageManager();\n        for (int userId : LocalServices.getService(UserManagerInternal.class).getUserIds()) {\n            SharedPreferences pref = getContext().getSharedPreferences(\n                    new File(Environment.getUserSystemDirectory(userId), PREF_FILE_NAME),\n                    Context.MODE_PRIVATE);\n            if (pref.getBoolean(PREF_KEY_AUTO_REVOKE_GRANTS_DONE, false)) {\n                continue;\n            }\n\n            try {\n                Set<Association> associations = getAllAssociations(userId);\n                if (associations == null) {\n                    continue;\n                }\n                for (Association a : associations) {\n                    try {\n                        int uid = pm.getPackageUidAsUser(a.getPackageName(), userId);\n                        exemptFromAutoRevoke(a.getPackageName(), uid);\n                    } catch (PackageManager.NameNotFoundException e) {\n                        Slog.w(LOG_TAG, \"Unknown companion package: \" + a.getPackageName(), e);\n                    }\n                }\n            } finally {\n                pref.edit().putBoolean(PREF_KEY_AUTO_REVOKE_GRANTS_DONE, true).apply();\n            }\n        }\n    }\n\n    @Override\n    public void binderDied() {\n        Slog.w(LOG_TAG, \"binderDied()\");\n        mMainHandler.post(this::cleanup);\n    }\n\n    private void cleanup() {\n        Slog.d(LOG_TAG, \"cleanup(); discovery = \"\n                + mOngoingDeviceDiscovery + \", request = \" + mRequest);\n        synchronized (mLock) {\n            AndroidFuture<Association> ongoingDeviceDiscovery = mOngoingDeviceDiscovery;\n            if (ongoingDeviceDiscovery != null && !ongoingDeviceDiscovery.isDone()) {\n                ongoingDeviceDiscovery.cancel(true);\n            }\n            mFindDeviceCallback = unlinkToDeath(mFindDeviceCallback, this, 0);\n            mRequest = null;\n            mCallingPackage = null;\n        }\n    }\n\n    /**\n     * Usage: {@code a = unlinkToDeath(a, deathRecipient, flags); }\n     */\n    @Nullable\n    @CheckResult\n    private static <T extends IInterface> T unlinkToDeath(T iinterface,\n            IBinder.DeathRecipient deathRecipient, int flags) {\n        if (iinterface != null) {\n            iinterface.asBinder().unlinkToDeath(deathRecipient, flags);\n        }\n        return null;\n    }\n\n    class CompanionDeviceManagerImpl extends ICompanionDeviceManager.Stub {\n\n        @Override\n        public boolean onTransact(int code, Parcel data, Parcel reply, int flags)\n                throws RemoteException {\n            try {\n                return super.onTransact(code, data, reply, flags);\n            } catch (Throwable e) {\n                Slog.e(LOG_TAG, \"Error during IPC\", e);\n                throw ExceptionUtils.propagate(e, RemoteException.class);\n            }\n        }\n\n        @Override\n        public void associate(\n                AssociationRequest request,\n                IFindDeviceCallback callback,\n                String callingPackage) throws RemoteException {\n            Slog.i(LOG_TAG, \"associate(request = \" + request + \", callback = \" + callback\n                    + \", callingPackage = \" + callingPackage + \")\");\n            checkNotNull(request, \"Request cannot be null\");\n            checkNotNull(callback, \"Callback cannot be null\");\n            checkCallerIsSystemOr(callingPackage);\n            int userId = getCallingUserId();\n            checkUsesFeature(callingPackage, userId);\n            checkProfilePermissions(request);\n\n            mFindDeviceCallback = callback;\n            mRequest = request;\n            mCallingPackage = callingPackage;\n            request.setCallingPackage(callingPackage);\n\n            if (mayAssociateWithoutPrompt(callingPackage, userId)) {\n                Slog.i(LOG_TAG, \"setSkipPrompt(true)\");\n                request.setSkipPrompt(true);\n            }\n            callback.asBinder().linkToDeath(CompanionDeviceManagerService.this /* recipient */, 0);\n\n            AndroidFuture<String> fetchProfileDescription =\n                    request.getDeviceProfile() == null\n                            ? AndroidFuture.completedFuture(null)\n                            : getDeviceProfilePermissionDescription(\n                                    request.getDeviceProfile());\n\n            mOngoingDeviceDiscovery = fetchProfileDescription.thenComposeAsync(description -> {\n                Slog.d(LOG_TAG, \"fetchProfileDescription done: \" + description);\n\n                request.setDeviceProfilePrivilegesDescription(description);\n\n                return mServiceConnectors.forUser(userId).postAsync(service -> {\n                    Slog.d(LOG_TAG, \"Connected to CDM service; starting discovery for \" + request);\n\n                    AndroidFuture<Association> future = new AndroidFuture<>();\n                    service.startDiscovery(request, callingPackage, callback, future);\n                    return future;\n                }).cancelTimeout();\n\n            }, FgThread.getExecutor()).whenComplete(uncheckExceptions((association, err) -> {\n                if (err == null) {\n                    addAssociation(association, userId);\n                    mServiceConnectors.forUser(userId).post(service -> {\n                        service.onAssociationCreated();\n                    });\n                } else {\n                    Slog.e(LOG_TAG, \"Failed to discover device(s)\", err);\n                    callback.onFailure(\"No devices found: \" + err.getMessage());\n                }\n                cleanup();\n            }));\n        }\n\n        @Override\n        public void stopScan(AssociationRequest request,\n                IFindDeviceCallback callback,\n                String callingPackage) {\n            Slog.d(LOG_TAG, \"stopScan(request = \" + request + \")\");\n            if (Objects.equals(request, mRequest)\n                    && Objects.equals(callback, mFindDeviceCallback)\n                    && Objects.equals(callingPackage, mCallingPackage)) {\n                cleanup();\n            }\n        }\n\n        @Override\n        public List<String> getAssociations(String callingPackage, int userId)\n                throws RemoteException {\n            if (!callerCanManageCompanionDevices()) {\n                checkCallerIsSystemOr(callingPackage, userId);\n                checkUsesFeature(callingPackage, getCallingUserId());\n            }\n            return new ArrayList<>(map(\n                    getAllAssociations(userId, callingPackage),\n                    a -> a.getDeviceMacAddress()));\n        }\n\n        @Override\n        public List<Association> getAssociationsForUser(int userId) {\n            if (!callerCanManageCompanionDevices()) {\n                throw new SecurityException(\"Caller must hold \"\n                        + android.Manifest.permission.MANAGE_COMPANION_DEVICES);\n            }\n\n            return new ArrayList<>(getAllAssociations(userId, null /* packageFilter */));\n        }\n\n        //TODO also revoke notification access\n        @Override\n        public void disassociate(String deviceMacAddress, String callingPackage)\n                throws RemoteException {\n            checkNotNull(deviceMacAddress);\n            checkCallerIsSystemOr(callingPackage);\n            checkUsesFeature(callingPackage, getCallingUserId());\n            removeAssociation(getCallingUserId(), callingPackage, deviceMacAddress);\n        }\n\n        private boolean callerCanManageCompanionDevices() {\n            return getContext().checkCallingOrSelfPermission(\n                    android.Manifest.permission.MANAGE_COMPANION_DEVICES)\n                    == PERMISSION_GRANTED;\n        }\n\n        private void checkCallerIsSystemOr(String pkg) throws RemoteException {\n            checkCallerIsSystemOr(pkg, getCallingUserId());\n        }\n\n        private void checkCallerIsSystemOr(String pkg, int userId) throws RemoteException {\n            if (isCallerSystem()) {\n                return;\n            }\n\n            checkArgument(getCallingUserId() == userId,\n                    \"Must be called by either same user or system\");\n            int callingUid = Binder.getCallingUid();\n            if (mAppOpsManager.checkPackage(callingUid, pkg) != AppOpsManager.MODE_ALLOWED) {\n                throw new SecurityException(pkg + \" doesn't belong to uid \" + callingUid);\n            }\n        }\n\n        private void checkProfilePermissions(AssociationRequest request) {\n            checkProfilePermission(request,\n                    AssociationRequest.DEVICE_PROFILE_WATCH,\n                    Manifest.permission.REQUEST_COMPANION_PROFILE_WATCH);\n        }\n\n        private void checkProfilePermission(\n                AssociationRequest request, String profile, String permission) {\n            if (profile.equals(request.getDeviceProfile())\n                    && getContext().checkCallingOrSelfPermission(permission)\n                            != PackageManager.PERMISSION_GRANTED) {\n                throw new SecurityException(\"Using \" + profile + \" requires \" + permission);\n            }\n        }\n\n        @Override\n        public PendingIntent requestNotificationAccess(ComponentName component)\n                throws RemoteException {\n            String callingPackage = component.getPackageName();\n            checkCanCallNotificationApi(callingPackage);\n            int userId = getCallingUserId();\n            if (component.flattenToString().length() > MAX_CN_LENGTH) {\n                throw new IllegalArgumentException(\"Component name is too long.\");\n            }\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return PendingIntent.getActivityAsUser(getContext(),\n                        0 /* request code */,\n                        NotificationAccessConfirmationActivityContract.launcherIntent(\n                                getContext(), userId, component),\n                        PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_ONE_SHOT\n                                | PendingIntent.FLAG_CANCEL_CURRENT,\n                        null /* options */,\n                        new UserHandle(userId));\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n\n        @Override\n        public boolean hasNotificationAccess(ComponentName component) throws RemoteException {\n            checkCanCallNotificationApi(component.getPackageName());\n            String setting = Settings.Secure.getString(getContext().getContentResolver(),\n                    Settings.Secure.ENABLED_NOTIFICATION_LISTENERS);\n            return new ComponentNameSet(setting).contains(component);\n        }\n\n        @Override\n        public boolean isDeviceAssociatedForWifiConnection(String packageName, String macAddress,\n                int userId) {\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.MANAGE_COMPANION_DEVICES, \"isDeviceAssociated\");\n\n            boolean bypassMacPermission = getContext().getPackageManager().checkPermission(\n                    android.Manifest.permission.COMPANION_APPROVE_WIFI_CONNECTIONS, packageName)\n                    == PERMISSION_GRANTED;\n            if (bypassMacPermission) {\n                return true;\n            }\n\n            return any(\n                    getAllAssociations(userId, packageName),\n                    a -> Objects.equals(a.getDeviceMacAddress(), macAddress));\n        }\n\n        @Override\n        public void registerDevicePresenceListenerService(\n                String packageName, String deviceAddress)\n                throws RemoteException {\n            registerDevicePresenceListenerActive(packageName, deviceAddress, true);\n        }\n\n        @Override\n        public void unregisterDevicePresenceListenerService(\n                String packageName, String deviceAddress)\n                throws RemoteException {\n            registerDevicePresenceListenerActive(packageName, deviceAddress, false);\n        }\n\n        private void registerDevicePresenceListenerActive(String packageName, String deviceAddress,\n                boolean active) throws RemoteException {\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.REQUEST_OBSERVE_COMPANION_DEVICE_PRESENCE,\n                    \"[un]registerDevicePresenceListenerService\");\n            checkCallerIsSystemOr(packageName);\n\n            int userId = getCallingUserId();\n            Set<Association> deviceAssociations = CollectionUtils.filter(\n                    getAllAssociations(userId, packageName),\n                    association -> deviceAddress.equals(association.getDeviceMacAddress()));\n\n            if (deviceAssociations.isEmpty()) {\n                throw new RemoteException(new DeviceNotAssociatedException(\"App \" + packageName\n                        + \" is not associated with device \" + deviceAddress\n                        + \" for user \" + userId));\n            }\n\n            updateAssociations(associations -> map(associations, association -> {\n                if (Objects.equals(association.getPackageName(), packageName)\n                        && Objects.equals(association.getDeviceMacAddress(), deviceAddress)) {\n                    return new Association(\n                            association.getUserId(),\n                            association.getDeviceMacAddress(),\n                            association.getPackageName(),\n                            association.getDeviceProfile(),\n                            active, /* notifyOnDeviceNearby */\n                            association.getTimeApprovedMs());\n                } else {\n                    return association;\n                }\n            }), userId);\n\n            restartBleScan();\n        }\n\n        @Override\n        public void createAssociation(String packageName, String macAddress, int userId,\n                byte[] certificate) {\n            if (!getContext().getPackageManager().hasSigningCertificate(\n                    packageName, certificate, CERT_INPUT_SHA256)) {\n                Slog.e(LOG_TAG, \"Given certificate doesn't match the package certificate.\");\n                return;\n            }\n\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.ASSOCIATE_COMPANION_DEVICES, \"createAssociation\");\n\n            addAssociation(new Association(\n                    userId, macAddress, packageName, null, false,\n                    System.currentTimeMillis()), userId);\n        }\n\n        private void checkCanCallNotificationApi(String callingPackage) throws RemoteException {\n            checkCallerIsSystemOr(callingPackage);\n            int userId = getCallingUserId();\n            checkState(!ArrayUtils.isEmpty(getAllAssociations(userId, callingPackage)),\n                    \"App must have an association before calling this API\");\n            checkUsesFeature(callingPackage, userId);\n        }\n\n        private void checkUsesFeature(String pkg, int userId) {\n            if (isCallerSystem()) {\n                // Drop the requirement for calls from system process\n                return;\n            }\n\n            FeatureInfo[] reqFeatures = getPackageInfo(pkg, userId).reqFeatures;\n            String requiredFeature = PackageManager.FEATURE_COMPANION_DEVICE_SETUP;\n            int numFeatures = ArrayUtils.size(reqFeatures);\n            for (int i = 0; i < numFeatures; i++) {\n                if (requiredFeature.equals(reqFeatures[i].name)) return;\n            }\n            throw new IllegalStateException(\"Must declare uses-feature \"\n                    + requiredFeature\n                    + \" in manifest to use this API\");\n        }\n\n        @Override\n        public boolean canPairWithoutPrompt(\n                String packageName, String deviceMacAddress, int userId) {\n            return CollectionUtils.any(\n                    getAllAssociations(userId, packageName, deviceMacAddress),\n                    a -> System.currentTimeMillis() - a.getTimeApprovedMs()\n                            < PAIR_WITHOUT_PROMPT_WINDOW_MS);\n        }\n\n        @Override\n        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n                throws RemoteException {\n            new ShellCmd().exec(this, in, out, err, args, callback, resultReceiver);\n        }\n\n        @Override\n        public void dump(@NonNull FileDescriptor fd,\n                @NonNull PrintWriter fout,\n                @Nullable String[] args) {\n            if (!DumpUtils.checkDumpAndUsageStatsPermission(getContext(), LOG_TAG, fout)) {\n                return;\n            }\n\n            fout.append(\"Companion Device Associations:\").append('\\n');\n            synchronized (mLock) {\n                for (UserInfo user : getAllUsers()) {\n                    forEach(mCachedAssociations.get(user.id), a -> {\n                        fout.append(\"  \")\n                                .append(\"u\").append(\"\" + a.getUserId()).append(\": \")\n                                .append(a.getPackageName()).append(\" - \")\n                                .append(a.getDeviceMacAddress()).append('\\n');\n                    });\n                }\n            }\n        }\n    }\n\n    private static int getCallingUserId() {\n        return UserHandle.getUserId(Binder.getCallingUid());\n    }\n\n    private static boolean isCallerSystem() {\n        return Binder.getCallingUid() == Process.SYSTEM_UID;\n    }\n\n    void addAssociation(Association association, int userId) {\n        updateSpecialAccessPermissionForAssociatedPackage(association);\n        recordAssociation(association, userId);\n    }\n\n    void removeAssociation(int userId, String pkg, String deviceMacAddress) {\n        updateAssociations(associations -> CollectionUtils.filter(associations, association -> {\n            boolean notMatch = association.getUserId() != userId\n                    || !Objects.equals(association.getDeviceMacAddress(), deviceMacAddress)\n                    || !Objects.equals(association.getPackageName(), pkg);\n            if (!notMatch) {\n                onAssociationPreRemove(association);\n            }\n            return notMatch;\n        }), userId);\n        restartBleScan();\n    }\n\n    void onAssociationPreRemove(Association association) {\n        if (association.isNotifyOnDeviceNearby()) {\n            ServiceConnector<ICompanionDeviceService> serviceConnector =\n                    mDeviceListenerServiceConnectors.forUser(association.getUserId())\n                            .get(association.getPackageName());\n            if (serviceConnector != null) {\n                serviceConnector.unbind();\n            }\n        }\n\n        String deviceProfile = association.getDeviceProfile();\n        if (deviceProfile != null) {\n            Association otherAssociationWithDeviceProfile = find(\n                    getAllAssociations(association.getUserId()),\n                    a -> !a.equals(association) && deviceProfile.equals(a.getDeviceProfile()));\n            if (otherAssociationWithDeviceProfile != null) {\n                Slog.i(LOG_TAG, \"Not revoking \" + deviceProfile\n                        + \" for \" + association\n                        + \" - profile still present in \" + otherAssociationWithDeviceProfile);\n            } else {\n                long identity = Binder.clearCallingIdentity();\n                try {\n                    mRoleManager.removeRoleHolderAsUser(\n                            association.getDeviceProfile(),\n                            association.getPackageName(),\n                            RoleManager.MANAGE_HOLDERS_FLAG_DONT_KILL_APP,\n                            UserHandle.of(association.getUserId()),\n                            getContext().getMainExecutor(),\n                            success -> {\n                                if (!success) {\n                                    Slog.e(LOG_TAG, \"Failed to revoke device profile role \"\n                                            + association.getDeviceProfile()\n                                            + \" to \" + association.getPackageName()\n                                            + \" for user \" + association.getUserId());\n                                }\n                            });\n                } finally {\n                    Binder.restoreCallingIdentity(identity);\n                }\n            }\n        }\n    }\n\n    private void updateSpecialAccessPermissionForAssociatedPackage(Association association) {\n        PackageInfo packageInfo = getPackageInfo(\n                association.getPackageName(),\n                association.getUserId());\n        if (packageInfo == null) {\n            return;\n        }\n\n        Binder.withCleanCallingIdentity(obtainRunnable(CompanionDeviceManagerService::\n                updateSpecialAccessPermissionAsSystem, this, association, packageInfo)\n                .recycleOnUse());\n    }\n\n    private void updateSpecialAccessPermissionAsSystem(\n            Association association, PackageInfo packageInfo) {\n        if (containsEither(packageInfo.requestedPermissions,\n                android.Manifest.permission.RUN_IN_BACKGROUND,\n                android.Manifest.permission.REQUEST_COMPANION_RUN_IN_BACKGROUND)) {\n            mPowerWhitelistManager.addToWhitelist(packageInfo.packageName);\n        } else {\n            mPowerWhitelistManager.removeFromWhitelist(packageInfo.packageName);\n        }\n\n        NetworkPolicyManager networkPolicyManager = NetworkPolicyManager.from(getContext());\n        if (containsEither(packageInfo.requestedPermissions,\n                android.Manifest.permission.USE_DATA_IN_BACKGROUND,\n                android.Manifest.permission.REQUEST_COMPANION_USE_DATA_IN_BACKGROUND)) {\n            networkPolicyManager.addUidPolicy(\n                    packageInfo.applicationInfo.uid,\n                    NetworkPolicyManager.POLICY_ALLOW_METERED_BACKGROUND);\n        } else {\n            networkPolicyManager.removeUidPolicy(\n                    packageInfo.applicationInfo.uid,\n                    NetworkPolicyManager.POLICY_ALLOW_METERED_BACKGROUND);\n        }\n\n        exemptFromAutoRevoke(packageInfo.packageName, packageInfo.applicationInfo.uid);\n\n        if (mCurrentlyConnectedDevices.contains(association.getDeviceMacAddress())) {\n            grantDeviceProfile(association);\n        }\n\n        if (association.isNotifyOnDeviceNearby()) {\n            restartBleScan();\n        }\n    }\n\n    private void exemptFromAutoRevoke(String packageName, int uid) {\n        try {\n            mAppOpsManager.setMode(\n                    AppOpsManager.OP_AUTO_REVOKE_PERMISSIONS_IF_UNUSED,\n                    uid,\n                    packageName,\n                    AppOpsManager.MODE_IGNORED);\n        } catch (RemoteException e) {\n            Slog.w(LOG_TAG,\n                    \"Error while granting auto revoke exemption for \" + packageName, e);\n        }\n    }\n\n    private Set<String> getSameOemPackageCerts(\n            String packageName, String[] oemPackages, String[] sameOemCerts) {\n        Set<String> sameOemPackageCerts = new HashSet<>();\n\n        // Assume OEM may enter same package name in the parallel string array with\n        // multiple APK certs corresponding to it\n        for (int i = 0; i < oemPackages.length; i++) {\n            if (oemPackages[i].equals(packageName)) {\n                sameOemPackageCerts.add(sameOemCerts[i].replaceAll(\":\", \"\"));\n            }\n        }\n\n        return sameOemPackageCerts;\n    }\n\n    boolean mayAssociateWithoutPrompt(String packageName, int userId) {\n        String[] sameOemPackages = getContext()\n                .getResources()\n                .getStringArray(com.android.internal.R.array.config_companionDevicePackages);\n        if (!ArrayUtils.contains(sameOemPackages, packageName)) {\n            Slog.w(LOG_TAG, packageName\n                    + \" can not silently create associations due to no package found.\"\n                    + \" Packages from OEM: \" + Arrays.toString(sameOemPackages)\n            );\n            return false;\n        }\n\n        // Throttle frequent associations\n        long now = System.currentTimeMillis();\n        Set<Association> recentAssociations = filter(\n                getAllAssociations(userId, packageName),\n                a -> now - a.getTimeApprovedMs() < ASSOCIATE_WITHOUT_PROMPT_WINDOW_MS);\n\n        if (recentAssociations.size() >= ASSOCIATE_WITHOUT_PROMPT_MAX_PER_TIME_WINDOW) {\n            Slog.w(LOG_TAG, \"Too many associations. \" + packageName\n                    + \" already associated \" + recentAssociations.size()\n                    + \" devices within the last \" + ASSOCIATE_WITHOUT_PROMPT_WINDOW_MS\n                    + \"ms: \" + recentAssociations);\n            return false;\n        }\n        String[] sameOemCerts = getContext()\n                .getResources()\n                .getStringArray(com.android.internal.R.array.config_companionDeviceCerts);\n\n        Signature[] signatures = mPackageManagerInternal\n                .getPackage(packageName).getSigningDetails().signatures;\n        String[] apkCerts = PackageUtils.computeSignaturesSha256Digests(signatures);\n\n        Set<String> sameOemPackageCerts =\n                getSameOemPackageCerts(packageName, sameOemPackages, sameOemCerts);\n\n        for (String cert : apkCerts) {\n            if (sameOemPackageCerts.contains(cert)) {\n                return true;\n            }\n        }\n\n        Slog.w(LOG_TAG, packageName\n                + \" can not silently create associations. \" + packageName\n                + \" has SHA256 certs from APK: \" + Arrays.toString(apkCerts)\n                + \" and from OEM: \" + Arrays.toString(sameOemCerts)\n        );\n\n        return false;\n    }\n\n    private static <T> boolean containsEither(T[] array, T a, T b) {\n        return ArrayUtils.contains(array, a) || ArrayUtils.contains(array, b);\n    }\n\n    @Nullable\n    private PackageInfo getPackageInfo(String packageName, int userId) {\n        return Binder.withCleanCallingIdentity(PooledLambda.obtainSupplier((context, pkg, id) -> {\n            try {\n                return context.getPackageManager().getPackageInfoAsUser(\n                        pkg,\n                        PackageManager.GET_PERMISSIONS | PackageManager.GET_CONFIGURATIONS,\n                        id);\n            } catch (PackageManager.NameNotFoundException e) {\n                Slog.e(LOG_TAG, \"Failed to get PackageInfo for package \" + pkg, e);\n                return null;\n            }\n        }, getContext(), packageName, userId).recycleOnUse());\n    }\n\n    private void recordAssociation(Association association, int userId) {\n        Slog.i(LOG_TAG, \"recordAssociation(\" + association + \")\");\n        updateAssociations(associations -> CollectionUtils.add(associations, association), userId);\n    }\n\n    private void updateAssociations(Function<Set<Association>, Set<Association>> update,\n            int userId) {\n        synchronized (mLock) {\n            final Set<Association> old = getAllAssociations(userId);\n            Set<Association> associations = new ArraySet<>(old);\n            associations = update.apply(associations);\n            Slog.i(LOG_TAG, \"Updating associations: \" + old + \"  -->  \" + associations);\n            mCachedAssociations.put(userId, Collections.unmodifiableSet(associations));\n            BackgroundThread.getHandler().sendMessage(PooledLambda.obtainMessage(\n                    CompanionDeviceManagerService::persistAssociations,\n                    this, associations, userId));\n\n            updateAtm(userId, associations);\n        }\n    }\n\n    private void updateAtm(int userId, Set<Association> associations) {\n        final Set<Integer> companionAppUids = new ArraySet<>();\n        for (Association association : associations) {\n            final int uid = mPackageManagerInternal.getPackageUid(association.getPackageName(),\n                    0, userId);\n            if (uid >= 0) {\n                companionAppUids.add(uid);\n            }\n        }\n        if (mAtmInternal != null) {\n            mAtmInternal.setCompanionAppUids(userId, companionAppUids);\n        }\n        if (mAmInternal != null) {\n            // Make a copy of companionAppUids and send it to ActivityManager.\n            mAmInternal.setCompanionAppUids(userId, new ArraySet<>(companionAppUids));\n        }\n    }\n\n    private void persistAssociations(Set<Association> associations, int userId) {\n        Slog.i(LOG_TAG, \"Writing associations to disk: \" + associations);\n        final AtomicFile file = getStorageFileForUser(userId);\n        synchronized (file) {\n            file.write(out -> {\n                XmlSerializer xml = Xml.newSerializer();\n                try {\n                    xml.setOutput(out, StandardCharsets.UTF_8.name());\n                    xml.setFeature(\"http://xmlpull.org/v1/doc/features.html#indent-output\", true);\n                    xml.startDocument(null, true);\n                    xml.startTag(null, XML_TAG_ASSOCIATIONS);\n\n                    forEach(associations, association -> {\n                        XmlSerializer tag = xml.startTag(null, XML_TAG_ASSOCIATION)\n                                .attribute(null, XML_ATTR_PACKAGE, association.getPackageName())\n                                .attribute(null, XML_ATTR_DEVICE,\n                                        association.getDeviceMacAddress());\n                        if (association.getDeviceProfile() != null) {\n                            tag.attribute(null, XML_ATTR_PROFILE, association.getDeviceProfile());\n                            tag.attribute(null, XML_ATTR_NOTIFY_DEVICE_NEARBY,\n                                    Boolean.toString(\n                                            association.isNotifyOnDeviceNearby()));\n                        }\n                        tag.attribute(null, XML_ATTR_TIME_APPROVED,\n                                Long.toString(association.getTimeApprovedMs()));\n                        tag.endTag(null, XML_TAG_ASSOCIATION);\n                    });\n\n                    xml.endTag(null, XML_TAG_ASSOCIATIONS);\n                    xml.endDocument();\n                } catch (Exception e) {\n                    Slog.e(LOG_TAG, \"Error while writing associations file\", e);\n                    throw ExceptionUtils.propagate(e);\n                }\n            });\n        }\n    }\n\n    private AtomicFile getStorageFileForUser(int userId) {\n        return mUidToStorage.computeIfAbsent(userId, (u) ->\n                new AtomicFile(new File(\n                        //TODO deprecated method - what's the right replacement?\n                        Environment.getUserSystemDirectory(u),\n                        XML_FILE_NAME)));\n    }\n\n    @Nullable\n    private Set<Association> getAllAssociations(int userId) {\n        synchronized (mLock) {\n            if (mCachedAssociations.get(userId) == null) {\n                mCachedAssociations.put(userId, Collections.unmodifiableSet(\n                        emptyIfNull(readAllAssociations(userId))));\n                Slog.i(LOG_TAG, \"Read associations from disk: \" + mCachedAssociations);\n            }\n            return mCachedAssociations.get(userId);\n        }\n    }\n\n    private List<UserInfo> getAllUsers() {\n        long identity = Binder.clearCallingIdentity();\n        try {\n            return mUserManager.getUsers();\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private Set<Association> getAllAssociations(int userId, @Nullable String packageFilter) {\n        return CollectionUtils.filter(\n                getAllAssociations(userId),\n                // Null filter == get all associations\n                a -> packageFilter == null || Objects.equals(packageFilter, a.getPackageName()));\n    }\n\n    private Set<Association> getAllAssociations() {\n        long identity = Binder.clearCallingIdentity();\n        try {\n            ArraySet<Association> result = new ArraySet<>();\n            for (UserInfo user : mUserManager.getAliveUsers()) {\n                result.addAll(getAllAssociations(user.id));\n            }\n            return result;\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private Set<Association> getAllAssociations(\n            int userId, @Nullable String packageFilter, @Nullable String addressFilter) {\n        return CollectionUtils.filter(\n                getAllAssociations(userId),\n                // Null filter == get all associations\n                a -> (packageFilter == null || Objects.equals(packageFilter, a.getPackageName()))\n                        && (addressFilter == null\n                                || Objects.equals(addressFilter, a.getDeviceMacAddress())));\n    }\n\n    private Set<Association> readAllAssociations(int userId) {\n        final AtomicFile file = getStorageFileForUser(userId);\n\n        if (!file.getBaseFile().exists()) return null;\n\n        ArraySet<Association> result = null;\n        final XmlPullParser parser = Xml.newPullParser();\n        synchronized (file) {\n            try (FileInputStream in = file.openRead()) {\n                parser.setInput(in, StandardCharsets.UTF_8.name());\n                int type;\n                while ((type = parser.next()) != XmlPullParser.END_DOCUMENT) {\n                    if (type != XmlPullParser.START_TAG\n                            && !XML_TAG_ASSOCIATIONS.equals(parser.getName())) continue;\n\n                    final String appPackage = parser.getAttributeValue(null, XML_ATTR_PACKAGE);\n                    final String deviceAddress = parser.getAttributeValue(null, XML_ATTR_DEVICE);\n\n                    final String profile = parser.getAttributeValue(null, XML_ATTR_PROFILE);\n                    final boolean persistentGrants = Boolean.valueOf(\n                            parser.getAttributeValue(null, XML_ATTR_NOTIFY_DEVICE_NEARBY));\n                    final long timeApproved = parseLongOrDefault(\n                            parser.getAttributeValue(null, XML_ATTR_TIME_APPROVED), 0L);\n\n                    if (appPackage == null || deviceAddress == null) continue;\n\n                    result = ArrayUtils.add(result,\n                            new Association(userId, deviceAddress, appPackage,\n                                    profile, persistentGrants, timeApproved));\n                }\n                return result;\n            } catch (XmlPullParserException | IOException e) {\n                Slog.e(LOG_TAG, \"Error while reading associations file\", e);\n                return null;\n            }\n        }\n    }\n\n    void onDeviceConnected(String address) {\n        Slog.d(LOG_TAG, \"onDeviceConnected(address = \" + address + \")\");\n\n        mCurrentlyConnectedDevices.add(address);\n\n        for (UserInfo user : getAllUsers()) {\n            for (Association association : getAllAssociations(user.id)) {\n                if (Objects.equals(address, association.getDeviceMacAddress())) {\n                    if (association.getDeviceProfile() != null) {\n                        Slog.i(LOG_TAG, \"Granting role \" + association.getDeviceProfile()\n                                + \" to \" + association.getPackageName()\n                                + \" due to device connected: \" + association.getDeviceMacAddress());\n                        grantDeviceProfile(association);\n                    }\n                }\n            }\n        }\n\n        onDeviceNearby(address);\n    }\n\n    private void grantDeviceProfile(Association association) {\n        Slog.i(LOG_TAG, \"grantDeviceProfile(association = \" + association + \")\");\n\n        if (association.getDeviceProfile() != null) {\n            mRoleManager.addRoleHolderAsUser(\n                    association.getDeviceProfile(),\n                    association.getPackageName(),\n                    RoleManager.MANAGE_HOLDERS_FLAG_DONT_KILL_APP,\n                    UserHandle.of(association.getUserId()),\n                    getContext().getMainExecutor(),\n                    success -> {\n                        if (!success) {\n                            Slog.e(LOG_TAG, \"Failed to grant device profile role \"\n                                    + association.getDeviceProfile()\n                                    + \" to \" + association.getPackageName()\n                                    + \" for user \" + association.getUserId());\n                        }\n                    });\n        }\n    }\n\n    void onDeviceDisconnected(String address) {\n        Slog.d(LOG_TAG, \"onDeviceDisconnected(address = \" + address + \")\");\n\n        mCurrentlyConnectedDevices.remove(address);\n\n        Date lastSeen = mDevicesLastNearby.get(address);\n        if (isDeviceDisappeared(lastSeen)) {\n            onDeviceDisappeared(address);\n            unscheduleTriggerDeviceDisappearedRunnable(address);\n        }\n    }\n\n    private boolean isDeviceDisappeared(Date lastSeen) {\n        return lastSeen == null || System.currentTimeMillis() - lastSeen.getTime()\n                >= DEVICE_DISAPPEARED_UNBIND_TIMEOUT_MS;\n    }\n\n    private ServiceConnector<ICompanionDeviceService> getDeviceListenerServiceConnector(\n            Association a) {\n        return mDeviceListenerServiceConnectors.forUser(a.getUserId()).computeIfAbsent(\n                a.getPackageName(),\n                pkg -> createDeviceListenerServiceConnector(a));\n    }\n\n    private ServiceConnector<ICompanionDeviceService> createDeviceListenerServiceConnector(\n            Association a) {\n        List<ResolveInfo> resolveInfos = getContext().getPackageManager().queryIntentServicesAsUser(\n                new Intent(CompanionDeviceService.SERVICE_INTERFACE), MATCH_ALL, a.getUserId());\n        List<ResolveInfo> packageResolveInfos = filter(resolveInfos,\n                info -> Objects.equals(info.serviceInfo.packageName, a.getPackageName()));\n        if (packageResolveInfos.size() != 1) {\n            Slog.w(LOG_TAG, \"Device presence listener package must have exactly one \"\n                    + \"CompanionDeviceService, but \" + a.getPackageName()\n                    + \" has \" + packageResolveInfos.size());\n            return new ServiceConnector.NoOp<>();\n        }\n        String servicePermission = packageResolveInfos.get(0).serviceInfo.permission;\n        if (!BIND_COMPANION_DEVICE_SERVICE.equals(servicePermission)) {\n            Slog.w(LOG_TAG, \"Binding CompanionDeviceService must have \"\n                    + BIND_COMPANION_DEVICE_SERVICE + \" permission.\");\n            return new ServiceConnector.NoOp<>();\n        }\n        ComponentName componentName = packageResolveInfos.get(0).serviceInfo.getComponentName();\n        Slog.i(LOG_TAG, \"Initializing CompanionDeviceService binding for \" + componentName);\n        return new ServiceConnector.Impl<ICompanionDeviceService>(getContext(),\n                new Intent(CompanionDeviceService.SERVICE_INTERFACE).setComponent(componentName),\n                BIND_IMPORTANT,\n                a.getUserId(),\n                ICompanionDeviceService.Stub::asInterface) {\n\n            @Override\n            protected long getAutoDisconnectTimeoutMs() {\n                // Service binding is managed manually based on corresponding device being nearby\n                return Long.MAX_VALUE;\n            }\n\n            @Override\n            public void binderDied() {\n                super.binderDied();\n\n                // Re-connect to the service if process gets killed\n                mMainHandler.postDelayed(this::connect, DEVICE_LISTENER_DIED_REBIND_TIMEOUT_MS);\n            }\n        };\n    }\n\n    private class BleScanCallback extends ScanCallback {\n        @Override\n        public void onScanResult(int callbackType, ScanResult result) {\n            if (DEBUG) {\n                Slog.i(LOG_TAG, \"onScanResult(callbackType = \"\n                        + callbackType + \", result = \" + result + \")\");\n            }\n\n            onDeviceNearby(result.getDevice().getAddress());\n        }\n\n        @Override\n        public void onBatchScanResults(List<ScanResult> results) {\n            for (int i = 0, size = results.size(); i < size; i++) {\n                onScanResult(CALLBACK_TYPE_ALL_MATCHES, results.get(i));\n            }\n        }\n\n        @Override\n        public void onScanFailed(int errorCode) {\n            if (errorCode == SCAN_FAILED_ALREADY_STARTED) {\n                // ignore - this might happen if BT tries to auto-restore scans for us in the\n                // future\n                Slog.i(LOG_TAG, \"Ignoring BLE scan error: SCAN_FAILED_ALREADY_STARTED\");\n            } else {\n                Slog.w(LOG_TAG, \"Failed to start BLE scan: error \" + errorCode);\n            }\n        }\n    }\n\n    private class BleStateBroadcastReceiver extends BroadcastReceiver {\n\n        final IntentFilter mIntentFilter =\n                new IntentFilter(BluetoothAdapter.ACTION_BLE_STATE_CHANGED);\n\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            int previousState = intent.getIntExtra(BluetoothAdapter.EXTRA_PREVIOUS_STATE, -1);\n            int newState = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, -1);\n            Slog.d(LOG_TAG, \"Received BT state transition broadcast: \"\n                    + BluetoothAdapter.nameForState(previousState)\n                    + \" -> \" + BluetoothAdapter.nameForState(newState));\n\n            boolean bleOn = newState == BluetoothAdapter.STATE_ON\n                    || newState == BluetoothAdapter.STATE_BLE_ON;\n            if (bleOn) {\n                if (mBluetoothAdapter.getBluetoothLeScanner() != null) {\n                    startBleScan();\n                } else {\n                    Slog.wtf(LOG_TAG, \"BLE on, but BluetoothLeScanner == null\");\n                }\n            }\n        }\n    }\n\n    private class UnbindDeviceListenersRunnable implements Runnable {\n\n        public String getJobId(String address) {\n            return \"CDM_deviceGone_unbind_\" + address;\n        }\n\n        @Override\n        public void run() {\n            Slog.i(LOG_TAG, \"UnbindDeviceListenersRunnable.run(); devicesNearby = \"\n                    + mDevicesLastNearby);\n            int size = mDevicesLastNearby.size();\n            for (int i = 0; i < size; i++) {\n                String address = mDevicesLastNearby.keyAt(i);\n                Date lastNearby = mDevicesLastNearby.valueAt(i);\n\n                if (isDeviceDisappeared(lastNearby)) {\n                    for (Association association : getAllAssociations(address)) {\n                        if (association.isNotifyOnDeviceNearby()) {\n                            getDeviceListenerServiceConnector(association).unbind();\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    private class TriggerDeviceDisappearedRunnable implements Runnable {\n\n        private final String mAddress;\n\n        TriggerDeviceDisappearedRunnable(String address) {\n            mAddress = address;\n        }\n\n        public void schedule() {\n            mMainHandler.removeCallbacks(this);\n            mMainHandler.postDelayed(this, this, DEVICE_DISAPPEARED_TIMEOUT_MS);\n        }\n\n        @Override\n        public void run() {\n            Slog.d(LOG_TAG, \"TriggerDeviceDisappearedRunnable.run(address = \" + mAddress + \")\");\n            if (!mCurrentlyConnectedDevices.contains(mAddress)) {\n                onDeviceDisappeared(mAddress);\n            }\n        }\n    }\n\n    private void unscheduleTriggerDeviceDisappearedRunnable(String address) {\n        Runnable r = mTriggerDeviceDisappearedRunnables.get(address);\n        if (r != null) {\n            Slog.d(LOG_TAG,\n                    \"unscheduling TriggerDeviceDisappearedRunnable(address = \" + address + \")\");\n            mMainHandler.removeCallbacks(r);\n        }\n    }\n\n    private Set<Association> getAllAssociations(String deviceAddress) {\n        List<UserInfo> aliveUsers = mUserManager.getAliveUsers();\n        Set<Association> result = new ArraySet<>();\n        for (int i = 0, size = aliveUsers.size(); i < size; i++) {\n            UserInfo user = aliveUsers.get(i);\n            for (Association association : getAllAssociations(user.id)) {\n                if (Objects.equals(association.getDeviceMacAddress(), deviceAddress)) {\n                    result.add(association);\n                }\n            }\n        }\n        return result;\n    }\n\n    private void onDeviceNearby(String address) {\n        Date timestamp = new Date();\n        Date oldTimestamp = mDevicesLastNearby.put(address, timestamp);\n\n        cancelUnbindDeviceListener(address);\n\n        mTriggerDeviceDisappearedRunnables\n                .computeIfAbsent(address, addr -> new TriggerDeviceDisappearedRunnable(address))\n                .schedule();\n\n        // Avoid spamming the app if device is already known to be nearby\n        boolean justAppeared = oldTimestamp == null\n                || timestamp.getTime() - oldTimestamp.getTime() >= DEVICE_DISAPPEARED_TIMEOUT_MS;\n        if (justAppeared) {\n            Slog.i(LOG_TAG, \"onDeviceNearby(justAppeared, address = \" + address + \")\");\n            for (Association association : getAllAssociations(address)) {\n                if (association.isNotifyOnDeviceNearby()) {\n                    Slog.i(LOG_TAG,\n                            \"Sending onDeviceAppeared to \" + association.getPackageName() + \")\");\n                    getDeviceListenerServiceConnector(association).run(\n                            service -> service.onDeviceAppeared(association.getDeviceMacAddress()));\n                }\n            }\n        }\n    }\n\n    private void onDeviceDisappeared(String address) {\n        Slog.i(LOG_TAG, \"onDeviceDisappeared(address = \" + address + \")\");\n\n        boolean hasDeviceListeners = false;\n        for (Association association : getAllAssociations(address)) {\n            if (association.isNotifyOnDeviceNearby()) {\n                Slog.i(LOG_TAG,\n                        \"Sending onDeviceDisappeared to \" + association.getPackageName() + \")\");\n                getDeviceListenerServiceConnector(association).run(\n                        service -> service.onDeviceDisappeared(address));\n                hasDeviceListeners = true;\n            }\n        }\n\n        cancelUnbindDeviceListener(address);\n        if (hasDeviceListeners) {\n            mMainHandler.postDelayed(\n                    mUnbindDeviceListenersRunnable,\n                    mUnbindDeviceListenersRunnable.getJobId(address),\n                    DEVICE_DISAPPEARED_UNBIND_TIMEOUT_MS);\n        }\n    }\n\n    private void cancelUnbindDeviceListener(String address) {\n        mMainHandler.removeCallbacks(\n                mUnbindDeviceListenersRunnable, mUnbindDeviceListenersRunnable.getJobId(address));\n    }\n\n    private void initBleScanning() {\n        Slog.i(LOG_TAG, \"initBleScanning()\");\n\n        boolean bluetoothReady = mBluetoothAdapter.registerServiceLifecycleCallback(\n                new BluetoothAdapter.ServiceLifecycleCallback() {\n                    @Override\n                    public void onBluetoothServiceUp() {\n                        Slog.i(LOG_TAG, \"Bluetooth stack is up\");\n                        startBleScan();\n                    }\n\n                    @Override\n                    public void onBluetoothServiceDown() {\n                        Slog.w(LOG_TAG, \"Bluetooth stack is down\");\n                    }\n                });\n        if (bluetoothReady) {\n            startBleScan();\n        }\n    }\n\n    void startBleScan() {\n        Slog.i(LOG_TAG, \"startBleScan()\");\n\n        List<ScanFilter> filters = getBleScanFilters();\n        if (filters.isEmpty()) {\n            return;\n        }\n        BluetoothLeScanner scanner = mBluetoothAdapter.getBluetoothLeScanner();\n        if (scanner == null) {\n            Slog.w(LOG_TAG, \"scanner == null (likely BLE isn't ON yet)\");\n        } else {\n            scanner.startScan(\n                    filters,\n                    new ScanSettings.Builder().setScanMode(SCAN_MODE_BALANCED).build(),\n                    mBleScanCallback);\n        }\n    }\n\n    void restartBleScan() {\n        if (mBluetoothAdapter.getBluetoothLeScanner() != null) {\n            mBluetoothAdapter.getBluetoothLeScanner().stopScan(mBleScanCallback);\n            startBleScan();\n        } else {\n            Slog.w(LOG_TAG, \"BluetoothLeScanner is null (likely BLE isn't ON yet).\");\n        }\n    }\n\n    private List<ScanFilter> getBleScanFilters() {\n        ArrayList<ScanFilter> result = new ArrayList<>();\n        ArraySet<String> addressesSeen = new ArraySet<>();\n        for (Association association : getAllAssociations()) {\n            String address = association.getDeviceMacAddress();\n            if (addressesSeen.contains(address)) {\n                continue;\n            }\n            if (association.isNotifyOnDeviceNearby()) {\n                result.add(new ScanFilter.Builder().setDeviceAddress(address).build());\n                addressesSeen.add(address);\n            }\n        }\n        return result;\n    }\n\n    private AndroidFuture<String> getDeviceProfilePermissionDescription(String deviceProfile) {\n        AndroidFuture<String> result = new AndroidFuture<>();\n        mPermissionControllerManager.getPrivilegesDescriptionStringForProfile(\n                deviceProfile, FgThread.getExecutor(), desc -> {\n                        try {\n                            result.complete(String.valueOf(desc));\n                        } catch (Exception e) {\n                            result.completeExceptionally(e);\n                        }\n                });\n        return result;\n    }\n\n    private static long parseLongOrDefault(String str, long def) {\n        try {\n            return Long.parseLong(str);\n        } catch (NumberFormatException e) {\n            Slog.w(LOG_TAG, \"Failed to parse\", e);\n            return def;\n        }\n    }\n\n    private class ShellCmd extends ShellCommand {\n        public static final String USAGE = \"help\\n\"\n                + \"list USER_ID\\n\"\n                + \"associate USER_ID PACKAGE MAC_ADDRESS\\n\"\n                + \"disassociate USER_ID PACKAGE MAC_ADDRESS\";\n\n        ShellCmd() {\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.MANAGE_COMPANION_DEVICES, \"ShellCmd\");\n        }\n\n        @Override\n        public int onCommand(String cmd) {\n            try {\n                switch (cmd) {\n                    case \"list\": {\n                        forEach(\n                                getAllAssociations(getNextArgInt()),\n                                a -> getOutPrintWriter()\n                                        .println(a.getPackageName() + \" \"\n                                                + a.getDeviceMacAddress()));\n                    }\n                    break;\n\n                    case \"associate\": {\n                        int userId = getNextArgInt();\n                        String pkg = getNextArgRequired();\n                        String address = getNextArgRequired();\n                        addAssociation(new Association(userId, address, pkg, null, false,\n                                System.currentTimeMillis()), userId);\n                    }\n                    break;\n\n                    case \"disassociate\": {\n                        removeAssociation(getNextArgInt(), getNextArgRequired(),\n                                getNextArgRequired());\n                    }\n                    break;\n\n                    case \"simulate_connect\": {\n                        onDeviceConnected(getNextArgRequired());\n                    }\n                    break;\n\n                    case \"simulate_disconnect\": {\n                        onDeviceDisconnected(getNextArgRequired());\n                    }\n                    break;\n\n                    default:\n                        return handleDefaultCommands(cmd);\n                }\n                return 0;\n            } catch (Throwable t) {\n                Slog.e(LOG_TAG, \"Error running a command: $ \" + cmd, t);\n                getErrPrintWriter().println(Log.getStackTraceString(t));\n                return 1;\n            }\n        }\n\n        private int getNextArgInt() {\n            return Integer.parseInt(getNextArgRequired());\n        }\n\n        @Override\n        public void onHelp() {\n            getOutPrintWriter().println(USAGE);\n        }\n    }\n\n\n    private class BluetoothDeviceConnectedListener\n            extends BluetoothAdapter.BluetoothConnectionCallback {\n        @Override\n        public void onDeviceConnected(BluetoothDevice device) {\n            CompanionDeviceManagerService.this.onDeviceConnected(device.getAddress());\n        }\n\n        @Override\n        public void onDeviceDisconnected(BluetoothDevice device, @DisconnectReason int reason) {\n            Slog.d(LOG_TAG, device.getAddress() + \" disconnected w/ reason: (\" + reason + \") \"\n                    + BluetoothAdapter.BluetoothConnectionCallback.disconnectReasonText(reason));\n            CompanionDeviceManagerService.this.onDeviceDisconnected(device.getAddress());\n        }\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 12201,
                                        "general": {
                                            "word_based": 4671,
                                            "char_based": 16963
                                        },
                                        "gemini": 14712
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "1ae3b43c248cdf5ee63311f06acd0ee19d93f0cd",
                            "repo_path": "android_repos/base",
                            "result": "failure",
                            "downstream_patch_content": "commit 1ae3b43c248cdf5ee63311f06acd0ee19d93f0cd\nAuthor: Guojing Yuan <guojing@google.com>\nDate:   Thu Dec 14 19:30:04 2023 +0000\n\n    [CDM][CMD] Check permissions for CDM shell commands\n    \n    Override handleShellCommand instead of onShellCommand because\n    Binder.onShellCommand checks the necessary permissions of the caller.\n    \n    Bug: 313428840\n    \n    Test: manually tested CDM shell commands\n    Change-Id: I5539b3594feb5544c458c0fd1061b51a0a808900\n    Merged-In: I5539b3594feb5544c458c0fd1061b51a0a808900\n    (cherry picked from commit 1761a0fee9c2cd9787bbb7fbdbe30b4c2b03396e)\n\ndiff --git a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\nindex 5f6211f158c2..1b50f2e535be 100644\n--- a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n+++ b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n@@ -72,12 +72,11 @@ import android.os.Environment;\n import android.os.Handler;\n import android.os.Message;\n import android.os.Parcel;\n+import android.os.ParcelFileDescriptor;\n import android.os.PowerWhitelistManager;\n import android.os.RemoteCallbackList;\n import android.os.RemoteException;\n-import android.os.ResultReceiver;\n import android.os.ServiceManager;\n-import android.os.ShellCallback;\n import android.os.SystemProperties;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -750,16 +749,13 @@ public class CompanionDeviceManagerService extends SystemService {\n         }\n \n         @Override\n-        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n-                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n-                throws RemoteException {\n-            enforceCallerCanManageCompanionDevice(getContext(), \"onShellCommand\");\n-\n-            final CompanionDeviceShellCommand cmd = new CompanionDeviceShellCommand(\n-                    CompanionDeviceManagerService.this,\n-                    mAssociationStore,\n-                    mDevicePresenceMonitor);\n-            cmd.exec(this, in, out, err, args, callback, resultReceiver);\n+        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n+                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n+                @NonNull String[] args) {\n+            return new CompanionDeviceShellCommand(CompanionDeviceManagerService.this,\n+                    mAssociationStore, mDevicePresenceMonitor)\n+                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n+                            err.getFileDescriptor(), args);\n         }\n \n         @Override\n",
                            "downstream_patch_tokens": {
                                "openai": 639,
                                "general": {
                                    "word_based": 245,
                                    "char_based": 693
                                },
                                "gemini": 812
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java",
                                    "total_hunks": 2,
                                    "failed_hunks": [
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n        public void enableSecureTransport(boolean enabled) {\n            mTransportManager.enableSecureTransport(enabled);\n=======\n        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n                @NonNull String[] args) {\n            return new CompanionDeviceShellCommand(CompanionDeviceManagerService.this,\n                    mAssociationStore, mDevicePresenceMonitor, mTransportManager,\n                    mSystemDataTransferProcessor, mAssociationRequestsProcessor)\n                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n                            err.getFileDescriptor(), args);\n>>>>>>> UPSTREAM PATCH (commit 1f31bb181fc56f3deab5ce0d199220404991c438)",
                                            "merge_conflict_tokens": {
                                                "openai": 154,
                                                "general": {
                                                    "word_based": 49,
                                                    "char_based": 206
                                                },
                                                "gemini": 185
                                            }
                                        }
                                    ],
                                    "inline_merge_token_summary": {
                                        "gemini": 17020,
                                        "openai": 14322,
                                        "general_word": 4557,
                                        "general_char": 19158
                                    },
                                    "rej_file_content": "```diff\n--- services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n+++ services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n@@ -949,13 +947,14 @@ public class CompanionDeviceManagerService extends SystemService {\n         }\n \n         @Override\n-        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n-                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n-                throws RemoteException {\n-            new CompanionDeviceShellCommand(CompanionDeviceManagerService.this, mAssociationStore,\n-                    mDevicePresenceMonitor, mTransportManager, mSystemDataTransferProcessor,\n-                    mAssociationRequestsProcessor)\n-                    .exec(this, in, out, err, args, callback, resultReceiver);\n+        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n+                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n+                @NonNull String[] args) {\n+            return new CompanionDeviceShellCommand(CompanionDeviceManagerService.this,\n+                    mAssociationStore, mDevicePresenceMonitor, mTransportManager,\n+                    mSystemDataTransferProcessor, mAssociationRequestsProcessor)\n+                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n+                            err.getFileDescriptor(), args);\n         }\n \n         @Override\n```",
                                    "rej_file_tokens": {
                                        "openai": 276,
                                        "general": {
                                            "word_based": 97,
                                            "char_based": 371
                                        },
                                        "gemini": 312
                                    },
                                    "patch_apply_output": "patching file services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\nHunk #1 succeeded at 75 (offset -9 lines).\nHunk #2 FAILED at 949.\n1 out of 2 hunks FAILED -- saving rejects to file services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java.rej",
                                    "inline_merge_output": "patching file services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\nHunk #1 already applied at 87,88.\nHunk #2 NOT MERGED at 817-829.",
                                    "upstream_file_tokens": {
                                        "openai": 13480,
                                        "general": {
                                            "word_based": 5482,
                                            "char_based": 18027
                                        },
                                        "gemini": 15497
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\npackage com.android.server.companion;\n\nimport static android.Manifest.permission.MANAGE_COMPANION_DEVICES;\nimport static android.content.pm.PackageManager.CERT_INPUT_SHA256;\nimport static android.content.pm.PackageManager.PERMISSION_GRANTED;\nimport static android.os.Process.SYSTEM_UID;\nimport static android.os.UserHandle.getCallingUserId;\n\nimport static com.android.internal.util.CollectionUtils.any;\nimport static com.android.internal.util.Preconditions.checkState;\nimport static com.android.internal.util.function.pooled.PooledLambda.obtainMessage;\nimport static com.android.server.companion.AssociationStore.CHANGE_TYPE_UPDATED_ADDRESS_UNCHANGED;\nimport static com.android.server.companion.MetricUtils.logCreateAssociation;\nimport static com.android.server.companion.MetricUtils.logRemoveAssociation;\nimport static com.android.server.companion.PackageUtils.enforceUsesCompanionDeviceFeature;\nimport static com.android.server.companion.PackageUtils.getPackageInfo;\nimport static com.android.server.companion.PermissionsUtils.checkCallerCanManageCompanionDevice;\nimport static com.android.server.companion.PermissionsUtils.enforceCallerCanManageAssociationsForPackage;\nimport static com.android.server.companion.PermissionsUtils.enforceCallerCanManageCompanionDevice;\nimport static com.android.server.companion.PermissionsUtils.enforceCallerIsSystemOr;\nimport static com.android.server.companion.PermissionsUtils.enforceCallerIsSystemOrCanInteractWithUserId;\nimport static com.android.server.companion.PermissionsUtils.sanitizeWithCallerChecks;\nimport static com.android.server.companion.RolesUtils.addRoleHolderForAssociation;\nimport static com.android.server.companion.RolesUtils.removeRoleHolderForAssociation;\n\nimport static java.util.Objects.requireNonNull;\nimport static java.util.concurrent.TimeUnit.DAYS;\nimport static java.util.concurrent.TimeUnit.MINUTES;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.SuppressLint;\nimport android.annotation.UserIdInt;\nimport android.app.ActivityManagerInternal;\nimport android.app.AppOpsManager;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.companion.AssociationInfo;\nimport android.companion.AssociationRequest;\nimport android.companion.DeviceNotAssociatedException;\nimport android.companion.IAssociationRequestCallback;\nimport android.companion.ICompanionDeviceManager;\nimport android.companion.IOnAssociationsChangedListener;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.UserInfo;\nimport android.net.MacAddress;\nimport android.net.NetworkPolicyManager;\nimport android.os.Binder;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Parcel;\nimport android.os.PowerWhitelistManager;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.ServiceManager;\nimport android.os.SystemProperties;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.util.ArraySet;\nimport android.util.ExceptionUtils;\nimport android.util.Log;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.app.IAppOpsService;\nimport com.android.internal.content.PackageMonitor;\nimport com.android.internal.notification.NotificationAccessConfirmationActivityContract;\nimport com.android.internal.os.BackgroundThread;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.server.FgThread;\nimport com.android.server.LocalServices;\nimport com.android.server.SystemService;\nimport com.android.server.companion.presence.CompanionDevicePresenceMonitor;\nimport com.android.server.pm.UserManagerInternal;\nimport com.android.server.wm.ActivityTaskManagerInternal;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.PrintWriter;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n@SuppressLint(\"LongLogTag\")\npublic class CompanionDeviceManagerService extends SystemService {\n    static final String TAG = \"CompanionDeviceManagerService\";\n    static final boolean DEBUG = false;\n\n    /** Range of Association IDs allocated for a user.*/\n    private static final int ASSOCIATIONS_IDS_PER_USER_RANGE = 100000;\n    private static final long PAIR_WITHOUT_PROMPT_WINDOW_MS = 10 * 60 * 1000; // 10 min\n\n    private static final String PREF_FILE_NAME = \"companion_device_preferences.xml\";\n    private static final String PREF_KEY_AUTO_REVOKE_GRANTS_DONE = \"auto_revoke_grants_done\";\n    private static final String SYS_PROP_DEBUG_REMOVAL_TIME_WINDOW =\n            \"debug.cdm.cdmservice.removal_time_window\";\n\n    private static final long ASSOCIATION_REMOVAL_TIME_WINDOW_DEFAULT = DAYS.toMillis(90);\n    private static final int MAX_CN_LENGTH = 500;\n\n    private PersistentDataStore mPersistentStore;\n    private final PersistUserStateHandler mUserPersistenceHandler;\n\n    private final AssociationStoreImpl mAssociationStore;\n    private AssociationRequestsProcessor mAssociationRequestsProcessor;\n    private CompanionDevicePresenceMonitor mDevicePresenceMonitor;\n    private CompanionApplicationController mCompanionAppController;\n\n    private final ActivityTaskManagerInternal mAtmInternal;\n    private final ActivityManagerInternal mAmInternal;\n    private final IAppOpsService mAppOpsManager;\n    private final PowerWhitelistManager mPowerWhitelistManager;\n    private final UserManager mUserManager;\n    final PackageManagerInternal mPackageManagerInternal;\n\n    /**\n     * A structure that consists of two nested maps, and effectively maps (userId + packageName) to\n     * a list of IDs that have been previously assigned to associations for that package.\n     * We maintain this structure so that we never re-use association IDs for the same package\n     * (until it's uninstalled).\n     */\n    @GuardedBy(\"mPreviouslyUsedIds\")\n    private final SparseArray<Map<String, Set<Integer>>> mPreviouslyUsedIds = new SparseArray<>();\n\n    private final RemoteCallbackList<IOnAssociationsChangedListener> mListeners =\n            new RemoteCallbackList<>();\n\n    public CompanionDeviceManagerService(Context context) {\n        super(context);\n\n        mPowerWhitelistManager = context.getSystemService(PowerWhitelistManager.class);\n        mAppOpsManager = IAppOpsService.Stub.asInterface(\n                ServiceManager.getService(Context.APP_OPS_SERVICE));\n        mAtmInternal = LocalServices.getService(ActivityTaskManagerInternal.class);\n        mAmInternal = LocalServices.getService(ActivityManagerInternal.class);\n        mPackageManagerInternal = LocalServices.getService(PackageManagerInternal.class);\n        mUserManager = context.getSystemService(UserManager.class);\n\n        mUserPersistenceHandler = new PersistUserStateHandler();\n        mAssociationStore = new AssociationStoreImpl();\n    }\n\n    @Override\n    public void onStart() {\n        mPersistentStore = new PersistentDataStore();\n\n        loadAssociationsFromDisk();\n        mAssociationStore.registerListener(mAssociationStoreChangeListener);\n\n        mDevicePresenceMonitor = new CompanionDevicePresenceMonitor(\n                mAssociationStore, mDevicePresenceCallback);\n\n        mAssociationRequestsProcessor = new AssociationRequestsProcessor(\n                /* cdmService */this, mAssociationStore);\n\n        final Context context = getContext();\n        mCompanionAppController = new CompanionApplicationController(\n                context, mApplicationControllerCallback);\n\n        // Publish \"binder\" service.\n        final CompanionDeviceManagerImpl impl = new CompanionDeviceManagerImpl();\n        publishBinderService(Context.COMPANION_DEVICE_SERVICE, impl);\n\n        // Publish \"local\" service.\n        LocalServices.addService(CompanionDeviceManagerServiceInternal.class, new LocalService());\n    }\n\n    void loadAssociationsFromDisk() {\n        final Set<AssociationInfo> allAssociations = new ArraySet<>();\n        synchronized (mPreviouslyUsedIds) {\n            // The data is stored in DE directories, so we can read the data for all users now\n            // (which would not be possible if the data was stored to CE directories).\n            mPersistentStore.readStateForUsers(\n                    mUserManager.getAliveUsers(), allAssociations, mPreviouslyUsedIds);\n        }\n\n        mAssociationStore.setAssociations(allAssociations);\n    }\n\n    @Override\n    public void onBootPhase(int phase) {\n        final Context context = getContext();\n        if (phase == PHASE_SYSTEM_SERVICES_READY) {\n            // WARNING: moving PackageMonitor to another thread (Looper) may introduce significant\n            // delays (even in case of the Main Thread). It may be fine overall, but would require\n            // updating the tests (adding a delay there).\n            mPackageMonitor.register(context, FgThread.get().getLooper(), UserHandle.ALL, true);\n            mDevicePresenceMonitor.init(context);\n        } else if (phase == PHASE_BOOT_COMPLETED) {\n            // Run the Inactive Association Removal job service daily.\n            InactiveAssociationsRemovalService.schedule(getContext());\n        }\n    }\n\n    @Override\n    public void onUserUnlocking(@NonNull TargetUser user) {\n        final int userId = user.getUserIdentifier();\n        final List<AssociationInfo> associations = mAssociationStore.getAssociationsForUser(userId);\n\n        if (associations.isEmpty()) return;\n\n        updateAtm(userId, associations);\n\n        BackgroundThread.getHandler().sendMessageDelayed(\n                obtainMessage(CompanionDeviceManagerService::maybeGrantAutoRevokeExemptions, this),\n                MINUTES.toMillis(10));\n    }\n\n    @Nullable\n    AssociationInfo getAssociationWithCallerChecks(\n            @UserIdInt int userId, @NonNull String packageName, @NonNull String macAddress) {\n        final AssociationInfo association = mAssociationStore.getAssociationsForPackageWithAddress(\n                userId, packageName, macAddress);\n        return sanitizeWithCallerChecks(getContext(), association);\n    }\n\n    @Nullable\n    AssociationInfo getAssociationWithCallerChecks(int associationId) {\n        final AssociationInfo association = mAssociationStore.getAssociationById(associationId);\n        return sanitizeWithCallerChecks(getContext(), association);\n    }\n\n    private void onDeviceAppearedInternal(int associationId) {\n        if (DEBUG) Log.i(TAG, \"onDevice_Appeared_Internal() id=\" + associationId);\n\n        final AssociationInfo association = mAssociationStore.getAssociationById(associationId);\n        if (DEBUG) Log.d(TAG, \"  association=\" + associationId);\n\n        if (!association.shouldBindWhenPresent()) return;\n\n        final int userId = association.getUserId();\n        final String packageName = association.getPackageName();\n        // Set bindImportant to true when the association is self-managed to avoid the target\n        // service being killed.\n        final boolean bindImportant = association.isSelfManaged();\n\n        if (!mCompanionAppController.isCompanionApplicationBound(userId, packageName)) {\n            mCompanionAppController.bindCompanionApplication(userId, packageName, bindImportant);\n        } else if (DEBUG) {\n            Log.i(TAG, \"u\" + userId + \"\\\\\" + packageName + \" is already bound\");\n        }\n        mCompanionAppController.notifyCompanionApplicationDeviceAppeared(association);\n    }\n\n    private void onDeviceDisappearedInternal(int associationId) {\n        if (DEBUG) Log.i(TAG, \"onDevice_Disappeared_Internal() id=\" + associationId);\n\n        final AssociationInfo association = mAssociationStore.getAssociationById(associationId);\n        if (DEBUG) Log.d(TAG, \"  association=\" + associationId);\n\n        final int userId = association.getUserId();\n        final String packageName = association.getPackageName();\n\n        if (!mCompanionAppController.isCompanionApplicationBound(userId, packageName)) {\n            if (DEBUG) Log.w(TAG, \"u\" + userId + \"\\\\\" + packageName + \" is NOT bound\");\n            return;\n        }\n\n        if (association.shouldBindWhenPresent()) {\n            mCompanionAppController.notifyCompanionApplicationDeviceDisappeared(association);\n        }\n\n        // Check if there are other devices associated to the app that are present.\n        if (shouldBindPackage(userId, packageName)) return;\n\n        mCompanionAppController.unbindCompanionApplication(userId, packageName);\n    }\n\n    private boolean onCompanionApplicationBindingDiedInternal(\n            @UserIdInt int userId, @NonNull String packageName) {\n        for (AssociationInfo ai :\n                mAssociationStore.getAssociationsForPackage(userId, packageName)) {\n            final int associationId = ai.getId();\n            if (ai.isSelfManaged()\n                    && mDevicePresenceMonitor.isDevicePresent(associationId)) {\n                mDevicePresenceMonitor.onSelfManagedDeviceReporterBinderDied(associationId);\n            }\n        }\n        // TODO(b/218613015): implement.\n        return false;\n    }\n\n    private void onRebindCompanionApplicationTimeoutInternal(\n            @UserIdInt int userId, @NonNull String packageName) {\n        // TODO(b/218613015): implement.\n    }\n\n    /**\n     * @return whether the package should be bound (i.e. at least one of the devices associated with\n     *         the package is currently present).\n     */\n    private boolean shouldBindPackage(@UserIdInt int userId, @NonNull String packageName) {\n        final List<AssociationInfo> packageAssociations =\n                mAssociationStore.getAssociationsForPackage(userId, packageName);\n        for (AssociationInfo association : packageAssociations) {\n            if (!association.shouldBindWhenPresent()) continue;\n            if (mDevicePresenceMonitor.isDevicePresent(association.getId())) return true;\n        }\n        return false;\n    }\n\n    private void onAssociationChangedInternal(\n            @AssociationStore.ChangeType int changeType, AssociationInfo association) {\n        final int id = association.getId();\n        final int userId = association.getUserId();\n        final String packageName = association.getPackageName();\n\n        if (changeType == AssociationStore.CHANGE_TYPE_REMOVED) {\n            markIdAsPreviouslyUsedForPackage(id, userId, packageName);\n        }\n\n        final List<AssociationInfo> updatedAssociations =\n                mAssociationStore.getAssociationsForUser(userId);\n\n        mUserPersistenceHandler.postPersistUserState(userId);\n\n        // Notify listeners if ADDED, REMOVED or UPDATED_ADDRESS_CHANGED.\n        // Do NOT notify when UPDATED_ADDRESS_UNCHANGED, which means a minor tweak in association's\n        // configs, which \"listeners\" won't (and shouldn't) be able to see.\n        if (changeType != CHANGE_TYPE_UPDATED_ADDRESS_UNCHANGED) {\n            notifyListeners(userId, updatedAssociations);\n        }\n        updateAtm(userId, updatedAssociations);\n    }\n\n    private void persistStateForUser(@UserIdInt int userId) {\n        final List<AssociationInfo> updatedAssociations =\n                mAssociationStore.getAssociationsForUser(userId);\n        final Map<String, Set<Integer>> usedIdsForUser = getPreviouslyUsedIdsForUser(userId);\n        mPersistentStore.persistStateForUser(userId, updatedAssociations, usedIdsForUser);\n    }\n\n    private void notifyListeners(\n            @UserIdInt int userId, @NonNull List<AssociationInfo> associations) {\n        mListeners.broadcast((listener, callbackUserId) -> {\n            if ((int) callbackUserId == userId) {\n                try {\n                    listener.onAssociationsChanged(associations);\n                } catch (RemoteException ignored) {\n                }\n            }\n        });\n    }\n\n    private void markIdAsPreviouslyUsedForPackage(\n            int associationId, @UserIdInt int userId, @NonNull String packageName) {\n        synchronized (mPreviouslyUsedIds) {\n            Map<String, Set<Integer>> usedIdsForUser = mPreviouslyUsedIds.get(userId);\n            if (usedIdsForUser == null) {\n                usedIdsForUser = new HashMap<>();\n                mPreviouslyUsedIds.put(userId, usedIdsForUser);\n            }\n\n            final Set<Integer> usedIdsForPackage =\n                    usedIdsForUser.computeIfAbsent(packageName, it -> new HashSet<>());\n            usedIdsForPackage.add(associationId);\n        }\n    }\n\n    private void onPackageRemoveOrDataClearedInternal(\n            @UserIdInt int userId, @NonNull String packageName) {\n        if (DEBUG) {\n            Log.i(TAG, \"onPackageRemove_Or_DataCleared() u\" + userId + \"/\"\n                    + packageName);\n        }\n\n        // Clear associations.\n        final List<AssociationInfo> associationsForPackage =\n                mAssociationStore.getAssociationsForPackage(userId, packageName);\n        for (AssociationInfo association : associationsForPackage) {\n            mAssociationStore.removeAssociation(association.getId());\n        }\n\n        mCompanionAppController.onPackagesChanged(userId);\n    }\n\n    private void onPackageModifiedInternal(@UserIdInt int userId, @NonNull String packageName) {\n        if (DEBUG) Log.i(TAG, \"onPackageModified() u\" + userId + \"/\" + packageName);\n\n        final List<AssociationInfo> associationsForPackage =\n                mAssociationStore.getAssociationsForPackage(userId, packageName);\n        for (AssociationInfo association : associationsForPackage) {\n            updateSpecialAccessPermissionForAssociatedPackage(association);\n        }\n\n        mCompanionAppController.onPackagesChanged(userId);\n    }\n\n    // Revoke associations if the selfManaged companion device does not connect for 3 months.\n    void removeInactiveSelfManagedAssociations() {\n        final long currentTime = System.currentTimeMillis();\n        long removalWindow = SystemProperties.getLong(SYS_PROP_DEBUG_REMOVAL_TIME_WINDOW, -1);\n        if (removalWindow <= 0) {\n            // 0 or negative values indicate that the sysprop was never set or should be ignored.\n            removalWindow = ASSOCIATION_REMOVAL_TIME_WINDOW_DEFAULT;\n        }\n\n        for (AssociationInfo ai : mAssociationStore.getAssociations()) {\n            if (!ai.isSelfManaged()) continue;\n            final boolean isInactive =  currentTime - ai.getLastTimeConnectedMs() >= removalWindow;\n            if (isInactive) {\n                Slog.i(TAG, \"Removing inactive self-managed association: \" + ai.getId());\n                disassociateInternal(ai.getId());\n            }\n        }\n    }\n\n    class CompanionDeviceManagerImpl extends ICompanionDeviceManager.Stub {\n        @Override\n        public boolean onTransact(int code, Parcel data, Parcel reply, int flags)\n                throws RemoteException {\n            try {\n                return super.onTransact(code, data, reply, flags);\n            } catch (Throwable e) {\n                Slog.e(TAG, \"Error during IPC\", e);\n                throw ExceptionUtils.propagate(e, RemoteException.class);\n            }\n        }\n\n        @Override\n        public void associate(AssociationRequest request, IAssociationRequestCallback callback,\n                String packageName, int userId) throws RemoteException {\n            Slog.i(TAG, \"associate() \"\n                    + \"request=\" + request + \", \"\n                    + \"package=u\" + userId + \"/\" + packageName);\n            enforceCallerCanManageAssociationsForPackage(getContext(), userId, packageName,\n                    \"create associations\");\n\n            mAssociationRequestsProcessor.processNewAssociationRequest(\n                    request, packageName, userId, callback);\n        }\n\n        @Override\n        public List<AssociationInfo> getAssociations(String packageName, int userId) {\n            enforceCallerCanManageAssociationsForPackage(getContext(), userId, packageName,\n                    \"get associations\");\n\n            if (!checkCallerCanManageCompanionDevice(getContext())) {\n                // If the caller neither is system nor holds MANAGE_COMPANION_DEVICES: it needs to\n                // request the feature (also: the caller is the app itself).\n                enforceUsesCompanionDeviceFeature(getContext(), userId, packageName);\n            }\n\n            return mAssociationStore.getAssociationsForPackage(userId, packageName);\n        }\n\n        @Override\n        public List<AssociationInfo> getAllAssociationsForUser(int userId) throws RemoteException {\n            enforceCallerIsSystemOrCanInteractWithUserId(getContext(), userId);\n            enforceCallerCanManageCompanionDevice(getContext(), \"getAllAssociationsForUser\");\n\n            return mAssociationStore.getAssociationsForUser(userId);\n        }\n\n        @Override\n        public void addOnAssociationsChangedListener(IOnAssociationsChangedListener listener,\n                int userId) {\n            enforceCallerIsSystemOrCanInteractWithUserId(getContext(), userId);\n            enforceCallerCanManageCompanionDevice(getContext(),\n                    \"addOnAssociationsChangedListener\");\n\n            mListeners.register(listener, userId);\n        }\n\n        @Override\n        public void removeOnAssociationsChangedListener(IOnAssociationsChangedListener listener,\n                int userId) {\n            enforceCallerIsSystemOrCanInteractWithUserId(getContext(), userId);\n            enforceCallerCanManageCompanionDevice(\n                    getContext(), \"removeOnAssociationsChangedListener\");\n\n            mListeners.unregister(listener);\n        }\n\n        @Override\n        public void legacyDisassociate(String deviceMacAddress, String packageName, int userId) {\n            if (DEBUG) {\n                Log.i(TAG, \"legacyDisassociate() pkg=u\" + userId + \"/\" + packageName\n                        + \", macAddress=\" + deviceMacAddress);\n            }\n\n            requireNonNull(deviceMacAddress);\n            requireNonNull(packageName);\n\n            final AssociationInfo association =\n                    getAssociationWithCallerChecks(userId, packageName, deviceMacAddress);\n            if (association == null) {\n                throw new IllegalArgumentException(\"Association does not exist \"\n                        + \"or the caller does not have permissions to manage it \"\n                        + \"(ie. it belongs to a different package or a different user).\");\n            }\n\n            disassociateInternal(association.getId());\n        }\n\n        @Override\n        public void disassociate(int associationId) {\n            if (DEBUG) Log.i(TAG, \"disassociate() associationId=\" + associationId);\n\n            final AssociationInfo association = getAssociationWithCallerChecks(associationId);\n            if (association == null) {\n                throw new IllegalArgumentException(\"Association with ID \" + associationId + \" \"\n                        + \"does not exist \"\n                        + \"or belongs to a different package \"\n                        + \"or belongs to a different user\");\n            }\n\n            disassociateInternal(associationId);\n        }\n\n        @Override\n        public PendingIntent requestNotificationAccess(ComponentName component, int userId)\n                throws RemoteException {\n            String callingPackage = component.getPackageName();\n            checkCanCallNotificationApi(callingPackage, userId);\n            if (component.flattenToString().length() > MAX_CN_LENGTH) {\n                throw new IllegalArgumentException(\"Component name is too long.\");\n            }\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return PendingIntent.getActivityAsUser(getContext(),\n                        0 /* request code */,\n                        NotificationAccessConfirmationActivityContract.launcherIntent(\n                                getContext(), userId, component),\n                        PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_ONE_SHOT\n                                | PendingIntent.FLAG_CANCEL_CURRENT,\n                        null /* options */,\n                        new UserHandle(userId));\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n\n        /**\n        * @deprecated Use\n        * {@link NotificationManager#isNotificationListenerAccessGranted(ComponentName)} instead.\n        */\n        @Deprecated\n        @Override\n        public boolean hasNotificationAccess(ComponentName component) throws RemoteException {\n            checkCanCallNotificationApi(component.getPackageName(), getCallingUserId());\n            NotificationManager nm = getContext().getSystemService(NotificationManager.class);\n            return nm.isNotificationListenerAccessGranted(component);\n        }\n\n        @Override\n        public boolean isDeviceAssociatedForWifiConnection(String packageName, String macAddress,\n                int userId) {\n            getContext().enforceCallingOrSelfPermission(\n                    MANAGE_COMPANION_DEVICES, \"isDeviceAssociated\");\n\n            boolean bypassMacPermission = getContext().getPackageManager().checkPermission(\n                    android.Manifest.permission.COMPANION_APPROVE_WIFI_CONNECTIONS, packageName)\n                    == PERMISSION_GRANTED;\n            if (bypassMacPermission) {\n                return true;\n            }\n\n            return any(mAssociationStore.getAssociationsForPackage(userId, packageName),\n                    a -> a.isLinkedTo(macAddress));\n        }\n\n        @Override\n        public void registerDevicePresenceListenerService(String deviceAddress,\n                String callingPackage, int userId) throws RemoteException {\n            // TODO: take the userId into account.\n            registerDevicePresenceListenerActive(callingPackage, deviceAddress, true);\n        }\n\n        @Override\n        public void unregisterDevicePresenceListenerService(String deviceAddress,\n                String callingPackage, int userId) throws RemoteException {\n            // TODO: take the userId into account.\n            registerDevicePresenceListenerActive(callingPackage, deviceAddress, false);\n        }\n\n        @Override\n        public void dispatchMessage(int messageId, int associationId, byte[] message)\n                throws RemoteException {\n            // TODO(b/199427116): implement.\n        }\n\n        @Override\n        public void notifyDeviceAppeared(int associationId) {\n            if (DEBUG) Log.i(TAG, \"notifyDevice_Appeared() id=\" + associationId);\n\n            AssociationInfo association = getAssociationWithCallerChecks(associationId);\n            if (association == null) {\n                throw new IllegalArgumentException(\"Association with ID \" + associationId + \" \"\n                        + \"does not exist \"\n                        + \"or belongs to a different package \"\n                        + \"or belongs to a different user\");\n            }\n\n            if (!association.isSelfManaged()) {\n                throw new IllegalArgumentException(\"Association with ID \" + associationId\n                        + \" is not self-managed. notifyDeviceAppeared(int) can only be called for\"\n                        + \" self-managed associations.\");\n            }\n            // AssociationInfo class is immutable: create a new AssociationInfo object with updated\n            // timestamp.\n            association = AssociationInfo.builder(association)\n                    .setLastTimeConnected(System.currentTimeMillis())\n                    .build();\n            mAssociationStore.updateAssociation(association);\n\n            mDevicePresenceMonitor.onSelfManagedDeviceConnected(associationId);\n        }\n\n        @Override\n        public void notifyDeviceDisappeared(int associationId) {\n            if (DEBUG) Log.i(TAG, \"notifyDevice_Disappeared() id=\" + associationId);\n\n            final AssociationInfo association = getAssociationWithCallerChecks(associationId);\n            if (association == null) {\n                throw new IllegalArgumentException(\"Association with ID \" + associationId + \" \"\n                        + \"does not exist \"\n                        + \"or belongs to a different package \"\n                        + \"or belongs to a different user\");\n            }\n\n            if (!association.isSelfManaged()) {\n                throw new IllegalArgumentException(\"Association with ID \" + associationId\n                        + \" is not self-managed. notifyDeviceAppeared(int) can only be called for\"\n                        + \" self-managed associations.\");\n            }\n\n            mDevicePresenceMonitor.onSelfManagedDeviceDisconnected(associationId);\n        }\n\n        private void registerDevicePresenceListenerActive(String packageName, String deviceAddress,\n                boolean active) throws RemoteException {\n            if (DEBUG) {\n                Log.i(TAG, \"registerDevicePresenceListenerActive()\"\n                        + \" active=\" + active\n                        + \" deviceAddress=\" + deviceAddress);\n            }\n\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.REQUEST_OBSERVE_COMPANION_DEVICE_PRESENCE,\n                    \"[un]registerDevicePresenceListenerService\");\n            final int userId = getCallingUserId();\n            enforceCallerIsSystemOr(userId, packageName);\n\n            AssociationInfo association = mAssociationStore.getAssociationsForPackageWithAddress(\n                            userId, packageName, deviceAddress);\n\n            if (association == null) {\n                throw new RemoteException(new DeviceNotAssociatedException(\"App \" + packageName\n                        + \" is not associated with device \" + deviceAddress\n                        + \" for user \" + userId));\n            }\n\n            // If already at specified state, then no-op.\n            if (active == association.isNotifyOnDeviceNearby()) {\n                if (DEBUG) Log.d(TAG, \"Device presence listener is already at desired state.\");\n                return;\n            }\n\n            // AssociationInfo class is immutable: create a new AssociationInfo object with updated\n            // flag.\n            association = AssociationInfo.builder(association)\n                    .setNotifyOnDeviceNearby(active)\n                    .build();\n            // Do not need to call {@link BleCompanionDeviceScanner#restartScan()} since it will\n            // trigger {@link BleCompanionDeviceScanner#restartScan(int, AssociationInfo)} when\n            // an application sets/unsets the mNotifyOnDeviceNearby flag.\n            mAssociationStore.updateAssociation(association);\n\n            // If device is already present, then trigger callback.\n            if (active && mDevicePresenceMonitor.isDevicePresent(association.getId())) {\n                if (DEBUG) Log.d(TAG, \"Device is already present. Triggering callback.\");\n                onDeviceAppearedInternal(association.getId());\n            }\n\n            // If last listener is unregistered, then unbind application.\n            if (!active && !shouldBindPackage(userId, packageName)) {\n                if (DEBUG) Log.d(TAG, \"Last listener unregistered. Unbinding application.\");\n                mCompanionAppController.unbindCompanionApplication(userId, packageName);\n            }\n        }\n\n        @Override\n        public void createAssociation(String packageName, String macAddress, int userId,\n                byte[] certificate) {\n            if (!getContext().getPackageManager().hasSigningCertificate(\n                    packageName, certificate, CERT_INPUT_SHA256)) {\n                Slog.e(TAG, \"Given certificate doesn't match the package certificate.\");\n                return;\n            }\n\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.ASSOCIATE_COMPANION_DEVICES, \"createAssociation\");\n\n            legacyCreateAssociation(userId, macAddress, packageName, null);\n        }\n\n        private void checkCanCallNotificationApi(String callingPackage, int userId) {\n            enforceCallerIsSystemOr(userId, callingPackage);\n\n            if (getCallingUid() == SYSTEM_UID) return;\n\n            enforceUsesCompanionDeviceFeature(getContext(), userId, callingPackage);\n            checkState(!ArrayUtils.isEmpty(\n                    mAssociationStore.getAssociationsForPackage(userId, callingPackage)),\n                    \"App must have an association before calling this API\");\n        }\n\n        @Override\n        public boolean canPairWithoutPrompt(String packageName, String macAddress, int userId) {\n            final AssociationInfo association =\n                    mAssociationStore.getAssociationsForPackageWithAddress(\n                            userId, packageName, macAddress);\n            if (association == null) {\n                return false;\n            }\n            return System.currentTimeMillis() - association.getTimeApprovedMs()\n                    < PAIR_WITHOUT_PROMPT_WINDOW_MS;\n        }\n\n        @Override\n        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n                throws RemoteException {\n            enforceCallerCanManageCompanionDevice(getContext(), \"onShellCommand\");\n\n            final CompanionDeviceShellCommand cmd = new CompanionDeviceShellCommand(\n                    CompanionDeviceManagerService.this,\n                    mAssociationStore,\n                    mDevicePresenceMonitor);\n            cmd.exec(this, in, out, err, args, callback, resultReceiver);\n        }\n\n        @Override\n        public void dump(@NonNull FileDescriptor fd, @NonNull PrintWriter out,\n                @Nullable String[] args) {\n            if (!DumpUtils.checkDumpAndUsageStatsPermission(getContext(), TAG, out)) {\n                return;\n            }\n\n            mAssociationStore.dump(out);\n            mDevicePresenceMonitor.dump(out);\n            mCompanionAppController.dump(out);\n        }\n    }\n\n    /**\n     * @deprecated use\n     * {@link #createAssociation(int, String, MacAddress, CharSequence, String, boolean)}\n     */\n    @Deprecated\n    void legacyCreateAssociation(@UserIdInt int userId, @NonNull String deviceMacAddress,\n            @NonNull String packageName, @Nullable String deviceProfile) {\n        final MacAddress macAddress = MacAddress.fromString(deviceMacAddress);\n        createAssociation(userId, packageName, macAddress, null, deviceProfile, false);\n    }\n\n    AssociationInfo createAssociation(@UserIdInt int userId, @NonNull String packageName,\n            @Nullable MacAddress macAddress, @Nullable CharSequence displayName,\n            @Nullable String deviceProfile, boolean selfManaged) {\n        final int id = getNewAssociationIdForPackage(userId, packageName);\n        final long timestamp = System.currentTimeMillis();\n\n        final AssociationInfo association = new AssociationInfo(id, userId, packageName,\n                macAddress, displayName, deviceProfile, selfManaged, false, timestamp,\n                Long.MAX_VALUE);\n        Slog.i(TAG, \"New CDM association created=\" + association);\n        mAssociationStore.addAssociation(association);\n\n        // If the \"Device Profile\" is specified, make the companion application a holder of the\n        // corresponding role.\n        if (deviceProfile != null) {\n            addRoleHolderForAssociation(getContext(), association);\n        }\n\n        updateSpecialAccessPermissionForAssociatedPackage(association);\n        logCreateAssociation(deviceProfile);\n        return association;\n    }\n\n    @NonNull\n    private Map<String, Set<Integer>> getPreviouslyUsedIdsForUser(@UserIdInt int userId) {\n        synchronized (mPreviouslyUsedIds) {\n            return getPreviouslyUsedIdsForUserLocked(userId);\n        }\n    }\n\n    @GuardedBy(\"mPreviouslyUsedIds\")\n    @NonNull\n    private Map<String, Set<Integer>> getPreviouslyUsedIdsForUserLocked(@UserIdInt int userId) {\n        final Map<String, Set<Integer>> usedIdsForUser = mPreviouslyUsedIds.get(userId);\n        if (usedIdsForUser == null) {\n            return Collections.emptyMap();\n        }\n        return deepUnmodifiableCopy(usedIdsForUser);\n    }\n\n    @GuardedBy(\"mPreviouslyUsedIds\")\n    @NonNull\n    private Set<Integer> getPreviouslyUsedIdsForPackageLocked(\n            @UserIdInt int userId, @NonNull String packageName) {\n        // \"Deeply unmodifiable\" map: the map itself and the Set<Integer> values it contains are all\n        // unmodifiable.\n        final Map<String, Set<Integer>> usedIdsForUser = getPreviouslyUsedIdsForUserLocked(userId);\n        final Set<Integer> usedIdsForPackage = usedIdsForUser.get(packageName);\n\n        if (usedIdsForPackage == null) {\n            return Collections.emptySet();\n        }\n\n        //The set is already unmodifiable.\n        return usedIdsForPackage;\n    }\n\n    private int getNewAssociationIdForPackage(@UserIdInt int userId, @NonNull String packageName) {\n        synchronized (mPreviouslyUsedIds) {\n            // First: collect all IDs currently in use for this user's Associations.\n            final SparseBooleanArray usedIds = new SparseBooleanArray();\n\n            // We should really only be checking associations for the given user (i.e.:\n            // mAssociationStore.getAssociationsForUser(userId)), BUT in the past we've got in a\n            // state where association IDs were not assigned correctly in regard to\n            // user-to-association-ids-range (e.g. associations with IDs from 1 to 100,000 should\n            // always belong to u0), so let's check all the associations.\n            for (AssociationInfo it : mAssociationStore.getAssociations()) {\n                usedIds.put(it.getId(), true);\n            }\n\n            // Second: collect all IDs that have been previously used for this package (and user).\n            final Set<Integer> previouslyUsedIds =\n                    getPreviouslyUsedIdsForPackageLocked(userId, packageName);\n\n            int id = getFirstAssociationIdForUser(userId);\n            final int lastAvailableIdForUser = getLastAssociationIdForUser(userId);\n\n            // Find first ID that isn't used now AND has never been used for the given package.\n            while (usedIds.get(id) || previouslyUsedIds.contains(id)) {\n                // Increment and try again\n                id++;\n                // ... but first check if the ID is valid (within the range allocated to the user).\n                if (id > lastAvailableIdForUser) {\n                    throw new RuntimeException(\"Cannot create a new Association ID for \"\n                            + packageName + \" for user \" + userId);\n                }\n            }\n\n            return id;\n        }\n    }\n\n    // TODO: also revoke notification access\n    void disassociateInternal(int associationId) {\n        final AssociationInfo association = mAssociationStore.getAssociationById(associationId);\n        final int userId = association.getUserId();\n        final String packageName = association.getPackageName();\n        final String deviceProfile = association.getDeviceProfile();\n\n        final boolean wasPresent = mDevicePresenceMonitor.isDevicePresent(associationId);\n\n        // Removing the association.\n        mAssociationStore.removeAssociation(associationId);\n        logRemoveAssociation(deviceProfile);\n\n        final List<AssociationInfo> otherAssociations =\n                mAssociationStore.getAssociationsForPackage(userId, packageName);\n\n        // Check if the package is associated with other devices with the same profile.\n        // If not: take away the role.\n        if (deviceProfile != null) {\n            final boolean shouldKeepTheRole = any(otherAssociations,\n                    it -> deviceProfile.equals(it.getDeviceProfile()));\n            if (!shouldKeepTheRole) {\n                Binder.withCleanCallingIdentity(() ->\n                        removeRoleHolderForAssociation(getContext(), association));\n            }\n        }\n\n        if (!wasPresent || !association.isNotifyOnDeviceNearby()) return;\n        // The device was connected and the app was notified: check if we need to unbind the app\n        // now.\n        final boolean shouldStayBound = any(otherAssociations,\n                it -> it.isNotifyOnDeviceNearby()\n                        && mDevicePresenceMonitor.isDevicePresent(it.getId()));\n        if (shouldStayBound) return;\n        mCompanionAppController.unbindCompanionApplication(userId, packageName);\n    }\n\n    private void updateSpecialAccessPermissionForAssociatedPackage(AssociationInfo association) {\n        final PackageInfo packageInfo =\n                getPackageInfo(getContext(), association.getUserId(), association.getPackageName());\n\n        Binder.withCleanCallingIdentity(() -> updateSpecialAccessPermissionAsSystem(packageInfo));\n    }\n\n    private void updateSpecialAccessPermissionAsSystem(PackageInfo packageInfo) {\n        if (containsEither(packageInfo.requestedPermissions,\n                android.Manifest.permission.RUN_IN_BACKGROUND,\n                android.Manifest.permission.REQUEST_COMPANION_RUN_IN_BACKGROUND)) {\n            mPowerWhitelistManager.addToWhitelist(packageInfo.packageName);\n        } else {\n            try {\n                mPowerWhitelistManager.removeFromWhitelist(packageInfo.packageName);\n            } catch (UnsupportedOperationException e) {\n                Slog.w(TAG, packageInfo.packageName + \" can't be removed from power save\"\n                        + \" whitelist. It might due to the package is whitelisted by the system.\");\n            }\n        }\n\n        NetworkPolicyManager networkPolicyManager = NetworkPolicyManager.from(getContext());\n        if (containsEither(packageInfo.requestedPermissions,\n                android.Manifest.permission.USE_DATA_IN_BACKGROUND,\n                android.Manifest.permission.REQUEST_COMPANION_USE_DATA_IN_BACKGROUND)) {\n            networkPolicyManager.addUidPolicy(\n                    packageInfo.applicationInfo.uid,\n                    NetworkPolicyManager.POLICY_ALLOW_METERED_BACKGROUND);\n        } else {\n            networkPolicyManager.removeUidPolicy(\n                    packageInfo.applicationInfo.uid,\n                    NetworkPolicyManager.POLICY_ALLOW_METERED_BACKGROUND);\n        }\n\n        exemptFromAutoRevoke(packageInfo.packageName, packageInfo.applicationInfo.uid);\n    }\n\n    private void exemptFromAutoRevoke(String packageName, int uid) {\n        try {\n            mAppOpsManager.setMode(\n                    AppOpsManager.OP_AUTO_REVOKE_PERMISSIONS_IF_UNUSED,\n                    uid,\n                    packageName,\n                    AppOpsManager.MODE_IGNORED);\n        } catch (RemoteException e) {\n            Slog.w(TAG, \"Error while granting auto revoke exemption for \" + packageName, e);\n        }\n    }\n\n    private void updateAtm(int userId, List<AssociationInfo> associations) {\n        final Set<Integer> companionAppUids = new ArraySet<>();\n        for (AssociationInfo association : associations) {\n            final int uid = mPackageManagerInternal.getPackageUid(association.getPackageName(),\n                    0, userId);\n            if (uid >= 0) {\n                companionAppUids.add(uid);\n            }\n        }\n        if (mAtmInternal != null) {\n            mAtmInternal.setCompanionAppUids(userId, companionAppUids);\n        }\n        if (mAmInternal != null) {\n            // Make a copy of the set and send it to ActivityManager.\n            mAmInternal.setCompanionAppUids(userId, new ArraySet<>(companionAppUids));\n        }\n    }\n\n    private void maybeGrantAutoRevokeExemptions() {\n        Slog.d(TAG, \"maybeGrantAutoRevokeExemptions()\");\n\n        PackageManager pm = getContext().getPackageManager();\n        for (int userId : LocalServices.getService(UserManagerInternal.class).getUserIds()) {\n            SharedPreferences pref = getContext().getSharedPreferences(\n                    new File(Environment.getUserSystemDirectory(userId), PREF_FILE_NAME),\n                    Context.MODE_PRIVATE);\n            if (pref.getBoolean(PREF_KEY_AUTO_REVOKE_GRANTS_DONE, false)) {\n                continue;\n            }\n\n            try {\n                final List<AssociationInfo> associations =\n                        mAssociationStore.getAssociationsForUser(userId);\n                for (AssociationInfo a : associations) {\n                    try {\n                        int uid = pm.getPackageUidAsUser(a.getPackageName(), userId);\n                        exemptFromAutoRevoke(a.getPackageName(), uid);\n                    } catch (PackageManager.NameNotFoundException e) {\n                        Slog.w(TAG, \"Unknown companion package: \" + a.getPackageName(), e);\n                    }\n                }\n            } finally {\n                pref.edit().putBoolean(PREF_KEY_AUTO_REVOKE_GRANTS_DONE, true).apply();\n            }\n        }\n    }\n\n    private final AssociationStore.OnChangeListener mAssociationStoreChangeListener =\n            new AssociationStore.OnChangeListener() {\n        @Override\n        public void onAssociationChanged(int changeType, AssociationInfo association) {\n            onAssociationChangedInternal(changeType, association);\n        }\n    };\n\n    private final CompanionDevicePresenceMonitor.Callback mDevicePresenceCallback =\n            new CompanionDevicePresenceMonitor.Callback() {\n        @Override\n        public void onDeviceAppeared(int associationId) {\n            onDeviceAppearedInternal(associationId);\n        }\n\n        @Override\n        public void onDeviceDisappeared(int associationId) {\n            onDeviceDisappearedInternal(associationId);\n        }\n    };\n\n    private final CompanionApplicationController.Callback mApplicationControllerCallback =\n            new CompanionApplicationController.Callback() {\n        @Override\n        public boolean onCompanionApplicationBindingDied(int userId, @NonNull String packageName) {\n            return onCompanionApplicationBindingDiedInternal(userId, packageName);\n        }\n\n        @Override\n        public void onRebindCompanionApplicationTimeout(int userId, @NonNull String packageName) {\n            onRebindCompanionApplicationTimeoutInternal(userId, packageName);\n        }\n    };\n\n    private final PackageMonitor mPackageMonitor = new PackageMonitor() {\n        @Override\n        public void onPackageRemoved(String packageName, int uid) {\n            onPackageRemoveOrDataClearedInternal(getChangingUserId(), packageName);\n        }\n\n        @Override\n        public void onPackageDataCleared(String packageName, int uid) {\n            onPackageRemoveOrDataClearedInternal(getChangingUserId(), packageName);\n        }\n\n        @Override\n        public void onPackageModified(String packageName) {\n            onPackageModifiedInternal(getChangingUserId(), packageName);\n        }\n    };\n\n    static int getFirstAssociationIdForUser(@UserIdInt int userId) {\n        // We want the IDs to start from 1, not 0.\n        return userId * ASSOCIATIONS_IDS_PER_USER_RANGE + 1;\n    }\n\n    static int getLastAssociationIdForUser(@UserIdInt int userId) {\n        return (userId + 1) * ASSOCIATIONS_IDS_PER_USER_RANGE;\n    }\n\n    private static Map<String, Set<Integer>> deepUnmodifiableCopy(Map<String, Set<Integer>> orig) {\n        final Map<String, Set<Integer>> copy = new HashMap<>();\n\n        for (Map.Entry<String, Set<Integer>> entry : orig.entrySet()) {\n            final Set<Integer> valueCopy = new HashSet<>(entry.getValue());\n            copy.put(entry.getKey(), Collections.unmodifiableSet(valueCopy));\n        }\n\n        return Collections.unmodifiableMap(copy);\n    }\n\n    private static <T> boolean containsEither(T[] array, T a, T b) {\n        return ArrayUtils.contains(array, a) || ArrayUtils.contains(array, b);\n    }\n\n    private class LocalService implements CompanionDeviceManagerServiceInternal {\n        @Override\n        public void removeInactiveSelfManagedAssociations() {\n            CompanionDeviceManagerService.this.removeInactiveSelfManagedAssociations();\n        }\n    }\n\n    /**\n     * This method must only be called from {@link CompanionDeviceShellCommand} for testing\n     * purposes only!\n     */\n    void persistState() {\n        mUserPersistenceHandler.clearMessages();\n        for (UserInfo user : mUserManager.getAliveUsers()) {\n            persistStateForUser(user.id);\n        }\n    }\n\n    /**\n     * This class is dedicated to handling requests to persist user state.\n     */\n    @SuppressLint(\"HandlerLeak\")\n    private class PersistUserStateHandler extends Handler {\n        PersistUserStateHandler() {\n            super(BackgroundThread.get().getLooper());\n        }\n\n        /**\n         * Persists user state unless there is already an outstanding request for the given user.\n         */\n        synchronized void postPersistUserState(@UserIdInt int userId) {\n            if (!hasMessages(userId)) {\n                sendMessage(obtainMessage(userId));\n            }\n        }\n\n        /**\n         * Clears *ALL* outstanding persist requests for *ALL* users.\n         */\n        synchronized void clearMessages() {\n            removeCallbacksAndMessages(null);\n        }\n\n        @Override\n        public void handleMessage(@NonNull Message msg) {\n            final int userId = msg.what;\n            persistStateForUser(userId);\n        }\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 9309,
                                        "general": {
                                            "word_based": 3817,
                                            "char_based": 12598
                                        },
                                        "gemini": 10877
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "54c968aaa66e9364bc0380c9a57af5c6844759aa",
                            "repo_path": "android_repos/base",
                            "result": "failure",
                            "downstream_patch_content": "commit 54c968aaa66e9364bc0380c9a57af5c6844759aa\nAuthor: Guojing Yuan <guojing@google.com>\nDate:   Thu Dec 14 19:30:04 2023 +0000\n\n    [CDM][CMD] Check permissions for CDM shell commands\n    \n    Override handleShellCommand instead of onShellCommand because\n    Binder.onShellCommand checks the necessary permissions of the caller.\n    \n    Bug: 313428840\n    \n    Test: manually tested CDM shell commands\n    Change-Id: I5539b3594feb5544c458c0fd1061b51a0a808900\n    Merged-In: I5539b3594feb5544c458c0fd1061b51a0a808900\n    (cherry picked from commit 1761a0fee9c2cd9787bbb7fbdbe30b4c2b03396e)\n\ndiff --git a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\nindex 5c36a6b07392..2194a0863238 100644\n--- a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n+++ b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n@@ -83,9 +83,7 @@ import android.os.ParcelFileDescriptor;\n import android.os.PowerWhitelistManager;\n import android.os.RemoteCallbackList;\n import android.os.RemoteException;\n-import android.os.ResultReceiver;\n import android.os.ServiceManager;\n-import android.os.ShellCallback;\n import android.os.SystemProperties;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -931,13 +929,14 @@ public class CompanionDeviceManagerService extends SystemService {\n         }\n \n         @Override\n-        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n-                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n-                throws RemoteException {\n-            new CompanionDeviceShellCommand(CompanionDeviceManagerService.this, mAssociationStore,\n-                    mDevicePresenceMonitor, mTransportManager, mSystemDataTransferRequestStore,\n-                    mAssociationRequestsProcessor)\n-                    .exec(this, in, out, err, args, callback, resultReceiver);\n+        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n+                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n+                @NonNull String[] args) {\n+            return new CompanionDeviceShellCommand(CompanionDeviceManagerService.this,\n+                    mAssociationStore, mDevicePresenceMonitor, mTransportManager,\n+                    mSystemDataTransferRequestStore, mAssociationRequestsProcessor)\n+                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n+                            err.getFileDescriptor(), args);\n         }\n \n         @Override\n",
                            "downstream_patch_tokens": {
                                "openai": 624,
                                "general": {
                                    "word_based": 228,
                                    "char_based": 674
                                },
                                "gemini": 786
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java",
                                    "total_hunks": 2,
                                    "failed_hunks": [
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n        public void enableSecureTransport(boolean enabled) {\n            mTransportManager.enableSecureTransport(enabled);\n=======\n        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n                @NonNull String[] args) {\n            return new CompanionDeviceShellCommand(CompanionDeviceManagerService.this,\n                    mAssociationStore, mDevicePresenceMonitor, mTransportManager,\n                    mSystemDataTransferProcessor, mAssociationRequestsProcessor)\n                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n                            err.getFileDescriptor(), args);\n>>>>>>> UPSTREAM PATCH (commit 1f31bb181fc56f3deab5ce0d199220404991c438)",
                                            "merge_conflict_tokens": {
                                                "openai": 154,
                                                "general": {
                                                    "word_based": 49,
                                                    "char_based": 206
                                                },
                                                "gemini": 185
                                            }
                                        }
                                    ],
                                    "inline_merge_token_summary": {
                                        "gemini": 17020,
                                        "openai": 14322,
                                        "general_word": 4557,
                                        "general_char": 19158
                                    },
                                    "rej_file_content": "```diff\n--- services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n+++ services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n@@ -949,13 +947,14 @@ public class CompanionDeviceManagerService extends SystemService {\n         }\n \n         @Override\n-        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n-                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n-                throws RemoteException {\n-            new CompanionDeviceShellCommand(CompanionDeviceManagerService.this, mAssociationStore,\n-                    mDevicePresenceMonitor, mTransportManager, mSystemDataTransferProcessor,\n-                    mAssociationRequestsProcessor)\n-                    .exec(this, in, out, err, args, callback, resultReceiver);\n+        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n+                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n+                @NonNull String[] args) {\n+            return new CompanionDeviceShellCommand(CompanionDeviceManagerService.this,\n+                    mAssociationStore, mDevicePresenceMonitor, mTransportManager,\n+                    mSystemDataTransferProcessor, mAssociationRequestsProcessor)\n+                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n+                            err.getFileDescriptor(), args);\n         }\n \n         @Override\n```",
                                    "rej_file_tokens": {
                                        "openai": 276,
                                        "general": {
                                            "word_based": 97,
                                            "char_based": 371
                                        },
                                        "gemini": 312
                                    },
                                    "patch_apply_output": "patching file services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\nHunk #1 succeeded at 83 (offset -1 lines).\nHunk #2 FAILED at 949.\n1 out of 2 hunks FAILED -- saving rejects to file services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java.rej",
                                    "inline_merge_output": "patching file services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\nHunk #1 already applied at 87,88.\nHunk #2 NOT MERGED at 817-829.",
                                    "upstream_file_tokens": {
                                        "openai": 13480,
                                        "general": {
                                            "word_based": 5482,
                                            "char_based": 18027
                                        },
                                        "gemini": 15497
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\npackage com.android.server.companion;\n\nimport static android.Manifest.permission.MANAGE_COMPANION_DEVICES;\nimport static android.app.ActivityManager.RunningAppProcessInfo.IMPORTANCE_VISIBLE;\nimport static android.companion.AssociationRequest.DEVICE_PROFILE_AUTOMOTIVE_PROJECTION;\nimport static android.content.pm.PackageManager.CERT_INPUT_SHA256;\nimport static android.content.pm.PackageManager.PERMISSION_GRANTED;\nimport static android.os.Process.SYSTEM_UID;\nimport static android.os.UserHandle.getCallingUserId;\n\nimport static com.android.internal.util.CollectionUtils.any;\nimport static com.android.internal.util.Preconditions.checkState;\nimport static com.android.internal.util.function.pooled.PooledLambda.obtainMessage;\nimport static com.android.server.companion.AssociationStore.CHANGE_TYPE_UPDATED_ADDRESS_UNCHANGED;\nimport static com.android.server.companion.MetricUtils.logRemoveAssociation;\nimport static com.android.server.companion.PackageUtils.enforceUsesCompanionDeviceFeature;\nimport static com.android.server.companion.PackageUtils.getPackageInfo;\nimport static com.android.server.companion.PermissionsUtils.checkCallerCanManageCompanionDevice;\nimport static com.android.server.companion.PermissionsUtils.enforceCallerCanManageAssociationsForPackage;\nimport static com.android.server.companion.PermissionsUtils.enforceCallerCanManageCompanionDevice;\nimport static com.android.server.companion.PermissionsUtils.enforceCallerIsSystemOr;\nimport static com.android.server.companion.PermissionsUtils.enforceCallerIsSystemOrCanInteractWithUserId;\nimport static com.android.server.companion.PermissionsUtils.sanitizeWithCallerChecks;\nimport static com.android.server.companion.RolesUtils.removeRoleHolderForAssociation;\n\nimport static java.util.Objects.requireNonNull;\nimport static java.util.concurrent.TimeUnit.DAYS;\nimport static java.util.concurrent.TimeUnit.MINUTES;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.SuppressLint;\nimport android.annotation.UserIdInt;\nimport android.app.ActivityManager;\nimport android.app.ActivityManager.RunningAppProcessInfo;\nimport android.app.ActivityManagerInternal;\nimport android.app.AppOpsManager;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.bluetooth.BluetoothDevice;\nimport android.companion.AssociationInfo;\nimport android.companion.AssociationRequest;\nimport android.companion.DeviceNotAssociatedException;\nimport android.companion.IAssociationRequestCallback;\nimport android.companion.ICompanionDeviceManager;\nimport android.companion.IOnAssociationsChangedListener;\nimport android.companion.IOnMessageReceivedListener;\nimport android.companion.IOnTransportsChangedListener;\nimport android.companion.ISystemDataTransferCallback;\nimport android.companion.utils.FeatureUtils;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.UserInfo;\nimport android.net.MacAddress;\nimport android.net.NetworkPolicyManager;\nimport android.os.Binder;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Parcel;\nimport android.os.ParcelFileDescriptor;\nimport android.os.PowerWhitelistManager;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.ServiceManager;\nimport android.os.SystemProperties;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.util.ArraySet;\nimport android.util.ExceptionUtils;\nimport android.util.Log;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.app.IAppOpsService;\nimport com.android.internal.content.PackageMonitor;\nimport com.android.internal.infra.PerUser;\nimport com.android.internal.notification.NotificationAccessConfirmationActivityContract;\nimport com.android.internal.os.BackgroundThread;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.server.FgThread;\nimport com.android.server.LocalServices;\nimport com.android.server.SystemService;\nimport com.android.server.companion.datatransfer.SystemDataTransferProcessor;\nimport com.android.server.companion.datatransfer.SystemDataTransferRequestStore;\nimport com.android.server.companion.datatransfer.contextsync.CrossDeviceCall;\nimport com.android.server.companion.datatransfer.contextsync.CrossDeviceSyncController;\nimport com.android.server.companion.datatransfer.contextsync.CrossDeviceSyncControllerCallback;\nimport com.android.server.companion.presence.CompanionDevicePresenceMonitor;\nimport com.android.server.companion.transport.CompanionTransportManager;\nimport com.android.server.pm.UserManagerInternal;\nimport com.android.server.wm.ActivityTaskManagerInternal;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n@SuppressLint(\"LongLogTag\")\npublic class CompanionDeviceManagerService extends SystemService {\n    static final String TAG = \"CDM_CompanionDeviceManagerService\";\n    static final boolean DEBUG = false;\n\n    /** Range of Association IDs allocated for a user.*/\n    private static final int ASSOCIATIONS_IDS_PER_USER_RANGE = 100000;\n    private static final long PAIR_WITHOUT_PROMPT_WINDOW_MS = 10 * 60 * 1000; // 10 min\n\n    private static final String PREF_FILE_NAME = \"companion_device_preferences.xml\";\n    private static final String PREF_KEY_AUTO_REVOKE_GRANTS_DONE = \"auto_revoke_grants_done\";\n    private static final String SYS_PROP_DEBUG_REMOVAL_TIME_WINDOW =\n            \"debug.cdm.cdmservice.removal_time_window\";\n\n    private static final long ASSOCIATION_REMOVAL_TIME_WINDOW_DEFAULT = DAYS.toMillis(90);\n    private static final int MAX_CN_LENGTH = 500;\n\n    private final ActivityManager mActivityManager;\n    private final OnPackageVisibilityChangeListener mOnPackageVisibilityChangeListener;\n\n    private PersistentDataStore mPersistentStore;\n    private final PersistUserStateHandler mUserPersistenceHandler;\n\n    private final AssociationStoreImpl mAssociationStore;\n    private final SystemDataTransferRequestStore mSystemDataTransferRequestStore;\n    private AssociationRequestsProcessor mAssociationRequestsProcessor;\n    private SystemDataTransferProcessor mSystemDataTransferProcessor;\n    private CompanionDevicePresenceMonitor mDevicePresenceMonitor;\n    private CompanionApplicationController mCompanionAppController;\n    private CompanionTransportManager mTransportManager;\n\n    private final ActivityTaskManagerInternal mAtmInternal;\n    private final ActivityManagerInternal mAmInternal;\n    private final IAppOpsService mAppOpsManager;\n    private final PowerWhitelistManager mPowerWhitelistManager;\n    private final UserManager mUserManager;\n    final PackageManagerInternal mPackageManagerInternal;\n\n    /**\n     * A structure that consists of two nested maps, and effectively maps (userId + packageName) to\n     * a list of IDs that have been previously assigned to associations for that package.\n     * We maintain this structure so that we never re-use association IDs for the same package\n     * (until it's uninstalled).\n     */\n    @GuardedBy(\"mPreviouslyUsedIds\")\n    private final SparseArray<Map<String, Set<Integer>>> mPreviouslyUsedIds = new SparseArray<>();\n\n    /**\n     * A structure that consists of a set of revoked associations that pending for role holder\n     * removal per each user.\n     *\n     * @see #maybeRemoveRoleHolderForAssociation(AssociationInfo)\n     * @see #addToPendingRoleHolderRemoval(AssociationInfo)\n     * @see #removeFromPendingRoleHolderRemoval(AssociationInfo)\n     * @see #getPendingRoleHolderRemovalAssociationsForUser(int)\n     */\n    @GuardedBy(\"mRevokedAssociationsPendingRoleHolderRemoval\")\n    private final PerUserAssociationSet mRevokedAssociationsPendingRoleHolderRemoval =\n            new PerUserAssociationSet();\n    /**\n     * Contains uid-s of packages pending to be removed from the role holder list (after\n     * revocation of an association), which will happen one the package is no longer visible to the\n     * user.\n     * For quicker uid -> (userId, packageName) look-up this is not a {@code Set<Integer>} but\n     * a {@code Map<Integer, String>} which maps uid-s to packageName-s (userId-s can be derived\n     * from uid-s using {@link UserHandle#getUserId(int)}).\n     *\n     * @see #maybeRemoveRoleHolderForAssociation(AssociationInfo)\n     * @see #addToPendingRoleHolderRemoval(AssociationInfo)\n     * @see #removeFromPendingRoleHolderRemoval(AssociationInfo)\n     */\n    @GuardedBy(\"mRevokedAssociationsPendingRoleHolderRemoval\")\n    private final Map<Integer, String> mUidsPendingRoleHolderRemoval = new HashMap<>();\n\n    private final RemoteCallbackList<IOnAssociationsChangedListener> mListeners =\n            new RemoteCallbackList<>();\n\n    private CrossDeviceSyncController mCrossDeviceSyncController;\n\n    public CompanionDeviceManagerService(Context context) {\n        super(context);\n\n        mActivityManager = context.getSystemService(ActivityManager.class);\n        mPowerWhitelistManager = context.getSystemService(PowerWhitelistManager.class);\n        mAppOpsManager = IAppOpsService.Stub.asInterface(\n                ServiceManager.getService(Context.APP_OPS_SERVICE));\n        mAtmInternal = LocalServices.getService(ActivityTaskManagerInternal.class);\n        mAmInternal = LocalServices.getService(ActivityManagerInternal.class);\n        mPackageManagerInternal = LocalServices.getService(PackageManagerInternal.class);\n        mUserManager = context.getSystemService(UserManager.class);\n\n        mUserPersistenceHandler = new PersistUserStateHandler();\n        mAssociationStore = new AssociationStoreImpl();\n        mSystemDataTransferRequestStore = new SystemDataTransferRequestStore();\n\n        mOnPackageVisibilityChangeListener =\n                new OnPackageVisibilityChangeListener(mActivityManager);\n    }\n\n    @Override\n    public void onStart() {\n        final Context context = getContext();\n\n        mPersistentStore = new PersistentDataStore();\n\n        loadAssociationsFromDisk();\n        mAssociationStore.registerListener(mAssociationStoreChangeListener);\n\n        mDevicePresenceMonitor = new CompanionDevicePresenceMonitor(mUserManager,\n                mAssociationStore, mDevicePresenceCallback);\n\n        mAssociationRequestsProcessor = new AssociationRequestsProcessor(\n                /* cdmService */this, mAssociationStore);\n        mCompanionAppController = new CompanionApplicationController(\n                context, mAssociationStore, mDevicePresenceMonitor);\n        mTransportManager = new CompanionTransportManager(context, mAssociationStore);\n        mSystemDataTransferProcessor = new SystemDataTransferProcessor(this, mAssociationStore,\n                mSystemDataTransferRequestStore, mTransportManager);\n        // TODO(b/279663946): move context sync to a dedicated system service\n        mCrossDeviceSyncController = new CrossDeviceSyncController(getContext(), mTransportManager);\n\n        // Publish \"binder\" service.\n        final CompanionDeviceManagerImpl impl = new CompanionDeviceManagerImpl();\n        publishBinderService(Context.COMPANION_DEVICE_SERVICE, impl);\n\n        // Publish \"local\" service.\n        LocalServices.addService(CompanionDeviceManagerServiceInternal.class, new LocalService());\n    }\n\n    void loadAssociationsFromDisk() {\n        final Set<AssociationInfo> allAssociations = new ArraySet<>();\n        synchronized (mPreviouslyUsedIds) {\n            // The data is stored in DE directories, so we can read the data for all users now\n            // (which would not be possible if the data was stored to CE directories).\n            mPersistentStore.readStateForUsers(\n                    mUserManager.getAliveUsers(), allAssociations, mPreviouslyUsedIds);\n        }\n\n        final Set<AssociationInfo> activeAssociations =\n                new ArraySet<>(/* capacity */ allAssociations.size());\n        // A set contains the userIds that need to persist state after remove the app\n        // from the list of role holders.\n        final Set<Integer> usersToPersistStateFor = new ArraySet<>();\n\n        for (AssociationInfo association : allAssociations) {\n            if (!association.isRevoked()) {\n                activeAssociations.add(association);\n            } else if (maybeRemoveRoleHolderForAssociation(association)) {\n                // Nothing more to do here, but we'll need to persist all the associations to the\n                // disk afterwards.\n                usersToPersistStateFor.add(association.getUserId());\n            } else {\n                addToPendingRoleHolderRemoval(association);\n            }\n        }\n\n        mAssociationStore.setAssociations(activeAssociations);\n\n        // IMPORTANT: only do this AFTER mAssociationStore.setAssociations(), because\n        // persistStateForUser() queries AssociationStore.\n        // (If persistStateForUser() is invoked before mAssociationStore.setAssociations() it\n        // would effectively just clear-out all the persisted associations).\n        for (int userId : usersToPersistStateFor) {\n            persistStateForUser(userId);\n        }\n    }\n\n    @Override\n    public void onBootPhase(int phase) {\n        final Context context = getContext();\n        if (phase == PHASE_SYSTEM_SERVICES_READY) {\n            // WARNING: moving PackageMonitor to another thread (Looper) may introduce significant\n            // delays (even in case of the Main Thread). It may be fine overall, but would require\n            // updating the tests (adding a delay there).\n            mPackageMonitor.register(context, FgThread.get().getLooper(), UserHandle.ALL, true);\n            mDevicePresenceMonitor.init(context);\n        } else if (phase == PHASE_BOOT_COMPLETED) {\n            // Run the Inactive Association Removal job service daily.\n            InactiveAssociationsRemovalService.schedule(getContext());\n            mCrossDeviceSyncController.onBootCompleted();\n        }\n    }\n\n    @Override\n    public void onUserUnlocking(@NonNull TargetUser user) {\n        final int userId = user.getUserIdentifier();\n        final List<AssociationInfo> associations = mAssociationStore.getAssociationsForUser(userId);\n\n        if (associations.isEmpty()) return;\n\n        updateAtm(userId, associations);\n\n        BackgroundThread.getHandler().sendMessageDelayed(\n                obtainMessage(CompanionDeviceManagerService::maybeGrantAutoRevokeExemptions, this),\n                MINUTES.toMillis(10));\n    }\n\n    @Override\n    public void onUserUnlocked(@NonNull TargetUser user) {\n        // Notify and bind the app after the phone is unlocked.\n        final int userId = user.getUserIdentifier();\n        final Set<BluetoothDevice> blueToothDevices =\n                mDevicePresenceMonitor.getPendingConnectedDevices().get(userId);\n        if (blueToothDevices != null) {\n            for (BluetoothDevice bluetoothDevice : blueToothDevices) {\n                for (AssociationInfo ai:\n                        mAssociationStore.getAssociationsByAddress(bluetoothDevice.getAddress())) {\n                    Slog.i(TAG, \"onUserUnlocked, device id( \" + ai.getId() + \" ) is connected\");\n                    mDevicePresenceMonitor.onBluetoothCompanionDeviceConnected(ai.getId());\n                }\n            }\n        }\n    }\n\n    @NonNull\n    AssociationInfo getAssociationWithCallerChecks(\n            @UserIdInt int userId, @NonNull String packageName, @NonNull String macAddress) {\n        AssociationInfo association = mAssociationStore.getAssociationsForPackageWithAddress(\n                userId, packageName, macAddress);\n        association = sanitizeWithCallerChecks(getContext(), association);\n        if (association != null) {\n            return association;\n        } else {\n            throw new IllegalArgumentException(\"Association does not exist \"\n                    + \"or the caller does not have permissions to manage it \"\n                    + \"(ie. it belongs to a different package or a different user).\");\n        }\n    }\n\n    @NonNull\n    AssociationInfo getAssociationWithCallerChecks(int associationId) {\n        AssociationInfo association = mAssociationStore.getAssociationById(associationId);\n        association = sanitizeWithCallerChecks(getContext(), association);\n        if (association != null) {\n            return association;\n        } else {\n            throw new IllegalArgumentException(\"Association does not exist \"\n                    + \"or the caller does not have permissions to manage it \"\n                    + \"(ie. it belongs to a different package or a different user).\");\n        }\n    }\n\n    private void onDeviceAppearedInternal(int associationId) {\n        if (DEBUG) Log.i(TAG, \"onDevice_Appeared_Internal() id=\" + associationId);\n\n        final AssociationInfo association = mAssociationStore.getAssociationById(associationId);\n        if (DEBUG) Log.d(TAG, \"  association=\" + association);\n\n        if (!association.shouldBindWhenPresent()) return;\n\n        final int userId = association.getUserId();\n        final String packageName = association.getPackageName();\n        // Set bindImportant to true when the association is self-managed to avoid the target\n        // service being killed.\n        final boolean bindImportant = association.isSelfManaged();\n\n        if (!mCompanionAppController.isCompanionApplicationBound(userId, packageName)) {\n            mCompanionAppController.bindCompanionApplication(userId, packageName, bindImportant);\n        } else if (DEBUG) {\n            Log.i(TAG, \"u\" + userId + \"\\\\\" + packageName + \" is already bound\");\n        }\n        mCompanionAppController.notifyCompanionApplicationDeviceAppeared(association);\n    }\n\n    private void onDeviceDisappearedInternal(int associationId) {\n        if (DEBUG) Log.i(TAG, \"onDevice_Disappeared_Internal() id=\" + associationId);\n\n        final AssociationInfo association = mAssociationStore.getAssociationById(associationId);\n        if (DEBUG) Log.d(TAG, \"  association=\" + association);\n\n        final int userId = association.getUserId();\n        final String packageName = association.getPackageName();\n\n        if (!mCompanionAppController.isCompanionApplicationBound(userId, packageName)) {\n            if (DEBUG) Log.w(TAG, \"u\" + userId + \"\\\\\" + packageName + \" is NOT bound\");\n            return;\n        }\n\n        if (association.shouldBindWhenPresent()) {\n            mCompanionAppController.notifyCompanionApplicationDeviceDisappeared(association);\n        }\n\n        // Check if there are other devices associated to the app that are present.\n        if (shouldBindPackage(userId, packageName)) return;\n\n        mCompanionAppController.unbindCompanionApplication(userId, packageName);\n    }\n\n    /**\n     * @return whether the package should be bound (i.e. at least one of the devices associated with\n     *         the package is currently present).\n     */\n    private boolean shouldBindPackage(@UserIdInt int userId, @NonNull String packageName) {\n        final List<AssociationInfo> packageAssociations =\n                mAssociationStore.getAssociationsForPackage(userId, packageName);\n        for (AssociationInfo association : packageAssociations) {\n            if (!association.shouldBindWhenPresent()) continue;\n            if (mDevicePresenceMonitor.isDevicePresent(association.getId())) return true;\n        }\n        return false;\n    }\n\n    private void onAssociationChangedInternal(\n            @AssociationStore.ChangeType int changeType, AssociationInfo association) {\n        final int id = association.getId();\n        final int userId = association.getUserId();\n        final String packageName = association.getPackageName();\n\n        if (changeType == AssociationStore.CHANGE_TYPE_REMOVED) {\n            markIdAsPreviouslyUsedForPackage(id, userId, packageName);\n        }\n\n        final List<AssociationInfo> updatedAssociations =\n                mAssociationStore.getAssociationsForUser(userId);\n\n        mUserPersistenceHandler.postPersistUserState(userId);\n\n        // Notify listeners if ADDED, REMOVED or UPDATED_ADDRESS_CHANGED.\n        // Do NOT notify when UPDATED_ADDRESS_UNCHANGED, which means a minor tweak in association's\n        // configs, which \"listeners\" won't (and shouldn't) be able to see.\n        if (changeType != CHANGE_TYPE_UPDATED_ADDRESS_UNCHANGED) {\n            notifyListeners(userId, updatedAssociations);\n        }\n        updateAtm(userId, updatedAssociations);\n    }\n\n    private void persistStateForUser(@UserIdInt int userId) {\n        // We want to store both active associations and the revoked (removed) association that we\n        // are keeping around for the final clean-up (delayed role holder removal).\n        final List<AssociationInfo> allAssociations;\n        // Start with the active associations - these we can get from the AssociationStore.\n        allAssociations = new ArrayList<>(\n                mAssociationStore.getAssociationsForUser(userId));\n        // ... and add the revoked (removed) association, that are yet to be permanently removed.\n        allAssociations.addAll(getPendingRoleHolderRemovalAssociationsForUser(userId));\n\n        final Map<String, Set<Integer>> usedIdsForUser = getPreviouslyUsedIdsForUser(userId);\n\n        mPersistentStore.persistStateForUser(userId, allAssociations, usedIdsForUser);\n    }\n\n    private void notifyListeners(\n            @UserIdInt int userId, @NonNull List<AssociationInfo> associations) {\n        mListeners.broadcast((listener, callbackUserId) -> {\n            if ((int) callbackUserId == userId) {\n                try {\n                    listener.onAssociationsChanged(associations);\n                } catch (RemoteException ignored) {\n                }\n            }\n        });\n    }\n\n    private void markIdAsPreviouslyUsedForPackage(\n            int associationId, @UserIdInt int userId, @NonNull String packageName) {\n        synchronized (mPreviouslyUsedIds) {\n            Map<String, Set<Integer>> usedIdsForUser = mPreviouslyUsedIds.get(userId);\n            if (usedIdsForUser == null) {\n                usedIdsForUser = new HashMap<>();\n                mPreviouslyUsedIds.put(userId, usedIdsForUser);\n            }\n\n            final Set<Integer> usedIdsForPackage =\n                    usedIdsForUser.computeIfAbsent(packageName, it -> new HashSet<>());\n            usedIdsForPackage.add(associationId);\n        }\n    }\n\n    private void onPackageRemoveOrDataClearedInternal(\n            @UserIdInt int userId, @NonNull String packageName) {\n        if (DEBUG) {\n            Log.i(TAG, \"onPackageRemove_Or_DataCleared() u\" + userId + \"/\"\n                    + packageName);\n        }\n\n        // Clear associations.\n        final List<AssociationInfo> associationsForPackage =\n                mAssociationStore.getAssociationsForPackage(userId, packageName);\n        for (AssociationInfo association : associationsForPackage) {\n            mAssociationStore.removeAssociation(association.getId());\n        }\n        // Clear role holders\n        for (AssociationInfo association : associationsForPackage) {\n            maybeRemoveRoleHolderForAssociation(association);\n        }\n\n        mCompanionAppController.onPackagesChanged(userId);\n    }\n\n    private void onPackageModifiedInternal(@UserIdInt int userId, @NonNull String packageName) {\n        if (DEBUG) Log.i(TAG, \"onPackageModified() u\" + userId + \"/\" + packageName);\n\n        final List<AssociationInfo> associationsForPackage =\n                mAssociationStore.getAssociationsForPackage(userId, packageName);\n        for (AssociationInfo association : associationsForPackage) {\n            updateSpecialAccessPermissionForAssociatedPackage(association);\n        }\n\n        mCompanionAppController.onPackagesChanged(userId);\n    }\n\n    // Revoke associations if the selfManaged companion device does not connect for 3 months.\n    void removeInactiveSelfManagedAssociations() {\n        final long currentTime = System.currentTimeMillis();\n        long removalWindow = SystemProperties.getLong(SYS_PROP_DEBUG_REMOVAL_TIME_WINDOW, -1);\n        if (removalWindow <= 0) {\n            // 0 or negative values indicate that the sysprop was never set or should be ignored.\n            removalWindow = ASSOCIATION_REMOVAL_TIME_WINDOW_DEFAULT;\n        }\n\n        for (AssociationInfo association : mAssociationStore.getAssociations()) {\n            if (!association.isSelfManaged()) continue;\n\n            final boolean isInactive =\n                    currentTime - association.getLastTimeConnectedMs() >= removalWindow;\n            if (!isInactive) continue;\n\n            final int id = association.getId();\n\n            Slog.i(TAG, \"Removing inactive self-managed association id=\" + id);\n            disassociateInternal(id);\n        }\n    }\n\n    class CompanionDeviceManagerImpl extends ICompanionDeviceManager.Stub {\n        @Override\n        public boolean onTransact(int code, Parcel data, Parcel reply, int flags)\n                throws RemoteException {\n            try {\n                return super.onTransact(code, data, reply, flags);\n            } catch (Throwable e) {\n                Slog.e(TAG, \"Error during IPC\", e);\n                throw ExceptionUtils.propagate(e, RemoteException.class);\n            }\n        }\n\n        @Override\n        public void associate(AssociationRequest request, IAssociationRequestCallback callback,\n                String packageName, int userId) throws RemoteException {\n            Slog.i(TAG, \"associate() \"\n                    + \"request=\" + request + \", \"\n                    + \"package=u\" + userId + \"/\" + packageName);\n            enforceCallerCanManageAssociationsForPackage(getContext(), userId, packageName,\n                    \"create associations\");\n\n            mAssociationRequestsProcessor.processNewAssociationRequest(\n                    request, packageName, userId, callback);\n        }\n\n        @Override\n        public PendingIntent buildAssociationCancellationIntent(String packageName,\n                int userId) throws RemoteException {\n            Slog.i(TAG, \"buildAssociationCancellationIntent() \"\n                    + \"package=u\" + userId + \"/\" + packageName);\n            enforceCallerCanManageAssociationsForPackage(getContext(), userId, packageName,\n                    \"build association cancellation intent\");\n\n            return mAssociationRequestsProcessor.buildAssociationCancellationIntent(\n                    packageName, userId);\n        }\n\n        @Override\n        public List<AssociationInfo> getAssociations(String packageName, int userId) {\n            enforceCallerCanManageAssociationsForPackage(getContext(), userId, packageName,\n                    \"get associations\");\n\n            if (!checkCallerCanManageCompanionDevice(getContext())) {\n                // If the caller neither is system nor holds MANAGE_COMPANION_DEVICES: it needs to\n                // request the feature (also: the caller is the app itself).\n                enforceUsesCompanionDeviceFeature(getContext(), userId, packageName);\n            }\n\n            return mAssociationStore.getAssociationsForPackage(userId, packageName);\n        }\n\n        @Override\n        public List<AssociationInfo> getAllAssociationsForUser(int userId) throws RemoteException {\n            enforceCallerIsSystemOrCanInteractWithUserId(getContext(), userId);\n            enforceCallerCanManageCompanionDevice(getContext(), \"getAllAssociationsForUser\");\n\n            return mAssociationStore.getAssociationsForUser(userId);\n        }\n\n        @Override\n        public void addOnAssociationsChangedListener(IOnAssociationsChangedListener listener,\n                int userId) {\n            enforceCallerIsSystemOrCanInteractWithUserId(getContext(), userId);\n            enforceCallerCanManageCompanionDevice(getContext(),\n                    \"addOnAssociationsChangedListener\");\n\n            mListeners.register(listener, userId);\n        }\n\n        @Override\n        public void removeOnAssociationsChangedListener(IOnAssociationsChangedListener listener,\n                int userId) {\n            enforceCallerIsSystemOrCanInteractWithUserId(getContext(), userId);\n            enforceCallerCanManageCompanionDevice(\n                    getContext(), \"removeOnAssociationsChangedListener\");\n\n            mListeners.unregister(listener);\n        }\n\n        @Override\n        public void addOnTransportsChangedListener(IOnTransportsChangedListener listener) {\n            mTransportManager.addListener(listener);\n        }\n\n        @Override\n        public void removeOnTransportsChangedListener(IOnTransportsChangedListener listener) {\n            mTransportManager.removeListener(listener);\n        }\n\n        @Override\n        public void sendMessage(int messageType, byte[] data, int[] associationIds) {\n            mTransportManager.sendMessage(messageType, data, associationIds);\n        }\n\n        @Override\n        public void addOnMessageReceivedListener(int messageType,\n                IOnMessageReceivedListener listener) {\n            mTransportManager.addListener(messageType, listener);\n        }\n\n        @Override\n        public void removeOnMessageReceivedListener(int messageType,\n                IOnMessageReceivedListener listener) {\n            mTransportManager.removeListener(messageType, listener);\n        }\n\n        @Override\n        public void legacyDisassociate(String deviceMacAddress, String packageName, int userId) {\n            Log.i(TAG, \"legacyDisassociate() pkg=u\" + userId + \"/\" + packageName\n                    + \", macAddress=\" + deviceMacAddress);\n\n            requireNonNull(deviceMacAddress);\n            requireNonNull(packageName);\n\n            final AssociationInfo association =\n                    getAssociationWithCallerChecks(userId, packageName, deviceMacAddress);\n            disassociateInternal(association.getId());\n        }\n\n        @Override\n        public void disassociate(int associationId) {\n            Log.i(TAG, \"disassociate() associationId=\" + associationId);\n\n            final AssociationInfo association =\n                    getAssociationWithCallerChecks(associationId);\n            disassociateInternal(association.getId());\n        }\n\n        @Override\n        public PendingIntent requestNotificationAccess(ComponentName component, int userId)\n                throws RemoteException {\n            String callingPackage = component.getPackageName();\n            checkCanCallNotificationApi(callingPackage, userId);\n            if (component.flattenToString().length() > MAX_CN_LENGTH) {\n                throw new IllegalArgumentException(\"Component name is too long.\");\n            }\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return PendingIntent.getActivityAsUser(getContext(),\n                        0 /* request code */,\n                        NotificationAccessConfirmationActivityContract.launcherIntent(\n                                getContext(), userId, component),\n                        PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_ONE_SHOT\n                                | PendingIntent.FLAG_CANCEL_CURRENT,\n                        null /* options */,\n                        new UserHandle(userId));\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n\n        /**\n        * @deprecated Use\n        * {@link NotificationManager#isNotificationListenerAccessGranted(ComponentName)} instead.\n        */\n        @Deprecated\n        @Override\n        public boolean hasNotificationAccess(ComponentName component) throws RemoteException {\n            checkCanCallNotificationApi(component.getPackageName(), getCallingUserId());\n            NotificationManager nm = getContext().getSystemService(NotificationManager.class);\n            return nm.isNotificationListenerAccessGranted(component);\n        }\n\n        @Override\n        public boolean isDeviceAssociatedForWifiConnection(String packageName, String macAddress,\n                int userId) {\n            getContext().enforceCallingOrSelfPermission(\n                    MANAGE_COMPANION_DEVICES, \"isDeviceAssociated\");\n\n            boolean bypassMacPermission = getContext().getPackageManager().checkPermission(\n                    android.Manifest.permission.COMPANION_APPROVE_WIFI_CONNECTIONS, packageName)\n                    == PERMISSION_GRANTED;\n            if (bypassMacPermission) {\n                return true;\n            }\n\n            return any(mAssociationStore.getAssociationsForPackage(userId, packageName),\n                    a -> a.isLinkedTo(macAddress));\n        }\n\n        @Override\n        public void registerDevicePresenceListenerService(String deviceAddress,\n                String callingPackage, int userId) throws RemoteException {\n            // TODO: take the userId into account.\n            registerDevicePresenceListenerActive(callingPackage, deviceAddress, true);\n        }\n\n        @Override\n        public void unregisterDevicePresenceListenerService(String deviceAddress,\n                String callingPackage, int userId) throws RemoteException {\n            // TODO: take the userId into account.\n            registerDevicePresenceListenerActive(callingPackage, deviceAddress, false);\n        }\n\n        @Override\n        public PendingIntent buildPermissionTransferUserConsentIntent(String packageName,\n                int userId, int associationId) {\n            if (!FeatureUtils.isPermSyncEnabled()) {\n                throw new UnsupportedOperationException(\"Calling\"\n                        + \" buildPermissionTransferUserConsentIntent, but this API is disabled by\"\n                        + \" the system.\");\n            }\n            return mSystemDataTransferProcessor.buildPermissionTransferUserConsentIntent(\n                    packageName, userId, associationId);\n        }\n\n        @Override\n        public void startSystemDataTransfer(String packageName, int userId, int associationId,\n                ISystemDataTransferCallback callback) {\n            if (!FeatureUtils.isPermSyncEnabled()) {\n                throw new UnsupportedOperationException(\"Calling startSystemDataTransfer, but this\"\n                        + \" API is disabled by the system.\");\n            }\n            mSystemDataTransferProcessor.startSystemDataTransfer(packageName, userId,\n                    associationId, callback);\n        }\n\n        @Override\n        public void attachSystemDataTransport(String packageName, int userId, int associationId,\n                ParcelFileDescriptor fd) {\n            getAssociationWithCallerChecks(associationId);\n            mTransportManager.attachSystemDataTransport(packageName, userId, associationId, fd);\n        }\n\n        @Override\n        public void detachSystemDataTransport(String packageName, int userId, int associationId) {\n            getAssociationWithCallerChecks(associationId);\n            mTransportManager.detachSystemDataTransport(packageName, userId, associationId);\n        }\n\n        @Override\n        public void enableSystemDataSync(int associationId, int flags) {\n            getAssociationWithCallerChecks(associationId);\n            mAssociationRequestsProcessor.enableSystemDataSync(associationId, flags);\n        }\n\n        @Override\n        public void disableSystemDataSync(int associationId, int flags) {\n            getAssociationWithCallerChecks(associationId);\n            mAssociationRequestsProcessor.disableSystemDataSync(associationId, flags);\n        }\n\n        @Override\n        public void enableSecureTransport(boolean enabled) {\n            mTransportManager.enableSecureTransport(enabled);\n        }\n\n        @Override\n        public void notifyDeviceAppeared(int associationId) {\n            if (DEBUG) Log.i(TAG, \"notifyDevice_Appeared() id=\" + associationId);\n\n            AssociationInfo association = getAssociationWithCallerChecks(associationId);\n            if (!association.isSelfManaged()) {\n                throw new IllegalArgumentException(\"Association with ID \" + associationId\n                        + \" is not self-managed. notifyDeviceAppeared(int) can only be called for\"\n                        + \" self-managed associations.\");\n            }\n            // AssociationInfo class is immutable: create a new AssociationInfo object with updated\n            // timestamp.\n            association = AssociationInfo.builder(association)\n                    .setLastTimeConnected(System.currentTimeMillis())\n                    .build();\n            mAssociationStore.updateAssociation(association);\n\n            mDevicePresenceMonitor.onSelfManagedDeviceConnected(associationId);\n        }\n\n        @Override\n        public void notifyDeviceDisappeared(int associationId) {\n            if (DEBUG) Log.i(TAG, \"notifyDevice_Disappeared() id=\" + associationId);\n\n            final AssociationInfo association = getAssociationWithCallerChecks(associationId);\n            if (!association.isSelfManaged()) {\n                throw new IllegalArgumentException(\"Association with ID \" + associationId\n                        + \" is not self-managed. notifyDeviceAppeared(int) can only be called for\"\n                        + \" self-managed associations.\");\n            }\n\n            mDevicePresenceMonitor.onSelfManagedDeviceDisconnected(associationId);\n        }\n\n        @Override\n        public boolean isCompanionApplicationBound(String packageName, int userId) {\n            return mCompanionAppController.isCompanionApplicationBound(userId, packageName);\n        }\n\n        private void registerDevicePresenceListenerActive(String packageName, String deviceAddress,\n                boolean active) throws RemoteException {\n            if (DEBUG) {\n                Log.i(TAG, \"registerDevicePresenceListenerActive()\"\n                        + \" active=\" + active\n                        + \" deviceAddress=\" + deviceAddress);\n            }\n\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.REQUEST_OBSERVE_COMPANION_DEVICE_PRESENCE,\n                    \"[un]registerDevicePresenceListenerService\");\n            final int userId = getCallingUserId();\n            enforceCallerIsSystemOr(userId, packageName);\n\n            AssociationInfo association = mAssociationStore.getAssociationsForPackageWithAddress(\n                    userId, packageName, deviceAddress);\n\n            if (association == null) {\n                throw new RemoteException(new DeviceNotAssociatedException(\"App \" + packageName\n                        + \" is not associated with device \" + deviceAddress\n                        + \" for user \" + userId));\n            }\n\n            // If already at specified state, then no-op.\n            if (active == association.isNotifyOnDeviceNearby()) {\n                if (DEBUG) Log.d(TAG, \"Device presence listener is already at desired state.\");\n                return;\n            }\n\n            // AssociationInfo class is immutable: create a new AssociationInfo object with updated\n            // flag.\n            association = AssociationInfo.builder(association)\n                    .setNotifyOnDeviceNearby(active)\n                    .build();\n            // Do not need to call {@link BleCompanionDeviceScanner#restartScan()} since it will\n            // trigger {@link BleCompanionDeviceScanner#restartScan(int, AssociationInfo)} when\n            // an application sets/unsets the mNotifyOnDeviceNearby flag.\n            mAssociationStore.updateAssociation(association);\n\n            // If device is already present, then trigger callback.\n            if (active && mDevicePresenceMonitor.isDevicePresent(association.getId())) {\n                if (DEBUG) Log.d(TAG, \"Device is already present. Triggering callback.\");\n                onDeviceAppearedInternal(association.getId());\n            }\n\n            // If last listener is unregistered, then unbind application.\n            if (!active && !shouldBindPackage(userId, packageName)) {\n                if (DEBUG) Log.d(TAG, \"Last listener unregistered. Unbinding application.\");\n                mCompanionAppController.unbindCompanionApplication(userId, packageName);\n            }\n        }\n\n        @Override\n        public void createAssociation(String packageName, String macAddress, int userId,\n                byte[] certificate) {\n            if (!getContext().getPackageManager().hasSigningCertificate(\n                    packageName, certificate, CERT_INPUT_SHA256)) {\n                Slog.e(TAG, \"Given certificate doesn't match the package certificate.\");\n                return;\n            }\n\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.ASSOCIATE_COMPANION_DEVICES, \"createAssociation\");\n\n            final MacAddress macAddressObj = MacAddress.fromString(macAddress);\n            createNewAssociation(userId, packageName, macAddressObj, null, null, false);\n        }\n\n        private void checkCanCallNotificationApi(String callingPackage, int userId) {\n            enforceCallerIsSystemOr(userId, callingPackage);\n\n            if (getCallingUid() == SYSTEM_UID) return;\n\n            enforceUsesCompanionDeviceFeature(getContext(), userId, callingPackage);\n            checkState(!ArrayUtils.isEmpty(\n                            mAssociationStore.getAssociationsForPackage(userId, callingPackage)),\n                    \"App must have an association before calling this API\");\n        }\n\n        @Override\n        public boolean canPairWithoutPrompt(String packageName, String macAddress, int userId) {\n            final AssociationInfo association =\n                    mAssociationStore.getAssociationsForPackageWithAddress(\n                            userId, packageName, macAddress);\n            if (association == null) {\n                return false;\n            }\n            return System.currentTimeMillis() - association.getTimeApprovedMs()\n                    < PAIR_WITHOUT_PROMPT_WINDOW_MS;\n        }\n\n        @Override\n        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n                throws RemoteException {\n            new CompanionDeviceShellCommand(CompanionDeviceManagerService.this, mAssociationStore,\n                    mDevicePresenceMonitor, mTransportManager, mSystemDataTransferRequestStore,\n                    mAssociationRequestsProcessor)\n                    .exec(this, in, out, err, args, callback, resultReceiver);\n        }\n\n        @Override\n        public void dump(@NonNull FileDescriptor fd, @NonNull PrintWriter out,\n                @Nullable String[] args) {\n            if (!DumpUtils.checkDumpAndUsageStatsPermission(getContext(), TAG, out)) {\n                return;\n            }\n\n            mAssociationStore.dump(out);\n            mDevicePresenceMonitor.dump(out);\n            mCompanionAppController.dump(out);\n        }\n    }\n\n    void createNewAssociation(@UserIdInt int userId, @NonNull String packageName,\n            @Nullable MacAddress macAddress, @Nullable CharSequence displayName,\n            @Nullable String deviceProfile, boolean isSelfManaged) {\n        mAssociationRequestsProcessor.createAssociation(userId, packageName, macAddress,\n                displayName, deviceProfile, /* associatedDevice */ null, isSelfManaged,\n                /* callback */ null, /* resultReceiver */ null);\n    }\n\n    @NonNull\n    private Map<String, Set<Integer>> getPreviouslyUsedIdsForUser(@UserIdInt int userId) {\n        synchronized (mPreviouslyUsedIds) {\n            return getPreviouslyUsedIdsForUserLocked(userId);\n        }\n    }\n\n    @GuardedBy(\"mPreviouslyUsedIds\")\n    @NonNull\n    private Map<String, Set<Integer>> getPreviouslyUsedIdsForUserLocked(@UserIdInt int userId) {\n        final Map<String, Set<Integer>> usedIdsForUser = mPreviouslyUsedIds.get(userId);\n        if (usedIdsForUser == null) {\n            return Collections.emptyMap();\n        }\n        return deepUnmodifiableCopy(usedIdsForUser);\n    }\n\n    @GuardedBy(\"mPreviouslyUsedIds\")\n    @NonNull\n    private Set<Integer> getPreviouslyUsedIdsForPackageLocked(\n            @UserIdInt int userId, @NonNull String packageName) {\n        // \"Deeply unmodifiable\" map: the map itself and the Set<Integer> values it contains are all\n        // unmodifiable.\n        final Map<String, Set<Integer>> usedIdsForUser = getPreviouslyUsedIdsForUserLocked(userId);\n        final Set<Integer> usedIdsForPackage = usedIdsForUser.get(packageName);\n\n        if (usedIdsForPackage == null) {\n            return Collections.emptySet();\n        }\n\n        //The set is already unmodifiable.\n        return usedIdsForPackage;\n    }\n\n    int getNewAssociationIdForPackage(@UserIdInt int userId, @NonNull String packageName) {\n        synchronized (mPreviouslyUsedIds) {\n            // First: collect all IDs currently in use for this user's Associations.\n            final SparseBooleanArray usedIds = new SparseBooleanArray();\n\n            // We should really only be checking associations for the given user (i.e.:\n            // mAssociationStore.getAssociationsForUser(userId)), BUT in the past we've got in a\n            // state where association IDs were not assigned correctly in regard to\n            // user-to-association-ids-range (e.g. associations with IDs from 1 to 100,000 should\n            // always belong to u0), so let's check all the associations.\n            for (AssociationInfo it : mAssociationStore.getAssociations()) {\n                usedIds.put(it.getId(), true);\n            }\n\n            // Second: collect all IDs that have been previously used for this package (and user).\n            final Set<Integer> previouslyUsedIds =\n                    getPreviouslyUsedIdsForPackageLocked(userId, packageName);\n\n            int id = getFirstAssociationIdForUser(userId);\n            final int lastAvailableIdForUser = getLastAssociationIdForUser(userId);\n\n            // Find first ID that isn't used now AND has never been used for the given package.\n            while (usedIds.get(id) || previouslyUsedIds.contains(id)) {\n                // Increment and try again\n                id++;\n                // ... but first check if the ID is valid (within the range allocated to the user).\n                if (id > lastAvailableIdForUser) {\n                    throw new RuntimeException(\"Cannot create a new Association ID for \"\n                            + packageName + \" for user \" + userId);\n                }\n            }\n\n            return id;\n        }\n    }\n\n    // TODO: also revoke notification access\n    void disassociateInternal(int associationId) {\n        final AssociationInfo association = mAssociationStore.getAssociationById(associationId);\n        final int userId = association.getUserId();\n        final String packageName = association.getPackageName();\n        final String deviceProfile = association.getDeviceProfile();\n\n        if (!maybeRemoveRoleHolderForAssociation(association)) {\n            // Need to remove the app from list of the role holders, but will have to do it later\n            // (the app is in foreground at the moment).\n            addToPendingRoleHolderRemoval(association);\n        }\n\n        // Need to check if device still present now because CompanionDevicePresenceMonitor will\n        // remove current connected device after mAssociationStore.removeAssociation\n        final boolean wasPresent = mDevicePresenceMonitor.isDevicePresent(associationId);\n\n        // Removing the association.\n        mAssociationStore.removeAssociation(associationId);\n        // Do not need to persistUserState since CompanionDeviceManagerService will get callback\n        // from #onAssociationChanged, and it will handle the persistUserState which including\n        // active and revoked association.\n        logRemoveAssociation(deviceProfile);\n\n        // Remove all the system data transfer requests for the association.\n        mSystemDataTransferRequestStore.removeRequestsByAssociationId(userId, associationId);\n\n        if (!wasPresent || !association.isNotifyOnDeviceNearby()) return;\n        // The device was connected and the app was notified: check if we need to unbind the app\n        // now.\n        final boolean shouldStayBound = any(\n                mAssociationStore.getAssociationsForPackage(userId, packageName),\n                it -> it.isNotifyOnDeviceNearby()\n                        && mDevicePresenceMonitor.isDevicePresent(it.getId()));\n        if (shouldStayBound) return;\n        mCompanionAppController.unbindCompanionApplication(userId, packageName);\n    }\n\n    /**\n     * First, checks if the companion application should be removed from the list role holders when\n     * upon association's removal, i.e.: association's profile (matches the role) is not null,\n     * the application does not have other associations with the same profile, etc.\n     *\n     * <p>\n     * Then, if establishes that the application indeed has to be removed from the list of the role\n     * holders, checks if it could be done right now -\n     * {@link android.app.role.RoleManager#removeRoleHolderAsUser(String, String, int, UserHandle, java.util.concurrent.Executor, java.util.function.Consumer) RoleManager#removeRoleHolderAsUser()}\n     * will kill the application's process, which leads poor user experience if the application was\n     * in foreground when this happened, to avoid this CDMS delays invoking\n     * {@code RoleManager.removeRoleHolderAsUser()} until the app is no longer in foreground.\n     *\n     * @return {@code true} if the application does NOT need be removed from the list of the role\n     *         holders OR if the application was successfully removed from the list of role holders.\n     *         I.e.: from the role-management perspective the association is done with.\n     *         {@code false} if the application needs to be removed from the list of role the role\n     *         holders, BUT it CDMS would prefer to do it later.\n     *         I.e.: application is in the foreground at the moment, but invoking\n     *         {@code RoleManager.removeRoleHolderAsUser()} will kill the application's process,\n     *         which would lead to the poor UX, hence need to try later.\n     */\n\n    private boolean maybeRemoveRoleHolderForAssociation(@NonNull AssociationInfo association) {\n        if (DEBUG) Log.d(TAG, \"maybeRemoveRoleHolderForAssociation() association=\" + association);\n\n        final String deviceProfile = association.getDeviceProfile();\n        if (deviceProfile == null) {\n            // No role was granted to for this association, there is nothing else we need to here.\n            return true;\n        }\n        // Do not need to remove the system role since it was pre-granted by the system.\n        if (deviceProfile.equals(DEVICE_PROFILE_AUTOMOTIVE_PROJECTION)) {\n            return true;\n        }\n\n        // Check if the applications is associated with another devices with the profile. If so,\n        // it should remain the role holder.\n        final int id = association.getId();\n        final int userId = association.getUserId();\n        final String packageName = association.getPackageName();\n        final boolean roleStillInUse = any(\n                mAssociationStore.getAssociationsForPackage(userId, packageName),\n                it -> deviceProfile.equals(it.getDeviceProfile()) && id != it.getId());\n        if (roleStillInUse) {\n            // Application should remain a role holder, there is nothing else we need to here.\n            return true;\n        }\n\n        final int packageProcessImportance = getPackageProcessImportance(userId, packageName);\n        if (packageProcessImportance <= IMPORTANCE_VISIBLE) {\n            // Need to remove the app from the list of role holders, but the process is visible to\n            // the user at the moment, so we'll need to it later: log and return false.\n            Slog.i(TAG, \"Cannot remove role holder for the removed association id=\" + id\n                    + \" now - process is visible.\");\n            return false;\n        }\n\n        removeRoleHolderForAssociation(getContext(), association);\n        return true;\n    }\n\n    private int getPackageProcessImportance(@UserIdInt int userId, @NonNull String packageName) {\n        return Binder.withCleanCallingIdentity(() -> {\n            final int uid =\n                    mPackageManagerInternal.getPackageUid(packageName, /* flags */0, userId);\n            return mActivityManager.getUidImportance(uid);\n        });\n    }\n\n    /**\n     * Set revoked flag for active association and add the revoked association and the uid into\n     * the caches.\n     *\n     * @see #mRevokedAssociationsPendingRoleHolderRemoval\n     * @see #mUidsPendingRoleHolderRemoval\n     * @see OnPackageVisibilityChangeListener\n     */\n    private void addToPendingRoleHolderRemoval(@NonNull AssociationInfo association) {\n        // First: set revoked flag.\n        association = AssociationInfo.builder(association)\n                .setRevoked(true)\n                .build();\n\n        final String packageName = association.getPackageName();\n        final int userId = association.getUserId();\n        final int uid = mPackageManagerInternal.getPackageUid(packageName, /* flags */0, userId);\n\n        // Second: add to the set.\n        synchronized (mRevokedAssociationsPendingRoleHolderRemoval) {\n            mRevokedAssociationsPendingRoleHolderRemoval.forUser(association.getUserId())\n                    .add(association);\n            if (!mUidsPendingRoleHolderRemoval.containsKey(uid)) {\n                mUidsPendingRoleHolderRemoval.put(uid, packageName);\n\n                if (mUidsPendingRoleHolderRemoval.size() == 1) {\n                    // Just added first uid: start the listener\n                    mOnPackageVisibilityChangeListener.startListening();\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove the revoked association from the cache and also remove the uid from the map if\n     * there are other associations with the same package still pending for role holder removal.\n     *\n     * @see #mRevokedAssociationsPendingRoleHolderRemoval\n     * @see #mUidsPendingRoleHolderRemoval\n     * @see OnPackageVisibilityChangeListener\n     */\n    private void removeFromPendingRoleHolderRemoval(@NonNull AssociationInfo association) {\n        final String packageName = association.getPackageName();\n        final int userId = association.getUserId();\n        final int uid = mPackageManagerInternal.getPackageUid(packageName, /* flags */0, userId);\n\n        synchronized (mRevokedAssociationsPendingRoleHolderRemoval) {\n            mRevokedAssociationsPendingRoleHolderRemoval.forUser(userId)\n                    .remove(association);\n\n            final boolean shouldKeepUidForRemoval = any(\n                    getPendingRoleHolderRemovalAssociationsForUser(userId),\n                    ai -> packageName.equals(ai.getPackageName()));\n            // Do not remove the uid from the map since other associations with\n            // the same packageName still pending for role holder removal.\n            if (!shouldKeepUidForRemoval) {\n                mUidsPendingRoleHolderRemoval.remove(uid);\n            }\n\n            if (mUidsPendingRoleHolderRemoval.isEmpty()) {\n                // The set is empty now - can \"turn off\" the listener.\n                mOnPackageVisibilityChangeListener.stopListening();\n            }\n        }\n    }\n\n    /**\n     * @return a copy of the revoked associations set (safeguarding against\n     *         {@code ConcurrentModificationException}-s).\n     */\n    private @NonNull Set<AssociationInfo> getPendingRoleHolderRemovalAssociationsForUser(\n            @UserIdInt int userId) {\n        synchronized (mRevokedAssociationsPendingRoleHolderRemoval) {\n            // Return a copy.\n            return new ArraySet<>(mRevokedAssociationsPendingRoleHolderRemoval.forUser(userId));\n        }\n    }\n\n    private String getPackageNameByUid(int uid) {\n        synchronized (mRevokedAssociationsPendingRoleHolderRemoval) {\n            return mUidsPendingRoleHolderRemoval.get(uid);\n        }\n    }\n\n    void updateSpecialAccessPermissionForAssociatedPackage(AssociationInfo association) {\n        final PackageInfo packageInfo =\n                getPackageInfo(getContext(), association.getUserId(), association.getPackageName());\n\n        Binder.withCleanCallingIdentity(() -> updateSpecialAccessPermissionAsSystem(packageInfo));\n    }\n\n    private void updateSpecialAccessPermissionAsSystem(PackageInfo packageInfo) {\n        if (packageInfo == null) {\n            return;\n        }\n        if (containsEither(packageInfo.requestedPermissions,\n                android.Manifest.permission.RUN_IN_BACKGROUND,\n                android.Manifest.permission.REQUEST_COMPANION_RUN_IN_BACKGROUND)) {\n            mPowerWhitelistManager.addToWhitelist(packageInfo.packageName);\n        } else {\n            try {\n                mPowerWhitelistManager.removeFromWhitelist(packageInfo.packageName);\n            } catch (UnsupportedOperationException e) {\n                Slog.w(TAG, packageInfo.packageName + \" can't be removed from power save\"\n                        + \" whitelist. It might due to the package is whitelisted by the system.\");\n            }\n        }\n\n        NetworkPolicyManager networkPolicyManager = NetworkPolicyManager.from(getContext());\n        try {\n            if (containsEither(packageInfo.requestedPermissions,\n                    android.Manifest.permission.USE_DATA_IN_BACKGROUND,\n                    android.Manifest.permission.REQUEST_COMPANION_USE_DATA_IN_BACKGROUND)) {\n                networkPolicyManager.addUidPolicy(\n                        packageInfo.applicationInfo.uid,\n                        NetworkPolicyManager.POLICY_ALLOW_METERED_BACKGROUND);\n            } else {\n                networkPolicyManager.removeUidPolicy(\n                        packageInfo.applicationInfo.uid,\n                        NetworkPolicyManager.POLICY_ALLOW_METERED_BACKGROUND);\n            }\n        } catch (IllegalArgumentException e) {\n            Slog.e(TAG, e.getMessage());\n        }\n\n        exemptFromAutoRevoke(packageInfo.packageName, packageInfo.applicationInfo.uid);\n    }\n\n    private void exemptFromAutoRevoke(String packageName, int uid) {\n        try {\n            mAppOpsManager.setMode(\n                    AppOpsManager.OP_AUTO_REVOKE_PERMISSIONS_IF_UNUSED,\n                    uid,\n                    packageName,\n                    AppOpsManager.MODE_IGNORED);\n        } catch (RemoteException e) {\n            Slog.w(TAG, \"Error while granting auto revoke exemption for \" + packageName, e);\n        }\n    }\n\n    private void updateAtm(int userId, List<AssociationInfo> associations) {\n        final Set<Integer> companionAppUids = new ArraySet<>();\n        for (AssociationInfo association : associations) {\n            final int uid = mPackageManagerInternal.getPackageUid(association.getPackageName(),\n                    0, userId);\n            if (uid >= 0) {\n                companionAppUids.add(uid);\n            }\n        }\n        if (mAtmInternal != null) {\n            mAtmInternal.setCompanionAppUids(userId, companionAppUids);\n        }\n        if (mAmInternal != null) {\n            // Make a copy of the set and send it to ActivityManager.\n            mAmInternal.setCompanionAppUids(userId, new ArraySet<>(companionAppUids));\n        }\n    }\n\n    private void maybeGrantAutoRevokeExemptions() {\n        Slog.d(TAG, \"maybeGrantAutoRevokeExemptions()\");\n\n        PackageManager pm = getContext().getPackageManager();\n        for (int userId : LocalServices.getService(UserManagerInternal.class).getUserIds()) {\n            SharedPreferences pref = getContext().getSharedPreferences(\n                    new File(Environment.getUserSystemDirectory(userId), PREF_FILE_NAME),\n                    Context.MODE_PRIVATE);\n            if (pref.getBoolean(PREF_KEY_AUTO_REVOKE_GRANTS_DONE, false)) {\n                continue;\n            }\n\n            try {\n                final List<AssociationInfo> associations =\n                        mAssociationStore.getAssociationsForUser(userId);\n                for (AssociationInfo a : associations) {\n                    try {\n                        int uid = pm.getPackageUidAsUser(a.getPackageName(), userId);\n                        exemptFromAutoRevoke(a.getPackageName(), uid);\n                    } catch (PackageManager.NameNotFoundException e) {\n                        Slog.w(TAG, \"Unknown companion package: \" + a.getPackageName(), e);\n                    }\n                }\n            } finally {\n                pref.edit().putBoolean(PREF_KEY_AUTO_REVOKE_GRANTS_DONE, true).apply();\n            }\n        }\n    }\n\n    private final AssociationStore.OnChangeListener mAssociationStoreChangeListener =\n            new AssociationStore.OnChangeListener() {\n        @Override\n        public void onAssociationChanged(int changeType, AssociationInfo association) {\n            onAssociationChangedInternal(changeType, association);\n        }\n    };\n\n    private final CompanionDevicePresenceMonitor.Callback mDevicePresenceCallback =\n            new CompanionDevicePresenceMonitor.Callback() {\n        @Override\n        public void onDeviceAppeared(int associationId) {\n            onDeviceAppearedInternal(associationId);\n        }\n\n        @Override\n        public void onDeviceDisappeared(int associationId) {\n            onDeviceDisappearedInternal(associationId);\n        }\n    };\n\n    private final PackageMonitor mPackageMonitor = new PackageMonitor() {\n        @Override\n        public void onPackageRemoved(String packageName, int uid) {\n            onPackageRemoveOrDataClearedInternal(getChangingUserId(), packageName);\n        }\n\n        @Override\n        public void onPackageDataCleared(String packageName, int uid) {\n            onPackageRemoveOrDataClearedInternal(getChangingUserId(), packageName);\n        }\n\n        @Override\n        public void onPackageModified(String packageName) {\n            onPackageModifiedInternal(getChangingUserId(), packageName);\n        }\n    };\n\n    static int getFirstAssociationIdForUser(@UserIdInt int userId) {\n        // We want the IDs to start from 1, not 0.\n        return userId * ASSOCIATIONS_IDS_PER_USER_RANGE + 1;\n    }\n\n    static int getLastAssociationIdForUser(@UserIdInt int userId) {\n        return (userId + 1) * ASSOCIATIONS_IDS_PER_USER_RANGE;\n    }\n\n    private static Map<String, Set<Integer>> deepUnmodifiableCopy(Map<String, Set<Integer>> orig) {\n        final Map<String, Set<Integer>> copy = new HashMap<>();\n\n        for (Map.Entry<String, Set<Integer>> entry : orig.entrySet()) {\n            final Set<Integer> valueCopy = new HashSet<>(entry.getValue());\n            copy.put(entry.getKey(), Collections.unmodifiableSet(valueCopy));\n        }\n\n        return Collections.unmodifiableMap(copy);\n    }\n\n    private static <T> boolean containsEither(T[] array, T a, T b) {\n        return ArrayUtils.contains(array, a) || ArrayUtils.contains(array, b);\n    }\n\n    private class LocalService implements CompanionDeviceManagerServiceInternal {\n        @Override\n        public void removeInactiveSelfManagedAssociations() {\n            CompanionDeviceManagerService.this.removeInactiveSelfManagedAssociations();\n        }\n\n        @Override\n        public void registerCallMetadataSyncCallback(CrossDeviceSyncControllerCallback callback,\n                @CrossDeviceSyncControllerCallback.Type int type) {\n            if (CompanionDeviceConfig.isEnabled(\n                    CompanionDeviceConfig.ENABLE_CONTEXT_SYNC_TELECOM)) {\n                mCrossDeviceSyncController.registerCallMetadataSyncCallback(callback, type);\n            }\n        }\n\n        @Override\n        public void crossDeviceSync(int userId, Collection<CrossDeviceCall> calls) {\n            if (CompanionDeviceConfig.isEnabled(\n                    CompanionDeviceConfig.ENABLE_CONTEXT_SYNC_TELECOM)) {\n                mCrossDeviceSyncController.syncToAllDevicesForUserId(userId, calls);\n            }\n        }\n\n        @Override\n        public void crossDeviceSync(AssociationInfo associationInfo,\n                Collection<CrossDeviceCall> calls) {\n            if (CompanionDeviceConfig.isEnabled(\n                    CompanionDeviceConfig.ENABLE_CONTEXT_SYNC_TELECOM)) {\n                mCrossDeviceSyncController.syncToSingleDevice(associationInfo, calls);\n            }\n        }\n\n        @Override\n        public void sendCrossDeviceSyncMessage(int associationId, byte[] message) {\n            if (CompanionDeviceConfig.isEnabled(\n                    CompanionDeviceConfig.ENABLE_CONTEXT_SYNC_TELECOM)) {\n                mCrossDeviceSyncController.syncMessageToDevice(associationId, message);\n            }\n        }\n\n        @Override\n        public void sendCrossDeviceSyncMessageToAllDevices(int userId, byte[] message) {\n            if (CompanionDeviceConfig.isEnabled(\n                    CompanionDeviceConfig.ENABLE_CONTEXT_SYNC_TELECOM)) {\n                mCrossDeviceSyncController.syncMessageToAllDevicesForUserId(userId, message);\n            }\n        }\n\n        @Override\n        public void addSelfOwnedCallId(String callId) {\n            if (CompanionDeviceConfig.isEnabled(\n                    CompanionDeviceConfig.ENABLE_CONTEXT_SYNC_TELECOM)) {\n                mCrossDeviceSyncController.addSelfOwnedCallId(callId);\n            }\n        }\n\n        @Override\n        public void removeSelfOwnedCallId(String callId) {\n            if (CompanionDeviceConfig.isEnabled(\n                    CompanionDeviceConfig.ENABLE_CONTEXT_SYNC_TELECOM)) {\n                mCrossDeviceSyncController.removeSelfOwnedCallId(callId);\n            }\n        }\n    }\n\n    /**\n     * This method must only be called from {@link CompanionDeviceShellCommand} for testing\n     * purposes only!\n     */\n    void persistState() {\n        mUserPersistenceHandler.clearMessages();\n        for (UserInfo user : mUserManager.getAliveUsers()) {\n            persistStateForUser(user.id);\n        }\n    }\n\n    /**\n     * This class is dedicated to handling requests to persist user state.\n     */\n    @SuppressLint(\"HandlerLeak\")\n    private class PersistUserStateHandler extends Handler {\n        PersistUserStateHandler() {\n            super(BackgroundThread.get().getLooper());\n        }\n\n        /**\n         * Persists user state unless there is already an outstanding request for the given user.\n         */\n        synchronized void postPersistUserState(@UserIdInt int userId) {\n            if (!hasMessages(userId)) {\n                sendMessage(obtainMessage(userId));\n            }\n        }\n\n        /**\n         * Clears *ALL* outstanding persist requests for *ALL* users.\n         */\n        synchronized void clearMessages() {\n            removeCallbacksAndMessages(null);\n        }\n\n        @Override\n        public void handleMessage(@NonNull Message msg) {\n            final int userId = msg.what;\n            persistStateForUser(userId);\n        }\n    }\n\n    /**\n     * An OnUidImportanceListener class which watches the importance of the packages.\n     * In this class, we ONLY interested in the importance of the running process is greater than\n     * {@link RunningAppProcessInfo.IMPORTANCE_VISIBLE} for the uids have been added into the\n     * {@link mUidsPendingRoleHolderRemoval}. Lastly remove the role holder for the revoked\n     * associations for the same packages.\n     *\n     * @see #maybeRemoveRoleHolderForAssociation(AssociationInfo)\n     * @see #removeFromPendingRoleHolderRemoval(AssociationInfo)\n     * @see #getPendingRoleHolderRemovalAssociationsForUser(int)\n     */\n    private class OnPackageVisibilityChangeListener implements\n            ActivityManager.OnUidImportanceListener {\n        final @NonNull ActivityManager mAm;\n\n        OnPackageVisibilityChangeListener(@NonNull ActivityManager am) {\n            this.mAm = am;\n        }\n\n        void startListening() {\n            Binder.withCleanCallingIdentity(\n                    () -> mAm.addOnUidImportanceListener(\n                            /* listener */ OnPackageVisibilityChangeListener.this,\n                            RunningAppProcessInfo.IMPORTANCE_VISIBLE));\n        }\n\n        void stopListening() {\n            Binder.withCleanCallingIdentity(\n                    () -> mAm.removeOnUidImportanceListener(\n                            /* listener */ OnPackageVisibilityChangeListener.this));\n        }\n\n        @Override\n        public void onUidImportance(int uid, int importance) {\n            if (importance <= RunningAppProcessInfo.IMPORTANCE_VISIBLE) {\n                // The lower the importance value the more \"important\" the process is.\n                // We are only interested when the process ceases to be visible.\n                return;\n            }\n\n            final String packageName = getPackageNameByUid(uid);\n            if (packageName == null) {\n                // Not interested in this uid.\n                return;\n            }\n\n            final int userId = UserHandle.getUserId(uid);\n\n            boolean needToPersistStateForUser = false;\n\n            for (AssociationInfo association :\n                    getPendingRoleHolderRemovalAssociationsForUser(userId)) {\n                if (!packageName.equals(association.getPackageName())) continue;\n\n                if (!maybeRemoveRoleHolderForAssociation(association)) {\n                    // Did not remove the role holder, will have to try again later.\n                    continue;\n                }\n\n                removeFromPendingRoleHolderRemoval(association);\n                needToPersistStateForUser = true;\n            }\n\n            if (needToPersistStateForUser) {\n                mUserPersistenceHandler.postPersistUserState(userId);\n            }\n        }\n    }\n\n    private static class PerUserAssociationSet extends PerUser<Set<AssociationInfo>> {\n        @Override\n        protected @NonNull Set<AssociationInfo> create(int userId) {\n            return new ArraySet<>();\n        }\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 13336,
                                        "general": {
                                            "word_based": 5442,
                                            "char_based": 17810
                                        },
                                        "gemini": 15330
                                    }
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-330722900",
            "aliases": [
                "A-330722900",
                "CVE-2024-43080"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-330722900",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "1189e24e47571eae86634aeaa7dc60b8fe7f4820"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 1189e24e47571eae86634aeaa7dc60b8fe7f4820 Mon Sep 17 00:00:00 2001\nFrom: Adam Bookatz <bookatz@google.com>\nDate: Mon, 22 Jul 2024 17:03:12 -0700\nSubject: [PATCH] startActivityForResult with new Intent\n\nRather than use the raw Intent, we make a copy of it. See bug.\n\nBug: 330722900\nFlag: EXEMPT bugfix\nTest: manual\nTest: atest com.android.settings.users.UserSettingsTest\n            com.android.settings.users.UserDetailsSettingsTest\nChange-Id: Id74e4b7ae261f2916eedaef04a679f83409a4b67\n---\n src/com/android/settings/users/AppRestrictionsFragment.java | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/src/com/android/settings/users/AppRestrictionsFragment.java b/src/com/android/settings/users/AppRestrictionsFragment.java\nindex 1532448718c..c42e2f57b1d 100644\n--- a/src/com/android/settings/users/AppRestrictionsFragment.java\n+++ b/src/com/android/settings/users/AppRestrictionsFragment.java\n@@ -651,7 +651,7 @@ public class AppRestrictionsFragment extends SettingsPreferenceFragment implemen\n                     int requestCode = generateCustomActivityRequestCode(\n                             RestrictionsResultReceiver.this.preference);\n                     AppRestrictionsFragment.this.startActivityForResult(\n-                            restrictionsIntent, requestCode);\n+                            new Intent(restrictionsIntent), requestCode);\n                 }\n             }\n         }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 359,
                        "general": {
                            "word_based": 150,
                            "char_based": 362
                        },
                        "gemini": 472
                    },
                    "total_downstream_versions_tested": 0,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": []
                }
            ]
        },
        {
            "id": "ASB-A-311374917",
            "aliases": [
                "A-311374917",
                "CVE-2024-23710"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-311374917",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "3ee5dfdcba047051ce81dca0696d6ddfeafe2d98"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 3ee5dfdcba047051ce81dca0696d6ddfeafe2d98 Mon Sep 17 00:00:00 2001\nFrom: Alex Buynytskyy <alexbuy@google.com>\nDate: Thu, 4 Jan 2024 00:18:16 +0000\nSubject: [PATCH] Stop marking apps as privileged if they are not signed\n properly.\n\nFixes: 311374917\nTest: atest android.content.pm.cts.PackageManagerTest\nChange-Id: I5b5b81cf43b06837a22c8dfd170a112106dd64c1\n---\n .../java/com/android/server/pm/InstallPackageHelper.java   | 7 +++++--\n 1 file changed, 5 insertions(+), 2 deletions(-)\n\ndiff --git a/services/core/java/com/android/server/pm/InstallPackageHelper.java b/services/core/java/com/android/server/pm/InstallPackageHelper.java\nindex b638d306544c..f8bc9d8f60b4 100644\n--- a/services/core/java/com/android/server/pm/InstallPackageHelper.java\n+++ b/services/core/java/com/android/server/pm/InstallPackageHelper.java\n@@ -4590,7 +4590,9 @@ final class InstallPackageHelper {\n \n     private void assertPackageWithSharedUserIdIsPrivileged(AndroidPackage pkg)\n             throws PackageManagerException {\n-        if (!AndroidPackageLegacyUtils.isPrivileged(pkg) && (pkg.getSharedUserId() != null)) {\n+        if (!AndroidPackageLegacyUtils.isPrivileged(pkg)\n+                && (pkg.getSharedUserId() != null)\n+                && !pkg.isLeavingSharedUser()) {\n             SharedUserSetting sharedUserSetting = null;\n             try {\n                 synchronized (mPm.mLock) {\n@@ -4630,7 +4632,8 @@ final class InstallPackageHelper {\n         if (((scanFlags & SCAN_AS_PRIVILEGED) == 0)\n                 && !AndroidPackageLegacyUtils.isPrivileged(pkg)\n                 && (pkg.getSharedUserId() != null)\n-                && !skipVendorPrivilegeScan) {\n+                && !skipVendorPrivilegeScan\n+                && !pkg.isLeavingSharedUser()) {\n             SharedUserSetting sharedUserSetting = null;\n             synchronized (mPm.mLock) {\n                 try {\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 509,
                        "general": {
                            "word_based": 181,
                            "char_based": 474
                        },
                        "gemini": 640
                    },
                    "total_downstream_versions_tested": 2,
                    "successful_patches": 0,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "e336c7d7c9ceb49d934bbef0d27ecef344ad80ed",
                            "repo_path": "android_repos/base",
                            "result": "failure",
                            "downstream_patch_content": "commit e336c7d7c9ceb49d934bbef0d27ecef344ad80ed\nAuthor: Alex Buynytskyy <alexbuy@google.com>\nDate:   Thu Jan 4 00:18:16 2024 +0000\n\n    Stop marking apps as privileged if they are not signed properly.\n    \n    Fixes: 311374917\n    Test: atest android.content.pm.cts.PackageManagerTest\n    Change-Id: I5b5b81cf43b06837a22c8dfd170a112106dd64c1\n    Merged-In: I5b5b81cf43b06837a22c8dfd170a112106dd64c1\n    (cherry picked from commit 3ee5dfdcba047051ce81dca0696d6ddfeafe2d98)\n\ndiff --git a/services/core/java/com/android/server/pm/InstallPackageHelper.java b/services/core/java/com/android/server/pm/InstallPackageHelper.java\nindex b541e33bde9e..52750e875c02 100644\n--- a/services/core/java/com/android/server/pm/InstallPackageHelper.java\n+++ b/services/core/java/com/android/server/pm/InstallPackageHelper.java\n@@ -4373,7 +4373,9 @@ final class InstallPackageHelper {\n \n     private void assertPackageWithSharedUserIdIsPrivileged(AndroidPackage pkg)\n             throws PackageManagerException {\n-        if (!pkg.isPrivileged() && (pkg.getSharedUserId() != null)) {\n+        if (!pkg.isPrivileged()\n+                && (pkg.getSharedUserId() != null)\n+                && !pkg.isLeavingSharedUid()) {\n             SharedUserSetting sharedUserSetting = null;\n             try {\n                 sharedUserSetting = mPm.mSettings.getSharedUserLPw(pkg.getSharedUserId(),\n@@ -4407,7 +4409,8 @@ final class InstallPackageHelper {\n         if (((scanFlags & SCAN_AS_PRIVILEGED) == 0)\n                 && !pkg.isPrivileged()\n                 && (pkg.getSharedUserId() != null)\n-                && !skipVendorPrivilegeScan) {\n+                && !skipVendorPrivilegeScan\n+                && !pkg.isLeavingSharedUid()) {\n             SharedUserSetting sharedUserSetting = null;\n             synchronized (mPm.mLock) {\n                 try {\n",
                            "downstream_patch_tokens": {
                                "openai": 501,
                                "general": {
                                    "word_based": 159,
                                    "char_based": 457
                                },
                                "gemini": 639
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "services/core/java/com/android/server/pm/InstallPackageHelper.java",
                                    "total_hunks": 2,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [],
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    },
                                    "rej_file_content": "```diff\n--- services/core/java/com/android/server/pm/InstallPackageHelper.java\n+++ services/core/java/com/android/server/pm/InstallPackageHelper.java\n@@ -4590,7 +4590,9 @@ final class InstallPackageHelper {\n \n     private void assertPackageWithSharedUserIdIsPrivileged(AndroidPackage pkg)\n             throws PackageManagerException {\n-        if (!AndroidPackageLegacyUtils.isPrivileged(pkg) && (pkg.getSharedUserId() != null)) {\n+        if (!AndroidPackageLegacyUtils.isPrivileged(pkg)\n+                && (pkg.getSharedUserId() != null)\n+                && !pkg.isLeavingSharedUser()) {\n             SharedUserSetting sharedUserSetting = null;\n             try {\n                 synchronized (mPm.mLock) {\n```",
                                    "rej_file_tokens": {
                                        "openai": 151,
                                        "general": {
                                            "word_based": 55,
                                            "char_based": 175
                                        },
                                        "gemini": 185
                                    },
                                    "patch_apply_output": "patching file services/core/java/com/android/server/pm/InstallPackageHelper.java\nHunk #1 FAILED at 4590.\nHunk #2 succeeded at 4407 with fuzz 2 (offset -223 lines).\n1 out of 2 hunks FAILED -- saving rejects to file services/core/java/com/android/server/pm/InstallPackageHelper.java.rej",
                                    "inline_merge_output": "patching file services/core/java/com/android/server/pm/InstallPackageHelper.java\nHunk #1 already applied at 4593-4595.\nHunk #2 already applied at 4635-4636.",
                                    "upstream_file_tokens": {
                                        "openai": 45285,
                                        "general": {
                                            "word_based": 18420,
                                            "char_based": 61445
                                        },
                                        "gemini": 52272
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2021 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.pm;\n\nimport static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;\nimport static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DISABLED;\nimport static android.content.pm.PackageManager.INSTALL_FAILED_ALREADY_EXISTS;\nimport static android.content.pm.PackageManager.INSTALL_FAILED_BAD_PERMISSION_GROUP;\nimport static android.content.pm.PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;\nimport static android.content.pm.PackageManager.INSTALL_FAILED_DUPLICATE_PERMISSION;\nimport static android.content.pm.PackageManager.INSTALL_FAILED_DUPLICATE_PERMISSION_GROUP;\nimport static android.content.pm.PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;\nimport static android.content.pm.PackageManager.INSTALL_FAILED_INTERNAL_ERROR;\nimport static android.content.pm.PackageManager.INSTALL_FAILED_INVALID_APK;\nimport static android.content.pm.PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION;\nimport static android.content.pm.PackageManager.INSTALL_FAILED_PACKAGE_CHANGED;\nimport static android.content.pm.PackageManager.INSTALL_FAILED_SESSION_INVALID;\nimport static android.content.pm.PackageManager.INSTALL_FAILED_TEST_ONLY;\nimport static android.content.pm.PackageManager.INSTALL_FAILED_UID_CHANGED;\nimport static android.content.pm.PackageManager.INSTALL_FAILED_UPDATE_INCOMPATIBLE;\nimport static android.content.pm.PackageManager.INSTALL_REASON_DEVICE_RESTORE;\nimport static android.content.pm.PackageManager.INSTALL_REASON_DEVICE_SETUP;\nimport static android.content.pm.PackageManager.INSTALL_SUCCEEDED;\nimport static android.content.pm.PackageManager.UNINSTALL_REASON_UNKNOWN;\nimport static android.content.pm.SigningDetails.SignatureSchemeVersion.SIGNING_BLOCK_V4;\nimport static android.content.pm.parsing.ApkLiteParseUtils.isApkFile;\nimport static android.os.PowerExemptionManager.REASON_PACKAGE_REPLACED;\nimport static android.os.Trace.TRACE_TAG_PACKAGE_MANAGER;\nimport static android.os.incremental.IncrementalManager.isIncrementalPath;\nimport static android.os.storage.StorageManager.FLAG_STORAGE_CE;\nimport static android.os.storage.StorageManager.FLAG_STORAGE_DE;\nimport static android.os.storage.StorageManager.FLAG_STORAGE_EXTERNAL;\n\nimport static com.android.server.pm.InstructionSets.getAppDexInstructionSets;\nimport static com.android.server.pm.InstructionSets.getDexCodeInstructionSet;\nimport static com.android.server.pm.InstructionSets.getPreferredInstructionSet;\nimport static com.android.server.pm.PackageManagerService.DEBUG_BACKUP;\nimport static com.android.server.pm.PackageManagerService.DEBUG_COMPRESSION;\nimport static com.android.server.pm.PackageManagerService.DEBUG_INSTALL;\nimport static com.android.server.pm.PackageManagerService.DEBUG_PACKAGE_SCANNING;\nimport static com.android.server.pm.PackageManagerService.DEBUG_REMOVE;\nimport static com.android.server.pm.PackageManagerService.DEBUG_UPGRADE;\nimport static com.android.server.pm.PackageManagerService.DEBUG_VERIFY;\nimport static com.android.server.pm.PackageManagerService.EMPTY_INT_ARRAY;\nimport static com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME;\nimport static com.android.server.pm.PackageManagerService.POST_INSTALL;\nimport static com.android.server.pm.PackageManagerService.PRECOMPILE_LAYOUTS;\nimport static com.android.server.pm.PackageManagerService.SCAN_AS_APK_IN_APEX;\nimport static com.android.server.pm.PackageManagerService.SCAN_AS_FULL_APP;\nimport static com.android.server.pm.PackageManagerService.SCAN_AS_INSTANT_APP;\nimport static com.android.server.pm.PackageManagerService.SCAN_AS_ODM;\nimport static com.android.server.pm.PackageManagerService.SCAN_AS_OEM;\nimport static com.android.server.pm.PackageManagerService.SCAN_AS_PRIVILEGED;\nimport static com.android.server.pm.PackageManagerService.SCAN_AS_PRODUCT;\nimport static com.android.server.pm.PackageManagerService.SCAN_AS_SYSTEM;\nimport static com.android.server.pm.PackageManagerService.SCAN_AS_SYSTEM_EXT;\nimport static com.android.server.pm.PackageManagerService.SCAN_AS_VENDOR;\nimport static com.android.server.pm.PackageManagerService.SCAN_AS_VIRTUAL_PRELOAD;\nimport static com.android.server.pm.PackageManagerService.SCAN_BOOTING;\nimport static com.android.server.pm.PackageManagerService.SCAN_DONT_KILL_APP;\nimport static com.android.server.pm.PackageManagerService.SCAN_DROP_CACHE;\nimport static com.android.server.pm.PackageManagerService.SCAN_FIRST_BOOT_OR_UPGRADE;\nimport static com.android.server.pm.PackageManagerService.SCAN_IGNORE_FROZEN;\nimport static com.android.server.pm.PackageManagerService.SCAN_INITIAL;\nimport static com.android.server.pm.PackageManagerService.SCAN_MOVE;\nimport static com.android.server.pm.PackageManagerService.SCAN_NEW_INSTALL;\nimport static com.android.server.pm.PackageManagerService.SCAN_NO_DEX;\nimport static com.android.server.pm.PackageManagerService.SCAN_REQUIRE_KNOWN;\nimport static com.android.server.pm.PackageManagerService.SCAN_UPDATE_SIGNATURE;\nimport static com.android.server.pm.PackageManagerService.TAG;\nimport static com.android.server.pm.PackageManagerServiceUtils.comparePackageSignatures;\nimport static com.android.server.pm.PackageManagerServiceUtils.compareSignatures;\nimport static com.android.server.pm.PackageManagerServiceUtils.compressedFileExists;\nimport static com.android.server.pm.PackageManagerServiceUtils.deriveAbiOverride;\nimport static com.android.server.pm.PackageManagerServiceUtils.logCriticalInfo;\nimport static com.android.server.pm.SharedUidMigration.BEST_EFFORT;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.UserIdInt;\nimport android.app.AppOpsManager;\nimport android.app.ApplicationPackageManager;\nimport android.app.BroadcastOptions;\nimport android.app.backup.IBackupManager;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentSender;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.DataLoaderType;\nimport android.content.pm.IPackageInstallObserver2;\nimport android.content.pm.PackageChangeEvent;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageInfoLite;\nimport android.content.pm.PackageInstaller;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PermissionGroupInfo;\nimport android.content.pm.PermissionInfo;\nimport android.content.pm.SharedLibraryInfo;\nimport android.content.pm.Signature;\nimport android.content.pm.SigningDetails;\nimport android.content.pm.VerifierInfo;\nimport android.content.pm.dex.DexMetadataHelper;\nimport android.content.pm.parsing.result.ParseResult;\nimport android.content.pm.parsing.result.ParseTypeImpl;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.SystemProperties;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.incremental.IncrementalManager;\nimport android.os.incremental.IncrementalStorage;\nimport android.os.storage.StorageManager;\nimport android.os.storage.VolumeInfo;\nimport android.stats.storage.StorageEnums;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.EventLog;\nimport android.util.Log;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.content.F2fsUtils;\nimport com.android.internal.content.InstallLocationUtils;\nimport com.android.internal.security.VerityUtils;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.CollectionUtils;\nimport com.android.internal.util.FrameworkStatsLog;\nimport com.android.server.EventLogTags;\nimport com.android.server.pm.dex.ArtManagerService;\nimport com.android.server.pm.dex.DexManager;\nimport com.android.server.pm.dex.DexoptOptions;\nimport com.android.server.pm.dex.ViewCompiler;\nimport com.android.server.pm.parsing.PackageCacher;\nimport com.android.server.pm.parsing.PackageParser2;\nimport com.android.server.pm.parsing.pkg.AndroidPackage;\nimport com.android.server.pm.parsing.pkg.AndroidPackageUtils;\nimport com.android.server.pm.parsing.pkg.ParsedPackage;\nimport com.android.server.pm.permission.Permission;\nimport com.android.server.pm.permission.PermissionManagerServiceInternal;\nimport com.android.server.pm.pkg.PackageStateInternal;\nimport com.android.server.pm.pkg.component.ComponentMutateUtils;\nimport com.android.server.pm.pkg.component.ParsedInstrumentation;\nimport com.android.server.pm.pkg.component.ParsedPermission;\nimport com.android.server.pm.pkg.component.ParsedPermissionGroup;\nimport com.android.server.pm.pkg.parsing.ParsingPackageUtils;\nimport com.android.server.rollback.RollbackManagerInternal;\nimport com.android.server.utils.WatchedArrayMap;\nimport com.android.server.utils.WatchedLongSparseArray;\n\nimport dalvik.system.VMRuntime;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.security.DigestException;\nimport java.security.DigestInputStream;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PublicKey;\nimport java.security.cert.CertificateException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ExecutorService;\n\nfinal class InstallPackageHelper {\n    private final PackageManagerService mPm;\n    private final AppDataHelper mAppDataHelper;\n    private final BroadcastHelper mBroadcastHelper;\n    private final RemovePackageHelper mRemovePackageHelper;\n    private final IncrementalManager mIncrementalManager;\n    private final ApexManager mApexManager;\n    private final DexManager mDexManager;\n    private final ArtManagerService mArtManagerService;\n    private final Context mContext;\n    private final PackageDexOptimizer mPackageDexOptimizer;\n    private final PackageAbiHelper mPackageAbiHelper;\n    private final ViewCompiler mViewCompiler;\n    private final SharedLibrariesImpl mSharedLibraries;\n    private final PackageManagerServiceInjector mInjector;\n\n    // TODO(b/198166813): remove PMS dependency\n    InstallPackageHelper(PackageManagerService pm, AppDataHelper appDataHelper) {\n        mPm = pm;\n        mInjector = pm.mInjector;\n        mAppDataHelper = appDataHelper;\n        mBroadcastHelper = new BroadcastHelper(pm.mInjector);\n        mRemovePackageHelper = new RemovePackageHelper(pm);\n        mIncrementalManager = pm.mInjector.getIncrementalManager();\n        mApexManager = pm.mInjector.getApexManager();\n        mDexManager = pm.mInjector.getDexManager();\n        mArtManagerService = pm.mInjector.getArtManagerService();\n        mContext = pm.mInjector.getContext();\n        mPackageDexOptimizer = pm.mInjector.getPackageDexOptimizer();\n        mPackageAbiHelper = pm.mInjector.getAbiHelper();\n        mViewCompiler = pm.mInjector.getViewCompiler();\n        mSharedLibraries = pm.mInjector.getSharedLibrariesImpl();\n    }\n\n    InstallPackageHelper(PackageManagerService pm) {\n        this(pm, new AppDataHelper(pm));\n    }\n\n    /**\n     * Commits the package scan and modifies system state.\n     * <p><em>WARNING:</em> The method may throw an exception in the middle\n     * of committing the package, leaving the system in an inconsistent state.\n     * This needs to be fixed so, once we get to this point, no errors are\n     * possible and the system is not left in an inconsistent state.\n     */\n    @GuardedBy({\"mPm.mLock\", \"mPm.mInstallLock\"})\n    public AndroidPackage commitReconciledScanResultLocked(\n            @NonNull ReconciledPackage reconciledPkg, int[] allUsers) {\n        final ScanResult result = reconciledPkg.mScanResult;\n        final ScanRequest request = result.mRequest;\n        // TODO(b/135203078): Move this even further away\n        ParsedPackage parsedPackage = request.mParsedPackage;\n        if (\"android\".equals(parsedPackage.getPackageName())) {\n            // TODO(b/135203078): Move this to initial parse\n            parsedPackage.setVersionCode(mPm.getSdkVersion())\n                    .setVersionCodeMajor(0);\n        }\n\n        final AndroidPackage oldPkg = request.mOldPkg;\n        final @ParsingPackageUtils.ParseFlags int parseFlags = request.mParseFlags;\n        final @PackageManagerService.ScanFlags int scanFlags = request.mScanFlags;\n        final PackageSetting oldPkgSetting = request.mOldPkgSetting;\n        final PackageSetting originalPkgSetting = request.mOriginalPkgSetting;\n        final UserHandle user = request.mUser;\n        final String realPkgName = request.mRealPkgName;\n        final List<String> changedAbiCodePath = result.mChangedAbiCodePath;\n        final PackageSetting pkgSetting;\n        if (request.mPkgSetting != null) {\n            SharedUserSetting requestSharedUserSetting = mPm.mSettings.getSharedUserSettingLPr(\n                    request.mPkgSetting);\n            SharedUserSetting resultSharedUserSetting = mPm.mSettings.getSharedUserSettingLPr(\n                    result.mPkgSetting);\n            if (requestSharedUserSetting != null\n                    && requestSharedUserSetting != resultSharedUserSetting) {\n                // shared user changed, remove from old shared user\n                requestSharedUserSetting.removePackage(request.mPkgSetting);\n                // Prune unused SharedUserSetting\n                if (mPm.mSettings.checkAndPruneSharedUserLPw(requestSharedUserSetting, false)) {\n                    // Set the app ID in removed info for UID_REMOVED broadcasts\n                    if (reconciledPkg.mInstallResult != null\n                            && reconciledPkg.mInstallResult.mRemovedInfo != null) {\n                        reconciledPkg.mInstallResult.mRemovedInfo.mRemovedAppId =\n                                requestSharedUserSetting.mAppId;\n                    }\n                }\n            }\n        }\n        if (result.mExistingSettingCopied) {\n            pkgSetting = request.mPkgSetting;\n            pkgSetting.updateFrom(result.mPkgSetting);\n        } else {\n            pkgSetting = result.mPkgSetting;\n            if (originalPkgSetting != null) {\n                mPm.mSettings.addRenamedPackageLPw(\n                        AndroidPackageUtils.getRealPackageOrNull(parsedPackage),\n                        originalPkgSetting.getPackageName());\n                mPm.mTransferredPackages.add(originalPkgSetting.getPackageName());\n            } else {\n                mPm.mSettings.removeRenamedPackageLPw(parsedPackage.getPackageName());\n            }\n        }\n        SharedUserSetting sharedUserSetting = mPm.mSettings.getSharedUserSettingLPr(pkgSetting);\n        if (sharedUserSetting != null) {\n            sharedUserSetting.addPackage(pkgSetting);\n            if (parsedPackage.isLeavingSharedUid()\n                    && SharedUidMigration.applyStrategy(BEST_EFFORT)\n                    && sharedUserSetting.isSingleUser()) {\n                // Attempt the transparent shared UID migration\n                mPm.mSettings.convertSharedUserSettingsLPw(sharedUserSetting);\n            }\n        }\n        if (reconciledPkg.mInstallArgs != null\n                && reconciledPkg.mInstallArgs.mForceQueryableOverride) {\n            pkgSetting.setForceQueryableOverride(true);\n        }\n\n        // If this is part of a standard install, set the initiating package name, else rely on\n        // previous device state.\n        if (reconciledPkg.mInstallArgs != null) {\n            InstallSource installSource = reconciledPkg.mInstallArgs.mInstallSource;\n            if (installSource.initiatingPackageName != null) {\n                final PackageSetting ips = mPm.mSettings.getPackageLPr(\n                        installSource.initiatingPackageName);\n                if (ips != null) {\n                    installSource = installSource.setInitiatingPackageSignatures(\n                            ips.getSignatures());\n                }\n            }\n            pkgSetting.setInstallSource(installSource);\n        }\n\n        // TODO(toddke): Consider a method specifically for modifying the Package object\n        // post scan; or, moving this stuff out of the Package object since it has nothing\n        // to do with the package on disk.\n        // We need to have this here because addUserToSettingLPw() is sometimes responsible\n        // for creating the application ID. If we did this earlier, we would be saving the\n        // correct ID.\n        parsedPackage.setUid(pkgSetting.getAppId());\n        final AndroidPackage pkg = parsedPackage.hideAsFinal();\n\n        mPm.mSettings.writeUserRestrictionsLPw(pkgSetting, oldPkgSetting);\n\n        if (realPkgName != null) {\n            mPm.mTransferredPackages.add(pkg.getPackageName());\n        }\n\n        if (reconciledPkg.mCollectedSharedLibraryInfos != null\n                || (oldPkgSetting != null && oldPkgSetting.getUsesLibraryInfos() != null)) {\n            // Reconcile if the new package or the old package uses shared libraries.\n            // It is possible that the old package uses shared libraries but the new one doesn't.\n            mSharedLibraries.executeSharedLibrariesUpdateLPw(pkg, pkgSetting, null, null,\n                    reconciledPkg.mCollectedSharedLibraryInfos, allUsers);\n        }\n\n        final KeySetManagerService ksms = mPm.mSettings.getKeySetManagerService();\n        if (reconciledPkg.mRemoveAppKeySetData) {\n            ksms.removeAppKeySetDataLPw(pkg.getPackageName());\n        }\n        if (reconciledPkg.mSharedUserSignaturesChanged) {\n            sharedUserSetting.signaturesChanged = Boolean.TRUE;\n            sharedUserSetting.signatures.mSigningDetails = reconciledPkg.mSigningDetails;\n        }\n        pkgSetting.setSigningDetails(reconciledPkg.mSigningDetails);\n\n        if (changedAbiCodePath != null && changedAbiCodePath.size() > 0) {\n            for (int i = changedAbiCodePath.size() - 1; i >= 0; --i) {\n                final String codePathString = changedAbiCodePath.get(i);\n                try {\n                    mPm.mInstaller.rmdex(codePathString,\n                            getDexCodeInstructionSet(getPreferredInstructionSet()));\n                } catch (Installer.InstallerException ignored) {\n                }\n            }\n        }\n\n        final int userId = user == null ? 0 : user.getIdentifier();\n        // Modify state for the given package setting\n        commitPackageSettings(pkg, oldPkg, pkgSetting, oldPkgSetting, scanFlags,\n                (parseFlags & ParsingPackageUtils.PARSE_CHATTY) != 0 /*chatty*/, reconciledPkg);\n        if (pkgSetting.getInstantApp(userId)) {\n            mPm.mInstantAppRegistry.addInstantApp(userId, pkgSetting.getAppId());\n        }\n\n        if (!IncrementalManager.isIncrementalPath(pkgSetting.getPathString())) {\n            pkgSetting.setLoadingProgress(1f);\n        }\n\n        return pkg;\n    }\n\n    /**\n     * Adds a scanned package to the system. When this method is finished, the package will\n     * be available for query, resolution, etc...\n     */\n    private void commitPackageSettings(@NonNull AndroidPackage pkg, @Nullable AndroidPackage oldPkg,\n            @NonNull PackageSetting pkgSetting, @Nullable PackageSetting oldPkgSetting,\n            final @PackageManagerService.ScanFlags int scanFlags, boolean chatty,\n            ReconciledPackage reconciledPkg) {\n        final String pkgName = pkg.getPackageName();\n        if (mPm.mCustomResolverComponentName != null\n                && mPm.mCustomResolverComponentName.getPackageName().equals(pkg.getPackageName())) {\n            mPm.setUpCustomResolverActivity(pkg, pkgSetting);\n        }\n\n        if (pkg.getPackageName().equals(\"android\")) {\n            mPm.setPlatformPackage(pkg, pkgSetting);\n        }\n\n        ArrayList<AndroidPackage> clientLibPkgs = null;\n        // writer\n        synchronized (mPm.mLock) {\n            if (!ArrayUtils.isEmpty(reconciledPkg.mAllowedSharedLibraryInfos)) {\n                for (SharedLibraryInfo info : reconciledPkg.mAllowedSharedLibraryInfos) {\n                    mSharedLibraries.commitSharedLibraryInfoLPw(info);\n                }\n                final Map<String, AndroidPackage> combinedSigningDetails =\n                        reconciledPkg.getCombinedAvailablePackages();\n                try {\n                    // Shared libraries for the package need to be updated.\n                    mSharedLibraries.updateSharedLibrariesLPw(pkg, pkgSetting, null, null,\n                            combinedSigningDetails);\n                } catch (PackageManagerException e) {\n                    Slog.e(TAG, \"updateSharedLibrariesLPr failed: \", e);\n                }\n                // Update all applications that use this library. Skip when booting\n                // since this will be done after all packages are scaned.\n                if ((scanFlags & SCAN_BOOTING) == 0) {\n                    clientLibPkgs = mSharedLibraries.updateAllSharedLibrariesLPw(pkg, pkgSetting,\n                            combinedSigningDetails);\n                }\n            }\n        }\n        if (reconciledPkg.mInstallResult != null) {\n            reconciledPkg.mInstallResult.mLibraryConsumers = clientLibPkgs;\n        }\n\n        if ((scanFlags & SCAN_BOOTING) != 0) {\n            // No apps can run during boot scan, so they don't need to be frozen\n        } else if ((scanFlags & SCAN_DONT_KILL_APP) != 0) {\n            // Caller asked to not kill app, so it's probably not frozen\n        } else if ((scanFlags & SCAN_IGNORE_FROZEN) != 0) {\n            // Caller asked us to ignore frozen check for some reason; they\n            // probably didn't know the package name\n        } else {\n            // We're doing major surgery on this package, so it better be frozen\n            // right now to keep it from launching\n            mPm.snapshotComputer().checkPackageFrozen(pkgName);\n        }\n\n        final boolean isReplace =\n                reconciledPkg.mPrepareResult != null && reconciledPkg.mPrepareResult.mReplace;\n        // Also need to kill any apps that are dependent on the library, except the case of\n        // installation of new version static shared library.\n        if (clientLibPkgs != null) {\n            if (pkg.getStaticSharedLibName() == null || isReplace) {\n                for (int i = 0; i < clientLibPkgs.size(); i++) {\n                    AndroidPackage clientPkg = clientLibPkgs.get(i);\n                    mPm.killApplication(clientPkg.getPackageName(),\n                            clientPkg.getUid(), \"update lib\");\n                }\n            }\n        }\n\n        // writer\n        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"updateSettings\");\n\n        synchronized (mPm.mLock) {\n            // We don't expect installation to fail beyond this point\n            // Add the new setting to mSettings\n            mPm.mSettings.insertPackageSettingLPw(pkgSetting, pkg);\n            // Add the new setting to mPackages\n            mPm.mPackages.put(pkg.getPackageName(), pkg);\n            if ((scanFlags & SCAN_AS_APK_IN_APEX) != 0) {\n                mApexManager.registerApkInApex(pkg);\n            }\n\n            // Add the package's KeySets to the global KeySetManagerService\n            KeySetManagerService ksms = mPm.mSettings.getKeySetManagerService();\n            ksms.addScannedPackageLPw(pkg);\n\n            final Computer snapshot = mPm.snapshotComputer();\n            mPm.mComponentResolver.addAllComponents(pkg, chatty, mPm.mSetupWizardPackage, snapshot);\n            mPm.mAppsFilter.addPackage(snapshot, pkgSetting, isReplace);\n            mPm.addAllPackageProperties(pkg);\n\n            if (oldPkgSetting == null || oldPkgSetting.getPkg() == null) {\n                mPm.mDomainVerificationManager.addPackage(pkgSetting);\n            } else {\n                mPm.mDomainVerificationManager.migrateState(oldPkgSetting, pkgSetting);\n            }\n\n            int collectionSize = ArrayUtils.size(pkg.getInstrumentations());\n            StringBuilder r = null;\n            int i;\n            for (i = 0; i < collectionSize; i++) {\n                ParsedInstrumentation a = pkg.getInstrumentations().get(i);\n                ComponentMutateUtils.setPackageName(a, pkg.getPackageName());\n                mPm.addInstrumentation(a.getComponentName(), a);\n                if (chatty) {\n                    if (r == null) {\n                        r = new StringBuilder(256);\n                    } else {\n                        r.append(' ');\n                    }\n                    r.append(a.getName());\n                }\n            }\n            if (r != null) {\n                if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, \"  Instrumentation: \" + r);\n            }\n\n            final List<String> protectedBroadcasts = pkg.getProtectedBroadcasts();\n            if (!protectedBroadcasts.isEmpty()) {\n                synchronized (mPm.mProtectedBroadcasts) {\n                    mPm.mProtectedBroadcasts.addAll(protectedBroadcasts);\n                }\n            }\n\n            mPm.mPermissionManager.onPackageAdded(pkg,\n                    (scanFlags & SCAN_AS_INSTANT_APP) != 0, oldPkg);\n        }\n\n        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n    }\n\n    public int installExistingPackageAsUser(@Nullable String packageName, @UserIdInt int userId,\n            @PackageManager.InstallFlags int installFlags,\n            @PackageManager.InstallReason int installReason,\n            @Nullable List<String> allowlistedRestrictedPermissions,\n            @Nullable IntentSender intentSender) {\n        if (DEBUG_INSTALL) {\n            Log.v(TAG, \"installExistingPackageAsUser package=\" + packageName + \" userId=\" + userId\n                    + \" installFlags=\" + installFlags + \" installReason=\" + installReason\n                    + \" allowlistedRestrictedPermissions=\" + allowlistedRestrictedPermissions);\n        }\n\n        final int callingUid = Binder.getCallingUid();\n        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.INSTALL_PACKAGES)\n                != PackageManager.PERMISSION_GRANTED\n                && mContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.INSTALL_EXISTING_PACKAGES)\n                != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"Neither user \" + callingUid + \" nor current process has \"\n                    + android.Manifest.permission.INSTALL_PACKAGES + \".\");\n        }\n        PackageSetting pkgSetting;\n        final Computer preLockSnapshot = mPm.snapshotComputer();\n        preLockSnapshot.enforceCrossUserPermission(callingUid, userId,\n                true /* requireFullPermission */, true /* checkShell */,\n                \"installExistingPackage for user \" + userId);\n        if (mPm.isUserRestricted(userId, UserManager.DISALLOW_INSTALL_APPS)) {\n            return PackageManager.INSTALL_FAILED_USER_RESTRICTED;\n        }\n\n        final long callingId = Binder.clearCallingIdentity();\n        try {\n            boolean installed = false;\n            final boolean instantApp =\n                    (installFlags & PackageManager.INSTALL_INSTANT_APP) != 0;\n            final boolean fullApp =\n                    (installFlags & PackageManager.INSTALL_FULL_APP) != 0;\n\n            // writer\n            synchronized (mPm.mLock) {\n                final Computer snapshot = mPm.snapshotComputer();\n                pkgSetting = mPm.mSettings.getPackageLPr(packageName);\n                if (pkgSetting == null) {\n                    return PackageManager.INSTALL_FAILED_INVALID_URI;\n                }\n                if (instantApp && (pkgSetting.isSystem() || pkgSetting.isUpdatedSystemApp())) {\n                    return PackageManager.INSTALL_FAILED_INVALID_URI;\n                }\n                if (!snapshot.canViewInstantApps(callingUid, UserHandle.getUserId(callingUid))) {\n                    // only allow the existing package to be used if it's installed as a full\n                    // application for at least one user\n                    boolean installAllowed = false;\n                    for (int checkUserId : mPm.mUserManager.getUserIds()) {\n                        installAllowed = !pkgSetting.getInstantApp(checkUserId);\n                        if (installAllowed) {\n                            break;\n                        }\n                    }\n                    if (!installAllowed) {\n                        return PackageManager.INSTALL_FAILED_INVALID_URI;\n                    }\n                }\n                if (!pkgSetting.getInstalled(userId)) {\n                    pkgSetting.setInstalled(true, userId);\n                    pkgSetting.setHidden(false, userId);\n                    pkgSetting.setInstallReason(installReason, userId);\n                    pkgSetting.setUninstallReason(PackageManager.UNINSTALL_REASON_UNKNOWN, userId);\n                    pkgSetting.setFirstInstallTime(System.currentTimeMillis(), userId);\n                    mPm.mSettings.writePackageRestrictionsLPr(userId);\n                    mPm.mSettings.writeKernelMappingLPr(pkgSetting);\n                    installed = true;\n                } else if (fullApp && pkgSetting.getInstantApp(userId)) {\n                    // upgrade app from instant to full; we don't allow app downgrade\n                    installed = true;\n                }\n                ScanPackageUtils.setInstantAppForUser(mPm.mInjector, pkgSetting, userId, instantApp,\n                        fullApp);\n            }\n\n            if (installed) {\n                if (pkgSetting.getPkg() != null) {\n                    final PermissionManagerServiceInternal.PackageInstalledParams.Builder\n                            permissionParamsBuilder =\n                            new PermissionManagerServiceInternal.PackageInstalledParams.Builder();\n                    if ((installFlags & PackageManager.INSTALL_ALL_WHITELIST_RESTRICTED_PERMISSIONS)\n                            != 0) {\n                        permissionParamsBuilder.setAllowlistedRestrictedPermissions(\n                                pkgSetting.getPkg().getRequestedPermissions());\n                    }\n                    mPm.mPermissionManager.onPackageInstalled(pkgSetting.getPkg(),\n                            Process.INVALID_UID /* previousAppId */,\n                            permissionParamsBuilder.build(), userId);\n\n                    synchronized (mPm.mInstallLock) {\n                        // We don't need to freeze for a brand new install\n                        mAppDataHelper.prepareAppDataAfterInstallLIF(pkgSetting.getPkg());\n                    }\n                }\n                mPm.sendPackageAddedForUser(mPm.snapshotComputer(), packageName, pkgSetting, userId,\n                        DataLoaderType.NONE);\n                synchronized (mPm.mLock) {\n                    mPm.updateSequenceNumberLP(pkgSetting, new int[]{ userId });\n                }\n                // start async restore with no post-install since we finish install here\n                PackageInstalledInfo res = new PackageInstalledInfo(\n                        PackageManager.INSTALL_SUCCEEDED);\n                res.mPkg = pkgSetting.getPkg();\n                res.mNewUsers = new int[]{ userId };\n\n                PostInstallData postInstallData =\n                        new PostInstallData(null, res, () -> {\n                            mPm.restorePermissionsAndUpdateRolesForNewUserInstall(packageName,\n                                    userId);\n                            if (intentSender != null) {\n                                onRestoreComplete(res.mReturnCode, mContext, intentSender);\n                            }\n                        });\n                restoreAndPostInstall(userId, res, postInstallData);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(callingId);\n        }\n\n        return PackageManager.INSTALL_SUCCEEDED;\n    }\n\n    private static void onRestoreComplete(int returnCode, Context context, IntentSender target) {\n        Intent fillIn = new Intent();\n        fillIn.putExtra(PackageInstaller.EXTRA_STATUS,\n                PackageManager.installStatusToPublicStatus(returnCode));\n        try {\n            final BroadcastOptions options = BroadcastOptions.makeBasic();\n            options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n            target.sendIntent(context, 0, fillIn, null /* onFinished*/, null /* handler */,\n                    null /* requiredPermission */, options.toBundle());\n        } catch (IntentSender.SendIntentException ignored) {\n        }\n    }\n\n    /** @param data Post-install is performed only if this is non-null. */\n    public void restoreAndPostInstall(\n            int userId, PackageInstalledInfo res, @Nullable PostInstallData data) {\n        if (DEBUG_INSTALL) {\n            Log.v(TAG, \"restoreAndPostInstall userId=\" + userId + \" package=\" + res.mPkg);\n        }\n\n        // A restore should be requested at this point if (a) the install\n        // succeeded, (b) the operation is not an update.\n        final boolean update = res.mRemovedInfo != null\n                && res.mRemovedInfo.mRemovedPackage != null;\n        boolean doRestore = !update && res.mPkg != null;\n\n        // Set up the post-install work request bookkeeping.  This will be used\n        // and cleaned up by the post-install event handling regardless of whether\n        // there's a restore pass performed.  Token values are >= 1.\n        int token;\n        if (mPm.mNextInstallToken < 0) mPm.mNextInstallToken = 1;\n        token = mPm.mNextInstallToken++;\n        if (data != null) {\n            mPm.mRunningInstalls.put(token, data);\n        } else if (DEBUG_INSTALL) {\n            Log.v(TAG, \"No post-install required for \" + token);\n        }\n\n        if (DEBUG_INSTALL) Log.v(TAG, \"+ starting restore round-trip \" + token);\n\n        if (res.mReturnCode == PackageManager.INSTALL_SUCCEEDED && doRestore) {\n            // Pass responsibility to the Backup Manager.  It will perform a\n            // restore if appropriate, then pass responsibility back to the\n            // Package Manager to run the post-install observer callbacks\n            // and broadcasts.\n            if (res.mFreezer != null) {\n                res.mFreezer.close();\n            }\n            doRestore = performBackupManagerRestore(userId, token, res);\n        }\n\n        // If this is an update to a package that might be potentially downgraded, then we\n        // need to check with the rollback manager whether there's any userdata that might\n        // need to be snapshotted or restored for the package.\n        //\n        // TODO(narayan): Get this working for cases where userId == UserHandle.USER_ALL.\n        if (res.mReturnCode == PackageManager.INSTALL_SUCCEEDED && !doRestore && update) {\n            doRestore = performRollbackManagerRestore(userId, token, res, data);\n        }\n\n        if (!doRestore) {\n            // No restore possible, or the Backup Manager was mysteriously not\n            // available -- just fire the post-install work request directly.\n            if (DEBUG_INSTALL) Log.v(TAG, \"No restore - queue post-install for \" + token);\n\n            Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, \"postInstall\", token);\n\n            Message msg = mPm.mHandler.obtainMessage(POST_INSTALL, token, 0);\n            mPm.mHandler.sendMessage(msg);\n        }\n    }\n\n    /**\n     * Perform Backup Manager restore for a given {@link PackageInstalledInfo}.\n     * Returns whether the restore successfully completed.\n     */\n    private boolean performBackupManagerRestore(int userId, int token, PackageInstalledInfo res) {\n        IBackupManager iBackupManager = mInjector.getIBackupManager();\n        if (iBackupManager != null) {\n            // For backwards compatibility as USER_ALL previously routed directly to USER_SYSTEM\n            // in the BackupManager. USER_ALL is used in compatibility tests.\n            if (userId == UserHandle.USER_ALL) {\n                userId = UserHandle.USER_SYSTEM;\n            }\n            if (DEBUG_INSTALL) {\n                Log.v(TAG, \"token \" + token + \" to BM for possible restore for user \" + userId);\n            }\n            Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, \"restore\", token);\n            try {\n                if (iBackupManager.isUserReadyForBackup(userId)) {\n                    iBackupManager.restoreAtInstallForUser(\n                            userId, res.mPkg.getPackageName(), token);\n                } else {\n                    Slog.w(TAG, \"User \" + userId + \" is not ready. Restore at install \"\n                            + \"didn't take place.\");\n                    return false;\n                }\n            } catch (RemoteException e) {\n                // can't happen; the backup manager is local\n            } catch (Exception e) {\n                Slog.e(TAG, \"Exception trying to enqueue restore\", e);\n                return false;\n            }\n        } else {\n            Slog.e(TAG, \"Backup Manager not found!\");\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Perform Rollback Manager restore for a given {@link PackageInstalledInfo}.\n     * Returns whether the restore successfully completed.\n     */\n    private boolean performRollbackManagerRestore(int userId, int token, PackageInstalledInfo res,\n            PostInstallData data) {\n        final String packageName = res.mPkg.getPackageName();\n        final int[] allUsers = mPm.mUserManager.getUserIds();\n        final int[] installedUsers;\n\n        final PackageSetting ps;\n        int appId = -1;\n        long ceDataInode = -1;\n        synchronized (mPm.mLock) {\n            ps = mPm.mSettings.getPackageLPr(packageName);\n            if (ps != null) {\n                appId = ps.getAppId();\n                ceDataInode = ps.getCeDataInode(userId);\n            }\n\n            // NOTE: We ignore the user specified in the InstallParam because we know this is\n            // an update, and hence need to restore data for all installed users.\n            installedUsers = ps.queryInstalledUsers(allUsers, true);\n        }\n\n        boolean doSnapshotOrRestore = data != null && data.args != null\n                && ((data.args.mInstallFlags & PackageManager.INSTALL_ENABLE_ROLLBACK) != 0\n                || (data.args.mInstallFlags & PackageManager.INSTALL_REQUEST_DOWNGRADE) != 0);\n\n        if (ps != null && doSnapshotOrRestore) {\n            final String seInfo = AndroidPackageUtils.getSeInfo(res.mPkg, ps);\n            final RollbackManagerInternal rollbackManager =\n                    mInjector.getLocalService(RollbackManagerInternal.class);\n            rollbackManager.snapshotAndRestoreUserData(packageName,\n                    UserHandle.toUserHandles(installedUsers), appId, ceDataInode, seInfo, token);\n            return true;\n        }\n        return false;\n    }\n\n    public void processInstallRequests(boolean success, List<InstallRequest> installRequests) {\n        List<InstallRequest> apexInstallRequests = new ArrayList<>();\n        List<InstallRequest> apkInstallRequests = new ArrayList<>();\n        for (InstallRequest request : installRequests) {\n            if ((request.mArgs.mInstallFlags & PackageManager.INSTALL_APEX) != 0) {\n                apexInstallRequests.add(request);\n            } else {\n                apkInstallRequests.add(request);\n            }\n        }\n        // Note: supporting multi package install of both APEXes and APKs might requir some\n        // thinking to ensure atomicity of the install.\n        if (!apexInstallRequests.isEmpty() && !apkInstallRequests.isEmpty()) {\n            // This should've been caught at the validation step, but for some reason wasn't.\n            throw new IllegalStateException(\n                    \"Attempted to do a multi package install of both APEXes and APKs\");\n        }\n        if (!apexInstallRequests.isEmpty()) {\n            if (success) {\n                // Since installApexPackages requires talking to external service (apexd), we\n                // schedule to run it async. Once it finishes, it will resume the install.\n                Thread t = new Thread(() -> installApexPackagesTraced(apexInstallRequests),\n                        \"installApexPackages\");\n                t.start();\n            } else {\n                // Non-staged APEX installation failed somewhere before\n                // processInstallRequestAsync. In that case just notify the observer about the\n                // failure.\n                InstallRequest request = apexInstallRequests.get(0);\n                mPm.notifyInstallObserver(request.mInstallResult,\n                        request.mArgs.mObserver);\n            }\n            return;\n        }\n        if (success) {\n            for (InstallRequest request : apkInstallRequests) {\n                request.mArgs.doPreInstall(request.mInstallResult.mReturnCode);\n            }\n            synchronized (mPm.mInstallLock) {\n                installPackagesTracedLI(apkInstallRequests);\n            }\n            for (InstallRequest request : apkInstallRequests) {\n                request.mArgs.doPostInstall(\n                        request.mInstallResult.mReturnCode, request.mInstallResult.mUid);\n            }\n        }\n        for (InstallRequest request : apkInstallRequests) {\n            restoreAndPostInstall(request.mArgs.mUser.getIdentifier(),\n                    request.mInstallResult,\n                    new PostInstallData(request.mArgs,\n                            request.mInstallResult, null));\n        }\n    }\n\n    private void installApexPackagesTraced(List<InstallRequest> requests) {\n        try {\n            Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"installApexPackages\");\n            installApexPackages(requests);\n        } finally {\n            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n        }\n    }\n\n    private void installApexPackages(List<InstallRequest> requests) {\n        if (requests.isEmpty()) {\n            return;\n        }\n        if (requests.size() != 1) {\n            throw new IllegalStateException(\n                    \"Only a non-staged install of a single APEX is supported\");\n        }\n        InstallRequest request = requests.get(0);\n        try {\n            // Should directory scanning logic be moved to ApexManager for better test coverage?\n            final File dir = request.mArgs.mOriginInfo.mResolvedFile;\n            final File[] apexes = dir.listFiles();\n            if (apexes == null) {\n                throw new PackageManagerException(INSTALL_FAILED_INTERNAL_ERROR,\n                        dir.getAbsolutePath() + \" is not a directory\");\n            }\n            if (apexes.length != 1) {\n                throw new PackageManagerException(INSTALL_FAILED_INTERNAL_ERROR,\n                        \"Expected exactly one .apex file under \" + dir.getAbsolutePath()\n                                + \" got: \" + apexes.length);\n            }\n            try (PackageParser2 packageParser = mPm.mInjector.getScanningPackageParser()) {\n                mApexManager.installPackage(apexes[0], packageParser);\n            }\n        } catch (PackageManagerException e) {\n            request.mInstallResult.setError(\"APEX installation failed\", e);\n        }\n        PackageManagerService.invalidatePackageInfoCache();\n        mPm.notifyInstallObserver(request.mInstallResult, request.mArgs.mObserver);\n    }\n\n    @GuardedBy(\"mPm.mInstallLock\")\n    private void installPackagesTracedLI(List<InstallRequest> requests) {\n        try {\n            Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"installPackages\");\n            installPackagesLI(requests);\n        } finally {\n            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n        }\n    }\n\n    /**\n     * Installs one or more packages atomically. This operation is broken up into four phases:\n     * <ul>\n     *     <li><b>Prepare</b>\n     *         <br/>Analyzes any current install state, parses the package and does initial\n     *         validation on it.</li>\n     *     <li><b>Scan</b>\n     *         <br/>Interrogates the parsed packages given the context collected in prepare.</li>\n     *     <li><b>Reconcile</b>\n     *         <br/>Validates scanned packages in the context of each other and the current system\n     *         state to ensure that the install will be successful.\n     *     <li><b>Commit</b>\n     *         <br/>Commits all scanned packages and updates system state. This is the only place\n     *         that system state may be modified in the install flow and all predictable errors\n     *         must be determined before this phase.</li>\n     * </ul>\n     *\n     * Failure at any phase will result in a full failure to install all packages.\n     */\n    @GuardedBy(\"mPm.mInstallLock\")\n    private void installPackagesLI(List<InstallRequest> requests) {\n        final Map<String, ScanResult> preparedScans = new ArrayMap<>(requests.size());\n        final Map<String, InstallArgs> installArgs = new ArrayMap<>(requests.size());\n        final Map<String, PackageInstalledInfo> installResults = new ArrayMap<>(requests.size());\n        final Map<String, PrepareResult> prepareResults = new ArrayMap<>(requests.size());\n        final Map<String, Settings.VersionInfo> versionInfos = new ArrayMap<>(requests.size());\n        final Map<String, Boolean> createdAppId = new ArrayMap<>(requests.size());\n        boolean success = false;\n        try {\n            Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"installPackagesLI\");\n            for (InstallRequest request : requests) {\n                // TODO(b/109941548): remove this once we've pulled everything from it and into\n                //                    scan, reconcile or commit.\n                final PrepareResult prepareResult;\n                try {\n                    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"preparePackage\");\n                    prepareResult =\n                            preparePackageLI(request.mArgs, request.mInstallResult);\n                } catch (PrepareFailure prepareFailure) {\n                    request.mInstallResult.setError(prepareFailure.error,\n                            prepareFailure.getMessage());\n                    request.mInstallResult.mOrigPackage = prepareFailure.mConflictingPackage;\n                    request.mInstallResult.mOrigPermission = prepareFailure.mConflictingPermission;\n                    return;\n                } finally {\n                    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n                }\n                request.mInstallResult.setReturnCode(PackageManager.INSTALL_SUCCEEDED);\n                request.mInstallResult.mInstallerPackageName =\n                        request.mArgs.mInstallSource.installerPackageName;\n\n                final String packageName = prepareResult.mPackageToScan.getPackageName();\n                prepareResults.put(packageName, prepareResult);\n                installResults.put(packageName, request.mInstallResult);\n                installArgs.put(packageName, request.mArgs);\n                try {\n                    final ScanResult result = scanPackageTracedLI(\n                            prepareResult.mPackageToScan, prepareResult.mParseFlags,\n                            prepareResult.mScanFlags, System.currentTimeMillis(),\n                            request.mArgs.mUser, request.mArgs.mAbiOverride);\n                    if (null != preparedScans.put(result.mPkgSetting.getPkg().getPackageName(),\n                            result)) {\n                        request.mInstallResult.setError(\n                                PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE,\n                                \"Duplicate package \"\n                                        + result.mPkgSetting.getPkg().getPackageName()\n                                        + \" in multi-package install request.\");\n                        return;\n                    }\n                    if (!checkNoAppStorageIsConsistent(\n                            result.mRequest.mOldPkg, result.mPkgSetting.getPkg())) {\n                        // TODO: INSTALL_FAILED_UPDATE_INCOMPATIBLE is about incomptabible\n                        //  signatures. Is there a better error code?\n                        request.mInstallResult.setError(\n                                INSTALL_FAILED_UPDATE_INCOMPATIBLE,\n                                \"Update attempted to change value of \"\n                                        + PackageManager.PROPERTY_NO_APP_DATA_STORAGE);\n                        return;\n                    }\n                    createdAppId.put(packageName, optimisticallyRegisterAppId(result));\n                    versionInfos.put(result.mPkgSetting.getPkg().getPackageName(),\n                            mPm.getSettingsVersionForPackage(result.mPkgSetting.getPkg()));\n                } catch (PackageManagerException e) {\n                    request.mInstallResult.setError(\"Scanning Failed.\", e);\n                    return;\n                }\n            }\n            ReconcileRequest reconcileRequest = new ReconcileRequest(preparedScans, installArgs,\n                    installResults, prepareResults,\n                    Collections.unmodifiableMap(mPm.mPackages), versionInfos);\n            CommitRequest commitRequest = null;\n            synchronized (mPm.mLock) {\n                Map<String, ReconciledPackage> reconciledPackages;\n                try {\n                    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"reconcilePackages\");\n                    reconciledPackages = ReconcilePackageUtils.reconcilePackages(\n                            reconcileRequest, mSharedLibraries,\n                            mPm.mSettings.getKeySetManagerService(), mPm.mSettings);\n                } catch (ReconcileFailure e) {\n                    for (InstallRequest request : requests) {\n                        request.mInstallResult.setError(\"Reconciliation failed...\", e);\n                    }\n                    return;\n                } finally {\n                    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n                }\n                try {\n                    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"commitPackages\");\n                    commitRequest = new CommitRequest(reconciledPackages,\n                            mPm.mUserManager.getUserIds());\n                    commitPackagesLocked(commitRequest);\n                    success = true;\n                } finally {\n                    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n                }\n            }\n            executePostCommitSteps(commitRequest);\n        } finally {\n            if (success) {\n                for (InstallRequest request : requests) {\n                    final InstallArgs args = request.mArgs;\n                    if (args.mDataLoaderType != DataLoaderType.INCREMENTAL) {\n                        continue;\n                    }\n                    if (args.mSigningDetails.getSignatureSchemeVersion() != SIGNING_BLOCK_V4) {\n                        continue;\n                    }\n                    // For incremental installs, we bypass the verifier prior to install. Now\n                    // that we know the package is valid, send a notice to the verifier with\n                    // the root hash of the base.apk.\n                    final String baseCodePath = request.mInstallResult.mPkg.getBaseApkPath();\n                    final String[] splitCodePaths = request.mInstallResult.mPkg.getSplitCodePaths();\n                    final Uri originUri = Uri.fromFile(args.mOriginInfo.mResolvedFile);\n                    final int verificationId = mPm.mPendingVerificationToken++;\n                    final String rootHashString = PackageManagerServiceUtils\n                            .buildVerificationRootHashString(baseCodePath, splitCodePaths);\n                    VerificationUtils.broadcastPackageVerified(verificationId, originUri,\n                            PackageManager.VERIFICATION_ALLOW, rootHashString,\n                            args.mDataLoaderType, args.getUser(), mContext);\n                }\n            } else {\n                for (ScanResult result : preparedScans.values()) {\n                    if (createdAppId.getOrDefault(result.mRequest.mParsedPackage.getPackageName(),\n                            false)) {\n                        cleanUpAppIdCreation(result);\n                    }\n                }\n                // TODO(b/194319951): create a more descriptive reason than unknown\n                // mark all non-failure installs as UNKNOWN so we do not treat them as success\n                for (InstallRequest request : requests) {\n                    if (request.mInstallResult.mFreezer != null) {\n                        request.mInstallResult.mFreezer.close();\n                    }\n                    if (request.mInstallResult.mReturnCode == PackageManager.INSTALL_SUCCEEDED) {\n                        request.mInstallResult.mReturnCode = PackageManager.INSTALL_UNKNOWN;\n                    }\n                }\n            }\n            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n        }\n    }\n\n    @GuardedBy(\"mPm.mInstallLock\")\n    private boolean checkNoAppStorageIsConsistent(AndroidPackage oldPkg, AndroidPackage newPkg) {\n        if (oldPkg == null) {\n            // New install, nothing to check against.\n            return true;\n        }\n        final PackageManager.Property curProp =\n                oldPkg.getProperties().get(PackageManager.PROPERTY_NO_APP_DATA_STORAGE);\n        final PackageManager.Property newProp =\n                newPkg.getProperties().get(PackageManager.PROPERTY_NO_APP_DATA_STORAGE);\n        if (curProp == null || !curProp.getBoolean()) {\n            return newProp == null || !newProp.getBoolean();\n        }\n        return newProp != null && newProp.getBoolean();\n    }\n\n    @GuardedBy(\"mPm.mInstallLock\")\n    private PrepareResult preparePackageLI(InstallArgs args, PackageInstalledInfo res)\n            throws PrepareFailure {\n        final int installFlags = args.mInstallFlags;\n        final File tmpPackageFile = new File(args.getCodePath());\n        final boolean onExternal = args.mVolumeUuid != null;\n        final boolean instantApp = ((installFlags & PackageManager.INSTALL_INSTANT_APP) != 0);\n        final boolean fullApp = ((installFlags & PackageManager.INSTALL_FULL_APP) != 0);\n        final boolean virtualPreload =\n                ((installFlags & PackageManager.INSTALL_VIRTUAL_PRELOAD) != 0);\n        final boolean isRollback = args.mInstallReason == PackageManager.INSTALL_REASON_ROLLBACK;\n        @PackageManagerService.ScanFlags int scanFlags = SCAN_NEW_INSTALL | SCAN_UPDATE_SIGNATURE;\n        if (args.mMoveInfo != null) {\n            // moving a complete application; perform an initial scan on the new install location\n            scanFlags |= SCAN_INITIAL;\n        }\n        if ((installFlags & PackageManager.INSTALL_DONT_KILL_APP) != 0) {\n            scanFlags |= SCAN_DONT_KILL_APP;\n        }\n        if (instantApp) {\n            scanFlags |= SCAN_AS_INSTANT_APP;\n        }\n        if (fullApp) {\n            scanFlags |= SCAN_AS_FULL_APP;\n        }\n        if (virtualPreload) {\n            scanFlags |= SCAN_AS_VIRTUAL_PRELOAD;\n        }\n\n        if (DEBUG_INSTALL) Slog.d(TAG, \"installPackageLI: path=\" + tmpPackageFile);\n\n        // Validity check\n        if (instantApp && onExternal) {\n            Slog.i(TAG, \"Incompatible ephemeral install; external=\" + onExternal);\n            throw new PrepareFailure(PackageManager.INSTALL_FAILED_SESSION_INVALID);\n        }\n\n        // Retrieve PackageSettings and parse package\n        @ParsingPackageUtils.ParseFlags final int parseFlags =\n                mPm.getDefParseFlags() | ParsingPackageUtils.PARSE_CHATTY\n                        | ParsingPackageUtils.PARSE_ENFORCE_CODE\n                        | (onExternal ? ParsingPackageUtils.PARSE_EXTERNAL_STORAGE : 0);\n\n        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"parsePackage\");\n        final ParsedPackage parsedPackage;\n        try (PackageParser2 pp = mPm.mInjector.getPreparingPackageParser()) {\n            parsedPackage = pp.parsePackage(tmpPackageFile, parseFlags, false);\n            AndroidPackageUtils.validatePackageDexMetadata(parsedPackage);\n        } catch (PackageManagerException e) {\n            throw new PrepareFailure(\"Failed parse during installPackageLI\", e);\n        } finally {\n            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n        }\n\n        // Instant apps have several additional install-time checks.\n        if (instantApp) {\n            if (parsedPackage.getTargetSdkVersion() < Build.VERSION_CODES.O) {\n                Slog.w(TAG, \"Instant app package \" + parsedPackage.getPackageName()\n                        + \" does not target at least O\");\n                throw new PrepareFailure(INSTALL_FAILED_SESSION_INVALID,\n                        \"Instant app package must target at least O\");\n            }\n            if (parsedPackage.getSharedUserId() != null) {\n                Slog.w(TAG, \"Instant app package \" + parsedPackage.getPackageName()\n                        + \" may not declare sharedUserId.\");\n                throw new PrepareFailure(INSTALL_FAILED_SESSION_INVALID,\n                        \"Instant app package may not declare a sharedUserId\");\n            }\n        }\n\n        if (parsedPackage.isStaticSharedLibrary()) {\n            // Static shared libraries have synthetic package names\n            PackageManagerService.renameStaticSharedLibraryPackage(parsedPackage);\n\n            // No static shared libs on external storage\n            if (onExternal) {\n                Slog.i(TAG, \"Static shared libs can only be installed on internal storage.\");\n                throw new PrepareFailure(INSTALL_FAILED_INVALID_INSTALL_LOCATION,\n                        \"Packages declaring static-shared libs cannot be updated\");\n            }\n        }\n\n        String pkgName = res.mName = parsedPackage.getPackageName();\n        if (parsedPackage.isTestOnly()) {\n            if ((installFlags & PackageManager.INSTALL_ALLOW_TEST) == 0) {\n                throw new PrepareFailure(INSTALL_FAILED_TEST_ONLY, \"installPackageLI\");\n            }\n        }\n\n        // either use what we've been given or parse directly from the APK\n        if (args.mSigningDetails != SigningDetails.UNKNOWN) {\n            parsedPackage.setSigningDetails(args.mSigningDetails);\n        } else {\n            final ParseTypeImpl input = ParseTypeImpl.forDefaultParsing();\n            final ParseResult<SigningDetails> result = ParsingPackageUtils.getSigningDetails(\n                    input, parsedPackage, false /*skipVerify*/);\n            if (result.isError()) {\n                throw new PrepareFailure(\"Failed collect during installPackageLI\",\n                        result.getException());\n            }\n            parsedPackage.setSigningDetails(result.getResult());\n        }\n\n        if (instantApp && parsedPackage.getSigningDetails().getSignatureSchemeVersion()\n                < SigningDetails.SignatureSchemeVersion.SIGNING_BLOCK_V2) {\n            Slog.w(TAG, \"Instant app package \" + parsedPackage.getPackageName()\n                    + \" is not signed with at least APK Signature Scheme v2\");\n            throw new PrepareFailure(INSTALL_FAILED_SESSION_INVALID,\n                    \"Instant app package must be signed with APK Signature Scheme v2 or greater\");\n        }\n\n        boolean systemApp = false;\n        boolean replace = false;\n        synchronized (mPm.mLock) {\n            // Check if installing already existing package\n            if ((installFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {\n                String oldName = mPm.mSettings.getRenamedPackageLPr(pkgName);\n                if (parsedPackage.getOriginalPackages().contains(oldName)\n                        && mPm.mPackages.containsKey(oldName)) {\n                    // This package is derived from an original package,\n                    // and this device has been updating from that original\n                    // name.  We must continue using the original name, so\n                    // rename the new package here.\n                    parsedPackage.setPackageName(oldName);\n                    pkgName = parsedPackage.getPackageName();\n                    replace = true;\n                    if (DEBUG_INSTALL) {\n                        Slog.d(TAG, \"Replacing existing renamed package: oldName=\"\n                                + oldName + \" pkgName=\" + pkgName);\n                    }\n                } else if (mPm.mPackages.containsKey(pkgName)) {\n                    // This package, under its official name, already exists\n                    // on the device; we should replace it.\n                    replace = true;\n                    if (DEBUG_INSTALL) Slog.d(TAG, \"Replace existing package: \" + pkgName);\n                }\n\n                if (replace) {\n                    // Prevent apps opting out from runtime permissions\n                    AndroidPackage oldPackage = mPm.mPackages.get(pkgName);\n                    final int oldTargetSdk = oldPackage.getTargetSdkVersion();\n                    final int newTargetSdk = parsedPackage.getTargetSdkVersion();\n                    if (oldTargetSdk > Build.VERSION_CODES.LOLLIPOP_MR1\n                            && newTargetSdk <= Build.VERSION_CODES.LOLLIPOP_MR1) {\n                        throw new PrepareFailure(\n                                PackageManager.INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE,\n                                \"Package \" + parsedPackage.getPackageName()\n                                        + \" new target SDK \" + newTargetSdk\n                                        + \" doesn't support runtime permissions but the old\"\n                                        + \" target SDK \" + oldTargetSdk + \" does.\");\n                    }\n                    // Prevent persistent apps from being updated\n                    if (oldPackage.isPersistent()\n                            && ((installFlags & PackageManager.INSTALL_STAGED) == 0)) {\n                        throw new PrepareFailure(PackageManager.INSTALL_FAILED_INVALID_APK,\n                                \"Package \" + oldPackage.getPackageName() + \" is a persistent app. \"\n                                        + \"Persistent apps are not updateable.\");\n                    }\n                }\n            }\n\n            PackageSetting ps = mPm.mSettings.getPackageLPr(pkgName);\n            PackageSetting signatureCheckPs = ps;\n\n            // SDK libs can have other major versions with different package names.\n            if (signatureCheckPs == null && parsedPackage.isSdkLibrary()) {\n                WatchedLongSparseArray<SharedLibraryInfo> libraryInfos =\n                        mSharedLibraries.getSharedLibraryInfos(\n                                parsedPackage.getSdkLibName());\n                if (libraryInfos != null && libraryInfos.size() > 0) {\n                    // Any existing version would do.\n                    SharedLibraryInfo libraryInfo = libraryInfos.valueAt(0);\n                    signatureCheckPs = mPm.mSettings.getPackageLPr(libraryInfo.getPackageName());\n                }\n            }\n\n            // Static shared libs have same package with different versions where\n            // we internally use a synthetic package name to allow multiple versions\n            // of the same package, therefore we need to compare signatures against\n            // the package setting for the latest library version.\n            if (parsedPackage.isStaticSharedLibrary()) {\n                SharedLibraryInfo libraryInfo =\n                        mSharedLibraries.getLatestStaticSharedLibraVersionLPr(parsedPackage);\n                if (libraryInfo != null) {\n                    signatureCheckPs = mPm.mSettings.getPackageLPr(libraryInfo.getPackageName());\n                }\n            }\n\n            if (signatureCheckPs != null) {\n                if (DEBUG_INSTALL) {\n                    Slog.d(TAG,\n                            \"Existing package for signature checking: \" + signatureCheckPs);\n                }\n\n                // Quick validity check that we're signed correctly if updating;\n                // we'll check this again later when scanning, but we want to\n                // bail early here before tripping over redefined permissions.\n                final KeySetManagerService ksms = mPm.mSettings.getKeySetManagerService();\n                final SharedUserSetting signatureCheckSus = mPm.mSettings.getSharedUserSettingLPr(\n                        signatureCheckPs);\n                if (ksms.shouldCheckUpgradeKeySetLocked(signatureCheckPs, signatureCheckSus,\n                        scanFlags)) {\n                    if (!ksms.checkUpgradeKeySetLocked(signatureCheckPs, parsedPackage)) {\n                        throw new PrepareFailure(INSTALL_FAILED_UPDATE_INCOMPATIBLE, \"Package \"\n                                + parsedPackage.getPackageName() + \" upgrade keys do not match the \"\n                                + \"previously installed version\");\n                    }\n                } else {\n                    try {\n                        final boolean compareCompat =\n                                ReconcilePackageUtils.isCompatSignatureUpdateNeeded(\n                                        mPm.getSettingsVersionForPackage(parsedPackage));\n                        final boolean compareRecover =\n                                ReconcilePackageUtils.isRecoverSignatureUpdateNeeded(\n                                        mPm.getSettingsVersionForPackage(parsedPackage));\n                        // We don't care about disabledPkgSetting on install for now.\n                        final boolean compatMatch =\n                                PackageManagerServiceUtils.verifySignatures(signatureCheckPs,\n                                        signatureCheckSus, null,\n                                parsedPackage.getSigningDetails(), compareCompat, compareRecover,\n                                isRollback);\n                        // The new KeySets will be re-added later in the scanning process.\n                        if (compatMatch) {\n                            synchronized (mPm.mLock) {\n                                ksms.removeAppKeySetDataLPw(parsedPackage.getPackageName());\n                            }\n                        }\n                    } catch (PackageManagerException e) {\n                        throw new PrepareFailure(e.error, e.getMessage());\n                    }\n                }\n            }\n\n            if (ps != null) {\n                if (DEBUG_INSTALL) Slog.d(TAG, \"Existing package: \" + ps);\n\n                if (ps.getPkg() != null) {\n                    systemApp = ps.getPkg().isSystem();\n                }\n                res.mOrigUsers = ps.queryInstalledUsers(mPm.mUserManager.getUserIds(), true);\n            }\n\n            final int numGroups = ArrayUtils.size(parsedPackage.getPermissionGroups());\n            for (int groupNum = 0; groupNum < numGroups; groupNum++) {\n                final ParsedPermissionGroup group =\n                        parsedPackage.getPermissionGroups().get(groupNum);\n                final PermissionGroupInfo sourceGroup = mPm.getPermissionGroupInfo(group.getName(),\n                        0);\n\n                if (sourceGroup != null && cannotInstallWithBadPermissionGroups(parsedPackage)) {\n                    final String sourcePackageName = sourceGroup.packageName;\n\n                    if ((replace || !parsedPackage.getPackageName().equals(sourcePackageName))\n                            && !doesSignatureMatchForPermissions(sourcePackageName, parsedPackage,\n                            scanFlags)) {\n                        EventLog.writeEvent(0x534e4554, \"146211400\", -1,\n                                parsedPackage.getPackageName());\n\n                        throw new PrepareFailure(INSTALL_FAILED_DUPLICATE_PERMISSION_GROUP,\n                                \"Package \"\n                                        + parsedPackage.getPackageName()\n                                        + \" attempting to redeclare permission group \"\n                                        + group.getName() + \" already owned by \"\n                                        + sourcePackageName);\n                    }\n                }\n            }\n\n            // TODO: Move logic for checking permission compatibility into PermissionManagerService\n            final int n = ArrayUtils.size(parsedPackage.getPermissions());\n            for (int i = n - 1; i >= 0; i--) {\n                final ParsedPermission perm = parsedPackage.getPermissions().get(i);\n                final Permission bp = mPm.mPermissionManager.getPermissionTEMP(perm.getName());\n\n                // Don't allow anyone but the system to define ephemeral permissions.\n                if ((perm.getProtectionLevel() & PermissionInfo.PROTECTION_FLAG_INSTANT) != 0\n                        && !systemApp) {\n                    Slog.w(TAG, \"Non-System package \" + parsedPackage.getPackageName()\n                            + \" attempting to delcare ephemeral permission \"\n                            + perm.getName() + \"; Removing ephemeral.\");\n                    ComponentMutateUtils.setProtectionLevel(perm,\n                            perm.getProtectionLevel() & ~PermissionInfo.PROTECTION_FLAG_INSTANT);\n                }\n\n                // Check whether the newly-scanned package wants to define an already-defined perm\n                if (bp != null) {\n                    final String sourcePackageName = bp.getPackageName();\n\n                    if (!doesSignatureMatchForPermissions(sourcePackageName, parsedPackage,\n                            scanFlags)) {\n                        // If the owning package is the system itself, we log but allow\n                        // install to proceed; we fail the install on all other permission\n                        // redefinitions.\n                        if (!sourcePackageName.equals(\"android\")) {\n                            throw new PrepareFailure(INSTALL_FAILED_DUPLICATE_PERMISSION,\n                                    \"Package \"\n                                            + parsedPackage.getPackageName()\n                                            + \" attempting to redeclare permission \"\n                                            + perm.getName() + \" already owned by \"\n                                            + sourcePackageName)\n                                    .conflictsWithExistingPermission(perm.getName(),\n                                            sourcePackageName);\n                        } else {\n                            Slog.w(TAG, \"Package \" + parsedPackage.getPackageName()\n                                    + \" attempting to redeclare system permission \"\n                                    + perm.getName() + \"; ignoring new declaration\");\n                            parsedPackage.removePermission(i);\n                        }\n                    } else if (!PLATFORM_PACKAGE_NAME.equals(parsedPackage.getPackageName())) {\n                        // Prevent apps to change protection level to dangerous from any other\n                        // type as this would allow a privilege escalation where an app adds a\n                        // normal/signature permission in other app's group and later redefines\n                        // it as dangerous leading to the group auto-grant.\n                        if ((perm.getProtectionLevel() & PermissionInfo.PROTECTION_MASK_BASE)\n                                == PermissionInfo.PROTECTION_DANGEROUS) {\n                            if (bp != null && !bp.isRuntime()) {\n                                Slog.w(TAG, \"Package \" + parsedPackage.getPackageName()\n                                        + \" trying to change a non-runtime permission \"\n                                        + perm.getName()\n                                        + \" to runtime; keeping old protection level\");\n                                ComponentMutateUtils.setProtectionLevel(perm,\n                                        bp.getProtectionLevel());\n                            }\n                        }\n                    }\n                }\n\n                if (perm.getGroup() != null\n                        && cannotInstallWithBadPermissionGroups(parsedPackage)) {\n                    boolean isPermGroupDefinedByPackage = false;\n                    for (int groupNum = 0; groupNum < numGroups; groupNum++) {\n                        if (parsedPackage.getPermissionGroups().get(groupNum).getName()\n                                .equals(perm.getGroup())) {\n                            isPermGroupDefinedByPackage = true;\n                            break;\n                        }\n                    }\n\n                    if (!isPermGroupDefinedByPackage) {\n                        final PermissionGroupInfo sourceGroup =\n                                mPm.getPermissionGroupInfo(perm.getGroup(), 0);\n\n                        if (sourceGroup == null) {\n                            EventLog.writeEvent(0x534e4554, \"146211400\", -1,\n                                    parsedPackage.getPackageName());\n\n                            throw new PrepareFailure(INSTALL_FAILED_BAD_PERMISSION_GROUP,\n                                    \"Package \"\n                                            + parsedPackage.getPackageName()\n                                            + \" attempting to declare permission \"\n                                            + perm.getName() + \" in non-existing group \"\n                                            + perm.getGroup());\n                        } else {\n                            String groupSourcePackageName = sourceGroup.packageName;\n\n                            if (!PLATFORM_PACKAGE_NAME.equals(groupSourcePackageName)\n                                    && !doesSignatureMatchForPermissions(groupSourcePackageName,\n                                    parsedPackage, scanFlags)) {\n                                EventLog.writeEvent(0x534e4554, \"146211400\", -1,\n                                        parsedPackage.getPackageName());\n\n                                throw new PrepareFailure(INSTALL_FAILED_BAD_PERMISSION_GROUP,\n                                        \"Package \"\n                                                + parsedPackage.getPackageName()\n                                                + \" attempting to declare permission \"\n                                                + perm.getName() + \" in group \"\n                                                + perm.getGroup() + \" owned by package \"\n                                                + groupSourcePackageName\n                                                + \" with incompatible certificate\");\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if (systemApp) {\n            if (onExternal) {\n                // Abort update; system app can't be replaced with app on sdcard\n                throw new PrepareFailure(INSTALL_FAILED_INVALID_INSTALL_LOCATION,\n                        \"Cannot install updates to system apps on sdcard\");\n            } else if (instantApp) {\n                // Abort update; system app can't be replaced with an instant app\n                throw new PrepareFailure(INSTALL_FAILED_SESSION_INVALID,\n                        \"Cannot update a system app with an instant app\");\n            }\n        }\n\n        if (args.mMoveInfo != null) {\n            // We did an in-place move, so dex is ready to roll\n            scanFlags |= SCAN_NO_DEX;\n            scanFlags |= SCAN_MOVE;\n\n            synchronized (mPm.mLock) {\n                final PackageSetting ps = mPm.mSettings.getPackageLPr(pkgName);\n                if (ps == null) {\n                    res.setError(INSTALL_FAILED_INTERNAL_ERROR,\n                            \"Missing settings for moved package \" + pkgName);\n                }\n\n                // We moved the entire application as-is, so bring over the\n                // previously derived ABI information.\n                parsedPackage.setPrimaryCpuAbi(ps.getPrimaryCpuAbi())\n                        .setSecondaryCpuAbi(ps.getSecondaryCpuAbi());\n            }\n\n        } else {\n            // Enable SCAN_NO_DEX flag to skip dexopt at a later stage\n            scanFlags |= SCAN_NO_DEX;\n\n            try {\n                PackageSetting pkgSetting;\n                AndroidPackage oldPackage;\n                synchronized (mPm.mLock) {\n                    pkgSetting = mPm.mSettings.getPackageLPr(pkgName);\n                    oldPackage = mPm.mPackages.get(pkgName);\n                }\n                boolean isUpdatedSystemAppFromExistingSetting = pkgSetting != null\n                        && pkgSetting.getPkgState().isUpdatedSystemApp();\n                final String abiOverride = deriveAbiOverride(args.mAbiOverride);\n                boolean isUpdatedSystemAppInferred = oldPackage != null && oldPackage.isSystem();\n                final Pair<PackageAbiHelper.Abis, PackageAbiHelper.NativeLibraryPaths>\n                        derivedAbi = mPackageAbiHelper.derivePackageAbi(parsedPackage,\n                        isUpdatedSystemAppFromExistingSetting || isUpdatedSystemAppInferred,\n                        abiOverride, ScanPackageUtils.getAppLib32InstallDir());\n                derivedAbi.first.applyTo(parsedPackage);\n                derivedAbi.second.applyTo(parsedPackage);\n            } catch (PackageManagerException pme) {\n                Slog.e(TAG, \"Error deriving application ABI\", pme);\n                throw new PrepareFailure(INSTALL_FAILED_INTERNAL_ERROR,\n                        \"Error deriving application ABI: \" + pme.getMessage());\n            }\n        }\n\n        if (!args.doRename(res.mReturnCode, parsedPackage)) {\n            throw new PrepareFailure(INSTALL_FAILED_INSUFFICIENT_STORAGE, \"Failed rename\");\n        }\n\n        try {\n            setUpFsVerityIfPossible(parsedPackage);\n        } catch (Installer.InstallerException | IOException | DigestException\n                | NoSuchAlgorithmException e) {\n            throw new PrepareFailure(INSTALL_FAILED_INTERNAL_ERROR,\n                    \"Failed to set up verity: \" + e);\n        }\n\n        final PackageFreezer freezer =\n                freezePackageForInstall(pkgName, installFlags, \"installPackageLI\");\n        boolean shouldCloseFreezerBeforeReturn = true;\n        try {\n            final AndroidPackage oldPackage;\n            String renamedPackage;\n            boolean sysPkg = false;\n            int targetScanFlags = scanFlags;\n            int targetParseFlags = parseFlags;\n            final PackageSetting ps;\n            final PackageSetting disabledPs;\n            final SharedUserSetting sharedUserSetting;\n            if (replace) {\n                final String pkgName11 = parsedPackage.getPackageName();\n                synchronized (mPm.mLock) {\n                    oldPackage = mPm.mPackages.get(pkgName11);\n                }\n                if (parsedPackage.isStaticSharedLibrary()) {\n                    // Static libs have a synthetic package name containing the version\n                    // and cannot be updated as an update would get a new package name,\n                    // unless this is installed from adb which is useful for development.\n                    if (oldPackage != null\n                            && (installFlags & PackageManager.INSTALL_FROM_ADB) == 0) {\n                        throw new PrepareFailure(INSTALL_FAILED_DUPLICATE_PACKAGE,\n                                \"Packages declaring \"\n                                        + \"static-shared libs cannot be updated\");\n                    }\n                }\n\n                final boolean isInstantApp = (scanFlags & SCAN_AS_INSTANT_APP) != 0;\n\n                final int[] allUsers;\n                final int[] installedUsers;\n                final int[] uninstalledUsers;\n\n                synchronized (mPm.mLock) {\n                    if (DEBUG_INSTALL) {\n                        Slog.d(TAG,\n                                \"replacePackageLI: new=\" + parsedPackage + \", old=\" + oldPackage);\n                    }\n\n                    ps = mPm.mSettings.getPackageLPr(pkgName11);\n                    disabledPs = mPm.mSettings.getDisabledSystemPkgLPr(ps);\n                    sharedUserSetting = mPm.mSettings.getSharedUserSettingLPr(ps);\n\n                    // verify signatures are valid\n                    final KeySetManagerService ksms = mPm.mSettings.getKeySetManagerService();\n                    if (ksms.shouldCheckUpgradeKeySetLocked(ps, sharedUserSetting, scanFlags)) {\n                        if (!ksms.checkUpgradeKeySetLocked(ps, parsedPackage)) {\n                            throw new PrepareFailure(INSTALL_FAILED_UPDATE_INCOMPATIBLE,\n                                    \"New package not signed by keys specified by upgrade-keysets: \"\n                                            + pkgName11);\n                        }\n                    } else {\n                        SigningDetails parsedPkgSigningDetails = parsedPackage.getSigningDetails();\n                        SigningDetails oldPkgSigningDetails = oldPackage.getSigningDetails();\n                        // default to original signature matching\n                        if (!parsedPkgSigningDetails.checkCapability(oldPkgSigningDetails,\n                                SigningDetails.CertCapabilities.INSTALLED_DATA)\n                                && !oldPkgSigningDetails.checkCapability(parsedPkgSigningDetails,\n                                SigningDetails.CertCapabilities.ROLLBACK)) {\n                            // Allow the update to proceed if this is a rollback and the parsed\n                            // package's current signing key is the current signer or in the lineage\n                            // of the old package; this allows a rollback to a previously installed\n                            // version after an app's signing key has been rotated without requiring\n                            // the rollback capability on the previous signing key.\n                            if (!isRollback || !oldPkgSigningDetails.hasAncestorOrSelf(\n                                    parsedPkgSigningDetails)) {\n                                throw new PrepareFailure(INSTALL_FAILED_UPDATE_INCOMPATIBLE,\n                                        \"New package has a different signature: \" + pkgName11);\n                            }\n                        }\n                    }\n\n                    // don't allow a system upgrade unless the upgrade hash matches\n                    if (oldPackage.getRestrictUpdateHash() != null && oldPackage.isSystem()) {\n                        final byte[] digestBytes;\n                        try {\n                            final MessageDigest digest = MessageDigest.getInstance(\"SHA-512\");\n                            updateDigest(digest, new File(parsedPackage.getBaseApkPath()));\n                            if (!ArrayUtils.isEmpty(parsedPackage.getSplitCodePaths())) {\n                                for (String path : parsedPackage.getSplitCodePaths()) {\n                                    updateDigest(digest, new File(path));\n                                }\n                            }\n                            digestBytes = digest.digest();\n                        } catch (NoSuchAlgorithmException | IOException e) {\n                            throw new PrepareFailure(INSTALL_FAILED_INVALID_APK,\n                                    \"Could not compute hash: \" + pkgName11);\n                        }\n                        if (!Arrays.equals(oldPackage.getRestrictUpdateHash(), digestBytes)) {\n                            throw new PrepareFailure(INSTALL_FAILED_INVALID_APK,\n                                    \"New package fails restrict-update check: \" + pkgName11);\n                        }\n                        // retain upgrade restriction\n                        parsedPackage.setRestrictUpdateHash(oldPackage.getRestrictUpdateHash());\n                    }\n\n                    // APK should not change its sharedUserId declarations\n                    final var oldSharedUid = oldPackage.getSharedUserId() != null\n                            ? oldPackage.getSharedUserId() : \"<nothing>\";\n                    final var newSharedUid = parsedPackage.getSharedUserId() != null\n                            ? parsedPackage.getSharedUserId() : \"<nothing>\";\n                    if (!oldSharedUid.equals(newSharedUid)) {\n                        throw new PrepareFailure(INSTALL_FAILED_UID_CHANGED,\n                                \"Package \" + parsedPackage.getPackageName()\n                                        + \" shared user changed from \"\n                                        + oldSharedUid + \" to \" + newSharedUid);\n                    }\n\n                    // APK should not re-join shared UID\n                    if (oldPackage.isLeavingSharedUid() && !parsedPackage.isLeavingSharedUid()) {\n                        throw new PrepareFailure(INSTALL_FAILED_UID_CHANGED,\n                                \"Package \" + parsedPackage.getPackageName()\n                                        + \" attempting to rejoin \" + newSharedUid);\n                    }\n\n                    // In case of rollback, remember per-user/profile install state\n                    allUsers = mPm.mUserManager.getUserIds();\n                    installedUsers = ps.queryInstalledUsers(allUsers, true);\n                    uninstalledUsers = ps.queryInstalledUsers(allUsers, false);\n\n\n                    // don't allow an upgrade from full to ephemeral\n                    if (isInstantApp) {\n                        if (args.mUser == null\n                                || args.mUser.getIdentifier() == UserHandle.USER_ALL) {\n                            for (int currentUser : allUsers) {\n                                if (!ps.getInstantApp(currentUser)) {\n                                    // can't downgrade from full to instant\n                                    Slog.w(TAG,\n                                            \"Can't replace full app with instant app: \" + pkgName11\n                                                    + \" for user: \" + currentUser);\n                                    throw new PrepareFailure(\n                                            PackageManager.INSTALL_FAILED_SESSION_INVALID);\n                                }\n                            }\n                        } else if (!ps.getInstantApp(args.mUser.getIdentifier())) {\n                            // can't downgrade from full to instant\n                            Slog.w(TAG, \"Can't replace full app with instant app: \" + pkgName11\n                                    + \" for user: \" + args.mUser.getIdentifier());\n                            throw new PrepareFailure(\n                                    PackageManager.INSTALL_FAILED_SESSION_INVALID);\n                        }\n                    }\n                }\n\n                // Update what is removed\n                res.mRemovedInfo = new PackageRemovedInfo(mPm);\n                res.mRemovedInfo.mUid = oldPackage.getUid();\n                res.mRemovedInfo.mRemovedPackage = oldPackage.getPackageName();\n                res.mRemovedInfo.mInstallerPackageName = ps.getInstallSource().installerPackageName;\n                res.mRemovedInfo.mIsStaticSharedLib =\n                        parsedPackage.getStaticSharedLibName() != null;\n                res.mRemovedInfo.mIsUpdate = true;\n                res.mRemovedInfo.mOrigUsers = installedUsers;\n                res.mRemovedInfo.mInstallReasons = new SparseArray<>(installedUsers.length);\n                for (int i = 0; i < installedUsers.length; i++) {\n                    final int userId = installedUsers[i];\n                    res.mRemovedInfo.mInstallReasons.put(userId, ps.getInstallReason(userId));\n                }\n                res.mRemovedInfo.mUninstallReasons = new SparseArray<>(uninstalledUsers.length);\n                for (int i = 0; i < uninstalledUsers.length; i++) {\n                    final int userId = uninstalledUsers[i];\n                    res.mRemovedInfo.mUninstallReasons.put(userId, ps.getUninstallReason(userId));\n                }\n                res.mRemovedInfo.mIsExternal = oldPackage.isExternalStorage();\n\n                sysPkg = oldPackage.isSystem();\n                if (sysPkg) {\n                    // Set the system/privileged/oem/vendor/product flags as needed\n                    final boolean privileged = oldPackage.isPrivileged();\n                    final boolean oem = oldPackage.isOem();\n                    final boolean vendor = oldPackage.isVendor();\n                    final boolean product = oldPackage.isProduct();\n                    final boolean odm = oldPackage.isOdm();\n                    final boolean systemExt = oldPackage.isSystemExt();\n                    final @ParsingPackageUtils.ParseFlags int systemParseFlags = parseFlags;\n                    final @PackageManagerService.ScanFlags int systemScanFlags = scanFlags\n                            | SCAN_AS_SYSTEM\n                            | (privileged ? SCAN_AS_PRIVILEGED : 0)\n                            | (oem ? SCAN_AS_OEM : 0)\n                            | (vendor ? SCAN_AS_VENDOR : 0)\n                            | (product ? SCAN_AS_PRODUCT : 0)\n                            | (odm ? SCAN_AS_ODM : 0)\n                            | (systemExt ? SCAN_AS_SYSTEM_EXT : 0);\n\n                    if (DEBUG_INSTALL) {\n                        Slog.d(TAG, \"replaceSystemPackageLI: new=\" + parsedPackage\n                                + \", old=\" + oldPackage);\n                    }\n                    res.setReturnCode(PackageManager.INSTALL_SUCCEEDED);\n                    targetParseFlags = systemParseFlags;\n                    targetScanFlags = systemScanFlags;\n                } else { // non system replace\n                    replace = true;\n                    if (DEBUG_INSTALL) {\n                        Slog.d(TAG,\n                                \"replaceNonSystemPackageLI: new=\" + parsedPackage + \", old=\"\n                                        + oldPackage);\n                    }\n                }\n            } else { // new package install\n                ps = null;\n                disabledPs = null;\n                replace = false;\n                oldPackage = null;\n                // Remember this for later, in case we need to rollback this install\n                String pkgName1 = parsedPackage.getPackageName();\n\n                if (DEBUG_INSTALL) Slog.d(TAG, \"installNewPackageLI: \" + parsedPackage);\n\n                // TODO(b/194319951): MOVE TO RECONCILE\n                synchronized (mPm.mLock) {\n                    renamedPackage = mPm.mSettings.getRenamedPackageLPr(pkgName1);\n                    if (renamedPackage != null) {\n                        // A package with the same name is already installed, though\n                        // it has been renamed to an older name.  The package we\n                        // are trying to install should be installed as an update to\n                        // the existing one, but that has not been requested, so bail.\n                        throw new PrepareFailure(INSTALL_FAILED_ALREADY_EXISTS,\n                                \"Attempt to re-install \" + pkgName1\n                                        + \" without first uninstalling package running as \"\n                                        + renamedPackage);\n                    }\n                    if (mPm.mPackages.containsKey(pkgName1)) {\n                        // Don't allow installation over an existing package with the same name.\n                        throw new PrepareFailure(INSTALL_FAILED_ALREADY_EXISTS,\n                                \"Attempt to re-install \" + pkgName1\n                                        + \" without first uninstalling.\");\n                    }\n                }\n            }\n            // we're passing the freezer back to be closed in a later phase of install\n            shouldCloseFreezerBeforeReturn = false;\n\n            return new PrepareResult(replace, targetScanFlags, targetParseFlags,\n                    oldPackage, parsedPackage, replace /* clearCodeCache */, sysPkg,\n                    ps, disabledPs);\n        } finally {\n            res.mFreezer = freezer;\n            if (shouldCloseFreezerBeforeReturn) {\n                freezer.close();\n            }\n        }\n    }\n\n    /*\n     * Cannot properly check CANNOT_INSTALL_WITH_BAD_PERMISSION_GROUPS using CompatChanges\n     * as this only works for packages that are installed\n     *\n     * TODO: Move logic for permission group compatibility into PermissionManagerService\n     */\n    @SuppressWarnings(\"AndroidFrameworkCompatChange\")\n    private static boolean cannotInstallWithBadPermissionGroups(ParsedPackage parsedPackage) {\n        return parsedPackage.getTargetSdkVersion() >= Build.VERSION_CODES.S;\n    }\n\n    private boolean doesSignatureMatchForPermissions(@NonNull String sourcePackageName,\n            @NonNull ParsedPackage parsedPackage, int scanFlags) {\n        // If the defining package is signed with our cert, it's okay.  This\n        // also includes the \"updating the same package\" case, of course.\n        // \"updating same package\" could also involve key-rotation.\n\n        final PackageSetting sourcePackageSetting;\n        final KeySetManagerService ksms;\n        final SharedUserSetting sharedUserSetting;\n        synchronized (mPm.mLock) {\n            sourcePackageSetting = mPm.mSettings.getPackageLPr(sourcePackageName);\n            ksms = mPm.mSettings.getKeySetManagerService();\n            sharedUserSetting = mPm.mSettings.getSharedUserSettingLPr(sourcePackageSetting);\n        }\n\n        final SigningDetails sourceSigningDetails = (sourcePackageSetting == null\n                ? SigningDetails.UNKNOWN : sourcePackageSetting.getSigningDetails());\n        if (sourcePackageName.equals(parsedPackage.getPackageName())\n                && (ksms.shouldCheckUpgradeKeySetLocked(\n                        sourcePackageSetting, sharedUserSetting, scanFlags))) {\n            return ksms.checkUpgradeKeySetLocked(sourcePackageSetting, parsedPackage);\n        } else {\n\n            // in the event of signing certificate rotation, we need to see if the\n            // package's certificate has rotated from the current one, or if it is an\n            // older certificate with which the current is ok with sharing permissions\n            if (sourceSigningDetails.checkCapability(\n                    parsedPackage.getSigningDetails(),\n                    SigningDetails.CertCapabilities.PERMISSION)) {\n                return true;\n            } else if (parsedPackage.getSigningDetails().checkCapability(\n                    sourceSigningDetails,\n                    SigningDetails.CertCapabilities.PERMISSION)) {\n                // the scanned package checks out, has signing certificate rotation\n                // history, and is newer; bring it over\n                synchronized (mPm.mLock) {\n                    sourcePackageSetting.setSigningDetails(parsedPackage.getSigningDetails());\n                }\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }\n\n    /**\n     * Set up fs-verity for the given package if possible.  This requires a feature flag of system\n     * property to be enabled only if the kernel supports fs-verity.\n     *\n     * <p>When the feature flag is set to legacy mode, only APK is supported (with some experimental\n     * kernel patches). In normal mode, all file format can be supported.\n     */\n    private void setUpFsVerityIfPossible(AndroidPackage pkg) throws Installer.InstallerException,\n            PrepareFailure, IOException, DigestException, NoSuchAlgorithmException {\n        if (!PackageManagerServiceUtils.isApkVerityEnabled()) {\n            return;\n        }\n\n        if (isIncrementalPath(pkg.getPath()) && IncrementalManager.getVersion()\n                < IncrementalManager.MIN_VERSION_TO_SUPPORT_FSVERITY) {\n            return;\n        }\n\n        // Collect files we care for fs-verity setup.\n        ArrayMap<String, String> fsverityCandidates = new ArrayMap<>();\n        // NB: These files will become only accessible if the signing key is loaded in kernel's\n        // .fs-verity keyring.\n        fsverityCandidates.put(pkg.getBaseApkPath(),\n                VerityUtils.getFsveritySignatureFilePath(pkg.getBaseApkPath()));\n\n        final String dmPath = DexMetadataHelper.buildDexMetadataPathForApk(\n                pkg.getBaseApkPath());\n        if (new File(dmPath).exists()) {\n            fsverityCandidates.put(dmPath, VerityUtils.getFsveritySignatureFilePath(dmPath));\n        }\n\n        for (String path : pkg.getSplitCodePaths()) {\n            fsverityCandidates.put(path, VerityUtils.getFsveritySignatureFilePath(path));\n\n            final String splitDmPath = DexMetadataHelper.buildDexMetadataPathForApk(path);\n            if (new File(splitDmPath).exists()) {\n                fsverityCandidates.put(splitDmPath,\n                        VerityUtils.getFsveritySignatureFilePath(splitDmPath));\n            }\n        }\n\n        final String packageName = pkg.getPackageName();\n        for (Map.Entry<String, String> entry : fsverityCandidates.entrySet()) {\n            final String filePath = entry.getKey();\n            final String signaturePath = entry.getValue();\n\n            // fs-verity is optional for now.  Only set up if signature is provided.\n            if (new File(signaturePath).exists() && !VerityUtils.hasFsverity(filePath)) {\n                try {\n                    VerityUtils.setUpFsverity(filePath, signaturePath);\n                } catch (IOException e) {\n                    throw new PrepareFailure(PackageManager.INSTALL_FAILED_BAD_SIGNATURE,\n                            \"Failed to enable fs-verity: \" + e);\n                }\n            }\n        }\n    }\n\n    private PackageFreezer freezePackageForInstall(String packageName, int installFlags,\n            String killReason) {\n        return freezePackageForInstall(packageName, UserHandle.USER_ALL, installFlags, killReason);\n    }\n\n    private PackageFreezer freezePackageForInstall(String packageName, int userId, int installFlags,\n            String killReason) {\n        if ((installFlags & PackageManager.INSTALL_DONT_KILL_APP) != 0) {\n            return new PackageFreezer(mPm);\n        } else {\n            return mPm.freezePackage(packageName, userId, killReason);\n        }\n    }\n\n    private static void updateDigest(MessageDigest digest, File file) throws IOException {\n        try (DigestInputStream digestStream =\n                     new DigestInputStream(new FileInputStream(file), digest)) {\n            int length, total = 0;\n            while ((length = digestStream.read()) != -1) {\n                total += length;\n            } // just plow through the file\n        }\n    }\n\n    @GuardedBy(\"mPm.mLock\")\n    private void commitPackagesLocked(final CommitRequest request) {\n        // TODO: remove any expected failures from this method; this should only be able to fail due\n        //       to unavoidable errors (I/O, etc.)\n        for (ReconciledPackage reconciledPkg : request.mReconciledPackages.values()) {\n            final ScanResult scanResult = reconciledPkg.mScanResult;\n            final ScanRequest scanRequest = scanResult.mRequest;\n            final ParsedPackage parsedPackage = scanRequest.mParsedPackage;\n            final String packageName = parsedPackage.getPackageName();\n            final PackageInstalledInfo res = reconciledPkg.mInstallResult;\n            final RemovePackageHelper removePackageHelper = new RemovePackageHelper(mPm);\n            final DeletePackageHelper deletePackageHelper = new DeletePackageHelper(mPm);\n\n            if (reconciledPkg.mPrepareResult.mReplace) {\n                AndroidPackage oldPackage = mPm.mPackages.get(packageName);\n\n                // Set the update and install times\n                PackageStateInternal deletedPkgSetting = mPm.snapshotComputer()\n                        .getPackageStateInternal(oldPackage.getPackageName());\n                reconciledPkg.mPkgSetting\n                        .setFirstInstallTimeFromReplaced(deletedPkgSetting, request.mAllUsers)\n                        .setLastUpdateTime(System.currentTimeMillis());\n\n                res.mRemovedInfo.mBroadcastAllowList = mPm.mAppsFilter.getVisibilityAllowList(\n                        mPm.snapshotComputer(), reconciledPkg.mPkgSetting, request.mAllUsers,\n                        mPm.mSettings.getPackagesLocked());\n                if (reconciledPkg.mPrepareResult.mSystem) {\n                    // Remove existing system package\n                    removePackageHelper.removePackageLI(oldPackage, true);\n                    if (!disableSystemPackageLPw(oldPackage)) {\n                        // We didn't need to disable the .apk as a current system package,\n                        // which means we are replacing another update that is already\n                        // installed.  We need to make sure to delete the older one's .apk.\n                        res.mRemovedInfo.mArgs = new FileInstallArgs(\n                                oldPackage.getPath(),\n                                getAppDexInstructionSets(\n                                        AndroidPackageUtils.getPrimaryCpuAbi(oldPackage,\n                                                deletedPkgSetting),\n                                        AndroidPackageUtils.getSecondaryCpuAbi(oldPackage,\n                                                deletedPkgSetting)), mPm);\n                    } else {\n                        res.mRemovedInfo.mArgs = null;\n                    }\n                } else {\n                    try {\n                        // Settings will be written during the call to updateSettingsLI().\n                        deletePackageHelper.executeDeletePackageLIF(\n                                reconciledPkg.mDeletePackageAction, packageName,\n                                true, request.mAllUsers, false);\n                    } catch (SystemDeleteException e) {\n                        if (mPm.mIsEngBuild) {\n                            throw new RuntimeException(\"Unexpected failure\", e);\n                            // ignore; not possible for non-system app\n                        }\n                    }\n                    // Successfully deleted the old package; proceed with replace.\n                    // Update the in-memory copy of the previous code paths.\n                    PackageSetting ps1 = mPm.mSettings.getPackageLPr(\n                            reconciledPkg.mPrepareResult.mExistingPackage.getPackageName());\n                    if ((reconciledPkg.mInstallArgs.mInstallFlags & PackageManager.DONT_KILL_APP)\n                            == 0) {\n                        Set<String> oldCodePaths = ps1.getOldCodePaths();\n                        if (oldCodePaths == null) {\n                            oldCodePaths = new ArraySet<>();\n                        }\n                        Collections.addAll(oldCodePaths, oldPackage.getBaseApkPath());\n                        Collections.addAll(oldCodePaths, oldPackage.getSplitCodePaths());\n                        ps1.setOldCodePaths(oldCodePaths);\n                    } else {\n                        ps1.setOldCodePaths(null);\n                    }\n\n                    if (reconciledPkg.mInstallResult.mReturnCode\n                            == PackageManager.INSTALL_SUCCEEDED) {\n                        PackageSetting ps2 = mPm.mSettings.getPackageLPr(\n                                parsedPackage.getPackageName());\n                        if (ps2 != null) {\n                            res.mRemovedInfo.mRemovedForAllUsers =\n                                    mPm.mPackages.get(ps2.getPackageName()) == null;\n                        }\n                    }\n                }\n            }\n\n            AndroidPackage pkg = commitReconciledScanResultLocked(\n                    reconciledPkg, request.mAllUsers);\n            updateSettingsLI(pkg, reconciledPkg, request.mAllUsers, res);\n\n            final PackageSetting ps = mPm.mSettings.getPackageLPr(packageName);\n            if (ps != null) {\n                res.mNewUsers = ps.queryInstalledUsers(mPm.mUserManager.getUserIds(), true);\n                ps.setUpdateAvailable(false /*updateAvailable*/);\n            }\n            if (res.mReturnCode == PackageManager.INSTALL_SUCCEEDED) {\n                mPm.updateSequenceNumberLP(ps, res.mNewUsers);\n                mPm.updateInstantAppInstallerLocked(packageName);\n            }\n        }\n        ApplicationPackageManager.invalidateGetPackagesForUidCache();\n    }\n\n    @GuardedBy(\"mPm.mLock\")\n    private boolean disableSystemPackageLPw(AndroidPackage oldPkg) {\n        return mPm.mSettings.disableSystemPackageLPw(oldPkg.getPackageName(), true);\n    }\n\n    private void updateSettingsLI(AndroidPackage newPackage, ReconciledPackage reconciledPkg,\n            int[] allUsers, PackageInstalledInfo res) {\n        updateSettingsInternalLI(newPackage, reconciledPkg, allUsers, res);\n    }\n\n    private void updateSettingsInternalLI(AndroidPackage pkg, ReconciledPackage reconciledPkg,\n            int[] allUsers, PackageInstalledInfo res) {\n        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"updateSettings\");\n\n        final String pkgName = pkg.getPackageName();\n        final int[] installedForUsers = res.mOrigUsers;\n        final InstallArgs installArgs = reconciledPkg.mInstallArgs;\n        final int installReason = installArgs.mInstallReason;\n        InstallSource installSource = installArgs.mInstallSource;\n        final String installerPackageName = installSource.installerPackageName;\n\n        if (DEBUG_INSTALL) Slog.d(TAG, \"New package installed in \" + pkg.getPath());\n        synchronized (mPm.mLock) {\n            // For system-bundled packages, we assume that installing an upgraded version\n            // of the package implies that the user actually wants to run that new code,\n            // so we enable the package.\n            final PackageSetting ps = mPm.mSettings.getPackageLPr(pkgName);\n            final int userId = installArgs.mUser.getIdentifier();\n            if (ps != null) {\n                if (pkg.isSystem()) {\n                    if (DEBUG_INSTALL) {\n                        Slog.d(TAG, \"Implicitly enabling system package on upgrade: \" + pkgName);\n                    }\n                    // Enable system package for requested users\n                    if (res.mOrigUsers != null) {\n                        for (int origUserId : res.mOrigUsers) {\n                            if (userId == UserHandle.USER_ALL || userId == origUserId) {\n                                ps.setEnabled(COMPONENT_ENABLED_STATE_DEFAULT,\n                                        origUserId, installerPackageName);\n                            }\n                        }\n                    }\n                    // Also convey the prior install/uninstall state\n                    if (allUsers != null && installedForUsers != null) {\n                        for (int currentUserId : allUsers) {\n                            final boolean installed = ArrayUtils.contains(\n                                    installedForUsers, currentUserId);\n                            if (DEBUG_INSTALL) {\n                                Slog.d(TAG, \"    user \" + currentUserId + \" => \" + installed);\n                            }\n                            ps.setInstalled(installed, currentUserId);\n                        }\n                        // these install state changes will be persisted in the\n                        // upcoming call to mSettings.writeLPr().\n                    }\n\n                    if (allUsers != null) {\n                        for (int currentUserId : allUsers) {\n                            ps.resetOverrideComponentLabelIcon(currentUserId);\n                        }\n                    }\n                }\n\n                // Retrieve the overlays for shared libraries of the package.\n                if (!ps.getPkgState().getUsesLibraryInfos().isEmpty()) {\n                    for (SharedLibraryInfo sharedLib : ps.getPkgState().getUsesLibraryInfos()) {\n                        for (int currentUserId : UserManagerService.getInstance().getUserIds()) {\n                            if (!sharedLib.isDynamic()) {\n                                // TODO(146804378): Support overlaying static shared libraries\n                                continue;\n                            }\n                            final PackageSetting libPs = mPm.mSettings.getPackageLPr(\n                                    sharedLib.getPackageName());\n                            if (libPs == null) {\n                                continue;\n                            }\n                            ps.setOverlayPathsForLibrary(sharedLib.getName(),\n                                    libPs.getOverlayPaths(currentUserId), currentUserId);\n                        }\n                    }\n                }\n\n                if (userId != UserHandle.USER_ALL) {\n                    // It's implied that when a user requests installation, they want the app to\n                    // be installed and enabled.\n                    ps.setInstalled(true, userId);\n                    ps.setEnabled(COMPONENT_ENABLED_STATE_DEFAULT, userId, installerPackageName);\n                } else if (allUsers != null) {\n                    // The caller explicitly specified INSTALL_ALL_USERS flag.\n                    // Thus, updating the settings to install the app for all users.\n                    for (int currentUserId : allUsers) {\n                        // If the app is already installed for the currentUser,\n                        // keep it as installed as we might be updating the app at this place.\n                        // If not currently installed, check if the currentUser is restricted by\n                        // DISALLOW_INSTALL_APPS or DISALLOW_DEBUGGING_FEATURES device policy.\n                        // Install / update the app if the user isn't restricted. Skip otherwise.\n                        final boolean installedForCurrentUser = ArrayUtils.contains(\n                                installedForUsers, currentUserId);\n                        final boolean restrictedByPolicy =\n                                mPm.isUserRestricted(currentUserId,\n                                        UserManager.DISALLOW_INSTALL_APPS)\n                                || mPm.isUserRestricted(currentUserId,\n                                        UserManager.DISALLOW_DEBUGGING_FEATURES);\n                        if (installedForCurrentUser || !restrictedByPolicy) {\n                            ps.setInstalled(true, currentUserId);\n                            ps.setEnabled(COMPONENT_ENABLED_STATE_DEFAULT, currentUserId,\n                                installerPackageName);\n                        } else {\n                            ps.setInstalled(false, currentUserId);\n                        }\n                    }\n                }\n\n                mPm.mSettings.addInstallerPackageNames(ps.getInstallSource());\n\n                // When replacing an existing package, preserve the original install reason for all\n                // users that had the package installed before. Similarly for uninstall reasons.\n                final Set<Integer> previousUserIds = new ArraySet<>();\n                if (res.mRemovedInfo != null && res.mRemovedInfo.mInstallReasons != null) {\n                    final int installReasonCount = res.mRemovedInfo.mInstallReasons.size();\n                    for (int i = 0; i < installReasonCount; i++) {\n                        final int previousUserId = res.mRemovedInfo.mInstallReasons.keyAt(i);\n                        final int previousInstallReason =\n                                res.mRemovedInfo.mInstallReasons.valueAt(i);\n                        ps.setInstallReason(previousInstallReason, previousUserId);\n                        previousUserIds.add(previousUserId);\n                    }\n                }\n                if (res.mRemovedInfo != null && res.mRemovedInfo.mUninstallReasons != null) {\n                    for (int i = 0; i < res.mRemovedInfo.mUninstallReasons.size(); i++) {\n                        final int previousUserId = res.mRemovedInfo.mUninstallReasons.keyAt(i);\n                        final int previousReason = res.mRemovedInfo.mUninstallReasons.valueAt(i);\n                        ps.setUninstallReason(previousReason, previousUserId);\n                    }\n                }\n\n                // Set install reason for users that are having the package newly installed.\n                final int[] allUsersList = mPm.mUserManager.getUserIds();\n                if (userId == UserHandle.USER_ALL) {\n                    for (int currentUserId : allUsersList) {\n                        if (!previousUserIds.contains(currentUserId)\n                                && ps.getInstalled(currentUserId)) {\n                            ps.setInstallReason(installReason, currentUserId);\n                        }\n                    }\n                } else if (!previousUserIds.contains(userId)) {\n                    ps.setInstallReason(installReason, userId);\n                }\n\n                // TODO(b/169721400): generalize Incremental States and create a Callback object\n                // that can be used for all the packages.\n                final String codePath = ps.getPathString();\n                if (IncrementalManager.isIncrementalPath(codePath)\n                        && mIncrementalManager != null) {\n                    mIncrementalManager.registerLoadingProgressCallback(codePath,\n                            new IncrementalProgressListener(ps.getPackageName(), mPm));\n                }\n\n                // Ensure that the uninstall reason is UNKNOWN for users with the package installed.\n                for (int currentUserId : allUsersList) {\n                    if (ps.getInstalled(currentUserId)) {\n                        ps.setUninstallReason(UNINSTALL_REASON_UNKNOWN, currentUserId);\n                    }\n                }\n\n                mPm.mSettings.writeKernelMappingLPr(ps);\n\n                final PermissionManagerServiceInternal.PackageInstalledParams.Builder\n                        permissionParamsBuilder =\n                        new PermissionManagerServiceInternal.PackageInstalledParams.Builder();\n                final boolean grantPermissions = (installArgs.mInstallFlags\n                        & PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0;\n                if (grantPermissions) {\n                    final List<String> grantedPermissions =\n                            installArgs.mInstallGrantPermissions != null\n                                    ? Arrays.asList(installArgs.mInstallGrantPermissions)\n                                    : pkg.getRequestedPermissions();\n                    permissionParamsBuilder.setGrantedPermissions(grantedPermissions);\n                }\n                final boolean allowlistAllRestrictedPermissions =\n                        (installArgs.mInstallFlags\n                                & PackageManager.INSTALL_ALL_WHITELIST_RESTRICTED_PERMISSIONS) != 0;\n                final List<String> allowlistedRestrictedPermissions =\n                        allowlistAllRestrictedPermissions ? pkg.getRequestedPermissions()\n                                : installArgs.mAllowlistedRestrictedPermissions;\n                if (allowlistedRestrictedPermissions != null) {\n                    permissionParamsBuilder.setAllowlistedRestrictedPermissions(\n                            allowlistedRestrictedPermissions);\n                }\n                final int autoRevokePermissionsMode = installArgs.mAutoRevokePermissionsMode;\n                permissionParamsBuilder.setAutoRevokePermissionsMode(autoRevokePermissionsMode);\n                final ScanResult scanResult = reconciledPkg.mScanResult;\n                mPm.mPermissionManager.onPackageInstalled(pkg, scanResult.mPreviousAppId,\n                        permissionParamsBuilder.build(), userId);\n                // Apply restricted settings on potentially dangerous packages.\n                if (installArgs.mPackageSource == PackageInstaller.PACKAGE_SOURCE_LOCAL_FILE\n                        || installArgs.mPackageSource\n                        == PackageInstaller.PACKAGE_SOURCE_DOWNLOADED_FILE) {\n                    enableRestrictedSettings(pkgName, pkg.getUid());\n                }\n            }\n            res.mName = pkgName;\n            res.mUid = pkg.getUid();\n            res.mPkg = pkg;\n            res.setReturnCode(PackageManager.INSTALL_SUCCEEDED);\n            //to update install status\n            Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"writeSettings\");\n            mPm.writeSettingsLPrTEMP();\n            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n        }\n\n        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n    }\n\n    private void enableRestrictedSettings(String pkgName, int appId) {\n        final AppOpsManager appOpsManager = mPm.mContext.getSystemService(AppOpsManager.class);\n        final int[] allUsersList = mPm.mUserManager.getUserIds();\n        for (int userId : allUsersList) {\n            final int uid = UserHandle.getUid(userId, appId);\n            appOpsManager.setMode(AppOpsManager.OP_ACCESS_RESTRICTED_SETTINGS,\n                    uid,\n                    pkgName,\n                    AppOpsManager.MODE_ERRORED);\n        }\n    }\n\n    /**\n     * On successful install, executes remaining steps after commit completes and the package lock\n     * is released. These are typically more expensive or require calls to installd, which often\n     * locks on {@link com.android.server.pm.PackageManagerService.mLock}.\n     */\n    private void executePostCommitSteps(CommitRequest commitRequest) {\n        final ArraySet<IncrementalStorage> incrementalStorages = new ArraySet<>();\n        for (ReconciledPackage reconciledPkg : commitRequest.mReconciledPackages.values()) {\n            final boolean instantApp = ((reconciledPkg.mScanResult.mRequest.mScanFlags\n                    & SCAN_AS_INSTANT_APP) != 0);\n            final AndroidPackage pkg = reconciledPkg.mPkgSetting.getPkg();\n            final String packageName = pkg.getPackageName();\n            final String codePath = pkg.getPath();\n            final boolean onIncremental = mIncrementalManager != null\n                    && isIncrementalPath(codePath);\n            if (onIncremental) {\n                IncrementalStorage storage = mIncrementalManager.openStorage(codePath);\n                if (storage == null) {\n                    throw new IllegalArgumentException(\n                            \"Install: null storage for incremental package \" + packageName);\n                }\n                incrementalStorages.add(storage);\n            }\n            // Hardcode previousAppId to 0 to disable any data migration (http://b/221088088)\n            mAppDataHelper.prepareAppDataPostCommitLIF(pkg, 0);\n            if (reconciledPkg.mPrepareResult.mClearCodeCache) {\n                mAppDataHelper.clearAppDataLIF(pkg, UserHandle.USER_ALL,\n                        FLAG_STORAGE_DE | FLAG_STORAGE_CE | FLAG_STORAGE_EXTERNAL\n                                | Installer.FLAG_CLEAR_CODE_CACHE_ONLY);\n            }\n            if (reconciledPkg.mPrepareResult.mReplace) {\n                mDexManager.notifyPackageUpdated(pkg.getPackageName(),\n                        pkg.getBaseApkPath(), pkg.getSplitCodePaths());\n            }\n\n            // Prepare the application profiles for the new code paths.\n            // This needs to be done before invoking dexopt so that any install-time profile\n            // can be used for optimizations.\n            mArtManagerService.prepareAppProfiles(\n                    pkg,\n                    mPm.resolveUserIds(reconciledPkg.mInstallArgs.mUser.getIdentifier()),\n                    /* updateReferenceProfileContent= */ true);\n\n            // Compute the compilation reason from the installation scenario.\n            final int compilationReason =\n                    mDexManager.getCompilationReasonForInstallScenario(\n                            reconciledPkg.mInstallArgs.mInstallScenario);\n\n            // Construct the DexoptOptions early to see if we should skip running dexopt.\n            //\n            // Do not run PackageDexOptimizer through the local performDexOpt\n            // method because `pkg` may not be in `mPackages` yet.\n            //\n            // Also, don't fail application installs if the dexopt step fails.\n            final boolean isBackupOrRestore =\n                    reconciledPkg.mInstallArgs.mInstallReason == INSTALL_REASON_DEVICE_RESTORE\n                            || reconciledPkg.mInstallArgs.mInstallReason\n                            == INSTALL_REASON_DEVICE_SETUP;\n\n            final int dexoptFlags = DexoptOptions.DEXOPT_BOOT_COMPLETE\n                    | DexoptOptions.DEXOPT_INSTALL_WITH_DEX_METADATA_FILE\n                    | (isBackupOrRestore ? DexoptOptions.DEXOPT_FOR_RESTORE : 0);\n            DexoptOptions dexoptOptions =\n                    new DexoptOptions(packageName, compilationReason, dexoptFlags);\n\n            // Check whether we need to dexopt the app.\n            //\n            // NOTE: it is IMPORTANT to call dexopt:\n            //   - after doRename which will sync the package data from AndroidPackage and\n            //     its corresponding ApplicationInfo.\n            //   - after installNewPackageLIF or replacePackageLIF which will update result with the\n            //     uid of the application (pkg.applicationInfo.uid).\n            //     This update happens in place!\n            //\n            // We only need to dexopt if the package meets ALL of the following conditions:\n            //   1) it is not an instant app or if it is then dexopt is enabled via gservices.\n            //   2) it is not debuggable.\n            //   3) it is not on Incremental File System.\n            //\n            // Note that we do not dexopt instant apps by default. dexopt can take some time to\n            // complete, so we skip this step during installation. Instead, we'll take extra time\n            // the first time the instant app starts. It's preferred to do it this way to provide\n            // continuous progress to the useur instead of mysteriously blocking somewhere in the\n            // middle of running an instant app. The default behaviour can be overridden\n            // via gservices.\n            //\n            // Furthermore, dexopt may be skipped, depending on the install scenario and current\n            // state of the device.\n            //\n            // TODO(b/174695087): instantApp and onIncremental should be removed and their install\n            //       path moved to SCENARIO_FAST.\n            final boolean performDexopt =\n                    (!instantApp || android.provider.Settings.Global.getInt(\n                            mContext.getContentResolver(),\n                            android.provider.Settings.Global.INSTANT_APP_DEXOPT_ENABLED, 0) != 0)\n                            && !pkg.isDebuggable()\n                            && (!onIncremental)\n                            && dexoptOptions.isCompilationEnabled();\n\n            if (performDexopt) {\n                // Compile the layout resources.\n                if (SystemProperties.getBoolean(PRECOMPILE_LAYOUTS, false)) {\n                    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"compileLayouts\");\n                    mViewCompiler.compileLayouts(pkg);\n                    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n                }\n\n                Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"dexopt\");\n                ScanResult result = reconciledPkg.mScanResult;\n\n                // This mirrors logic from commitReconciledScanResultLocked, where the library files\n                // needed for dexopt are assigned.\n                // TODO: Fix this to have 1 mutable PackageSetting for scan/install. If the previous\n                //  setting needs to be passed to have a comparison, hide it behind an immutable\n                //  interface. There's no good reason to have 3 different ways to access the real\n                //  PackageSetting object, only one of which is actually correct.\n                PackageSetting realPkgSetting = result.mExistingSettingCopied\n                        ? result.mRequest.mPkgSetting : result.mPkgSetting;\n                if (realPkgSetting == null) {\n                    realPkgSetting = reconciledPkg.mPkgSetting;\n                }\n\n                // Unfortunately, the updated system app flag is only tracked on this PackageSetting\n                boolean isUpdatedSystemApp = reconciledPkg.mPkgSetting.getPkgState()\n                        .isUpdatedSystemApp();\n\n                realPkgSetting.getPkgState().setUpdatedSystemApp(isUpdatedSystemApp);\n\n                mPackageDexOptimizer.performDexOpt(pkg, realPkgSetting,\n                        null /* instructionSets */,\n                        mPm.getOrCreateCompilerPackageStats(pkg),\n                        mDexManager.getPackageUseInfoOrDefault(packageName),\n                        dexoptOptions);\n                Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n            }\n\n            // Notify BackgroundDexOptService that the package has been changed.\n            // If this is an update of a package which used to fail to compile,\n            // BackgroundDexOptService will remove it from its denylist.\n            // TODO: Layering violation\n            BackgroundDexOptService.getService().notifyPackageChanged(packageName);\n\n            notifyPackageChangeObserversOnUpdate(reconciledPkg);\n        }\n        PackageManagerServiceUtils.waitForNativeBinariesExtractionForIncremental(\n                incrementalStorages);\n    }\n\n    private void notifyPackageChangeObserversOnUpdate(ReconciledPackage reconciledPkg) {\n        final PackageSetting pkgSetting = reconciledPkg.mPkgSetting;\n        final PackageInstalledInfo pkgInstalledInfo = reconciledPkg.mInstallResult;\n        final PackageRemovedInfo pkgRemovedInfo = pkgInstalledInfo.mRemovedInfo;\n\n        PackageChangeEvent pkgChangeEvent = new PackageChangeEvent();\n        pkgChangeEvent.packageName = pkgSetting.getPkg().getPackageName();\n        pkgChangeEvent.version = pkgSetting.getVersionCode();\n        pkgChangeEvent.lastUpdateTimeMillis = pkgSetting.getLastUpdateTime();\n        pkgChangeEvent.newInstalled = (pkgRemovedInfo == null || !pkgRemovedInfo.mIsUpdate);\n        pkgChangeEvent.dataRemoved = (pkgRemovedInfo != null && pkgRemovedInfo.mDataRemoved);\n        pkgChangeEvent.isDeleted = false;\n\n        mPm.notifyPackageChangeObservers(pkgChangeEvent);\n    }\n\n    public int installLocationPolicy(PackageInfoLite pkgLite, int installFlags) {\n        String packageName = pkgLite.packageName;\n        int installLocation = pkgLite.installLocation;\n        // reader\n        synchronized (mPm.mLock) {\n            // Currently installed package which the new package is attempting to replace or\n            // null if no such package is installed.\n            AndroidPackage installedPkg = mPm.mPackages.get(packageName);\n\n            if (installedPkg != null) {\n                if ((installFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {\n                    // Check for updated system application.\n                    if (installedPkg.isSystem()) {\n                        return InstallLocationUtils.RECOMMEND_INSTALL_INTERNAL;\n                    } else {\n                        // If current upgrade specifies particular preference\n                        if (installLocation == PackageInfo.INSTALL_LOCATION_INTERNAL_ONLY) {\n                            // Application explicitly specified internal.\n                            return InstallLocationUtils.RECOMMEND_INSTALL_INTERNAL;\n                        } else if (\n                                installLocation == PackageInfo.INSTALL_LOCATION_PREFER_EXTERNAL) {\n                            // App explicitly prefers external. Let policy decide\n                        } else {\n                            // Prefer previous location\n                            if (installedPkg.isExternalStorage()) {\n                                return InstallLocationUtils.RECOMMEND_INSTALL_EXTERNAL;\n                            }\n                            return InstallLocationUtils.RECOMMEND_INSTALL_INTERNAL;\n                        }\n                    }\n                } else {\n                    // Invalid install. Return error code\n                    return InstallLocationUtils.RECOMMEND_FAILED_ALREADY_EXISTS;\n                }\n            }\n        }\n        return pkgLite.recommendedInstallLocation;\n    }\n\n    Pair<Integer, String> verifyReplacingVersionCode(PackageInfoLite pkgLite,\n            long requiredInstalledVersionCode, int installFlags) {\n        if ((installFlags & PackageManager.INSTALL_APEX) != 0) {\n            return verifyReplacingVersionCodeForApex(\n                    pkgLite, requiredInstalledVersionCode, installFlags);\n        }\n\n        String packageName = pkgLite.packageName;\n        synchronized (mPm.mLock) {\n            // Package which currently owns the data that the new package will own if installed.\n            // If an app is uninstalled while keeping data (e.g. adb uninstall -k), installedPkg\n            // will be null whereas dataOwnerPkg will contain information about the package\n            // which was uninstalled while keeping its data.\n            AndroidPackage dataOwnerPkg = mPm.mPackages.get(packageName);\n            PackageSetting dataOwnerPs = mPm.mSettings.getPackageLPr(packageName);\n            if (dataOwnerPkg  == null) {\n                if (dataOwnerPs != null) {\n                    dataOwnerPkg = dataOwnerPs.getPkg();\n                }\n            }\n\n            if (requiredInstalledVersionCode != PackageManager.VERSION_CODE_HIGHEST) {\n                if (dataOwnerPkg == null) {\n                    String errorMsg = \"Required installed version code was \"\n                            + requiredInstalledVersionCode\n                            + \" but package is not installed\";\n                    Slog.w(TAG, errorMsg);\n                    return Pair.create(\n                            PackageManager.INSTALL_FAILED_WRONG_INSTALLED_VERSION, errorMsg);\n                }\n\n                if (dataOwnerPkg.getLongVersionCode() != requiredInstalledVersionCode) {\n                    String errorMsg = \"Required installed version code was \"\n                            + requiredInstalledVersionCode\n                            + \" but actual installed version is \"\n                            + dataOwnerPkg.getLongVersionCode();\n                    Slog.w(TAG, errorMsg);\n                    return Pair.create(\n                            PackageManager.INSTALL_FAILED_WRONG_INSTALLED_VERSION, errorMsg);\n                }\n            }\n\n            if (dataOwnerPkg != null && !dataOwnerPkg.isSdkLibrary()) {\n                if (!PackageManagerServiceUtils.isDowngradePermitted(installFlags,\n                        dataOwnerPkg.isDebuggable())) {\n                    // Downgrade is not permitted; a lower version of the app will not be allowed\n                    try {\n                        PackageManagerServiceUtils.checkDowngrade(dataOwnerPkg, pkgLite);\n                    } catch (PackageManagerException e) {\n                        String errorMsg = \"Downgrade detected: \" + e.getMessage();\n                        Slog.w(TAG, errorMsg);\n                        return Pair.create(\n                                PackageManager.INSTALL_FAILED_VERSION_DOWNGRADE, errorMsg);\n                    }\n                } else if (dataOwnerPs.isSystem()) {\n                    // Downgrade is permitted, but system apps can't be downgraded below\n                    // the version preloaded onto the system image\n                    final PackageSetting disabledPs = mPm.mSettings.getDisabledSystemPkgLPr(\n                            dataOwnerPs);\n                    if (disabledPs != null) {\n                        dataOwnerPkg = disabledPs.getPkg();\n                    }\n                    if (!Build.IS_DEBUGGABLE && !dataOwnerPkg.isDebuggable()) {\n                        // Only restrict non-debuggable builds and non-debuggable version of the app\n                        try {\n                            PackageManagerServiceUtils.checkDowngrade(dataOwnerPkg, pkgLite);\n                        } catch (PackageManagerException e) {\n                            String errorMsg =\n                                    \"System app: \" + packageName + \" cannot be downgraded to\"\n                                            + \" older than its preloaded version on the system\"\n                                            + \" image. \" + e.getMessage();\n                            Slog.w(TAG, errorMsg);\n                            return Pair.create(\n                                    PackageManager.INSTALL_FAILED_VERSION_DOWNGRADE, errorMsg);\n                        }\n                    }\n                }\n            }\n        }\n        return Pair.create(PackageManager.INSTALL_SUCCEEDED, null);\n    }\n\n    private Pair<Integer, String> verifyReplacingVersionCodeForApex(PackageInfoLite pkgLite,\n            long requiredInstalledVersionCode, int installFlags) {\n        String packageName = pkgLite.packageName;\n\n        final PackageInfo activePackage = mApexManager.getPackageInfo(packageName,\n                ApexManager.MATCH_ACTIVE_PACKAGE);\n        if (activePackage == null) {\n            String errorMsg = \"Attempting to install new APEX package \" + packageName;\n            Slog.w(TAG, errorMsg);\n            return Pair.create(PackageManager.INSTALL_FAILED_PACKAGE_CHANGED, errorMsg);\n        }\n\n        final long activeVersion = activePackage.getLongVersionCode();\n        if (requiredInstalledVersionCode != PackageManager.VERSION_CODE_HIGHEST\n                && activeVersion != requiredInstalledVersionCode) {\n            String errorMsg = \"Installed version of APEX package \" + packageName\n                    + \" does not match required. Active version: \" + activeVersion\n                    + \" required: \" + requiredInstalledVersionCode;\n            Slog.w(TAG, errorMsg);\n            return Pair.create(PackageManager.INSTALL_FAILED_WRONG_INSTALLED_VERSION, errorMsg);\n        }\n\n        final boolean isAppDebuggable = (activePackage.applicationInfo.flags\n                & ApplicationInfo.FLAG_DEBUGGABLE) != 0;\n        final long newVersionCode = pkgLite.getLongVersionCode();\n        if (!PackageManagerServiceUtils.isDowngradePermitted(installFlags, isAppDebuggable)\n                && newVersionCode < activeVersion) {\n            String errorMsg = \"Downgrade of APEX package \" + packageName\n                    + \" is not allowed. Active version: \" + activeVersion\n                    + \" attempted: \" + newVersionCode;\n            Slog.w(TAG, errorMsg);\n            return Pair.create(PackageManager.INSTALL_FAILED_VERSION_DOWNGRADE, errorMsg);\n        }\n\n        return Pair.create(PackageManager.INSTALL_SUCCEEDED, null);\n    }\n\n    int getUidForVerifier(VerifierInfo verifierInfo) {\n        synchronized (mPm.mLock) {\n            final AndroidPackage pkg = mPm.mPackages.get(verifierInfo.packageName);\n            if (pkg == null) {\n                return -1;\n            } else if (pkg.getSigningDetails().getSignatures().length != 1) {\n                Slog.i(TAG, \"Verifier package \" + verifierInfo.packageName\n                        + \" has more than one signature; ignoring\");\n                return -1;\n            }\n\n            /*\n             * If the public key of the package's signature does not match\n             * our expected public key, then this is a different package and\n             * we should skip.\n             */\n\n            final byte[] expectedPublicKey;\n            try {\n                final Signature verifierSig = pkg.getSigningDetails().getSignatures()[0];\n                final PublicKey publicKey = verifierSig.getPublicKey();\n                expectedPublicKey = publicKey.getEncoded();\n            } catch (CertificateException e) {\n                return -1;\n            }\n\n            final byte[] actualPublicKey = verifierInfo.publicKey.getEncoded();\n\n            if (!Arrays.equals(actualPublicKey, expectedPublicKey)) {\n                Slog.i(TAG, \"Verifier package \" + verifierInfo.packageName\n                        + \" does not have the expected public key; ignoring\");\n                return -1;\n            }\n\n            return pkg.getUid();\n        }\n    }\n\n    public void sendPendingBroadcasts() {\n        String[] packages;\n        ArrayList<String>[] components;\n        int numBroadcasts = 0, numUsers;\n        int[] uids;\n\n        synchronized (mPm.mLock) {\n            final SparseArray<ArrayMap<String, ArrayList<String>>> userIdToPackagesToComponents =\n                    mPm.mPendingBroadcasts.copiedMap();\n            numUsers = userIdToPackagesToComponents.size();\n            for (int n = 0; n < numUsers; n++) {\n                numBroadcasts += userIdToPackagesToComponents.valueAt(n).size();\n            }\n            if (numBroadcasts == 0) {\n                // Nothing to be done. Just return\n                return;\n            }\n            packages = new String[numBroadcasts];\n            components = new ArrayList[numBroadcasts];\n            uids = new int[numBroadcasts];\n            int i = 0;  // filling out the above arrays\n\n            for (int n = 0; n < numUsers; n++) {\n                final int packageUserId = userIdToPackagesToComponents.keyAt(n);\n                final ArrayMap<String, ArrayList<String>> componentsToBroadcast =\n                        userIdToPackagesToComponents.valueAt(n);\n                final int numComponents = CollectionUtils.size(componentsToBroadcast);\n                for (int index = 0; index < numComponents; index++) {\n                    packages[i] = componentsToBroadcast.keyAt(index);\n                    components[i] = componentsToBroadcast.valueAt(index);\n                    final PackageSetting ps = mPm.mSettings.getPackageLPr(packages[i]);\n                    uids[i] = (ps != null)\n                            ? UserHandle.getUid(packageUserId, ps.getAppId())\n                            : -1;\n                    i++;\n                }\n            }\n            numBroadcasts = i;\n            mPm.mPendingBroadcasts.clear();\n        }\n        final Computer snapshot = mPm.snapshotComputer();\n        // Send broadcasts\n        for (int i = 0; i < numBroadcasts; i++) {\n            mPm.sendPackageChangedBroadcast(snapshot, packages[i], true /* dontKillApp */,\n                    components[i], uids[i], null /* reason */);\n        }\n    }\n\n    void handlePackagePostInstall(PackageInstalledInfo res, InstallArgs installArgs,\n            boolean launchedForRestore) {\n        final boolean killApp =\n                (installArgs.mInstallFlags & PackageManager.INSTALL_DONT_KILL_APP) == 0;\n        final boolean virtualPreload =\n                ((installArgs.mInstallFlags & PackageManager.INSTALL_VIRTUAL_PRELOAD) != 0);\n        final String installerPackage = installArgs.mInstallSource.installerPackageName;\n        final IPackageInstallObserver2 installObserver = installArgs.mObserver;\n        final int dataLoaderType = installArgs.mDataLoaderType;\n        final boolean succeeded = res.mReturnCode == PackageManager.INSTALL_SUCCEEDED;\n        final boolean update = res.mRemovedInfo != null && res.mRemovedInfo.mRemovedPackage != null;\n        final String packageName = res.mName;\n        final PackageStateInternal pkgSetting =\n                succeeded ? mPm.snapshotComputer().getPackageStateInternal(packageName) : null;\n        final boolean removedBeforeUpdate = (pkgSetting == null)\n                || (pkgSetting.isSystem() && !pkgSetting.getPath().getPath().equals(\n                res.mPkg.getPath()));\n        if (succeeded && removedBeforeUpdate) {\n            Slog.e(TAG, packageName + \" was removed before handlePackagePostInstall \"\n                    + \"could be executed\");\n            res.mReturnCode = INSTALL_FAILED_PACKAGE_CHANGED;\n            res.mReturnMsg = \"Package was removed before install could complete.\";\n\n            // Remove the update failed package's older resources safely now\n            InstallArgs args = res.mRemovedInfo != null ? res.mRemovedInfo.mArgs : null;\n            if (args != null) {\n                synchronized (mPm.mInstallLock) {\n                    args.doPostDeleteLI(true);\n                }\n            }\n            mPm.notifyInstallObserver(res, installObserver);\n            return;\n        }\n\n        if (succeeded) {\n            // Clear the uid cache after we installed a new package.\n            mPm.mPerUidReadTimeoutsCache = null;\n\n            // Send the removed broadcasts\n            if (res.mRemovedInfo != null) {\n                if (res.mRemovedInfo.mIsExternal) {\n                    if (DEBUG_INSTALL) {\n                        Slog.i(TAG, \"upgrading pkg \" + res.mRemovedInfo.mRemovedPackage\n                                + \" is ASEC-hosted -> UNAVAILABLE\");\n                    }\n                    final int[] uidArray = new int[]{res.mRemovedInfo.mUid};\n                    final ArrayList<String> pkgList = new ArrayList<>(1);\n                    pkgList.add(res.mRemovedInfo.mRemovedPackage);\n                    mBroadcastHelper.sendResourcesChangedBroadcast(\n                            false, true, pkgList, uidArray, null);\n                }\n                res.mRemovedInfo.sendPackageRemovedBroadcasts(killApp, false /*removedBySystem*/);\n            }\n\n            final String installerPackageName =\n                    res.mInstallerPackageName != null\n                            ? res.mInstallerPackageName\n                            : res.mRemovedInfo != null\n                                    ? res.mRemovedInfo.mInstallerPackageName\n                                    : null;\n\n            mPm.notifyInstantAppPackageInstalled(res.mPkg.getPackageName(), res.mNewUsers);\n\n            // Determine the set of users who are adding this package for\n            // the first time vs. those who are seeing an update.\n            int[] firstUserIds = EMPTY_INT_ARRAY;\n            int[] firstInstantUserIds = EMPTY_INT_ARRAY;\n            int[] updateUserIds = EMPTY_INT_ARRAY;\n            int[] instantUserIds = EMPTY_INT_ARRAY;\n            final boolean allNewUsers = res.mOrigUsers == null || res.mOrigUsers.length == 0;\n            for (int newUser : res.mNewUsers) {\n                final boolean isInstantApp = pkgSetting.getUserStateOrDefault(newUser)\n                        .isInstantApp();\n                if (allNewUsers) {\n                    if (isInstantApp) {\n                        firstInstantUserIds = ArrayUtils.appendInt(firstInstantUserIds, newUser);\n                    } else {\n                        firstUserIds = ArrayUtils.appendInt(firstUserIds, newUser);\n                    }\n                    continue;\n                }\n                boolean isNew = true;\n                for (int origUser : res.mOrigUsers) {\n                    if (origUser == newUser) {\n                        isNew = false;\n                        break;\n                    }\n                }\n                if (isNew) {\n                    if (isInstantApp) {\n                        firstInstantUserIds = ArrayUtils.appendInt(firstInstantUserIds, newUser);\n                    } else {\n                        firstUserIds = ArrayUtils.appendInt(firstUserIds, newUser);\n                    }\n                } else {\n                    if (isInstantApp) {\n                        instantUserIds = ArrayUtils.appendInt(instantUserIds, newUser);\n                    } else {\n                        updateUserIds = ArrayUtils.appendInt(updateUserIds, newUser);\n                    }\n                }\n            }\n\n            // Send installed broadcasts if the package is not a static shared lib.\n            if (res.mPkg.getStaticSharedLibName() == null) {\n                mPm.mProcessLoggingHandler.invalidateBaseApkHash(res.mPkg.getBaseApkPath());\n\n                // Send added for users that see the package for the first time\n                // sendPackageAddedForNewUsers also deals with system apps\n                int appId = UserHandle.getAppId(res.mUid);\n                boolean isSystem = res.mPkg.isSystem();\n                mPm.sendPackageAddedForNewUsers(mPm.snapshotComputer(), packageName,\n                        isSystem || virtualPreload, virtualPreload /*startReceiver*/, appId,\n                        firstUserIds, firstInstantUserIds, dataLoaderType);\n\n                // Send added for users that don't see the package for the first time\n                Bundle extras = new Bundle();\n                extras.putInt(Intent.EXTRA_UID, res.mUid);\n                if (update) {\n                    extras.putBoolean(Intent.EXTRA_REPLACING, true);\n                }\n                extras.putInt(PackageInstaller.EXTRA_DATA_LOADER_TYPE, dataLoaderType);\n                // Send to all running apps.\n                final SparseArray<int[]> newBroadcastAllowList;\n                synchronized (mPm.mLock) {\n                    final Computer snapshot = mPm.snapshotComputer();\n                    newBroadcastAllowList = mPm.mAppsFilter.getVisibilityAllowList(snapshot,\n                            snapshot.getPackageStateInternal(packageName, Process.SYSTEM_UID),\n                            updateUserIds, mPm.mSettings.getPackagesLocked());\n                }\n                mPm.sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName,\n                        extras, 0 /*flags*/,\n                        null /*targetPackage*/, null /*finishedReceiver*/,\n                        updateUserIds, instantUserIds, newBroadcastAllowList, null);\n                if (installerPackageName != null) {\n                    // Send to the installer, even if it's not running.\n                    mPm.sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName,\n                            extras, 0 /*flags*/,\n                            installerPackageName, null /*finishedReceiver*/,\n                            updateUserIds, instantUserIds, null /* broadcastAllowList */, null);\n                }\n                // if the required verifier is defined, but, is not the installer of record\n                // for the package, it gets notified\n                final boolean notifyVerifier = mPm.mRequiredVerifierPackage != null\n                        && !mPm.mRequiredVerifierPackage.equals(installerPackageName);\n                if (notifyVerifier) {\n                    mPm.sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName,\n                            extras, 0 /*flags*/,\n                            mPm.mRequiredVerifierPackage, null /*finishedReceiver*/,\n                            updateUserIds, instantUserIds, null /* broadcastAllowList */, null);\n                }\n                // If package installer is defined, notify package installer about new\n                // app installed\n                if (mPm.mRequiredInstallerPackage != null) {\n                    mPm.sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName,\n                            extras, Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND /*flags*/,\n                            mPm.mRequiredInstallerPackage, null /*finishedReceiver*/,\n                            firstUserIds, instantUserIds, null /* broadcastAllowList */, null);\n                }\n\n                // Send replaced for users that don't see the package for the first time\n                if (update) {\n                    mPm.sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,\n                            packageName, extras, 0 /*flags*/,\n                            null /*targetPackage*/, null /*finishedReceiver*/,\n                            updateUserIds, instantUserIds, res.mRemovedInfo.mBroadcastAllowList,\n                            null);\n                    if (installerPackageName != null) {\n                        mPm.sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED, packageName,\n                                extras, 0 /*flags*/,\n                                installerPackageName, null /*finishedReceiver*/,\n                                updateUserIds, instantUserIds, null /*broadcastAllowList*/,\n                                null);\n                    }\n                    if (notifyVerifier) {\n                        mPm.sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED, packageName,\n                                extras, 0 /*flags*/,\n                                mPm.mRequiredVerifierPackage, null /*finishedReceiver*/,\n                                updateUserIds, instantUserIds, null /*broadcastAllowList*/,\n                                null);\n                    }\n                    mPm.sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,\n                            null /*package*/, null /*extras*/, 0 /*flags*/,\n                            packageName /*targetPackage*/,\n                            null /*finishedReceiver*/, updateUserIds, instantUserIds,\n                            null /*broadcastAllowList*/,\n                            mBroadcastHelper.getTemporaryAppAllowlistBroadcastOptions(\n                                    REASON_PACKAGE_REPLACED).toBundle());\n                } else if (launchedForRestore && !res.mPkg.isSystem()) {\n                    // First-install and we did a restore, so we're responsible for the\n                    // first-launch broadcast.\n                    if (DEBUG_BACKUP) {\n                        Slog.i(TAG, \"Post-restore of \" + packageName\n                                + \" sending FIRST_LAUNCH in \" + Arrays.toString(firstUserIds));\n                    }\n                    mBroadcastHelper.sendFirstLaunchBroadcast(packageName, installerPackage,\n                            firstUserIds, firstInstantUserIds);\n                }\n\n                // Send broadcast package appeared if external for all users\n                if (res.mPkg.isExternalStorage()) {\n                    if (!update) {\n                        final StorageManager storageManager =\n                                mInjector.getSystemService(StorageManager.class);\n                        VolumeInfo volume =\n                                storageManager.findVolumeByUuid(\n                                        StorageManager.convert(\n                                                res.mPkg.getVolumeUuid()).toString());\n                        int packageExternalStorageType =\n                                PackageManagerServiceUtils.getPackageExternalStorageType(volume,\n                                        res.mPkg.isExternalStorage());\n                        // If the package was installed externally, log it.\n                        if (packageExternalStorageType != StorageEnums.UNKNOWN) {\n                            FrameworkStatsLog.write(\n                                    FrameworkStatsLog.APP_INSTALL_ON_EXTERNAL_STORAGE_REPORTED,\n                                    packageExternalStorageType, packageName);\n                        }\n                    }\n                    if (DEBUG_INSTALL) {\n                        Slog.i(TAG, \"upgrading pkg \" + res.mPkg + \" is external\");\n                    }\n                    final int[] uidArray = new int[]{res.mPkg.getUid()};\n                    ArrayList<String> pkgList = new ArrayList<>(1);\n                    pkgList.add(packageName);\n                    mBroadcastHelper.sendResourcesChangedBroadcast(\n                            true, true, pkgList, uidArray, null);\n                }\n            } else if (!ArrayUtils.isEmpty(res.mLibraryConsumers)) { // if static shared lib\n                // No need to kill consumers if it's installation of new version static shared lib.\n                final Computer snapshot = mPm.snapshotComputer();\n                final boolean dontKillApp = !update && res.mPkg.getStaticSharedLibName() != null;\n                for (int i = 0; i < res.mLibraryConsumers.size(); i++) {\n                    AndroidPackage pkg = res.mLibraryConsumers.get(i);\n                    // send broadcast that all consumers of the static shared library have changed\n                    mPm.sendPackageChangedBroadcast(snapshot, pkg.getPackageName(), dontKillApp,\n                            new ArrayList<>(Collections.singletonList(pkg.getPackageName())),\n                            pkg.getUid(), null);\n                }\n            }\n\n            // Work that needs to happen on first install within each user\n            if (firstUserIds.length > 0) {\n                for (int userId : firstUserIds) {\n                    mPm.restorePermissionsAndUpdateRolesForNewUserInstall(packageName,\n                            userId);\n                }\n            }\n\n            if (allNewUsers && !update) {\n                mPm.notifyPackageAdded(packageName, res.mUid);\n            } else {\n                mPm.notifyPackageChanged(packageName, res.mUid);\n            }\n\n            // Log current value of \"unknown sources\" setting\n            EventLog.writeEvent(EventLogTags.UNKNOWN_SOURCES_ENABLED,\n                    getUnknownSourcesSettings());\n\n            // Remove the replaced package's older resources safely now\n            InstallArgs args = res.mRemovedInfo != null ? res.mRemovedInfo.mArgs : null;\n            if (args != null) {\n                if (!killApp) {\n                    // If we didn't kill the app, defer the deletion of code/resource files, since\n                    // they may still be in use by the running application. This mitigates problems\n                    // in cases where resources or code is loaded by a new Activity before\n                    // ApplicationInfo changes have propagated to all application threads.\n                    mPm.scheduleDeferredNoKillPostDelete(args);\n                } else {\n                    synchronized (mPm.mInstallLock) {\n                        args.doPostDeleteLI(true);\n                    }\n                }\n            } else {\n                // Force a gc to clear up things. Ask for a background one, it's fine to go on\n                // and not block here.\n                VMRuntime.getRuntime().requestConcurrentGC();\n            }\n\n            final Computer snapshot = mPm.snapshotComputer();\n            // Notify DexManager that the package was installed for new users.\n            // The updated users should already be indexed and the package code paths\n            // should not change.\n            // Don't notify the manager for ephemeral apps as they are not expected to\n            // survive long enough to benefit of background optimizations.\n            for (int userId : firstUserIds) {\n                PackageInfo info = snapshot.getPackageInfo(packageName, /*flags*/ 0, userId);\n                // There's a race currently where some install events may interleave with an\n                // uninstall. This can lead to package info being null (b/36642664).\n                if (info != null) {\n                    mDexManager.notifyPackageInstalled(info, userId);\n                }\n            }\n        }\n\n        final boolean deferInstallObserver = succeeded && update;\n        if (deferInstallObserver) {\n            if (killApp) {\n                mPm.scheduleDeferredPendingKillInstallObserver(res, installObserver);\n            } else {\n                mPm.scheduleDeferredNoKillInstallObserver(res, installObserver);\n            }\n        } else {\n            mPm.notifyInstallObserver(res, installObserver);\n        }\n\n        // Prune unused static shared libraries which have been cached a period of time\n        mPm.schedulePruneUnusedStaticSharedLibraries(true /* delay */);\n\n        // Log tracing if needed\n        if (installArgs.mTraceMethod != null) {\n            Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, installArgs.mTraceMethod,\n                    installArgs.mTraceCookie);\n        }\n    }\n\n    /**\n     * Get the \"allow unknown sources\" setting.\n     *\n     * @return the current \"allow unknown sources\" setting\n     */\n    private int getUnknownSourcesSettings() {\n        return android.provider.Settings.Secure.getIntForUser(mContext.getContentResolver(),\n                android.provider.Settings.Secure.INSTALL_NON_MARKET_APPS,\n                -1, UserHandle.USER_SYSTEM);\n    }\n\n    /**\n     * Uncompress and install stub applications.\n     * <p>In order to save space on the system partition, some applications are shipped in a\n     * compressed form. In addition the compressed bits for the full application, the\n     * system image contains a tiny stub comprised of only the Android manifest.\n     * <p>During the first boot, attempt to uncompress and install the full application. If\n     * the application can't be installed for any reason, disable the stub and prevent\n     * uncompressing the full application during future boots.\n     * <p>In order to forcefully attempt an installation of a full application, go to app\n     * settings and enable the application.\n     */\n    @GuardedBy({\"mPm.mLock\", \"mPm.mInstallLock\"})\n    void installSystemStubPackages(@NonNull List<String> systemStubPackageNames,\n            @PackageManagerService.ScanFlags int scanFlags) {\n        for (int i = systemStubPackageNames.size() - 1; i >= 0; --i) {\n            final String packageName = systemStubPackageNames.get(i);\n            // skip if the system package is already disabled\n            if (mPm.mSettings.isDisabledSystemPackageLPr(packageName)) {\n                systemStubPackageNames.remove(i);\n                continue;\n            }\n            // skip if the package isn't installed (?!); this should never happen\n            final AndroidPackage pkg = mPm.mPackages.get(packageName);\n            if (pkg == null) {\n                systemStubPackageNames.remove(i);\n                continue;\n            }\n            // skip if the package has been disabled by the user\n            final PackageSetting ps = mPm.mSettings.getPackageLPr(packageName);\n            if (ps != null) {\n                final int enabledState = ps.getEnabled(UserHandle.USER_SYSTEM);\n                if (enabledState == PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER) {\n                    systemStubPackageNames.remove(i);\n                    continue;\n                }\n            }\n\n            // install the package to replace the stub on /system\n            try {\n                installStubPackageLI(pkg, 0, scanFlags);\n                ps.setEnabled(PackageManager.COMPONENT_ENABLED_STATE_DEFAULT,\n                        UserHandle.USER_SYSTEM, \"android\");\n                systemStubPackageNames.remove(i);\n            } catch (PackageManagerException e) {\n                Slog.e(TAG, \"Failed to parse uncompressed system package: \" + e.getMessage());\n            }\n\n            // any failed attempt to install the package will be cleaned up later\n        }\n\n        // disable any stub still left; these failed to install the full application\n        for (int i = systemStubPackageNames.size() - 1; i >= 0; --i) {\n            final String pkgName = systemStubPackageNames.get(i);\n            final PackageSetting ps = mPm.mSettings.getPackageLPr(pkgName);\n            ps.setEnabled(PackageManager.COMPONENT_ENABLED_STATE_DISABLED,\n                    UserHandle.USER_SYSTEM, \"android\");\n            logCriticalInfo(Log.ERROR, \"Stub disabled; pkg: \" + pkgName);\n        }\n    }\n\n    /**\n     * Extract, install and enable a stub package.\n     * <p>If the compressed file can not be extracted / installed for any reason, the stub\n     * APK will be installed and the package will be disabled. To recover from this situation,\n     * the user will need to go into system settings and re-enable the package.\n     */\n    boolean enableCompressedPackage(AndroidPackage stubPkg,\n            @NonNull PackageSetting stubPkgSetting) {\n        final int parseFlags = mPm.getDefParseFlags() | ParsingPackageUtils.PARSE_CHATTY\n                | ParsingPackageUtils.PARSE_ENFORCE_CODE;\n        synchronized (mPm.mInstallLock) {\n            final AndroidPackage pkg;\n            try (PackageFreezer freezer =\n                         mPm.freezePackage(stubPkg.getPackageName(), \"setEnabledSetting\")) {\n                pkg = installStubPackageLI(stubPkg, parseFlags, 0 /*scanFlags*/);\n                mAppDataHelper.prepareAppDataAfterInstallLIF(pkg);\n                synchronized (mPm.mLock) {\n                    try {\n                        mSharedLibraries.updateSharedLibrariesLPw(\n                                pkg, stubPkgSetting, null, null,\n                                Collections.unmodifiableMap(mPm.mPackages));\n                    } catch (PackageManagerException e) {\n                        Slog.w(TAG, \"updateAllSharedLibrariesLPw failed: \", e);\n                    }\n                    mPm.mPermissionManager.onPackageInstalled(pkg,\n                            Process.INVALID_UID /* previousAppId */,\n                            PermissionManagerServiceInternal.PackageInstalledParams.DEFAULT,\n                            UserHandle.USER_ALL);\n                    mPm.writeSettingsLPrTEMP();\n                    // Since compressed package can be system app only, we do not need to\n                    // set restricted settings on it.\n                }\n            } catch (PackageManagerException e) {\n                // Whoops! Something went very wrong; roll back to the stub and disable the package\n                try (PackageFreezer freezer =\n                             mPm.freezePackage(stubPkg.getPackageName(), \"setEnabledSetting\")) {\n                    synchronized (mPm.mLock) {\n                        // NOTE: Ensure the system package is enabled; even for a compressed stub.\n                        // If we don't, installing the system package fails during scan\n                        mPm.mSettings.enableSystemPackageLPw(stubPkg.getPackageName());\n                    }\n                    installPackageFromSystemLIF(stubPkg.getPath(),\n                            mPm.mUserManager.getUserIds() /*allUserHandles*/,\n                            null /*origUserHandles*/,\n                            true /*writeSettings*/);\n                } catch (PackageManagerException pme) {\n                    // Serious WTF; we have to be able to install the stub\n                    Slog.wtf(TAG, \"Failed to restore system package:\" + stubPkg.getPackageName(),\n                            pme);\n                } finally {\n                    // Disable the package; the stub by itself is not runnable\n                    synchronized (mPm.mLock) {\n                        final PackageSetting stubPs = mPm.mSettings.getPackageLPr(\n                                stubPkg.getPackageName());\n                        if (stubPs != null) {\n                            stubPs.setEnabled(COMPONENT_ENABLED_STATE_DISABLED,\n                                    UserHandle.USER_SYSTEM, \"android\");\n                        }\n                        mPm.writeSettingsLPrTEMP();\n                    }\n                }\n                return false;\n            }\n            mAppDataHelper.clearAppDataLIF(pkg, UserHandle.USER_ALL,\n                    FLAG_STORAGE_DE | FLAG_STORAGE_CE | FLAG_STORAGE_EXTERNAL\n                            | Installer.FLAG_CLEAR_CODE_CACHE_ONLY);\n            mDexManager.notifyPackageUpdated(pkg.getPackageName(),\n                    pkg.getBaseApkPath(), pkg.getSplitCodePaths());\n        }\n        return true;\n    }\n\n    @GuardedBy(\"mPm.mInstallLock\")\n    private AndroidPackage installStubPackageLI(AndroidPackage stubPkg,\n            @ParsingPackageUtils.ParseFlags int parseFlags,\n            @PackageManagerService.ScanFlags int scanFlags)\n            throws PackageManagerException {\n        if (DEBUG_COMPRESSION) {\n            Slog.i(TAG, \"Uncompressing system stub; pkg: \" + stubPkg.getPackageName());\n        }\n        // uncompress the binary to its eventual destination on /data\n        final File scanFile = decompressPackage(stubPkg.getPackageName(), stubPkg.getPath());\n        if (scanFile == null) {\n            throw new PackageManagerException(\n                    \"Unable to decompress stub at \" + stubPkg.getPath());\n        }\n        synchronized (mPm.mLock) {\n            mPm.mSettings.disableSystemPackageLPw(stubPkg.getPackageName(), true /*replaced*/);\n        }\n        final RemovePackageHelper removePackageHelper = new RemovePackageHelper(mPm);\n        removePackageHelper.removePackageLI(stubPkg, true /*chatty*/);\n        try {\n            return scanSystemPackageTracedLI(scanFile, parseFlags, scanFlags, null);\n        } catch (PackageManagerException e) {\n            Slog.w(TAG, \"Failed to install compressed system package:\" + stubPkg.getPackageName(),\n                    e);\n            // Remove the failed install\n            removePackageHelper.removeCodePathLI(scanFile);\n            throw e;\n        }\n    }\n\n    /**\n     * Decompresses the given package on the system image onto\n     * the /data partition.\n     * @return The directory the package was decompressed into. Otherwise, {@code null}.\n     */\n    @GuardedBy(\"mPm.mInstallLock\")\n    private File decompressPackage(String packageName, String codePath) {\n        if (!compressedFileExists(codePath)) {\n            if (DEBUG_COMPRESSION) {\n                Slog.i(TAG, \"No files to decompress at: \" + codePath);\n            }\n            return null;\n        }\n        final File dstCodePath =\n                PackageManagerServiceUtils.getNextCodePath(Environment.getDataAppDirectory(null),\n                        packageName);\n        int ret = PackageManagerServiceUtils.decompressFiles(codePath, dstCodePath, packageName);\n        if (ret == PackageManager.INSTALL_SUCCEEDED) {\n            ret = PackageManagerServiceUtils.extractNativeBinaries(dstCodePath, packageName);\n        }\n        if (ret == PackageManager.INSTALL_SUCCEEDED) {\n            // NOTE: During boot, we have to delay releasing cblocks for no other reason than\n            // we cannot retrieve the setting {@link Secure#RELEASE_COMPRESS_BLOCKS_ON_INSTALL}.\n            // When we no longer need to read that setting, cblock release can occur always\n            // occur here directly\n            if (!mPm.isSystemReady()) {\n                if (mPm.mReleaseOnSystemReady == null) {\n                    mPm.mReleaseOnSystemReady = new ArrayList<>();\n                }\n                mPm.mReleaseOnSystemReady.add(dstCodePath);\n            } else {\n                final ContentResolver resolver = mContext.getContentResolver();\n                F2fsUtils.releaseCompressedBlocks(resolver, dstCodePath);\n            }\n        } else {\n            if (!dstCodePath.exists()) {\n                return null;\n            }\n            new RemovePackageHelper(mPm).removeCodePathLI(dstCodePath);\n            return null;\n        }\n\n        return dstCodePath;\n    }\n\n    /**\n     * Tries to restore the disabled system package after an update has been deleted.\n     */\n    public void restoreDisabledSystemPackageLIF(DeletePackageAction action,\n            @NonNull int[] allUserHandles, boolean writeSettings) throws SystemDeleteException {\n        final PackageSetting deletedPs = action.mDeletingPs;\n        final PackageRemovedInfo outInfo = action.mRemovedInfo;\n        final PackageSetting disabledPs = action.mDisabledPs;\n\n        synchronized (mPm.mLock) {\n            // NOTE: The system package always needs to be enabled; even if it's for\n            // a compressed stub. If we don't, installing the system package fails\n            // during scan [scanning checks the disabled packages]. We will reverse\n            // this later, after we've \"installed\" the stub.\n            // Reinstate the old system package\n            mPm.mSettings.enableSystemPackageLPw(disabledPs.getPkg().getPackageName());\n            // Remove any native libraries from the upgraded package.\n            PackageManagerServiceUtils.removeNativeBinariesLI(deletedPs);\n        }\n        // Install the system package\n        if (DEBUG_REMOVE) Slog.d(TAG, \"Re-installing system package: \" + disabledPs);\n        try {\n            synchronized (mPm.mInstallLock) {\n                final int[] origUsers = outInfo == null ? null : outInfo.mOrigUsers;\n                installPackageFromSystemLIF(disabledPs.getPathString(), allUserHandles,\n                        origUsers, writeSettings);\n            }\n        } catch (PackageManagerException e) {\n            Slog.w(TAG, \"Failed to restore system package:\" + deletedPs.getPackageName() + \": \"\n                    + e.getMessage());\n            // TODO(b/194319951): can we avoid this; throw would come from scan...\n            throw new SystemDeleteException(e);\n        } finally {\n            if (disabledPs.getPkg().isStub()) {\n                // We've re-installed the stub; make sure it's disabled here. If package was\n                // originally enabled, we'll install the compressed version of the application\n                // and re-enable it afterward.\n                synchronized (mPm.mLock) {\n                    disableStubPackage(action, deletedPs, allUserHandles);\n                }\n            }\n        }\n    }\n\n    @GuardedBy(\"mPm.mLock\")\n    private void disableStubPackage(DeletePackageAction action, PackageSetting deletedPs,\n            @NonNull int[] allUserHandles) {\n        final PackageSetting stubPs = mPm.mSettings.getPackageLPr(\n                deletedPs.getPackageName());\n        if (stubPs != null) {\n            int userId = action.mUser == null\n                    ? UserHandle.USER_ALL : action.mUser.getIdentifier();\n            if (userId == UserHandle.USER_ALL) {\n                for (int aUserId : allUserHandles) {\n                    stubPs.setEnabled(COMPONENT_ENABLED_STATE_DISABLED, aUserId, \"android\");\n                }\n            } else if (userId >= UserHandle.USER_SYSTEM) {\n                stubPs.setEnabled(COMPONENT_ENABLED_STATE_DISABLED, userId, \"android\");\n            }\n        }\n    }\n\n    /**\n     * Installs a package that's already on the system partition.\n     */\n    @GuardedBy(\"mPm.mInstallLock\")\n    private void installPackageFromSystemLIF(@NonNull String codePathString,\n            @NonNull int[] allUserHandles, @Nullable int[] origUserHandles,\n            boolean writeSettings)\n            throws PackageManagerException {\n        final File codePath = new File(codePathString);\n        @ParsingPackageUtils.ParseFlags int parseFlags =\n                mPm.getDefParseFlags()\n                        | ParsingPackageUtils.PARSE_MUST_BE_APK\n                        | ParsingPackageUtils.PARSE_IS_SYSTEM_DIR;\n        @PackageManagerService.ScanFlags int scanFlags = mPm.getSystemPackageScanFlags(codePath);\n        final AndroidPackage pkg = scanSystemPackageTracedLI(\n                codePath, parseFlags, scanFlags, null);\n\n        PackageSetting pkgSetting = mPm.mSettings.getPackageLPr(pkg.getPackageName());\n\n        try {\n            // update shared libraries for the newly re-installed system package\n            mSharedLibraries.updateSharedLibrariesLPw(pkg, pkgSetting, null, null,\n                    Collections.unmodifiableMap(mPm.mPackages));\n        } catch (PackageManagerException e) {\n            Slog.e(TAG, \"updateAllSharedLibrariesLPw failed: \" + e.getMessage());\n        }\n\n        mAppDataHelper.prepareAppDataAfterInstallLIF(pkg);\n\n        setPackageInstalledForSystemPackage(pkg, allUserHandles, origUserHandles, writeSettings);\n    }\n\n    private void setPackageInstalledForSystemPackage(@NonNull AndroidPackage pkg,\n            @NonNull int[] allUserHandles, @Nullable int[] origUserHandles,\n            boolean writeSettings) {\n        // writer\n        synchronized (mPm.mLock) {\n            PackageSetting ps = mPm.mSettings.getPackageLPr(pkg.getPackageName());\n\n            final boolean applyUserRestrictions = origUserHandles != null;\n            if (applyUserRestrictions) {\n                boolean installedStateChanged = false;\n                if (DEBUG_REMOVE) {\n                    Slog.d(TAG, \"Propagating install state across reinstall\");\n                }\n                for (int userId : allUserHandles) {\n                    final boolean installed = ArrayUtils.contains(origUserHandles, userId);\n                    if (DEBUG_REMOVE) {\n                        Slog.d(TAG, \"    user \" + userId + \" => \" + installed);\n                    }\n                    if (installed != ps.getInstalled(userId)) {\n                        installedStateChanged = true;\n                    }\n                    ps.setInstalled(installed, userId);\n                    if (installed) {\n                        ps.setUninstallReason(UNINSTALL_REASON_UNKNOWN, userId);\n                    }\n                }\n                // Regardless of writeSettings we need to ensure that this restriction\n                // state propagation is persisted\n                mPm.mSettings.writeAllUsersPackageRestrictionsLPr();\n                if (installedStateChanged) {\n                    mPm.mSettings.writeKernelMappingLPr(ps);\n                }\n            }\n\n            // The method below will take care of removing obsolete permissions and granting\n            // install permissions.\n            mPm.mPermissionManager.onPackageInstalled(pkg, Process.INVALID_UID,\n                    PermissionManagerServiceInternal.PackageInstalledParams.DEFAULT,\n                    UserHandle.USER_ALL);\n            for (final int userId : allUserHandles) {\n                if (applyUserRestrictions) {\n                    mPm.mSettings.writePermissionStateForUserLPr(userId, false);\n                }\n            }\n\n            // can downgrade to reader here\n            if (writeSettings) {\n                mPm.writeSettingsLPrTEMP();\n            }\n        }\n    }\n\n    @GuardedBy(\"mPm.mLock\")\n    public void prepareSystemPackageCleanUp(\n            WatchedArrayMap<String, PackageSetting> packageSettings,\n            List<String> possiblyDeletedUpdatedSystemApps,\n            ArrayMap<String, File> expectingBetter, int[] userIds) {\n        // Iterates PackageSettings in reversed order because the item could be removed\n        // during the iteration.\n        for (int index = packageSettings.size() - 1; index >= 0; index--) {\n            final PackageSetting ps = packageSettings.valueAt(index);\n            final String packageName = ps.getPackageName();\n            /*\n             * If this is not a system app, it can't be a\n             * disable system app.\n             */\n            if (!ps.isSystem()) {\n                continue;\n            }\n\n            /*\n             * If the package is scanned, it's not erased.\n             */\n            final AndroidPackage scannedPkg = mPm.mPackages.get(packageName);\n            final PackageSetting disabledPs =\n                    mPm.mSettings.getDisabledSystemPkgLPr(packageName);\n            if (scannedPkg != null) {\n                /*\n                 * If the system app is both scanned and in the\n                 * disabled packages list, then it must have been\n                 * added via OTA. Remove it from the currently\n                 * scanned package so the previously user-installed\n                 * application can be scanned.\n                 */\n                if (disabledPs != null) {\n                    logCriticalInfo(Log.WARN,\n                            \"Expecting better updated system app for \"\n                                    + packageName\n                                    + \"; removing system app.  Last known\"\n                                    + \" codePath=\" + ps.getPathString()\n                                    + \", versionCode=\" + ps.getVersionCode()\n                                    + \"; scanned versionCode=\"\n                                    + scannedPkg.getLongVersionCode());\n                    mRemovePackageHelper.removePackageLI(scannedPkg, true);\n                    expectingBetter.put(ps.getPackageName(), ps.getPath());\n                }\n\n                continue;\n            }\n\n            if (disabledPs == null) {\n                logCriticalInfo(Log.WARN, \"System package \" + packageName\n                        + \" no longer exists; its data will be wiped\");\n                mRemovePackageHelper.removePackageDataLIF(ps, userIds, null, 0, false);\n            } else {\n                // we still have a disabled system package, but, it still might have\n                // been removed. check the code path still exists and check there's\n                // still a package. the latter can happen if an OTA keeps the same\n                // code path, but, changes the package name.\n                if (disabledPs.getPath() == null || !disabledPs.getPath().exists()\n                        || disabledPs.getPkg() == null) {\n                    possiblyDeletedUpdatedSystemApps.add(packageName);\n                } else {\n                    // We're expecting that the system app should remain disabled, but add\n                    // it to expecting better to recover in case the data version cannot\n                    // be scanned.\n                    expectingBetter.put(disabledPs.getPackageName(), disabledPs.getPath());\n                }\n            }\n        }\n    }\n\n    @GuardedBy(\"mPm.mLock\")\n    // Remove disable package settings for updated system apps that were\n    // removed via an OTA. If the update is no longer present, remove the\n    // app completely. Otherwise, revoke their system privileges.\n    public void cleanupDisabledPackageSettings(List<String> possiblyDeletedUpdatedSystemApps,\n            int[] userIds, int scanFlags) {\n        for (int i = possiblyDeletedUpdatedSystemApps.size() - 1; i >= 0; --i) {\n            final String packageName = possiblyDeletedUpdatedSystemApps.get(i);\n            final AndroidPackage pkg = mPm.mPackages.get(packageName);\n            final String msg;\n\n            // remove from the disabled system list; do this first so any future\n            // scans of this package are performed without this state\n            mPm.mSettings.removeDisabledSystemPackageLPw(packageName);\n\n            if (pkg == null) {\n                // should have found an update, but, we didn't; remove everything\n                msg = \"Updated system package \" + packageName\n                        + \" no longer exists; removing its data\";\n                // Actual deletion of code and data will be handled by later\n                // reconciliation step\n            } else {\n                // found an update; revoke system privileges\n                msg = \"Updated system package \" + packageName\n                        + \" no longer exists; rescanning package on data\";\n\n                // NOTE: We don't do anything special if a stub is removed from the\n                // system image. But, if we were [like removing the uncompressed\n                // version from the /data partition], this is where it'd be done.\n\n                // remove the package from the system and re-scan it without any\n                // special privileges\n                mRemovePackageHelper.removePackageLI(pkg, true);\n                try {\n                    final File codePath = new File(pkg.getPath());\n                    scanSystemPackageTracedLI(codePath, 0, scanFlags, null);\n                } catch (PackageManagerException e) {\n                    Slog.e(TAG, \"Failed to parse updated, ex-system package: \"\n                            + e.getMessage());\n                }\n            }\n\n            // one final check. if we still have a package setting [ie. it was\n            // previously scanned and known to the system], but, we don't have\n            // a package [ie. there was an error scanning it from the /data\n            // partition], completely remove the package data.\n            final PackageSetting ps = mPm.mSettings.getPackageLPr(packageName);\n            if (ps != null && mPm.mPackages.get(packageName) == null) {\n                mRemovePackageHelper.removePackageDataLIF(ps, userIds, null, 0, false);\n            }\n            logCriticalInfo(Log.WARN, msg);\n        }\n    }\n\n    @GuardedBy({\"mPm.mInstallLock\", \"mPm.mLock\"})\n    public void installPackagesFromDir(File scanDir, List<File> frameworkSplits, int parseFlags,\n            int scanFlags, PackageParser2 packageParser,\n            ExecutorService executorService) {\n        final File[] files = scanDir.listFiles();\n        if (ArrayUtils.isEmpty(files)) {\n            Log.d(TAG, \"No files in app dir \" + scanDir);\n            return;\n        }\n\n        if (DEBUG_PACKAGE_SCANNING) {\n            Log.d(TAG, \"Scanning app dir \" + scanDir + \" scanFlags=\" + scanFlags\n                    + \" flags=0x\" + Integer.toHexString(parseFlags));\n        }\n        ParallelPackageParser parallelPackageParser =\n                new ParallelPackageParser(packageParser, executorService, frameworkSplits);\n\n        // Submit files for parsing in parallel\n        int fileCount = 0;\n        for (File file : files) {\n            final boolean isPackage = (isApkFile(file) || file.isDirectory())\n                    && !PackageInstallerService.isStageName(file.getName());\n            if (!isPackage) {\n                // Ignore entries which are not packages\n                continue;\n            }\n            if ((scanFlags & SCAN_DROP_CACHE) != 0) {\n                final PackageCacher cacher = new PackageCacher(mPm.getCacheDir());\n                Log.w(TAG, \"Dropping cache of \" + file.getAbsolutePath());\n                cacher.cleanCachedResult(file);\n            }\n            parallelPackageParser.submit(file, parseFlags);\n            fileCount++;\n        }\n\n        // Process results one by one\n        for (; fileCount > 0; fileCount--) {\n            ParallelPackageParser.ParseResult parseResult = parallelPackageParser.take();\n            Throwable throwable = parseResult.throwable;\n            int errorCode = PackageManager.INSTALL_SUCCEEDED;\n            String errorMsg = null;\n\n            if (throwable == null) {\n                // TODO(b/194319951): move lower in the scan chain\n                // Static shared libraries have synthetic package names\n                if (parseResult.parsedPackage.isStaticSharedLibrary()) {\n                    PackageManagerService.renameStaticSharedLibraryPackage(\n                            parseResult.parsedPackage);\n                }\n                try {\n                    addForInitLI(parseResult.parsedPackage, parseFlags, scanFlags,\n                            null);\n                } catch (PackageManagerException e) {\n                    errorCode = e.error;\n                    errorMsg = \"Failed to scan \" + parseResult.scanFile + \": \" + e.getMessage();\n                    Slog.w(TAG, errorMsg);\n                }\n            } else if (throwable instanceof PackageManagerException) {\n                PackageManagerException e = (PackageManagerException) throwable;\n                errorCode = e.error;\n                errorMsg = \"Failed to parse \" + parseResult.scanFile + \": \" + e.getMessage();\n                Slog.w(TAG, errorMsg);\n            } else {\n                throw new IllegalStateException(\"Unexpected exception occurred while parsing \"\n                        + parseResult.scanFile, throwable);\n            }\n\n            if ((scanFlags & SCAN_AS_APK_IN_APEX) != 0 && errorCode != INSTALL_SUCCEEDED) {\n                mApexManager.reportErrorWithApkInApex(scanDir.getAbsolutePath(), errorMsg);\n            }\n\n            // Delete invalid userdata apps\n            if ((scanFlags & SCAN_AS_SYSTEM) == 0\n                    && errorCode != PackageManager.INSTALL_SUCCEEDED) {\n                logCriticalInfo(Log.WARN,\n                        \"Deleting invalid package at \" + parseResult.scanFile);\n                mRemovePackageHelper.removeCodePathLI(parseResult.scanFile);\n            }\n        }\n    }\n\n    /**\n     * Make sure all system apps that we expected to appear on\n     * the userdata partition actually showed up. If they never\n     * appeared, crawl back and revive the system version.\n     */\n    @GuardedBy(\"mPm.mLock\")\n    public void checkExistingBetterPackages(ArrayMap<String, File> expectingBetterPackages,\n            List<String> stubSystemApps, int systemScanFlags, int systemParseFlags) {\n        for (int i = 0; i < expectingBetterPackages.size(); i++) {\n            final String packageName = expectingBetterPackages.keyAt(i);\n            if (mPm.mPackages.containsKey(packageName)) {\n                continue;\n            }\n            final File scanFile = expectingBetterPackages.valueAt(i);\n\n            logCriticalInfo(Log.WARN, \"Expected better \" + packageName\n                    + \" but never showed up; reverting to system\");\n\n            final Pair<Integer, Integer> rescanAndReparseFlags =\n                    mPm.getSystemPackageRescanFlagsAndReparseFlags(scanFile,\n                            systemScanFlags, systemParseFlags);\n            @PackageManagerService.ScanFlags int rescanFlags = rescanAndReparseFlags.first;\n            @ParsingPackageUtils.ParseFlags int reparseFlags = rescanAndReparseFlags.second;\n\n            if (rescanFlags == 0) {\n                Slog.e(TAG, \"Ignoring unexpected fallback path \" + scanFile);\n                continue;\n            }\n            mPm.mSettings.enableSystemPackageLPw(packageName);\n\n            try {\n                final AndroidPackage newPkg = scanSystemPackageTracedLI(\n                        scanFile, reparseFlags, rescanFlags, null);\n                // We rescanned a stub, add it to the list of stubbed system packages\n                if (newPkg.isStub()) {\n                    stubSystemApps.add(packageName);\n                }\n            } catch (PackageManagerException e) {\n                Slog.e(TAG, \"Failed to parse original system package: \"\n                        + e.getMessage());\n            }\n        }\n    }\n\n    /**\n     *  Traces a package scan.\n     *  @see #scanSystemPackageLI(File, int, int, UserHandle)\n     */\n    @GuardedBy({\"mPm.mInstallLock\", \"mPm.mLock\"})\n    public AndroidPackage scanSystemPackageTracedLI(File scanFile, final int parseFlags,\n            int scanFlags, UserHandle user) throws PackageManagerException {\n        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"scanPackage [\" + scanFile.toString() + \"]\");\n        try {\n            return scanSystemPackageLI(scanFile, parseFlags, scanFlags, user);\n        } finally {\n            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n        }\n    }\n\n    /**\n     *  Scans a package and returns the newly parsed package.\n     *  Returns {@code null} in case of errors and the error code is stored in mLastScanError\n     */\n    @GuardedBy({\"mPm.mInstallLock\", \"mPm.mLock\"})\n    private AndroidPackage scanSystemPackageLI(File scanFile, int parseFlags, int scanFlags,\n            UserHandle user) throws PackageManagerException {\n        if (DEBUG_INSTALL) Slog.d(TAG, \"Parsing: \" + scanFile);\n\n        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"parsePackage\");\n        final ParsedPackage parsedPackage;\n        try (PackageParser2 pp = mPm.mInjector.getScanningPackageParser()) {\n            parsedPackage = pp.parsePackage(scanFile, parseFlags, false);\n        } finally {\n            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n        }\n\n        // Static shared libraries have synthetic package names\n        if (parsedPackage.isStaticSharedLibrary()) {\n            PackageManagerService.renameStaticSharedLibraryPackage(parsedPackage);\n        }\n\n        return addForInitLI(parsedPackage, parseFlags, scanFlags, user);\n    }\n\n    /**\n     * Adds a new package to the internal data structures during platform initialization.\n     * <p>After adding, the package is known to the system and available for querying.\n     * <p>For packages located on the device ROM [eg. packages located in /system, /vendor,\n     * etc...], additional checks are performed. Basic verification [such as ensuring\n     * matching signatures, checking version codes, etc...] occurs if the package is\n     * identical to a previously known package. If the package fails a signature check,\n     * the version installed on /data will be removed. If the version of the new package\n     * is less than or equal than the version on /data, it will be ignored.\n     * <p>Regardless of the package location, the results are applied to the internal\n     * structures and the package is made available to the rest of the system.\n     * <p>NOTE: The return value should be removed. It's the passed in package object.\n     */\n    @GuardedBy({\"mPm.mLock\", \"mPm.mInstallLock\"})\n    private AndroidPackage addForInitLI(ParsedPackage parsedPackage,\n            @ParsingPackageUtils.ParseFlags int parseFlags,\n            @PackageManagerService.ScanFlags int scanFlags,\n            @Nullable UserHandle user) throws PackageManagerException {\n\n        final Pair<ScanResult, Boolean> scanResultPair = scanSystemPackageLI(\n                parsedPackage, parseFlags, scanFlags, user);\n        final ScanResult scanResult = scanResultPair.first;\n        boolean shouldHideSystemApp = scanResultPair.second;\n        if (scanResult.mSuccess) {\n            synchronized (mPm.mLock) {\n                boolean appIdCreated = false;\n                try {\n                    final String pkgName = scanResult.mPkgSetting.getPackageName();\n                    final ReconcileRequest reconcileRequest = new ReconcileRequest(\n                            Collections.singletonMap(pkgName, scanResult),\n                            mPm.mPackages,\n                            Collections.singletonMap(pkgName,\n                                    mPm.getSettingsVersionForPackage(parsedPackage)));\n                    final Map<String, ReconciledPackage> reconcileResult =\n                            ReconcilePackageUtils.reconcilePackages(reconcileRequest,\n                                    mSharedLibraries, mPm.mSettings.getKeySetManagerService(),\n                                    mPm.mSettings);\n                    appIdCreated = optimisticallyRegisterAppId(scanResult);\n                    commitReconciledScanResultLocked(reconcileResult.get(pkgName),\n                            mPm.mUserManager.getUserIds());\n                } catch (PackageManagerException e) {\n                    if (appIdCreated) {\n                        cleanUpAppIdCreation(scanResult);\n                    }\n                    throw e;\n                }\n            }\n        }\n\n        if (shouldHideSystemApp) {\n            synchronized (mPm.mLock) {\n                mPm.mSettings.disableSystemPackageLPw(parsedPackage.getPackageName(), true);\n            }\n        }\n        if (mIncrementalManager != null && isIncrementalPath(parsedPackage.getPath())) {\n            if (scanResult.mPkgSetting != null && scanResult.mPkgSetting.isLoading()) {\n                // Continue monitoring loading progress of active incremental packages\n                mIncrementalManager.registerLoadingProgressCallback(parsedPackage.getPath(),\n                        new IncrementalProgressListener(parsedPackage.getPackageName(), mPm));\n            }\n        }\n        return scanResult.mPkgSetting.getPkg();\n    }\n\n    /**\n     * Prepares the system to commit a {@link ScanResult} in a way that will not fail by registering\n     * the app ID required for reconcile.\n     * @return {@code true} if a new app ID was registered and will need to be cleaned up on\n     *         failure.\n     */\n    private boolean optimisticallyRegisterAppId(@NonNull ScanResult result)\n            throws PackageManagerException {\n        if (!result.mExistingSettingCopied || result.needsNewAppId()) {\n            synchronized (mPm.mLock) {\n                // THROWS: when we can't allocate a user id. add call to check if there's\n                // enough space to ensure we won't throw; otherwise, don't modify state\n                return mPm.mSettings.registerAppIdLPw(result.mPkgSetting, result.needsNewAppId());\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Reverts any app ID creation that were made by\n     * {@link #optimisticallyRegisterAppId(ScanResult)}. Note: this is only necessary if the\n     * referenced method returned true.\n     */\n    private void cleanUpAppIdCreation(@NonNull ScanResult result) {\n        // iff we've acquired an app ID for a new package setting, remove it so that it can be\n        // acquired by another request.\n        if (result.mPkgSetting.getAppId() > 0) {\n            mPm.mSettings.removeAppIdLPw(result.mPkgSetting.getAppId());\n        }\n    }\n\n    @GuardedBy({\"mPm.mInstallLock\", \"mPm.mLock\"})\n    private ScanResult scanPackageTracedLI(ParsedPackage parsedPackage,\n            final @ParsingPackageUtils.ParseFlags int parseFlags,\n            @PackageManagerService.ScanFlags int scanFlags, long currentTime,\n            @Nullable UserHandle user, String cpuAbiOverride) throws PackageManagerException {\n        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"scanPackage\");\n        try {\n            return scanPackageNewLI(parsedPackage, parseFlags, scanFlags, currentTime, user,\n                    cpuAbiOverride);\n        } finally {\n            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n        }\n    }\n\n    private ScanRequest prepareInitialScanRequest(@NonNull ParsedPackage parsedPackage,\n            @ParsingPackageUtils.ParseFlags int parseFlags,\n            @PackageManagerService.ScanFlags int scanFlags,\n            @Nullable UserHandle user, String cpuAbiOverride)\n            throws PackageManagerException {\n        final AndroidPackage platformPackage;\n        final String realPkgName;\n        final PackageSetting disabledPkgSetting;\n        final PackageSetting installedPkgSetting;\n        final PackageSetting originalPkgSetting;\n        final SharedUserSetting sharedUserSetting;\n        SharedUserSetting oldSharedUserSetting = null;\n\n        synchronized (mPm.mLock) {\n            platformPackage = mPm.getPlatformPackage();\n            final String renamedPkgName = mPm.mSettings.getRenamedPackageLPr(\n                    AndroidPackageUtils.getRealPackageOrNull(parsedPackage));\n            realPkgName = ScanPackageUtils.getRealPackageName(parsedPackage, renamedPkgName);\n            if (realPkgName != null) {\n                ScanPackageUtils.ensurePackageRenamed(parsedPackage, renamedPkgName);\n            }\n            originalPkgSetting = getOriginalPackageLocked(parsedPackage, renamedPkgName);\n            installedPkgSetting = mPm.mSettings.getPackageLPr(parsedPackage.getPackageName());\n            if (mPm.mTransferredPackages.contains(parsedPackage.getPackageName())) {\n                Slog.w(TAG, \"Package \" + parsedPackage.getPackageName()\n                        + \" was transferred to another, but its .apk remains\");\n            }\n            disabledPkgSetting = mPm.mSettings.getDisabledSystemPkgLPr(\n                    parsedPackage.getPackageName());\n\n            boolean ignoreSharedUserId = false;\n            if (installedPkgSetting == null || !installedPkgSetting.hasSharedUser()) {\n                // Directly ignore sharedUserSetting for new installs, or if the app has\n                // already left shared UID\n                ignoreSharedUserId = parsedPackage.isLeavingSharedUid();\n            }\n\n            if (!ignoreSharedUserId && parsedPackage.getSharedUserId() != null) {\n                sharedUserSetting = mPm.mSettings.getSharedUserLPw(\n                        parsedPackage.getSharedUserId(),\n                        0 /*pkgFlags*/, 0 /*pkgPrivateFlags*/, true /*create*/);\n            } else {\n                sharedUserSetting = null;\n            }\n            if (DEBUG_PACKAGE_SCANNING\n                    && (parseFlags & ParsingPackageUtils.PARSE_CHATTY) != 0\n                    && sharedUserSetting != null) {\n                Log.d(TAG, \"Shared UserID \" + parsedPackage.getSharedUserId()\n                        + \" (uid=\" + sharedUserSetting.mAppId + \"):\"\n                        + \" packages=\" + sharedUserSetting.getPackageStates());\n            }\n            if (installedPkgSetting != null) {\n                oldSharedUserSetting = mPm.mSettings.getSharedUserSettingLPr(installedPkgSetting);\n            }\n        }\n\n        final boolean isPlatformPackage = platformPackage != null\n                && platformPackage.getPackageName().equals(parsedPackage.getPackageName());\n\n        return new ScanRequest(parsedPackage, oldSharedUserSetting,\n                installedPkgSetting == null ? null : installedPkgSetting.getPkg() /* oldPkg */,\n                installedPkgSetting /* packageSetting */,\n                sharedUserSetting,\n                disabledPkgSetting /* disabledPackageSetting */,\n                originalPkgSetting  /* originalPkgSetting */,\n                realPkgName, parseFlags, scanFlags, isPlatformPackage, user, cpuAbiOverride);\n    }\n\n    @GuardedBy({\"mPm.mInstallLock\", \"mPm.mLock\"})\n    private ScanResult scanPackageNewLI(@NonNull ParsedPackage parsedPackage,\n            final @ParsingPackageUtils.ParseFlags int parseFlags,\n            @PackageManagerService.ScanFlags int scanFlags, long currentTime,\n            @Nullable UserHandle user, String cpuAbiOverride)\n            throws PackageManagerException {\n        final ScanRequest initialScanRequest = prepareInitialScanRequest(parsedPackage, parseFlags,\n                scanFlags, user, cpuAbiOverride);\n        final PackageSetting installedPkgSetting = initialScanRequest.mPkgSetting;\n        final PackageSetting disabledPkgSetting = initialScanRequest.mDisabledPkgSetting;\n\n        boolean isUpdatedSystemApp;\n        if (installedPkgSetting != null) {\n            isUpdatedSystemApp = installedPkgSetting.getPkgState().isUpdatedSystemApp();\n        } else {\n            isUpdatedSystemApp = disabledPkgSetting != null;\n        }\n\n        final int newScanFlags = adjustScanFlags(scanFlags, installedPkgSetting, disabledPkgSetting,\n                user, parsedPackage);\n        ScanPackageUtils.applyPolicy(parsedPackage, newScanFlags,\n                mPm.getPlatformPackage(), isUpdatedSystemApp);\n\n        synchronized (mPm.mLock) {\n            assertPackageIsValid(parsedPackage, parseFlags, newScanFlags);\n            final ScanRequest request = new ScanRequest(parsedPackage,\n                    initialScanRequest.mOldSharedUserSetting,\n                    initialScanRequest.mOldPkg, installedPkgSetting,\n                    initialScanRequest.mSharedUserSetting, disabledPkgSetting,\n                    initialScanRequest.mOriginalPkgSetting, initialScanRequest.mRealPkgName,\n                    parseFlags, scanFlags, initialScanRequest.mIsPlatformPackage, user,\n                    cpuAbiOverride);\n            return ScanPackageUtils.scanPackageOnlyLI(request, mPm.mInjector, mPm.mFactoryTest,\n                    currentTime);\n        }\n    }\n\n    private Pair<ScanResult, Boolean> scanSystemPackageLI(ParsedPackage parsedPackage,\n            @ParsingPackageUtils.ParseFlags int parseFlags,\n            @PackageManagerService.ScanFlags int scanFlags,\n            @Nullable UserHandle user) throws PackageManagerException {\n        final boolean scanSystemPartition =\n                (parseFlags & ParsingPackageUtils.PARSE_IS_SYSTEM_DIR) != 0;\n        final ScanRequest initialScanRequest = prepareInitialScanRequest(parsedPackage, parseFlags,\n                scanFlags, user, null);\n        final PackageSetting installedPkgSetting = initialScanRequest.mPkgSetting;\n        final PackageSetting originalPkgSetting = initialScanRequest.mOriginalPkgSetting;\n        final PackageSetting pkgSetting =\n                originalPkgSetting == null ? installedPkgSetting : originalPkgSetting;\n        final boolean pkgAlreadyExists = pkgSetting != null;\n        final String disabledPkgName = pkgAlreadyExists\n                ? pkgSetting.getPackageName() : parsedPackage.getPackageName();\n        final boolean isSystemPkgUpdated;\n        final boolean isUpgrade;\n        synchronized (mPm.mLock) {\n            isUpgrade = mPm.isDeviceUpgrading();\n            if (scanSystemPartition && !pkgAlreadyExists\n                    && mPm.mSettings.getDisabledSystemPkgLPr(disabledPkgName) != null) {\n                // The updated-package data for /system apk remains inconsistently\n                // after the package data for /data apk is lost accidentally.\n                // To recover it, enable /system apk and install it as non-updated system app.\n                Slog.w(TAG, \"Inconsistent package setting of updated system app for \"\n                        + disabledPkgName + \". To recover it, enable the system app \"\n                        + \"and install it as non-updated system app.\");\n                mPm.mSettings.removeDisabledSystemPackageLPw(disabledPkgName);\n            }\n            final PackageSetting disabledPkgSetting =\n                    mPm.mSettings.getDisabledSystemPkgLPr(disabledPkgName);\n            isSystemPkgUpdated = disabledPkgSetting != null;\n\n            if (DEBUG_INSTALL && isSystemPkgUpdated) {\n                Slog.d(TAG, \"updatedPkg = \" + disabledPkgSetting);\n            }\n\n            if (scanSystemPartition && isSystemPkgUpdated) {\n                // we're updating the disabled package, so, scan it as the package setting\n                final ScanRequest request = new ScanRequest(parsedPackage,\n                        mPm.mSettings.getSharedUserSettingLPr(disabledPkgSetting),\n                        null, disabledPkgSetting /* pkgSetting */,\n                        initialScanRequest.mSharedUserSetting,\n                        null /* disabledPkgSetting */, null /* originalPkgSetting */,\n                        null, parseFlags, scanFlags,\n                        initialScanRequest.mIsPlatformPackage, user, null);\n                ScanPackageUtils.applyPolicy(parsedPackage, scanFlags,\n                        mPm.getPlatformPackage(), true);\n                final ScanResult scanResult =\n                        ScanPackageUtils.scanPackageOnlyLI(request, mPm.mInjector,\n                                mPm.mFactoryTest, -1L);\n                if (scanResult.mExistingSettingCopied\n                        && scanResult.mRequest.mPkgSetting != null) {\n                    scanResult.mRequest.mPkgSetting.updateFrom(scanResult.mPkgSetting);\n                }\n            }\n        } // End of mLock\n\n        final boolean newPkgChangedPaths = pkgAlreadyExists\n                && !pkgSetting.getPathString().equals(parsedPackage.getPath());\n        final boolean newPkgVersionGreater = pkgAlreadyExists\n                && parsedPackage.getLongVersionCode() > pkgSetting.getVersionCode();\n        final boolean isSystemPkgBetter = scanSystemPartition && isSystemPkgUpdated\n                && newPkgChangedPaths && newPkgVersionGreater;\n        if (isSystemPkgBetter) {\n            // The version of the application on /system is greater than the version on\n            // /data. Switch back to the application on /system.\n            // It's safe to assume the application on /system will correctly scan. If not,\n            // there won't be a working copy of the application.\n            synchronized (mPm.mLock) {\n                // just remove the loaded entries from package lists\n                mPm.mPackages.remove(pkgSetting.getPackageName());\n            }\n\n            logCriticalInfo(Log.WARN,\n                    \"System package updated;\"\n                            + \" name: \" + pkgSetting.getPackageName()\n                            + \"; \" + pkgSetting.getVersionCode() + \" --> \"\n                            + parsedPackage.getLongVersionCode()\n                            + \"; \" + pkgSetting.getPathString()\n                            + \" --> \" + parsedPackage.getPath());\n\n            final InstallArgs args = new FileInstallArgs(\n                    pkgSetting.getPathString(), getAppDexInstructionSets(\n                    pkgSetting.getPrimaryCpuAbi(), pkgSetting.getSecondaryCpuAbi()), mPm);\n            args.cleanUpResourcesLI();\n            synchronized (mPm.mLock) {\n                mPm.mSettings.enableSystemPackageLPw(pkgSetting.getPackageName());\n            }\n        }\n\n        // The version of the application on the /system partition is less than or\n        // equal to the version on the /data partition. Throw an exception and use\n        // the application already installed on the /data partition.\n        if (scanSystemPartition && isSystemPkgUpdated && !isSystemPkgBetter) {\n            // In the case of a skipped package, commitReconciledScanResultLocked is not called to\n            // add the object to the \"live\" data structures, so this is the final mutation step\n            // for the package. Which means it needs to be finalized here to cache derived fields.\n            // This is relevant for cases where the disabled system package is used for flags or\n            // other metadata.\n            parsedPackage.hideAsFinal();\n            throw new PackageManagerException(Log.WARN, \"Package \" + parsedPackage.getPackageName()\n                    + \" at \" + parsedPackage.getPath() + \" ignored: updated version \"\n                    + (pkgAlreadyExists ? String.valueOf(pkgSetting.getVersionCode()) : \"unknown\")\n                    + \" better than this \" + parsedPackage.getLongVersionCode());\n        }\n\n        // Verify certificates against what was last scanned. Force re-collecting certificate in two\n        // special cases:\n        // 1) when scanning system, force re-collect only if system is upgrading.\n        // 2) when scanning /data, force re-collect only if the app is privileged (updated from\n        // preinstall, or treated as privileged, e.g. due to shared user ID).\n        final boolean forceCollect = scanSystemPartition ? isUpgrade\n                : PackageManagerServiceUtils.isApkVerificationForced(pkgSetting);\n        if (DEBUG_VERIFY && forceCollect) {\n            Slog.d(TAG, \"Force collect certificate of \" + parsedPackage.getPackageName());\n        }\n\n        // Full APK verification can be skipped during certificate collection, only if the file is\n        // in verified partition, or can be verified on access (when apk verity is enabled). In both\n        // cases, only data in Signing Block is verified instead of the whole file.\n        final boolean skipVerify = scanSystemPartition\n                || (forceCollect && canSkipForcedPackageVerification(parsedPackage));\n        ScanPackageUtils.collectCertificatesLI(pkgSetting, parsedPackage,\n                mPm.getSettingsVersionForPackage(parsedPackage), forceCollect, skipVerify,\n                mPm.isPreNMR1Upgrade());\n\n        // Reset profile if the application version is changed\n        maybeClearProfilesForUpgradesLI(pkgSetting, parsedPackage);\n\n        /*\n         * A new system app appeared, but we already had a non-system one of the\n         * same name installed earlier.\n         */\n        boolean shouldHideSystemApp = false;\n        // A new application appeared on /system, but, we already have a copy of\n        // the application installed on /data.\n        if (scanSystemPartition && !isSystemPkgUpdated && pkgAlreadyExists\n                && !pkgSetting.isSystem()) {\n\n            if (!parsedPackage.getSigningDetails()\n                    .checkCapability(pkgSetting.getSigningDetails(),\n                            SigningDetails.CertCapabilities.INSTALLED_DATA)\n                    && !pkgSetting.getSigningDetails().checkCapability(\n                    parsedPackage.getSigningDetails(),\n                    SigningDetails.CertCapabilities.ROLLBACK)) {\n                logCriticalInfo(Log.WARN,\n                        \"System package signature mismatch;\"\n                                + \" name: \" + pkgSetting.getPackageName());\n                try (@SuppressWarnings(\"unused\") PackageFreezer freezer = mPm.freezePackage(\n                        parsedPackage.getPackageName(),\n                        \"scanPackageInternalLI\")) {\n                    DeletePackageHelper deletePackageHelper = new DeletePackageHelper(mPm);\n                    deletePackageHelper.deletePackageLIF(parsedPackage.getPackageName(), null, true,\n                            mPm.mUserManager.getUserIds(), 0, null, false);\n                }\n            } else if (newPkgVersionGreater) {\n                // The application on /system is newer than the application on /data.\n                // Simply remove the application on /data [keeping application data]\n                // and replace it with the version on /system.\n                logCriticalInfo(Log.WARN,\n                        \"System package enabled;\"\n                                + \" name: \" + pkgSetting.getPackageName()\n                                + \"; \" + pkgSetting.getVersionCode() + \" --> \"\n                                + parsedPackage.getLongVersionCode()\n                                + \"; \" + pkgSetting.getPathString() + \" --> \"\n                                + parsedPackage.getPath());\n                InstallArgs args = new FileInstallArgs(\n                        pkgSetting.getPathString(), getAppDexInstructionSets(\n                        pkgSetting.getPrimaryCpuAbi(), pkgSetting.getSecondaryCpuAbi()),\n                        mPm);\n                synchronized (mPm.mInstallLock) {\n                    args.cleanUpResourcesLI();\n                }\n            } else {\n                // The application on /system is older than the application on /data. Hide\n                // the application on /system and the version on /data will be scanned later\n                // and re-added like an update.\n                shouldHideSystemApp = true;\n                logCriticalInfo(Log.INFO,\n                        \"System package disabled;\"\n                                + \" name: \" + pkgSetting.getPackageName()\n                                + \"; old: \" + pkgSetting.getPathString() + \" @ \"\n                                + pkgSetting.getVersionCode()\n                                + \"; new: \" + parsedPackage.getPath() + \" @ \"\n                                + parsedPackage.getPath());\n            }\n        }\n\n        final ScanResult scanResult = scanPackageNewLI(parsedPackage, parseFlags,\n                scanFlags | SCAN_UPDATE_SIGNATURE, 0 /* currentTime */, user, null);\n        return new Pair<>(scanResult, shouldHideSystemApp);\n    }\n\n    /**\n     * Returns if forced apk verification can be skipped for the whole package, including splits.\n     */\n    private boolean canSkipForcedPackageVerification(AndroidPackage pkg) {\n        final String packageName = pkg.getPackageName();\n        if (!VerityUtils.hasFsverity(pkg.getBaseApkPath())) {\n            return false;\n        }\n        // TODO: Allow base and splits to be verified individually.\n        String[] splitCodePaths = pkg.getSplitCodePaths();\n        if (!ArrayUtils.isEmpty(splitCodePaths)) {\n            for (int i = 0; i < splitCodePaths.length; i++) {\n                if (!VerityUtils.hasFsverity(splitCodePaths[i])) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Clear the package profile if this was an upgrade and the package\n     * version was updated.\n     */\n    private void maybeClearProfilesForUpgradesLI(\n            @Nullable PackageSetting originalPkgSetting,\n            @NonNull AndroidPackage pkg) {\n        if (originalPkgSetting == null || !mPm.isDeviceUpgrading()) {\n            return;\n        }\n        if (originalPkgSetting.getVersionCode() == pkg.getLongVersionCode()) {\n            return;\n        }\n\n        mAppDataHelper.clearAppProfilesLIF(pkg);\n        if (DEBUG_INSTALL) {\n            Slog.d(TAG, originalPkgSetting.getPackageName()\n                    + \" clear profile due to version change \"\n                    + originalPkgSetting.getVersionCode() + \" != \"\n                    + pkg.getLongVersionCode());\n        }\n    }\n\n    /**\n     * Returns the original package setting.\n     * <p>A package can migrate its name during an update. In this scenario, a package\n     * designates a set of names that it considers as one of its original names.\n     * <p>An original package must be signed identically and it must have the same\n     * shared user [if any].\n     */\n    @GuardedBy(\"mPm.mLock\")\n    @Nullable\n    private PackageSetting getOriginalPackageLocked(@NonNull AndroidPackage pkg,\n            @Nullable String renamedPkgName) {\n        if (ScanPackageUtils.isPackageRenamed(pkg, renamedPkgName)) {\n            return null;\n        }\n        for (int i = ArrayUtils.size(pkg.getOriginalPackages()) - 1; i >= 0; --i) {\n            final PackageSetting originalPs =\n                    mPm.mSettings.getPackageLPr(pkg.getOriginalPackages().get(i));\n            if (originalPs != null) {\n                // the package is already installed under its original name...\n                // but, should we use it?\n                if (!verifyPackageUpdateLPr(originalPs, pkg)) {\n                    // the new package is incompatible with the original\n                    continue;\n                } else if (mPm.mSettings.getSharedUserSettingLPr(originalPs) != null) {\n                    final String sharedUserSettingsName =\n                            mPm.mSettings.getSharedUserSettingLPr(originalPs).name;\n                    if (!sharedUserSettingsName.equals(pkg.getSharedUserId())) {\n                        // the shared user id is incompatible with the original\n                        Slog.w(TAG, \"Unable to migrate data from \" + originalPs.getPackageName()\n                                + \" to \" + pkg.getPackageName() + \": old shared user settings name \"\n                                + sharedUserSettingsName\n                                + \" differs from \" + pkg.getSharedUserId());\n                        continue;\n                    }\n                    // TODO: Add case when shared user id is added [b/28144775]\n                } else {\n                    if (DEBUG_UPGRADE) {\n                        Log.v(TAG, \"Renaming new package \"\n                                + pkg.getPackageName() + \" to old name \"\n                                + originalPs.getPackageName());\n                    }\n                }\n                return originalPs;\n            }\n        }\n        return null;\n    }\n\n    @GuardedBy(\"mPm.mLock\")\n    private boolean verifyPackageUpdateLPr(PackageSetting oldPkg, AndroidPackage newPkg) {\n        if ((oldPkg.getFlags() & ApplicationInfo.FLAG_SYSTEM) == 0) {\n            Slog.w(TAG, \"Unable to update from \" + oldPkg.getPackageName()\n                    + \" to \" + newPkg.getPackageName()\n                    + \": old package not in system partition\");\n            return false;\n        } else if (mPm.mPackages.get(oldPkg.getPackageName()) != null) {\n            Slog.w(TAG, \"Unable to update from \" + oldPkg.getPackageName()\n                    + \" to \" + newPkg.getPackageName()\n                    + \": old package still exists\");\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Asserts the parsed package is valid according to the given policy. If the\n     * package is invalid, for whatever reason, throws {@link PackageManagerException}.\n     * <p>\n     * Implementation detail: This method must NOT have any side effects. It would\n     * ideally be static, but, it requires locks to read system state.\n     *\n     * @throws PackageManagerException If the package fails any of the validation checks\n     */\n    private void assertPackageIsValid(AndroidPackage pkg,\n            final @ParsingPackageUtils.ParseFlags int parseFlags,\n            final @PackageManagerService.ScanFlags int scanFlags)\n            throws PackageManagerException {\n        if ((parseFlags & ParsingPackageUtils.PARSE_ENFORCE_CODE) != 0) {\n            ScanPackageUtils.assertCodePolicy(pkg);\n        }\n\n        if (pkg.getPath() == null) {\n            // Bail out. The resource and code paths haven't been set.\n            throw new PackageManagerException(INSTALL_FAILED_INVALID_APK,\n                    \"Code and resource paths haven't been set correctly\");\n        }\n\n        // Check that there is an APEX package with the same name only during install/first boot\n        // after OTA.\n        final boolean isUserInstall = (scanFlags & SCAN_BOOTING) == 0;\n        final boolean isFirstBootOrUpgrade = (scanFlags & SCAN_FIRST_BOOT_OR_UPGRADE) != 0;\n        if ((isUserInstall || isFirstBootOrUpgrade)\n                && mApexManager.isApexPackage(pkg.getPackageName())) {\n            throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE,\n                    pkg.getPackageName()\n                            + \" is an APEX package and can't be installed as an APK.\");\n        }\n\n        // Make sure we're not adding any bogus keyset info\n        final KeySetManagerService ksms = mPm.mSettings.getKeySetManagerService();\n        ksms.assertScannedPackageValid(pkg);\n\n        synchronized (mPm.mLock) {\n            // The special \"android\" package can only be defined once\n            if (pkg.getPackageName().equals(\"android\")) {\n                if (mPm.getCoreAndroidApplication() != null) {\n                    Slog.w(TAG, \"*************************************************\");\n                    Slog.w(TAG, \"Core android package being redefined.  Skipping.\");\n                    Slog.w(TAG, \" codePath=\" + pkg.getPath());\n                    Slog.w(TAG, \"*************************************************\");\n                    throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE,\n                            \"Core android package being redefined.  Skipping.\");\n                }\n            }\n\n            // A package name must be unique; don't allow duplicates\n            if ((scanFlags & SCAN_NEW_INSTALL) == 0\n                    && mPm.mPackages.containsKey(pkg.getPackageName())) {\n                throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE,\n                        \"Application package \" + pkg.getPackageName()\n                                + \" already installed.  Skipping duplicate.\");\n            }\n\n            if (pkg.isStaticSharedLibrary()) {\n                // Static libs have a synthetic package name containing the version\n                // but we still want the base name to be unique.\n                if ((scanFlags & SCAN_NEW_INSTALL) == 0\n                        && mPm.mPackages.containsKey(pkg.getManifestPackageName())) {\n                    throw new PackageManagerException(\n                            \"Duplicate static shared lib provider package\");\n                }\n                ScanPackageUtils.assertStaticSharedLibraryIsValid(pkg, scanFlags);\n                assertStaticSharedLibraryVersionCodeIsValid(pkg);\n            }\n\n            // If we're only installing presumed-existing packages, require that the\n            // scanned APK is both already known and at the path previously established\n            // for it.  Previously unknown packages we pick up normally, but if we have an\n            // a priori expectation about this package's install presence, enforce it.\n            // With a singular exception for new system packages. When an OTA contains\n            // a new system package, we allow the codepath to change from a system location\n            // to the user-installed location. If we don't allow this change, any newer,\n            // user-installed version of the application will be ignored.\n            if ((scanFlags & SCAN_REQUIRE_KNOWN) != 0) {\n                if (mPm.isExpectingBetter(pkg.getPackageName())) {\n                    Slog.w(TAG, \"Relax SCAN_REQUIRE_KNOWN requirement for package \"\n                            + pkg.getPackageName());\n                } else {\n                    PackageSetting known = mPm.mSettings.getPackageLPr(pkg.getPackageName());\n                    if (known != null) {\n                        if (DEBUG_PACKAGE_SCANNING) {\n                            Log.d(TAG, \"Examining \" + pkg.getPath()\n                                    + \" and requiring known path \" + known.getPathString());\n                        }\n                        if (!pkg.getPath().equals(known.getPathString())) {\n                            throw new PackageManagerException(INSTALL_FAILED_PACKAGE_CHANGED,\n                                    \"Application package \" + pkg.getPackageName()\n                                            + \" found at \" + pkg.getPath()\n                                            + \" but expected at \" + known.getPathString()\n                                            + \"; ignoring.\");\n                        }\n                    } else {\n                        throw new PackageManagerException(INSTALL_FAILED_INVALID_INSTALL_LOCATION,\n                                \"Application package \" + pkg.getPackageName()\n                                        + \" not found; ignoring.\");\n                    }\n                }\n            }\n\n            // Verify that this new package doesn't have any content providers\n            // that conflict with existing packages.  Only do this if the\n            // package isn't already installed, since we don't want to break\n            // things that are installed.\n            if ((scanFlags & SCAN_NEW_INSTALL) != 0) {\n                mPm.mComponentResolver.assertProvidersNotDefined(pkg);\n            }\n\n            // If this package has defined explicit processes, then ensure that these are\n            // the only processes used by its components.\n            ScanPackageUtils.assertProcessesAreValid(pkg);\n\n            // Verify that packages sharing a user with a privileged app are marked as privileged.\n            assertPackageWithSharedUserIdIsPrivileged(pkg);\n\n            // Apply policies specific for runtime resource overlays (RROs).\n            if (pkg.getOverlayTarget() != null) {\n                assertOverlayIsValid(pkg, parseFlags, scanFlags);\n            }\n\n            // Ensure the package is signed with at least the minimum signature scheme version\n            // required for its target SDK.\n            ScanPackageUtils.assertMinSignatureSchemeIsValid(pkg, parseFlags);\n        }\n    }\n\n    private void assertStaticSharedLibraryVersionCodeIsValid(AndroidPackage pkg)\n            throws PackageManagerException {\n        // The version codes must be ordered as lib versions\n        long minVersionCode = Long.MIN_VALUE;\n        long maxVersionCode = Long.MAX_VALUE;\n\n        WatchedLongSparseArray<SharedLibraryInfo> versionedLib =\n                mSharedLibraries.getSharedLibraryInfos(pkg.getStaticSharedLibName());\n        if (versionedLib != null) {\n            final int versionCount = versionedLib.size();\n            for (int i = 0; i < versionCount; i++) {\n                SharedLibraryInfo libInfo = versionedLib.valueAt(i);\n                final long libVersionCode = libInfo.getDeclaringPackage()\n                        .getLongVersionCode();\n                if (libInfo.getLongVersion() < pkg.getStaticSharedLibVersion()) {\n                    minVersionCode = Math.max(minVersionCode, libVersionCode + 1);\n                } else if (libInfo.getLongVersion()\n                        > pkg.getStaticSharedLibVersion()) {\n                    maxVersionCode = Math.min(maxVersionCode, libVersionCode - 1);\n                } else {\n                    minVersionCode = maxVersionCode = libVersionCode;\n                    break;\n                }\n            }\n        }\n        if (pkg.getLongVersionCode() < minVersionCode\n                || pkg.getLongVersionCode() > maxVersionCode) {\n            throw new PackageManagerException(\"Static shared\"\n                    + \" lib version codes must be ordered as lib versions\");\n        }\n    }\n\n    private void assertOverlayIsValid(AndroidPackage pkg,\n            @ParsingPackageUtils.ParseFlags int parseFlags,\n            @PackageManagerService.ScanFlags int scanFlags) throws PackageManagerException {\n        // System overlays have some restrictions on their use of the 'static' state.\n        if ((scanFlags & SCAN_AS_SYSTEM) != 0) {\n            // We are scanning a system overlay. This can be the first scan of the\n            // system/vendor/oem partition, or an update to the system overlay.\n            if ((parseFlags & ParsingPackageUtils.PARSE_IS_SYSTEM_DIR) == 0) {\n                // This must be an update to a system overlay. Immutable overlays cannot be\n                // upgraded.\n                if (!mPm.isOverlayMutable(pkg.getPackageName())) {\n                    throw new PackageManagerException(\"Overlay \"\n                            + pkg.getPackageName()\n                            + \" is static and cannot be upgraded.\");\n                }\n            } else {\n                if ((scanFlags & SCAN_AS_VENDOR) != 0) {\n                    if (pkg.getTargetSdkVersion() < ScanPackageUtils.getVendorPartitionVersion()) {\n                        Slog.w(TAG, \"System overlay \" + pkg.getPackageName()\n                                + \" targets an SDK below the required SDK level of vendor\"\n                                + \" overlays (\"\n                                + ScanPackageUtils.getVendorPartitionVersion()\n                                + \").\"\n                                + \" This will become an install error in a future release\");\n                    }\n                } else if (pkg.getTargetSdkVersion() < Build.VERSION.SDK_INT) {\n                    Slog.w(TAG, \"System overlay \" + pkg.getPackageName()\n                            + \" targets an SDK below the required SDK level of system\"\n                            + \" overlays (\" + Build.VERSION.SDK_INT + \").\"\n                            + \" This will become an install error in a future release\");\n                }\n            }\n        } else {\n            // A non-preloaded overlay packages must have targetSdkVersion >= Q, or be\n            // signed with the platform certificate. Check this in increasing order of\n            // computational cost.\n            if (pkg.getTargetSdkVersion() < Build.VERSION_CODES.Q) {\n                final PackageSetting platformPkgSetting =\n                        mPm.mSettings.getPackageLPr(\"android\");\n                if (!comparePackageSignatures(platformPkgSetting,\n                        pkg.getSigningDetails().getSignatures())) {\n                    throw new PackageManagerException(\"Overlay \"\n                            + pkg.getPackageName()\n                            + \" must target Q or later, \"\n                            + \"or be signed with the platform certificate\");\n                }\n            }\n\n            // A non-preloaded overlay package, without <overlay android:targetName>, will\n            // only be used if it is signed with the same certificate as its target OR if\n            // it is signed with the same certificate as a reference package declared\n            // in 'overlay-config-signature' tag of SystemConfig.\n            // If the target is already installed or 'overlay-config-signature' tag in\n            // SystemConfig is set, check this here to augment the last line of defense\n            // which is OMS.\n            if (pkg.getOverlayTargetOverlayableName() == null) {\n                final PackageSetting targetPkgSetting =\n                        mPm.mSettings.getPackageLPr(pkg.getOverlayTarget());\n                if (targetPkgSetting != null) {\n                    if (!comparePackageSignatures(targetPkgSetting,\n                            pkg.getSigningDetails().getSignatures())) {\n                        // check reference signature\n                        if (mPm.mOverlayConfigSignaturePackage == null) {\n                            throw new PackageManagerException(\"Overlay \"\n                                    + pkg.getPackageName() + \" and target \"\n                                    + pkg.getOverlayTarget() + \" signed with\"\n                                    + \" different certificates, and the overlay lacks\"\n                                    + \" <overlay android:targetName>\");\n                        }\n                        final PackageSetting refPkgSetting =\n                                mPm.mSettings.getPackageLPr(\n                                        mPm.mOverlayConfigSignaturePackage);\n                        if (!comparePackageSignatures(refPkgSetting,\n                                pkg.getSigningDetails().getSignatures())) {\n                            throw new PackageManagerException(\"Overlay \"\n                                    + pkg.getPackageName() + \" signed with a different \"\n                                    + \"certificate than both the reference package and \"\n                                    + \"target \" + pkg.getOverlayTarget() + \", and the \"\n                                    + \"overlay lacks <overlay android:targetName>\");\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    private void assertPackageWithSharedUserIdIsPrivileged(AndroidPackage pkg)\n            throws PackageManagerException {\n        if (!pkg.isPrivileged() && (pkg.getSharedUserId() != null)) {\n            SharedUserSetting sharedUserSetting = null;\n            try {\n                sharedUserSetting = mPm.mSettings.getSharedUserLPw(pkg.getSharedUserId(),\n                        0, 0, false);\n            } catch (PackageManagerException ignore) {\n            }\n            if (sharedUserSetting != null && sharedUserSetting.isPrivileged()) {\n                // Exempt SharedUsers signed with the platform key.\n                PackageSetting platformPkgSetting = mPm.mSettings.getPackageLPr(\"android\");\n                if (!comparePackageSignatures(platformPkgSetting,\n                        pkg.getSigningDetails().getSignatures())) {\n                    throw new PackageManagerException(\"Apps that share a user with a \"\n                            + \"privileged app must themselves be marked as privileged. \"\n                            + pkg.getPackageName() + \" shares privileged user \"\n                            + pkg.getSharedUserId() + \".\");\n                }\n            }\n        }\n    }\n\n    private @PackageManagerService.ScanFlags int adjustScanFlags(\n            @PackageManagerService.ScanFlags int scanFlags,\n            PackageSetting pkgSetting, PackageSetting disabledPkgSetting, UserHandle user,\n            AndroidPackage pkg) {\n        scanFlags = ScanPackageUtils.adjustScanFlagsWithPackageSetting(scanFlags, pkgSetting,\n                disabledPkgSetting, user);\n\n        // Exception for privileged apps that share a user with a priv-app.\n        final boolean skipVendorPrivilegeScan = ((scanFlags & SCAN_AS_VENDOR) != 0)\n                && ScanPackageUtils.getVendorPartitionVersion() < 28;\n        if (((scanFlags & SCAN_AS_PRIVILEGED) == 0)\n                && !pkg.isPrivileged()\n                && (pkg.getSharedUserId() != null)\n                && !skipVendorPrivilegeScan\n                && !pkg.isLeavingSharedUser()) {\n            SharedUserSetting sharedUserSetting = null;\n            synchronized (mPm.mLock) {\n                try {\n                    sharedUserSetting = mPm.mSettings.getSharedUserLPw(pkg.getSharedUserId(), 0,\n                            0, false);\n                } catch (PackageManagerException ignore) {\n                }\n                if (sharedUserSetting != null && sharedUserSetting.isPrivileged()) {\n                    // Exempt SharedUsers signed with the platform key.\n                    // TODO(b/72378145) Fix this exemption. Force signature apps\n                    // to allowlist their privileged permissions just like other\n                    // priv-apps.\n                    PackageSetting platformPkgSetting = mPm.mSettings.getPackageLPr(\"android\");\n                    if ((compareSignatures(\n                            platformPkgSetting.getSigningDetails().getSignatures(),\n                            pkg.getSigningDetails().getSignatures())\n                            != PackageManager.SIGNATURE_MATCH)) {\n                        scanFlags |= SCAN_AS_PRIVILEGED;\n                    }\n                }\n            }\n        }\n\n        return scanFlags;\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 43278,
                                        "general": {
                                            "word_based": 17575,
                                            "char_based": 58403
                                        },
                                        "gemini": 49968
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "06775341ad7d77410798f95117cbee7a1a02c201",
                            "repo_path": "android_repos/base",
                            "result": "failure",
                            "downstream_patch_content": "commit 06775341ad7d77410798f95117cbee7a1a02c201\nAuthor: Alex Buynytskyy <alexbuy@google.com>\nDate:   Thu Jan 4 00:18:16 2024 +0000\n\n    Stop marking apps as privileged if they are not signed properly.\n    \n    Fixes: 311374917\n    Test: atest android.content.pm.cts.PackageManagerTest\n    Change-Id: I5b5b81cf43b06837a22c8dfd170a112106dd64c1\n    Merged-In: I5b5b81cf43b06837a22c8dfd170a112106dd64c1\n    (cherry picked from commit 3ee5dfdcba047051ce81dca0696d6ddfeafe2d98)\n\ndiff --git a/services/core/java/com/android/server/pm/InstallPackageHelper.java b/services/core/java/com/android/server/pm/InstallPackageHelper.java\nindex d0304b43215e..f26a9f8f3aed 100644\n--- a/services/core/java/com/android/server/pm/InstallPackageHelper.java\n+++ b/services/core/java/com/android/server/pm/InstallPackageHelper.java\n@@ -4742,7 +4742,9 @@ final class InstallPackageHelper {\n \n     private void assertPackageWithSharedUserIdIsPrivileged(AndroidPackage pkg)\n             throws PackageManagerException {\n-        if (!AndroidPackageUtils.isPrivileged(pkg) && (pkg.getSharedUserId() != null)) {\n+        if (!AndroidPackageUtils.isPrivileged(pkg)\n+                && (pkg.getSharedUserId() != null)\n+                && !pkg.isLeavingSharedUser()) {\n             SharedUserSetting sharedUserSetting = null;\n             try {\n                 synchronized (mPm.mLock) {\n@@ -4783,7 +4785,8 @@ final class InstallPackageHelper {\n         if (((scanFlags & SCAN_AS_PRIVILEGED) == 0)\n                 && !AndroidPackageUtils.isPrivileged(pkg)\n                 && (pkg.getSharedUserId() != null)\n-                && !skipVendorPrivilegeScan) {\n+                && !skipVendorPrivilegeScan\n+                && !pkg.isLeavingSharedUser()) {\n             SharedUserSetting sharedUserSetting = null;\n             synchronized (mPm.mLock) {\n                 try {\n",
                            "downstream_patch_tokens": {
                                "openai": 501,
                                "general": {
                                    "word_based": 159,
                                    "char_based": 460
                                },
                                "gemini": 646
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "services/core/java/com/android/server/pm/InstallPackageHelper.java",
                                    "total_hunks": 2,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [],
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    },
                                    "rej_file_content": "```diff\n--- services/core/java/com/android/server/pm/InstallPackageHelper.java\n+++ services/core/java/com/android/server/pm/InstallPackageHelper.java\n@@ -4590,7 +4590,9 @@ final class InstallPackageHelper {\n \n     private void assertPackageWithSharedUserIdIsPrivileged(AndroidPackage pkg)\n             throws PackageManagerException {\n-        if (!AndroidPackageLegacyUtils.isPrivileged(pkg) && (pkg.getSharedUserId() != null)) {\n+        if (!AndroidPackageLegacyUtils.isPrivileged(pkg)\n+                && (pkg.getSharedUserId() != null)\n+                && !pkg.isLeavingSharedUser()) {\n             SharedUserSetting sharedUserSetting = null;\n             try {\n                 synchronized (mPm.mLock) {\n```",
                                    "rej_file_tokens": {
                                        "openai": 151,
                                        "general": {
                                            "word_based": 55,
                                            "char_based": 175
                                        },
                                        "gemini": 185
                                    },
                                    "patch_apply_output": "patching file services/core/java/com/android/server/pm/InstallPackageHelper.java\nHunk #1 FAILED at 4590.\nHunk #2 succeeded at 4783 with fuzz 2 (offset 153 lines).\n1 out of 2 hunks FAILED -- saving rejects to file services/core/java/com/android/server/pm/InstallPackageHelper.java.rej",
                                    "inline_merge_output": "patching file services/core/java/com/android/server/pm/InstallPackageHelper.java\nHunk #1 already applied at 4593-4595.\nHunk #2 already applied at 4635-4636.",
                                    "upstream_file_tokens": {
                                        "openai": 45285,
                                        "general": {
                                            "word_based": 18420,
                                            "char_based": 61445
                                        },
                                        "gemini": 52272
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2021 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.pm;\n\nimport static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;\nimport static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DISABLED;\nimport static android.content.pm.PackageManager.INSTALL_FAILED_ALREADY_EXISTS;\nimport static android.content.pm.PackageManager.INSTALL_FAILED_BAD_PERMISSION_GROUP;\nimport static android.content.pm.PackageManager.INSTALL_FAILED_DEPRECATED_SDK_VERSION;\nimport static android.content.pm.PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;\nimport static android.content.pm.PackageManager.INSTALL_FAILED_DUPLICATE_PERMISSION;\nimport static android.content.pm.PackageManager.INSTALL_FAILED_DUPLICATE_PERMISSION_GROUP;\nimport static android.content.pm.PackageManager.INSTALL_FAILED_INVALID_APK;\nimport static android.content.pm.PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION;\nimport static android.content.pm.PackageManager.INSTALL_FAILED_PACKAGE_CHANGED;\nimport static android.content.pm.PackageManager.INSTALL_FAILED_SESSION_INVALID;\nimport static android.content.pm.PackageManager.INSTALL_FAILED_TEST_ONLY;\nimport static android.content.pm.PackageManager.INSTALL_FAILED_UID_CHANGED;\nimport static android.content.pm.PackageManager.INSTALL_FAILED_UPDATE_INCOMPATIBLE;\nimport static android.content.pm.PackageManager.INSTALL_REASON_DEVICE_RESTORE;\nimport static android.content.pm.PackageManager.INSTALL_REASON_DEVICE_SETUP;\nimport static android.content.pm.PackageManager.INSTALL_STAGED;\nimport static android.content.pm.PackageManager.INSTALL_SUCCEEDED;\nimport static android.content.pm.PackageManager.UNINSTALL_REASON_UNKNOWN;\nimport static android.content.pm.SigningDetails.SignatureSchemeVersion.SIGNING_BLOCK_V4;\nimport static android.content.pm.parsing.ApkLiteParseUtils.isApkFile;\nimport static android.os.PowerExemptionManager.REASON_PACKAGE_REPLACED;\nimport static android.os.Trace.TRACE_TAG_PACKAGE_MANAGER;\nimport static android.os.incremental.IncrementalManager.isIncrementalPath;\nimport static android.os.storage.StorageManager.FLAG_STORAGE_CE;\nimport static android.os.storage.StorageManager.FLAG_STORAGE_DE;\nimport static android.os.storage.StorageManager.FLAG_STORAGE_EXTERNAL;\n\nimport static com.android.server.pm.DexOptHelper.useArtService;\nimport static com.android.server.pm.InstructionSets.getAppDexInstructionSets;\nimport static com.android.server.pm.InstructionSets.getDexCodeInstructionSet;\nimport static com.android.server.pm.InstructionSets.getPreferredInstructionSet;\nimport static com.android.server.pm.PackageManagerService.APP_METADATA_FILE_NAME;\nimport static com.android.server.pm.PackageManagerService.DEBUG_BACKUP;\nimport static com.android.server.pm.PackageManagerService.DEBUG_COMPRESSION;\nimport static com.android.server.pm.PackageManagerService.DEBUG_INSTALL;\nimport static com.android.server.pm.PackageManagerService.DEBUG_PACKAGE_SCANNING;\nimport static com.android.server.pm.PackageManagerService.DEBUG_REMOVE;\nimport static com.android.server.pm.PackageManagerService.DEBUG_UPGRADE;\nimport static com.android.server.pm.PackageManagerService.DEBUG_VERIFY;\nimport static com.android.server.pm.PackageManagerService.EMPTY_INT_ARRAY;\nimport static com.android.server.pm.PackageManagerService.MIN_INSTALLABLE_TARGET_SDK;\nimport static com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME;\nimport static com.android.server.pm.PackageManagerService.POST_INSTALL;\nimport static com.android.server.pm.PackageManagerService.PRECOMPILE_LAYOUTS;\nimport static com.android.server.pm.PackageManagerService.SCAN_AS_APEX;\nimport static com.android.server.pm.PackageManagerService.SCAN_AS_APK_IN_APEX;\nimport static com.android.server.pm.PackageManagerService.SCAN_AS_FACTORY;\nimport static com.android.server.pm.PackageManagerService.SCAN_AS_FULL_APP;\nimport static com.android.server.pm.PackageManagerService.SCAN_AS_INSTANT_APP;\nimport static com.android.server.pm.PackageManagerService.SCAN_AS_ODM;\nimport static com.android.server.pm.PackageManagerService.SCAN_AS_OEM;\nimport static com.android.server.pm.PackageManagerService.SCAN_AS_PRIVILEGED;\nimport static com.android.server.pm.PackageManagerService.SCAN_AS_PRODUCT;\nimport static com.android.server.pm.PackageManagerService.SCAN_AS_STOPPED_SYSTEM_APP;\nimport static com.android.server.pm.PackageManagerService.SCAN_AS_SYSTEM;\nimport static com.android.server.pm.PackageManagerService.SCAN_AS_SYSTEM_EXT;\nimport static com.android.server.pm.PackageManagerService.SCAN_AS_VENDOR;\nimport static com.android.server.pm.PackageManagerService.SCAN_AS_VIRTUAL_PRELOAD;\nimport static com.android.server.pm.PackageManagerService.SCAN_BOOTING;\nimport static com.android.server.pm.PackageManagerService.SCAN_DONT_KILL_APP;\nimport static com.android.server.pm.PackageManagerService.SCAN_DROP_CACHE;\nimport static com.android.server.pm.PackageManagerService.SCAN_FIRST_BOOT_OR_UPGRADE;\nimport static com.android.server.pm.PackageManagerService.SCAN_IGNORE_FROZEN;\nimport static com.android.server.pm.PackageManagerService.SCAN_INITIAL;\nimport static com.android.server.pm.PackageManagerService.SCAN_MOVE;\nimport static com.android.server.pm.PackageManagerService.SCAN_NEW_INSTALL;\nimport static com.android.server.pm.PackageManagerService.SCAN_NO_DEX;\nimport static com.android.server.pm.PackageManagerService.SCAN_REQUIRE_KNOWN;\nimport static com.android.server.pm.PackageManagerService.SCAN_UPDATE_SIGNATURE;\nimport static com.android.server.pm.PackageManagerService.TAG;\nimport static com.android.server.pm.PackageManagerServiceUtils.comparePackageSignatures;\nimport static com.android.server.pm.PackageManagerServiceUtils.compareSignatures;\nimport static com.android.server.pm.PackageManagerServiceUtils.compressedFileExists;\nimport static com.android.server.pm.PackageManagerServiceUtils.deriveAbiOverride;\nimport static com.android.server.pm.PackageManagerServiceUtils.isInstalledByAdb;\nimport static com.android.server.pm.PackageManagerServiceUtils.logCriticalInfo;\nimport static com.android.server.pm.PackageManagerServiceUtils.makeDirRecursive;\nimport static com.android.server.pm.SharedUidMigration.BEST_EFFORT;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.UserIdInt;\nimport android.apex.ApexInfo;\nimport android.app.AppOpsManager;\nimport android.app.ApplicationExitInfo;\nimport android.app.ApplicationPackageManager;\nimport android.app.BroadcastOptions;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.app.backup.IBackupManager;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.DataLoaderType;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageInfoLite;\nimport android.content.pm.PackageInstaller;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PermissionGroupInfo;\nimport android.content.pm.PermissionInfo;\nimport android.content.pm.SharedLibraryInfo;\nimport android.content.pm.Signature;\nimport android.content.pm.SigningDetails;\nimport android.content.pm.VerifierInfo;\nimport android.content.pm.dex.DexMetadataHelper;\nimport android.content.pm.parsing.result.ParseResult;\nimport android.content.pm.parsing.result.ParseTypeImpl;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.FileUtils;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.SELinux;\nimport android.os.SystemProperties;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.incremental.IncrementalManager;\nimport android.os.incremental.IncrementalStorage;\nimport android.os.storage.StorageManager;\nimport android.os.storage.VolumeInfo;\nimport android.stats.storage.StorageEnums;\nimport android.system.ErrnoException;\nimport android.system.Os;\nimport android.text.TextUtils;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.EventLog;\nimport android.util.Log;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseIntArray;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.content.F2fsUtils;\nimport com.android.internal.security.VerityUtils;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.CollectionUtils;\nimport com.android.internal.util.FrameworkStatsLog;\nimport com.android.server.EventLogTags;\nimport com.android.server.LocalManagerRegistry;\nimport com.android.server.SystemConfig;\nimport com.android.server.art.model.DexoptParams;\nimport com.android.server.art.model.DexoptResult;\nimport com.android.server.pm.Installer.LegacyDexoptDisabledException;\nimport com.android.server.pm.dex.ArtManagerService;\nimport com.android.server.pm.dex.DexManager;\nimport com.android.server.pm.dex.DexoptOptions;\nimport com.android.server.pm.dex.ViewCompiler;\nimport com.android.server.pm.parsing.PackageCacher;\nimport com.android.server.pm.parsing.PackageParser2;\nimport com.android.server.pm.parsing.pkg.AndroidPackageUtils;\nimport com.android.server.pm.parsing.pkg.ParsedPackage;\nimport com.android.server.pm.permission.Permission;\nimport com.android.server.pm.permission.PermissionManagerServiceInternal;\nimport com.android.server.pm.pkg.AndroidPackage;\nimport com.android.server.pm.pkg.PackageState;\nimport com.android.server.pm.pkg.PackageStateInternal;\nimport com.android.server.pm.pkg.SharedLibraryWrapper;\nimport com.android.server.pm.pkg.component.ComponentMutateUtils;\nimport com.android.server.pm.pkg.component.ParsedActivity;\nimport com.android.server.pm.pkg.component.ParsedInstrumentation;\nimport com.android.server.pm.pkg.component.ParsedIntentInfo;\nimport com.android.server.pm.pkg.component.ParsedPermission;\nimport com.android.server.pm.pkg.component.ParsedPermissionGroup;\nimport com.android.server.pm.pkg.parsing.ParsingPackageUtils;\nimport com.android.server.rollback.RollbackManagerInternal;\nimport com.android.server.security.FileIntegrityService;\nimport com.android.server.utils.WatchedArrayMap;\nimport com.android.server.utils.WatchedLongSparseArray;\n\nimport dalvik.system.VMRuntime;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.security.DigestException;\nimport java.security.DigestInputStream;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PublicKey;\nimport java.security.cert.CertificateException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ExecutorService;\n\nfinal class InstallPackageHelper {\n    private final PackageManagerService mPm;\n    private final AppDataHelper mAppDataHelper;\n    private final BroadcastHelper mBroadcastHelper;\n    private final RemovePackageHelper mRemovePackageHelper;\n    private final IncrementalManager mIncrementalManager;\n    private final ApexManager mApexManager;\n    private final DexManager mDexManager;\n    private final ArtManagerService mArtManagerService;\n    private final Context mContext;\n    private final PackageDexOptimizer mPackageDexOptimizer;\n    private final PackageAbiHelper mPackageAbiHelper;\n    private final ViewCompiler mViewCompiler;\n    private final SharedLibrariesImpl mSharedLibraries;\n    private final PackageManagerServiceInjector mInjector;\n    private final UpdateOwnershipHelper mUpdateOwnershipHelper;\n\n    // TODO(b/198166813): remove PMS dependency\n    InstallPackageHelper(PackageManagerService pm, AppDataHelper appDataHelper) {\n        mPm = pm;\n        mInjector = pm.mInjector;\n        mAppDataHelper = appDataHelper;\n        mBroadcastHelper = new BroadcastHelper(pm.mInjector);\n        mRemovePackageHelper = new RemovePackageHelper(pm);\n        mIncrementalManager = pm.mInjector.getIncrementalManager();\n        mApexManager = pm.mInjector.getApexManager();\n        mDexManager = pm.mInjector.getDexManager();\n        mArtManagerService = pm.mInjector.getArtManagerService();\n        mContext = pm.mInjector.getContext();\n        mPackageDexOptimizer = pm.mInjector.getPackageDexOptimizer();\n        mPackageAbiHelper = pm.mInjector.getAbiHelper();\n        mViewCompiler = pm.mInjector.getViewCompiler();\n        mSharedLibraries = pm.mInjector.getSharedLibrariesImpl();\n        mUpdateOwnershipHelper = pm.mInjector.getUpdateOwnershipHelper();\n    }\n\n    InstallPackageHelper(PackageManagerService pm) {\n        this(pm, new AppDataHelper(pm));\n    }\n\n    /**\n     * Commits the package scan and modifies system state.\n     * <p><em>WARNING:</em> The method may throw an exception in the middle\n     * of committing the package, leaving the system in an inconsistent state.\n     * This needs to be fixed so, once we get to this point, no errors are\n     * possible and the system is not left in an inconsistent state.\n     */\n    @GuardedBy(\"mPm.mLock\")\n    public AndroidPackage commitReconciledScanResultLocked(\n            @NonNull ReconciledPackage reconciledPkg, int[] allUsers) {\n        final InstallRequest request = reconciledPkg.mInstallRequest;\n        // TODO(b/135203078): Move this even further away\n        ParsedPackage parsedPackage = request.getParsedPackage();\n        if (parsedPackage != null && \"android\".equals(parsedPackage.getPackageName())) {\n            // TODO(b/135203078): Move this to initial parse\n            parsedPackage.setVersionCode(mPm.getSdkVersion())\n                    .setVersionCodeMajor(0);\n        }\n\n        final @PackageManagerService.ScanFlags int scanFlags = request.getScanFlags();\n        final PackageSetting oldPkgSetting = request.getScanRequestOldPackageSetting();\n        final PackageSetting originalPkgSetting = request.getScanRequestOriginalPackageSetting();\n        final String realPkgName = request.getRealPackageName();\n        final List<String> changedAbiCodePath =\n                useArtService() ? null : request.getChangedAbiCodePath();\n        final PackageSetting pkgSetting;\n        if (request.getScanRequestPackageSetting() != null) {\n            SharedUserSetting requestSharedUserSetting = mPm.mSettings.getSharedUserSettingLPr(\n                    request.getScanRequestPackageSetting());\n            SharedUserSetting resultSharedUserSetting = mPm.mSettings.getSharedUserSettingLPr(\n                    request.getScannedPackageSetting());\n            if (requestSharedUserSetting != null\n                    && requestSharedUserSetting != resultSharedUserSetting) {\n                // shared user changed, remove from old shared user\n                requestSharedUserSetting.removePackage(request.getScanRequestPackageSetting());\n                // Prune unused SharedUserSetting\n                if (mPm.mSettings.checkAndPruneSharedUserLPw(requestSharedUserSetting, false)) {\n                    // Set the app ID in removed info for UID_REMOVED broadcasts\n                    request.setRemovedAppId(requestSharedUserSetting.mAppId);\n                }\n            }\n        }\n        if (request.isExistingSettingCopied()) {\n            pkgSetting = request.getScanRequestPackageSetting();\n            pkgSetting.updateFrom(request.getScannedPackageSetting());\n        } else {\n            pkgSetting = request.getScannedPackageSetting();\n            if (originalPkgSetting != null) {\n                mPm.mSettings.addRenamedPackageLPw(\n                        AndroidPackageUtils.getRealPackageOrNull(parsedPackage,\n                                pkgSetting.isSystem()),\n                        originalPkgSetting.getPackageName());\n                mPm.mTransferredPackages.add(originalPkgSetting.getPackageName());\n            } else {\n                mPm.mSettings.removeRenamedPackageLPw(parsedPackage.getPackageName());\n            }\n        }\n        SharedUserSetting sharedUserSetting = mPm.mSettings.getSharedUserSettingLPr(pkgSetting);\n        if (sharedUserSetting != null) {\n            sharedUserSetting.addPackage(pkgSetting);\n            if (parsedPackage.isLeavingSharedUser()\n                    && SharedUidMigration.applyStrategy(BEST_EFFORT)\n                    && sharedUserSetting.isSingleUser()) {\n                // Attempt the transparent shared UID migration\n                mPm.mSettings.convertSharedUserSettingsLPw(sharedUserSetting);\n            }\n        }\n        if (request.isForceQueryableOverride()) {\n            pkgSetting.setForceQueryableOverride(true);\n        }\n\n        InstallSource installSource = request.getInstallSource();\n        final boolean isApex = (scanFlags & SCAN_AS_APEX) != 0;\n        final boolean pkgAlreadyExists = oldPkgSetting != null;\n        final String oldUpdateOwner =\n                pkgAlreadyExists ? oldPkgSetting.getInstallSource().mUpdateOwnerPackageName : null;\n        final String updateOwnerFromSysconfig = isApex || !pkgSetting.isSystem() ? null\n                : mPm.mInjector.getSystemConfig().getSystemAppUpdateOwnerPackageName(\n                        parsedPackage.getPackageName());\n        final boolean isUpdateOwnershipDenylisted =\n                mUpdateOwnershipHelper.isUpdateOwnershipDenylisted(parsedPackage.getPackageName());\n        final boolean isUpdateOwnershipEnabled = oldUpdateOwner != null;\n\n        // For standard install (install via session), the installSource isn't null.\n        if (installSource != null) {\n            // If this is part of a standard install, set the initiating package name, else rely on\n            // previous device state.\n            if (!isInstalledByAdb(installSource.mInitiatingPackageName)) {\n                final PackageSetting ips = mPm.mSettings.getPackageLPr(\n                        installSource.mInitiatingPackageName);\n                if (ips != null) {\n                    installSource = installSource.setInitiatingPackageSignatures(\n                            ips.getSignatures());\n                }\n            }\n\n            // Handle the update ownership enforcement for APK\n            if (!isApex) {\n                // User installer UID as \"current\" userId if present; otherwise, use the userId\n                // from InstallRequest.\n                final int userId = installSource.mInstallerPackageUid != Process.INVALID_UID\n                        ? UserHandle.getUserId(installSource.mInstallerPackageUid)\n                        : request.getUserId();\n                // Whether the parsedPackage is installed on the userId\n                // If the oldPkgSetting doesn't exist, this package isn't installed for all users.\n                final boolean isUpdate = pkgAlreadyExists && (userId >= UserHandle.USER_SYSTEM\n                        // If userID >= 0, we could check via oldPkgSetting.getInstalled(userId).\n                        ? oldPkgSetting.getInstalled(userId)\n                        // When userId is -1 (USER_ALL) and it's not installed for any user,\n                        // treat it as not installed.\n                        : oldPkgSetting.getNotInstalledUserIds().length\n                                <= (UserManager.isHeadlessSystemUserMode() ? 1 : 0));\n                final boolean isRequestUpdateOwnership = (request.getInstallFlags()\n                        & PackageManager.INSTALL_REQUEST_UPDATE_OWNERSHIP) != 0;\n                final boolean isSameUpdateOwner =\n                        TextUtils.equals(oldUpdateOwner, installSource.mInstallerPackageName);\n                final boolean isInstallerUpdateOwnerDenylistProvider =\n                        mUpdateOwnershipHelper.isUpdateOwnershipDenyListProvider(\n                                installSource.mUpdateOwnerPackageName);\n\n                // Here we handle the update owner for the package, and the rules are:\n                // -. Only enabling update ownership enforcement on initial installation if the\n                //    installer has requested.\n                // -. Once the installer changes and users agree to proceed, clear the update\n                //    owner (package state in other users are taken into account as well).\n                if (!isUpdate) {\n                    if (!isRequestUpdateOwnership\n                            || isUpdateOwnershipDenylisted\n                            || isInstallerUpdateOwnerDenylistProvider) {\n                        installSource = installSource.setUpdateOwnerPackageName(null);\n                    } else if ((!isUpdateOwnershipEnabled && pkgAlreadyExists)\n                            || (isUpdateOwnershipEnabled && !isSameUpdateOwner)) {\n                        installSource = installSource.setUpdateOwnerPackageName(null);\n                    }\n                } else if (!isSameUpdateOwner\n                        || !isUpdateOwnershipEnabled) {\n                    installSource = installSource.setUpdateOwnerPackageName(null);\n                }\n            }\n\n            pkgSetting.setInstallSource(installSource);\n        // For non-standard install (addForInit), installSource is null.\n        } else if (pkgSetting.isSystem()) {\n            // We still honor the manifest attr if the system app wants to opt-out of it.\n            final boolean isSameUpdateOwner = isUpdateOwnershipEnabled\n                    && TextUtils.equals(oldUpdateOwner, updateOwnerFromSysconfig);\n\n            // Here we handle the update owner for the system package, and the rules are:\n            // -. We use the update owner from sysconfig as the initial value.\n            // -. Once an app becomes to system app later via OTA, only retains the update\n            //    owner if it's consistence with sysconfig.\n            // -. Clear the update owner when update owner changes from sysconfig.\n            if (!pkgAlreadyExists || isSameUpdateOwner) {\n                pkgSetting.setUpdateOwnerPackage(updateOwnerFromSysconfig);\n            } else {\n                pkgSetting.setUpdateOwnerPackage(null);\n            }\n        }\n\n        if ((scanFlags & SCAN_AS_APK_IN_APEX) != 0) {\n            boolean isFactory = (scanFlags & SCAN_AS_FACTORY) != 0;\n            pkgSetting.getPkgState().setApkInUpdatedApex(!isFactory);\n        }\n\n        pkgSetting.getPkgState().setApexModuleName(request.getApexModuleName());\n\n        // TODO(toddke): Consider a method specifically for modifying the Package object\n        // post scan; or, moving this stuff out of the Package object since it has nothing\n        // to do with the package on disk.\n        // We need to have this here because addUserToSettingLPw() is sometimes responsible\n        // for creating the application ID. If we did this earlier, we would be saving the\n        // correct ID.\n        parsedPackage.setUid(pkgSetting.getAppId());\n        final AndroidPackage pkg = parsedPackage.hideAsFinal();\n\n        mPm.mSettings.writeUserRestrictionsLPw(pkgSetting, oldPkgSetting);\n\n        if (realPkgName != null) {\n            mPm.mTransferredPackages.add(pkg.getPackageName());\n        }\n\n        if (reconciledPkg.mCollectedSharedLibraryInfos != null\n                || (oldPkgSetting != null\n                && !oldPkgSetting.getSharedLibraryDependencies().isEmpty())) {\n            // Reconcile if the new package or the old package uses shared libraries.\n            // It is possible that the old package uses shared libraries but the new one doesn't.\n            mSharedLibraries.executeSharedLibrariesUpdate(pkg, pkgSetting, null, null,\n                    reconciledPkg.mCollectedSharedLibraryInfos, allUsers);\n        }\n\n        final KeySetManagerService ksms = mPm.mSettings.getKeySetManagerService();\n        if (reconciledPkg.mRemoveAppKeySetData) {\n            ksms.removeAppKeySetDataLPw(pkg.getPackageName());\n        }\n        if (reconciledPkg.mSharedUserSignaturesChanged) {\n            sharedUserSetting.signaturesChanged = Boolean.TRUE;\n            sharedUserSetting.signatures.mSigningDetails = reconciledPkg.mSigningDetails;\n        }\n        pkgSetting.setSigningDetails(reconciledPkg.mSigningDetails);\n\n        // The conditional on useArtService() for changedAbiCodePath above means this is skipped\n        // when ART Service is in use, since it has its own dex file GC.\n        if (changedAbiCodePath != null && changedAbiCodePath.size() > 0) {\n            for (int i = changedAbiCodePath.size() - 1; i >= 0; --i) {\n                final String codePathString = changedAbiCodePath.get(i);\n                try {\n                    synchronized (mPm.mInstallLock) {\n                        mPm.mInstaller.rmdex(codePathString,\n                                getDexCodeInstructionSet(getPreferredInstructionSet()));\n                    }\n                } catch (LegacyDexoptDisabledException e) {\n                    throw new RuntimeException(e);\n                } catch (Installer.InstallerException ignored) {\n                }\n            }\n        }\n\n        final int userId = request.getUserId();\n        // Modify state for the given package setting\n        commitPackageSettings(pkg, pkgSetting, oldPkgSetting, reconciledPkg);\n        if (pkgSetting.getInstantApp(userId)) {\n            mPm.mInstantAppRegistry.addInstantApp(userId, pkgSetting.getAppId());\n        }\n\n        if (!IncrementalManager.isIncrementalPath(pkgSetting.getPathString())) {\n            pkgSetting.setLoadingProgress(1f);\n        }\n\n        ArraySet<String> listItems = mUpdateOwnershipHelper.readUpdateOwnerDenyList(pkgSetting);\n        if (listItems != null && !listItems.isEmpty()) {\n            mUpdateOwnershipHelper.addToUpdateOwnerDenyList(pkgSetting.getPackageName(), listItems);\n            for (String unownedPackage : listItems) {\n                PackageSetting unownedSetting = mPm.mSettings.getPackageLPr(unownedPackage);\n                SystemConfig config = SystemConfig.getInstance();\n                if (unownedSetting != null\n                        && config.getSystemAppUpdateOwnerPackageName(unownedPackage) == null) {\n                    unownedSetting.setUpdateOwnerPackage(null);\n                }\n            }\n        }\n\n        return pkg;\n    }\n\n    /**\n     * Adds a scanned package to the system. When this method is finished, the package will\n     * be available for query, resolution, etc...\n     */\n    private void commitPackageSettings(@NonNull AndroidPackage pkg,\n            @NonNull PackageSetting pkgSetting, @Nullable PackageSetting oldPkgSetting,\n            ReconciledPackage reconciledPkg) {\n        final String pkgName = pkg.getPackageName();\n        final InstallRequest request = reconciledPkg.mInstallRequest;\n        final AndroidPackage oldPkg = request.getScanRequestOldPackage();\n        final int scanFlags = request.getScanFlags();\n        final boolean chatty = (request.getParseFlags() & ParsingPackageUtils.PARSE_CHATTY) != 0;\n        if (mPm.mCustomResolverComponentName != null\n                && mPm.mCustomResolverComponentName.getPackageName().equals(pkg.getPackageName())) {\n            mPm.setUpCustomResolverActivity(pkg, pkgSetting);\n        }\n\n        if (pkg.getPackageName().equals(\"android\")) {\n            mPm.setPlatformPackage(pkg, pkgSetting);\n        }\n\n        // writer\n        ArrayList<AndroidPackage> clientLibPkgs =\n                mSharedLibraries.commitSharedLibraryChanges(pkg, pkgSetting,\n                        reconciledPkg.mAllowedSharedLibraryInfos,\n                        reconciledPkg.getCombinedAvailablePackages(), scanFlags);\n\n        request.setLibraryConsumers(clientLibPkgs);\n\n        if ((scanFlags & SCAN_BOOTING) != 0) {\n            // No apps can run during boot scan, so they don't need to be frozen\n        } else if ((scanFlags & SCAN_DONT_KILL_APP) != 0) {\n            // Caller asked to not kill app, so it's probably not frozen\n        } else if ((scanFlags & SCAN_IGNORE_FROZEN) != 0) {\n            // Caller asked us to ignore frozen check for some reason; they\n            // probably didn't know the package name\n        } else {\n            // We're doing major surgery on this package, so it better be frozen\n            // right now to keep it from launching\n            mPm.snapshotComputer().checkPackageFrozen(pkgName);\n        }\n\n        final boolean isReplace = request.isInstallReplace();\n        // Also need to kill any apps that are dependent on the library, except the case of\n        // installation of new version static shared library.\n        if (clientLibPkgs != null) {\n            if (pkg.getStaticSharedLibraryName() == null || isReplace) {\n                for (int i = 0; i < clientLibPkgs.size(); i++) {\n                    AndroidPackage clientPkg = clientLibPkgs.get(i);\n                    String packageName = clientPkg.getPackageName();\n                    mPm.killApplication(packageName,\n                            clientPkg.getUid(), \"update lib\",\n                            ApplicationExitInfo.REASON_DEPENDENCY_DIED);\n                }\n            }\n        }\n\n        // writer\n        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"updateSettings\");\n\n        synchronized (mPm.mLock) {\n            // We don't expect installation to fail beyond this point\n            // Add the new setting to mSettings\n            mPm.mSettings.insertPackageSettingLPw(pkgSetting, pkg);\n            // Add the new setting to mPackages\n            mPm.mPackages.put(pkg.getPackageName(), pkg);\n            if ((scanFlags & SCAN_AS_APK_IN_APEX) != 0) {\n                mApexManager.registerApkInApex(pkg);\n            }\n\n            // Don't add keysets for APEX as their package settings are not persisted and will\n            // result in orphaned keysets.\n            if ((scanFlags & SCAN_AS_APEX) == 0) {\n                // Add the package's KeySets to the global KeySetManagerService\n                KeySetManagerService ksms = mPm.mSettings.getKeySetManagerService();\n                ksms.addScannedPackageLPw(pkg);\n            }\n\n            final Computer snapshot = mPm.snapshotComputer();\n            mPm.mComponentResolver.addAllComponents(pkg, chatty, mPm.mSetupWizardPackage, snapshot);\n            mPm.mAppsFilter.addPackage(snapshot, pkgSetting, isReplace,\n                    (scanFlags & SCAN_DONT_KILL_APP) != 0 /* retainImplicitGrantOnReplace */);\n            mPm.addAllPackageProperties(pkg);\n\n            if (oldPkgSetting == null || oldPkgSetting.getPkg() == null) {\n                mPm.mDomainVerificationManager.addPackage(pkgSetting);\n            } else {\n                mPm.mDomainVerificationManager.migrateState(oldPkgSetting, pkgSetting);\n            }\n\n            int collectionSize = ArrayUtils.size(pkg.getInstrumentations());\n            StringBuilder r = null;\n            int i;\n            for (i = 0; i < collectionSize; i++) {\n                ParsedInstrumentation a = pkg.getInstrumentations().get(i);\n                ComponentMutateUtils.setPackageName(a, pkg.getPackageName());\n                mPm.addInstrumentation(a.getComponentName(), a);\n                if (chatty) {\n                    if (r == null) {\n                        r = new StringBuilder(256);\n                    } else {\n                        r.append(' ');\n                    }\n                    r.append(a.getName());\n                }\n            }\n            if (r != null) {\n                if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, \"  Instrumentation: \" + r);\n            }\n\n            final List<String> protectedBroadcasts = pkg.getProtectedBroadcasts();\n            if (!protectedBroadcasts.isEmpty()) {\n                synchronized (mPm.mProtectedBroadcasts) {\n                    mPm.mProtectedBroadcasts.addAll(protectedBroadcasts);\n                }\n            }\n\n            mPm.mPermissionManager.onPackageAdded(pkgSetting,\n                    (scanFlags & SCAN_AS_INSTANT_APP) != 0, oldPkg);\n        }\n\n        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n    }\n\n    public Pair<Integer, IntentSender> installExistingPackageAsUser(@Nullable String packageName,\n            @UserIdInt int userId, @PackageManager.InstallFlags int installFlags,\n            @PackageManager.InstallReason int installReason,\n            @Nullable List<String> allowlistedRestrictedPermissions,\n            @Nullable IntentSender intentSender) {\n        if (DEBUG_INSTALL) {\n            Log.v(TAG, \"installExistingPackageAsUser package=\" + packageName + \" userId=\" + userId\n                    + \" installFlags=\" + installFlags + \" installReason=\" + installReason\n                    + \" allowlistedRestrictedPermissions=\" + allowlistedRestrictedPermissions);\n        }\n\n        final int callingUid = Binder.getCallingUid();\n        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.INSTALL_PACKAGES)\n                != PackageManager.PERMISSION_GRANTED\n                && mContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.INSTALL_EXISTING_PACKAGES)\n                != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"Neither user \" + callingUid + \" nor current process has \"\n                    + android.Manifest.permission.INSTALL_PACKAGES + \".\");\n        }\n        PackageSetting pkgSetting;\n        final Computer preLockSnapshot = mPm.snapshotComputer();\n        preLockSnapshot.enforceCrossUserPermission(callingUid, userId,\n                true /* requireFullPermission */, true /* checkShell */,\n                \"installExistingPackage for user \" + userId);\n        if (mPm.isUserRestricted(userId, UserManager.DISALLOW_INSTALL_APPS)) {\n            return Pair.create(PackageManager.INSTALL_FAILED_USER_RESTRICTED, intentSender);\n        }\n\n        final long callingId = Binder.clearCallingIdentity();\n        try {\n            boolean installed = false;\n            final boolean instantApp =\n                    (installFlags & PackageManager.INSTALL_INSTANT_APP) != 0;\n            final boolean fullApp =\n                    (installFlags & PackageManager.INSTALL_FULL_APP) != 0;\n\n            // writer\n            synchronized (mPm.mLock) {\n                final Computer snapshot = mPm.snapshotComputer();\n                pkgSetting = mPm.mSettings.getPackageLPr(packageName);\n                if (pkgSetting == null || pkgSetting.getPkg() == null) {\n                    return Pair.create(PackageManager.INSTALL_FAILED_INVALID_URI, intentSender);\n                }\n                if (instantApp && (pkgSetting.isSystem() || pkgSetting.isUpdatedSystemApp())) {\n                    return Pair.create(PackageManager.INSTALL_FAILED_INVALID_URI, intentSender);\n                }\n                if (!snapshot.canViewInstantApps(callingUid, UserHandle.getUserId(callingUid))) {\n                    // only allow the existing package to be used if it's installed as a full\n                    // application for at least one user\n                    boolean installAllowed = false;\n                    for (int checkUserId : mPm.mUserManager.getUserIds()) {\n                        installAllowed = !pkgSetting.getInstantApp(checkUserId);\n                        if (installAllowed) {\n                            break;\n                        }\n                    }\n                    if (!installAllowed) {\n                        return Pair.create(PackageManager.INSTALL_FAILED_INVALID_URI, intentSender);\n                    }\n                }\n                if (!pkgSetting.getInstalled(userId)) {\n                    pkgSetting.setInstalled(true, userId);\n                    pkgSetting.setHidden(false, userId);\n                    pkgSetting.setInstallReason(installReason, userId);\n                    pkgSetting.setUninstallReason(PackageManager.UNINSTALL_REASON_UNKNOWN, userId);\n                    pkgSetting.setFirstInstallTime(System.currentTimeMillis(), userId);\n                    mPm.mSettings.writePackageRestrictionsLPr(userId);\n                    mPm.mSettings.writeKernelMappingLPr(pkgSetting);\n                    installed = true;\n                } else if (fullApp && pkgSetting.getInstantApp(userId)) {\n                    // upgrade app from instant to full; we don't allow app downgrade\n                    installed = true;\n                }\n                ScanPackageUtils.setInstantAppForUser(mPm.mInjector, pkgSetting, userId, instantApp,\n                        fullApp);\n            }\n\n            if (installed) {\n                final String updateOwner = pkgSetting.getInstallSource().mUpdateOwnerPackageName;\n                final var dpmi = mInjector.getLocalService(DevicePolicyManagerInternal.class);\n                final boolean isFromManagedUserOrProfile =\n                        dpmi != null && dpmi.isUserOrganizationManaged(userId);\n                // Here we handle the update owner when install existing package, and the rules are:\n                // -. Retain the update owner when enable a system app in managed user or profile.\n                // -. Retain the update owner if the installer is the same.\n                // -. Clear the update owner when update owner changes.\n                if (!preLockSnapshot.isCallerSameApp(updateOwner, callingUid)\n                        && (!pkgSetting.isSystem() || !isFromManagedUserOrProfile)) {\n                    pkgSetting.setUpdateOwnerPackage(null);\n                }\n                if (pkgSetting.getPkg() != null) {\n                    final PermissionManagerServiceInternal.PackageInstalledParams.Builder\n                            permissionParamsBuilder =\n                            new PermissionManagerServiceInternal.PackageInstalledParams.Builder();\n                    if ((installFlags & PackageManager.INSTALL_ALL_WHITELIST_RESTRICTED_PERMISSIONS)\n                            != 0) {\n                        permissionParamsBuilder.setAllowlistedRestrictedPermissions(\n                                pkgSetting.getPkg().getRequestedPermissions());\n                    }\n                    mPm.mPermissionManager.onPackageInstalled(pkgSetting.getPkg(),\n                            Process.INVALID_UID /* previousAppId */,\n                            permissionParamsBuilder.build(), userId);\n\n                    synchronized (mPm.mInstallLock) {\n                        // We don't need to freeze for a brand new install\n                        mAppDataHelper.prepareAppDataAfterInstallLIF(pkgSetting.getPkg());\n                    }\n                }\n                mPm.sendPackageAddedForUser(mPm.snapshotComputer(), packageName, pkgSetting, userId,\n                        DataLoaderType.NONE);\n                synchronized (mPm.mLock) {\n                    mPm.updateSequenceNumberLP(pkgSetting, new int[]{ userId });\n                }\n                // start async restore with no post-install since we finish install here\n\n                final IntentSender onCompleteSender = intentSender;\n                intentSender = null;\n\n                InstallRequest request = new InstallRequest(userId,\n                        PackageManager.INSTALL_SUCCEEDED, pkgSetting.getPkg(), new int[]{ userId },\n                        () -> {\n                            mPm.restorePermissionsAndUpdateRolesForNewUserInstall(packageName,\n                                    userId);\n                            if (onCompleteSender != null) {\n                                onInstallComplete(PackageManager.INSTALL_SUCCEEDED, mContext,\n                                        onCompleteSender);\n                            }\n                        });\n                restoreAndPostInstall(request);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(callingId);\n        }\n\n        return Pair.create(PackageManager.INSTALL_SUCCEEDED, intentSender);\n    }\n\n    static void onInstallComplete(int returnCode, Context context, IntentSender target) {\n        Intent fillIn = new Intent();\n        fillIn.putExtra(PackageInstaller.EXTRA_STATUS,\n                PackageManager.installStatusToPublicStatus(returnCode));\n        try {\n            final BroadcastOptions options = BroadcastOptions.makeBasic();\n            options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n            target.sendIntent(context, 0, fillIn, null /* onFinished*/, null /* handler */,\n                    null /* requiredPermission */, options.toBundle());\n        } catch (IntentSender.SendIntentException ignored) {\n        }\n    }\n\n    public void restoreAndPostInstall(InstallRequest request) {\n        final int userId = request.getUserId();\n        if (DEBUG_INSTALL) {\n            Log.v(TAG,\n                    \"restoreAndPostInstall userId=\" + userId + \" package=\" + request.getPkg());\n        }\n\n        // A restore should be requested at this point if (a) the install\n        // succeeded, (b) the operation is not an update.\n        final boolean update = request.isUpdate();\n        boolean doRestore = !update && request.getPkg() != null;\n\n        // Set up the post-install work request bookkeeping.  This will be used\n        // and cleaned up by the post-install event handling regardless of whether\n        // there's a restore pass performed.  Token values are >= 1.\n        int token;\n        if (mPm.mNextInstallToken < 0) mPm.mNextInstallToken = 1;\n        token = mPm.mNextInstallToken++;\n        mPm.mRunningInstalls.put(token, request);\n\n        if (DEBUG_INSTALL) Log.v(TAG, \"+ starting restore round-trip \" + token);\n\n        if (request.getReturnCode() == PackageManager.INSTALL_SUCCEEDED && doRestore) {\n            // Pass responsibility to the Backup Manager.  It will perform a\n            // restore if appropriate, then pass responsibility back to the\n            // Package Manager to run the post-install observer callbacks\n            // and broadcasts.\n            request.closeFreezer();\n            doRestore = performBackupManagerRestore(userId, token, request);\n        }\n\n        // If this is an update to a package that might be potentially downgraded, then we\n        // need to check with the rollback manager whether there's any userdata that might\n        // need to be snapshotted or restored for the package.\n        //\n        // TODO(narayan): Get this working for cases where userId == UserHandle.USER_ALL.\n        if (request.getReturnCode() == PackageManager.INSTALL_SUCCEEDED && !doRestore && update) {\n            doRestore = performRollbackManagerRestore(userId, token, request);\n        }\n\n        if (!doRestore) {\n            // No restore possible, or the Backup Manager was mysteriously not\n            // available -- just fire the post-install work request directly.\n            if (DEBUG_INSTALL) Log.v(TAG, \"No restore - queue post-install for \" + token);\n\n            Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, \"postInstall\", token);\n\n            Message msg = mPm.mHandler.obtainMessage(POST_INSTALL, token, 0);\n            mPm.mHandler.sendMessage(msg);\n        }\n    }\n\n    /**\n     * Perform Backup Manager restore for a given {@link InstallRequest}.\n     * Returns whether the restore successfully completed.\n     */\n    private boolean performBackupManagerRestore(int userId, int token, InstallRequest request) {\n        if (request.getPkg() == null) {\n            return false;\n        }\n        IBackupManager iBackupManager = mInjector.getIBackupManager();\n        if (iBackupManager != null) {\n            // For backwards compatibility as USER_ALL previously routed directly to USER_SYSTEM\n            // in the BackupManager. USER_ALL is used in compatibility tests.\n            if (userId == UserHandle.USER_ALL) {\n                userId = UserHandle.USER_SYSTEM;\n            }\n            if (DEBUG_INSTALL) {\n                Log.v(TAG, \"token \" + token + \" to BM for possible restore for user \" + userId);\n            }\n            Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, \"restore\", token);\n            try {\n                if (iBackupManager.isUserReadyForBackup(userId)) {\n                    iBackupManager.restoreAtInstallForUser(\n                            userId, request.getPkg().getPackageName(), token);\n                } else {\n                    Slog.w(TAG, \"User \" + userId + \" is not ready. Restore at install \"\n                            + \"didn't take place.\");\n                    return false;\n                }\n            } catch (RemoteException e) {\n                // can't happen; the backup manager is local\n            } catch (Exception e) {\n                Slog.e(TAG, \"Exception trying to enqueue restore\", e);\n                return false;\n            }\n        } else {\n            Slog.e(TAG, \"Backup Manager not found!\");\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Perform Rollback Manager restore for a given {@link InstallRequest}.\n     * Returns whether the restore successfully completed.\n     */\n    private boolean performRollbackManagerRestore(int userId, int token, InstallRequest request) {\n        if (request.getPkg() == null) {\n            return false;\n        }\n        final String packageName = request.getPkg().getPackageName();\n        final int[] allUsers = mPm.mUserManager.getUserIds();\n        final int[] installedUsers;\n\n        final PackageSetting ps;\n        int appId = -1;\n        long ceDataInode = -1;\n        synchronized (mPm.mLock) {\n            ps = mPm.mSettings.getPackageLPr(packageName);\n            if (ps != null) {\n                appId = ps.getAppId();\n                ceDataInode = ps.getCeDataInode(userId);\n                // NOTE: We ignore the user specified in the InstallParam because we know this is\n                // an update, and hence need to restore data for all installed users.\n                installedUsers = ps.queryInstalledUsers(allUsers, true);\n            } else {\n                installedUsers = new int[0];\n            }\n        }\n\n        final int installFlags = request.getInstallFlags();\n        boolean doSnapshotOrRestore = ((installFlags & PackageManager.INSTALL_ENABLE_ROLLBACK) != 0\n                || (installFlags & PackageManager.INSTALL_REQUEST_DOWNGRADE) != 0);\n\n        if (ps != null && doSnapshotOrRestore) {\n            final String seInfo = ps.getSeInfo();\n            final RollbackManagerInternal rollbackManager =\n                    mInjector.getLocalService(RollbackManagerInternal.class);\n            rollbackManager.snapshotAndRestoreUserData(packageName,\n                    UserHandle.toUserHandles(installedUsers), appId, ceDataInode, seInfo, token);\n            return true;\n        }\n        return false;\n    }\n\n    void installPackagesTraced(List<InstallRequest> requests) {\n        synchronized (mPm.mInstallLock) {\n            try {\n                Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"installPackages\");\n                installPackagesLI(requests);\n            } finally {\n                Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n            }\n        }\n    }\n\n    /**\n     * Installs one or more packages atomically. This operation is broken up into four phases:\n     * <ul>\n     *     <li><b>Prepare</b>\n     *         <br/>Analyzes any current install state, parses the package and does initial\n     *         validation on it.</li>\n     *     <li><b>Scan</b>\n     *         <br/>Interrogates the parsed packages given the context collected in prepare.</li>\n     *     <li><b>Reconcile</b>\n     *         <br/>Validates scanned packages in the context of each other and the current system\n     *         state to ensure that the install will be successful.\n     *     <li><b>Commit</b>\n     *         <br/>Commits all scanned packages and updates system state. This is the only place\n     *         that system state may be modified in the install flow and all predictable errors\n     *         must be determined before this phase.</li>\n     * </ul>\n     *\n     * Failure at any phase will result in a full failure to install all packages.\n     */\n    @GuardedBy(\"mPm.mInstallLock\")\n    private void installPackagesLI(List<InstallRequest> requests) {\n        final Set<String> scannedPackages = new ArraySet<>(requests.size());\n        final Map<String, Settings.VersionInfo> versionInfos = new ArrayMap<>(requests.size());\n        final Map<String, Boolean> createdAppId = new ArrayMap<>(requests.size());\n        boolean success = false;\n        try {\n            Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"installPackagesLI\");\n            for (InstallRequest request : requests) {\n                try {\n                    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"preparePackage\");\n                    request.onPrepareStarted();\n                    preparePackageLI(request);\n                } catch (PrepareFailure prepareFailure) {\n                    request.setError(prepareFailure.error,\n                            prepareFailure.getMessage());\n                    request.setOriginPackage(prepareFailure.mConflictingPackage);\n                    request.setOriginPermission(prepareFailure.mConflictingPermission);\n                    return;\n                } finally {\n                    request.onPrepareFinished();\n                    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n                }\n\n                final ParsedPackage packageToScan = request.getParsedPackage();\n                if (packageToScan == null) {\n                    request.setError(INSTALL_FAILED_SESSION_INVALID,\n                            \"Failed to obtain package to scan\");\n                    return;\n                }\n                request.setReturnCode(PackageManager.INSTALL_SUCCEEDED);\n                final String packageName = packageToScan.getPackageName();\n                try {\n                    request.onScanStarted();\n                    final ScanResult scanResult = scanPackageTracedLI(request.getParsedPackage(),\n                            request.getParseFlags(), request.getScanFlags(),\n                            System.currentTimeMillis(), request.getUser(),\n                            request.getAbiOverride());\n                    request.setScanResult(scanResult);\n                    request.onScanFinished();\n                    if (!scannedPackages.add(packageName)) {\n                        request.setError(\n                                PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE,\n                                \"Duplicate package \"\n                                        + packageName\n                                        + \" in multi-package install request.\");\n                        return;\n                    }\n                    if (!checkNoAppStorageIsConsistent(\n                            request.getScanRequestOldPackage(), packageToScan)) {\n                        // TODO: INSTALL_FAILED_UPDATE_INCOMPATIBLE is about incomptabible\n                        //  signatures. Is there a better error code?\n                        request.setError(\n                                INSTALL_FAILED_UPDATE_INCOMPATIBLE,\n                                \"Update attempted to change value of \"\n                                        + PackageManager.PROPERTY_NO_APP_DATA_STORAGE);\n                        return;\n                    }\n                    final boolean isApex = (request.getScanFlags() & SCAN_AS_APEX) != 0;\n                    if (!isApex) {\n                        createdAppId.put(packageName, optimisticallyRegisterAppId(request));\n                    } else {\n                        request.getScannedPackageSetting().setAppId(Process.INVALID_UID);\n                    }\n                    versionInfos.put(packageName,\n                            mPm.getSettingsVersionForPackage(packageToScan));\n                } catch (PackageManagerException e) {\n                    request.setError(\"Scanning Failed.\", e);\n                    return;\n                }\n            }\n\n            List<ReconciledPackage> reconciledPackages;\n            synchronized (mPm.mLock) {\n                try {\n                    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"reconcilePackages\");\n                    reconciledPackages = ReconcilePackageUtils.reconcilePackages(\n                            requests, Collections.unmodifiableMap(mPm.mPackages),\n                            versionInfos, mSharedLibraries, mPm.mSettings.getKeySetManagerService(),\n                            mPm.mSettings);\n                } catch (ReconcileFailure e) {\n                    for (InstallRequest request : requests) {\n                        request.setError(\"Reconciliation failed...\", e);\n                    }\n                    return;\n                } finally {\n                    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n                }\n                try {\n                    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"commitPackages\");\n                    commitPackagesLocked(reconciledPackages, mPm.mUserManager.getUserIds());\n                    success = true;\n                } finally {\n                    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n                }\n            }\n            executePostCommitStepsLIF(reconciledPackages);\n        } finally {\n            if (success) {\n                for (InstallRequest request : requests) {\n                    if (request.getDataLoaderType() != DataLoaderType.INCREMENTAL) {\n                        continue;\n                    }\n                    if (request.getSignatureSchemeVersion() != SIGNING_BLOCK_V4) {\n                        continue;\n                    }\n                    // For incremental installs, we bypass the verifier prior to install. Now\n                    // that we know the package is valid, send a notice to the verifier with\n                    // the root hash of the base.apk.\n                    final String baseCodePath = request.getPkg().getBaseApkPath();\n                    final String[] splitCodePaths = request.getPkg().getSplitCodePaths();\n                    final Uri originUri = request.getOriginUri();\n                    final int verificationId = mPm.mPendingVerificationToken++;\n                    final String rootHashString = PackageManagerServiceUtils\n                            .buildVerificationRootHashString(baseCodePath, splitCodePaths);\n                    VerificationUtils.broadcastPackageVerified(verificationId, originUri,\n                            PackageManager.VERIFICATION_ALLOW, rootHashString,\n                            request.getDataLoaderType(), request.getUser(), mContext);\n                }\n            } else {\n                for (InstallRequest installRequest : requests) {\n                    if (installRequest.getParsedPackage() != null && createdAppId.getOrDefault(\n                            installRequest.getParsedPackage().getPackageName(), false)) {\n                        cleanUpAppIdCreation(installRequest);\n                    }\n                }\n                // TODO(b/194319951): create a more descriptive reason than unknown\n                // mark all non-failure installs as UNKNOWN so we do not treat them as success\n                for (InstallRequest request : requests) {\n                    request.closeFreezer();\n                    if (request.getReturnCode() == PackageManager.INSTALL_SUCCEEDED) {\n                        request.setReturnCode(PackageManager.INSTALL_UNKNOWN);\n                    }\n                }\n            }\n            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n        }\n    }\n\n    @GuardedBy(\"mPm.mInstallLock\")\n    private boolean checkNoAppStorageIsConsistent(AndroidPackage oldPkg, AndroidPackage newPkg) {\n        if (oldPkg == null) {\n            // New install, nothing to check against.\n            return true;\n        }\n        final PackageManager.Property curProp =\n                oldPkg.getProperties().get(PackageManager.PROPERTY_NO_APP_DATA_STORAGE);\n        final PackageManager.Property newProp =\n                newPkg.getProperties().get(PackageManager.PROPERTY_NO_APP_DATA_STORAGE);\n        if (curProp == null || !curProp.getBoolean()) {\n            return newProp == null || !newProp.getBoolean();\n        }\n        return newProp != null && newProp.getBoolean();\n    }\n\n    @GuardedBy(\"mPm.mInstallLock\")\n    private void preparePackageLI(InstallRequest request) throws PrepareFailure {\n        final int installFlags = request.getInstallFlags();\n        final boolean onExternal = request.getVolumeUuid() != null;\n        final boolean instantApp = ((installFlags & PackageManager.INSTALL_INSTANT_APP) != 0);\n        final boolean fullApp = ((installFlags & PackageManager.INSTALL_FULL_APP) != 0);\n        final boolean virtualPreload =\n                ((installFlags & PackageManager.INSTALL_VIRTUAL_PRELOAD) != 0);\n        final boolean isApex = ((installFlags & PackageManager.INSTALL_APEX) != 0);\n        final boolean isRollback =\n                request.getInstallReason() == PackageManager.INSTALL_REASON_ROLLBACK;\n        @PackageManagerService.ScanFlags int scanFlags = SCAN_NEW_INSTALL | SCAN_UPDATE_SIGNATURE;\n        if (request.isInstallMove()) {\n            // moving a complete application; perform an initial scan on the new install location\n            scanFlags |= SCAN_INITIAL;\n        }\n        if ((installFlags & PackageManager.INSTALL_DONT_KILL_APP) != 0) {\n            scanFlags |= SCAN_DONT_KILL_APP;\n        }\n        if (instantApp) {\n            scanFlags |= SCAN_AS_INSTANT_APP;\n        }\n        if (fullApp) {\n            scanFlags |= SCAN_AS_FULL_APP;\n        }\n        if (virtualPreload) {\n            scanFlags |= SCAN_AS_VIRTUAL_PRELOAD;\n        }\n        if (isApex) {\n            scanFlags |= SCAN_AS_APEX;\n        }\n\n        final File tmpPackageFile = new File(\n                isApex ? request.getApexInfo().modulePath : request.getCodePath());\n        if (DEBUG_INSTALL) Slog.d(TAG, \"installPackageLI: path=\" + tmpPackageFile);\n\n        // Validity check\n        if (instantApp && onExternal) {\n            Slog.i(TAG, \"Incompatible ephemeral install; external=\" + onExternal);\n            throw new PrepareFailure(PackageManager.INSTALL_FAILED_SESSION_INVALID);\n        }\n\n        // Retrieve PackageSettings and parse package\n        @ParsingPackageUtils.ParseFlags final int parseFlags =\n                mPm.getDefParseFlags() | ParsingPackageUtils.PARSE_CHATTY\n                        | ParsingPackageUtils.PARSE_ENFORCE_CODE\n                        | (onExternal ? ParsingPackageUtils.PARSE_EXTERNAL_STORAGE : 0);\n\n        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"parsePackage\");\n        final ParsedPackage parsedPackage;\n        try (PackageParser2 pp = mPm.mInjector.getPreparingPackageParser()) {\n            parsedPackage = pp.parsePackage(tmpPackageFile, parseFlags, false);\n            AndroidPackageUtils.validatePackageDexMetadata(parsedPackage);\n        } catch (PackageManagerException e) {\n            throw new PrepareFailure(\"Failed parse during installPackageLI\", e);\n        } finally {\n            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n        }\n\n        // Block the install of apps using a lower target SDK version than required.\n        // This helps improve security and privacy as malware can target older SDK versions\n        // to avoid enforcement of new API behavior.\n        boolean bypassLowTargetSdkBlock =\n                ((installFlags & PackageManager.INSTALL_BYPASS_LOW_TARGET_SDK_BLOCK) != 0);\n\n        // Skip enforcement when the testOnly flag is set\n        if (!bypassLowTargetSdkBlock && parsedPackage.isTestOnly()) {\n            bypassLowTargetSdkBlock = true;\n        }\n\n        // Enforce the low target sdk install block except when\n        // the --bypass-low-target-sdk-block is set for the install\n        if (!bypassLowTargetSdkBlock\n                && parsedPackage.getTargetSdkVersion() < MIN_INSTALLABLE_TARGET_SDK) {\n            Slog.w(TAG, \"App \" + parsedPackage.getPackageName()\n                    + \" targets deprecated sdk version\");\n            throw new PrepareFailure(INSTALL_FAILED_DEPRECATED_SDK_VERSION,\n                    \"App package must target at least SDK version \"\n                            + MIN_INSTALLABLE_TARGET_SDK + \", but found \"\n                            + parsedPackage.getTargetSdkVersion());\n        }\n\n        // Instant apps have several additional install-time checks.\n        if (instantApp) {\n            if (parsedPackage.getTargetSdkVersion() < Build.VERSION_CODES.O) {\n                Slog.w(TAG, \"Instant app package \" + parsedPackage.getPackageName()\n                        + \" does not target at least O\");\n                throw new PrepareFailure(INSTALL_FAILED_SESSION_INVALID,\n                        \"Instant app package must target at least O\");\n            }\n            if (parsedPackage.getSharedUserId() != null) {\n                Slog.w(TAG, \"Instant app package \" + parsedPackage.getPackageName()\n                        + \" may not declare sharedUserId.\");\n                throw new PrepareFailure(INSTALL_FAILED_SESSION_INVALID,\n                        \"Instant app package may not declare a sharedUserId\");\n            }\n        }\n\n        if (parsedPackage.isStaticSharedLibrary()) {\n            // Static shared libraries have synthetic package names\n            PackageManagerService.renameStaticSharedLibraryPackage(parsedPackage);\n\n            // No static shared libs on external storage\n            if (onExternal) {\n                Slog.i(TAG, \"Static shared libs can only be installed on internal storage.\");\n                throw new PrepareFailure(INSTALL_FAILED_INVALID_INSTALL_LOCATION,\n                        \"Static shared libs can only be installed on internal storage.\");\n            }\n        }\n\n        String pkgName = parsedPackage.getPackageName();\n        request.setName(pkgName);\n        if (parsedPackage.isTestOnly()) {\n            if ((installFlags & PackageManager.INSTALL_ALLOW_TEST) == 0) {\n                throw new PrepareFailure(INSTALL_FAILED_TEST_ONLY,\n                        \"Failed to install test-only apk. Did you forget to add -t?\");\n            }\n        }\n\n        // either use what we've been given or parse directly from the APK\n        if (request.getSigningDetails() != SigningDetails.UNKNOWN) {\n            parsedPackage.setSigningDetails(request.getSigningDetails());\n        } else {\n            final ParseTypeImpl input = ParseTypeImpl.forDefaultParsing();\n            final ParseResult<SigningDetails> result = ParsingPackageUtils.getSigningDetails(\n                    input, parsedPackage, false /*skipVerify*/);\n            if (result.isError()) {\n                throw new PrepareFailure(\"Failed collect during installPackageLI\",\n                        result.getException());\n            }\n            parsedPackage.setSigningDetails(result.getResult());\n        }\n\n        if (instantApp && parsedPackage.getSigningDetails().getSignatureSchemeVersion()\n                < SigningDetails.SignatureSchemeVersion.SIGNING_BLOCK_V2) {\n            Slog.w(TAG, \"Instant app package \" + parsedPackage.getPackageName()\n                    + \" is not signed with at least APK Signature Scheme v2\");\n            throw new PrepareFailure(INSTALL_FAILED_SESSION_INVALID,\n                    \"Instant app package must be signed with APK Signature Scheme v2 or greater\");\n        }\n\n        boolean systemApp = false;\n        boolean replace = false;\n        synchronized (mPm.mLock) {\n            // Check if installing already existing package\n            if ((installFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {\n                String oldName = mPm.mSettings.getRenamedPackageLPr(pkgName);\n                if (parsedPackage.getOriginalPackages().contains(oldName)\n                        && mPm.mPackages.containsKey(oldName)) {\n                    // This package is derived from an original package,\n                    // and this device has been updating from that original\n                    // name.  We must continue using the original name, so\n                    // rename the new package here.\n                    parsedPackage.setPackageName(oldName);\n                    pkgName = parsedPackage.getPackageName();\n                    replace = true;\n                    if (DEBUG_INSTALL) {\n                        Slog.d(TAG, \"Replacing existing renamed package: oldName=\"\n                                + oldName + \" pkgName=\" + pkgName);\n                    }\n                } else if (mPm.mPackages.containsKey(pkgName)) {\n                    // This package, under its official name, already exists\n                    // on the device; we should replace it.\n                    replace = true;\n                    if (DEBUG_INSTALL) Slog.d(TAG, \"Replace existing package: \" + pkgName);\n                }\n\n                if (replace) {\n                    // Prevent apps opting out from runtime permissions\n                    AndroidPackage oldPackage = mPm.mPackages.get(pkgName);\n                    final int oldTargetSdk = oldPackage.getTargetSdkVersion();\n                    final int newTargetSdk = parsedPackage.getTargetSdkVersion();\n                    if (oldTargetSdk > Build.VERSION_CODES.LOLLIPOP_MR1\n                            && newTargetSdk <= Build.VERSION_CODES.LOLLIPOP_MR1) {\n                        throw new PrepareFailure(\n                                PackageManager.INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE,\n                                \"Package \" + parsedPackage.getPackageName()\n                                        + \" new target SDK \" + newTargetSdk\n                                        + \" doesn't support runtime permissions but the old\"\n                                        + \" target SDK \" + oldTargetSdk + \" does.\");\n                    }\n                    // Prevent persistent apps from being updated\n                    if (oldPackage.isPersistent()\n                            && ((installFlags & PackageManager.INSTALL_STAGED) == 0)) {\n                        throw new PrepareFailure(PackageManager.INSTALL_FAILED_INVALID_APK,\n                                \"Package \" + oldPackage.getPackageName() + \" is a persistent app. \"\n                                        + \"Persistent apps are not updateable.\");\n                    }\n                }\n            }\n\n            PackageSetting ps = mPm.mSettings.getPackageLPr(pkgName);\n            PackageSetting signatureCheckPs = ps;\n\n            // SDK libs can have other major versions with different package names.\n            if (signatureCheckPs == null && parsedPackage.isSdkLibrary()) {\n                WatchedLongSparseArray<SharedLibraryInfo> libraryInfos =\n                        mSharedLibraries.getSharedLibraryInfos(\n                                parsedPackage.getSdkLibraryName());\n                if (libraryInfos != null && libraryInfos.size() > 0) {\n                    // Any existing version would do.\n                    SharedLibraryInfo libraryInfo = libraryInfos.valueAt(0);\n                    signatureCheckPs = mPm.mSettings.getPackageLPr(libraryInfo.getPackageName());\n                }\n            }\n\n            // Static shared libs have same package with different versions where\n            // we internally use a synthetic package name to allow multiple versions\n            // of the same package, therefore we need to compare signatures against\n            // the package setting for the latest library version.\n            if (parsedPackage.isStaticSharedLibrary()) {\n                SharedLibraryInfo libraryInfo =\n                        mSharedLibraries.getLatestStaticSharedLibraVersion(parsedPackage);\n                if (libraryInfo != null) {\n                    signatureCheckPs = mPm.mSettings.getPackageLPr(libraryInfo.getPackageName());\n                }\n            }\n\n            if (signatureCheckPs != null) {\n                if (DEBUG_INSTALL) {\n                    Slog.d(TAG,\n                            \"Existing package for signature checking: \" + signatureCheckPs);\n                }\n\n                // Quick validity check that we're signed correctly if updating;\n                // we'll check this again later when scanning, but we want to\n                // bail early here before tripping over redefined permissions.\n                final KeySetManagerService ksms = mPm.mSettings.getKeySetManagerService();\n                final SharedUserSetting signatureCheckSus = mPm.mSettings.getSharedUserSettingLPr(\n                        signatureCheckPs);\n                if (ksms.shouldCheckUpgradeKeySetLocked(signatureCheckPs, signatureCheckSus,\n                        scanFlags)) {\n                    if (!ksms.checkUpgradeKeySetLocked(signatureCheckPs, parsedPackage)) {\n                        throw new PrepareFailure(INSTALL_FAILED_UPDATE_INCOMPATIBLE, \"Package \"\n                                + parsedPackage.getPackageName() + \" upgrade keys do not match the \"\n                                + \"previously installed version\");\n                    }\n                } else {\n                    try {\n                        final boolean compareCompat =\n                                ReconcilePackageUtils.isCompatSignatureUpdateNeeded(\n                                        mPm.getSettingsVersionForPackage(parsedPackage));\n                        final boolean compareRecover =\n                                ReconcilePackageUtils.isRecoverSignatureUpdateNeeded(\n                                        mPm.getSettingsVersionForPackage(parsedPackage));\n                        // We don't care about disabledPkgSetting on install for now.\n                        final boolean compatMatch =\n                                PackageManagerServiceUtils.verifySignatures(signatureCheckPs,\n                                        signatureCheckSus, null,\n                                parsedPackage.getSigningDetails(), compareCompat, compareRecover,\n                                isRollback);\n                        // The new KeySets will be re-added later in the scanning process.\n                        if (compatMatch) {\n                            synchronized (mPm.mLock) {\n                                ksms.removeAppKeySetDataLPw(parsedPackage.getPackageName());\n                            }\n                        }\n                    } catch (PackageManagerException e) {\n                        throw new PrepareFailure(e.error, e.getMessage());\n                    }\n                }\n            }\n\n            if (ps != null) {\n                if (DEBUG_INSTALL) Slog.d(TAG, \"Existing package: \" + ps);\n\n                systemApp = ps.isSystem();\n                request.setOriginUsers(\n                        ps.queryInstalledUsers(mPm.mUserManager.getUserIds(), true));\n            }\n\n            final int numGroups = ArrayUtils.size(parsedPackage.getPermissionGroups());\n            for (int groupNum = 0; groupNum < numGroups; groupNum++) {\n                final ParsedPermissionGroup group =\n                        parsedPackage.getPermissionGroups().get(groupNum);\n                final PermissionGroupInfo sourceGroup = mPm.getPermissionGroupInfo(group.getName(),\n                        0);\n\n                if (sourceGroup != null && cannotInstallWithBadPermissionGroups(parsedPackage)) {\n                    final String sourcePackageName = sourceGroup.packageName;\n\n                    if ((replace || !parsedPackage.getPackageName().equals(sourcePackageName))\n                            && !doesSignatureMatchForPermissions(sourcePackageName, parsedPackage,\n                            scanFlags)) {\n                        EventLog.writeEvent(0x534e4554, \"146211400\", -1,\n                                parsedPackage.getPackageName());\n\n                        throw new PrepareFailure(INSTALL_FAILED_DUPLICATE_PERMISSION_GROUP,\n                                \"Package \"\n                                        + parsedPackage.getPackageName()\n                                        + \" attempting to redeclare permission group \"\n                                        + group.getName() + \" already owned by \"\n                                        + sourcePackageName);\n                    }\n                }\n            }\n\n            // TODO: Move logic for checking permission compatibility into PermissionManagerService\n            final int n = ArrayUtils.size(parsedPackage.getPermissions());\n            for (int i = n - 1; i >= 0; i--) {\n                final ParsedPermission perm = parsedPackage.getPermissions().get(i);\n                final Permission bp = mPm.mPermissionManager.getPermissionTEMP(perm.getName());\n\n                // Don't allow anyone but the system to define ephemeral permissions.\n                if ((perm.getProtectionLevel() & PermissionInfo.PROTECTION_FLAG_INSTANT) != 0\n                        && !systemApp) {\n                    Slog.w(TAG, \"Non-System package \" + parsedPackage.getPackageName()\n                            + \" attempting to delcare ephemeral permission \"\n                            + perm.getName() + \"; Removing ephemeral.\");\n                    ComponentMutateUtils.setProtectionLevel(perm,\n                            perm.getProtectionLevel() & ~PermissionInfo.PROTECTION_FLAG_INSTANT);\n                }\n\n                // Check whether the newly-scanned package wants to define an already-defined perm\n                if (bp != null) {\n                    final String sourcePackageName = bp.getPackageName();\n\n                    if (!doesSignatureMatchForPermissions(sourcePackageName, parsedPackage,\n                            scanFlags)) {\n                        // If the owning package is the system itself, we log but allow\n                        // install to proceed; we fail the install on all other permission\n                        // redefinitions.\n                        if (!sourcePackageName.equals(\"android\")) {\n                            throw new PrepareFailure(INSTALL_FAILED_DUPLICATE_PERMISSION,\n                                    \"Package \"\n                                            + parsedPackage.getPackageName()\n                                            + \" attempting to redeclare permission \"\n                                            + perm.getName() + \" already owned by \"\n                                            + sourcePackageName)\n                                    .conflictsWithExistingPermission(perm.getName(),\n                                            sourcePackageName);\n                        } else {\n                            Slog.w(TAG, \"Package \" + parsedPackage.getPackageName()\n                                    + \" attempting to redeclare system permission \"\n                                    + perm.getName() + \"; ignoring new declaration\");\n                            parsedPackage.removePermission(i);\n                        }\n                    } else if (!PLATFORM_PACKAGE_NAME.equals(parsedPackage.getPackageName())) {\n                        // Prevent apps to change protection level to dangerous from any other\n                        // type as this would allow a privilege escalation where an app adds a\n                        // normal/signature permission in other app's group and later redefines\n                        // it as dangerous leading to the group auto-grant.\n                        if ((perm.getProtectionLevel() & PermissionInfo.PROTECTION_MASK_BASE)\n                                == PermissionInfo.PROTECTION_DANGEROUS) {\n                            if (!bp.isRuntime()) {\n                                Slog.w(TAG, \"Package \" + parsedPackage.getPackageName()\n                                        + \" trying to change a non-runtime permission \"\n                                        + perm.getName()\n                                        + \" to runtime; keeping old protection level\");\n                                ComponentMutateUtils.setProtectionLevel(perm,\n                                        bp.getProtectionLevel());\n                            }\n                        }\n                    }\n                }\n\n                if (perm.getGroup() != null\n                        && cannotInstallWithBadPermissionGroups(parsedPackage)) {\n                    boolean isPermGroupDefinedByPackage = false;\n                    for (int groupNum = 0; groupNum < numGroups; groupNum++) {\n                        if (parsedPackage.getPermissionGroups().get(groupNum).getName()\n                                .equals(perm.getGroup())) {\n                            isPermGroupDefinedByPackage = true;\n                            break;\n                        }\n                    }\n\n                    if (!isPermGroupDefinedByPackage) {\n                        final PermissionGroupInfo sourceGroup =\n                                mPm.getPermissionGroupInfo(perm.getGroup(), 0);\n\n                        if (sourceGroup == null) {\n                            EventLog.writeEvent(0x534e4554, \"146211400\", -1,\n                                    parsedPackage.getPackageName());\n\n                            throw new PrepareFailure(INSTALL_FAILED_BAD_PERMISSION_GROUP,\n                                    \"Package \"\n                                            + parsedPackage.getPackageName()\n                                            + \" attempting to declare permission \"\n                                            + perm.getName() + \" in non-existing group \"\n                                            + perm.getGroup());\n                        } else {\n                            String groupSourcePackageName = sourceGroup.packageName;\n\n                            if (!PLATFORM_PACKAGE_NAME.equals(groupSourcePackageName)\n                                    && !doesSignatureMatchForPermissions(groupSourcePackageName,\n                                    parsedPackage, scanFlags)) {\n                                EventLog.writeEvent(0x534e4554, \"146211400\", -1,\n                                        parsedPackage.getPackageName());\n\n                                throw new PrepareFailure(INSTALL_FAILED_BAD_PERMISSION_GROUP,\n                                        \"Package \"\n                                                + parsedPackage.getPackageName()\n                                                + \" attempting to declare permission \"\n                                                + perm.getName() + \" in group \"\n                                                + perm.getGroup() + \" owned by package \"\n                                                + groupSourcePackageName\n                                                + \" with incompatible certificate\");\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if (systemApp) {\n            if (onExternal) {\n                // Abort update; system app can't be replaced with app on sdcard\n                throw new PrepareFailure(INSTALL_FAILED_INVALID_INSTALL_LOCATION,\n                        \"Cannot install updates to system apps on sdcard\");\n            } else if (instantApp) {\n                // Abort update; system app can't be replaced with an instant app\n                throw new PrepareFailure(INSTALL_FAILED_SESSION_INVALID,\n                        \"Cannot update a system app with an instant app\");\n            }\n        }\n\n        if (request.isInstallMove()) {\n            // We did an in-place move, so dex is ready to roll\n            scanFlags |= SCAN_NO_DEX;\n            scanFlags |= SCAN_MOVE;\n\n            synchronized (mPm.mLock) {\n                final PackageSetting ps = mPm.mSettings.getPackageLPr(pkgName);\n                if (ps == null) {\n                    request.setError(PackageManagerException.ofInternalError(\n                            \"Missing settings for moved package \" + pkgName,\n                            PackageManagerException.INTERNAL_ERROR_MISSING_SETTING_FOR_MOVE));\n                }\n\n                // We moved the entire application as-is, so bring over the\n                // previously derived ABI information.\n                parsedPackage.setPrimaryCpuAbi(ps.getPrimaryCpuAbiLegacy())\n                        .setSecondaryCpuAbi(ps.getSecondaryCpuAbiLegacy());\n            }\n\n        } else {\n            // Enable SCAN_NO_DEX flag to skip dexopt at a later stage\n            scanFlags |= SCAN_NO_DEX;\n\n            try {\n                PackageSetting pkgSetting;\n                synchronized (mPm.mLock) {\n                    pkgSetting = mPm.mSettings.getPackageLPr(pkgName);\n                }\n                boolean isUpdatedSystemAppFromExistingSetting = pkgSetting != null\n                        && pkgSetting.isUpdatedSystemApp();\n                final String abiOverride = deriveAbiOverride(request.getAbiOverride());\n\n                // TODO: Are these system flags actually set properly at this stage?\n                boolean isUpdatedSystemAppInferred = pkgSetting != null && pkgSetting.isSystem();\n                final Pair<PackageAbiHelper.Abis, PackageAbiHelper.NativeLibraryPaths>\n                        derivedAbi = mPackageAbiHelper.derivePackageAbi(parsedPackage, systemApp,\n                        isUpdatedSystemAppFromExistingSetting || isUpdatedSystemAppInferred,\n                        abiOverride, ScanPackageUtils.getAppLib32InstallDir());\n                derivedAbi.first.applyTo(parsedPackage);\n                derivedAbi.second.applyTo(parsedPackage);\n            } catch (PackageManagerException pme) {\n                Slog.e(TAG, \"Error deriving application ABI\", pme);\n                throw PrepareFailure.ofInternalError(\n                        \"Error deriving application ABI: \" + pme.getMessage(),\n                        PackageManagerException.INTERNAL_ERROR_DERIVING_ABI);\n            }\n        }\n\n        if (!isApex) {\n            doRenameLI(request, parsedPackage);\n\n            try {\n                setUpFsVerity(parsedPackage);\n            } catch (Installer.InstallerException | IOException | DigestException\n                    | NoSuchAlgorithmException e) {\n                throw PrepareFailure.ofInternalError(\n                        \"Failed to set up verity: \" + e,\n                        PackageManagerException.INTERNAL_ERROR_VERITY_SETUP);\n            }\n        } else {\n            // Use the path returned by apexd\n            parsedPackage.setPath(request.getApexInfo().modulePath);\n            parsedPackage.setBaseApkPath(request.getApexInfo().modulePath);\n        }\n\n        final PackageFreezer freezer =\n                freezePackageForInstall(pkgName, UserHandle.USER_ALL, installFlags,\n                        \"installPackageLI\", ApplicationExitInfo.REASON_PACKAGE_UPDATED);\n        boolean shouldCloseFreezerBeforeReturn = true;\n        try {\n            final PackageState oldPackageState;\n            final AndroidPackage oldPackage;\n            String renamedPackage;\n            boolean sysPkg = false;\n            int targetScanFlags = scanFlags;\n            int targetParseFlags = parseFlags;\n            final PackageSetting ps;\n            final PackageSetting disabledPs;\n            final SharedUserSetting sharedUserSetting;\n            if (replace) {\n                final String pkgName11 = parsedPackage.getPackageName();\n                synchronized (mPm.mLock) {\n                    oldPackageState = mPm.mSettings.getPackageLPr(pkgName11);\n                }\n                oldPackage = oldPackageState.getAndroidPackage();\n                if (parsedPackage.isStaticSharedLibrary()) {\n                    // Static libs have a synthetic package name containing the version\n                    // and cannot be updated as an update would get a new package name,\n                    // unless this is installed from adb which is useful for development.\n                    if (oldPackage != null\n                            && (installFlags & PackageManager.INSTALL_FROM_ADB) == 0) {\n                        throw new PrepareFailure(INSTALL_FAILED_DUPLICATE_PACKAGE,\n                                \"Packages declaring \"\n                                        + \"static-shared libs cannot be updated\");\n                    }\n                }\n\n                final boolean isInstantApp = (scanFlags & SCAN_AS_INSTANT_APP) != 0;\n\n                final int[] allUsers;\n                final int[] installedUsers;\n                final int[] uninstalledUsers;\n\n                synchronized (mPm.mLock) {\n                    if (DEBUG_INSTALL) {\n                        Slog.d(TAG,\n                                \"replacePackageLI: new=\" + parsedPackage + \", old=\" + oldPackage);\n                    }\n\n                    ps = mPm.mSettings.getPackageLPr(pkgName11);\n                    disabledPs = mPm.mSettings.getDisabledSystemPkgLPr(ps);\n                    sharedUserSetting = mPm.mSettings.getSharedUserSettingLPr(ps);\n\n                    // verify signatures are valid\n                    final KeySetManagerService ksms = mPm.mSettings.getKeySetManagerService();\n                    if (ksms.shouldCheckUpgradeKeySetLocked(ps, sharedUserSetting, scanFlags)) {\n                        if (!ksms.checkUpgradeKeySetLocked(ps, parsedPackage)) {\n                            throw new PrepareFailure(INSTALL_FAILED_UPDATE_INCOMPATIBLE,\n                                    \"New package not signed by keys specified by upgrade-keysets: \"\n                                            + pkgName11);\n                        }\n                    } else {\n                        SigningDetails parsedPkgSigningDetails = parsedPackage.getSigningDetails();\n                        SigningDetails oldPkgSigningDetails = oldPackage.getSigningDetails();\n                        // default to original signature matching\n                        if (!parsedPkgSigningDetails.checkCapability(oldPkgSigningDetails,\n                                SigningDetails.CertCapabilities.INSTALLED_DATA)\n                                && !oldPkgSigningDetails.checkCapability(parsedPkgSigningDetails,\n                                SigningDetails.CertCapabilities.ROLLBACK)) {\n                            // Allow the update to proceed if this is a rollback and the parsed\n                            // package's current signing key is the current signer or in the lineage\n                            // of the old package; this allows a rollback to a previously installed\n                            // version after an app's signing key has been rotated without requiring\n                            // the rollback capability on the previous signing key.\n                            if (!isRollback || !oldPkgSigningDetails.hasAncestorOrSelf(\n                                    parsedPkgSigningDetails)) {\n                                throw new PrepareFailure(INSTALL_FAILED_UPDATE_INCOMPATIBLE,\n                                        \"New package has a different signature: \" + pkgName11);\n                            }\n                        }\n                    }\n\n                    // don't allow a system upgrade unless the upgrade hash matches\n                    if (oldPackage.getRestrictUpdateHash() != null && oldPackageState.isSystem()) {\n                        final byte[] digestBytes;\n                        try {\n                            final MessageDigest digest = MessageDigest.getInstance(\"SHA-512\");\n                            updateDigest(digest, new File(parsedPackage.getBaseApkPath()));\n                            if (!ArrayUtils.isEmpty(parsedPackage.getSplitCodePaths())) {\n                                for (String path : parsedPackage.getSplitCodePaths()) {\n                                    updateDigest(digest, new File(path));\n                                }\n                            }\n                            digestBytes = digest.digest();\n                        } catch (NoSuchAlgorithmException | IOException e) {\n                            throw new PrepareFailure(INSTALL_FAILED_INVALID_APK,\n                                    \"Could not compute hash: \" + pkgName11);\n                        }\n                        if (!Arrays.equals(oldPackage.getRestrictUpdateHash(), digestBytes)) {\n                            throw new PrepareFailure(INSTALL_FAILED_INVALID_APK,\n                                    \"New package fails restrict-update check: \" + pkgName11);\n                        }\n                        // retain upgrade restriction\n                        parsedPackage.setRestrictUpdateHash(oldPackage.getRestrictUpdateHash());\n                    }\n\n                    // APK should not change its sharedUserId declarations\n                    final var oldSharedUid = oldPackage.getSharedUserId() != null\n                            ? oldPackage.getSharedUserId() : \"<nothing>\";\n                    final var newSharedUid = parsedPackage.getSharedUserId() != null\n                            ? parsedPackage.getSharedUserId() : \"<nothing>\";\n                    if (!oldSharedUid.equals(newSharedUid)) {\n                        throw new PrepareFailure(INSTALL_FAILED_UID_CHANGED,\n                                \"Package \" + parsedPackage.getPackageName()\n                                        + \" shared user changed from \"\n                                        + oldSharedUid + \" to \" + newSharedUid);\n                    }\n\n                    // APK should not re-join shared UID\n                    if (oldPackage.isLeavingSharedUser() && !parsedPackage.isLeavingSharedUser()) {\n                        throw new PrepareFailure(INSTALL_FAILED_UID_CHANGED,\n                                \"Package \" + parsedPackage.getPackageName()\n                                        + \" attempting to rejoin \" + newSharedUid);\n                    }\n\n                    // In case of rollback, remember per-user/profile install state\n                    allUsers = mPm.mUserManager.getUserIds();\n                    installedUsers = ps.queryInstalledUsers(allUsers, true);\n                    uninstalledUsers = ps.queryInstalledUsers(allUsers, false);\n\n\n                    // don't allow an upgrade from full to ephemeral\n                    if (isInstantApp) {\n                        if (request.getUserId() == UserHandle.USER_ALL) {\n                            for (int currentUser : allUsers) {\n                                if (!ps.getInstantApp(currentUser)) {\n                                    // can't downgrade from full to instant\n                                    Slog.w(TAG,\n                                            \"Can't replace full app with instant app: \" + pkgName11\n                                                    + \" for user: \" + currentUser);\n                                    throw new PrepareFailure(\n                                            PackageManager.INSTALL_FAILED_SESSION_INVALID);\n                                }\n                            }\n                        } else if (!ps.getInstantApp(request.getUserId())) {\n                            // can't downgrade from full to instant\n                            Slog.w(TAG, \"Can't replace full app with instant app: \" + pkgName11\n                                    + \" for user: \" + request.getUserId());\n                            throw new PrepareFailure(\n                                    PackageManager.INSTALL_FAILED_SESSION_INVALID);\n                        }\n                    }\n                }\n\n                // Update what is removed\n                PackageRemovedInfo removedInfo = new PackageRemovedInfo(mPm);\n                removedInfo.mUid = oldPackage.getUid();\n                removedInfo.mRemovedPackage = oldPackage.getPackageName();\n                removedInfo.mInstallerPackageName =\n                        ps.getInstallSource().mInstallerPackageName;\n                removedInfo.mIsStaticSharedLib =\n                        parsedPackage.getStaticSharedLibraryName() != null;\n                removedInfo.mIsUpdate = true;\n                removedInfo.mOrigUsers = installedUsers;\n                removedInfo.mInstallReasons = new SparseIntArray(installedUsers.length);\n                for (int i = 0; i < installedUsers.length; i++) {\n                    final int userId = installedUsers[i];\n                    removedInfo.mInstallReasons.put(userId,\n                            ps.getInstallReason(userId));\n                }\n                removedInfo.mUninstallReasons = new SparseIntArray(uninstalledUsers.length);\n                for (int i = 0; i < uninstalledUsers.length; i++) {\n                    final int userId = uninstalledUsers[i];\n                    removedInfo.mUninstallReasons.put(userId,\n                            ps.getUninstallReason(userId));\n                }\n                removedInfo.mIsExternal = oldPackage.isExternalStorage();\n                removedInfo.mRemovedPackageVersionCode = oldPackage.getLongVersionCode();\n                request.setRemovedInfo(removedInfo);\n\n                sysPkg = oldPackageState.isSystem();\n                if (sysPkg) {\n                    // Set the system/privileged/oem/vendor/product flags as needed\n                    final boolean privileged = oldPackageState.isPrivileged();\n                    final boolean oem = oldPackageState.isOem();\n                    final boolean vendor = oldPackageState.isVendor();\n                    final boolean product = oldPackageState.isProduct();\n                    final boolean odm = oldPackageState.isOdm();\n                    final boolean systemExt = oldPackageState.isSystemExt();\n                    final @ParsingPackageUtils.ParseFlags int systemParseFlags = parseFlags;\n                    final @PackageManagerService.ScanFlags int systemScanFlags = scanFlags\n                            | SCAN_AS_SYSTEM\n                            | (privileged ? SCAN_AS_PRIVILEGED : 0)\n                            | (oem ? SCAN_AS_OEM : 0)\n                            | (vendor ? SCAN_AS_VENDOR : 0)\n                            | (product ? SCAN_AS_PRODUCT : 0)\n                            | (odm ? SCAN_AS_ODM : 0)\n                            | (systemExt ? SCAN_AS_SYSTEM_EXT : 0);\n\n                    if (DEBUG_INSTALL) {\n                        Slog.d(TAG, \"replaceSystemPackageLI: new=\" + parsedPackage\n                                + \", old=\" + oldPackage);\n                    }\n                    request.setReturnCode(PackageManager.INSTALL_SUCCEEDED);\n                    request.setApexModuleName(oldPackageState.getApexModuleName());\n                    targetParseFlags = systemParseFlags;\n                    targetScanFlags = systemScanFlags;\n                } else { // non system replace\n                    if (DEBUG_INSTALL) {\n                        Slog.d(TAG,\n                                \"replaceNonSystemPackageLI: new=\" + parsedPackage + \", old=\"\n                                        + oldPackage);\n                    }\n                }\n            } else { // new package install\n                ps = null;\n                disabledPs = null;\n                oldPackage = null;\n                // Remember this for later, in case we need to rollback this install\n                String pkgName1 = parsedPackage.getPackageName();\n\n                if (DEBUG_INSTALL) Slog.d(TAG, \"installNewPackageLI: \" + parsedPackage);\n\n                // TODO(b/194319951): MOVE TO RECONCILE\n                synchronized (mPm.mLock) {\n                    renamedPackage = mPm.mSettings.getRenamedPackageLPr(pkgName1);\n                    if (renamedPackage != null) {\n                        // A package with the same name is already installed, though\n                        // it has been renamed to an older name.  The package we\n                        // are trying to install should be installed as an update to\n                        // the existing one, but that has not been requested, so bail.\n                        throw new PrepareFailure(INSTALL_FAILED_ALREADY_EXISTS,\n                                \"Attempt to re-install \" + pkgName1\n                                        + \" without first uninstalling package running as \"\n                                        + renamedPackage);\n                    }\n                    if (mPm.mPackages.containsKey(pkgName1)) {\n                        // Don't allow installation over an existing package with the same name.\n                        throw new PrepareFailure(INSTALL_FAILED_ALREADY_EXISTS,\n                                \"Attempt to re-install \" + pkgName1\n                                        + \" without first uninstalling.\");\n                    }\n                }\n            }\n            // we're passing the freezer back to be closed in a later phase of install\n            shouldCloseFreezerBeforeReturn = false;\n\n            request.setPrepareResult(replace, targetScanFlags, targetParseFlags,\n                    oldPackage, parsedPackage, replace /* clearCodeCache */, sysPkg,\n                    ps, disabledPs);\n        } finally {\n            request.setFreezer(freezer);\n            if (shouldCloseFreezerBeforeReturn) {\n                freezer.close();\n            }\n        }\n    }\n\n    /**\n     * Rename package into final resting place. All paths on the given\n     * scanned package should be updated to reflect the rename.\n     */\n    @GuardedBy(\"mPm.mInstallLock\")\n    private void doRenameLI(InstallRequest request,\n            ParsedPackage parsedPackage) throws PrepareFailure {\n        final int status = request.getReturnCode();\n        final String statusMsg = request.getReturnMsg();\n        if (request.isInstallMove()) {\n            if (status != PackageManager.INSTALL_SUCCEEDED) {\n                mRemovePackageHelper.cleanUpForMoveInstall(request.getMoveToUuid(),\n                        request.getMovePackageName(), request.getMoveFromCodePath());\n                throw new PrepareFailure(status, statusMsg);\n            }\n            return;\n        }\n        // For file installations\n        if (status != PackageManager.INSTALL_SUCCEEDED) {\n            mRemovePackageHelper.removeCodePath(request.getCodeFile());\n            throw new PrepareFailure(status, statusMsg);\n        }\n\n        final File targetDir = resolveTargetDir(request.getInstallFlags(), request.getCodeFile());\n        final File beforeCodeFile = request.getCodeFile();\n        final File afterCodeFile = PackageManagerServiceUtils.getNextCodePath(targetDir,\n                parsedPackage.getPackageName());\n\n        if (DEBUG_INSTALL) Slog.d(TAG, \"Renaming \" + beforeCodeFile + \" to \" + afterCodeFile);\n        final boolean onIncremental = mPm.mIncrementalManager != null\n                && isIncrementalPath(beforeCodeFile.getAbsolutePath());\n        try {\n            makeDirRecursive(afterCodeFile.getParentFile(), 0771);\n            if (onIncremental) {\n                // Just link files here. The stage dir will be removed when the installation\n                // session is completed.\n                mPm.mIncrementalManager.linkCodePath(beforeCodeFile, afterCodeFile);\n            } else {\n                Os.rename(beforeCodeFile.getAbsolutePath(), afterCodeFile.getAbsolutePath());\n            }\n        } catch (IOException | ErrnoException e) {\n            Slog.w(TAG, \"Failed to rename\", e);\n            throw new PrepareFailure(PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE,\n                    \"Failed to rename\");\n        }\n\n        if (!onIncremental && !SELinux.restoreconRecursive(afterCodeFile)) {\n            Slog.w(TAG, \"Failed to restorecon\");\n            throw new PrepareFailure(PackageManager.INSTALL_FAILED_MEDIA_UNAVAILABLE,\n                    \"Failed to restorecon\");\n        }\n\n        // Reflect the rename internally\n        request.setCodeFile(afterCodeFile);\n\n        // Reflect the rename in scanned details\n        try {\n            parsedPackage.setPath(afterCodeFile.getCanonicalPath());\n        } catch (IOException e) {\n            Slog.e(TAG, \"Failed to get path: \" + afterCodeFile, e);\n            throw new PrepareFailure(PackageManager.INSTALL_FAILED_MEDIA_UNAVAILABLE,\n                    \"Failed to get path: \" + afterCodeFile);\n        }\n        parsedPackage.setBaseApkPath(FileUtils.rewriteAfterRename(beforeCodeFile,\n                afterCodeFile, parsedPackage.getBaseApkPath()));\n        parsedPackage.setSplitCodePaths(FileUtils.rewriteAfterRename(beforeCodeFile,\n                afterCodeFile, parsedPackage.getSplitCodePaths()));\n    }\n\n    // TODO(b/168126411): Once staged install flow starts using the same folder as non-staged\n    //  flow, we won't need this method anymore.\n    private File resolveTargetDir(int installFlags, File codeFile) {\n        boolean isStagedInstall = (installFlags & INSTALL_STAGED) != 0;\n        if (isStagedInstall) {\n            return Environment.getDataAppDirectory(null);\n        } else {\n            return codeFile.getParentFile();\n        }\n    }\n\n    /*\n     * Cannot properly check CANNOT_INSTALL_WITH_BAD_PERMISSION_GROUPS using CompatChanges\n     * as this only works for packages that are installed\n     *\n     * TODO: Move logic for permission group compatibility into PermissionManagerService\n     */\n    @SuppressWarnings(\"AndroidFrameworkCompatChange\")\n    private static boolean cannotInstallWithBadPermissionGroups(ParsedPackage parsedPackage) {\n        return parsedPackage.getTargetSdkVersion() >= Build.VERSION_CODES.S;\n    }\n\n    private boolean doesSignatureMatchForPermissions(@NonNull String sourcePackageName,\n            @NonNull ParsedPackage parsedPackage, int scanFlags) {\n        // If the defining package is signed with our cert, it's okay.  This\n        // also includes the \"updating the same package\" case, of course.\n        // \"updating same package\" could also involve key-rotation.\n\n        final PackageSetting sourcePackageSetting;\n        final KeySetManagerService ksms;\n        final SharedUserSetting sharedUserSetting;\n        synchronized (mPm.mLock) {\n            sourcePackageSetting = mPm.mSettings.getPackageLPr(sourcePackageName);\n            ksms = mPm.mSettings.getKeySetManagerService();\n            sharedUserSetting = mPm.mSettings.getSharedUserSettingLPr(sourcePackageSetting);\n        }\n\n        final SigningDetails sourceSigningDetails = (sourcePackageSetting == null\n                ? SigningDetails.UNKNOWN : sourcePackageSetting.getSigningDetails());\n        if (sourcePackageName.equals(parsedPackage.getPackageName())\n                && (ksms.shouldCheckUpgradeKeySetLocked(\n                        sourcePackageSetting, sharedUserSetting, scanFlags))) {\n            return ksms.checkUpgradeKeySetLocked(sourcePackageSetting, parsedPackage);\n        } else {\n\n            // in the event of signing certificate rotation, we need to see if the\n            // package's certificate has rotated from the current one, or if it is an\n            // older certificate with which the current is ok with sharing permissions\n            if (sourceSigningDetails.checkCapability(\n                    parsedPackage.getSigningDetails(),\n                    SigningDetails.CertCapabilities.PERMISSION)) {\n                return true;\n            } else if (parsedPackage.getSigningDetails().checkCapability(\n                    sourceSigningDetails,\n                    SigningDetails.CertCapabilities.PERMISSION)) {\n                // the scanned package checks out, has signing certificate rotation\n                // history, and is newer; bring it over\n                synchronized (mPm.mLock) {\n                    sourcePackageSetting.setSigningDetails(parsedPackage.getSigningDetails());\n                }\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }\n\n    /**\n     * Set up fs-verity for the given package. For older devices that do not support fs-verity,\n     * this is a no-op.\n     */\n    private void setUpFsVerity(AndroidPackage pkg) throws Installer.InstallerException,\n            PrepareFailure, IOException, DigestException, NoSuchAlgorithmException {\n        if (!PackageManagerServiceUtils.isApkVerityEnabled()) {\n            return;\n        }\n\n        if (isIncrementalPath(pkg.getPath()) && IncrementalManager.getVersion()\n                < IncrementalManager.MIN_VERSION_TO_SUPPORT_FSVERITY) {\n            return;\n        }\n\n        // Collect files we care for fs-verity setup.\n        ArrayMap<String, String> fsverityCandidates = new ArrayMap<>();\n        fsverityCandidates.put(pkg.getBaseApkPath(),\n                VerityUtils.getFsveritySignatureFilePath(pkg.getBaseApkPath()));\n\n        final String dmPath = DexMetadataHelper.buildDexMetadataPathForApk(\n                pkg.getBaseApkPath());\n        if (new File(dmPath).exists()) {\n            fsverityCandidates.put(dmPath, VerityUtils.getFsveritySignatureFilePath(dmPath));\n        }\n\n        for (String path : pkg.getSplitCodePaths()) {\n            fsverityCandidates.put(path, VerityUtils.getFsveritySignatureFilePath(path));\n\n            final String splitDmPath = DexMetadataHelper.buildDexMetadataPathForApk(path);\n            if (new File(splitDmPath).exists()) {\n                fsverityCandidates.put(splitDmPath,\n                        VerityUtils.getFsveritySignatureFilePath(splitDmPath));\n            }\n        }\n\n        var fis = FileIntegrityService.getService();\n        for (Map.Entry<String, String> entry : fsverityCandidates.entrySet()) {\n            try {\n                final String filePath = entry.getKey();\n                if (VerityUtils.hasFsverity(filePath)) {\n                    continue;\n                }\n\n                final String signaturePath = entry.getValue();\n                if (new File(signaturePath).exists()) {\n                    // If signature is provided, enable fs-verity first so that the file can be\n                    // measured for signature check below.\n                    VerityUtils.setUpFsverity(filePath);\n\n                    if (!fis.verifyPkcs7DetachedSignature(signaturePath, filePath)) {\n                        throw new PrepareFailure(PackageManager.INSTALL_FAILED_BAD_SIGNATURE,\n                                \"fs-verity signature does not verify against a known key\");\n                    }\n                }\n            } catch (IOException e) {\n                throw new PrepareFailure(PackageManager.INSTALL_FAILED_BAD_SIGNATURE,\n                        \"Failed to enable fs-verity: \" + e);\n            }\n        }\n    }\n\n    private PackageFreezer freezePackageForInstall(String packageName, int userId, int installFlags,\n            String killReason, int exitInfoReason) {\n        if ((installFlags & PackageManager.INSTALL_DONT_KILL_APP) != 0) {\n            return new PackageFreezer(mPm);\n        } else {\n            return mPm.freezePackage(packageName, userId, killReason, exitInfoReason);\n        }\n    }\n\n    private static void updateDigest(MessageDigest digest, File file) throws IOException {\n        try (DigestInputStream digestStream =\n                     new DigestInputStream(new FileInputStream(file), digest)) {\n            int length, total = 0;\n            while ((length = digestStream.read()) != -1) {\n                total += length;\n            } // just plow through the file\n        }\n    }\n\n    @GuardedBy(\"mPm.mLock\")\n    private void commitPackagesLocked(List<ReconciledPackage> reconciledPackages,\n            @NonNull int[] allUsers) {\n        // TODO: remove any expected failures from this method; this should only be able to fail due\n        //       to unavoidable errors (I/O, etc.)\n        for (ReconciledPackage reconciledPkg : reconciledPackages) {\n            final InstallRequest installRequest = reconciledPkg.mInstallRequest;\n            final ParsedPackage parsedPackage = installRequest.getParsedPackage();\n            final String packageName = parsedPackage.getPackageName();\n            final RemovePackageHelper removePackageHelper = new RemovePackageHelper(mPm);\n            final DeletePackageHelper deletePackageHelper = new DeletePackageHelper(mPm);\n\n            installRequest.onCommitStarted();\n            if (installRequest.isInstallReplace()) {\n                AndroidPackage oldPackage = mPm.mPackages.get(packageName);\n\n                // Set the update and install times\n                PackageStateInternal deletedPkgSetting = mPm.snapshotComputer()\n                        .getPackageStateInternal(oldPackage.getPackageName());\n                // TODO(b/225756739): For rebootless APEX, consider using lastUpdateMillis provided\n                //  by apexd to be more accurate.\n                installRequest.setScannedPackageSettingFirstInstallTimeFromReplaced(\n                        deletedPkgSetting, allUsers);\n                installRequest.setScannedPackageSettingLastUpdateTime(\n                        System.currentTimeMillis());\n\n                installRequest.getRemovedInfo().mBroadcastAllowList =\n                        mPm.mAppsFilter.getVisibilityAllowList(mPm.snapshotComputer(),\n                                installRequest.getScannedPackageSetting(),\n                                allUsers, mPm.mSettings.getPackagesLocked());\n                if (installRequest.isInstallSystem()) {\n                    // Remove existing system package\n                    removePackageHelper.removePackage(oldPackage, true);\n                    if (!disableSystemPackageLPw(oldPackage)) {\n                        // We didn't need to disable the .apk as a current system package,\n                        // which means we are replacing another update that is already\n                        // installed.  We need to make sure to delete the older one's .apk.\n                        installRequest.getRemovedInfo().mArgs = new InstallArgs(\n                                oldPackage.getPath(),\n                                getAppDexInstructionSets(\n                                        deletedPkgSetting.getPrimaryCpuAbi(),\n                                        deletedPkgSetting.getSecondaryCpuAbi()));\n                    } else {\n                        installRequest.getRemovedInfo().mArgs = null;\n                    }\n                } else {\n                    try {\n                        // Settings will be written during the call to updateSettingsLI().\n                        deletePackageHelper.executeDeletePackage(\n                                reconciledPkg.mDeletePackageAction, packageName,\n                                true, allUsers, false);\n                    } catch (SystemDeleteException e) {\n                        if (mPm.mIsEngBuild) {\n                            throw new RuntimeException(\"Unexpected failure\", e);\n                            // ignore; not possible for non-system app\n                        }\n                    }\n                    // Successfully deleted the old package; proceed with replace.\n                    // Update the in-memory copy of the previous code paths.\n                    PackageSetting ps1 = mPm.mSettings.getPackageLPr(\n                            installRequest.getExistingPackageName());\n                    if ((installRequest.getInstallFlags() & PackageManager.DONT_KILL_APP)\n                            == 0) {\n                        Set<String> oldCodePaths = ps1.getOldCodePaths();\n                        if (oldCodePaths == null) {\n                            oldCodePaths = new ArraySet<>();\n                        }\n                        Collections.addAll(oldCodePaths, oldPackage.getBaseApkPath());\n                        Collections.addAll(oldCodePaths, oldPackage.getSplitCodePaths());\n                        ps1.setOldCodePaths(oldCodePaths);\n                    } else {\n                        ps1.setOldCodePaths(null);\n                    }\n\n                    if (installRequest.getReturnCode() == PackageManager.INSTALL_SUCCEEDED) {\n                        PackageSetting ps2 = mPm.mSettings.getPackageLPr(\n                                parsedPackage.getPackageName());\n                        if (ps2 != null) {\n                            installRequest.getRemovedInfo().mRemovedForAllUsers =\n                                    mPm.mPackages.get(ps2.getPackageName()) == null;\n                        }\n                    }\n                }\n            }\n\n            AndroidPackage pkg = commitReconciledScanResultLocked(reconciledPkg, allUsers);\n            updateSettingsLI(pkg, allUsers, installRequest);\n\n            final PackageSetting ps = mPm.mSettings.getPackageLPr(packageName);\n            if (ps != null) {\n                installRequest.setNewUsers(\n                        ps.queryInstalledUsers(mPm.mUserManager.getUserIds(), true));\n                ps.setUpdateAvailable(false /*updateAvailable*/);\n\n                File appMetadataFile = new File(ps.getPath(), APP_METADATA_FILE_NAME);\n                if (appMetadataFile.exists()) {\n                    ps.setAppMetadataFilePath(appMetadataFile.getAbsolutePath());\n                } else {\n                    ps.setAppMetadataFilePath(null);\n                }\n            }\n            if (installRequest.getReturnCode() == PackageManager.INSTALL_SUCCEEDED) {\n                mPm.updateSequenceNumberLP(ps, installRequest.getNewUsers());\n                mPm.updateInstantAppInstallerLocked(packageName);\n            }\n            installRequest.onCommitFinished();\n        }\n        ApplicationPackageManager.invalidateGetPackagesForUidCache();\n    }\n\n    @GuardedBy(\"mPm.mLock\")\n    private boolean disableSystemPackageLPw(AndroidPackage oldPkg) {\n        return mPm.mSettings.disableSystemPackageLPw(oldPkg.getPackageName(), true);\n    }\n\n    private void updateSettingsLI(AndroidPackage newPackage,\n            int[] allUsers, InstallRequest installRequest) {\n        updateSettingsInternalLI(newPackage, allUsers, installRequest);\n    }\n\n    private void updateSettingsInternalLI(AndroidPackage pkg,\n            int[] allUsers, InstallRequest installRequest) {\n        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"updateSettings\");\n\n        final String pkgName = pkg.getPackageName();\n        final int[] installedForUsers = installRequest.getOriginUsers();\n        final int installReason = installRequest.getInstallReason();\n        final String installerPackageName = installRequest.getInstallerPackageName();\n\n        if (DEBUG_INSTALL) Slog.d(TAG, \"New package installed in \" + pkg.getPath());\n        synchronized (mPm.mLock) {\n            // For system-bundled packages, we assume that installing an upgraded version\n            // of the package implies that the user actually wants to run that new code,\n            // so we enable the package.\n            final PackageSetting ps = mPm.mSettings.getPackageLPr(pkgName);\n            final int userId = installRequest.getUserId();\n            if (ps != null) {\n                if (ps.isSystem()) {\n                    if (DEBUG_INSTALL) {\n                        Slog.d(TAG, \"Implicitly enabling system package on upgrade: \" + pkgName);\n                    }\n                    // Enable system package for requested users\n                    if (installedForUsers != null\n                            && !installRequest.isApplicationEnabledSettingPersistent()) {\n                        for (int origUserId : installedForUsers) {\n                            if (userId == UserHandle.USER_ALL || userId == origUserId) {\n                                ps.setEnabled(COMPONENT_ENABLED_STATE_DEFAULT,\n                                        origUserId, installerPackageName);\n                            }\n                        }\n                    }\n                    // Also convey the prior install/uninstall state\n                    if (allUsers != null && installedForUsers != null) {\n                        for (int currentUserId : allUsers) {\n                            final boolean installed = ArrayUtils.contains(\n                                    installedForUsers, currentUserId);\n                            if (DEBUG_INSTALL) {\n                                Slog.d(TAG, \"    user \" + currentUserId + \" => \" + installed);\n                            }\n                            ps.setInstalled(installed, currentUserId);\n                        }\n                        // these install state changes will be persisted in the\n                        // upcoming call to mSettings.writeLPr().\n                    }\n\n                    if (allUsers != null) {\n                        for (int currentUserId : allUsers) {\n                            ps.resetOverrideComponentLabelIcon(currentUserId);\n                        }\n                    }\n                }\n\n                // Retrieve the overlays for shared libraries of the package.\n                if (!ps.getPkgState().getUsesLibraryInfos().isEmpty()) {\n                    for (SharedLibraryWrapper sharedLib : ps.getPkgState().getUsesLibraryInfos()) {\n                        for (int currentUserId : UserManagerService.getInstance().getUserIds()) {\n                            if (sharedLib.getType() != SharedLibraryInfo.TYPE_DYNAMIC) {\n                                // TODO(146804378): Support overlaying static shared libraries\n                                continue;\n                            }\n                            final PackageSetting libPs = mPm.mSettings.getPackageLPr(\n                                    sharedLib.getPackageName());\n                            if (libPs == null) {\n                                continue;\n                            }\n                            ps.setOverlayPathsForLibrary(sharedLib.getName(),\n                                    libPs.getOverlayPaths(currentUserId), currentUserId);\n                        }\n                    }\n                }\n\n                if (userId != UserHandle.USER_ALL) {\n                    // It's implied that when a user requests installation, they want the app to\n                    // be installed and enabled. The caller, however, can explicitly specify to\n                    // keep the existing enabled state.\n                    ps.setInstalled(true, userId);\n                    if (!installRequest.isApplicationEnabledSettingPersistent()) {\n                        ps.setEnabled(COMPONENT_ENABLED_STATE_DEFAULT, userId,\n                                installerPackageName);\n                    }\n                } else if (allUsers != null) {\n                    // The caller explicitly specified INSTALL_ALL_USERS flag.\n                    // Thus, updating the settings to install the app for all users.\n                    for (int currentUserId : allUsers) {\n                        // If the app is already installed for the currentUser,\n                        // keep it as installed as we might be updating the app at this place.\n                        // If not currently installed, check if the currentUser is restricted by\n                        // DISALLOW_INSTALL_APPS or DISALLOW_DEBUGGING_FEATURES device policy.\n                        // Install / update the app if the user isn't restricted. Skip otherwise.\n                        final boolean installedForCurrentUser = ArrayUtils.contains(\n                                installedForUsers, currentUserId);\n                        final boolean restrictedByPolicy =\n                                mPm.isUserRestricted(currentUserId,\n                                        UserManager.DISALLOW_INSTALL_APPS)\n                                || mPm.isUserRestricted(currentUserId,\n                                        UserManager.DISALLOW_DEBUGGING_FEATURES);\n                        if (installedForCurrentUser || !restrictedByPolicy) {\n                            ps.setInstalled(true, currentUserId);\n                            if (!installRequest.isApplicationEnabledSettingPersistent()) {\n                                ps.setEnabled(COMPONENT_ENABLED_STATE_DEFAULT, currentUserId,\n                                        installerPackageName);\n                            }\n                        } else {\n                            ps.setInstalled(false, currentUserId);\n                        }\n                    }\n                }\n\n                mPm.mSettings.addInstallerPackageNames(ps.getInstallSource());\n\n                // When replacing an existing package, preserve the original install reason for all\n                // users that had the package installed before. Similarly for uninstall reasons.\n                final Set<Integer> previousUserIds = new ArraySet<>();\n                if (installRequest.getRemovedInfo() != null\n                        && installRequest.getRemovedInfo().mInstallReasons != null) {\n                    final int installReasonCount =\n                            installRequest.getRemovedInfo().mInstallReasons.size();\n                    for (int i = 0; i < installReasonCount; i++) {\n                        final int previousUserId =\n                                installRequest.getRemovedInfo().mInstallReasons.keyAt(i);\n                        final int previousInstallReason =\n                                installRequest.getRemovedInfo().mInstallReasons.valueAt(i);\n                        ps.setInstallReason(previousInstallReason, previousUserId);\n                        previousUserIds.add(previousUserId);\n                    }\n                }\n                if (installRequest.getRemovedInfo() != null\n                        && installRequest.getRemovedInfo().mUninstallReasons != null) {\n                    for (int i = 0; i < installRequest.getRemovedInfo().mUninstallReasons.size();\n                            i++) {\n                        final int previousUserId =\n                                installRequest.getRemovedInfo().mUninstallReasons.keyAt(i);\n                        final int previousReason =\n                                installRequest.getRemovedInfo().mUninstallReasons.valueAt(i);\n                        ps.setUninstallReason(previousReason, previousUserId);\n                    }\n                }\n\n                // Set install reason for users that are having the package newly installed.\n                final int[] allUsersList = mPm.mUserManager.getUserIds();\n                if (userId == UserHandle.USER_ALL) {\n                    for (int currentUserId : allUsersList) {\n                        if (!previousUserIds.contains(currentUserId)\n                                && ps.getInstalled(currentUserId)) {\n                            ps.setInstallReason(installReason, currentUserId);\n                        }\n                    }\n                } else if (!previousUserIds.contains(userId)) {\n                    ps.setInstallReason(installReason, userId);\n                }\n\n                // TODO(b/169721400): generalize Incremental States and create a Callback object\n                // that can be used for all the packages.\n                final String codePath = ps.getPathString();\n                if (IncrementalManager.isIncrementalPath(codePath)\n                        && mIncrementalManager != null) {\n                    mIncrementalManager.registerLoadingProgressCallback(codePath,\n                            new IncrementalProgressListener(ps.getPackageName(), mPm));\n                }\n\n                // Ensure that the uninstall reason is UNKNOWN for users with the package installed.\n                for (int currentUserId : allUsersList) {\n                    if (ps.getInstalled(currentUserId)) {\n                        ps.setUninstallReason(UNINSTALL_REASON_UNKNOWN, currentUserId);\n                    }\n                }\n\n                mPm.mSettings.writeKernelMappingLPr(ps);\n\n                final PermissionManagerServiceInternal.PackageInstalledParams.Builder\n                        permissionParamsBuilder =\n                        new PermissionManagerServiceInternal.PackageInstalledParams.Builder();\n                final boolean grantRequestedPermissions = (installRequest.getInstallFlags()\n                        & PackageManager.INSTALL_GRANT_ALL_REQUESTED_PERMISSIONS) != 0;\n                if (grantRequestedPermissions) {\n                    var permissionStates = new ArrayMap<String, Integer>();\n                    var requestedPermissions = pkg.getRequestedPermissions();\n                    for (int index = 0; index < requestedPermissions.size(); index++) {\n                        var permissionName = requestedPermissions.get(index);\n                        permissionStates.put(permissionName,\n                                PackageInstaller.SessionParams.PERMISSION_STATE_GRANTED);\n                    }\n                    permissionParamsBuilder.setPermissionStates(permissionStates);\n                } else {\n                    var permissionStates = installRequest.getPermissionStates();\n                    if (permissionStates != null) {\n                        permissionParamsBuilder\n                                .setPermissionStates(permissionStates);\n                    }\n                }\n                final boolean allowlistAllRestrictedPermissions =\n                        (installRequest.getInstallFlags()\n                                & PackageManager.INSTALL_ALL_WHITELIST_RESTRICTED_PERMISSIONS) != 0;\n                final List<String> allowlistedRestrictedPermissions =\n                        allowlistAllRestrictedPermissions ? pkg.getRequestedPermissions()\n                                : installRequest.getAllowlistedRestrictedPermissions();\n                if (allowlistedRestrictedPermissions != null) {\n                    permissionParamsBuilder.setAllowlistedRestrictedPermissions(\n                            allowlistedRestrictedPermissions);\n                }\n                final int autoRevokePermissionsMode = installRequest.getAutoRevokePermissionsMode();\n                permissionParamsBuilder.setAutoRevokePermissionsMode(autoRevokePermissionsMode);\n                mPm.mPermissionManager.onPackageInstalled(pkg, installRequest.getPreviousAppId(),\n                        permissionParamsBuilder.build(), userId);\n                // Apply restricted settings on potentially dangerous packages.\n                if (installRequest.getPackageSource() == PackageInstaller.PACKAGE_SOURCE_LOCAL_FILE\n                        || installRequest.getPackageSource()\n                        == PackageInstaller.PACKAGE_SOURCE_DOWNLOADED_FILE) {\n                    enableRestrictedSettings(pkgName, pkg.getUid());\n                }\n            }\n            installRequest.setName(pkgName);\n            installRequest.setAppId(pkg.getUid());\n            installRequest.setPkg(pkg);\n            installRequest.setReturnCode(PackageManager.INSTALL_SUCCEEDED);\n            //to update install status\n            Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"writeSettings\");\n            mPm.writeSettingsLPrTEMP();\n            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n        }\n\n        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n    }\n\n    private void enableRestrictedSettings(String pkgName, int appId) {\n        final AppOpsManager appOpsManager = mPm.mContext.getSystemService(AppOpsManager.class);\n        final int[] allUsersList = mPm.mUserManager.getUserIds();\n        for (int userId : allUsersList) {\n            final int uid = UserHandle.getUid(userId, appId);\n            appOpsManager.setMode(AppOpsManager.OP_ACCESS_RESTRICTED_SETTINGS,\n                    uid,\n                    pkgName,\n                    AppOpsManager.MODE_ERRORED);\n        }\n    }\n\n    /**\n     * On successful install, executes remaining steps after commit completes and the package lock\n     * is released. These are typically more expensive or require calls to installd, which often\n     * locks on {@link com.android.server.pm.PackageManagerService.mLock}.\n     */\n    @GuardedBy(\"mPm.mInstallLock\")\n    private void executePostCommitStepsLIF(List<ReconciledPackage> reconciledPackages) {\n        final ArraySet<IncrementalStorage> incrementalStorages = new ArraySet<>();\n        for (ReconciledPackage reconciledPkg : reconciledPackages) {\n            final InstallRequest installRequest = reconciledPkg.mInstallRequest;\n            final boolean instantApp = ((installRequest.getScanFlags() & SCAN_AS_INSTANT_APP) != 0);\n            final boolean isApex = ((installRequest.getScanFlags() & SCAN_AS_APEX) != 0);\n            final AndroidPackage pkg = installRequest.getScannedPackageSetting().getPkg();\n            final String packageName = pkg.getPackageName();\n            final String codePath = pkg.getPath();\n            final boolean onIncremental = mIncrementalManager != null\n                    && isIncrementalPath(codePath);\n            if (onIncremental) {\n                IncrementalStorage storage = mIncrementalManager.openStorage(codePath);\n                if (storage == null) {\n                    throw new IllegalArgumentException(\n                            \"Install: null storage for incremental package \" + packageName);\n                }\n                incrementalStorages.add(storage);\n            }\n\n            // Hardcode previousAppId to 0 to disable any data migration (http://b/221088088)\n            mAppDataHelper.prepareAppDataPostCommitLIF(pkg, 0);\n            if (installRequest.isClearCodeCache()) {\n                mAppDataHelper.clearAppDataLIF(pkg, UserHandle.USER_ALL,\n                        FLAG_STORAGE_DE | FLAG_STORAGE_CE | FLAG_STORAGE_EXTERNAL\n                                | Installer.FLAG_CLEAR_CODE_CACHE_ONLY);\n            }\n            if (installRequest.isInstallReplace()) {\n                mDexManager.notifyPackageUpdated(pkg.getPackageName(),\n                        pkg.getBaseApkPath(), pkg.getSplitCodePaths());\n            }\n\n            if (!useArtService()) { // ART Service handles this on demand instead.\n                // Prepare the application profiles for the new code paths.\n                // This needs to be done before invoking dexopt so that any install-time profile\n                // can be used for optimizations.\n                try {\n                    mArtManagerService.prepareAppProfiles(pkg,\n                            mPm.resolveUserIds(installRequest.getUserId()),\n                            /* updateReferenceProfileContent= */ true);\n                } catch (LegacyDexoptDisabledException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            // Compute the compilation reason from the installation scenario.\n            final int compilationReason =\n                    mDexManager.getCompilationReasonForInstallScenario(\n                            installRequest.getInstallScenario());\n\n            // Construct the DexoptOptions early to see if we should skip running dexopt.\n            //\n            // Do not run PackageDexOptimizer through the local performDexOpt\n            // method because `pkg` may not be in `mPackages` yet.\n            //\n            // Also, don't fail application installs if the dexopt step fails.\n            final boolean isBackupOrRestore =\n                    installRequest.getInstallReason() == INSTALL_REASON_DEVICE_RESTORE\n                            || installRequest.getInstallReason() == INSTALL_REASON_DEVICE_SETUP;\n\n            final int dexoptFlags = DexoptOptions.DEXOPT_BOOT_COMPLETE\n                    | DexoptOptions.DEXOPT_CHECK_FOR_PROFILES_UPDATES\n                    | DexoptOptions.DEXOPT_INSTALL_WITH_DEX_METADATA_FILE\n                    | (isBackupOrRestore ? DexoptOptions.DEXOPT_FOR_RESTORE : 0);\n            DexoptOptions dexoptOptions =\n                    new DexoptOptions(packageName, compilationReason, dexoptFlags);\n\n            // Check whether we need to dexopt the app.\n            //\n            // NOTE: it is IMPORTANT to call dexopt:\n            //   - after doRename which will sync the package data from AndroidPackage and\n            //     its corresponding ApplicationInfo.\n            //   - after installNewPackageLIF or replacePackageLIF which will update result with the\n            //     uid of the application (pkg.applicationInfo.uid).\n            //     This update happens in place!\n            //\n            // We only need to dexopt if the package meets ALL of the following conditions:\n            //   1) it is not an instant app or if it is then dexopt is enabled via gservices.\n            //   2) it is not debuggable.\n            //   3) it is not on Incremental File System.\n            //\n            // Note that we do not dexopt instant apps by default. dexopt can take some time to\n            // complete, so we skip this step during installation. Instead, we'll take extra time\n            // the first time the instant app starts. It's preferred to do it this way to provide\n            // continuous progress to the useur instead of mysteriously blocking somewhere in the\n            // middle of running an instant app. The default behaviour can be overridden\n            // via gservices.\n            //\n            // Furthermore, dexopt may be skipped, depending on the install scenario and current\n            // state of the device.\n            //\n            // TODO(b/174695087): instantApp and onIncremental should be removed and their install\n            //       path moved to SCENARIO_FAST.\n            final boolean performDexopt =\n                    (!instantApp || android.provider.Settings.Global.getInt(\n                            mContext.getContentResolver(),\n                            android.provider.Settings.Global.INSTANT_APP_DEXOPT_ENABLED, 0) != 0)\n                            && !pkg.isDebuggable()\n                            && (!onIncremental)\n                            && dexoptOptions.isCompilationEnabled()\n                            && !isApex;\n\n            if (performDexopt) {\n                // Compile the layout resources.\n                if (SystemProperties.getBoolean(PRECOMPILE_LAYOUTS, false)) {\n                    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"compileLayouts\");\n                    mViewCompiler.compileLayouts(pkg);\n                    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n                }\n\n                Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"dexopt\");\n\n                // This mirrors logic from commitReconciledScanResultLocked, where the library files\n                // needed for dexopt are assigned.\n                PackageSetting realPkgSetting = installRequest.getRealPackageSetting();\n\n                // Unfortunately, the updated system app flag is only tracked on this PackageSetting\n                boolean isUpdatedSystemApp =\n                        installRequest.getScannedPackageSetting().isUpdatedSystemApp();\n\n                realPkgSetting.getPkgState().setUpdatedSystemApp(isUpdatedSystemApp);\n\n                if (useArtService()) {\n                    PackageManagerLocal packageManagerLocal =\n                            LocalManagerRegistry.getManager(PackageManagerLocal.class);\n                    try (PackageManagerLocal.FilteredSnapshot snapshot =\n                                    packageManagerLocal.withFilteredSnapshot()) {\n                        DexoptParams params =\n                                dexoptOptions.convertToDexoptParams(0 /* extraFlags */);\n                        DexoptResult dexOptResult = DexOptHelper.getArtManagerLocal().dexoptPackage(\n                                snapshot, packageName, params);\n                        installRequest.onDexoptFinished(dexOptResult);\n                    }\n                } else {\n                    try {\n                        mPackageDexOptimizer.performDexOpt(pkg, realPkgSetting,\n                                null /* instructionSets */,\n                                mPm.getOrCreateCompilerPackageStats(pkg),\n                                mDexManager.getPackageUseInfoOrDefault(packageName), dexoptOptions);\n                    } catch (LegacyDexoptDisabledException e) {\n                        throw new RuntimeException(e);\n                    }\n                }\n                Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n            }\n\n            if (!useArtService()) {\n                // Notify BackgroundDexOptService that the package has been changed.\n                // If this is an update of a package which used to fail to compile,\n                // BackgroundDexOptService will remove it from its denylist.\n                // ART Service currently doesn't support this and will retry packages in every\n                // background dexopt.\n                // TODO: Layering violation\n                try {\n                    BackgroundDexOptService.getService().notifyPackageChanged(packageName);\n                } catch (LegacyDexoptDisabledException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n        PackageManagerServiceUtils.waitForNativeBinariesExtractionForIncremental(\n                incrementalStorages);\n    }\n\n    Pair<Integer, String> verifyReplacingVersionCode(PackageInfoLite pkgLite,\n            long requiredInstalledVersionCode, int installFlags) {\n        if ((installFlags & PackageManager.INSTALL_APEX) != 0) {\n            return verifyReplacingVersionCodeForApex(\n                    pkgLite, requiredInstalledVersionCode, installFlags);\n        }\n\n        String packageName = pkgLite.packageName;\n        synchronized (mPm.mLock) {\n            // Package which currently owns the data that the new package will own if installed.\n            // If an app is uninstalled while keeping data (e.g. adb uninstall -k), installedPkg\n            // will be null whereas dataOwnerPkg will contain information about the package\n            // which was uninstalled while keeping its data.\n            AndroidPackage dataOwnerPkg = mPm.mPackages.get(packageName);\n            PackageSetting dataOwnerPs = mPm.mSettings.getPackageLPr(packageName);\n            if (dataOwnerPkg  == null) {\n                if (dataOwnerPs != null) {\n                    dataOwnerPkg = dataOwnerPs.getPkg();\n                }\n            }\n\n            if (requiredInstalledVersionCode != PackageManager.VERSION_CODE_HIGHEST) {\n                if (dataOwnerPkg == null) {\n                    String errorMsg = \"Required installed version code was \"\n                            + requiredInstalledVersionCode\n                            + \" but package is not installed\";\n                    Slog.w(TAG, errorMsg);\n                    return Pair.create(\n                            PackageManager.INSTALL_FAILED_WRONG_INSTALLED_VERSION, errorMsg);\n                }\n\n                if (dataOwnerPkg.getLongVersionCode() != requiredInstalledVersionCode) {\n                    String errorMsg = \"Required installed version code was \"\n                            + requiredInstalledVersionCode\n                            + \" but actual installed version is \"\n                            + dataOwnerPkg.getLongVersionCode();\n                    Slog.w(TAG, errorMsg);\n                    return Pair.create(\n                            PackageManager.INSTALL_FAILED_WRONG_INSTALLED_VERSION, errorMsg);\n                }\n            }\n\n            if (dataOwnerPkg != null && !dataOwnerPkg.isSdkLibrary()) {\n                if (!PackageManagerServiceUtils.isDowngradePermitted(installFlags,\n                        dataOwnerPkg.isDebuggable())) {\n                    // Downgrade is not permitted; a lower version of the app will not be allowed\n                    try {\n                        PackageManagerServiceUtils.checkDowngrade(dataOwnerPkg, pkgLite);\n                    } catch (PackageManagerException e) {\n                        String errorMsg = \"Downgrade detected: \" + e.getMessage();\n                        Slog.w(TAG, errorMsg);\n                        return Pair.create(\n                                PackageManager.INSTALL_FAILED_VERSION_DOWNGRADE, errorMsg);\n                    }\n                } else if (dataOwnerPs.isSystem()) {\n                    // Downgrade is permitted, but system apps can't be downgraded below\n                    // the version preloaded onto the system image\n                    final PackageSetting disabledPs = mPm.mSettings.getDisabledSystemPkgLPr(\n                            dataOwnerPs);\n                    if (disabledPs != null) {\n                        dataOwnerPkg = disabledPs.getPkg();\n                    }\n                    if (!Build.IS_DEBUGGABLE && !dataOwnerPkg.isDebuggable()) {\n                        // Only restrict non-debuggable builds and non-debuggable version of the app\n                        try {\n                            PackageManagerServiceUtils.checkDowngrade(dataOwnerPkg, pkgLite);\n                        } catch (PackageManagerException e) {\n                            String errorMsg =\n                                    \"System app: \" + packageName + \" cannot be downgraded to\"\n                                            + \" older than its preloaded version on the system\"\n                                            + \" image. \" + e.getMessage();\n                            Slog.w(TAG, errorMsg);\n                            return Pair.create(\n                                    PackageManager.INSTALL_FAILED_VERSION_DOWNGRADE, errorMsg);\n                        }\n                    }\n                }\n            }\n        }\n        return Pair.create(PackageManager.INSTALL_SUCCEEDED, null);\n    }\n\n    private Pair<Integer, String> verifyReplacingVersionCodeForApex(PackageInfoLite pkgLite,\n            long requiredInstalledVersionCode, int installFlags) {\n        String packageName = pkgLite.packageName;\n\n        final PackageInfo activePackage = mPm.snapshotComputer().getPackageInfo(\n                packageName, PackageManager.MATCH_APEX, UserHandle.USER_SYSTEM);\n        if (activePackage == null) {\n            String errorMsg = \"Attempting to install new APEX package \" + packageName;\n            Slog.w(TAG, errorMsg);\n            return Pair.create(PackageManager.INSTALL_FAILED_PACKAGE_CHANGED, errorMsg);\n        }\n\n        final long activeVersion = activePackage.getLongVersionCode();\n        if (requiredInstalledVersionCode != PackageManager.VERSION_CODE_HIGHEST\n                && activeVersion != requiredInstalledVersionCode) {\n            String errorMsg = \"Installed version of APEX package \" + packageName\n                    + \" does not match required. Active version: \" + activeVersion\n                    + \" required: \" + requiredInstalledVersionCode;\n            Slog.w(TAG, errorMsg);\n            return Pair.create(PackageManager.INSTALL_FAILED_WRONG_INSTALLED_VERSION, errorMsg);\n        }\n\n        final boolean isAppDebuggable = (activePackage.applicationInfo.flags\n                & ApplicationInfo.FLAG_DEBUGGABLE) != 0;\n        final long newVersionCode = pkgLite.getLongVersionCode();\n        if (!PackageManagerServiceUtils.isDowngradePermitted(installFlags, isAppDebuggable)\n                && newVersionCode < activeVersion) {\n            String errorMsg = \"Downgrade of APEX package \" + packageName\n                    + \" is not allowed. Active version: \" + activeVersion\n                    + \" attempted: \" + newVersionCode;\n            Slog.w(TAG, errorMsg);\n            return Pair.create(PackageManager.INSTALL_FAILED_VERSION_DOWNGRADE, errorMsg);\n        }\n\n        return Pair.create(PackageManager.INSTALL_SUCCEEDED, null);\n    }\n\n    int getUidForVerifier(VerifierInfo verifierInfo) {\n        synchronized (mPm.mLock) {\n            final AndroidPackage pkg = mPm.mPackages.get(verifierInfo.packageName);\n            if (pkg == null) {\n                return -1;\n            } else if (pkg.getSigningDetails().getSignatures().length != 1) {\n                Slog.i(TAG, \"Verifier package \" + verifierInfo.packageName\n                        + \" has more than one signature; ignoring\");\n                return -1;\n            }\n\n            /*\n             * If the public key of the package's signature does not match\n             * our expected public key, then this is a different package and\n             * we should skip.\n             */\n\n            final byte[] expectedPublicKey;\n            try {\n                final Signature verifierSig = pkg.getSigningDetails().getSignatures()[0];\n                final PublicKey publicKey = verifierSig.getPublicKey();\n                expectedPublicKey = publicKey.getEncoded();\n            } catch (CertificateException e) {\n                return -1;\n            }\n\n            final byte[] actualPublicKey = verifierInfo.publicKey.getEncoded();\n\n            if (!Arrays.equals(actualPublicKey, expectedPublicKey)) {\n                Slog.i(TAG, \"Verifier package \" + verifierInfo.packageName\n                        + \" does not have the expected public key; ignoring\");\n                return -1;\n            }\n\n            return pkg.getUid();\n        }\n    }\n\n    public void sendPendingBroadcasts() {\n        String[] packages;\n        ArrayList<String>[] components;\n        int numBroadcasts = 0, numUsers;\n        int[] uids;\n\n        synchronized (mPm.mLock) {\n            final SparseArray<ArrayMap<String, ArrayList<String>>> userIdToPackagesToComponents =\n                    mPm.mPendingBroadcasts.copiedMap();\n            numUsers = userIdToPackagesToComponents.size();\n            for (int n = 0; n < numUsers; n++) {\n                numBroadcasts += userIdToPackagesToComponents.valueAt(n).size();\n            }\n            if (numBroadcasts == 0) {\n                // Nothing to be done. Just return\n                return;\n            }\n            packages = new String[numBroadcasts];\n            components = new ArrayList[numBroadcasts];\n            uids = new int[numBroadcasts];\n            int i = 0;  // filling out the above arrays\n\n            for (int n = 0; n < numUsers; n++) {\n                final int packageUserId = userIdToPackagesToComponents.keyAt(n);\n                final ArrayMap<String, ArrayList<String>> componentsToBroadcast =\n                        userIdToPackagesToComponents.valueAt(n);\n                final int numComponents = CollectionUtils.size(componentsToBroadcast);\n                for (int index = 0; index < numComponents; index++) {\n                    packages[i] = componentsToBroadcast.keyAt(index);\n                    components[i] = componentsToBroadcast.valueAt(index);\n                    final PackageSetting ps = mPm.mSettings.getPackageLPr(packages[i]);\n                    uids[i] = (ps != null)\n                            ? UserHandle.getUid(packageUserId, ps.getAppId())\n                            : -1;\n                    i++;\n                }\n            }\n            numBroadcasts = i;\n            mPm.mPendingBroadcasts.clear();\n        }\n        final Computer snapshot = mPm.snapshotComputer();\n        // Send broadcasts\n        for (int i = 0; i < numBroadcasts; i++) {\n            mPm.sendPackageChangedBroadcast(snapshot, packages[i], true /* dontKillApp */,\n                    components[i], uids[i], null /* reason */);\n        }\n    }\n\n    void handlePackagePostInstall(InstallRequest request, boolean launchedForRestore) {\n        final boolean killApp =\n                (request.getInstallFlags() & PackageManager.INSTALL_DONT_KILL_APP) == 0;\n        final boolean virtualPreload =\n                ((request.getInstallFlags() & PackageManager.INSTALL_VIRTUAL_PRELOAD) != 0);\n        final String installerPackage = request.getInstallerPackageName();\n        final int dataLoaderType = request.getDataLoaderType();\n        final boolean succeeded = request.getReturnCode() == PackageManager.INSTALL_SUCCEEDED;\n        final boolean update = request.isUpdate();\n        final String packageName = request.getName();\n        final PackageStateInternal pkgSetting =\n                succeeded ? mPm.snapshotComputer().getPackageStateInternal(packageName) : null;\n        final boolean removedBeforeUpdate = (pkgSetting == null)\n                || (pkgSetting.isSystem() && !pkgSetting.getPath().getPath().equals(\n                request.getPkg().getPath()));\n        if (succeeded && removedBeforeUpdate) {\n            Slog.e(TAG, packageName + \" was removed before handlePackagePostInstall \"\n                    + \"could be executed\");\n            request.setReturnCode(INSTALL_FAILED_PACKAGE_CHANGED);\n            request.setReturnMessage(\"Package was removed before install could complete.\");\n\n            // Remove the update failed package's older resources safely now\n            mRemovePackageHelper.cleanUpResources(request.getOldCodeFile(),\n                    request.getOldInstructionSet());\n            mPm.notifyInstallObserver(request);\n            return;\n        }\n\n        if (succeeded) {\n            // Clear the uid cache after we installed a new package.\n            mPm.mPerUidReadTimeoutsCache = null;\n\n            // Send the removed broadcasts\n            if (request.getRemovedInfo() != null) {\n                if (request.getRemovedInfo().mIsExternal) {\n                    if (DEBUG_INSTALL) {\n                        Slog.i(TAG, \"upgrading pkg \" + request.getRemovedInfo().mRemovedPackage\n                                + \" is ASEC-hosted -> UNAVAILABLE\");\n                    }\n                    final String[] pkgNames = new String[]{\n                            request.getRemovedInfo().mRemovedPackage};\n                    final int[] uids = new int[]{request.getRemovedInfo().mUid};\n                    mBroadcastHelper.sendResourcesChangedBroadcast(mPm::snapshotComputer,\n                            false /* mediaStatus */, true /* replacing */, pkgNames, uids);\n                }\n                request.getRemovedInfo().sendPackageRemovedBroadcasts(\n                        killApp, false /*removedBySystem*/);\n            }\n\n            final String installerPackageName =\n                    request.getInstallerPackageName() != null\n                            ? request.getInstallerPackageName()\n                            : request.getRemovedInfo() != null\n                                    ? request.getRemovedInfo().mInstallerPackageName\n                                    : null;\n\n            mPm.notifyInstantAppPackageInstalled(request.getPkg().getPackageName(),\n                    request.getNewUsers());\n\n            // Determine the set of users who are adding this package for\n            // the first time vs. those who are seeing an update.\n            int[] firstUserIds = EMPTY_INT_ARRAY;\n            int[] firstInstantUserIds = EMPTY_INT_ARRAY;\n            int[] updateUserIds = EMPTY_INT_ARRAY;\n            int[] instantUserIds = EMPTY_INT_ARRAY;\n            final boolean allNewUsers = request.getOriginUsers() == null\n                    || request.getOriginUsers().length == 0;\n            for (int newUser : request.getNewUsers()) {\n                final boolean isInstantApp = pkgSetting.getUserStateOrDefault(newUser)\n                        .isInstantApp();\n                if (allNewUsers) {\n                    if (isInstantApp) {\n                        firstInstantUserIds = ArrayUtils.appendInt(firstInstantUserIds, newUser);\n                    } else {\n                        firstUserIds = ArrayUtils.appendInt(firstUserIds, newUser);\n                    }\n                    continue;\n                }\n                boolean isNew = true;\n                for (int origUser : request.getOriginUsers()) {\n                    if (origUser == newUser) {\n                        isNew = false;\n                        break;\n                    }\n                }\n                if (isNew) {\n                    if (isInstantApp) {\n                        firstInstantUserIds = ArrayUtils.appendInt(firstInstantUserIds, newUser);\n                    } else {\n                        firstUserIds = ArrayUtils.appendInt(firstUserIds, newUser);\n                    }\n                } else {\n                    if (isInstantApp) {\n                        instantUserIds = ArrayUtils.appendInt(instantUserIds, newUser);\n                    } else {\n                        updateUserIds = ArrayUtils.appendInt(updateUserIds, newUser);\n                    }\n                }\n            }\n\n            Bundle extras = new Bundle();\n            extras.putInt(Intent.EXTRA_UID, request.getAppId());\n            if (update) {\n                extras.putBoolean(Intent.EXTRA_REPLACING, true);\n            }\n            extras.putInt(PackageInstaller.EXTRA_DATA_LOADER_TYPE, dataLoaderType);\n\n            // If a package is a static shared library, then only the installer of the package\n            // should get the broadcast.\n            if (installerPackageName != null\n                    && request.getPkg().getStaticSharedLibraryName() != null) {\n                mPm.sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName,\n                        extras, 0 /*flags*/,\n                        installerPackageName, null /*finishedReceiver*/,\n                        request.getNewUsers(), null /* instantUserIds*/,\n                        null /* broadcastAllowList */, null);\n            }\n\n            // Send installed broadcasts if the package is not a static shared lib.\n            if (request.getPkg().getStaticSharedLibraryName() == null) {\n                mPm.mProcessLoggingHandler.invalidateBaseApkHash(request.getPkg().getBaseApkPath());\n\n                // Send PACKAGE_ADDED broadcast for users that see the package for the first time\n                // sendPackageAddedForNewUsers also deals with system apps\n                int appId = UserHandle.getAppId(request.getAppId());\n                boolean isSystem = request.isInstallSystem();\n                mPm.sendPackageAddedForNewUsers(mPm.snapshotComputer(), packageName,\n                        isSystem || virtualPreload, virtualPreload /*startReceiver*/, appId,\n                        firstUserIds, firstInstantUserIds, dataLoaderType);\n\n                // Send PACKAGE_ADDED broadcast for users that don't see\n                // the package for the first time\n\n                // Send to all running apps.\n                final SparseArray<int[]> newBroadcastAllowList;\n                synchronized (mPm.mLock) {\n                    final Computer snapshot = mPm.snapshotComputer();\n                    newBroadcastAllowList = mPm.mAppsFilter.getVisibilityAllowList(snapshot,\n                            snapshot.getPackageStateInternal(packageName, Process.SYSTEM_UID),\n                            updateUserIds, mPm.mSettings.getPackagesLocked());\n                }\n                mPm.sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName,\n                        extras, 0 /*flags*/,\n                        null /*targetPackage*/, null /*finishedReceiver*/,\n                        updateUserIds, instantUserIds, newBroadcastAllowList, null);\n                // Send to the installer, even if it's not running.\n                if (installerPackageName != null) {\n                    mPm.sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName,\n                            extras, 0 /*flags*/,\n                            installerPackageName, null /*finishedReceiver*/,\n                            updateUserIds, instantUserIds, null /* broadcastAllowList */, null);\n                }\n                // Send to PermissionController for all update users, even if it may not be running\n                // for some users\n                if (BroadcastHelper.isPrivacySafetyLabelChangeNotificationsEnabled(mContext)) {\n                    mPm.sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName,\n                            extras, 0 /*flags*/,\n                            mPm.mRequiredPermissionControllerPackage, null /*finishedReceiver*/,\n                            updateUserIds, instantUserIds, null /* broadcastAllowList */, null);\n                }\n                // Notify required verifier(s) that are not the installer of record for the package.\n                for (String verifierPackageName : mPm.mRequiredVerifierPackages) {\n                    if (verifierPackageName != null && !verifierPackageName.equals(\n                            installerPackageName)) {\n                        mPm.sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName,\n                                extras, 0 /*flags*/,\n                                verifierPackageName, null /*finishedReceiver*/,\n                                updateUserIds, instantUserIds, null /* broadcastAllowList */,\n                                null);\n                    }\n                }\n                // If package installer is defined, notify package installer about new\n                // app installed\n                if (mPm.mRequiredInstallerPackage != null) {\n                    mPm.sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName,\n                            extras, Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND /*flags*/,\n                            mPm.mRequiredInstallerPackage, null /*finishedReceiver*/,\n                            firstUserIds, instantUserIds, null /* broadcastAllowList */, null);\n                }\n\n                // Send replaced for users that don't see the package for the first time\n                if (update) {\n                    mPm.sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,\n                            packageName, extras, 0 /*flags*/,\n                            null /*targetPackage*/, null /*finishedReceiver*/,\n                            updateUserIds, instantUserIds,\n                            request.getRemovedInfo().mBroadcastAllowList, null);\n                    if (installerPackageName != null) {\n                        mPm.sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED, packageName,\n                                extras, 0 /*flags*/,\n                                installerPackageName, null /*finishedReceiver*/,\n                                updateUserIds, instantUserIds, null /*broadcastAllowList*/,\n                                null);\n                    }\n                    for (String verifierPackageName : mPm.mRequiredVerifierPackages) {\n                        if (verifierPackageName != null && !verifierPackageName.equals(\n                                installerPackageName)) {\n                            mPm.sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,\n                                    packageName, extras, 0 /*flags*/, verifierPackageName,\n                                    null /*finishedReceiver*/, updateUserIds, instantUserIds,\n                                    null /*broadcastAllowList*/, null);\n                        }\n                    }\n                    mPm.sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,\n                            null /*package*/, null /*extras*/, 0 /*flags*/,\n                            packageName /*targetPackage*/,\n                            null /*finishedReceiver*/, updateUserIds, instantUserIds,\n                            null /*broadcastAllowList*/,\n                            mBroadcastHelper.getTemporaryAppAllowlistBroadcastOptions(\n                                    REASON_PACKAGE_REPLACED).toBundle());\n                } else if (launchedForRestore && !request.isInstallSystem()) {\n                    // First-install and we did a restore, so we're responsible for the\n                    // first-launch broadcast.\n                    if (DEBUG_BACKUP) {\n                        Slog.i(TAG, \"Post-restore of \" + packageName\n                                + \" sending FIRST_LAUNCH in \" + Arrays.toString(firstUserIds));\n                    }\n                    mBroadcastHelper.sendFirstLaunchBroadcast(packageName, installerPackage,\n                            firstUserIds, firstInstantUserIds);\n                }\n\n                // Send broadcast package appeared if external for all users\n                if (request.getPkg().isExternalStorage()) {\n                    if (!update) {\n                        final StorageManager storageManager =\n                                mInjector.getSystemService(StorageManager.class);\n                        VolumeInfo volume =\n                                storageManager.findVolumeByUuid(\n                                        StorageManager.convert(\n                                                request.getPkg().getVolumeUuid()).toString());\n                        int packageExternalStorageType =\n                                PackageManagerServiceUtils.getPackageExternalStorageType(volume,\n                                        request.getPkg().isExternalStorage());\n                        // If the package was installed externally, log it.\n                        if (packageExternalStorageType != StorageEnums.UNKNOWN) {\n                            FrameworkStatsLog.write(\n                                    FrameworkStatsLog.APP_INSTALL_ON_EXTERNAL_STORAGE_REPORTED,\n                                    packageExternalStorageType, packageName);\n                        }\n                    }\n                    if (DEBUG_INSTALL) {\n                        Slog.i(TAG, \"upgrading pkg \" + request.getPkg() + \" is external\");\n                    }\n                    final String[] pkgNames = new String[]{packageName};\n                    final int[] uids = new int[]{request.getPkg().getUid()};\n                    mBroadcastHelper.sendResourcesChangedBroadcast(mPm::snapshotComputer,\n                            true /* mediaStatus */, true /* replacing */, pkgNames, uids);\n                }\n            } else if (!ArrayUtils.isEmpty(request.getLibraryConsumers())) { // if static shared lib\n                // No need to kill consumers if it's installation of new version static shared lib.\n                final Computer snapshot = mPm.snapshotComputer();\n                final boolean dontKillApp = !update\n                        && request.getPkg().getStaticSharedLibraryName() != null;\n                for (int i = 0; i < request.getLibraryConsumers().size(); i++) {\n                    AndroidPackage pkg = request.getLibraryConsumers().get(i);\n                    // send broadcast that all consumers of the static shared library have changed\n                    mPm.sendPackageChangedBroadcast(snapshot, pkg.getPackageName(), dontKillApp,\n                            new ArrayList<>(Collections.singletonList(pkg.getPackageName())),\n                            pkg.getUid(), null);\n                }\n            }\n\n            // Work that needs to happen on first install within each user\n            if (firstUserIds.length > 0) {\n                for (int userId : firstUserIds) {\n                    mPm.restorePermissionsAndUpdateRolesForNewUserInstall(packageName,\n                            userId);\n                }\n            }\n\n            if (allNewUsers && !update) {\n                mPm.notifyPackageAdded(packageName, request.getAppId());\n            } else {\n                mPm.notifyPackageChanged(packageName, request.getAppId());\n            }\n\n            // Log current value of \"unknown sources\" setting\n            EventLog.writeEvent(EventLogTags.UNKNOWN_SOURCES_ENABLED,\n                    getUnknownSourcesSettings());\n\n            // Remove the replaced package's older resources safely now\n            InstallArgs args = request.getRemovedInfo() != null\n                    ? request.getRemovedInfo().mArgs : null;\n            if (args != null) {\n                if (!killApp) {\n                    // If we didn't kill the app, defer the deletion of code/resource files, since\n                    // they may still be in use by the running application. This mitigates problems\n                    // in cases where resources or code is loaded by a new Activity before\n                    // ApplicationInfo changes have propagated to all application threads.\n                    mPm.scheduleDeferredNoKillPostDelete(args);\n                } else {\n                    mRemovePackageHelper.cleanUpResources(args.mCodeFile, args.mInstructionSets);\n                }\n            } else {\n                // Force a gc to clear up things. Ask for a background one, it's fine to go on\n                // and not block here.\n                VMRuntime.getRuntime().requestConcurrentGC();\n            }\n\n            final Computer snapshot = mPm.snapshotComputer();\n            // Notify DexManager that the package was installed for new users.\n            // The updated users should already be indexed and the package code paths\n            // should not change.\n            // Don't notify the manager for ephemeral apps as they are not expected to\n            // survive long enough to benefit of background optimizations.\n            for (int userId : firstUserIds) {\n                PackageInfo info = snapshot.getPackageInfo(packageName, /*flags*/ 0, userId);\n                // There's a race currently where some install events may interleave with an\n                // uninstall. This can lead to package info being null (b/36642664).\n                if (info != null) {\n                    mDexManager.notifyPackageInstalled(info, userId);\n                }\n            }\n        }\n\n        final boolean deferInstallObserver = succeeded && update;\n        if (deferInstallObserver) {\n            if (killApp) {\n                mPm.scheduleDeferredPendingKillInstallObserver(request);\n            } else {\n                mPm.scheduleDeferredNoKillInstallObserver(request);\n            }\n        } else {\n            mPm.notifyInstallObserver(request);\n        }\n\n        // Prune unused static shared libraries which have been cached a period of time\n        mPm.schedulePruneUnusedStaticSharedLibraries(true /* delay */);\n\n        // Log tracing if needed\n        if (request.getTraceMethod() != null) {\n            Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, request.getTraceMethod(),\n                    request.getTraceCookie());\n        }\n    }\n\n    /**\n     * Get the \"allow unknown sources\" setting.\n     *\n     * @return the current \"allow unknown sources\" setting\n     */\n    private int getUnknownSourcesSettings() {\n        return android.provider.Settings.Secure.getIntForUser(mContext.getContentResolver(),\n                android.provider.Settings.Secure.INSTALL_NON_MARKET_APPS,\n                -1, UserHandle.USER_SYSTEM);\n    }\n\n    /**\n     * Uncompress and install stub applications.\n     * <p>In order to save space on the system partition, some applications are shipped in a\n     * compressed form. In addition the compressed bits for the full application, the\n     * system image contains a tiny stub comprised of only the Android manifest.\n     * <p>During the first boot, attempt to uncompress and install the full application. If\n     * the application can't be installed for any reason, disable the stub and prevent\n     * uncompressing the full application during future boots.\n     * <p>In order to forcefully attempt an installation of a full application, go to app\n     * settings and enable the application.\n     */\n    @GuardedBy({\"mPm.mLock\", \"mPm.mInstallLock\"})\n    void installSystemStubPackages(@NonNull List<String> systemStubPackageNames,\n            @PackageManagerService.ScanFlags int scanFlags) {\n        for (int i = systemStubPackageNames.size() - 1; i >= 0; --i) {\n            final String packageName = systemStubPackageNames.get(i);\n            // skip if the system package is already disabled\n            if (mPm.mSettings.isDisabledSystemPackageLPr(packageName)) {\n                systemStubPackageNames.remove(i);\n                continue;\n            }\n            // skip if the package isn't installed (?!); this should never happen\n            final AndroidPackage pkg = mPm.mPackages.get(packageName);\n            if (pkg == null) {\n                systemStubPackageNames.remove(i);\n                continue;\n            }\n            // skip if the package has been disabled by the user\n            final PackageSetting ps = mPm.mSettings.getPackageLPr(packageName);\n            if (ps != null) {\n                final int enabledState = ps.getEnabled(UserHandle.USER_SYSTEM);\n                if (enabledState == PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER) {\n                    systemStubPackageNames.remove(i);\n                    continue;\n                }\n            }\n\n            // install the package to replace the stub on /system\n            try {\n                installStubPackageLI(pkg, 0, scanFlags);\n                ps.setEnabled(PackageManager.COMPONENT_ENABLED_STATE_DEFAULT,\n                        UserHandle.USER_SYSTEM, \"android\");\n                systemStubPackageNames.remove(i);\n            } catch (PackageManagerException e) {\n                Slog.e(TAG, \"Failed to parse uncompressed system package: \" + e.getMessage());\n            }\n\n            // any failed attempt to install the package will be cleaned up later\n        }\n\n        // disable any stub still left; these failed to install the full application\n        for (int i = systemStubPackageNames.size() - 1; i >= 0; --i) {\n            final String pkgName = systemStubPackageNames.get(i);\n            final PackageSetting ps = mPm.mSettings.getPackageLPr(pkgName);\n            ps.setEnabled(PackageManager.COMPONENT_ENABLED_STATE_DISABLED,\n                    UserHandle.USER_SYSTEM, \"android\");\n            logCriticalInfo(Log.ERROR, \"Stub disabled; pkg: \" + pkgName);\n        }\n    }\n\n    /**\n     * Extract, install and enable a stub package.\n     * <p>If the compressed file can not be extracted / installed for any reason, the stub\n     * APK will be installed and the package will be disabled. To recover from this situation,\n     * the user will need to go into system settings and re-enable the package.\n     */\n    boolean enableCompressedPackage(AndroidPackage stubPkg,\n            @NonNull PackageSetting stubPkgSetting) {\n        final int parseFlags = mPm.getDefParseFlags() | ParsingPackageUtils.PARSE_CHATTY\n                | ParsingPackageUtils.PARSE_ENFORCE_CODE;\n        synchronized (mPm.mInstallLock) {\n            final AndroidPackage pkg;\n            try (PackageFreezer freezer =\n                         mPm.freezePackage(stubPkg.getPackageName(), UserHandle.USER_ALL,\n                                 \"setEnabledSetting\",\n                                 ApplicationExitInfo.REASON_PACKAGE_UPDATED)) {\n                pkg = installStubPackageLI(stubPkg, parseFlags, 0 /*scanFlags*/);\n                mAppDataHelper.prepareAppDataAfterInstallLIF(pkg);\n                synchronized (mPm.mLock) {\n                    try {\n                        mSharedLibraries.updateSharedLibraries(\n                                pkg, stubPkgSetting, null, null,\n                                Collections.unmodifiableMap(mPm.mPackages));\n                    } catch (PackageManagerException e) {\n                        Slog.w(TAG, \"updateAllSharedLibrariesLPw failed: \", e);\n                    }\n                    mPm.mPermissionManager.onPackageInstalled(pkg,\n                            Process.INVALID_UID /* previousAppId */,\n                            PermissionManagerServiceInternal.PackageInstalledParams.DEFAULT,\n                            UserHandle.USER_ALL);\n                    mPm.writeSettingsLPrTEMP();\n                    // Since compressed package can be system app only, we do not need to\n                    // set restricted settings on it.\n                }\n            } catch (PackageManagerException e) {\n                // Whoops! Something went very wrong; roll back to the stub and disable the package\n                try (PackageFreezer freezer =\n                             mPm.freezePackage(stubPkg.getPackageName(), UserHandle.USER_ALL,\n                                     \"setEnabledSetting\",\n                                     ApplicationExitInfo.REASON_PACKAGE_UPDATED)) {\n                    synchronized (mPm.mLock) {\n                        // NOTE: Ensure the system package is enabled; even for a compressed stub.\n                        // If we don't, installing the system package fails during scan\n                        mPm.mSettings.enableSystemPackageLPw(stubPkg.getPackageName());\n                    }\n                    installPackageFromSystemLIF(stubPkg.getPath(),\n                            mPm.mUserManager.getUserIds() /*allUserHandles*/,\n                            null /*origUserHandles*/,\n                            true /*writeSettings*/);\n                } catch (PackageManagerException pme) {\n                    // Serious WTF; we have to be able to install the stub\n                    Slog.wtf(TAG, \"Failed to restore system package:\" + stubPkg.getPackageName(),\n                            pme);\n                } finally {\n                    // Disable the package; the stub by itself is not runnable\n                    synchronized (mPm.mLock) {\n                        final PackageSetting stubPs = mPm.mSettings.getPackageLPr(\n                                stubPkg.getPackageName());\n                        if (stubPs != null) {\n                            stubPs.setEnabled(COMPONENT_ENABLED_STATE_DISABLED,\n                                    UserHandle.USER_SYSTEM, \"android\");\n                        }\n                        mPm.writeSettingsLPrTEMP();\n                    }\n                }\n                return false;\n            }\n            mAppDataHelper.clearAppDataLIF(pkg, UserHandle.USER_ALL,\n                    FLAG_STORAGE_DE | FLAG_STORAGE_CE | FLAG_STORAGE_EXTERNAL\n                            | Installer.FLAG_CLEAR_CODE_CACHE_ONLY);\n            mDexManager.notifyPackageUpdated(pkg.getPackageName(),\n                    pkg.getBaseApkPath(), pkg.getSplitCodePaths());\n        }\n        return true;\n    }\n\n    @GuardedBy(\"mPm.mInstallLock\")\n    private AndroidPackage installStubPackageLI(AndroidPackage stubPkg,\n            @ParsingPackageUtils.ParseFlags int parseFlags,\n            @PackageManagerService.ScanFlags int scanFlags)\n            throws PackageManagerException {\n        if (DEBUG_COMPRESSION) {\n            Slog.i(TAG, \"Uncompressing system stub; pkg: \" + stubPkg.getPackageName());\n        }\n        // uncompress the binary to its eventual destination on /data\n        final File scanFile = decompressPackage(stubPkg.getPackageName(), stubPkg.getPath());\n        if (scanFile == null) {\n            throw PackageManagerException.ofInternalError(\n                    \"Unable to decompress stub at \" + stubPkg.getPath(),\n                    PackageManagerException.INTERNAL_ERROR_DECOMPRESS_STUB);\n        }\n        synchronized (mPm.mLock) {\n            mPm.mSettings.disableSystemPackageLPw(stubPkg.getPackageName(), true /*replaced*/);\n        }\n        final RemovePackageHelper removePackageHelper = new RemovePackageHelper(mPm);\n        removePackageHelper.removePackage(stubPkg, true /*chatty*/);\n        try {\n            return initPackageTracedLI(scanFile, parseFlags, scanFlags);\n        } catch (PackageManagerException e) {\n            Slog.w(TAG, \"Failed to install compressed system package:\" + stubPkg.getPackageName(),\n                    e);\n            // Remove the failed install\n            removePackageHelper.removeCodePath(scanFile);\n            throw e;\n        }\n    }\n\n    /**\n     * Decompresses the given package on the system image onto\n     * the /data partition.\n     * @return The directory the package was decompressed into. Otherwise, {@code null}.\n     */\n    @GuardedBy(\"mPm.mInstallLock\")\n    private File decompressPackage(String packageName, String codePath) {\n        if (!compressedFileExists(codePath)) {\n            if (DEBUG_COMPRESSION) {\n                Slog.i(TAG, \"No files to decompress at: \" + codePath);\n            }\n            return null;\n        }\n        final File dstCodePath =\n                PackageManagerServiceUtils.getNextCodePath(Environment.getDataAppDirectory(null),\n                        packageName);\n        int ret = PackageManagerServiceUtils.decompressFiles(codePath, dstCodePath, packageName);\n        if (ret == PackageManager.INSTALL_SUCCEEDED) {\n            ret = PackageManagerServiceUtils.extractNativeBinaries(dstCodePath, packageName);\n        }\n        if (ret == PackageManager.INSTALL_SUCCEEDED) {\n            // NOTE: During boot, we have to delay releasing cblocks for no other reason than\n            // we cannot retrieve the setting {@link Secure#RELEASE_COMPRESS_BLOCKS_ON_INSTALL}.\n            // When we no longer need to read that setting, cblock release can occur always\n            // occur here directly\n            if (!mPm.isSystemReady()) {\n                if (mPm.mReleaseOnSystemReady == null) {\n                    mPm.mReleaseOnSystemReady = new ArrayList<>();\n                }\n                mPm.mReleaseOnSystemReady.add(dstCodePath);\n            } else {\n                final ContentResolver resolver = mContext.getContentResolver();\n                F2fsUtils.releaseCompressedBlocks(resolver, dstCodePath);\n            }\n        } else {\n            if (!dstCodePath.exists()) {\n                return null;\n            }\n            new RemovePackageHelper(mPm).removeCodePath(dstCodePath);\n            return null;\n        }\n\n        return dstCodePath;\n    }\n\n    /**\n     * Tries to restore the disabled system package after an update has been deleted.\n     */\n    public void restoreDisabledSystemPackageLIF(DeletePackageAction action,\n            @NonNull int[] allUserHandles, boolean writeSettings) throws SystemDeleteException {\n        final PackageSetting deletedPs = action.mDeletingPs;\n        final PackageRemovedInfo outInfo = action.mRemovedInfo;\n        final PackageSetting disabledPs = action.mDisabledPs;\n\n        synchronized (mPm.mLock) {\n            // NOTE: The system package always needs to be enabled; even if it's for\n            // a compressed stub. If we don't, installing the system package fails\n            // during scan [scanning checks the disabled packages]. We will reverse\n            // this later, after we've \"installed\" the stub.\n            // Reinstate the old system package\n            mPm.mSettings.enableSystemPackageLPw(disabledPs.getPkg().getPackageName());\n            // Remove any native libraries from the upgraded package.\n            PackageManagerServiceUtils.removeNativeBinariesLI(deletedPs);\n        }\n        // Install the system package\n        if (DEBUG_REMOVE) Slog.d(TAG, \"Re-installing system package: \" + disabledPs);\n        try {\n            synchronized (mPm.mInstallLock) {\n                final int[] origUsers = outInfo == null ? null : outInfo.mOrigUsers;\n                installPackageFromSystemLIF(disabledPs.getPathString(), allUserHandles,\n                        origUsers, writeSettings);\n            }\n        } catch (PackageManagerException e) {\n            Slog.w(TAG, \"Failed to restore system package:\" + deletedPs.getPackageName() + \": \"\n                    + e.getMessage());\n            // TODO(b/194319951): can we avoid this; throw would come from scan...\n            throw new SystemDeleteException(e);\n        } finally {\n            if (disabledPs.getPkg().isStub()) {\n                // We've re-installed the stub; make sure it's disabled here. If package was\n                // originally enabled, we'll install the compressed version of the application\n                // and re-enable it afterward.\n                synchronized (mPm.mLock) {\n                    disableStubPackage(action, deletedPs, allUserHandles);\n                }\n            }\n        }\n    }\n\n    @GuardedBy(\"mPm.mLock\")\n    private void disableStubPackage(DeletePackageAction action, PackageSetting deletedPs,\n            @NonNull int[] allUserHandles) {\n        final PackageSetting stubPs = mPm.mSettings.getPackageLPr(\n                deletedPs.getPackageName());\n        if (stubPs != null) {\n            int userId = action.mUser == null\n                    ? UserHandle.USER_ALL : action.mUser.getIdentifier();\n            if (userId == UserHandle.USER_ALL) {\n                for (int aUserId : allUserHandles) {\n                    stubPs.setEnabled(COMPONENT_ENABLED_STATE_DISABLED, aUserId, \"android\");\n                }\n            } else if (userId >= UserHandle.USER_SYSTEM) {\n                stubPs.setEnabled(COMPONENT_ENABLED_STATE_DISABLED, userId, \"android\");\n            }\n        }\n    }\n\n    /**\n     * Installs a package that's already on the system partition.\n     */\n    @GuardedBy(\"mPm.mInstallLock\")\n    private void installPackageFromSystemLIF(@NonNull String codePathString,\n            @NonNull int[] allUserHandles, @Nullable int[] origUserHandles,\n            boolean writeSettings)\n            throws PackageManagerException {\n        final File codePath = new File(codePathString);\n        @ParsingPackageUtils.ParseFlags int parseFlags =\n                mPm.getDefParseFlags()\n                        | ParsingPackageUtils.PARSE_MUST_BE_APK\n                        | ParsingPackageUtils.PARSE_IS_SYSTEM_DIR;\n        @PackageManagerService.ScanFlags int scanFlags = mPm.getSystemPackageScanFlags(codePath);\n        final AndroidPackage pkg = initPackageTracedLI(codePath, parseFlags, scanFlags);\n\n        synchronized (mPm.mLock) {\n            PackageSetting pkgSetting = mPm.mSettings.getPackageLPr(pkg.getPackageName());\n            try {\n                // update shared libraries for the newly re-installed system package\n                mSharedLibraries.updateSharedLibraries(pkg, pkgSetting, null, null,\n                        Collections.unmodifiableMap(mPm.mPackages));\n            } catch (PackageManagerException e) {\n                Slog.e(TAG, \"updateAllSharedLibrariesLPw failed: \" + e.getMessage());\n            }\n        }\n        mAppDataHelper.prepareAppDataAfterInstallLIF(pkg);\n\n        setPackageInstalledForSystemPackage(pkg, allUserHandles, origUserHandles, writeSettings);\n    }\n\n    private void setPackageInstalledForSystemPackage(@NonNull AndroidPackage pkg,\n            @NonNull int[] allUserHandles, @Nullable int[] origUserHandles,\n            boolean writeSettings) {\n        // writer\n        synchronized (mPm.mLock) {\n            PackageSetting ps = mPm.mSettings.getPackageLPr(pkg.getPackageName());\n\n            final boolean applyUserRestrictions = origUserHandles != null;\n            if (applyUserRestrictions) {\n                boolean installedStateChanged = false;\n                if (DEBUG_REMOVE) {\n                    Slog.d(TAG, \"Propagating install state across reinstall\");\n                }\n                for (int userId : allUserHandles) {\n                    final boolean installed = ArrayUtils.contains(origUserHandles, userId);\n                    if (DEBUG_REMOVE) {\n                        Slog.d(TAG, \"    user \" + userId + \" => \" + installed);\n                    }\n                    if (installed != ps.getInstalled(userId)) {\n                        installedStateChanged = true;\n                    }\n                    ps.setInstalled(installed, userId);\n                    if (installed) {\n                        ps.setUninstallReason(UNINSTALL_REASON_UNKNOWN, userId);\n                    }\n                }\n                // Regardless of writeSettings we need to ensure that this restriction\n                // state propagation is persisted\n                mPm.mSettings.writeAllUsersPackageRestrictionsLPr();\n                if (installedStateChanged) {\n                    mPm.mSettings.writeKernelMappingLPr(ps);\n                }\n            }\n\n            // The method below will take care of removing obsolete permissions and granting\n            // install permissions.\n            mPm.mPermissionManager.onPackageInstalled(pkg, Process.INVALID_UID,\n                    PermissionManagerServiceInternal.PackageInstalledParams.DEFAULT,\n                    UserHandle.USER_ALL);\n            for (final int userId : allUserHandles) {\n                if (applyUserRestrictions) {\n                    mPm.mSettings.writePermissionStateForUserLPr(userId, false);\n                }\n            }\n\n            // can downgrade to reader here\n            if (writeSettings) {\n                mPm.writeSettingsLPrTEMP();\n            }\n        }\n    }\n\n    @GuardedBy(\"mPm.mLock\")\n    public void prepareSystemPackageCleanUp(\n            WatchedArrayMap<String, PackageSetting> packageSettings,\n            List<String> possiblyDeletedUpdatedSystemApps,\n            ArrayMap<String, File> expectingBetter, int[] userIds) {\n        // Iterates PackageSettings in reversed order because the item could be removed\n        // during the iteration.\n        for (int index = packageSettings.size() - 1; index >= 0; index--) {\n            final PackageSetting ps = packageSettings.valueAt(index);\n            final String packageName = ps.getPackageName();\n            /*\n             * If this is not a system app, it can't be a\n             * disable system app.\n             */\n            if (!ps.isSystem()) {\n                continue;\n            }\n\n            /*\n             * If the package is scanned, it's not erased.\n             */\n            final AndroidPackage scannedPkg = mPm.mPackages.get(packageName);\n            final PackageSetting disabledPs =\n                    mPm.mSettings.getDisabledSystemPkgLPr(packageName);\n            if (scannedPkg != null) {\n                if (scannedPkg.isApex()) {\n                    // APEX on /data has been scanned. No need to expect better.\n                    continue;\n                }\n                /*\n                 * If the system app is both scanned and in the\n                 * disabled packages list, then it must have been\n                 * added via OTA. Remove it from the currently\n                 * scanned package so the previously user-installed\n                 * application can be scanned.\n                 */\n                if (disabledPs != null) {\n                    logCriticalInfo(Log.WARN,\n                            \"Expecting better updated system app for \"\n                                    + packageName\n                                    + \"; removing system app.  Last known\"\n                                    + \" codePath=\" + ps.getPathString()\n                                    + \", versionCode=\" + ps.getVersionCode()\n                                    + \"; scanned versionCode=\"\n                                    + scannedPkg.getLongVersionCode());\n                    mRemovePackageHelper.removePackage(scannedPkg, true);\n                    expectingBetter.put(ps.getPackageName(), ps.getPath());\n                }\n\n                continue;\n            }\n\n            if (disabledPs == null) {\n                logCriticalInfo(Log.WARN, \"System package \" + packageName\n                        + \" no longer exists; its data will be wiped\");\n                mInjector.getHandler().post(\n                        () -> mRemovePackageHelper.removePackageData(ps, userIds, null, 0, false));\n            } else {\n                // we still have a disabled system package, but, it still might have\n                // been removed. check the code path still exists and check there's\n                // still a package. the latter can happen if an OTA keeps the same\n                // code path, but, changes the package name.\n                if (disabledPs.getPath() == null || !disabledPs.getPath().exists()\n                        || disabledPs.getPkg() == null) {\n                    possiblyDeletedUpdatedSystemApps.add(packageName);\n                } else {\n                    // We're expecting that the system app should remain disabled, but add\n                    // it to expecting better to recover in case the data version cannot\n                    // be scanned.\n                    expectingBetter.put(disabledPs.getPackageName(), disabledPs.getPath());\n                }\n            }\n        }\n    }\n\n    @GuardedBy(\"mPm.mLock\")\n    // Remove disable package settings for updated system apps that were\n    // removed via an OTA. If the update is no longer present, remove the\n    // app completely. Otherwise, revoke their system privileges.\n    public void cleanupDisabledPackageSettings(List<String> possiblyDeletedUpdatedSystemApps,\n            int[] userIds, int scanFlags) {\n        for (int i = possiblyDeletedUpdatedSystemApps.size() - 1; i >= 0; --i) {\n            final String packageName = possiblyDeletedUpdatedSystemApps.get(i);\n            final AndroidPackage pkg = mPm.mPackages.get(packageName);\n            final String msg;\n\n            // remove from the disabled system list; do this first so any future\n            // scans of this package are performed without this state\n            mPm.mSettings.removeDisabledSystemPackageLPw(packageName);\n\n            if (pkg == null) {\n                // should have found an update, but, we didn't; remove everything\n                msg = \"Updated system package \" + packageName\n                        + \" no longer exists; removing its data\";\n                // Actual deletion of code and data will be handled by later\n                // reconciliation step\n            } else {\n                // found an update; revoke system privileges\n                msg = \"Updated system package \" + packageName\n                        + \" no longer exists; rescanning package on data\";\n\n                // NOTE: We don't do anything special if a stub is removed from the\n                // system image. But, if we were [like removing the uncompressed\n                // version from the /data partition], this is where it'd be done.\n\n                // remove the package from the system and re-scan it without any\n                // special privileges\n                mRemovePackageHelper.removePackage(pkg, true);\n                PackageSetting ps = mPm.mSettings.getPackageLPr(packageName);\n                if (ps != null) {\n                    ps.getPkgState().setUpdatedSystemApp(false);\n                }\n\n                try {\n                    final File codePath = new File(pkg.getPath());\n                    synchronized (mPm.mInstallLock) {\n                        initPackageTracedLI(codePath, 0, scanFlags);\n                    }\n                } catch (PackageManagerException e) {\n                    Slog.e(TAG, \"Failed to parse updated, ex-system package: \"\n                            + e.getMessage());\n                }\n            }\n\n            // one final check. if we still have a package setting [ie. it was\n            // previously scanned and known to the system], but, we don't have\n            // a package [ie. there was an error scanning it from the /data\n            // partition], completely remove the package data.\n            final PackageSetting ps = mPm.mSettings.getPackageLPr(packageName);\n            if (ps != null && mPm.mPackages.get(packageName) == null) {\n                mRemovePackageHelper.removePackageData(ps, userIds, null, 0, false);\n            }\n            logCriticalInfo(Log.WARN, msg);\n        }\n    }\n\n    /**\n     * Scans APEX packages and registers them with the system.\n     *\n     * apexd has its own policy to decide which APEX to activate and which not. The policy might\n     * conflicts that of PMS. The APEX package info stored in PMS is a mirror of that managed by\n     * apexd. To keep things simple and keep activation status in sync for both apexd and PMS, we\n     * don't persist APEX in settings and always scan APEX from scratch during boot. However, some\n     * data like lastUpdateTime will be lost if PackageSetting is not persisted for APEX.\n     *\n     * TODO(b/225756739): Read lastUpdateTime from ApexInfoList to populate PackageSetting correctly\n     */\n    @GuardedBy({\"mPm.mInstallLock\", \"mPm.mLock\"})\n    public List<ApexManager.ScanResult> scanApexPackages(ApexInfo[] allPackages, int parseFlags,\n            int scanFlags, PackageParser2 packageParser, ExecutorService executorService) {\n        if (allPackages == null) {\n            return Collections.EMPTY_LIST;\n        }\n\n        ParallelPackageParser parallelPackageParser =\n                new ParallelPackageParser(packageParser, executorService);\n\n        // Submit files for parsing in parallel\n        ArrayMap<File, ApexInfo> parsingApexInfo = new ArrayMap<>();\n        for (ApexInfo ai : allPackages) {\n            File apexFile = new File(ai.modulePath);\n            parallelPackageParser.submit(apexFile, parseFlags);\n            parsingApexInfo.put(apexFile, ai);\n        }\n\n        List<ParallelPackageParser.ParseResult> parseResults =\n                new ArrayList<>(parsingApexInfo.size());\n        for (int i = 0; i < parsingApexInfo.size(); i++) {\n            ParallelPackageParser.ParseResult parseResult = parallelPackageParser.take();\n            parseResults.add(parseResult);\n        }\n        // Sort the list to ensure we always process factory packages first\n        Collections.sort(parseResults, (a, b) -> {\n            ApexInfo i1 = parsingApexInfo.get(a.scanFile);\n            ApexInfo i2 = parsingApexInfo.get(b.scanFile);\n            return Boolean.compare(i2.isFactory, i1.isFactory);\n        });\n\n\n        // Process results one by one\n        List<ApexManager.ScanResult> results = new ArrayList<>(parsingApexInfo.size());\n        for (int i = 0; i < parseResults.size(); i++) {\n            ParallelPackageParser.ParseResult parseResult = parseResults.get(i);\n            Throwable throwable = parseResult.throwable;\n            ApexInfo ai = parsingApexInfo.get(parseResult.scanFile);\n            int newParseFlags = parseFlags;\n            int newScanFlags = scanFlags | SCAN_AS_APEX\n                    | mPm.getSystemPackageScanFlags(parseResult.scanFile);\n            if (!ai.isFactory) {\n                newParseFlags &= ~ParsingPackageUtils.PARSE_IS_SYSTEM_DIR;\n                newScanFlags |= SCAN_NEW_INSTALL;\n            }\n\n            if (throwable == null) {\n                try {\n                    addForInitLI(parseResult.parsedPackage, newParseFlags, newScanFlags, null,\n                            new ApexManager.ActiveApexInfo(ai));\n                    AndroidPackage pkg = parseResult.parsedPackage.hideAsFinal();\n                    if (ai.isFactory && !ai.isActive) {\n                        disableSystemPackageLPw(pkg);\n                    }\n                    results.add(new ApexManager.ScanResult(ai, pkg, pkg.getPackageName()));\n                } catch (PackageManagerException e) {\n                    throw new IllegalStateException(\"Failed to scan: \" + ai.modulePath, e);\n                }\n            } else if (throwable instanceof PackageManagerException) {\n                throw new IllegalStateException(\"Unable to parse: \" + ai.modulePath, throwable);\n            } else {\n                throw new IllegalStateException(\"Unexpected exception occurred while parsing \"\n                        + ai.modulePath, throwable);\n            }\n        }\n\n        return results;\n    }\n\n    @GuardedBy({\"mPm.mInstallLock\", \"mPm.mLock\"})\n    public void installPackagesFromDir(File scanDir, int parseFlags,\n            int scanFlags, PackageParser2 packageParser, ExecutorService executorService,\n            @Nullable ApexManager.ActiveApexInfo apexInfo) {\n        final File[] files = scanDir.listFiles();\n        if (ArrayUtils.isEmpty(files)) {\n            Log.d(TAG, \"No files in app dir \" + scanDir);\n            return;\n        }\n\n        if (DEBUG_PACKAGE_SCANNING) {\n            Log.d(TAG, \"Scanning app dir \" + scanDir + \" scanFlags=\" + scanFlags\n                    + \" flags=0x\" + Integer.toHexString(parseFlags));\n        }\n        ParallelPackageParser parallelPackageParser =\n                new ParallelPackageParser(packageParser, executorService);\n\n        // Submit files for parsing in parallel\n        int fileCount = 0;\n        for (File file : files) {\n            final boolean isPackage = (isApkFile(file) || file.isDirectory())\n                    && !PackageInstallerService.isStageName(file.getName());\n            if (!isPackage) {\n                // Ignore entries which are not packages\n                continue;\n            }\n            if ((scanFlags & SCAN_DROP_CACHE) != 0) {\n                final PackageCacher cacher = new PackageCacher(mPm.getCacheDir());\n                Log.w(TAG, \"Dropping cache of \" + file.getAbsolutePath());\n                cacher.cleanCachedResult(file);\n            }\n            parallelPackageParser.submit(file, parseFlags);\n            fileCount++;\n        }\n\n        // Process results one by one\n        for (; fileCount > 0; fileCount--) {\n            ParallelPackageParser.ParseResult parseResult = parallelPackageParser.take();\n            Throwable throwable = parseResult.throwable;\n            int errorCode = PackageManager.INSTALL_SUCCEEDED;\n            String errorMsg = null;\n\n            if (throwable == null) {\n                try {\n                    addForInitLI(parseResult.parsedPackage, parseFlags, scanFlags,\n                            new UserHandle(UserHandle.USER_SYSTEM), apexInfo);\n                } catch (PackageManagerException e) {\n                    errorCode = e.error;\n                    errorMsg = \"Failed to scan \" + parseResult.scanFile + \": \" + e.getMessage();\n                    Slog.w(TAG, errorMsg);\n                }\n            } else if (throwable instanceof PackageManagerException) {\n                PackageManagerException e = (PackageManagerException) throwable;\n                errorCode = e.error;\n                errorMsg = \"Failed to parse \" + parseResult.scanFile + \": \" + e.getMessage();\n                Slog.w(TAG, errorMsg);\n            } else {\n                throw new IllegalStateException(\"Unexpected exception occurred while parsing \"\n                        + parseResult.scanFile, throwable);\n            }\n\n            if ((scanFlags & SCAN_AS_APK_IN_APEX) != 0 && errorCode != INSTALL_SUCCEEDED) {\n                mApexManager.reportErrorWithApkInApex(scanDir.getAbsolutePath(), errorMsg);\n            }\n\n            // Delete invalid userdata apps\n            if ((scanFlags & SCAN_AS_SYSTEM) == 0\n                    && errorCode != PackageManager.INSTALL_SUCCEEDED) {\n                logCriticalInfo(Log.WARN,\n                        \"Deleting invalid package at \" + parseResult.scanFile);\n                mRemovePackageHelper.removeCodePath(parseResult.scanFile);\n            }\n        }\n    }\n\n    /**\n     * Make sure all system apps that we expected to appear on\n     * the userdata partition actually showed up. If they never\n     * appeared, crawl back and revive the system version.\n     */\n    @GuardedBy(\"mPm.mLock\")\n    public void checkExistingBetterPackages(ArrayMap<String, File> expectingBetterPackages,\n            List<String> stubSystemApps, int systemScanFlags, int systemParseFlags) {\n        for (int i = 0; i < expectingBetterPackages.size(); i++) {\n            final String packageName = expectingBetterPackages.keyAt(i);\n            if (mPm.mPackages.containsKey(packageName)) {\n                continue;\n            }\n            final File scanFile = expectingBetterPackages.valueAt(i);\n\n            logCriticalInfo(Log.WARN, \"Expected better \" + packageName\n                    + \" but never showed up; reverting to system\");\n\n            final Pair<Integer, Integer> rescanAndReparseFlags =\n                    mPm.getSystemPackageRescanFlagsAndReparseFlags(scanFile,\n                            systemScanFlags, systemParseFlags);\n            @PackageManagerService.ScanFlags int rescanFlags = rescanAndReparseFlags.first;\n            @ParsingPackageUtils.ParseFlags int reparseFlags = rescanAndReparseFlags.second;\n\n            if (rescanFlags == 0) {\n                Slog.e(TAG, \"Ignoring unexpected fallback path \" + scanFile);\n                continue;\n            }\n            mPm.mSettings.enableSystemPackageLPw(packageName);\n\n            try {\n                synchronized (mPm.mInstallLock) {\n                    final AndroidPackage newPkg = initPackageTracedLI(\n                            scanFile, reparseFlags, rescanFlags);\n                    // We rescanned a stub, add it to the list of stubbed system packages\n                    if (newPkg.isStub()) {\n                        stubSystemApps.add(packageName);\n                    }\n                }\n            } catch (PackageManagerException e) {\n                Slog.e(TAG, \"Failed to parse original system package: \"\n                        + e.getMessage());\n            }\n        }\n    }\n\n    /**\n     *  Traces a package scan and registers it with the system.\n     *  @see #initPackageLI(File, int, int)\n     */\n    @GuardedBy(\"mPm.mInstallLock\")\n    public AndroidPackage initPackageTracedLI(File scanFile, final int parseFlags, int scanFlags)\n            throws PackageManagerException {\n        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"scanPackage [\" + scanFile.toString() + \"]\");\n        try {\n            return initPackageLI(scanFile, parseFlags, scanFlags);\n        } finally {\n            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n        }\n    }\n\n    /**\n     *  Scans a package, registers it with the system and returns the newly parsed package.\n     *  Returns {@code null} in case of errors and the error code is stored in mLastScanError\n     */\n    @GuardedBy(\"mPm.mInstallLock\")\n    private AndroidPackage initPackageLI(File scanFile, int parseFlags, int scanFlags)\n            throws PackageManagerException {\n        if (DEBUG_INSTALL) Slog.d(TAG, \"Parsing: \" + scanFile);\n\n        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"parsePackage\");\n        final ParsedPackage parsedPackage;\n        try (PackageParser2 pp = mPm.mInjector.getScanningPackageParser()) {\n            parsedPackage = pp.parsePackage(scanFile, parseFlags, false);\n        } finally {\n            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n        }\n\n        return addForInitLI(parsedPackage, parseFlags, scanFlags,\n                new UserHandle(UserHandle.USER_SYSTEM), null);\n    }\n\n    /**\n     * Adds a new package to the internal data structures during platform initialization.\n     * <p>After adding, the package is known to the system and available for querying.\n     * <p>For packages located on the device ROM [eg. packages located in /system, /vendor,\n     * etc...], additional checks are performed. Basic verification [such as ensuring\n     * matching signatures, checking version codes, etc...] occurs if the package is\n     * identical to a previously known package. If the package fails a signature check,\n     * the version installed on /data will be removed. If the version of the new package\n     * is less than or equal than the version on /data, it will be ignored.\n     * <p>Regardless of the package location, the results are applied to the internal\n     * structures and the package is made available to the rest of the system.\n     * <p>NOTE: The return value should be removed. It's the passed in package object.\n     */\n    @GuardedBy(\"mPm.mInstallLock\")\n    private AndroidPackage addForInitLI(ParsedPackage parsedPackage,\n            @ParsingPackageUtils.ParseFlags int parseFlags,\n            @PackageManagerService.ScanFlags int scanFlags,\n            @Nullable UserHandle user, @Nullable ApexManager.ActiveApexInfo activeApexInfo)\n            throws PackageManagerException {\n        PackageSetting disabledPkgSetting;\n        synchronized (mPm.mLock) {\n            // Static shared libraries have synthetic package names\n            if (activeApexInfo == null && parsedPackage.isStaticSharedLibrary()) {\n                PackageManagerService.renameStaticSharedLibraryPackage(parsedPackage);\n            }\n            disabledPkgSetting =\n                    mPm.mSettings.getDisabledSystemPkgLPr(parsedPackage.getPackageName());\n            if (activeApexInfo != null && disabledPkgSetting != null) {\n                // When a disabled system package is scanned, its final PackageSetting is actually\n                // skipped and not added to any data structures, instead relying on the disabled\n                // setting read from the persisted Settings XML file. This persistence does not\n                // include the APEX module name, so here, re-set it from the active APEX info.\n                //\n                // This also has the (beneficial) side effect where if a package disappears from an\n                // APEX, leaving only a /data copy, it will lose its apexModuleName.\n                //\n                // This must be done before scanSystemPackageLI as that will throw in the case of a\n                // system -> data package.\n                disabledPkgSetting.setApexModuleName(activeApexInfo.apexModuleName);\n            }\n        }\n\n        final Pair<ScanResult, Boolean> scanResultPair = scanSystemPackageLI(\n                parsedPackage, parseFlags, scanFlags, user);\n        final ScanResult scanResult = scanResultPair.first;\n        boolean shouldHideSystemApp = scanResultPair.second;\n        final InstallRequest installRequest = new InstallRequest(\n                parsedPackage, parseFlags, scanFlags, user, scanResult);\n\n        String existingApexModuleName = null;\n        synchronized (mPm.mLock) {\n            var existingPkgSetting = mPm.mSettings.getPackageLPr(parsedPackage.getPackageName());\n            if (existingPkgSetting != null) {\n                existingApexModuleName = existingPkgSetting.getApexModuleName();\n            }\n        }\n\n        if (activeApexInfo != null) {\n            installRequest.setApexModuleName(activeApexInfo.apexModuleName);\n        } else {\n            if (disabledPkgSetting != null) {\n                installRequest.setApexModuleName(disabledPkgSetting.getApexModuleName());\n            } else if (existingApexModuleName != null) {\n                installRequest.setApexModuleName(existingApexModuleName);\n            }\n        }\n\n        synchronized (mPm.mLock) {\n            boolean appIdCreated = false;\n            try {\n                final String pkgName = scanResult.mPkgSetting.getPackageName();\n                final List<ReconciledPackage> reconcileResult =\n                        ReconcilePackageUtils.reconcilePackages(\n                                Collections.singletonList(installRequest),\n                                mPm.mPackages, Collections.singletonMap(pkgName,\n                                        mPm.getSettingsVersionForPackage(parsedPackage)),\n                                mSharedLibraries, mPm.mSettings.getKeySetManagerService(),\n                                mPm.mSettings);\n                if ((scanFlags & SCAN_AS_APEX) == 0) {\n                    appIdCreated = optimisticallyRegisterAppId(installRequest);\n                } else {\n                    installRequest.setScannedPackageSettingAppId(Process.INVALID_UID);\n                }\n                commitReconciledScanResultLocked(reconcileResult.get(0),\n                        mPm.mUserManager.getUserIds());\n            } catch (PackageManagerException e) {\n                if (appIdCreated) {\n                    cleanUpAppIdCreation(installRequest);\n                }\n                throw e;\n            }\n        }\n\n        if (shouldHideSystemApp) {\n            synchronized (mPm.mLock) {\n                mPm.mSettings.disableSystemPackageLPw(parsedPackage.getPackageName(), true);\n            }\n        }\n\n        if (mIncrementalManager != null && isIncrementalPath(parsedPackage.getPath())) {\n            if (scanResult.mPkgSetting != null && scanResult.mPkgSetting.isLoading()) {\n                // Continue monitoring loading progress of active incremental packages\n                mIncrementalManager.registerLoadingProgressCallback(parsedPackage.getPath(),\n                        new IncrementalProgressListener(parsedPackage.getPackageName(), mPm));\n            }\n        }\n        return scanResult.mPkgSetting.getPkg();\n    }\n\n    /**\n     * Prepares the system to commit a {@link ScanResult} in a way that will not fail by registering\n     * the app ID required for reconcile.\n     * @return {@code true} if a new app ID was registered and will need to be cleaned up on\n     *         failure.\n     */\n    private boolean optimisticallyRegisterAppId(@NonNull InstallRequest installRequest)\n            throws PackageManagerException {\n        if (!installRequest.isExistingSettingCopied() || installRequest.needsNewAppId()) {\n            synchronized (mPm.mLock) {\n                // THROWS: when we can't allocate a user id. add call to check if there's\n                // enough space to ensure we won't throw; otherwise, don't modify state\n                return mPm.mSettings.registerAppIdLPw(installRequest.getScannedPackageSetting(),\n                        installRequest.needsNewAppId());\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Reverts any app ID creation that were made by\n     * {@link #optimisticallyRegisterAppId(InstallRequest)}. Note: this is only necessary if the\n     * referenced method returned true.\n     */\n    private void cleanUpAppIdCreation(@NonNull InstallRequest installRequest) {\n        // iff we've acquired an app ID for a new package setting, remove it so that it can be\n        // acquired by another request.\n        if (installRequest.getScannedPackageSetting() != null\n                && installRequest.getScannedPackageSetting().getAppId() > 0) {\n            synchronized (mPm.mLock) {\n                mPm.mSettings.removeAppIdLPw(installRequest.getScannedPackageSetting().getAppId());\n            }\n        }\n    }\n\n    @GuardedBy(\"mPm.mInstallLock\")\n    private ScanResult scanPackageTracedLI(ParsedPackage parsedPackage,\n            final @ParsingPackageUtils.ParseFlags int parseFlags,\n            @PackageManagerService.ScanFlags int scanFlags, long currentTime,\n            @Nullable UserHandle user, String cpuAbiOverride) throws PackageManagerException {\n        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"scanPackage\");\n        try {\n            return scanPackageNewLI(parsedPackage, parseFlags, scanFlags, currentTime, user,\n                    cpuAbiOverride);\n        } finally {\n            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n        }\n    }\n\n    private ScanRequest prepareInitialScanRequest(@NonNull ParsedPackage parsedPackage,\n            @ParsingPackageUtils.ParseFlags int parseFlags,\n            @PackageManagerService.ScanFlags int scanFlags,\n            @Nullable UserHandle user, String cpuAbiOverride)\n            throws PackageManagerException {\n        final AndroidPackage platformPackage;\n        final String realPkgName;\n        final PackageSetting disabledPkgSetting;\n        final PackageSetting installedPkgSetting;\n        final PackageSetting originalPkgSetting;\n        final SharedUserSetting sharedUserSetting;\n        SharedUserSetting oldSharedUserSetting = null;\n\n        synchronized (mPm.mLock) {\n            platformPackage = mPm.getPlatformPackage();\n            var isSystemApp = AndroidPackageUtils.isSystem(parsedPackage);\n            final String renamedPkgName = mPm.mSettings.getRenamedPackageLPr(\n                    AndroidPackageUtils.getRealPackageOrNull(parsedPackage, isSystemApp));\n            realPkgName = ScanPackageUtils.getRealPackageName(parsedPackage, renamedPkgName,\n                    isSystemApp);\n            if (realPkgName != null) {\n                ScanPackageUtils.ensurePackageRenamed(parsedPackage, renamedPkgName);\n            }\n            originalPkgSetting = getOriginalPackageLocked(parsedPackage, renamedPkgName);\n            installedPkgSetting = mPm.mSettings.getPackageLPr(parsedPackage.getPackageName());\n            if (mPm.mTransferredPackages.contains(parsedPackage.getPackageName())) {\n                Slog.w(TAG, \"Package \" + parsedPackage.getPackageName()\n                        + \" was transferred to another, but its .apk remains\");\n            }\n            disabledPkgSetting = mPm.mSettings.getDisabledSystemPkgLPr(\n                    parsedPackage.getPackageName());\n\n            boolean ignoreSharedUserId = false;\n            if (installedPkgSetting == null || !installedPkgSetting.hasSharedUser()) {\n                // Directly ignore sharedUserSetting for new installs, or if the app has\n                // already left shared UID\n                ignoreSharedUserId = parsedPackage.isLeavingSharedUser();\n            }\n\n            if (!ignoreSharedUserId && parsedPackage.getSharedUserId() != null) {\n                sharedUserSetting = mPm.mSettings.getSharedUserLPw(\n                        parsedPackage.getSharedUserId(),\n                        0 /*pkgFlags*/, 0 /*pkgPrivateFlags*/, true /*create*/);\n            } else {\n                sharedUserSetting = null;\n            }\n            if (DEBUG_PACKAGE_SCANNING\n                    && (parseFlags & ParsingPackageUtils.PARSE_CHATTY) != 0\n                    && sharedUserSetting != null) {\n                Log.d(TAG, \"Shared UserID \" + parsedPackage.getSharedUserId()\n                        + \" (uid=\" + sharedUserSetting.mAppId + \"):\"\n                        + \" packages=\" + sharedUserSetting.getPackageStates());\n            }\n            if (installedPkgSetting != null) {\n                oldSharedUserSetting = mPm.mSettings.getSharedUserSettingLPr(installedPkgSetting);\n            }\n        }\n\n        final boolean isPlatformPackage = platformPackage != null\n                && platformPackage.getPackageName().equals(parsedPackage.getPackageName());\n\n        return new ScanRequest(parsedPackage, oldSharedUserSetting,\n                installedPkgSetting == null ? null : installedPkgSetting.getPkg() /* oldPkg */,\n                installedPkgSetting /* packageSetting */,\n                sharedUserSetting,\n                disabledPkgSetting /* disabledPackageSetting */,\n                originalPkgSetting  /* originalPkgSetting */,\n                realPkgName, parseFlags, scanFlags, isPlatformPackage, user, cpuAbiOverride);\n    }\n\n    @GuardedBy(\"mPm.mInstallLock\")\n    private ScanResult scanPackageNewLI(@NonNull ParsedPackage parsedPackage,\n            final @ParsingPackageUtils.ParseFlags int parseFlags,\n            @PackageManagerService.ScanFlags int scanFlags, long currentTime,\n            @Nullable UserHandle user, String cpuAbiOverride)\n            throws PackageManagerException {\n        final ScanRequest initialScanRequest = prepareInitialScanRequest(parsedPackage, parseFlags,\n                scanFlags, user, cpuAbiOverride);\n        final PackageSetting installedPkgSetting = initialScanRequest.mPkgSetting;\n        final PackageSetting disabledPkgSetting = initialScanRequest.mDisabledPkgSetting;\n\n        boolean isUpdatedSystemApp;\n        if (installedPkgSetting != null) {\n            isUpdatedSystemApp = installedPkgSetting.isUpdatedSystemApp();\n        } else {\n            isUpdatedSystemApp = disabledPkgSetting != null;\n        }\n\n        final int newScanFlags = adjustScanFlags(scanFlags, installedPkgSetting, disabledPkgSetting,\n                user, parsedPackage);\n        ScanPackageUtils.applyPolicy(parsedPackage, newScanFlags,\n                mPm.getPlatformPackage(), isUpdatedSystemApp);\n\n        synchronized (mPm.mLock) {\n            assertPackageIsValid(parsedPackage, parseFlags, newScanFlags);\n            final ScanRequest request = new ScanRequest(parsedPackage,\n                    initialScanRequest.mOldSharedUserSetting,\n                    initialScanRequest.mOldPkg, installedPkgSetting,\n                    initialScanRequest.mSharedUserSetting, disabledPkgSetting,\n                    initialScanRequest.mOriginalPkgSetting, initialScanRequest.mRealPkgName,\n                    parseFlags, scanFlags, initialScanRequest.mIsPlatformPackage, user,\n                    cpuAbiOverride);\n            return ScanPackageUtils.scanPackageOnlyLI(request, mPm.mInjector, mPm.mFactoryTest,\n                    currentTime);\n        }\n    }\n\n    private Pair<ScanResult, Boolean> scanSystemPackageLI(ParsedPackage parsedPackage,\n            @ParsingPackageUtils.ParseFlags int parseFlags,\n            @PackageManagerService.ScanFlags int scanFlags,\n            @Nullable UserHandle user) throws PackageManagerException {\n        final boolean scanSystemPartition =\n                (parseFlags & ParsingPackageUtils.PARSE_IS_SYSTEM_DIR) != 0;\n        final ScanRequest initialScanRequest = prepareInitialScanRequest(parsedPackage, parseFlags,\n                scanFlags, user, null);\n        final PackageSetting installedPkgSetting = initialScanRequest.mPkgSetting;\n        final PackageSetting originalPkgSetting = initialScanRequest.mOriginalPkgSetting;\n        final PackageSetting pkgSetting =\n                originalPkgSetting == null ? installedPkgSetting : originalPkgSetting;\n        final boolean pkgAlreadyExists = pkgSetting != null;\n        final String disabledPkgName = pkgAlreadyExists\n                ? pkgSetting.getPackageName() : parsedPackage.getPackageName();\n        final boolean isSystemPkgUpdated;\n        final boolean isUpgrade;\n        synchronized (mPm.mLock) {\n            isUpgrade = mPm.isDeviceUpgrading();\n            if (scanSystemPartition && !pkgAlreadyExists\n                    && mPm.mSettings.getDisabledSystemPkgLPr(disabledPkgName) != null) {\n                // The updated-package data for /system apk remains inconsistently\n                // after the package data for /data apk is lost accidentally.\n                // To recover it, enable /system apk and install it as non-updated system app.\n                Slog.w(TAG, \"Inconsistent package setting of updated system app for \"\n                        + disabledPkgName + \". To recover it, enable the system app \"\n                        + \"and install it as non-updated system app.\");\n                mPm.mSettings.removeDisabledSystemPackageLPw(disabledPkgName);\n            }\n            final PackageSetting disabledPkgSetting =\n                    mPm.mSettings.getDisabledSystemPkgLPr(disabledPkgName);\n            isSystemPkgUpdated = disabledPkgSetting != null;\n\n            if (DEBUG_INSTALL && isSystemPkgUpdated) {\n                Slog.d(TAG, \"updatedPkg = \" + disabledPkgSetting);\n            }\n\n            if (scanSystemPartition && isSystemPkgUpdated) {\n                // we're updating the disabled package, so, scan it as the package setting\n                final ScanRequest request = new ScanRequest(parsedPackage,\n                        mPm.mSettings.getSharedUserSettingLPr(disabledPkgSetting),\n                        null, disabledPkgSetting /* pkgSetting */,\n                        initialScanRequest.mSharedUserSetting,\n                        null /* disabledPkgSetting */, null /* originalPkgSetting */,\n                        null, parseFlags, scanFlags,\n                        initialScanRequest.mIsPlatformPackage, user, null);\n                ScanPackageUtils.applyPolicy(parsedPackage, scanFlags,\n                        mPm.getPlatformPackage(), true);\n                final ScanResult scanResult =\n                        ScanPackageUtils.scanPackageOnlyLI(request, mPm.mInjector,\n                                mPm.mFactoryTest, -1L);\n                if (scanResult.mExistingSettingCopied\n                        && scanResult.mRequest.mPkgSetting != null) {\n                    scanResult.mRequest.mPkgSetting.updateFrom(scanResult.mPkgSetting);\n                }\n            }\n        } // End of mLock\n\n        final boolean newPkgChangedPaths = pkgAlreadyExists\n                && !pkgSetting.getPathString().equals(parsedPackage.getPath());\n        final boolean newPkgVersionGreater = pkgAlreadyExists\n                && parsedPackage.getLongVersionCode() > pkgSetting.getVersionCode();\n        final boolean newSharedUserSetting = pkgAlreadyExists\n                && (initialScanRequest.mOldSharedUserSetting\n                != initialScanRequest.mSharedUserSetting);\n        final boolean isSystemPkgBetter = scanSystemPartition && isSystemPkgUpdated\n                && newPkgChangedPaths && (newPkgVersionGreater || newSharedUserSetting);\n        if (isSystemPkgBetter) {\n            // The version of the application on /system is greater than the version on\n            // /data. Switch back to the application on /system.\n            // It's safe to assume the application on /system will correctly scan. If not,\n            // there won't be a working copy of the application.\n            // Also, if the sharedUserSetting of the application on /system is different\n            // from the sharedUserSetting on /data, switch back to the application on /system.\n            // We should trust the sharedUserSetting on /system, even if the application\n            // version on /system is smaller than the version on /data.\n            synchronized (mPm.mLock) {\n                // just remove the loaded entries from package lists\n                mPm.mPackages.remove(pkgSetting.getPackageName());\n            }\n\n            logCriticalInfo(Log.WARN,\n                    \"System package updated;\"\n                            + \" name: \" + pkgSetting.getPackageName()\n                            + \"; \" + pkgSetting.getVersionCode() + \" --> \"\n                            + parsedPackage.getLongVersionCode()\n                            + \"; \" + pkgSetting.getPathString()\n                            + \" --> \" + parsedPackage.getPath());\n\n            mRemovePackageHelper.cleanUpResources(\n                    new File(pkgSetting.getPathString()),\n                    getAppDexInstructionSets(pkgSetting.getPrimaryCpuAbiLegacy(),\n                            pkgSetting.getSecondaryCpuAbiLegacy()));\n            synchronized (mPm.mLock) {\n                mPm.mSettings.enableSystemPackageLPw(pkgSetting.getPackageName());\n            }\n        }\n\n        // The version of the application on the /system partition is less than or\n        // equal to the version on the /data partition. Throw an exception and use\n        // the application already installed on the /data partition.\n        if (scanSystemPartition && isSystemPkgUpdated && !isSystemPkgBetter) {\n            // In the case of a skipped package, commitReconciledScanResultLocked is not called to\n            // add the object to the \"live\" data structures, so this is the final mutation step\n            // for the package. Which means it needs to be finalized here to cache derived fields.\n            // This is relevant for cases where the disabled system package is used for flags or\n            // other metadata.\n            parsedPackage.hideAsFinal();\n            throw PackageManagerException.ofInternalError(\n                    \"Package \" + parsedPackage.getPackageName()\n                    + \" at \" + parsedPackage.getPath() + \" ignored: updated version \"\n                    + (pkgAlreadyExists ? String.valueOf(pkgSetting.getVersionCode()) : \"unknown\")\n                    + \" better than this \" + parsedPackage.getLongVersionCode(),\n                    PackageManagerException.INTERNAL_ERROR_UPDATED_VERSION_BETTER_THAN_SYSTEM);\n        }\n\n        // Verify certificates against what was last scanned. Force re-collecting certificate in two\n        // special cases:\n        // 1) when scanning system, force re-collect only if system is upgrading.\n        // 2) when scanning /data, force re-collect only if the app is privileged (updated from\n        // preinstall, or treated as privileged, e.g. due to shared user ID).\n        final boolean forceCollect = scanSystemPartition ? isUpgrade\n                : PackageManagerServiceUtils.isApkVerificationForced(pkgSetting);\n        if (DEBUG_VERIFY && forceCollect) {\n            Slog.d(TAG, \"Force collect certificate of \" + parsedPackage.getPackageName());\n        }\n\n        // Full APK verification can be skipped during certificate collection, only if the file is\n        // in verified partition, or can be verified on access (when apk verity is enabled). In both\n        // cases, only data in Signing Block is verified instead of the whole file.\n        final boolean skipVerify = scanSystemPartition\n                || (forceCollect && canSkipForcedPackageVerification(parsedPackage));\n        ScanPackageUtils.collectCertificatesLI(pkgSetting, parsedPackage,\n                mPm.getSettingsVersionForPackage(parsedPackage), forceCollect, skipVerify,\n                mPm.isPreNMR1Upgrade());\n\n        // Reset profile if the application version is changed\n        maybeClearProfilesForUpgradesLI(pkgSetting, parsedPackage);\n\n        /*\n         * A new system app appeared, but we already had a non-system one of the\n         * same name installed earlier.\n         */\n        boolean shouldHideSystemApp = false;\n        // A new application appeared on /system, but, we already have a copy of\n        // the application installed on /data.\n        if (scanSystemPartition && !isSystemPkgUpdated && pkgAlreadyExists\n                && !pkgSetting.isSystem()) {\n\n            if (!parsedPackage.getSigningDetails()\n                    .checkCapability(pkgSetting.getSigningDetails(),\n                            SigningDetails.CertCapabilities.INSTALLED_DATA)\n                    && !pkgSetting.getSigningDetails().checkCapability(\n                    parsedPackage.getSigningDetails(),\n                    SigningDetails.CertCapabilities.ROLLBACK)) {\n                logCriticalInfo(Log.WARN,\n                        \"System package signature mismatch;\"\n                                + \" name: \" + pkgSetting.getPackageName());\n                try (@SuppressWarnings(\"unused\") PackageFreezer freezer = mPm.freezePackage(\n                        parsedPackage.getPackageName(), UserHandle.USER_ALL,\n                        \"scanPackageInternalLI\", ApplicationExitInfo.REASON_OTHER)) {\n                    DeletePackageHelper deletePackageHelper = new DeletePackageHelper(mPm);\n                    deletePackageHelper.deletePackageLIF(parsedPackage.getPackageName(), null, true,\n                            mPm.mUserManager.getUserIds(), 0, null, false);\n                }\n            } else if (newPkgVersionGreater || newSharedUserSetting) {\n                // The application on /system is newer than the application on /data.\n                // Simply remove the application on /data [keeping application data]\n                // and replace it with the version on /system.\n                // Also, if the sharedUserSetting of the application on /system is different\n                // from the sharedUserSetting on data, we should trust the sharedUserSetting\n                // on /system, even if the application version on /system is smaller than\n                // the version on /data.\n                logCriticalInfo(Log.WARN,\n                        \"System package enabled;\"\n                                + \" name: \" + pkgSetting.getPackageName()\n                                + \"; \" + pkgSetting.getVersionCode() + \" --> \"\n                                + parsedPackage.getLongVersionCode()\n                                + \"; \" + pkgSetting.getPathString() + \" --> \"\n                                + parsedPackage.getPath());\n                mRemovePackageHelper.cleanUpResources(new File(pkgSetting.getPathString()),\n                        getAppDexInstructionSets(\n                                pkgSetting.getPrimaryCpuAbiLegacy(), pkgSetting.getSecondaryCpuAbiLegacy()));\n            } else {\n                // The application on /system is older than the application on /data. Hide\n                // the application on /system and the version on /data will be scanned later\n                // and re-added like an update.\n                shouldHideSystemApp = true;\n                logCriticalInfo(Log.INFO,\n                        \"System package disabled;\"\n                                + \" name: \" + pkgSetting.getPackageName()\n                                + \"; old: \" + pkgSetting.getPathString() + \" @ \"\n                                + pkgSetting.getVersionCode()\n                                + \"; new: \" + parsedPackage.getPath() + \" @ \"\n                                + parsedPackage.getPath());\n            }\n        }\n\n        // A new application appeared on /system, and we are seeing it for the first time.\n        // Its also not updated as we don't have a copy of it on /data. So, scan it in a\n        // STOPPED state.\n        // We'll skip this step under the following conditions:\n        //   - It's \"android\"\n        //   - It's an APEX or overlay package since stopped state does not affect them.\n        //   - It is enumerated with a <initial-package-state> tag having the stopped attribute\n        //     set to false\n        //   - It doesn't have an enabled and exported launcher activity, which means the user\n        //     wouldn't have a way to un-stop it\n        final boolean isApexPkg = (scanFlags & SCAN_AS_APEX) != 0;\n        if (mPm.mShouldStopSystemPackagesByDefault\n                && scanSystemPartition\n                && !pkgAlreadyExists\n                && !isApexPkg\n                && !parsedPackage.isOverlayIsStatic()\n        ) {\n            String packageName = parsedPackage.getPackageName();\n            if (!\"android\".contentEquals(packageName)\n                    && !mPm.mInitialNonStoppedSystemPackages.contains(packageName)\n                    && hasLauncherEntry(parsedPackage)) {\n                scanFlags |= SCAN_AS_STOPPED_SYSTEM_APP;\n            }\n        }\n\n        final ScanResult scanResult = scanPackageNewLI(parsedPackage, parseFlags,\n                scanFlags | SCAN_UPDATE_SIGNATURE, 0 /* currentTime */, user, null);\n        return new Pair<>(scanResult, shouldHideSystemApp);\n    }\n\n    private static boolean hasLauncherEntry(ParsedPackage parsedPackage) {\n        final HashSet<String> categories = new HashSet<>();\n        categories.add(Intent.CATEGORY_LAUNCHER);\n        final List<ParsedActivity> activities = parsedPackage.getActivities();\n        for (int indexActivity = 0; indexActivity < activities.size(); indexActivity++) {\n            final ParsedActivity activity = activities.get(indexActivity);\n            if (!activity.isEnabled() || !activity.isExported()) {\n                continue;\n            }\n            final List<ParsedIntentInfo> intents = activity.getIntents();\n            for (int indexIntent = 0; indexIntent < intents.size(); indexIntent++) {\n                final IntentFilter intentFilter = intents.get(indexIntent).getIntentFilter();\n                if (intentFilter != null && intentFilter.matchCategories(categories) == null) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns if forced apk verification can be skipped for the whole package, including splits.\n     */\n    private boolean canSkipForcedPackageVerification(AndroidPackage pkg) {\n        if (!VerityUtils.hasFsverity(pkg.getBaseApkPath())) {\n            return false;\n        }\n        // TODO: Allow base and splits to be verified individually.\n        String[] splitCodePaths = pkg.getSplitCodePaths();\n        if (!ArrayUtils.isEmpty(splitCodePaths)) {\n            for (int i = 0; i < splitCodePaths.length; i++) {\n                if (!VerityUtils.hasFsverity(splitCodePaths[i])) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Clear the package profile if this was an upgrade and the package\n     * version was updated.\n     */\n    private void maybeClearProfilesForUpgradesLI(\n            @Nullable PackageSetting originalPkgSetting,\n            @NonNull AndroidPackage pkg) {\n        if (originalPkgSetting == null || !mPm.isDeviceUpgrading()) {\n            return;\n        }\n        if (originalPkgSetting.getVersionCode() == pkg.getLongVersionCode()) {\n            return;\n        }\n\n        mAppDataHelper.clearAppProfilesLIF(pkg);\n        if (DEBUG_INSTALL) {\n            Slog.d(TAG, originalPkgSetting.getPackageName()\n                    + \" clear profile due to version change \"\n                    + originalPkgSetting.getVersionCode() + \" != \"\n                    + pkg.getLongVersionCode());\n        }\n    }\n\n    /**\n     * Returns the original package setting.\n     * <p>A package can migrate its name during an update. In this scenario, a package\n     * designates a set of names that it considers as one of its original names.\n     * <p>An original package must be signed identically and it must have the same\n     * shared user [if any].\n     */\n    @GuardedBy(\"mPm.mLock\")\n    @Nullable\n    private PackageSetting getOriginalPackageLocked(@NonNull AndroidPackage pkg,\n            @Nullable String renamedPkgName) {\n        if (ScanPackageUtils.isPackageRenamed(pkg, renamedPkgName)) {\n            return null;\n        }\n        for (int i = ArrayUtils.size(pkg.getOriginalPackages()) - 1; i >= 0; --i) {\n            final PackageSetting originalPs =\n                    mPm.mSettings.getPackageLPr(pkg.getOriginalPackages().get(i));\n            if (originalPs != null) {\n                // the package is already installed under its original name...\n                // but, should we use it?\n                if (!verifyPackageUpdateLPr(originalPs, pkg)) {\n                    // the new package is incompatible with the original\n                    continue;\n                } else if (mPm.mSettings.getSharedUserSettingLPr(originalPs) != null) {\n                    final String sharedUserSettingsName =\n                            mPm.mSettings.getSharedUserSettingLPr(originalPs).name;\n                    if (!sharedUserSettingsName.equals(pkg.getSharedUserId())) {\n                        // the shared user id is incompatible with the original\n                        Slog.w(TAG, \"Unable to migrate data from \" + originalPs.getPackageName()\n                                + \" to \" + pkg.getPackageName() + \": old shared user settings name \"\n                                + sharedUserSettingsName\n                                + \" differs from \" + pkg.getSharedUserId());\n                        continue;\n                    }\n                    // TODO: Add case when shared user id is added [b/28144775]\n                } else {\n                    if (DEBUG_UPGRADE) {\n                        Log.v(TAG, \"Renaming new package \"\n                                + pkg.getPackageName() + \" to old name \"\n                                + originalPs.getPackageName());\n                    }\n                }\n                return originalPs;\n            }\n        }\n        return null;\n    }\n\n    @GuardedBy(\"mPm.mLock\")\n    private boolean verifyPackageUpdateLPr(PackageSetting oldPkg, AndroidPackage newPkg) {\n        if ((oldPkg.getFlags() & ApplicationInfo.FLAG_SYSTEM) == 0) {\n            Slog.w(TAG, \"Unable to update from \" + oldPkg.getPackageName()\n                    + \" to \" + newPkg.getPackageName()\n                    + \": old package not in system partition\");\n            return false;\n        } else if (mPm.mPackages.get(oldPkg.getPackageName()) != null) {\n            Slog.w(TAG, \"Unable to update from \" + oldPkg.getPackageName()\n                    + \" to \" + newPkg.getPackageName()\n                    + \": old package still exists\");\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Asserts the parsed package is valid according to the given policy. If the\n     * package is invalid, for whatever reason, throws {@link PackageManagerException}.\n     * <p>\n     * Implementation detail: This method must NOT have any side effects. It would\n     * ideally be static, but, it requires locks to read system state.\n     *\n     * @throws PackageManagerException If the package fails any of the validation checks\n     */\n    private void assertPackageIsValid(AndroidPackage pkg,\n            final @ParsingPackageUtils.ParseFlags int parseFlags,\n            final @PackageManagerService.ScanFlags int scanFlags)\n            throws PackageManagerException {\n        if ((parseFlags & ParsingPackageUtils.PARSE_ENFORCE_CODE) != 0) {\n            ScanPackageUtils.assertCodePolicy(pkg);\n        }\n\n        if (pkg.getPath() == null) {\n            // Bail out. The resource and code paths haven't been set.\n            throw new PackageManagerException(INSTALL_FAILED_INVALID_APK,\n                    \"Code and resource paths haven't been set correctly\");\n        }\n\n        // Check that there is an APEX package with the same name only during install/first boot\n        // after OTA.\n        final boolean isUserInstall = (scanFlags & SCAN_BOOTING) == 0;\n        final boolean isFirstBootOrUpgrade = (scanFlags & SCAN_FIRST_BOOT_OR_UPGRADE) != 0;\n        // It is allowed to install a new APEX with the same name. But there shouldn't be\n        // conflicting names between APK and APEX.\n        final boolean installApex = (scanFlags & SCAN_AS_APEX) != 0;\n        if ((isUserInstall || isFirstBootOrUpgrade)\n                && mPm.snapshotComputer().isApexPackage(pkg.getPackageName())\n                && !installApex) {\n            throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE,\n                    pkg.getPackageName()\n                            + \" is an APEX package and can't be installed as an APK.\");\n        }\n\n        // Make sure we're not adding any bogus keyset info\n        final KeySetManagerService ksms = mPm.mSettings.getKeySetManagerService();\n        ksms.assertScannedPackageValid(pkg);\n\n        synchronized (mPm.mLock) {\n            // The special \"android\" package can only be defined once\n            if (pkg.getPackageName().equals(\"android\")) {\n                if (mPm.getCoreAndroidApplication() != null) {\n                    Slog.w(TAG, \"*************************************************\");\n                    Slog.w(TAG, \"Core android package being redefined.  Skipping.\");\n                    Slog.w(TAG, \" codePath=\" + pkg.getPath());\n                    Slog.w(TAG, \"*************************************************\");\n                    throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE,\n                            \"Core android package being redefined.  Skipping.\");\n                }\n            }\n\n            // A package name must be unique; don't allow duplicates\n            if ((scanFlags & SCAN_NEW_INSTALL) == 0\n                    && mPm.mPackages.containsKey(pkg.getPackageName())) {\n                throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE,\n                        \"Application package \" + pkg.getPackageName()\n                                + \" already installed.  Skipping duplicate.\");\n            }\n\n            if (pkg.isStaticSharedLibrary()) {\n                // Static libs have a synthetic package name containing the version\n                // but we still want the base name to be unique.\n                if ((scanFlags & SCAN_NEW_INSTALL) == 0\n                        && mPm.mPackages.containsKey(pkg.getManifestPackageName())) {\n                    throw PackageManagerException.ofInternalError(\n                            \"Duplicate static shared lib provider package\",\n                            PackageManagerException.INTERNAL_ERROR_DUP_STATIC_SHARED_LIB_PROVIDER);\n                }\n                ScanPackageUtils.assertStaticSharedLibraryIsValid(pkg, scanFlags);\n                assertStaticSharedLibraryVersionCodeIsValid(pkg);\n            }\n\n            // If we're only installing presumed-existing packages, require that the\n            // scanned APK is both already known and at the path previously established\n            // for it.  Previously unknown packages we pick up normally, but if we have an\n            // a priori expectation about this package's install presence, enforce it.\n            // With a singular exception for new system packages. When an OTA contains\n            // a new system package, we allow the codepath to change from a system location\n            // to the user-installed location. If we don't allow this change, any newer,\n            // user-installed version of the application will be ignored.\n            if ((scanFlags & SCAN_REQUIRE_KNOWN) != 0) {\n                if (mPm.isExpectingBetter(pkg.getPackageName())) {\n                    Slog.w(TAG, \"Relax SCAN_REQUIRE_KNOWN requirement for package \"\n                            + pkg.getPackageName());\n                } else {\n                    PackageSetting known = mPm.mSettings.getPackageLPr(pkg.getPackageName());\n                    if (known != null) {\n                        if (DEBUG_PACKAGE_SCANNING) {\n                            Log.d(TAG, \"Examining \" + pkg.getPath()\n                                    + \" and requiring known path \" + known.getPathString());\n                        }\n                        if (!pkg.getPath().equals(known.getPathString())) {\n                            throw new PackageManagerException(INSTALL_FAILED_PACKAGE_CHANGED,\n                                    \"Application package \" + pkg.getPackageName()\n                                            + \" found at \" + pkg.getPath()\n                                            + \" but expected at \" + known.getPathString()\n                                            + \"; ignoring.\");\n                        }\n                    } else {\n                        throw new PackageManagerException(INSTALL_FAILED_INVALID_INSTALL_LOCATION,\n                                \"Application package \" + pkg.getPackageName()\n                                        + \" not found; ignoring.\");\n                    }\n                }\n            }\n\n            // Verify that this new package doesn't have any content providers\n            // that conflict with existing packages.  Only do this if the\n            // package isn't already installed, since we don't want to break\n            // things that are installed.\n            if ((scanFlags & SCAN_NEW_INSTALL) != 0) {\n                mPm.mComponentResolver.assertProvidersNotDefined(pkg);\n            }\n\n            // If this package has defined explicit processes, then ensure that these are\n            // the only processes used by its components.\n            ScanPackageUtils.assertProcessesAreValid(pkg);\n\n            // Verify that packages sharing a user with a privileged app are marked as privileged.\n            assertPackageWithSharedUserIdIsPrivileged(pkg);\n\n            // Apply policies specific for runtime resource overlays (RROs).\n            if (pkg.getOverlayTarget() != null) {\n                assertOverlayIsValid(pkg, parseFlags, scanFlags);\n            }\n\n            // Ensure the package is signed with at least the minimum signature scheme version\n            // required for its target SDK.\n            ScanPackageUtils.assertMinSignatureSchemeIsValid(pkg, parseFlags);\n        }\n    }\n\n    private void assertStaticSharedLibraryVersionCodeIsValid(AndroidPackage pkg)\n            throws PackageManagerException {\n        // The version codes must be ordered as lib versions\n        long minVersionCode = Long.MIN_VALUE;\n        long maxVersionCode = Long.MAX_VALUE;\n\n        WatchedLongSparseArray<SharedLibraryInfo> versionedLib =\n                mSharedLibraries.getSharedLibraryInfos(pkg.getStaticSharedLibraryName());\n        if (versionedLib != null) {\n            final int versionCount = versionedLib.size();\n            for (int i = 0; i < versionCount; i++) {\n                SharedLibraryInfo libInfo = versionedLib.valueAt(i);\n                final long libVersionCode = libInfo.getDeclaringPackage()\n                        .getLongVersionCode();\n                if (libInfo.getLongVersion() < pkg.getStaticSharedLibraryVersion()) {\n                    minVersionCode = Math.max(minVersionCode, libVersionCode + 1);\n                } else if (libInfo.getLongVersion()\n                        > pkg.getStaticSharedLibraryVersion()) {\n                    maxVersionCode = Math.min(maxVersionCode, libVersionCode - 1);\n                } else {\n                    minVersionCode = maxVersionCode = libVersionCode;\n                    break;\n                }\n            }\n        }\n        if (pkg.getLongVersionCode() < minVersionCode\n                || pkg.getLongVersionCode() > maxVersionCode) {\n            throw PackageManagerException.ofInternalError(\"Static shared\"\n                    + \" lib version codes must be ordered as lib versions\",\n                    PackageManagerException.INTERNAL_ERROR_STATIC_SHARED_LIB_VERSION_CODES_ORDER);\n        }\n    }\n\n    private void assertOverlayIsValid(AndroidPackage pkg,\n            @ParsingPackageUtils.ParseFlags int parseFlags,\n            @PackageManagerService.ScanFlags int scanFlags) throws PackageManagerException {\n        // System overlays have some restrictions on their use of the 'static' state.\n        if ((scanFlags & SCAN_AS_SYSTEM) != 0) {\n            // We are scanning a system overlay. This can be the first scan of the\n            // system/vendor/oem partition, or an update to the system overlay.\n            if ((parseFlags & ParsingPackageUtils.PARSE_IS_SYSTEM_DIR) == 0) {\n                // This must be an update to a system overlay. Immutable overlays cannot be\n                // upgraded.\n                if (!mPm.isOverlayMutable(pkg.getPackageName())) {\n                    throw PackageManagerException.ofInternalError(\"Overlay \"\n                            + pkg.getPackageName()\n                            + \" is static and cannot be upgraded.\",\n                            PackageManagerException.INTERNAL_ERROR_SYSTEM_OVERLAY_STATIC);\n                }\n            } else {\n                if ((scanFlags & SCAN_AS_VENDOR) != 0) {\n                    if (pkg.getTargetSdkVersion() < ScanPackageUtils.getVendorPartitionVersion()) {\n                        Slog.w(TAG, \"System overlay \" + pkg.getPackageName()\n                                + \" targets an SDK below the required SDK level of vendor\"\n                                + \" overlays (\"\n                                + ScanPackageUtils.getVendorPartitionVersion()\n                                + \").\"\n                                + \" This will become an install error in a future release\");\n                    }\n                } else if (pkg.getTargetSdkVersion() < Build.VERSION.SDK_INT) {\n                    Slog.w(TAG, \"System overlay \" + pkg.getPackageName()\n                            + \" targets an SDK below the required SDK level of system\"\n                            + \" overlays (\" + Build.VERSION.SDK_INT + \").\"\n                            + \" This will become an install error in a future release\");\n                }\n            }\n        } else {\n            // A non-preloaded overlay packages must have targetSdkVersion >= Q, or be\n            // signed with the platform certificate. Check this in increasing order of\n            // computational cost.\n            if (pkg.getTargetSdkVersion() < Build.VERSION_CODES.Q) {\n                final PackageSetting platformPkgSetting;\n                synchronized (mPm.mLock) {\n                    platformPkgSetting = mPm.mSettings.getPackageLPr(\"android\");\n                }\n                if (!comparePackageSignatures(platformPkgSetting,\n                        pkg.getSigningDetails().getSignatures())) {\n                    throw PackageManagerException.ofInternalError(\"Overlay \"\n                            + pkg.getPackageName()\n                            + \" must target Q or later, \"\n                            + \"or be signed with the platform certificate\",\n                            PackageManagerException.INTERNAL_ERROR_OVERLAY_LOW_TARGET_SDK);\n                }\n            }\n\n            // A non-preloaded overlay package, without <overlay android:targetName>, will\n            // only be used if it is signed with the same certificate as its target OR if\n            // it is signed with the same certificate as a reference package declared\n            // in 'overlay-config-signature' tag of SystemConfig.\n            // If the target is already installed or 'overlay-config-signature' tag in\n            // SystemConfig is set, check this here to augment the last line of defense\n            // which is OMS.\n            if (pkg.getOverlayTargetOverlayableName() == null) {\n                final PackageSetting targetPkgSetting;\n                synchronized (mPm.mLock) {\n                    targetPkgSetting = mPm.mSettings.getPackageLPr(pkg.getOverlayTarget());\n                }\n                if (targetPkgSetting != null) {\n                    if (!comparePackageSignatures(targetPkgSetting,\n                            pkg.getSigningDetails().getSignatures())) {\n                        // check reference signature\n                        if (mPm.mOverlayConfigSignaturePackage == null) {\n                            throw PackageManagerException.ofInternalError(\"Overlay \"\n                                    + pkg.getPackageName() + \" and target \"\n                                    + pkg.getOverlayTarget() + \" signed with\"\n                                    + \" different certificates, and the overlay lacks\"\n                                    + \" <overlay android:targetName>\",\n                                    PackageManagerException.INTERNAL_ERROR_OVERLAY_SIGNATURE1);\n                        }\n                        final PackageSetting refPkgSetting;\n                        synchronized (mPm.mLock) {\n                            refPkgSetting = mPm.mSettings.getPackageLPr(\n                                    mPm.mOverlayConfigSignaturePackage);\n                        }\n                        if (!comparePackageSignatures(refPkgSetting,\n                                pkg.getSigningDetails().getSignatures())) {\n                            throw PackageManagerException.ofInternalError(\"Overlay \"\n                                    + pkg.getPackageName() + \" signed with a different \"\n                                    + \"certificate than both the reference package and \"\n                                    + \"target \" + pkg.getOverlayTarget() + \", and the \"\n                                    + \"overlay lacks <overlay android:targetName>\",\n                                    PackageManagerException.INTERNAL_ERROR_OVERLAY_SIGNATURE2);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    private void assertPackageWithSharedUserIdIsPrivileged(AndroidPackage pkg)\n            throws PackageManagerException {\n        if (!AndroidPackageUtils.isPrivileged(pkg) && (pkg.getSharedUserId() != null)) {\n            SharedUserSetting sharedUserSetting = null;\n            try {\n                synchronized (mPm.mLock) {\n                    sharedUserSetting = mPm.mSettings.getSharedUserLPw(pkg.getSharedUserId(),\n                            0, 0, false);\n                }\n            } catch (PackageManagerException ignore) {\n            }\n            if (sharedUserSetting != null && sharedUserSetting.isPrivileged()) {\n                // Exempt SharedUsers signed with the platform key.\n                final PackageSetting platformPkgSetting;\n                synchronized (mPm.mLock) {\n                    platformPkgSetting = mPm.mSettings.getPackageLPr(\"android\");\n                }\n                if (!comparePackageSignatures(platformPkgSetting,\n                        pkg.getSigningDetails().getSignatures())) {\n                    throw PackageManagerException.ofInternalError(\"Apps that share a user with a \"\n                            + \"privileged app must themselves be marked as privileged. \"\n                            + pkg.getPackageName() + \" shares privileged user \"\n                            + pkg.getSharedUserId() + \".\",\n                            PackageManagerException.INTERNAL_ERROR_NOT_PRIV_SHARED_USER);\n                }\n            }\n        }\n    }\n\n    private @PackageManagerService.ScanFlags int adjustScanFlags(\n            @PackageManagerService.ScanFlags int scanFlags,\n            @Nullable PackageSetting existingPkgSetting,\n            @Nullable PackageSetting disabledPkgSetting, UserHandle user,\n            @NonNull AndroidPackage pkg) {\n        scanFlags = ScanPackageUtils.adjustScanFlagsWithPackageSetting(scanFlags, existingPkgSetting,\n                disabledPkgSetting, user);\n\n        // Exception for privileged apps that share a user with a priv-app.\n        final boolean skipVendorPrivilegeScan = ((scanFlags & SCAN_AS_VENDOR) != 0)\n                && ScanPackageUtils.getVendorPartitionVersion() < 28;\n        if (((scanFlags & SCAN_AS_PRIVILEGED) == 0)\n                && !AndroidPackageUtils.isPrivileged(pkg)\n                && (pkg.getSharedUserId() != null)\n                && !skipVendorPrivilegeScan\n                && !pkg.isLeavingSharedUser()) {\n            SharedUserSetting sharedUserSetting = null;\n            synchronized (mPm.mLock) {\n                try {\n                    sharedUserSetting = mPm.mSettings.getSharedUserLPw(pkg.getSharedUserId(), 0,\n                            0, false);\n                } catch (PackageManagerException ignore) {\n                }\n                if (sharedUserSetting != null && sharedUserSetting.isPrivileged()) {\n                    // Exempt SharedUsers signed with the platform key.\n                    // TODO(b/72378145) Fix this exemption. Force signature apps\n                    // to allowlist their privileged permissions just like other\n                    // priv-apps.\n                    PackageSetting platformPkgSetting = mPm.mSettings.getPackageLPr(\"android\");\n                    if ((compareSignatures(\n                            platformPkgSetting.getSigningDetails().getSignatures(),\n                            pkg.getSigningDetails().getSignatures())\n                            != PackageManager.SIGNATURE_MATCH)) {\n                        scanFlags |= SCAN_AS_PRIVILEGED;\n                    }\n                }\n            }\n        }\n\n        return scanFlags;\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 46808,
                                        "general": {
                                            "word_based": 18993,
                                            "char_based": 63698
                                        },
                                        "gemini": 54081
                                    }
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-343440463",
            "aliases": [
                "A-343440463",
                "CVE-2024-43086"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-343440463",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "ddfc078af7e89641360b896f99af23a6b371b847"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From ddfc078af7e89641360b896f99af23a6b371b847 Mon Sep 17 00:00:00 2001\nFrom: Dmitry Dementyev <dementyev@google.com>\nDate: Tue, 2 Jul 2024 11:02:07 -0700\nSubject: [PATCH] Remove authenticator data if it was disabled.\n\nTest: manual\nBug: 343440463\nFlag: EXEMPT bugfix\nChange-Id: I36bd6bf101da03c9c30a6d3c0080b801e7898bc6\n---\n .../com/android/server/accounts/AccountManagerService.java    | 4 ++++\n 1 file changed, 4 insertions(+)\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex ac9ed0da95a5..320122390681 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -1233,6 +1233,10 @@ public class AccountManagerService\n                             obsoleteAuthType.add(type);\n                             // And delete it from the TABLE_META\n                             accountsDb.deleteMetaByAuthTypeAndUid(type, uid);\n+                        } else if (knownUid != null && knownUid != uid) {\n+                            Slog.w(TAG, \"authenticator no longer exist for type \" + type);\n+                            obsoleteAuthType.add(type);\n+                            accountsDb.deleteMetaByAuthTypeAndUid(type, uid);\n                         }\n                     }\n                 }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 371,
                        "general": {
                            "word_based": 150,
                            "char_based": 363
                        },
                        "gemini": 495
                    },
                    "total_downstream_versions_tested": 0,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": []
                }
            ]
        },
        {
            "id": "ASB-A-333364513",
            "aliases": [
                "A-333364513",
                "CVE-2024-40654"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-333364513",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "901880a1d2e632179eb4ac708fc4bc18d9d50791"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 901880a1d2e632179eb4ac708fc4bc18d9d50791 Mon Sep 17 00:00:00 2001\nFrom: Jason Chiu <chiujason@google.com>\nDate: Wed, 31 Jan 2024 16:29:01 +0800\nSubject: [PATCH] Replace getCallingActivity() with getLaunchedFromPackage()\n\ngetLaunchedFromPackage() reports who launched this Activity or built\nPendingIntent used to launch it, whereas getCallingActivity() reports\nwho will get result of Activity.\n\nBug: 316891059\nTest: robotest, manual\nChange-Id: If97018c2741caef622f0596bbfeaa42ef1788b78\n---\n .../settings/search/SearchFeatureProvider.java |  2 +-\n .../search/SearchFeatureProviderImpl.java      | 18 ++++++++----------\n .../search/SearchResultTrampoline.java         | 13 ++++++-------\n .../search/SearchFeatureProviderImplTest.java  | 15 ++++++++-------\n 4 files changed, 23 insertions(+), 25 deletions(-)\n\ndiff --git a/src/com/android/settings/search/SearchFeatureProvider.java b/src/com/android/settings/search/SearchFeatureProvider.java\nindex 0741ce4b02c..b1d04d4398c 100644\n--- a/src/com/android/settings/search/SearchFeatureProvider.java\n+++ b/src/com/android/settings/search/SearchFeatureProvider.java\n@@ -56,7 +56,7 @@ public interface SearchFeatureProvider {\n      * @throws IllegalArgumentException when caller is null\n      * @throws SecurityException        when caller is not allowed to launch search result page\n      */\n-    void verifyLaunchSearchResultPageCaller(Context context, @NonNull ComponentName caller)\n+    void verifyLaunchSearchResultPageCaller(@NonNull Context context, @NonNull String callerPackage)\n             throws SecurityException, IllegalArgumentException;\n \n     /**\ndiff --git a/src/com/android/settings/search/SearchFeatureProviderImpl.java b/src/com/android/settings/search/SearchFeatureProviderImpl.java\nindex 6f909709058..3a62ddfb67e 100644\n--- a/src/com/android/settings/search/SearchFeatureProviderImpl.java\n+++ b/src/com/android/settings/search/SearchFeatureProviderImpl.java\n@@ -17,13 +17,14 @@\n \n package com.android.settings.search;\n \n-import android.content.ComponentName;\n import android.content.Context;\n import android.content.Intent;\n import android.net.Uri;\n import android.provider.Settings;\n import android.text.TextUtils;\n \n+import androidx.annotation.NonNull;\n+\n import com.android.settingslib.search.SearchIndexableResources;\n import com.android.settingslib.search.SearchIndexableResourcesMobile;\n \n@@ -32,21 +33,18 @@ import com.android.settingslib.search.SearchIndexableResourcesMobile;\n  */\n public class SearchFeatureProviderImpl implements SearchFeatureProvider {\n \n-    private static final String TAG = \"SearchFeatureProvider\";\n-\n     private SearchIndexableResources mSearchIndexableResources;\n \n     @Override\n-    public void verifyLaunchSearchResultPageCaller(Context context, ComponentName caller) {\n-        if (caller == null) {\n+    public void verifyLaunchSearchResultPageCaller(@NonNull Context context,\n+            @NonNull String callerPackage) {\n+        if (TextUtils.isEmpty(callerPackage)) {\n             throw new IllegalArgumentException(\"ExternalSettingsTrampoline intents \"\n                     + \"must be called with startActivityForResult\");\n         }\n-        final String packageName = caller.getPackageName();\n-        final boolean isSettingsPackage = TextUtils.equals(packageName, context.getPackageName())\n-                || TextUtils.equals(getSettingsIntelligencePkgName(context), packageName);\n-        final boolean isAllowlistedPackage =\n-                isSignatureAllowlisted(context, caller.getPackageName());\n+        final boolean isSettingsPackage = TextUtils.equals(callerPackage, context.getPackageName())\n+                || TextUtils.equals(getSettingsIntelligencePkgName(context), callerPackage);\n+        final boolean isAllowlistedPackage = isSignatureAllowlisted(context, callerPackage);\n         if (isSettingsPackage || isAllowlistedPackage) {\n             return;\n         }\ndiff --git a/src/com/android/settings/search/SearchResultTrampoline.java b/src/com/android/settings/search/SearchResultTrampoline.java\nindex 5d897af3b35..04d9db56eb7 100644\n--- a/src/com/android/settings/search/SearchResultTrampoline.java\n+++ b/src/com/android/settings/search/SearchResultTrampoline.java\n@@ -21,7 +21,6 @@ import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n import static com.android.settings.activityembedding.EmbeddedDeepLinkUtils.getTrampolineIntent;\n \n import android.app.Activity;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.net.Uri;\n import android.os.Bundle;\n@@ -53,11 +52,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFeatureFactory()\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -106,7 +105,7 @@ public class SearchResultTrampoline extends Activity {\n         if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)\n                 || ActivityEmbeddingUtils.isAlreadyEmbedded(this)) {\n             startActivity(intent);\n-        } else if (isSettingsIntelligence(callingActivity)) {\n+        } else if (isSettingsIntelligence(callerPackage)) {\n             if (FeatureFlagUtils.isEnabled(this, FeatureFlags.SETTINGS_SEARCH_ALWAYS_EXPAND)) {\n                 startActivity(getTrampolineIntent(intent, highlightMenuKey)\n                         .setClass(this, DeepLinkHomepageActivityInternal.class)\n@@ -139,9 +138,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFeatureFactory().getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }\ndiff --git a/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java b/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\nindex f3496001d09..8a7419bb1ba 100644\n--- a/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\n+++ b/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\n@@ -20,7 +20,6 @@ package com.android.settings.search;\n import static com.google.common.truth.Truth.assertThat;\n \n import android.app.settings.SettingsEnums;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n import android.content.pm.ResolveInfo;\n@@ -131,20 +130,22 @@ public class SearchFeatureProviderImplTest {\n \n     @Test(expected = SecurityException.class)\n     public void verifyLaunchSearchResultPageCaller_badCaller_shouldCrash() {\n-        final ComponentName cn = new ComponentName(\"pkg\", \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+        final String packageName = \"pkg\";\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n \n     @Test\n     public void verifyLaunchSearchResultPageCaller_settingsCaller_shouldNotCrash() {\n-        final ComponentName cn = new ComponentName(mActivity.getPackageName(), \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+        final String packageName = mActivity.getPackageName();\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n \n     @Test\n     public void verifyLaunchSearchResultPageCaller_settingsIntelligenceCaller_shouldNotCrash() {\n         final String packageName = mProvider.getSettingsIntelligencePkgName(mActivity);\n-        final ComponentName cn = new ComponentName(packageName, \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 1803,
                        "general": {
                            "word_based": 751,
                            "char_based": 2153
                        },
                        "gemini": 2289
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 0,
                    "failed_patches": 4,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "b86569b274003e517bfd089cc7d6ba62d1c5f820",
                            "repo_path": "android_repos/Settings",
                            "result": "failure",
                            "downstream_patch_content": "commit b86569b274003e517bfd089cc7d6ba62d1c5f820\nAuthor: Jason Chiu <chiujason@google.com>\nDate:   Wed Jan 31 16:29:01 2024 +0800\n\n    [RESTRICT AUTOMERGE] Replace getCallingActivity() with getLaunchedFromPackage()\n    \n    getLaunchedFromPackage() reports who launched this Activity or built\n    PendingIntent used to launch it, whereas getCallingActivity() reports\n    who will get result of Activity.\n    \n    Bug: 316891059\n    Bug: 333364513\n    Test: robotest, manual\n    Change-Id: If97018c2741caef622f0596bbfeaa42ef1788b78\n    (cherry picked from commit ddc11bc03ab48e885f652b89df5f92ff283bcd4a)\n\ndiff --git a/src/com/android/settings/search/SearchFeatureProvider.java b/src/com/android/settings/search/SearchFeatureProvider.java\nindex 4c39b9c0c11..5c548788275 100644\n--- a/src/com/android/settings/search/SearchFeatureProvider.java\n+++ b/src/com/android/settings/search/SearchFeatureProvider.java\n@@ -51,7 +51,7 @@ public interface SearchFeatureProvider {\n      * @throws IllegalArgumentException when caller is null\n      * @throws SecurityException        when caller is not allowed to launch search result page\n      */\n-    void verifyLaunchSearchResultPageCaller(Context context, @NonNull ComponentName caller)\n+    void verifyLaunchSearchResultPageCaller(@NonNull Context context, @NonNull String callerPackage)\n             throws SecurityException, IllegalArgumentException;\n \n     /**\ndiff --git a/src/com/android/settings/search/SearchFeatureProviderImpl.java b/src/com/android/settings/search/SearchFeatureProviderImpl.java\nindex 508d37d7e6a..5035ef8f9fe 100644\n--- a/src/com/android/settings/search/SearchFeatureProviderImpl.java\n+++ b/src/com/android/settings/search/SearchFeatureProviderImpl.java\n@@ -17,13 +17,14 @@\n \n package com.android.settings.search;\n \n-import android.content.ComponentName;\n import android.content.Context;\n import android.content.Intent;\n import android.net.Uri;\n import android.provider.Settings;\n import android.text.TextUtils;\n \n+import androidx.annotation.NonNull;\n+\n import com.android.settingslib.search.SearchIndexableResources;\n import com.android.settingslib.search.SearchIndexableResourcesMobile;\n \n@@ -32,21 +33,18 @@ import com.android.settingslib.search.SearchIndexableResourcesMobile;\n  */\n public class SearchFeatureProviderImpl implements SearchFeatureProvider {\n \n-    private static final String TAG = \"SearchFeatureProvider\";\n-\n     private SearchIndexableResources mSearchIndexableResources;\n \n     @Override\n-    public void verifyLaunchSearchResultPageCaller(Context context, ComponentName caller) {\n-        if (caller == null) {\n+    public void verifyLaunchSearchResultPageCaller(@NonNull Context context,\n+            @NonNull String callerPackage) {\n+        if (TextUtils.isEmpty(callerPackage)) {\n             throw new IllegalArgumentException(\"ExternalSettingsTrampoline intents \"\n                     + \"must be called with startActivityForResult\");\n         }\n-        final String packageName = caller.getPackageName();\n-        final boolean isSettingsPackage = TextUtils.equals(packageName, context.getPackageName())\n-                || TextUtils.equals(getSettingsIntelligencePkgName(context), packageName);\n-        final boolean isAllowlistedPackage =\n-                isSignatureAllowlisted(context, caller.getPackageName());\n+        final boolean isSettingsPackage = TextUtils.equals(callerPackage, context.getPackageName())\n+                || TextUtils.equals(getSettingsIntelligencePkgName(context), callerPackage);\n+        final boolean isAllowlistedPackage = isSignatureAllowlisted(context, callerPackage);\n         if (isSettingsPackage || isAllowlistedPackage) {\n             return;\n         }\ndiff --git a/src/com/android/settings/search/SearchResultTrampoline.java b/src/com/android/settings/search/SearchResultTrampoline.java\nindex e9304739460..28030e81d87 100644\n--- a/src/com/android/settings/search/SearchResultTrampoline.java\n+++ b/src/com/android/settings/search/SearchResultTrampoline.java\n@@ -39,7 +39,7 @@ public class SearchResultTrampoline extends Activity {\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFactory(this)\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, getCallingActivity());\n+                .verifyLaunchSearchResultPageCaller(this, getLaunchedFromPackage());\n         // Didn't crash, proceed and launch the result as a subsetting.\n         final Intent intent = getIntent();\n \ndiff --git a/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java b/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\nindex 444a8137889..ebd935d3406 100644\n--- a/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\n+++ b/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\n@@ -21,7 +21,6 @@ import static com.google.common.truth.Truth.assertThat;\n \n import android.app.Activity;\n import android.app.settings.SettingsEnums;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n import android.content.pm.ResolveInfo;\n@@ -126,20 +125,22 @@ public class SearchFeatureProviderImplTest {\n \n     @Test(expected = SecurityException.class)\n     public void verifyLaunchSearchResultPageCaller_badCaller_shouldCrash() {\n-        final ComponentName cn = new ComponentName(\"pkg\", \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+        final String packageName = \"pkg\";\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n \n     @Test\n     public void verifyLaunchSearchResultPageCaller_settingsCaller_shouldNotCrash() {\n-        final ComponentName cn = new ComponentName(mActivity.getPackageName(), \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+        final String packageName = mActivity.getPackageName();\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n \n     @Test\n     public void verifyLaunchSearchResultPageCaller_settingsIntelligenceCaller_shouldNotCrash() {\n         final String packageName = mProvider.getSettingsIntelligencePkgName(mActivity);\n-        final ComponentName cn = new ComponentName(packageName, \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n }\n",
                            "downstream_patch_tokens": {
                                "openai": 1401,
                                "general": {
                                    "word_based": 586,
                                    "char_based": 1633
                                },
                                "gemini": 1801
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "src/com/android/settings/search/SearchResultTrampoline.java",
                                    "total_hunks": 0,
                                    "failed_hunks": [],
                                    "inline_merge_conflicts": [],
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    },
                                    "rej_file_content": "```diff\n--- src/com/android/settings/search/SearchResultTrampoline.java\n+++ src/com/android/settings/search/SearchResultTrampoline.java\n@@ -21,7 +21,6 @@ import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n import static com.android.settings.activityembedding.EmbeddedDeepLinkUtils.getTrampolineIntent;\n \n import android.app.Activity;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.net.Uri;\n import android.os.Bundle;\n@@ -53,11 +52,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFeatureFactory()\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -106,7 +105,7 @@ public class SearchResultTrampoline extends Activity {\n         if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)\n                 || ActivityEmbeddingUtils.isAlreadyEmbedded(this)) {\n             startActivity(intent);\n-        } else if (isSettingsIntelligence(callingActivity)) {\n+        } else if (isSettingsIntelligence(callerPackage)) {\n             if (FeatureFlagUtils.isEnabled(this, FeatureFlags.SETTINGS_SEARCH_ALWAYS_EXPAND)) {\n                 startActivity(getTrampolineIntent(intent, highlightMenuKey)\n                         .setClass(this, DeepLinkHomepageActivityInternal.class)\n@@ -139,9 +138,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFeatureFactory().getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }\n```",
                                    "rej_file_tokens": {
                                        "openai": 465,
                                        "general": {
                                            "word_based": 194,
                                            "char_based": 623
                                        },
                                        "gemini": 578
                                    },
                                    "patch_apply_output": "patching file src/com/android/settings/search/SearchFeatureProvider.java\nHunk #1 succeeded at 51 (offset -5 lines).\npatching file src/com/android/settings/search/SearchFeatureProviderImpl.java\npatching file src/com/android/settings/search/SearchResultTrampoline.java\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n4 out of 4 hunks ignored -- saving rejects to file src/com/android/settings/search/SearchResultTrampoline.java.rej",
                                    "inline_merge_output": "patching file src/com/android/settings/search/SearchResultTrampoline.java\nHunk #1 already applied at 24.\nHunk #2 already applied at 55,59.\nHunk #3 already applied at 108.\nHunk #4 already applied at 141-143.",
                                    "upstream_file_tokens": {
                                        "openai": 1137,
                                        "general": {
                                            "word_based": 526,
                                            "char_based": 1616
                                        },
                                        "gemini": 1451
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.search;\n\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENTS;\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\n\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SubSettings;\nimport com.android.settings.overlay.FeatureFactory;\n\n/**\n * A trampoline activity that launches setting result page.\n */\npublic class SearchResultTrampoline extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        // First make sure caller has privilege to launch a search result page.\n        FeatureFactory.getFactory(this)\n                .getSearchFeatureProvider()\n                .verifyLaunchSearchResultPageCaller(this, getCallingActivity());\n        // Didn't crash, proceed and launch the result as a subsetting.\n        final Intent intent = getIntent();\n\n        // Hack to take EXTRA_FRAGMENT_ARG_KEY from intent and set into\n        // EXTRA_SHOW_FRAGMENT_ARGUMENTS. This is necessary because intent could be from external\n        // caller and args may not persisted.\n        final String settingKey = intent.getStringExtra(SettingsActivity.EXTRA_FRAGMENT_ARG_KEY);\n        final int tab = intent.getIntExtra(EXTRA_SHOW_FRAGMENT_TAB, 0);\n        final Bundle args = new Bundle();\n        args.putString(SettingsActivity.EXTRA_FRAGMENT_ARG_KEY, settingKey);\n        args.putInt(EXTRA_SHOW_FRAGMENT_TAB, tab);\n        intent.putExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS, args);\n\n        // Reroute request to SubSetting.\n        intent.setClass(this /* context */, SubSettings.class)\n                .addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);\n        startActivity(intent);\n\n        // Done.\n        finish();\n    }\n\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 472,
                                        "general": {
                                            "word_based": 271,
                                            "char_based": 628
                                        },
                                        "gemini": 602
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "8bdbb580da847d82f16fb57883a01a5e65ffa696",
                            "repo_path": "android_repos/Settings",
                            "result": "failure",
                            "downstream_patch_content": "commit 8bdbb580da847d82f16fb57883a01a5e65ffa696\nAuthor: Jason Chiu <chiujason@google.com>\nDate:   Wed Jan 31 16:29:01 2024 +0800\n\n    Replace getCallingActivity() with getLaunchedFromPackage()\n    \n    getLaunchedFromPackage() reports who launched this Activity or built\n    PendingIntent used to launch it, whereas getCallingActivity() reports\n    who will get result of Activity.\n    \n    Bug: 316891059\n    Test: robotest, manual\n    Change-Id: If97018c2741caef622f0596bbfeaa42ef1788b78\n    Merged-In: If97018c2741caef622f0596bbfeaa42ef1788b78\n    (cherry picked from commit ddc11bc03ab48e885f652b89df5f92ff283bcd4a)\n\ndiff --git a/src/com/android/settings/search/SearchFeatureProvider.java b/src/com/android/settings/search/SearchFeatureProvider.java\nindex 1785361d3b2..c4141e91f72 100644\n--- a/src/com/android/settings/search/SearchFeatureProvider.java\n+++ b/src/com/android/settings/search/SearchFeatureProvider.java\n@@ -56,7 +56,7 @@ public interface SearchFeatureProvider {\n      * @throws IllegalArgumentException when caller is null\n      * @throws SecurityException        when caller is not allowed to launch search result page\n      */\n-    void verifyLaunchSearchResultPageCaller(Context context, @NonNull ComponentName caller)\n+    void verifyLaunchSearchResultPageCaller(@NonNull Context context, @NonNull String callerPackage)\n             throws SecurityException, IllegalArgumentException;\n \n     /**\ndiff --git a/src/com/android/settings/search/SearchFeatureProviderImpl.java b/src/com/android/settings/search/SearchFeatureProviderImpl.java\nindex 6f909709058..3a62ddfb67e 100644\n--- a/src/com/android/settings/search/SearchFeatureProviderImpl.java\n+++ b/src/com/android/settings/search/SearchFeatureProviderImpl.java\n@@ -17,13 +17,14 @@\n \n package com.android.settings.search;\n \n-import android.content.ComponentName;\n import android.content.Context;\n import android.content.Intent;\n import android.net.Uri;\n import android.provider.Settings;\n import android.text.TextUtils;\n \n+import androidx.annotation.NonNull;\n+\n import com.android.settingslib.search.SearchIndexableResources;\n import com.android.settingslib.search.SearchIndexableResourcesMobile;\n \n@@ -32,21 +33,18 @@ import com.android.settingslib.search.SearchIndexableResourcesMobile;\n  */\n public class SearchFeatureProviderImpl implements SearchFeatureProvider {\n \n-    private static final String TAG = \"SearchFeatureProvider\";\n-\n     private SearchIndexableResources mSearchIndexableResources;\n \n     @Override\n-    public void verifyLaunchSearchResultPageCaller(Context context, ComponentName caller) {\n-        if (caller == null) {\n+    public void verifyLaunchSearchResultPageCaller(@NonNull Context context,\n+            @NonNull String callerPackage) {\n+        if (TextUtils.isEmpty(callerPackage)) {\n             throw new IllegalArgumentException(\"ExternalSettingsTrampoline intents \"\n                     + \"must be called with startActivityForResult\");\n         }\n-        final String packageName = caller.getPackageName();\n-        final boolean isSettingsPackage = TextUtils.equals(packageName, context.getPackageName())\n-                || TextUtils.equals(getSettingsIntelligencePkgName(context), packageName);\n-        final boolean isAllowlistedPackage =\n-                isSignatureAllowlisted(context, caller.getPackageName());\n+        final boolean isSettingsPackage = TextUtils.equals(callerPackage, context.getPackageName())\n+                || TextUtils.equals(getSettingsIntelligencePkgName(context), callerPackage);\n+        final boolean isAllowlistedPackage = isSignatureAllowlisted(context, callerPackage);\n         if (isSettingsPackage || isAllowlistedPackage) {\n             return;\n         }\ndiff --git a/src/com/android/settings/search/SearchResultTrampoline.java b/src/com/android/settings/search/SearchResultTrampoline.java\nindex 8b041b67f87..6580c682fa1 100644\n--- a/src/com/android/settings/search/SearchResultTrampoline.java\n+++ b/src/com/android/settings/search/SearchResultTrampoline.java\n@@ -20,7 +20,6 @@ import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENT\n import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n \n import android.app.Activity;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.os.Bundle;\n import android.provider.Settings;\n@@ -48,11 +47,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFactory(this)\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -96,7 +95,7 @@ public class SearchResultTrampoline extends Activity {\n \n         if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)) {\n             startActivity(intent);\n-        } else if (isSettingsIntelligence(callingActivity)) {\n+        } else if (isSettingsIntelligence(callerPackage)) {\n             // Register SplitPairRule for SubSettings, set clearTop false to prevent unexpected back\n             // navigation behavior.\n             ActivityEmbeddingRulesController.registerSubSettingsPairRule(this,\n@@ -122,9 +121,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }\ndiff --git a/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java b/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\nindex 5de57b6c95e..dec99028e82 100644\n--- a/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\n+++ b/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\n@@ -20,7 +20,6 @@ package com.android.settings.search;\n import static com.google.common.truth.Truth.assertThat;\n \n import android.app.settings.SettingsEnums;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n import android.content.pm.ResolveInfo;\n@@ -127,20 +126,22 @@ public class SearchFeatureProviderImplTest {\n \n     @Test(expected = SecurityException.class)\n     public void verifyLaunchSearchResultPageCaller_badCaller_shouldCrash() {\n-        final ComponentName cn = new ComponentName(\"pkg\", \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+        final String packageName = \"pkg\";\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n \n     @Test\n     public void verifyLaunchSearchResultPageCaller_settingsCaller_shouldNotCrash() {\n-        final ComponentName cn = new ComponentName(mActivity.getPackageName(), \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+        final String packageName = mActivity.getPackageName();\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n \n     @Test\n     public void verifyLaunchSearchResultPageCaller_settingsIntelligenceCaller_shouldNotCrash() {\n         final String packageName = mProvider.getSettingsIntelligencePkgName(mActivity);\n-        final ComponentName cn = new ComponentName(packageName, \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n }\n",
                            "downstream_patch_tokens": {
                                "openai": 1732,
                                "general": {
                                    "word_based": 720,
                                    "char_based": 2070
                                },
                                "gemini": 2215
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "src/com/android/settings/search/SearchResultTrampoline.java",
                                    "total_hunks": 4,
                                    "failed_hunks": [
                                        2,
                                        3,
                                        4
                                    ],
                                    "inline_merge_conflicts": [],
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    },
                                    "rej_file_content": "```diff\n--- src/com/android/settings/search/SearchResultTrampoline.java\n+++ src/com/android/settings/search/SearchResultTrampoline.java\n@@ -52,11 +51,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFeatureFactory()\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -105,7 +104,7 @@ public class SearchResultTrampoline extends Activity {\n         if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)\n                 || ActivityEmbeddingUtils.isAlreadyEmbedded(this)) {\n             startActivity(intent);\n-        } else if (isSettingsIntelligence(callingActivity)) {\n+        } else if (isSettingsIntelligence(callerPackage)) {\n             if (FeatureFlagUtils.isEnabled(this, FeatureFlags.SETTINGS_SEARCH_ALWAYS_EXPAND)) {\n                 startActivity(getTrampolineIntent(intent, highlightMenuKey)\n                         .setClass(this, DeepLinkHomepageActivityInternal.class)\n@@ -138,9 +137,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFeatureFactory().getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }\n```",
                                    "rej_file_tokens": {
                                        "openai": 399,
                                        "general": {
                                            "word_based": 155,
                                            "char_based": 536
                                        },
                                        "gemini": 480
                                    },
                                    "patch_apply_output": "patching file src/com/android/settings/search/SearchFeatureProvider.java\npatching file src/com/android/settings/search/SearchFeatureProviderImpl.java\npatching file src/com/android/settings/search/SearchResultTrampoline.java\nHunk #1 succeeded at 20 with fuzz 2 (offset -1 lines).\nHunk #2 FAILED at 52.\nHunk #3 FAILED at 105.\nHunk #4 FAILED at 138.\n3 out of 4 hunks FAILED -- saving rejects to file src/com/android/settings/search/SearchResultTrampoline.java.rej",
                                    "inline_merge_output": "patching file src/com/android/settings/search/SearchResultTrampoline.java\nHunk #1 already applied at 24.\nHunk #2 already applied at 55,59.\nHunk #3 already applied at 108.\nHunk #4 already applied at 141-143.",
                                    "upstream_file_tokens": {
                                        "openai": 1137,
                                        "general": {
                                            "word_based": 526,
                                            "char_based": 1616
                                        },
                                        "gemini": 1451
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.search;\n\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENTS;\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsApplication;\nimport com.android.settings.SubSettings;\nimport com.android.settings.activityembedding.ActivityEmbeddingRulesController;\nimport com.android.settings.activityembedding.ActivityEmbeddingUtils;\nimport com.android.settings.homepage.SettingsHomepageActivity;\nimport com.android.settings.overlay.FeatureFactory;\n\nimport java.net.URISyntaxException;\n\n/**\n * A trampoline activity that launches setting result page.\n */\npublic class SearchResultTrampoline extends Activity {\n\n    private static final String TAG = \"SearchResultTrampoline\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        final ComponentName callingActivity = getCallingActivity();\n        // First make sure caller has privilege to launch a search result page.\n        FeatureFactory.getFactory(this)\n                .getSearchFeatureProvider()\n                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n        // Didn't crash, proceed and launch the result as a subsetting.\n        Intent intent = getIntent();\n        final String highlightMenuKey = intent.getStringExtra(\n                Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_HIGHLIGHT_MENU_KEY);\n\n        final String fragment = intent.getStringExtra(SettingsActivity.EXTRA_SHOW_FRAGMENT);\n        if (!TextUtils.isEmpty(fragment)) {\n            // Hack to take EXTRA_FRAGMENT_ARG_KEY from intent and set into\n            // EXTRA_SHOW_FRAGMENT_ARGUMENTS. This is necessary because intent could be from\n            // external caller and args may not persisted.\n            final String settingKey = intent.getStringExtra(\n                    SettingsActivity.EXTRA_FRAGMENT_ARG_KEY);\n            final int tab = intent.getIntExtra(EXTRA_SHOW_FRAGMENT_TAB, 0);\n            final Bundle args = new Bundle();\n            args.putString(SettingsActivity.EXTRA_FRAGMENT_ARG_KEY, settingKey);\n            args.putInt(EXTRA_SHOW_FRAGMENT_TAB, tab);\n            intent.putExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS, args);\n\n            // Reroute request to SubSetting.\n            intent.setClass(this /* context */, SubSettings.class);\n        } else {\n            // Direct link case\n            final String intentUriString = intent.getStringExtra(\n                    Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI);\n            if (TextUtils.isEmpty(intentUriString)) {\n                Log.e(TAG, \"No EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI for deep link\");\n                finish();\n                return;\n            }\n\n            try {\n                intent = Intent.parseUri(intentUriString, Intent.URI_INTENT_SCHEME);\n            } catch (URISyntaxException e) {\n                Log.e(TAG, \"Failed to parse deep link intent: \" + e);\n                finish();\n                return;\n            }\n        }\n\n        intent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);\n\n        if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)) {\n            startActivity(intent);\n        } else if (isSettingsIntelligence(callingActivity)) {\n            // Register SplitPairRule for SubSettings, set clearTop false to prevent unexpected back\n            // navigation behavior.\n            ActivityEmbeddingRulesController.registerSubSettingsPairRule(this,\n                    false /* clearTop */);\n\n            intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_NEW_TASK);\n            startActivity(intent);\n\n            // Pass menu key to homepage\n            final SettingsHomepageActivity homeActivity =\n                    ((SettingsApplication) getApplicationContext()).getHomeActivity();\n            if (homeActivity != null) {\n                homeActivity.getMainFragment().setHighlightMenuKey(highlightMenuKey,\n                        /* scrollNeeded= */ true);\n            }\n        } else {\n            // Two-pane case\n            startActivity(SettingsActivity.getTrampolineIntent(intent, highlightMenuKey)\n                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK));\n        }\n\n        // Done.\n        finish();\n    }\n\n    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n        return callingActivity != null && TextUtils.equals(\n                callingActivity.getPackageName(),\n                FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                        .getSettingsIntelligencePkgName(this));\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 980,
                                        "general": {
                                            "word_based": 469,
                                            "char_based": 1373
                                        },
                                        "gemini": 1237
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "8bdbb580da847d82f16fb57883a01a5e65ffa696",
                            "repo_path": "android_repos/Settings",
                            "result": "failure",
                            "downstream_patch_content": "commit 8bdbb580da847d82f16fb57883a01a5e65ffa696\nAuthor: Jason Chiu <chiujason@google.com>\nDate:   Wed Jan 31 16:29:01 2024 +0800\n\n    Replace getCallingActivity() with getLaunchedFromPackage()\n    \n    getLaunchedFromPackage() reports who launched this Activity or built\n    PendingIntent used to launch it, whereas getCallingActivity() reports\n    who will get result of Activity.\n    \n    Bug: 316891059\n    Test: robotest, manual\n    Change-Id: If97018c2741caef622f0596bbfeaa42ef1788b78\n    Merged-In: If97018c2741caef622f0596bbfeaa42ef1788b78\n    (cherry picked from commit ddc11bc03ab48e885f652b89df5f92ff283bcd4a)\n\ndiff --git a/src/com/android/settings/search/SearchFeatureProvider.java b/src/com/android/settings/search/SearchFeatureProvider.java\nindex 1785361d3b2..c4141e91f72 100644\n--- a/src/com/android/settings/search/SearchFeatureProvider.java\n+++ b/src/com/android/settings/search/SearchFeatureProvider.java\n@@ -56,7 +56,7 @@ public interface SearchFeatureProvider {\n      * @throws IllegalArgumentException when caller is null\n      * @throws SecurityException        when caller is not allowed to launch search result page\n      */\n-    void verifyLaunchSearchResultPageCaller(Context context, @NonNull ComponentName caller)\n+    void verifyLaunchSearchResultPageCaller(@NonNull Context context, @NonNull String callerPackage)\n             throws SecurityException, IllegalArgumentException;\n \n     /**\ndiff --git a/src/com/android/settings/search/SearchFeatureProviderImpl.java b/src/com/android/settings/search/SearchFeatureProviderImpl.java\nindex 6f909709058..3a62ddfb67e 100644\n--- a/src/com/android/settings/search/SearchFeatureProviderImpl.java\n+++ b/src/com/android/settings/search/SearchFeatureProviderImpl.java\n@@ -17,13 +17,14 @@\n \n package com.android.settings.search;\n \n-import android.content.ComponentName;\n import android.content.Context;\n import android.content.Intent;\n import android.net.Uri;\n import android.provider.Settings;\n import android.text.TextUtils;\n \n+import androidx.annotation.NonNull;\n+\n import com.android.settingslib.search.SearchIndexableResources;\n import com.android.settingslib.search.SearchIndexableResourcesMobile;\n \n@@ -32,21 +33,18 @@ import com.android.settingslib.search.SearchIndexableResourcesMobile;\n  */\n public class SearchFeatureProviderImpl implements SearchFeatureProvider {\n \n-    private static final String TAG = \"SearchFeatureProvider\";\n-\n     private SearchIndexableResources mSearchIndexableResources;\n \n     @Override\n-    public void verifyLaunchSearchResultPageCaller(Context context, ComponentName caller) {\n-        if (caller == null) {\n+    public void verifyLaunchSearchResultPageCaller(@NonNull Context context,\n+            @NonNull String callerPackage) {\n+        if (TextUtils.isEmpty(callerPackage)) {\n             throw new IllegalArgumentException(\"ExternalSettingsTrampoline intents \"\n                     + \"must be called with startActivityForResult\");\n         }\n-        final String packageName = caller.getPackageName();\n-        final boolean isSettingsPackage = TextUtils.equals(packageName, context.getPackageName())\n-                || TextUtils.equals(getSettingsIntelligencePkgName(context), packageName);\n-        final boolean isAllowlistedPackage =\n-                isSignatureAllowlisted(context, caller.getPackageName());\n+        final boolean isSettingsPackage = TextUtils.equals(callerPackage, context.getPackageName())\n+                || TextUtils.equals(getSettingsIntelligencePkgName(context), callerPackage);\n+        final boolean isAllowlistedPackage = isSignatureAllowlisted(context, callerPackage);\n         if (isSettingsPackage || isAllowlistedPackage) {\n             return;\n         }\ndiff --git a/src/com/android/settings/search/SearchResultTrampoline.java b/src/com/android/settings/search/SearchResultTrampoline.java\nindex 8b041b67f87..6580c682fa1 100644\n--- a/src/com/android/settings/search/SearchResultTrampoline.java\n+++ b/src/com/android/settings/search/SearchResultTrampoline.java\n@@ -20,7 +20,6 @@ import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENT\n import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n \n import android.app.Activity;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.os.Bundle;\n import android.provider.Settings;\n@@ -48,11 +47,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFactory(this)\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -96,7 +95,7 @@ public class SearchResultTrampoline extends Activity {\n \n         if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)) {\n             startActivity(intent);\n-        } else if (isSettingsIntelligence(callingActivity)) {\n+        } else if (isSettingsIntelligence(callerPackage)) {\n             // Register SplitPairRule for SubSettings, set clearTop false to prevent unexpected back\n             // navigation behavior.\n             ActivityEmbeddingRulesController.registerSubSettingsPairRule(this,\n@@ -122,9 +121,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }\ndiff --git a/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java b/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\nindex 5de57b6c95e..dec99028e82 100644\n--- a/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\n+++ b/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\n@@ -20,7 +20,6 @@ package com.android.settings.search;\n import static com.google.common.truth.Truth.assertThat;\n \n import android.app.settings.SettingsEnums;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n import android.content.pm.ResolveInfo;\n@@ -127,20 +126,22 @@ public class SearchFeatureProviderImplTest {\n \n     @Test(expected = SecurityException.class)\n     public void verifyLaunchSearchResultPageCaller_badCaller_shouldCrash() {\n-        final ComponentName cn = new ComponentName(\"pkg\", \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+        final String packageName = \"pkg\";\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n \n     @Test\n     public void verifyLaunchSearchResultPageCaller_settingsCaller_shouldNotCrash() {\n-        final ComponentName cn = new ComponentName(mActivity.getPackageName(), \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+        final String packageName = mActivity.getPackageName();\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n \n     @Test\n     public void verifyLaunchSearchResultPageCaller_settingsIntelligenceCaller_shouldNotCrash() {\n         final String packageName = mProvider.getSettingsIntelligencePkgName(mActivity);\n-        final ComponentName cn = new ComponentName(packageName, \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n }\n",
                            "downstream_patch_tokens": {
                                "openai": 1732,
                                "general": {
                                    "word_based": 720,
                                    "char_based": 2070
                                },
                                "gemini": 2215
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "src/com/android/settings/search/SearchResultTrampoline.java",
                                    "total_hunks": 4,
                                    "failed_hunks": [
                                        2,
                                        3,
                                        4
                                    ],
                                    "inline_merge_conflicts": [],
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    },
                                    "rej_file_content": "```diff\n--- src/com/android/settings/search/SearchResultTrampoline.java\n+++ src/com/android/settings/search/SearchResultTrampoline.java\n@@ -52,11 +51,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFeatureFactory()\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -105,7 +104,7 @@ public class SearchResultTrampoline extends Activity {\n         if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)\n                 || ActivityEmbeddingUtils.isAlreadyEmbedded(this)) {\n             startActivity(intent);\n-        } else if (isSettingsIntelligence(callingActivity)) {\n+        } else if (isSettingsIntelligence(callerPackage)) {\n             if (FeatureFlagUtils.isEnabled(this, FeatureFlags.SETTINGS_SEARCH_ALWAYS_EXPAND)) {\n                 startActivity(getTrampolineIntent(intent, highlightMenuKey)\n                         .setClass(this, DeepLinkHomepageActivityInternal.class)\n@@ -138,9 +137,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFeatureFactory().getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }\n```",
                                    "rej_file_tokens": {
                                        "openai": 399,
                                        "general": {
                                            "word_based": 155,
                                            "char_based": 536
                                        },
                                        "gemini": 480
                                    },
                                    "patch_apply_output": "patching file src/com/android/settings/search/SearchFeatureProvider.java\npatching file src/com/android/settings/search/SearchFeatureProviderImpl.java\npatching file src/com/android/settings/search/SearchResultTrampoline.java\nHunk #1 succeeded at 20 with fuzz 2 (offset -1 lines).\nHunk #2 FAILED at 52.\nHunk #3 FAILED at 105.\nHunk #4 FAILED at 138.\n3 out of 4 hunks FAILED -- saving rejects to file src/com/android/settings/search/SearchResultTrampoline.java.rej",
                                    "inline_merge_output": "patching file src/com/android/settings/search/SearchResultTrampoline.java\nHunk #1 already applied at 24.\nHunk #2 already applied at 55,59.\nHunk #3 already applied at 108.\nHunk #4 already applied at 141-143.",
                                    "upstream_file_tokens": {
                                        "openai": 1137,
                                        "general": {
                                            "word_based": 526,
                                            "char_based": 1616
                                        },
                                        "gemini": 1451
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.search;\n\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENTS;\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsApplication;\nimport com.android.settings.SubSettings;\nimport com.android.settings.activityembedding.ActivityEmbeddingRulesController;\nimport com.android.settings.activityembedding.ActivityEmbeddingUtils;\nimport com.android.settings.homepage.SettingsHomepageActivity;\nimport com.android.settings.overlay.FeatureFactory;\n\nimport java.net.URISyntaxException;\n\n/**\n * A trampoline activity that launches setting result page.\n */\npublic class SearchResultTrampoline extends Activity {\n\n    private static final String TAG = \"SearchResultTrampoline\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        final ComponentName callingActivity = getCallingActivity();\n        // First make sure caller has privilege to launch a search result page.\n        FeatureFactory.getFactory(this)\n                .getSearchFeatureProvider()\n                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n        // Didn't crash, proceed and launch the result as a subsetting.\n        Intent intent = getIntent();\n        final String highlightMenuKey = intent.getStringExtra(\n                Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_HIGHLIGHT_MENU_KEY);\n\n        final String fragment = intent.getStringExtra(SettingsActivity.EXTRA_SHOW_FRAGMENT);\n        if (!TextUtils.isEmpty(fragment)) {\n            // Hack to take EXTRA_FRAGMENT_ARG_KEY from intent and set into\n            // EXTRA_SHOW_FRAGMENT_ARGUMENTS. This is necessary because intent could be from\n            // external caller and args may not persisted.\n            final String settingKey = intent.getStringExtra(\n                    SettingsActivity.EXTRA_FRAGMENT_ARG_KEY);\n            final int tab = intent.getIntExtra(EXTRA_SHOW_FRAGMENT_TAB, 0);\n            final Bundle args = new Bundle();\n            args.putString(SettingsActivity.EXTRA_FRAGMENT_ARG_KEY, settingKey);\n            args.putInt(EXTRA_SHOW_FRAGMENT_TAB, tab);\n            intent.putExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS, args);\n\n            // Reroute request to SubSetting.\n            intent.setClass(this /* context */, SubSettings.class);\n        } else {\n            // Direct link case\n            final String intentUriString = intent.getStringExtra(\n                    Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI);\n            if (TextUtils.isEmpty(intentUriString)) {\n                Log.e(TAG, \"No EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI for deep link\");\n                finish();\n                return;\n            }\n\n            try {\n                intent = Intent.parseUri(intentUriString, Intent.URI_INTENT_SCHEME);\n            } catch (URISyntaxException e) {\n                Log.e(TAG, \"Failed to parse deep link intent: \" + e);\n                finish();\n                return;\n            }\n        }\n\n        intent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);\n\n        if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)) {\n            startActivity(intent);\n        } else if (isSettingsIntelligence(callingActivity)) {\n            // Register SplitPairRule for SubSettings, set clearTop false to prevent unexpected back\n            // navigation behavior.\n            ActivityEmbeddingRulesController.registerSubSettingsPairRule(this,\n                    false /* clearTop */);\n\n            intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_NEW_TASK);\n            startActivity(intent);\n\n            // Pass menu key to homepage\n            final SettingsHomepageActivity homeActivity =\n                    ((SettingsApplication) getApplicationContext()).getHomeActivity();\n            if (homeActivity != null) {\n                homeActivity.getMainFragment().setHighlightMenuKey(highlightMenuKey,\n                        /* scrollNeeded= */ true);\n            }\n        } else {\n            // Two-pane case\n            startActivity(SettingsActivity.getTrampolineIntent(intent, highlightMenuKey)\n                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK));\n        }\n\n        // Done.\n        finish();\n    }\n\n    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n        return callingActivity != null && TextUtils.equals(\n                callingActivity.getPackageName(),\n                FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                        .getSettingsIntelligencePkgName(this));\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 980,
                                        "general": {
                                            "word_based": 469,
                                            "char_based": 1373
                                        },
                                        "gemini": 1237
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "ddc11bc03ab48e885f652b89df5f92ff283bcd4a",
                            "repo_path": "android_repos/Settings",
                            "result": "failure",
                            "downstream_patch_content": "commit ddc11bc03ab48e885f652b89df5f92ff283bcd4a\nAuthor: Jason Chiu <chiujason@google.com>\nDate:   Wed Jan 31 16:29:01 2024 +0800\n\n    Replace getCallingActivity() with getLaunchedFromPackage()\n    \n    getLaunchedFromPackage() reports who launched this Activity or built\n    PendingIntent used to launch it, whereas getCallingActivity() reports\n    who will get result of Activity.\n    \n    Bug: 316891059\n    Test: robotest, manual\n    Change-Id: If97018c2741caef622f0596bbfeaa42ef1788b78\n    Merged-In: If97018c2741caef622f0596bbfeaa42ef1788b78\n    (cherry picked from commit 901880a1d2e632179eb4ac708fc4bc18d9d50791)\n\ndiff --git a/src/com/android/settings/search/SearchFeatureProvider.java b/src/com/android/settings/search/SearchFeatureProvider.java\nindex cd096ec6e16..c2257b47c9e 100644\n--- a/src/com/android/settings/search/SearchFeatureProvider.java\n+++ b/src/com/android/settings/search/SearchFeatureProvider.java\n@@ -56,7 +56,7 @@ public interface SearchFeatureProvider {\n      * @throws IllegalArgumentException when caller is null\n      * @throws SecurityException        when caller is not allowed to launch search result page\n      */\n-    void verifyLaunchSearchResultPageCaller(Context context, @NonNull ComponentName caller)\n+    void verifyLaunchSearchResultPageCaller(@NonNull Context context, @NonNull String callerPackage)\n             throws SecurityException, IllegalArgumentException;\n \n     /**\ndiff --git a/src/com/android/settings/search/SearchFeatureProviderImpl.java b/src/com/android/settings/search/SearchFeatureProviderImpl.java\nindex 6f909709058..3a62ddfb67e 100644\n--- a/src/com/android/settings/search/SearchFeatureProviderImpl.java\n+++ b/src/com/android/settings/search/SearchFeatureProviderImpl.java\n@@ -17,13 +17,14 @@\n \n package com.android.settings.search;\n \n-import android.content.ComponentName;\n import android.content.Context;\n import android.content.Intent;\n import android.net.Uri;\n import android.provider.Settings;\n import android.text.TextUtils;\n \n+import androidx.annotation.NonNull;\n+\n import com.android.settingslib.search.SearchIndexableResources;\n import com.android.settingslib.search.SearchIndexableResourcesMobile;\n \n@@ -32,21 +33,18 @@ import com.android.settingslib.search.SearchIndexableResourcesMobile;\n  */\n public class SearchFeatureProviderImpl implements SearchFeatureProvider {\n \n-    private static final String TAG = \"SearchFeatureProvider\";\n-\n     private SearchIndexableResources mSearchIndexableResources;\n \n     @Override\n-    public void verifyLaunchSearchResultPageCaller(Context context, ComponentName caller) {\n-        if (caller == null) {\n+    public void verifyLaunchSearchResultPageCaller(@NonNull Context context,\n+            @NonNull String callerPackage) {\n+        if (TextUtils.isEmpty(callerPackage)) {\n             throw new IllegalArgumentException(\"ExternalSettingsTrampoline intents \"\n                     + \"must be called with startActivityForResult\");\n         }\n-        final String packageName = caller.getPackageName();\n-        final boolean isSettingsPackage = TextUtils.equals(packageName, context.getPackageName())\n-                || TextUtils.equals(getSettingsIntelligencePkgName(context), packageName);\n-        final boolean isAllowlistedPackage =\n-                isSignatureAllowlisted(context, caller.getPackageName());\n+        final boolean isSettingsPackage = TextUtils.equals(callerPackage, context.getPackageName())\n+                || TextUtils.equals(getSettingsIntelligencePkgName(context), callerPackage);\n+        final boolean isAllowlistedPackage = isSignatureAllowlisted(context, callerPackage);\n         if (isSettingsPackage || isAllowlistedPackage) {\n             return;\n         }\ndiff --git a/src/com/android/settings/search/SearchResultTrampoline.java b/src/com/android/settings/search/SearchResultTrampoline.java\nindex 6ba0338bfc9..504e2985742 100644\n--- a/src/com/android/settings/search/SearchResultTrampoline.java\n+++ b/src/com/android/settings/search/SearchResultTrampoline.java\n@@ -20,7 +20,6 @@ import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENT\n import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n \n import android.app.Activity;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.net.Uri;\n import android.os.Bundle;\n@@ -52,11 +51,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFactory(this)\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -105,7 +104,7 @@ public class SearchResultTrampoline extends Activity {\n         if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)\n                 || ActivityEmbeddingUtils.isAlreadyEmbedded(this)) {\n             startActivity(intent);\n-        } else if (isSettingsIntelligence(callingActivity)) {\n+        } else if (isSettingsIntelligence(callerPackage)) {\n             if (FeatureFlagUtils.isEnabled(this, FeatureFlags.SETTINGS_SEARCH_ALWAYS_EXPAND)) {\n                 startActivity(SettingsActivity.getTrampolineIntent(intent, highlightMenuKey)\n                         .setClass(this, DeepLinkHomepageActivityInternal.class)\n@@ -138,9 +137,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }\ndiff --git a/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java b/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\nindex 0aa49eb6d68..7a1b2606a92 100644\n--- a/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\n+++ b/tests/robotests/src/com/android/settings/search/SearchFeatureProviderImplTest.java\n@@ -20,7 +20,6 @@ package com.android.settings.search;\n import static com.google.common.truth.Truth.assertThat;\n \n import android.app.settings.SettingsEnums;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n import android.content.pm.ResolveInfo;\n@@ -136,20 +135,22 @@ public class SearchFeatureProviderImplTest {\n \n     @Test(expected = SecurityException.class)\n     public void verifyLaunchSearchResultPageCaller_badCaller_shouldCrash() {\n-        final ComponentName cn = new ComponentName(\"pkg\", \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+        final String packageName = \"pkg\";\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n \n     @Test\n     public void verifyLaunchSearchResultPageCaller_settingsCaller_shouldNotCrash() {\n-        final ComponentName cn = new ComponentName(mActivity.getPackageName(), \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+        final String packageName = mActivity.getPackageName();\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n \n     @Test\n     public void verifyLaunchSearchResultPageCaller_settingsIntelligenceCaller_shouldNotCrash() {\n         final String packageName = mProvider.getSettingsIntelligencePkgName(mActivity);\n-        final ComponentName cn = new ComponentName(packageName, \"class\");\n-        mProvider.verifyLaunchSearchResultPageCaller(mActivity, cn);\n+\n+        mProvider.verifyLaunchSearchResultPageCaller(mActivity, packageName);\n     }\n }\n",
                            "downstream_patch_tokens": {
                                "openai": 1752,
                                "general": {
                                    "word_based": 722,
                                    "char_based": 2098
                                },
                                "gemini": 2245
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "src/com/android/settings/search/SearchResultTrampoline.java",
                                    "total_hunks": 4,
                                    "failed_hunks": [
                                        2,
                                        4
                                    ],
                                    "inline_merge_conflicts": [],
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    },
                                    "rej_file_content": "```diff\n--- src/com/android/settings/search/SearchResultTrampoline.java\n+++ src/com/android/settings/search/SearchResultTrampoline.java\n@@ -52,11 +51,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFeatureFactory()\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -138,9 +137,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFeatureFactory().getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }\n```",
                                    "rej_file_tokens": {
                                        "openai": 277,
                                        "general": {
                                            "word_based": 115,
                                            "char_based": 378
                                        },
                                        "gemini": 335
                                    },
                                    "patch_apply_output": "patching file src/com/android/settings/search/SearchFeatureProvider.java\npatching file src/com/android/settings/search/SearchFeatureProviderImpl.java\npatching file src/com/android/settings/search/SearchResultTrampoline.java\nHunk #1 succeeded at 20 with fuzz 1 (offset -1 lines).\nHunk #2 FAILED at 52.\nHunk #3 succeeded at 104 with fuzz 2 (offset -1 lines).\nHunk #4 FAILED at 138.\n2 out of 4 hunks FAILED -- saving rejects to file src/com/android/settings/search/SearchResultTrampoline.java.rej",
                                    "inline_merge_output": "patching file src/com/android/settings/search/SearchResultTrampoline.java\nHunk #1 already applied at 24.\nHunk #2 already applied at 55,59.\nHunk #3 already applied at 108.\nHunk #4 already applied at 141-143.",
                                    "upstream_file_tokens": {
                                        "openai": 1137,
                                        "general": {
                                            "word_based": 526,
                                            "char_based": 1616
                                        },
                                        "gemini": 1451
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.search;\n\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENTS;\nimport static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.FeatureFlagUtils;\nimport android.util.Log;\n\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsApplication;\nimport com.android.settings.SubSettings;\nimport com.android.settings.activityembedding.ActivityEmbeddingRulesController;\nimport com.android.settings.activityembedding.ActivityEmbeddingUtils;\nimport com.android.settings.core.FeatureFlags;\nimport com.android.settings.homepage.DeepLinkHomepageActivityInternal;\nimport com.android.settings.homepage.SettingsHomepageActivity;\nimport com.android.settings.overlay.FeatureFactory;\n\nimport java.net.URISyntaxException;\n\n/**\n * A trampoline activity that launches setting result page.\n */\npublic class SearchResultTrampoline extends Activity {\n\n    private static final String TAG = \"SearchResultTrampoline\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        final ComponentName callingActivity = getCallingActivity();\n        // First make sure caller has privilege to launch a search result page.\n        FeatureFactory.getFactory(this)\n                .getSearchFeatureProvider()\n                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n        // Didn't crash, proceed and launch the result as a subsetting.\n        Intent intent = getIntent();\n        final String highlightMenuKey = intent.getStringExtra(\n                Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_HIGHLIGHT_MENU_KEY);\n\n        final String fragment = intent.getStringExtra(SettingsActivity.EXTRA_SHOW_FRAGMENT);\n        if (!TextUtils.isEmpty(fragment)) {\n            // Hack to take EXTRA_FRAGMENT_ARG_KEY from intent and set into\n            // EXTRA_SHOW_FRAGMENT_ARGUMENTS. This is necessary because intent could be from\n            // external caller and args may not persisted.\n            final String settingKey = intent.getStringExtra(\n                    SettingsActivity.EXTRA_FRAGMENT_ARG_KEY);\n            final int tab = intent.getIntExtra(EXTRA_SHOW_FRAGMENT_TAB, 0);\n            final Bundle args = new Bundle();\n            args.putString(SettingsActivity.EXTRA_FRAGMENT_ARG_KEY, settingKey);\n            args.putInt(EXTRA_SHOW_FRAGMENT_TAB, tab);\n            intent.putExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS, args);\n\n            // Reroute request to SubSetting.\n            intent.setClass(this /* context */, SubSettings.class);\n        } else {\n            // Direct link case\n            final String intentUriString = intent.getStringExtra(\n                    Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI);\n            if (TextUtils.isEmpty(intentUriString)) {\n                Log.e(TAG, \"No EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI for deep link\");\n                finish();\n                return;\n            }\n\n            final Uri data = intent.getParcelableExtra(\n                    SettingsHomepageActivity.EXTRA_SETTINGS_LARGE_SCREEN_DEEP_LINK_INTENT_DATA,\n                    Uri.class);\n            try {\n                intent = Intent.parseUri(intentUriString, Intent.URI_INTENT_SCHEME);\n                intent.setData(data);\n            } catch (URISyntaxException e) {\n                Log.e(TAG, \"Failed to parse deep link intent: \" + e);\n                finish();\n                return;\n            }\n        }\n\n        intent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);\n\n        if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)\n                || ActivityEmbeddingUtils.isAlreadyEmbedded(this)) {\n            startActivity(intent);\n        } else if (isSettingsIntelligence(callerPackage)) {\n            if (FeatureFlagUtils.isEnabled(this, FeatureFlags.SETTINGS_SEARCH_ALWAYS_EXPAND)) {\n                startActivity(SettingsActivity.getTrampolineIntent(intent, highlightMenuKey)\n                        .setClass(this, DeepLinkHomepageActivityInternal.class)\n                        .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK\n                                | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS));\n            } else {\n                // Register SplitPairRule for SubSettings, set clearTop false to prevent unexpected\n                // back navigation behavior.\n                ActivityEmbeddingRulesController.registerSubSettingsPairRule(this,\n                        false /* clearTop */);\n\n                intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_NEW_TASK);\n                startActivity(intent);\n\n                // Pass menu key to homepage\n                final SettingsHomepageActivity homeActivity =\n                        ((SettingsApplication) getApplicationContext()).getHomeActivity();\n                if (homeActivity != null) {\n                    homeActivity.getMainFragment().setHighlightMenuKey(highlightMenuKey,\n                            /* scrollNeeded= */ true);\n                }\n            }\n        } else {\n            // Two-pane case\n            startActivity(SettingsActivity.getTrampolineIntent(intent, highlightMenuKey)\n                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK));\n        }\n\n        // Done.\n        finish();\n    }\n\n    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n        return callingActivity != null && TextUtils.equals(\n                callingActivity.getPackageName(),\n                FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                        .getSettingsIntelligencePkgName(this));\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 1131,
                                        "general": {
                                            "word_based": 525,
                                            "char_based": 1614
                                        },
                                        "gemini": 1443
                                    }
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ],
    "vulnerabilities_with_partial_failures": [
        {
            "id": "ASB-A-317048495",
            "aliases": [
                "A-317048495",
                "CVE-2024-43764"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-317048495",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "2976ca86d5c5be558191a1fe706d4cd0d7ccdecb"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 2976ca86d5c5be558191a1fe706d4cd0d7ccdecb Mon Sep 17 00:00:00 2001\nFrom: Miranda Kephart <mkephart@google.com>\nDate: Fri, 16 Feb 2024 10:14:15 -0500\nSubject: [PATCH] Block clipboard UI when device is locked\n\nIn some situations (see bug for details) it's possible to enter the\nclipboard even while the device is locked, and from there access the\nprovided intents. Users should not be able to access intents from this\nstate; this change adds an additional check before showing the interactive UI.\n\nThe behavior is identical to what we do when user setup is not complete\n(b/251778420): we show a toast to note that content has been copied, but no interactive UI.\n\nInteractive UI is only blocked when device is locked (i.e. requiring pin\nentry/password/biometric/etc), not if the keyguard is up but trivially\ndismissable.\n\nBug: 317048495\nFlag: ACONFIG com.android.systemui.clipboard_noninteractive_on_lockscreen DEVELOPMENT\nTest: atest ClipboardListenerTest; verification using steps in linked\nbug as well as forcing text content to appear client-side, to verify\nthat even if text content is received in the ClipboardListener, no\ninteractive UI appears.\n\nChange-Id: I1a48cbe64852dce3fba69915ca11dad8878f66eb\n---\n packages/SystemUI/aconfig/systemui.aconfig    | 10 ++++++\n .../clipboardoverlay/ClipboardListener.java   |  9 ++++-\n .../ClipboardListenerTest.java                | 36 ++++++++++++++++++-\n 3 files changed, 53 insertions(+), 2 deletions(-)\n\ndiff --git a/packages/SystemUI/aconfig/systemui.aconfig b/packages/SystemUI/aconfig/systemui.aconfig\nindex 4ed1965d1b33..7df8f03fe6ac 100644\n--- a/packages/SystemUI/aconfig/systemui.aconfig\n+++ b/packages/SystemUI/aconfig/systemui.aconfig\n@@ -489,3 +489,13 @@ flag {\n         purpose: PURPOSE_BUGFIX\n     }\n }\n+\n+flag {\n+    name: \"clipboard_noninteractive_on_lockscreen\"\n+    namespace: \"systemui\"\n+    description: \"Prevents the interactive clipboard UI from appearing when device is locked\"\n+    bug: \"317048495\"\n+    metadata {\n+        purpose: PURPOSE_BUGFIX\n+    }\n+}\ndiff --git a/packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java b/packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\nindex e0ce3db39403..c7a47b18f467 100644\n--- a/packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\n+++ b/packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\n@@ -18,12 +18,14 @@ package com.android.systemui.clipboardoverlay;\n \n import static android.content.ClipDescription.CLASSIFICATION_COMPLETE;\n \n+import static com.android.systemui.Flags.clipboardNoninteractiveOnLockscreen;\n import static com.android.systemui.clipboardoverlay.ClipboardOverlayEvent.CLIPBOARD_OVERLAY_ENTERED;\n import static com.android.systemui.clipboardoverlay.ClipboardOverlayEvent.CLIPBOARD_OVERLAY_UPDATED;\n import static com.android.systemui.clipboardoverlay.ClipboardOverlayEvent.CLIPBOARD_TOAST_SHOWN;\n \n import static com.google.android.setupcompat.util.WizardManagerHelper.SETTINGS_SECURE_USER_SETUP_COMPLETE;\n \n+import android.app.KeyguardManager;\n import android.content.ClipData;\n import android.content.ClipboardManager;\n import android.content.Context;\n@@ -57,6 +59,7 @@ public class ClipboardListener implements\n     private final Provider<ClipboardOverlayController> mOverlayProvider;\n     private final ClipboardToast mClipboardToast;\n     private final ClipboardManager mClipboardManager;\n+    private final KeyguardManager mKeyguardManager;\n     private final UiEventLogger mUiEventLogger;\n     private ClipboardOverlay mClipboardOverlay;\n \n@@ -65,11 +68,13 @@ public class ClipboardListener implements\n             Provider<ClipboardOverlayController> clipboardOverlayControllerProvider,\n             ClipboardToast clipboardToast,\n             ClipboardManager clipboardManager,\n+            KeyguardManager keyguardManager,\n             UiEventLogger uiEventLogger) {\n         mContext = context;\n         mOverlayProvider = clipboardOverlayControllerProvider;\n         mClipboardToast = clipboardToast;\n         mClipboardManager = clipboardManager;\n+        mKeyguardManager = keyguardManager;\n         mUiEventLogger = uiEventLogger;\n     }\n \n@@ -92,7 +97,9 @@ public class ClipboardListener implements\n             return;\n         }\n \n-        if (!isUserSetupComplete() // user should not access intents from this state\n+        // user should not access intents before setup or while device is locked\n+        if ((clipboardNoninteractiveOnLockscreen() && mKeyguardManager.isDeviceLocked())\n+                || !isUserSetupComplete()\n                 || clipData == null // shouldn't happen, but just in case\n                 || clipData.getItemCount() == 0) {\n             if (shouldShowToast(clipData)) {\ndiff --git a/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardListenerTest.java b/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardListenerTest.java\nindex 18515825967f..c65a1176a55b 100644\n--- a/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardListenerTest.java\n+++ b/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardListenerTest.java\n@@ -27,16 +27,20 @@ import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.verifyZeroInteractions;\n import static org.mockito.Mockito.when;\n \n+import android.app.KeyguardManager;\n import android.content.ClipData;\n import android.content.ClipDescription;\n import android.content.ClipboardManager;\n import android.os.PersistableBundle;\n+import android.platform.test.annotations.DisableFlags;\n+import android.platform.test.annotations.EnableFlags;\n import android.provider.Settings;\n \n import androidx.test.filters.SmallTest;\n import androidx.test.runner.AndroidJUnit4;\n \n import com.android.internal.logging.UiEventLogger;\n+import com.android.systemui.Flags;\n import com.android.systemui.SysuiTestCase;\n \n import org.junit.Before;\n@@ -59,6 +63,8 @@ public class ClipboardListenerTest extends SysuiTestCase {\n     @Mock\n     private ClipboardManager mClipboardManager;\n     @Mock\n+    private KeyguardManager mKeyguardManager;\n+    @Mock\n     private ClipboardOverlayController mOverlayController;\n     @Mock\n     private ClipboardToast mClipboardToast;\n@@ -96,7 +102,7 @@ public class ClipboardListenerTest extends SysuiTestCase {\n         when(mClipboardManager.getPrimaryClipSource()).thenReturn(mSampleSource);\n \n         mClipboardListener = new ClipboardListener(getContext(), mOverlayControllerProvider,\n-                mClipboardToast, mClipboardManager, mUiEventLogger);\n+                mClipboardToast, mClipboardManager, mKeyguardManager, mUiEventLogger);\n     }\n \n \n@@ -190,6 +196,34 @@ public class ClipboardListenerTest extends SysuiTestCase {\n         verifyZeroInteractions(mOverlayControllerProvider);\n     }\n \n+    @Test\n+    @EnableFlags(Flags.FLAG_CLIPBOARD_NONINTERACTIVE_ON_LOCKSCREEN)\n+    public void test_deviceLocked_showsToast() {\n+        when(mKeyguardManager.isDeviceLocked()).thenReturn(true);\n+\n+        mClipboardListener.start();\n+        mClipboardListener.onPrimaryClipChanged();\n+\n+        verify(mUiEventLogger, times(1)).log(\n+                ClipboardOverlayEvent.CLIPBOARD_TOAST_SHOWN, 0, mSampleSource);\n+        verify(mClipboardToast, times(1)).showCopiedToast();\n+        verifyZeroInteractions(mOverlayControllerProvider);\n+    }\n+\n+    @Test\n+    @DisableFlags(Flags.FLAG_CLIPBOARD_NONINTERACTIVE_ON_LOCKSCREEN)\n+    public void test_deviceLocked_legacyBehavior_showsInteractiveUI() {\n+        when(mKeyguardManager.isDeviceLocked()).thenReturn(true);\n+\n+        mClipboardListener.start();\n+        mClipboardListener.onPrimaryClipChanged();\n+\n+        verify(mUiEventLogger, times(1)).log(\n+                ClipboardOverlayEvent.CLIPBOARD_OVERLAY_ENTERED, 0, mSampleSource);\n+        verify(mOverlayController).setClipData(mSampleClipData, mSampleSource);\n+        verifyZeroInteractions(mClipboardToast);\n+    }\n+\n     @Test\n     public void test_nullClipData_showsNothing() {\n         when(mClipboardManager.getPrimaryClip()).thenReturn(null);\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 1871,
                        "general": {
                            "word_based": 775,
                            "char_based": 2040
                        },
                        "gemini": 2327
                    },
                    "total_downstream_versions_tested": 2,
                    "successful_patches": 1,
                    "failed_patches": 1,
                    "patch_results": [
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "c7d1402707ea106b58fa9297585ae22d5c09d7f9",
                            "repo_path": "android_repos/base",
                            "result": "failure",
                            "downstream_patch_content": "commit c7d1402707ea106b58fa9297585ae22d5c09d7f9\nAuthor: Miranda Kephart <mkephart@google.com>\nDate:   Fri Feb 16 10:14:15 2024 -0500\n\n    Block clipboard UI when device is locked\n    \n    In some situations (see bug for details) it's possible to enter the\n    clipboard even while the device is locked, and from there access the\n    provided intents. Users should not be able to access intents from this\n    state; this change adds an additional check before showing the interactive UI.\n    \n    The behavior is identical to what we do when user setup is not complete\n    (b/251778420): we show a toast to note that content has been copied, but no interactive UI.\n    \n    Interactive UI is only blocked when device is locked (i.e. requiring pin\n    entry/password/biometric/etc), not if the keyguard is up but trivially\n    dismissable.\n    \n    Bug: 317048495\n    Test: atest ClipboardListenerTest; verification using steps in linked\n    bug as well as forcing text content to appear client-side, to verify\n    that even if text content is received in the ClipboardListener, no\n    interactive UI appears.\n    \n    Change-Id: I1a48cbe64852dce3fba69915ca11dad8878f66eb\n    Merged-In: I1a48cbe64852dce3fba69915ca11dad8878f66eb\n    (cherry picked from commit 2976ca86d5c5be558191a1fe706d4cd0d7ccdecb)\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java b/packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\nindex da602caac0dc..cdf58db58a15 100644\n--- a/packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\n+++ b/packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\n@@ -25,6 +25,7 @@ import static com.android.systemui.clipboardoverlay.ClipboardOverlayEvent.CLIPBO\n \n import static com.google.android.setupcompat.util.WizardManagerHelper.SETTINGS_SECURE_USER_SETUP_COMPLETE;\n \n+import android.app.KeyguardManager;\n import android.content.ClipData;\n import android.content.ClipboardManager;\n import android.content.Context;\n@@ -59,18 +60,21 @@ public class ClipboardListener extends CoreStartable\n     private final ClipboardOverlayControllerFactory mOverlayFactory;\n     private final ClipboardToast mClipboardToast;\n     private final ClipboardManager mClipboardManager;\n+    private final KeyguardManager mKeyguardManager;\n     private final UiEventLogger mUiEventLogger;\n     private ClipboardOverlayController mClipboardOverlayController;\n \n     @Inject\n     public ClipboardListener(Context context, DeviceConfigProxy deviceConfigProxy,\n             ClipboardOverlayControllerFactory overlayFactory, ClipboardManager clipboardManager,\n-            ClipboardToast clipboardToast,UiEventLogger uiEventLogger) {\n+            ClipboardToast clipboardToast, KeyguardManager keyguardManager,\n+            UiEventLogger uiEventLogger) {\n         super(context);\n         mDeviceConfig = deviceConfigProxy;\n         mOverlayFactory = overlayFactory;\n         mClipboardToast = clipboardToast;\n         mClipboardManager = clipboardManager;\n+        mKeyguardManager = keyguardManager;\n         mUiEventLogger = uiEventLogger;\n     }\n \n@@ -96,8 +100,11 @@ public class ClipboardListener extends CoreStartable\n             return;\n         }\n \n-        if (!isUserSetupComplete()) {\n-            // just show a toast, user should not access intents from this state\n+        // user should not access intents before setup or while device is locked\n+        if (mKeyguardManager.isDeviceLocked()\n+                || !isUserSetupComplete()\n+                || clipData == null // shouldn't happen, but just in case\n+                || clipData.getItemCount() == 0) {\n             if (shouldShowToast(clipData)) {\n                 mUiEventLogger.log(CLIPBOARD_TOAST_SHOWN, 0, clipSource);\n                 mClipboardToast.showCopiedToast();\ndiff --git a/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardListenerTest.java b/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardListenerTest.java\nindex 86402b3202d4..11803d68d5ac 100644\n--- a/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardListenerTest.java\n+++ b/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardListenerTest.java\n@@ -29,6 +29,7 @@ import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.verifyZeroInteractions;\n import static org.mockito.Mockito.when;\n \n+import android.app.KeyguardManager;\n import android.content.ClipData;\n import android.content.ClipDescription;\n import android.content.ClipboardManager;\n@@ -51,6 +52,8 @@ import org.mockito.Captor;\n import org.mockito.Mock;\n import org.mockito.MockitoAnnotations;\n \n+import java.util.ArrayList;\n+\n @SmallTest\n @RunWith(AndroidJUnit4.class)\n public class ClipboardListenerTest extends SysuiTestCase {\n@@ -60,6 +63,8 @@ public class ClipboardListenerTest extends SysuiTestCase {\n     @Mock\n     private ClipboardOverlayControllerFactory mClipboardOverlayControllerFactory;\n     @Mock\n+    private KeyguardManager mKeyguardManager;\n+    @Mock\n     private ClipboardOverlayController mOverlayController;\n     @Mock\n     private ClipboardToast mClipboardToast;\n@@ -97,7 +102,7 @@ public class ClipboardListenerTest extends SysuiTestCase {\n \n         mClipboardListener = new ClipboardListener(getContext(), mDeviceConfigProxy,\n                 mClipboardOverlayControllerFactory, mClipboardManager,mClipboardToast,\n-                mUiEventLogger);\n+                mKeyguardManager, mUiEventLogger);\n     }\n \n     @Test\n@@ -201,4 +206,44 @@ public class ClipboardListenerTest extends SysuiTestCase {\n         verify(mClipboardToast, times(1)).showCopiedToast();\n         verifyZeroInteractions(mClipboardOverlayControllerFactory);\n     }\n+\n+    @Test\n+    public void test_deviceLocked_showsToast() {\n+        when(mKeyguardManager.isDeviceLocked()).thenReturn(true);\n+\n+        mClipboardListener.start();\n+        mClipboardListener.onPrimaryClipChanged();\n+\n+        verify(mUiEventLogger, times(1)).log(\n+                ClipboardOverlayEvent.CLIPBOARD_TOAST_SHOWN, 0, mSampleSource);\n+        verify(mClipboardToast, times(1)).showCopiedToast();\n+        verifyZeroInteractions(mClipboardOverlayControllerFactory);\n+    }\n+\n+    @Test\n+    public void test_nullClipData_showsNothing() {\n+        when(mClipboardManager.getPrimaryClip()).thenReturn(null);\n+\n+        mClipboardListener.start();\n+        mClipboardListener.onPrimaryClipChanged();\n+\n+        verifyZeroInteractions(mUiEventLogger);\n+        verifyZeroInteractions(mClipboardToast);\n+        verifyZeroInteractions(mClipboardOverlayControllerFactory);\n+    }\n+\n+    @Test\n+    public void test_emptyClipData_showsToast() {\n+        ClipDescription description = new ClipDescription(\"Test\", new String[0]);\n+        ClipData noItems = new ClipData(description, new ArrayList<>());\n+        when(mClipboardManager.getPrimaryClip()).thenReturn(noItems);\n+\n+        mClipboardListener.start();\n+        mClipboardListener.onPrimaryClipChanged();\n+\n+        verify(mUiEventLogger, times(1)).log(\n+                ClipboardOverlayEvent.CLIPBOARD_TOAST_SHOWN, 0, mSampleSource);\n+        verify(mClipboardToast, times(1)).showCopiedToast();\n+        verifyZeroInteractions(mClipboardOverlayControllerFactory);\n+    }\n }\ndiff --git a/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardOverlayEventTest.java b/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardOverlayEventTest.java\nindex 5e2f6a0f7a70..022d1a2b411b 100644\n--- a/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardOverlayEventTest.java\n+++ b/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardOverlayEventTest.java\n@@ -23,6 +23,7 @@ import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n+import android.app.KeyguardManager;\n import android.content.ClipData;\n import android.content.ClipboardManager;\n import android.provider.DeviceConfig;\n@@ -51,6 +52,8 @@ public class ClipboardOverlayEventTest extends SysuiTestCase {\n     @Mock\n     private ClipboardOverlayController mOverlayController;\n     @Mock\n+    private KeyguardManager mKeyguardManager;\n+    @Mock\n     private ClipboardToast mClipboardToast;\n     @Mock\n     private UiEventLogger mUiEventLogger;\n@@ -78,7 +81,7 @@ public class ClipboardOverlayEventTest extends SysuiTestCase {\n \n         mClipboardListener = new ClipboardListener(getContext(), deviceConfigProxy,\n                 mClipboardOverlayControllerFactory, mClipboardManager, mClipboardToast,\n-                mUiEventLogger);\n+                mKeyguardManager, mUiEventLogger);\n     }\n \n     @Test\n",
                            "downstream_patch_tokens": {
                                "openai": 2006,
                                "general": {
                                    "word_based": 795,
                                    "char_based": 2195
                                },
                                "gemini": 2447
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java",
                                    "total_hunks": 4,
                                    "failed_hunks": [
                                        1,
                                        3,
                                        4
                                    ],
                                    "inline_merge_conflicts": [],
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    },
                                    "rej_file_content": "```diff\n--- packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\n+++ packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\n@@ -18,12 +18,14 @@ package com.android.systemui.clipboardoverlay;\n \n import static android.content.ClipDescription.CLASSIFICATION_COMPLETE;\n \n+import static com.android.systemui.Flags.clipboardNoninteractiveOnLockscreen;\n import static com.android.systemui.clipboardoverlay.ClipboardOverlayEvent.CLIPBOARD_OVERLAY_ENTERED;\n import static com.android.systemui.clipboardoverlay.ClipboardOverlayEvent.CLIPBOARD_OVERLAY_UPDATED;\n import static com.android.systemui.clipboardoverlay.ClipboardOverlayEvent.CLIPBOARD_TOAST_SHOWN;\n \n import static com.google.android.setupcompat.util.WizardManagerHelper.SETTINGS_SECURE_USER_SETUP_COMPLETE;\n \n+import android.app.KeyguardManager;\n import android.content.ClipData;\n import android.content.ClipboardManager;\n import android.content.Context;\n@@ -66,11 +69,13 @@ public class ClipboardListener implements\n             Provider<ClipboardOverlayController> clipboardOverlayControllerProvider,\n             ClipboardToast clipboardToast,\n             ClipboardManager clipboardManager,\n+            KeyguardManager keyguardManager,\n             UiEventLogger uiEventLogger) {\n         mContext = context;\n         mOverlayProvider = clipboardOverlayControllerProvider;\n         mClipboardToast = clipboardToast;\n         mClipboardManager = clipboardManager;\n+        mKeyguardManager = keyguardManager;\n         mUiEventLogger = uiEventLogger;\n     }\n \n@@ -93,7 +98,9 @@ public class ClipboardListener implements\n             return;\n         }\n \n-        if (!isUserSetupComplete() // user should not access intents from this state\n+        // user should not access intents before setup or while device is locked\n+        if ((clipboardNoninteractiveOnLockscreen() && mKeyguardManager.isDeviceLocked())\n+                || !isUserSetupComplete()\n                 || clipData == null // shouldn't happen, but just in case\n                 || clipData.getItemCount() == 0) {\n             if (shouldShowToast(clipData)) {\n```",
                                    "rej_file_tokens": {
                                        "openai": 434,
                                        "general": {
                                            "word_based": 171,
                                            "char_based": 533
                                        },
                                        "gemini": 522
                                    },
                                    "patch_apply_output": "patching file packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\nHunk #1 FAILED at 18.\nHunk #2 succeeded at 59 with fuzz 2 (offset 2 lines).\nHunk #3 FAILED at 66.\nHunk #4 FAILED at 93.\n3 out of 4 hunks FAILED -- saving rejects to file packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java.rej",
                                    "inline_merge_output": "patching file packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\nHunk #1 already applied at 21,28.\nHunk #2 already applied at 62.\nHunk #3 already applied at 71,77.\nHunk #4 already applied at 100-102.",
                                    "upstream_file_tokens": {
                                        "openai": 1271,
                                        "general": {
                                            "word_based": 550,
                                            "char_based": 1580
                                        },
                                        "gemini": 1496
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2021 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.systemui.clipboardoverlay;\n\nimport static android.content.ClipDescription.CLASSIFICATION_COMPLETE;\n\nimport static com.android.internal.config.sysui.SystemUiDeviceConfigFlags.CLIPBOARD_OVERLAY_ENABLED;\nimport static com.android.systemui.clipboardoverlay.ClipboardOverlayEvent.CLIPBOARD_OVERLAY_ENTERED;\nimport static com.android.systemui.clipboardoverlay.ClipboardOverlayEvent.CLIPBOARD_OVERLAY_UPDATED;\nimport static com.android.systemui.clipboardoverlay.ClipboardOverlayEvent.CLIPBOARD_TOAST_SHOWN;\n\nimport static com.google.android.setupcompat.util.WizardManagerHelper.SETTINGS_SECURE_USER_SETUP_COMPLETE;\n\nimport android.content.ClipData;\nimport android.content.ClipboardManager;\nimport android.content.Context;\nimport android.os.SystemProperties;\nimport android.provider.DeviceConfig;\nimport android.provider.Settings;\nimport android.util.Log;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.logging.UiEventLogger;\nimport com.android.systemui.CoreStartable;\nimport com.android.systemui.dagger.SysUISingleton;\nimport com.android.systemui.util.DeviceConfigProxy;\n\nimport javax.inject.Inject;\n\n/**\n * ClipboardListener brings up a clipboard overlay when something is copied to the clipboard.\n */\n@SysUISingleton\npublic class ClipboardListener extends CoreStartable\n        implements ClipboardManager.OnPrimaryClipChangedListener {\n    private static final String TAG = \"ClipboardListener\";\n\n    @VisibleForTesting\n    static final String SHELL_PACKAGE = \"com.android.shell\";\n    @VisibleForTesting\n    static final String EXTRA_SUPPRESS_OVERLAY =\n            \"com.android.systemui.SUPPRESS_CLIPBOARD_OVERLAY\";\n\n    private final DeviceConfigProxy mDeviceConfig;\n    private final ClipboardOverlayControllerFactory mOverlayFactory;\n    private final ClipboardToast mClipboardToast;\n    private final ClipboardManager mClipboardManager;\n    private final KeyguardManager mKeyguardManager;\n    private final UiEventLogger mUiEventLogger;\n    private ClipboardOverlayController mClipboardOverlayController;\n\n    @Inject\n    public ClipboardListener(Context context, DeviceConfigProxy deviceConfigProxy,\n            ClipboardOverlayControllerFactory overlayFactory, ClipboardManager clipboardManager,\n            ClipboardToast clipboardToast,UiEventLogger uiEventLogger) {\n        super(context);\n        mDeviceConfig = deviceConfigProxy;\n        mOverlayFactory = overlayFactory;\n        mClipboardToast = clipboardToast;\n        mClipboardManager = clipboardManager;\n        mUiEventLogger = uiEventLogger;\n    }\n\n    @Override\n    public void start() {\n        if (mDeviceConfig.getBoolean(\n                DeviceConfig.NAMESPACE_SYSTEMUI, CLIPBOARD_OVERLAY_ENABLED, true)) {\n            mClipboardManager.addPrimaryClipChangedListener(this);\n        }\n    }\n\n    @Override\n    public void onPrimaryClipChanged() {\n        if (!mClipboardManager.hasPrimaryClip()) {\n            return;\n        }\n\n        String clipSource = mClipboardManager.getPrimaryClipSource();\n        ClipData clipData = mClipboardManager.getPrimaryClip();\n\n        if (shouldSuppressOverlay(clipData, clipSource, isEmulator())) {\n            Log.i(TAG, \"Clipboard overlay suppressed.\");\n            return;\n        }\n\n        if (!isUserSetupComplete()) {\n            // just show a toast, user should not access intents from this state\n            if (shouldShowToast(clipData)) {\n                mUiEventLogger.log(CLIPBOARD_TOAST_SHOWN, 0, clipSource);\n                mClipboardToast.showCopiedToast();\n            }\n            return;\n        }\n\n        if (mClipboardOverlayController == null) {\n            mClipboardOverlayController = mOverlayFactory.create(mContext);\n            mUiEventLogger.log(CLIPBOARD_OVERLAY_ENTERED, 0, clipSource);\n        } else {\n            mUiEventLogger.log(CLIPBOARD_OVERLAY_UPDATED, 0, clipSource);\n        }\n        mClipboardOverlayController.setClipData(clipData, clipSource);\n        mClipboardOverlayController.setOnSessionCompleteListener(() -> {\n            // Session is complete, free memory until it's needed again.\n            mClipboardOverlayController = null;\n        });\n    }\n\n    // The overlay is suppressed if EXTRA_SUPPRESS_OVERLAY is true and the device is an emulator or\n    // the source package is SHELL_PACKAGE. This is meant to suppress the overlay when the emulator\n    // or a mirrored device is syncing the clipboard.\n    @VisibleForTesting\n    static boolean shouldSuppressOverlay(ClipData clipData, String clipSource,\n            boolean isEmulator) {\n        if (!(isEmulator || SHELL_PACKAGE.equals(clipSource))) {\n            return false;\n        }\n        if (clipData == null || clipData.getDescription().getExtras() == null) {\n            return false;\n        }\n        return clipData.getDescription().getExtras().getBoolean(EXTRA_SUPPRESS_OVERLAY, false);\n    }\n\n    boolean shouldShowToast(ClipData clipData) {\n        if (clipData == null) {\n            return false;\n        } else if (clipData.getDescription().getClassificationStatus() == CLASSIFICATION_COMPLETE) {\n            // only show for classification complete if we aren't already showing a toast, to ignore\n            // the duplicate ClipData with classification\n            return !mClipboardToast.isShowing();\n        }\n        return true;\n    }\n\n    private static boolean isEmulator() {\n        return SystemProperties.getBoolean(\"ro.boot.qemu\", false);\n    }\n\n    private boolean isUserSetupComplete() {\n        return Settings.Secure.getInt(mContext.getContentResolver(),\n                SETTINGS_SECURE_USER_SETUP_COMPLETE, 0) == 1;\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 1254,
                                        "general": {
                                            "word_based": 544,
                                            "char_based": 1565
                                        },
                                        "gemini": 1485
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "b156c582347ad55a592eb364c8c86aee915195bf",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit b156c582347ad55a592eb364c8c86aee915195bf\nAuthor: Miranda Kephart <mkephart@google.com>\nDate:   Fri Feb 16 10:14:15 2024 -0500\n\n    Block clipboard UI when device is locked\n    \n    In some situations (see bug for details) it's possible to enter the\n    clipboard even while the device is locked, and from there access the\n    provided intents. Users should not be able to access intents from this\n    state; this change adds an additional check before showing the interactive UI.\n    \n    The behavior is identical to what we do when user setup is not complete\n    (b/251778420): we show a toast to note that content has been copied, but no interactive UI.\n    \n    Interactive UI is only blocked when device is locked (i.e. requiring pin\n    entry/password/biometric/etc), not if the keyguard is up but trivially\n    dismissable.\n    \n    Bug: 317048495\n    Test: atest ClipboardListenerTest; verification using steps in linked\n    bug as well as forcing text content to appear client-side, to verify\n    that even if text content is received in the ClipboardListener, no\n    interactive UI appears.\n    \n    Change-Id: I1a48cbe64852dce3fba69915ca11dad8878f66eb\n    Merged-In: I1a48cbe64852dce3fba69915ca11dad8878f66eb\n    (cherry picked from commit 2976ca86d5c5be558191a1fe706d4cd0d7ccdecb)\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java b/packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\nindex 63b4288ce055..f0a980e0a30c 100644\n--- a/packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\n+++ b/packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\n@@ -24,6 +24,7 @@ import static com.android.systemui.clipboardoverlay.ClipboardOverlayEvent.CLIPBO\n \n import static com.google.android.setupcompat.util.WizardManagerHelper.SETTINGS_SECURE_USER_SETUP_COMPLETE;\n \n+import android.app.KeyguardManager;\n import android.content.ClipData;\n import android.content.ClipboardManager;\n import android.content.Context;\n@@ -57,6 +58,7 @@ public class ClipboardListener implements\n     private final Provider<ClipboardOverlayController> mOverlayProvider;\n     private final ClipboardToast mClipboardToast;\n     private final ClipboardManager mClipboardManager;\n+    private final KeyguardManager mKeyguardManager;\n     private final UiEventLogger mUiEventLogger;\n     private ClipboardOverlay mClipboardOverlay;\n \n@@ -65,11 +67,13 @@ public class ClipboardListener implements\n             Provider<ClipboardOverlayController> clipboardOverlayControllerProvider,\n             ClipboardToast clipboardToast,\n             ClipboardManager clipboardManager,\n+            KeyguardManager keyguardManager,\n             UiEventLogger uiEventLogger) {\n         mContext = context;\n         mOverlayProvider = clipboardOverlayControllerProvider;\n         mClipboardToast = clipboardToast;\n         mClipboardManager = clipboardManager;\n+        mKeyguardManager = keyguardManager;\n         mUiEventLogger = uiEventLogger;\n     }\n \n@@ -92,7 +96,9 @@ public class ClipboardListener implements\n             return;\n         }\n \n-        if (!isUserSetupComplete() // user should not access intents from this state\n+        // user should not access intents before setup or while device is locked\n+        if (mKeyguardManager.isDeviceLocked()\n+                || !isUserSetupComplete()\n                 || clipData == null // shouldn't happen, but just in case\n                 || clipData.getItemCount() == 0) {\n             if (shouldShowToast(clipData)) {\ndiff --git a/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardListenerTest.java b/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardListenerTest.java\nindex 18515825967f..9d02c86cfa7a 100644\n--- a/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardListenerTest.java\n+++ b/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardListenerTest.java\n@@ -27,6 +27,7 @@ import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.verifyZeroInteractions;\n import static org.mockito.Mockito.when;\n \n+import android.app.KeyguardManager;\n import android.content.ClipData;\n import android.content.ClipDescription;\n import android.content.ClipboardManager;\n@@ -59,6 +60,8 @@ public class ClipboardListenerTest extends SysuiTestCase {\n     @Mock\n     private ClipboardManager mClipboardManager;\n     @Mock\n+    private KeyguardManager mKeyguardManager;\n+    @Mock\n     private ClipboardOverlayController mOverlayController;\n     @Mock\n     private ClipboardToast mClipboardToast;\n@@ -96,7 +99,7 @@ public class ClipboardListenerTest extends SysuiTestCase {\n         when(mClipboardManager.getPrimaryClipSource()).thenReturn(mSampleSource);\n \n         mClipboardListener = new ClipboardListener(getContext(), mOverlayControllerProvider,\n-                mClipboardToast, mClipboardManager, mUiEventLogger);\n+                mClipboardToast, mClipboardManager, mKeyguardManager, mUiEventLogger);\n     }\n \n \n@@ -190,6 +193,19 @@ public class ClipboardListenerTest extends SysuiTestCase {\n         verifyZeroInteractions(mOverlayControllerProvider);\n     }\n \n+    @Test\n+    public void test_deviceLocked_showsToast() {\n+        when(mKeyguardManager.isDeviceLocked()).thenReturn(true);\n+\n+        mClipboardListener.start();\n+        mClipboardListener.onPrimaryClipChanged();\n+\n+        verify(mUiEventLogger, times(1)).log(\n+                ClipboardOverlayEvent.CLIPBOARD_TOAST_SHOWN, 0, mSampleSource);\n+        verify(mClipboardToast, times(1)).showCopiedToast();\n+        verifyZeroInteractions(mOverlayControllerProvider);\n+    }\n+\n     @Test\n     public void test_nullClipData_showsNothing() {\n         when(mClipboardManager.getPrimaryClip()).thenReturn(null);\n",
                            "downstream_patch_tokens": {
                                "openai": 1346,
                                "general": {
                                    "word_based": 562,
                                    "char_based": 1461
                                },
                                "gemini": 1650
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-283103220",
            "aliases": [
                "A-283103220",
                "CVE-2024-34737"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-283103220",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "17b00deed56a6bbd3b78fbac76c2f1089f615002"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 17b00deed56a6bbd3b78fbac76c2f1089f615002 Mon Sep 17 00:00:00 2001\nFrom: Hongwei Wang <hwwang@google.com>\nDate: Tue, 1 Aug 2023 16:00:31 -0700\nSubject: [PATCH] Rate limiting PiP aspect ratio change request\n\nUsing CountQuotaTrack to limit how frequent an app can request aspect\nratio change via PictureInPictureParams, which could result flood of PiP\nresizing requests and freeze the PiP window.\n\nNote that CountQuotaTrack is initialized out of the WM lock to avoid\ndead lock with the AM one.\n\nBug: 283103220\nTest: Manually, using the POC app\nTest: Manually, switching YT PiP video functions at a regular rate\nTest: atest WindowOrganizerTests ActivityThreadTest\nChange-Id: Icb7dd17bbf7df573a9bb28f3dc56e90e78384f4f\n---\n .../server/wm/ActivityClientController.java   | 39 +++++++++++++++++++\n .../server/wm/WindowOrganizerTests.java       |  6 +++\n 2 files changed, 45 insertions(+)\n\ndiff --git a/services/core/java/com/android/server/wm/ActivityClientController.java b/services/core/java/com/android/server/wm/ActivityClientController.java\nindex fe4522acc148..c9395daff974 100644\n--- a/services/core/java/com/android/server/wm/ActivityClientController.java\n+++ b/services/core/java/com/android/server/wm/ActivityClientController.java\n@@ -99,6 +99,7 @@ import android.view.RemoteAnimationDefinition;\n import android.window.SizeConfigurationBuckets;\n import android.window.TransitionInfo;\n \n+import com.android.internal.annotations.VisibleForTesting;\n import com.android.internal.app.AssistUtils;\n import com.android.internal.policy.IKeyguardDismissCallback;\n import com.android.internal.protolog.common.ProtoLog;\n@@ -108,6 +109,9 @@ import com.android.server.pm.KnownPackages;\n import com.android.server.pm.pkg.AndroidPackage;\n import com.android.server.uri.GrantUri;\n import com.android.server.uri.NeededUriGrants;\n+import com.android.server.utils.quota.Categorizer;\n+import com.android.server.utils.quota.Category;\n+import com.android.server.utils.quota.CountQuotaTracker;\n import com.android.server.vr.VrManagerInternal;\n \n /**\n@@ -123,6 +127,13 @@ class ActivityClientController extends IActivityClientController.Stub {\n     private final ActivityTaskSupervisor mTaskSupervisor;\n     private final Context mContext;\n \n+    // Prevent malicious app abusing the Activity#setPictureInPictureParams API\n+    @VisibleForTesting CountQuotaTracker mSetPipAspectRatioQuotaTracker;\n+    // Limit to 60 times / minute\n+    private static final int SET_PIP_ASPECT_RATIO_LIMIT = 60;\n+    // The timeWindowMs here can not be smaller than QuotaTracker#MIN_WINDOW_SIZE_MS\n+    private static final long SET_PIP_ASPECT_RATIO_TIME_WINDOW_MS = 60_000;\n+\n     /** Wrapper around VoiceInteractionServiceManager. */\n     private AssistUtils mAssistUtils;\n \n@@ -946,6 +957,7 @@ class ActivityClientController extends IActivityClientController.Stub {\n     public boolean enterPictureInPictureMode(IBinder token, final PictureInPictureParams params) {\n         final long origId = Binder.clearCallingIdentity();\n         try {\n+            ensureSetPipAspectRatioQuotaTracker();\n             synchronized (mGlobalLock) {\n                 final ActivityRecord r = ensureValidPictureInPictureActivityParams(\n                         \"enterPictureInPictureMode\", token, params);\n@@ -960,6 +972,7 @@ class ActivityClientController extends IActivityClientController.Stub {\n     public void setPictureInPictureParams(IBinder token, final PictureInPictureParams params) {\n         final long origId = Binder.clearCallingIdentity();\n         try {\n+            ensureSetPipAspectRatioQuotaTracker();\n             synchronized (mGlobalLock) {\n                 final ActivityRecord r = ensureValidPictureInPictureActivityParams(\n                         \"setPictureInPictureParams\", token, params);\n@@ -1011,6 +1024,19 @@ class ActivityClientController extends IActivityClientController.Stub {\n         }\n     }\n \n+    /**\n+     * Initialize the {@link #mSetPipAspectRatioQuotaTracker} if applicable, which should happen\n+     * out of {@link #mGlobalLock} to avoid deadlock (AM lock is used in QuotaTrack ctor).\n+     */\n+    private void ensureSetPipAspectRatioQuotaTracker() {\n+        if (mSetPipAspectRatioQuotaTracker == null) {\n+            mSetPipAspectRatioQuotaTracker = new CountQuotaTracker(mContext,\n+                    Categorizer.SINGLE_CATEGORIZER);\n+            mSetPipAspectRatioQuotaTracker.setCountLimit(Category.SINGLE_CATEGORY,\n+                    SET_PIP_ASPECT_RATIO_LIMIT, SET_PIP_ASPECT_RATIO_TIME_WINDOW_MS);\n+        }\n+    }\n+\n     /**\n      * Checks the state of the system and the activity associated with the given {@param token} to\n      * verify that picture-in-picture is supported for that activity.\n@@ -1035,6 +1061,19 @@ class ActivityClientController extends IActivityClientController.Stub {\n                     + \": Current activity does not support picture-in-picture.\");\n         }\n \n+        // Rate limit how frequent an app can request aspect ratio change via\n+        // Activity#setPictureInPictureParams\n+        final int userId = UserHandle.getCallingUserId();\n+        if (r.pictureInPictureArgs.hasSetAspectRatio()\n+                && params.hasSetAspectRatio()\n+                && !r.pictureInPictureArgs.getAspectRatio().equals(\n+                params.getAspectRatio())\n+                && !mSetPipAspectRatioQuotaTracker.noteEvent(\n+                userId, r.packageName, \"setPipAspectRatio\")) {\n+            throw new IllegalStateException(caller\n+                    + \": Too many PiP aspect ratio change requests from \" + r.packageName);\n+        }\n+\n         final float minAspectRatio = mContext.getResources().getFloat(\n                 com.android.internal.R.dimen.config_pictureInPictureMinAspectRatio);\n         final float maxAspectRatio = mContext.getResources().getFloat(\ndiff --git a/services/tests/wmtests/src/com/android/server/wm/WindowOrganizerTests.java b/services/tests/wmtests/src/com/android/server/wm/WindowOrganizerTests.java\nindex 43b424fab907..fb854c5bda68 100644\n--- a/services/tests/wmtests/src/com/android/server/wm/WindowOrganizerTests.java\n+++ b/services/tests/wmtests/src/com/android/server/wm/WindowOrganizerTests.java\n@@ -1235,6 +1235,12 @@ public class WindowOrganizerTests extends WindowTestsBase {\n         assertNotNull(o.mInfo);\n         assertNotNull(o.mInfo.pictureInPictureParams);\n \n+        // Bypass the quota check, which causes NPE in current test setup.\n+        if (mWm.mAtmService.mActivityClientController.mSetPipAspectRatioQuotaTracker != null) {\n+            mWm.mAtmService.mActivityClientController.mSetPipAspectRatioQuotaTracker\n+                    .setEnabled(false);\n+        }\n+\n         final PictureInPictureParams p2 = new PictureInPictureParams.Builder()\n                 .setAspectRatio(new Rational(3, 4)).build();\n         mWm.mAtmService.mActivityClientController.setPictureInPictureParams(record.token, p2);\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 1623,
                        "general": {
                            "word_based": 666,
                            "char_based": 1733
                        },
                        "gemini": 1934
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 2,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "add219bcb2aa3654ed8614f150b664be1161812d",
                            "repo_path": "android_repos/base",
                            "result": "failure",
                            "downstream_patch_content": "commit add219bcb2aa3654ed8614f150b664be1161812d\nAuthor: Hongwei Wang <hwwang@google.com>\nDate:   Tue Aug 1 16:00:31 2023 -0700\n\n    Rate limiting PiP aspect ratio change request\n    \n    Using CountQuotaTrack to limit how frequent an app can request aspect\n    ratio change via PictureInPictureParams, which could result flood of PiP\n    resizing requests and freeze the PiP window.\n    \n    Note that CountQuotaTrack is initialized out of the WM lock to avoid\n    dead lock with the AM one.\n    \n    Bug: 283103220\n    Test: Manually, using the POC app\n    Test: Manually, switching YT PiP video functions at a regular rate\n    Test: atest WindowOrganizerTests ActivityThreadTest\n    Merged-In: Icb7dd17bbf7df573a9bb28f3dc56e90e78384f4f\n    Change-Id: Icb7dd17bbf7df573a9bb28f3dc56e90e78384f4f\n\ndiff --git a/services/core/java/com/android/server/wm/ActivityClientController.java b/services/core/java/com/android/server/wm/ActivityClientController.java\nindex 3a4faf73bfe1..1cad6b5db365 100644\n--- a/services/core/java/com/android/server/wm/ActivityClientController.java\n+++ b/services/core/java/com/android/server/wm/ActivityClientController.java\n@@ -64,17 +64,22 @@ import android.os.PersistableBundle;\n import android.os.RemoteException;\n import android.os.SystemClock;\n import android.os.Trace;\n+import android.os.UserHandle;\n import android.service.voice.VoiceInteractionManagerInternal;\n import android.util.Slog;\n import android.view.RemoteAnimationDefinition;\n import android.window.SizeConfigurationBuckets;\n \n+import com.android.internal.annotations.VisibleForTesting;\n import com.android.internal.app.AssistUtils;\n import com.android.internal.policy.IKeyguardDismissCallback;\n import com.android.internal.protolog.common.ProtoLog;\n import com.android.server.LocalServices;\n import com.android.server.Watchdog;\n import com.android.server.uri.NeededUriGrants;\n+import com.android.server.utils.quota.Categorizer;\n+import com.android.server.utils.quota.Category;\n+import com.android.server.utils.quota.CountQuotaTracker;\n import com.android.server.vr.VrManagerInternal;\n \n /**\n@@ -90,6 +95,13 @@ class ActivityClientController extends IActivityClientController.Stub {\n     private final ActivityTaskSupervisor mTaskSupervisor;\n     private final Context mContext;\n \n+    // Prevent malicious app abusing the Activity#setPictureInPictureParams API\n+    @VisibleForTesting CountQuotaTracker mSetPipAspectRatioQuotaTracker;\n+    // Limit to 60 times / minute\n+    private static final int SET_PIP_ASPECT_RATIO_LIMIT = 60;\n+    // The timeWindowMs here can not be smaller than QuotaTracker#MIN_WINDOW_SIZE_MS\n+    private static final long SET_PIP_ASPECT_RATIO_TIME_WINDOW_MS = 60_000;\n+\n     /** Wrapper around VoiceInteractionServiceManager. */\n     private AssistUtils mAssistUtils;\n \n@@ -661,6 +673,7 @@ class ActivityClientController extends IActivityClientController.Stub {\n     public boolean enterPictureInPictureMode(IBinder token, final PictureInPictureParams params) {\n         final long origId = Binder.clearCallingIdentity();\n         try {\n+            ensureSetPipAspectRatioQuotaTracker();\n             synchronized (mGlobalLock) {\n                 final ActivityRecord r = ensureValidPictureInPictureActivityParams(\n                         \"enterPictureInPictureMode\", token, params);\n@@ -675,6 +688,7 @@ class ActivityClientController extends IActivityClientController.Stub {\n     public void setPictureInPictureParams(IBinder token, final PictureInPictureParams params) {\n         final long origId = Binder.clearCallingIdentity();\n         try {\n+            ensureSetPipAspectRatioQuotaTracker();\n             synchronized (mGlobalLock) {\n                 final ActivityRecord r = ensureValidPictureInPictureActivityParams(\n                         \"setPictureInPictureParams\", token, params);\n@@ -708,6 +722,19 @@ class ActivityClientController extends IActivityClientController.Stub {\n         Binder.restoreCallingIdentity(origId);\n     }\n \n+    /**\n+     * Initialize the {@link #mSetPipAspectRatioQuotaTracker} if applicable, which should happen\n+     * out of {@link #mGlobalLock} to avoid deadlock (AM lock is used in QuotaTrack ctor).\n+     */\n+    private void ensureSetPipAspectRatioQuotaTracker() {\n+        if (mSetPipAspectRatioQuotaTracker == null) {\n+            mSetPipAspectRatioQuotaTracker = new CountQuotaTracker(mContext,\n+                    Categorizer.SINGLE_CATEGORIZER);\n+            mSetPipAspectRatioQuotaTracker.setCountLimit(Category.SINGLE_CATEGORY,\n+                    SET_PIP_ASPECT_RATIO_LIMIT, SET_PIP_ASPECT_RATIO_TIME_WINDOW_MS);\n+        }\n+    }\n+\n     /**\n      * Checks the state of the system and the activity associated with the given {@param token} to\n      * verify that picture-in-picture is supported for that activity.\n@@ -732,6 +759,19 @@ class ActivityClientController extends IActivityClientController.Stub {\n                     + \": Current activity does not support picture-in-picture.\");\n         }\n \n+        // Rate limit how frequent an app can request aspect ratio change via\n+        // Activity#setPictureInPictureParams\n+        final int userId = UserHandle.getCallingUserId();\n+        if (r.pictureInPictureArgs.hasSetAspectRatio()\n+                && params.hasSetAspectRatio()\n+                && !r.pictureInPictureArgs.getAspectRatioRational().equals(\n+                params.getAspectRatioRational())\n+                && !mSetPipAspectRatioQuotaTracker.noteEvent(\n+                userId, r.packageName, \"setPipAspectRatio\")) {\n+            throw new IllegalStateException(caller\n+                    + \": Too many PiP aspect ratio change requests from \" + r.packageName);\n+        }\n+\n         if (params.hasSetAspectRatio()\n                 && !mService.mWindowManager.isValidPictureInPictureAspectRatio(\n                 r.mDisplayContent, params.getAspectRatio())) {\ndiff --git a/services/tests/wmtests/src/com/android/server/wm/WindowOrganizerTests.java b/services/tests/wmtests/src/com/android/server/wm/WindowOrganizerTests.java\nindex ab496cf34acc..cb1a69339044 100644\n--- a/services/tests/wmtests/src/com/android/server/wm/WindowOrganizerTests.java\n+++ b/services/tests/wmtests/src/com/android/server/wm/WindowOrganizerTests.java\n@@ -851,6 +851,12 @@ public class WindowOrganizerTests extends WindowTestsBase {\n         assertNotNull(o.mInfo);\n         assertNotNull(o.mInfo.pictureInPictureParams);\n \n+        // Bypass the quota check, which causes NPE in current test setup.\n+        if (mWm.mAtmService.mActivityClientController.mSetPipAspectRatioQuotaTracker != null) {\n+            mWm.mAtmService.mActivityClientController.mSetPipAspectRatioQuotaTracker\n+                    .setEnabled(false);\n+        }\n+\n         final PictureInPictureParams p2 = new PictureInPictureParams.Builder()\n                 .setAspectRatio(new Rational(3, 4)).build();\n         mWm.mAtmService.mActivityClientController.setPictureInPictureParams(record.token, p2);\n",
                            "downstream_patch_tokens": {
                                "openai": 1606,
                                "general": {
                                    "word_based": 646,
                                    "char_based": 1739
                                },
                                "gemini": 1921
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "services/core/java/com/android/server/wm/ActivityClientController.java",
                                    "total_hunks": 7,
                                    "failed_hunks": [
                                        7
                                    ],
                                    "inline_merge_conflicts": [],
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    },
                                    "rej_file_content": "```diff\n--- services/core/java/com/android/server/wm/ActivityClientController.java\n+++ services/core/java/com/android/server/wm/ActivityClientController.java\n@@ -1061,6 +1087,19 @@ class ActivityClientController extends IActivityClientController.Stub {\n                     + \": Current activity does not support picture-in-picture.\");\n         }\n \n+        // Rate limit how frequent an app can request aspect ratio change via\n+        // Activity#setPictureInPictureParams\n+        final int userId = UserHandle.getCallingUserId();\n+        if (r.pictureInPictureArgs.hasSetAspectRatio()\n+                && params.hasSetAspectRatio()\n+                && !r.pictureInPictureArgs.getAspectRatio().equals(\n+                params.getAspectRatio())\n+                && !mSetPipAspectRatioQuotaTracker.noteEvent(\n+                userId, r.packageName, \"setPipAspectRatio\")) {\n+            throw new IllegalStateException(caller\n+                    + \": Too many PiP aspect ratio change requests from \" + r.packageName);\n+        }\n+\n         final float minAspectRatio = mContext.getResources().getFloat(\n                 com.android.internal.R.dimen.config_pictureInPictureMinAspectRatio);\n         final float maxAspectRatio = mContext.getResources().getFloat(\n```",
                                    "rej_file_tokens": {
                                        "openai": 248,
                                        "general": {
                                            "word_based": 104,
                                            "char_based": 313
                                        },
                                        "gemini": 295
                                    },
                                    "patch_apply_output": "patching file services/core/java/com/android/server/wm/ActivityClientController.java\nHunk #1 succeeded at 69 with fuzz 2 (offset -30 lines).\nHunk #2 succeeded at 76 with fuzz 2 (offset -33 lines).\nHunk #3 succeeded at 94 (offset -33 lines).\nHunk #4 succeeded at 672 (offset -285 lines).\nHunk #5 succeeded at 687 (offset -285 lines).\nHunk #6 succeeded at 721 with fuzz 1 (offset -303 lines).\nHunk #7 FAILED at 1061.\n1 out of 7 hunks FAILED -- saving rejects to file services/core/java/com/android/server/wm/ActivityClientController.java.rej",
                                    "inline_merge_output": "patching file services/core/java/com/android/server/wm/ActivityClientController.java\nHunk #1 already applied at 102.\nHunk #2 already applied at 112-114.\nHunk #3 merged at 137-143.\nHunk #4 already applied at 967.\nHunk #5 already applied at 982.\nHunk #7 merged at 1097-1109.",
                                    "upstream_file_tokens": {
                                        "openai": 14685,
                                        "general": {
                                            "word_based": 5921,
                                            "char_based": 19126
                                        },
                                        "gemini": 17232
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2020 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.wm;\n\nimport static android.Manifest.permission.CONTROL_REMOTE_APP_TRANSITION_ANIMATIONS;\nimport static android.app.ActivityTaskManager.INVALID_TASK_ID;\nimport static android.app.WindowConfiguration.WINDOWING_MODE_FREEFORM;\nimport static android.app.WindowConfiguration.WINDOWING_MODE_FULLSCREEN;\nimport static android.app.WindowConfiguration.WINDOWING_MODE_UNDEFINED;\nimport static android.os.Trace.TRACE_TAG_WINDOW_MANAGER;\nimport static android.service.voice.VoiceInteractionSession.SHOW_SOURCE_APPLICATION;\nimport static android.view.Display.DEFAULT_DISPLAY;\nimport static android.view.Display.INVALID_DISPLAY;\n\nimport static com.android.internal.protolog.ProtoLogGroup.WM_DEBUG_CONFIGURATION;\nimport static com.android.internal.protolog.ProtoLogGroup.WM_DEBUG_IMMERSIVE;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.DEBUG_ALL;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.DEBUG_SWITCH;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.TAG_ATM;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.TAG_WITH_CLASS_NAME;\nimport static com.android.server.wm.ActivityTaskManagerService.RELAUNCH_REASON_NONE;\nimport static com.android.server.wm.ActivityTaskManagerService.TAG_SWITCH;\nimport static com.android.server.wm.ActivityTaskManagerService.enforceNotIsolatedCaller;\nimport static com.android.server.wm.Task.ActivityState.DESTROYED;\nimport static com.android.server.wm.Task.ActivityState.DESTROYING;\n\nimport android.annotation.NonNull;\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.ActivityTaskManager;\nimport android.app.IActivityClientController;\nimport android.app.IRequestFinishCallback;\nimport android.app.PictureInPictureParams;\nimport android.app.PictureInPictureUiState;\nimport android.app.servertransaction.ClientTransaction;\nimport android.app.servertransaction.EnterPipRequestedItem;\nimport android.app.servertransaction.PipStateTransactionItem;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.ResolveInfo;\nimport android.content.res.Configuration;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.IBinder;\nimport android.os.Parcel;\nimport android.os.PersistableBundle;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.Trace;\nimport android.service.voice.VoiceInteractionManagerInternal;\nimport android.util.Slog;\nimport android.view.RemoteAnimationDefinition;\nimport android.window.SizeConfigurationBuckets;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.app.AssistUtils;\nimport com.android.internal.policy.IKeyguardDismissCallback;\nimport com.android.internal.protolog.common.ProtoLog;\nimport com.android.server.LocalServices;\nimport com.android.server.Watchdog;\nimport com.android.server.uri.NeededUriGrants;\nimport com.android.server.utils.quota.Categorizer;\nimport com.android.server.utils.quota.Category;\nimport com.android.server.utils.quota.CountQuotaTracker;\nimport com.android.server.vr.VrManagerInternal;\n\n/**\n * Server side implementation for the client activity to interact with system.\n *\n * @see android.app.ActivityClient\n */\nclass ActivityClientController extends IActivityClientController.Stub {\n    private static final String TAG = TAG_WITH_CLASS_NAME ? \"ActivityClientController\" : TAG_ATM;\n\n    private final ActivityTaskManagerService mService;\n    private final WindowManagerGlobalLock mGlobalLock;\n    private final ActivityTaskSupervisor mTaskSupervisor;\n    private final Context mContext;\n\n    // Prevent malicious app abusing the Activity#setPictureInPictureParams API\n    @VisibleForTesting CountQuotaTracker mSetPipAspectRatioQuotaTracker;\n    // Limit to 60 times / minute\n    private static final int SET_PIP_ASPECT_RATIO_LIMIT = 60;\n    // The timeWindowMs here can not be smaller than QuotaTracker#MIN_WINDOW_SIZE_MS\n    private static final long SET_PIP_ASPECT_RATIO_TIME_WINDOW_MS = 60_000;\n\n    /** Wrapper around VoiceInteractionServiceManager. */\n    private AssistUtils mAssistUtils;\n\n    ActivityClientController(ActivityTaskManagerService service) {\n        mService = service;\n        mGlobalLock = service.mGlobalLock;\n        mTaskSupervisor = service.mTaskSupervisor;\n        mContext = service.mContext;\n    }\n\n    void onSystemReady() {\n        mAssistUtils = new AssistUtils(mContext);\n    }\n\n    @Override\n    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)\n            throws RemoteException {\n        try {\n            return super.onTransact(code, data, reply, flags);\n        } catch (RuntimeException e) {\n            throw ActivityTaskManagerService.logAndRethrowRuntimeExceptionOnTransact(\n                    \"ActivityClientController\", e);\n        }\n    }\n\n    @Override\n    public void activityIdle(IBinder token, Configuration config, boolean stopProfiling) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, \"activityIdle\");\n                final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n                if (r == null) {\n                    return;\n                }\n                mTaskSupervisor.activityIdleInternal(r, false /* fromTimeout */,\n                        false /* processPausingActivities */, config);\n                if (stopProfiling && r.hasProcess()) {\n                    r.app.clearProfilerIfNeeded();\n                }\n            }\n        } finally {\n            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public void activityResumed(IBinder token, boolean handleSplashScreenExit) {\n        final long origId = Binder.clearCallingIdentity();\n        synchronized (mGlobalLock) {\n            ActivityRecord.activityResumedLocked(token, handleSplashScreenExit);\n        }\n        Binder.restoreCallingIdentity(origId);\n    }\n\n    @Override\n    public void activityTopResumedStateLost() {\n        final long origId = Binder.clearCallingIdentity();\n        synchronized (mGlobalLock) {\n            mTaskSupervisor.handleTopResumedStateReleased(false /* timeout */);\n        }\n        Binder.restoreCallingIdentity(origId);\n    }\n\n    @Override\n    public void activityPaused(IBinder token) {\n        final long origId = Binder.clearCallingIdentity();\n        synchronized (mGlobalLock) {\n            Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, \"activityPaused\");\n            final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n            if (r != null) {\n                r.activityPaused(false);\n            }\n            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);\n        }\n        Binder.restoreCallingIdentity(origId);\n    }\n\n    @Override\n    public void activityStopped(IBinder token, Bundle icicle, PersistableBundle persistentState,\n            CharSequence description) {\n        if (DEBUG_ALL) Slog.v(TAG, \"Activity stopped: token=\" + token);\n\n        // Refuse possible leaked file descriptors.\n        if (icicle != null && icicle.hasFileDescriptors()) {\n            throw new IllegalArgumentException(\"File descriptors passed in Bundle\");\n        }\n\n        final long origId = Binder.clearCallingIdentity();\n\n        String restartingName = null;\n        int restartingUid = 0;\n        final ActivityRecord r;\n        synchronized (mGlobalLock) {\n            Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, \"activityStopped\");\n            r = ActivityRecord.isInRootTaskLocked(token);\n            if (r != null) {\n                if (r.attachedToProcess() && r.isState(Task.ActivityState.RESTARTING_PROCESS)) {\n                    // The activity was requested to restart from\n                    // {@link #restartActivityProcessIfVisible}.\n                    restartingName = r.app.mName;\n                    restartingUid = r.app.mUid;\n                }\n                r.activityStopped(icicle, persistentState, description);\n            }\n            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);\n        }\n\n        if (restartingName != null) {\n            // In order to let the foreground activity can be restarted with its saved state from\n            // {@link android.app.Activity#onSaveInstanceState}, the kill operation is postponed\n            // until the activity reports stopped with the state. And the activity record will be\n            // kept because the record state is restarting, then the activity will be restarted\n            // immediately if it is still the top one.\n            mTaskSupervisor.removeRestartTimeouts(r);\n            mService.mAmInternal.killProcess(restartingName, restartingUid,\n                    \"restartActivityProcess\");\n        }\n        mService.mAmInternal.trimApplications();\n\n        Binder.restoreCallingIdentity(origId);\n    }\n\n    @Override\n    public void activityDestroyed(IBinder token) {\n        if (DEBUG_SWITCH) Slog.v(TAG_SWITCH, \"ACTIVITY DESTROYED: \" + token);\n        final long origId = Binder.clearCallingIdentity();\n        synchronized (mGlobalLock) {\n            Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, \"activityDestroyed\");\n            try {\n                final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n                if (r != null) {\n                    r.destroyed(\"activityDestroyed\");\n                }\n            } finally {\n                Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public void activityRelaunched(IBinder token) {\n        final long origId = Binder.clearCallingIdentity();\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n            if (r != null) {\n                r.finishRelaunching();\n            }\n        }\n        Binder.restoreCallingIdentity(origId);\n    }\n\n    @Override\n    public void reportSizeConfigurations(IBinder token,\n            SizeConfigurationBuckets sizeConfigurations) {\n        ProtoLog.v(WM_DEBUG_CONFIGURATION, \"Report configuration: %s %s\",\n                token, sizeConfigurations);\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n            if (r != null) {\n                r.setSizeConfigurations(sizeConfigurations);\n            }\n        }\n    }\n\n    /**\n     * Attempts to move a task backwards in z-order (the order of activities within the task is\n     * unchanged).\n     *\n     * There are several possible results of this call:\n     * - if the task is locked, then we will show the lock toast.\n     * - if there is a task behind the provided task, then that task is made visible and resumed as\n     * this task is moved to the back.\n     * - otherwise, if there are no other tasks in the root task:\n     * - if this task is in the pinned mode, then we remove the task completely, which will\n     * have the effect of moving the task to the top or bottom of the fullscreen root task\n     * (depending on whether it is visible).\n     * - otherwise, we simply return home and hide this task.\n     *\n     * @param token   A reference to the activity we wish to move.\n     * @param nonRoot If false then this only works if the activity is the root\n     *                of a task; if true it will work for any activity in a task.\n     * @return Returns true if the move completed, false if not.\n     */\n    @Override\n    public boolean moveActivityTaskToBack(IBinder token, boolean nonRoot) {\n        enforceNotIsolatedCaller(\"moveActivityTaskToBack\");\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final int taskId = ActivityRecord.getTaskForActivityLocked(token, !nonRoot);\n                final Task task = mService.mRootWindowContainer.anyTaskForId(taskId);\n                if (task != null) {\n                    return ActivityRecord.getRootTask(token).moveTaskToBack(task);\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n        return false;\n    }\n\n    @Override\n    public boolean shouldUpRecreateTask(IBinder token, String destAffinity) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord srec = ActivityRecord.forTokenLocked(token);\n            if (srec != null) {\n                return srec.getRootTask().shouldUpRecreateTaskLocked(srec, destAffinity);\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean navigateUpTo(IBinder token, Intent destIntent, int resultCode,\n            Intent resultData) {\n        final ActivityRecord r;\n        synchronized (mGlobalLock) {\n            r = ActivityRecord.isInRootTaskLocked(token);\n            if (r == null) {\n                return false;\n            }\n        }\n\n        // Carefully collect grants without holding lock.\n        final NeededUriGrants destGrants = mService.collectGrants(destIntent, r);\n        final NeededUriGrants resultGrants = mService.collectGrants(resultData, r.resultTo);\n\n        synchronized (mGlobalLock) {\n            return r.getRootTask().navigateUpTo(\n                    r, destIntent, destGrants, resultCode, resultData, resultGrants);\n        }\n    }\n\n    @Override\n    public boolean releaseActivityInstance(IBinder token) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r == null || !r.isDestroyable()) {\n                    return false;\n                }\n                r.destroyImmediately(\"app-req\");\n                return r.isState(DESTROYING, DESTROYED);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    /**\n     * This is the internal entry point for handling Activity.finish().\n     *\n     * @param token      The Binder token referencing the Activity we want to finish.\n     * @param resultCode Result code, if any, from this Activity.\n     * @param resultData Result data (Intent), if any, from this Activity.\n     * @param finishTask Whether to finish the task associated with this Activity.\n     * @return Returns true if the activity successfully finished, or false if it is still running.\n     */\n    @Override\n    public boolean finishActivity(IBinder token, int resultCode, Intent resultData,\n            int finishTask) {\n        // Refuse possible leaked file descriptors.\n        if (resultData != null && resultData.hasFileDescriptors()) {\n            throw new IllegalArgumentException(\"File descriptors passed in Intent\");\n        }\n\n        final ActivityRecord r;\n        synchronized (mGlobalLock) {\n            r = ActivityRecord.isInRootTaskLocked(token);\n            if (r == null) {\n                return true;\n            }\n        }\n\n        // Carefully collect grants without holding lock.\n        final NeededUriGrants resultGrants = mService.collectGrants(resultData, r.resultTo);\n\n        synchronized (mGlobalLock) {\n            // Check again in case activity was removed when collecting grants.\n            if (!r.isInHistory()) {\n                return true;\n            }\n\n            // Keep track of the root activity of the task before we finish it.\n            final Task tr = r.getTask();\n            final ActivityRecord rootR = tr.getRootActivity();\n            if (rootR == null) {\n                Slog.w(TAG, \"Finishing task with all activities already finished\");\n            }\n            // Do not allow task to finish if last task in lockTask mode. Launchable priv-apps can\n            // finish.\n            if (mService.getLockTaskController().activityBlockedFromFinish(r)) {\n                return false;\n            }\n\n            // TODO: There is a dup. of this block of code in ActivityStack.navigateUpToLocked\n            // We should consolidate.\n            if (mService.mController != null) {\n                // Find the first activity that is not finishing.\n                final ActivityRecord next =\n                        r.getRootTask().topRunningActivity(token, INVALID_TASK_ID);\n                if (next != null) {\n                    // ask watcher if this is allowed\n                    boolean resumeOK = true;\n                    try {\n                        resumeOK = mService.mController.activityResuming(next.packageName);\n                    } catch (RemoteException e) {\n                        mService.mController = null;\n                        Watchdog.getInstance().setActivityController(null);\n                    }\n\n                    if (!resumeOK) {\n                        Slog.i(TAG, \"Not finishing activity because controller resumed\");\n                        return false;\n                    }\n                }\n            }\n\n            // Note down that the process has finished an activity and is in background activity\n            // starts grace period.\n            if (r.app != null) {\n                r.app.setLastActivityFinishTimeIfNeeded(SystemClock.uptimeMillis());\n            }\n\n            final long origId = Binder.clearCallingIdentity();\n            Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, \"finishActivity\");\n            try {\n                final boolean res;\n                final boolean finishWithRootActivity =\n                        finishTask == Activity.FINISH_TASK_WITH_ROOT_ACTIVITY;\n                if (finishTask == Activity.FINISH_TASK_WITH_ACTIVITY\n                        || (finishWithRootActivity && r == rootR)) {\n                    // If requested, remove the task that is associated to this activity only if it\n                    // was the root activity in the task. The result code and data is ignored\n                    // because we don't support returning them across task boundaries. Also, to\n                    // keep backwards compatibility we remove the task from recents when finishing\n                    // task with root activity.\n                    mTaskSupervisor.removeTask(tr, false /*killProcess*/,\n                            finishWithRootActivity, \"finish-activity\");\n                    res = true;\n                    // Explicitly dismissing the activity so reset its relaunch flag.\n                    r.mRelaunchReason = RELAUNCH_REASON_NONE;\n                } else {\n                    r.finishIfPossible(resultCode, resultData, resultGrants,\n                            \"app-request\", true /* oomAdj */);\n                    res = r.finishing;\n                    if (!res) {\n                        Slog.i(TAG, \"Failed to finish by app-request\");\n                    }\n                }\n                return res;\n            } finally {\n                Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public boolean finishActivityAffinity(IBinder token) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r == null) {\n                    return false;\n                }\n\n                // Do not allow task to finish if last task in lockTask mode. Launchable priv-apps\n                // can finish.\n                if (mService.getLockTaskController().activityBlockedFromFinish(r)) {\n                    return false;\n                }\n\n                r.getTask().forAllActivities(activity -> r.finishIfSameAffinity(activity),\n                        r /* boundary */, true /* includeBoundary */,\n                        true /* traverseTopToBottom */);\n                return true;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public void finishSubActivity(IBinder token, String resultWho, int requestCode) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r == null) return;\n\n                // TODO: This should probably only loop over the task since you need to be in the\n                // same task to return results.\n                r.getRootTask().forAllActivities(activity -> {\n                    activity.finishIfSubActivity(r /* parent */, resultWho, requestCode);\n                }, true /* traverseTopToBottom */);\n\n                mService.updateOomAdj();\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public boolean isTopOfTask(IBinder token) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n            return r != null && r.getTask().getTopNonFinishingActivity() == r;\n        }\n    }\n\n    @Override\n    public boolean willActivityBeVisible(IBinder token) {\n        synchronized (mGlobalLock) {\n            final Task rootTask = ActivityRecord.getRootTask(token);\n            return rootTask != null && rootTask.willActivityBeVisible(token);\n        }\n    }\n\n    @Override\n    public int getDisplayId(IBinder activityToken) {\n        synchronized (mGlobalLock) {\n            final Task rootTask = ActivityRecord.getRootTask(activityToken);\n            if (rootTask != null) {\n                final int displayId = rootTask.getDisplayId();\n                return displayId != INVALID_DISPLAY ? displayId : DEFAULT_DISPLAY;\n            }\n            return DEFAULT_DISPLAY;\n        }\n    }\n\n    @Override\n    public int getTaskForActivity(IBinder token, boolean onlyRoot) {\n        synchronized (mGlobalLock) {\n            return ActivityRecord.getTaskForActivityLocked(token, onlyRoot);\n        }\n    }\n\n    @Override\n    public ComponentName getCallingActivity(IBinder token) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = getCallingRecord(token);\n            return r != null ? r.intent.getComponent() : null;\n        }\n    }\n\n    @Override\n    public String getCallingPackage(IBinder token) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = getCallingRecord(token);\n            return r != null ? r.info.packageName : null;\n        }\n    }\n\n    private static ActivityRecord getCallingRecord(IBinder token) {\n        final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n        return r != null ? r.resultTo : null;\n    }\n\n    @Override\n    public int getLaunchedFromUid(IBinder token) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n            return r != null ? r.launchedFromUid : android.os.Process.INVALID_UID;\n        }\n    }\n\n    @Override\n    public String getLaunchedFromPackage(IBinder token) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n            return r != null ? r.launchedFromPackage : null;\n        }\n    }\n\n    @Override\n    public void setRequestedOrientation(IBinder token, int requestedOrientation) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r != null) {\n                    r.setRequestedOrientation(requestedOrientation);\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public int getRequestedOrientation(IBinder token) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n            return r != null\n                    ? r.getRequestedOrientation() : ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;\n        }\n    }\n\n    @Override\n    public boolean convertFromTranslucent(IBinder token) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                return r != null && r.setOccludesParent(true);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public boolean convertToTranslucent(IBinder token, Bundle options) {\n        final SafeActivityOptions safeOptions = SafeActivityOptions.fromBundle(options);\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r == null) {\n                    return false;\n                }\n                final ActivityRecord under = r.getTask().getActivityBelow(r);\n                if (under != null) {\n                    under.returningOptions = safeOptions != null ? safeOptions.getOptions(r) : null;\n                }\n                return r.setOccludesParent(false);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public boolean isImmersive(IBinder token) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n            if (r == null) {\n                throw new IllegalArgumentException();\n            }\n            return r.immersive;\n        }\n    }\n\n    @Override\n    public void setImmersive(IBinder token, boolean immersive) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n            if (r == null) {\n                throw new IllegalArgumentException();\n            }\n            r.immersive = immersive;\n\n            // Update associated state if we're frontmost.\n            if (r.isFocusedActivityOnDisplay()) {\n                ProtoLog.d(WM_DEBUG_IMMERSIVE, \"Frontmost changed immersion: %s\", r);\n                mService.applyUpdateLockStateLocked(r);\n            }\n        }\n    }\n\n    @Override\n    public boolean enterPictureInPictureMode(IBinder token, final PictureInPictureParams params) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            ensureSetPipAspectRatioQuotaTracker();\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ensureValidPictureInPictureActivityParams(\n                        \"enterPictureInPictureMode\", token, params);\n                return mService.enterPictureInPictureMode(r, params);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public void setPictureInPictureParams(IBinder token, final PictureInPictureParams params) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            ensureSetPipAspectRatioQuotaTracker();\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ensureValidPictureInPictureActivityParams(\n                        \"setPictureInPictureParams\", token, params);\n\n                // Only update the saved args from the args that are set.\n                r.setPictureInPictureParams(params);\n                if (r.inPinnedWindowingMode()) {\n                    // If the activity is already in picture-in-picture, update the pinned task now\n                    // if it is not already expanding to fullscreen. Otherwise, the arguments will\n                    // be used the next time the activity enters PiP.\n                    final Task rootTask = r.getRootTask();\n                    rootTask.setPictureInPictureAspectRatio(\n                            r.pictureInPictureArgs.getAspectRatio());\n                    rootTask.setPictureInPictureActions(r.pictureInPictureArgs.getActions());\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    /**\n     * Splash screen view is attached to activity.\n     */\n    @Override\n    public void splashScreenAttached(IBinder token) {\n        final long origId = Binder.clearCallingIdentity();\n        synchronized (mGlobalLock) {\n            ActivityRecord.splashScreenAttachedLocked(token);\n        }\n        Binder.restoreCallingIdentity(origId);\n    }\n\n    /**\n     * Initialize the {@link #mSetPipAspectRatioQuotaTracker} if applicable, which should happen\n     * out of {@link #mGlobalLock} to avoid deadlock (AM lock is used in QuotaTrack ctor).\n     */\n    private void ensureSetPipAspectRatioQuotaTracker() {\n        if (mSetPipAspectRatioQuotaTracker == null) {\n            mSetPipAspectRatioQuotaTracker = new CountQuotaTracker(mContext,\n                    Categorizer.SINGLE_CATEGORIZER);\n            mSetPipAspectRatioQuotaTracker.setCountLimit(Category.SINGLE_CATEGORY,\n                    SET_PIP_ASPECT_RATIO_LIMIT, SET_PIP_ASPECT_RATIO_TIME_WINDOW_MS);\n        }\n    }\n\n    /**\n     * Checks the state of the system and the activity associated with the given {@param token} to\n     * verify that picture-in-picture is supported for that activity.\n     *\n     * @return the activity record for the given {@param token} if all the checks pass.\n     */\n    private ActivityRecord ensureValidPictureInPictureActivityParams(String caller,\n            IBinder token, PictureInPictureParams params) {\n        if (!mService.mSupportsPictureInPicture) {\n            throw new IllegalStateException(caller\n                    + \": Device doesn't support picture-in-picture mode.\");\n        }\n\n        final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n        if (r == null) {\n            throw new IllegalStateException(caller\n                    + \": Can't find activity for token=\" + token);\n        }\n\n        if (!r.supportsPictureInPicture()) {\n            throw new IllegalStateException(caller\n                    + \": Current activity does not support picture-in-picture.\");\n        }\n\n        if (params.hasSetAspectRatio()\n                && !mService.mWindowManager.isValidPictureInPictureAspectRatio(\n                r.mDisplayContent, params.getAspectRatio())) {\n            final float minAspectRatio = mContext.getResources().getFloat(\n                    com.android.internal.R.dimen.config_pictureInPictureMinAspectRatio);\n            final float maxAspectRatio = mContext.getResources().getFloat(\n                    com.android.internal.R.dimen.config_pictureInPictureMaxAspectRatio);\n            throw new IllegalArgumentException(String.format(caller\n                            + \": Aspect ratio is too extreme (must be between %f and %f).\",\n                    minAspectRatio, maxAspectRatio));\n        }\n\n        // Truncate the number of actions if necessary.\n        params.truncateActions(ActivityTaskManager.getMaxNumPictureInPictureActions(mContext));\n        return r;\n    }\n\n    /**\n     * Requests that an activity should enter picture-in-picture mode if possible. This method may\n     * be used by the implementation of non-phone form factors.\n     */\n    void requestPictureInPictureMode(@NonNull ActivityRecord r) {\n        if (r.inPinnedWindowingMode()) {\n            throw new IllegalStateException(\"Activity is already in PIP mode\");\n        }\n\n        final boolean canEnterPictureInPicture = r.checkEnterPictureInPictureState(\n                \"requestPictureInPictureMode\", /* beforeStopping */ false);\n        if (!canEnterPictureInPicture) {\n            throw new IllegalStateException(\n                    \"Requested PIP on an activity that doesn't support it\");\n        }\n\n        if (r.pictureInPictureArgs.isAutoEnterEnabled()) {\n            mService.enterPictureInPictureMode(r, r.pictureInPictureArgs);\n            return;\n        }\n\n        try {\n            final ClientTransaction transaction = ClientTransaction.obtain(\n                    r.app.getThread(), r.token);\n            transaction.addCallback(EnterPipRequestedItem.obtain());\n            mService.getLifecycleManager().scheduleTransaction(transaction);\n        } catch (Exception e) {\n            Slog.w(TAG, \"Failed to send enter pip requested item: \"\n                    + r.intent.getComponent(), e);\n        }\n    }\n\n    /**\n     * Alert the client that the Picture-in-Picture state has changed.\n     */\n    void onPictureInPictureStateChanged(@NonNull ActivityRecord r,\n            PictureInPictureUiState pipState) {\n        if (!r.inPinnedWindowingMode()) {\n            throw new IllegalStateException(\"Activity is not in PIP mode\");\n        }\n\n        try {\n            final ClientTransaction transaction = ClientTransaction.obtain(\n                    r.app.getThread(), r.token);\n            transaction.addCallback(PipStateTransactionItem.obtain(pipState));\n            mService.getLifecycleManager().scheduleTransaction(transaction);\n        } catch (Exception e) {\n            Slog.w(TAG, \"Failed to send pip state transaction item: \"\n                    + r.intent.getComponent(), e);\n        }\n    }\n\n    @Override\n    public void toggleFreeformWindowingMode(IBinder token) {\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n                if (r == null) {\n                    throw new IllegalArgumentException(\n                            \"toggleFreeformWindowingMode: No activity record matching token=\"\n                                    + token);\n                }\n\n                final Task rootTask = r.getRootTask();\n                if (rootTask == null) {\n                    throw new IllegalStateException(\"toggleFreeformWindowingMode: the activity \"\n                            + \"doesn't have a root task\");\n                }\n\n                if (!rootTask.inFreeformWindowingMode()\n                        && rootTask.getWindowingMode() != WINDOWING_MODE_FULLSCREEN) {\n                    throw new IllegalStateException(\"toggleFreeformWindowingMode: You can only \"\n                            + \"toggle between fullscreen and freeform.\");\n                }\n\n                if (rootTask.inFreeformWindowingMode()) {\n                    rootTask.setWindowingMode(WINDOWING_MODE_FULLSCREEN);\n                } else if (!r.supportsFreeform()) {\n                    throw new IllegalStateException(\n                            \"This activity is currently not freeform-enabled\");\n                } else if (rootTask.getParent().inFreeformWindowingMode()) {\n                    // If the window is on a freeform display, set it to undefined. It will be\n                    // resolved to freeform and it can adjust windowing mode when the display mode\n                    // changes in runtime.\n                    rootTask.setWindowingMode(WINDOWING_MODE_UNDEFINED);\n                } else {\n                    rootTask.setWindowingMode(WINDOWING_MODE_FREEFORM);\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public void startLockTaskModeByToken(IBinder token) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n            if (r != null) {\n                mService.startLockTaskMode(r.getTask(), false /* isSystemCaller */);\n            }\n        }\n    }\n\n    @Override\n    public void stopLockTaskModeByToken(IBinder token) {\n        mService.stopLockTaskModeInternal(token, false /* isSystemCaller */);\n    }\n\n    @Override\n    public void showLockTaskEscapeMessage(IBinder token) {\n        synchronized (mGlobalLock) {\n            if (ActivityRecord.forTokenLocked(token) != null) {\n                mService.getLockTaskController().showLockTaskToast();\n            }\n        }\n    }\n\n    @Override\n    public void setTaskDescription(IBinder token, ActivityManager.TaskDescription td) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n            if (r != null) {\n                r.setTaskDescription(td);\n            }\n        }\n    }\n\n    @Override\n    public boolean showAssistFromActivity(IBinder token, Bundle args) {\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord caller = ActivityRecord.forTokenLocked(token);\n                final Task topRootTask = mService.getTopDisplayFocusedRootTask();\n                final ActivityRecord top = topRootTask != null\n                        ? topRootTask.getTopNonFinishingActivity() : null;\n                if (top != caller) {\n                    Slog.w(TAG, \"showAssistFromActivity failed: caller \" + caller\n                            + \" is not current top \" + top);\n                    return false;\n                }\n                if (!top.nowVisible) {\n                    Slog.w(TAG, \"showAssistFromActivity failed: caller \" + caller\n                            + \" is not visible\");\n                    return false;\n                }\n            }\n            return mAssistUtils.showSessionForActiveService(args, SHOW_SOURCE_APPLICATION,\n                    null /* showCallback */, token);\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public boolean isRootVoiceInteraction(IBinder token) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n            return r != null && r.rootVoiceInteraction;\n        }\n    }\n\n    @Override\n    public void startLocalVoiceInteraction(IBinder callingActivity, Bundle options) {\n        Slog.i(TAG, \"Activity tried to startLocalVoiceInteraction\");\n        synchronized (mGlobalLock) {\n            final Task topRootTask = mService.getTopDisplayFocusedRootTask();\n            final ActivityRecord activity = topRootTask != null\n                    ? topRootTask.getTopNonFinishingActivity() : null;\n            if (ActivityRecord.forTokenLocked(callingActivity) != activity) {\n                throw new SecurityException(\"Only focused activity can call startVoiceInteraction\");\n            }\n            if (mService.mRunningVoice != null || activity.getTask().voiceSession != null\n                    || activity.voiceSession != null) {\n                Slog.w(TAG, \"Already in a voice interaction, cannot start new voice interaction\");\n                return;\n            }\n            if (activity.pendingVoiceInteractionStart) {\n                Slog.w(TAG, \"Pending start of voice interaction already.\");\n                return;\n            }\n            activity.pendingVoiceInteractionStart = true;\n        }\n        LocalServices.getService(VoiceInteractionManagerInternal.class)\n                .startLocalVoiceInteraction(callingActivity, options);\n    }\n\n    @Override\n    public void stopLocalVoiceInteraction(IBinder callingActivity) {\n        LocalServices.getService(VoiceInteractionManagerInternal.class)\n                .stopLocalVoiceInteraction(callingActivity);\n    }\n\n    @Override\n    public void setShowWhenLocked(IBinder token, boolean showWhenLocked) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r != null) {\n                    r.setShowWhenLocked(showWhenLocked);\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public void setInheritShowWhenLocked(IBinder token, boolean inheritShowWhenLocked) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r != null) {\n                    r.setInheritShowWhenLocked(inheritShowWhenLocked);\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public void setTurnScreenOn(IBinder token, boolean turnScreenOn) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r != null) {\n                    r.setTurnScreenOn(turnScreenOn);\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public void reportActivityFullyDrawn(IBinder token, boolean restoredFromBundle) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r != null) {\n                    r.reportFullyDrawnLocked(restoredFromBundle);\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public void overridePendingTransition(IBinder token, String packageName,\n            int enterAnim, int exitAnim) {\n        final long origId = Binder.clearCallingIdentity();\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n            if (r != null && r.isState(Task.ActivityState.RESUMED, Task.ActivityState.PAUSING)) {\n                r.mDisplayContent.mAppTransition.overridePendingAppTransition(\n                        packageName, enterAnim, exitAnim, null, null,\n                        r.mOverrideTaskTransition);\n            }\n        }\n        Binder.restoreCallingIdentity(origId);\n    }\n\n    @Override\n    public int setVrMode(IBinder token, boolean enabled, ComponentName packageName) {\n        mService.enforceSystemHasVrFeature();\n\n        final VrManagerInternal vrService = LocalServices.getService(VrManagerInternal.class);\n        final ActivityRecord r;\n        synchronized (mGlobalLock) {\n            r = ActivityRecord.isInRootTaskLocked(token);\n        }\n        if (r == null) {\n            throw new IllegalArgumentException();\n        }\n\n        final int err;\n        if ((err = vrService.hasVrPackage(packageName, r.mUserId)) != VrManagerInternal.NO_ERROR) {\n            return err;\n        }\n\n        // Clear the binder calling uid since this path may call moveToTask().\n        final long callingId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                r.requestedVrComponent = (enabled) ? packageName : null;\n\n                // Update associated state if this activity is currently focused.\n                if (r.isFocusedActivityOnDisplay()) {\n                    mService.applyUpdateVrModeLocked(r);\n                }\n                return 0;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(callingId);\n        }\n    }\n\n    @Override\n    public void setDisablePreviewScreenshots(IBinder token, boolean disable) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r != null) {\n                    r.setDisablePreviewScreenshots(disable);\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    void restartActivityProcessIfVisible(IBinder token) {\n        ActivityTaskManagerService.enforceTaskPermission(\"restartActivityProcess\");\n        final long callingId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r != null) {\n                    r.restartProcessIfVisible();\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(callingId);\n        }\n    }\n\n    @Override\n    public void invalidateHomeTaskSnapshot(IBinder token) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n            if (r != null && r.isActivityTypeHome()) {\n                mService.mWindowManager.mTaskSnapshotController.removeSnapshotCache(\n                        r.getTask().mTaskId);\n            }\n        }\n    }\n\n    @Override\n    public void dismissKeyguard(IBinder token, IKeyguardDismissCallback callback,\n            CharSequence message) {\n        if (message != null) {\n            mService.mAmInternal.enforceCallingPermission(\n                    android.Manifest.permission.SHOW_KEYGUARD_MESSAGE, \"dismissKeyguard\");\n        }\n        final long callingId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                mService.mKeyguardController.dismissKeyguard(token, callback, message);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(callingId);\n        }\n    }\n\n    @Override\n    public void registerRemoteAnimations(IBinder token, RemoteAnimationDefinition definition) {\n        mService.mAmInternal.enforceCallingPermission(CONTROL_REMOTE_APP_TRANSITION_ANIMATIONS,\n                \"registerRemoteAnimations\");\n        definition.setCallingPidUid(Binder.getCallingPid(), Binder.getCallingUid());\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r != null) {\n                    r.registerRemoteAnimations(definition);\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public void unregisterRemoteAnimations(IBinder token) {\n        mService.mAmInternal.enforceCallingPermission(CONTROL_REMOTE_APP_TRANSITION_ANIMATIONS,\n                \"unregisterRemoteAnimations\");\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r != null) {\n                    r.unregisterRemoteAnimations();\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public void onBackPressedOnTaskRoot(IBinder token, IRequestFinishCallback callback) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            final Intent baseActivityIntent;\n            final boolean launchedFromHome;\n\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r == null) return;\n\n                if (mService.mWindowOrganizerController.mTaskOrganizerController\n                        .handleInterceptBackPressedOnTaskRoot(r.getRootTask())) {\n                    // This task is handled by a task organizer that has requested the back pressed\n                    // callback.\n                    return;\n                }\n\n                final Intent baseIntent = r.getTask().getBaseIntent();\n                final boolean activityIsBaseActivity = baseIntent != null\n                        && r.mActivityComponent.equals(baseIntent.getComponent());\n                baseActivityIntent = activityIsBaseActivity ? r.intent : null;\n                launchedFromHome = r.isLaunchSourceType(ActivityRecord.LAUNCH_SOURCE_TYPE_HOME);\n            }\n\n            // If the activity is one of the main entry points for the application, then we should\n            // refrain from finishing the activity and instead move it to the back to keep it in\n            // memory. The requirements for this are:\n            //   1. The current activity is the base activity for the task.\n            //   2. a. If the activity was launched by the home process, we trust that its intent\n            //         was resolved, so we check if the it is a main intent for the application.\n            //      b. Otherwise, we query Package Manager to verify whether the activity is a\n            //         launcher activity for the application.\n            if (baseActivityIntent != null\n                    && ((launchedFromHome && ActivityRecord.isMainIntent(baseActivityIntent))\n                        || isLauncherActivity(baseActivityIntent.getComponent()))) {\n                moveActivityTaskToBack(token, false /* nonRoot */);\n                return;\n            }\n\n            // The default option for handling the back button is to finish the Activity.\n            try {\n                callback.requestFinish();\n            } catch (RemoteException e) {\n                Slog.e(TAG, \"Failed to invoke request finish callback\", e);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    /**\n     * Queries PackageManager to see if the given activity is one of the main entry point for the\n     * application. This should not be called with the WM lock held.\n     */\n    @SuppressWarnings(\"unchecked\")\n    private boolean isLauncherActivity(@NonNull ComponentName activity) {\n        final Intent queryIntent = new Intent(Intent.ACTION_MAIN);\n        queryIntent.addCategory(Intent.CATEGORY_LAUNCHER);\n        queryIntent.setPackage(activity.getPackageName());\n        try {\n            final ParceledListSlice<ResolveInfo> resolved =\n                    mService.getPackageManager().queryIntentActivities(\n                            queryIntent, null, 0, mContext.getUserId());\n            if (resolved == null) return false;\n            for (final ResolveInfo ri : resolved.getList()) {\n                if (ri.getComponentInfo().getComponentName().equals(activity)) {\n                    return true;\n                }\n            }\n        } catch (RemoteException e) {\n            Slog.e(TAG, \"Failed to query intent activities\", e);\n        }\n        return false;\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 9834,
                                        "general": {
                                            "word_based": 4058,
                                            "char_based": 12788
                                        },
                                        "gemini": 11545
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "c3f4dd070cfc7f20581779abd83620fc8769fbd4",
                            "repo_path": "android_repos/base",
                            "result": "failure",
                            "downstream_patch_content": "commit c3f4dd070cfc7f20581779abd83620fc8769fbd4\nAuthor: Hongwei Wang <hwwang@google.com>\nDate:   Tue Aug 1 16:00:31 2023 -0700\n\n    Rate limiting PiP aspect ratio change request\n    \n    Using CountQuotaTrack to limit how frequent an app can request aspect\n    ratio change via PictureInPictureParams, which could result flood of PiP\n    resizing requests and freeze the PiP window.\n    \n    Note that CountQuotaTrack is initialized out of the WM lock to avoid\n    dead lock with the AM one.\n    \n    Bug: 283103220\n    Test: Manually, using the POC app\n    Test: Manually, switching YT PiP video functions at a regular rate\n    Test: atest WindowOrganizerTests ActivityThreadTest\n    Merged-In: Icb7dd17bbf7df573a9bb28f3dc56e90e78384f4f\n    Change-Id: Icb7dd17bbf7df573a9bb28f3dc56e90e78384f4f\n\ndiff --git a/services/core/java/com/android/server/wm/ActivityClientController.java b/services/core/java/com/android/server/wm/ActivityClientController.java\nindex e02e8671f211..c783630be113 100644\n--- a/services/core/java/com/android/server/wm/ActivityClientController.java\n+++ b/services/core/java/com/android/server/wm/ActivityClientController.java\n@@ -73,6 +73,7 @@ import android.util.Slog;\n import android.view.RemoteAnimationDefinition;\n import android.window.SizeConfigurationBuckets;\n \n+import com.android.internal.annotations.VisibleForTesting;\n import com.android.internal.app.AssistUtils;\n import com.android.internal.policy.IKeyguardDismissCallback;\n import com.android.internal.protolog.common.ProtoLog;\n@@ -80,6 +81,9 @@ import com.android.server.LocalServices;\n import com.android.server.Watchdog;\n import com.android.server.pm.parsing.pkg.AndroidPackage;\n import com.android.server.uri.NeededUriGrants;\n+import com.android.server.utils.quota.Categorizer;\n+import com.android.server.utils.quota.Category;\n+import com.android.server.utils.quota.CountQuotaTracker;\n import com.android.server.vr.VrManagerInternal;\n \n /**\n@@ -95,6 +99,13 @@ class ActivityClientController extends IActivityClientController.Stub {\n     private final ActivityTaskSupervisor mTaskSupervisor;\n     private final Context mContext;\n \n+    // Prevent malicious app abusing the Activity#setPictureInPictureParams API\n+    @VisibleForTesting CountQuotaTracker mSetPipAspectRatioQuotaTracker;\n+    // Limit to 60 times / minute\n+    private static final int SET_PIP_ASPECT_RATIO_LIMIT = 60;\n+    // The timeWindowMs here can not be smaller than QuotaTracker#MIN_WINDOW_SIZE_MS\n+    private static final long SET_PIP_ASPECT_RATIO_TIME_WINDOW_MS = 60_000;\n+\n     /** Wrapper around VoiceInteractionServiceManager. */\n     private AssistUtils mAssistUtils;\n \n@@ -691,6 +702,7 @@ class ActivityClientController extends IActivityClientController.Stub {\n     public boolean enterPictureInPictureMode(IBinder token, final PictureInPictureParams params) {\n         final long origId = Binder.clearCallingIdentity();\n         try {\n+            ensureSetPipAspectRatioQuotaTracker();\n             synchronized (mGlobalLock) {\n                 final ActivityRecord r = ensureValidPictureInPictureActivityParams(\n                         \"enterPictureInPictureMode\", token, params);\n@@ -705,6 +717,7 @@ class ActivityClientController extends IActivityClientController.Stub {\n     public void setPictureInPictureParams(IBinder token, final PictureInPictureParams params) {\n         final long origId = Binder.clearCallingIdentity();\n         try {\n+            ensureSetPipAspectRatioQuotaTracker();\n             synchronized (mGlobalLock) {\n                 final ActivityRecord r = ensureValidPictureInPictureActivityParams(\n                         \"setPictureInPictureParams\", token, params);\n@@ -738,6 +751,19 @@ class ActivityClientController extends IActivityClientController.Stub {\n         Binder.restoreCallingIdentity(origId);\n     }\n \n+    /**\n+     * Initialize the {@link #mSetPipAspectRatioQuotaTracker} if applicable, which should happen\n+     * out of {@link #mGlobalLock} to avoid deadlock (AM lock is used in QuotaTrack ctor).\n+     */\n+    private void ensureSetPipAspectRatioQuotaTracker() {\n+        if (mSetPipAspectRatioQuotaTracker == null) {\n+            mSetPipAspectRatioQuotaTracker = new CountQuotaTracker(mContext,\n+                    Categorizer.SINGLE_CATEGORIZER);\n+            mSetPipAspectRatioQuotaTracker.setCountLimit(Category.SINGLE_CATEGORY,\n+                    SET_PIP_ASPECT_RATIO_LIMIT, SET_PIP_ASPECT_RATIO_TIME_WINDOW_MS);\n+        }\n+    }\n+\n     /**\n      * Checks the state of the system and the activity associated with the given {@param token} to\n      * verify that picture-in-picture is supported for that activity.\n@@ -762,6 +788,19 @@ class ActivityClientController extends IActivityClientController.Stub {\n                     + \": Current activity does not support picture-in-picture.\");\n         }\n \n+        // Rate limit how frequent an app can request aspect ratio change via\n+        // Activity#setPictureInPictureParams\n+        final int userId = UserHandle.getCallingUserId();\n+        if (r.pictureInPictureArgs.hasSetAspectRatio()\n+                && params.hasSetAspectRatio()\n+                && !r.pictureInPictureArgs.getAspectRatioRational().equals(\n+                params.getAspectRatioRational())\n+                && !mSetPipAspectRatioQuotaTracker.noteEvent(\n+                userId, r.packageName, \"setPipAspectRatio\")) {\n+            throw new IllegalStateException(caller\n+                    + \": Too many PiP aspect ratio change requests from \" + r.packageName);\n+        }\n+\n         if (params.hasSetAspectRatio()\n                 && !mService.mWindowManager.isValidPictureInPictureAspectRatio(\n                 r.mDisplayContent, params.getAspectRatio())) {\ndiff --git a/services/tests/wmtests/src/com/android/server/wm/WindowOrganizerTests.java b/services/tests/wmtests/src/com/android/server/wm/WindowOrganizerTests.java\nindex ab496cf34acc..cb1a69339044 100644\n--- a/services/tests/wmtests/src/com/android/server/wm/WindowOrganizerTests.java\n+++ b/services/tests/wmtests/src/com/android/server/wm/WindowOrganizerTests.java\n@@ -851,6 +851,12 @@ public class WindowOrganizerTests extends WindowTestsBase {\n         assertNotNull(o.mInfo);\n         assertNotNull(o.mInfo.pictureInPictureParams);\n \n+        // Bypass the quota check, which causes NPE in current test setup.\n+        if (mWm.mAtmService.mActivityClientController.mSetPipAspectRatioQuotaTracker != null) {\n+            mWm.mAtmService.mActivityClientController.mSetPipAspectRatioQuotaTracker\n+                    .setEnabled(false);\n+        }\n+\n         final PictureInPictureParams p2 = new PictureInPictureParams.Builder()\n                 .setAspectRatio(new Rational(3, 4)).build();\n         mWm.mAtmService.mActivityClientController.setPictureInPictureParams(record.token, p2);\n",
                            "downstream_patch_tokens": {
                                "openai": 1583,
                                "general": {
                                    "word_based": 633,
                                    "char_based": 1701
                                },
                                "gemini": 1894
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "services/core/java/com/android/server/wm/ActivityClientController.java",
                                    "total_hunks": 7,
                                    "failed_hunks": [
                                        7
                                    ],
                                    "inline_merge_conflicts": [],
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    },
                                    "rej_file_content": "```diff\n--- services/core/java/com/android/server/wm/ActivityClientController.java\n+++ services/core/java/com/android/server/wm/ActivityClientController.java\n@@ -1061,6 +1087,19 @@ class ActivityClientController extends IActivityClientController.Stub {\n                     + \": Current activity does not support picture-in-picture.\");\n         }\n \n+        // Rate limit how frequent an app can request aspect ratio change via\n+        // Activity#setPictureInPictureParams\n+        final int userId = UserHandle.getCallingUserId();\n+        if (r.pictureInPictureArgs.hasSetAspectRatio()\n+                && params.hasSetAspectRatio()\n+                && !r.pictureInPictureArgs.getAspectRatio().equals(\n+                params.getAspectRatio())\n+                && !mSetPipAspectRatioQuotaTracker.noteEvent(\n+                userId, r.packageName, \"setPipAspectRatio\")) {\n+            throw new IllegalStateException(caller\n+                    + \": Too many PiP aspect ratio change requests from \" + r.packageName);\n+        }\n+\n         final float minAspectRatio = mContext.getResources().getFloat(\n                 com.android.internal.R.dimen.config_pictureInPictureMinAspectRatio);\n         final float maxAspectRatio = mContext.getResources().getFloat(\n```",
                                    "rej_file_tokens": {
                                        "openai": 248,
                                        "general": {
                                            "word_based": 104,
                                            "char_based": 313
                                        },
                                        "gemini": 295
                                    },
                                    "patch_apply_output": "patching file services/core/java/com/android/server/wm/ActivityClientController.java\nHunk #1 succeeded at 73 with fuzz 2 (offset -26 lines).\nHunk #2 succeeded at 81 with fuzz 2 (offset -28 lines).\nHunk #3 succeeded at 99 (offset -28 lines).\nHunk #4 succeeded at 702 (offset -255 lines).\nHunk #5 succeeded at 717 (offset -255 lines).\nHunk #6 succeeded at 751 with fuzz 1 (offset -273 lines).\nHunk #7 FAILED at 1061.\n1 out of 7 hunks FAILED -- saving rejects to file services/core/java/com/android/server/wm/ActivityClientController.java.rej",
                                    "inline_merge_output": "patching file services/core/java/com/android/server/wm/ActivityClientController.java\nHunk #1 already applied at 102.\nHunk #2 already applied at 112-114.\nHunk #3 merged at 137-143.\nHunk #4 already applied at 967.\nHunk #5 already applied at 982.\nHunk #7 merged at 1097-1109.",
                                    "upstream_file_tokens": {
                                        "openai": 14685,
                                        "general": {
                                            "word_based": 5921,
                                            "char_based": 19126
                                        },
                                        "gemini": 17232
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2020 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.wm;\n\nimport static android.Manifest.permission.CONTROL_REMOTE_APP_TRANSITION_ANIMATIONS;\nimport static android.app.ActivityTaskManager.INVALID_TASK_ID;\nimport static android.app.WindowConfiguration.WINDOWING_MODE_FREEFORM;\nimport static android.app.WindowConfiguration.WINDOWING_MODE_FULLSCREEN;\nimport static android.app.WindowConfiguration.WINDOWING_MODE_UNDEFINED;\nimport static android.os.Process.INVALID_UID;\nimport static android.os.Process.SYSTEM_UID;\nimport static android.os.Trace.TRACE_TAG_WINDOW_MANAGER;\nimport static android.service.voice.VoiceInteractionSession.SHOW_SOURCE_APPLICATION;\nimport static android.view.Display.DEFAULT_DISPLAY;\nimport static android.view.Display.INVALID_DISPLAY;\n\nimport static com.android.internal.protolog.ProtoLogGroup.WM_DEBUG_CONFIGURATION;\nimport static com.android.internal.protolog.ProtoLogGroup.WM_DEBUG_IMMERSIVE;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.DEBUG_ALL;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.DEBUG_SWITCH;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.TAG_ATM;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.TAG_WITH_CLASS_NAME;\nimport static com.android.server.wm.ActivityTaskManagerService.RELAUNCH_REASON_NONE;\nimport static com.android.server.wm.ActivityTaskManagerService.TAG_SWITCH;\nimport static com.android.server.wm.ActivityTaskManagerService.enforceNotIsolatedCaller;\nimport static com.android.server.wm.Task.ActivityState.DESTROYED;\nimport static com.android.server.wm.Task.ActivityState.DESTROYING;\n\nimport android.annotation.NonNull;\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.ActivityTaskManager;\nimport android.app.IActivityClientController;\nimport android.app.IRequestFinishCallback;\nimport android.app.PictureInPictureParams;\nimport android.app.PictureInPictureUiState;\nimport android.app.servertransaction.ClientTransaction;\nimport android.app.servertransaction.EnterPipRequestedItem;\nimport android.app.servertransaction.PipStateTransactionItem;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.ResolveInfo;\nimport android.content.res.Configuration;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.IBinder;\nimport android.os.Parcel;\nimport android.os.PersistableBundle;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.service.voice.VoiceInteractionManagerInternal;\nimport android.util.Slog;\nimport android.view.RemoteAnimationDefinition;\nimport android.window.SizeConfigurationBuckets;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.app.AssistUtils;\nimport com.android.internal.policy.IKeyguardDismissCallback;\nimport com.android.internal.protolog.common.ProtoLog;\nimport com.android.server.LocalServices;\nimport com.android.server.Watchdog;\nimport com.android.server.pm.parsing.pkg.AndroidPackage;\nimport com.android.server.uri.NeededUriGrants;\nimport com.android.server.utils.quota.Categorizer;\nimport com.android.server.utils.quota.Category;\nimport com.android.server.utils.quota.CountQuotaTracker;\nimport com.android.server.vr.VrManagerInternal;\n\n/**\n * Server side implementation for the client activity to interact with system.\n *\n * @see android.app.ActivityClient\n */\nclass ActivityClientController extends IActivityClientController.Stub {\n    private static final String TAG = TAG_WITH_CLASS_NAME ? \"ActivityClientController\" : TAG_ATM;\n\n    private final ActivityTaskManagerService mService;\n    private final WindowManagerGlobalLock mGlobalLock;\n    private final ActivityTaskSupervisor mTaskSupervisor;\n    private final Context mContext;\n\n    // Prevent malicious app abusing the Activity#setPictureInPictureParams API\n    @VisibleForTesting CountQuotaTracker mSetPipAspectRatioQuotaTracker;\n    // Limit to 60 times / minute\n    private static final int SET_PIP_ASPECT_RATIO_LIMIT = 60;\n    // The timeWindowMs here can not be smaller than QuotaTracker#MIN_WINDOW_SIZE_MS\n    private static final long SET_PIP_ASPECT_RATIO_TIME_WINDOW_MS = 60_000;\n\n    /** Wrapper around VoiceInteractionServiceManager. */\n    private AssistUtils mAssistUtils;\n\n    ActivityClientController(ActivityTaskManagerService service) {\n        mService = service;\n        mGlobalLock = service.mGlobalLock;\n        mTaskSupervisor = service.mTaskSupervisor;\n        mContext = service.mContext;\n    }\n\n    void onSystemReady() {\n        mAssistUtils = new AssistUtils(mContext);\n    }\n\n    @Override\n    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)\n            throws RemoteException {\n        try {\n            return super.onTransact(code, data, reply, flags);\n        } catch (RuntimeException e) {\n            throw ActivityTaskManagerService.logAndRethrowRuntimeExceptionOnTransact(\n                    \"ActivityClientController\", e);\n        }\n    }\n\n    @Override\n    public void activityIdle(IBinder token, Configuration config, boolean stopProfiling) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, \"activityIdle\");\n                final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n                if (r == null) {\n                    return;\n                }\n                mTaskSupervisor.activityIdleInternal(r, false /* fromTimeout */,\n                        false /* processPausingActivities */, config);\n                if (stopProfiling && r.hasProcess()) {\n                    r.app.clearProfilerIfNeeded();\n                }\n            }\n        } finally {\n            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public void activityResumed(IBinder token, boolean handleSplashScreenExit) {\n        final long origId = Binder.clearCallingIdentity();\n        synchronized (mGlobalLock) {\n            ActivityRecord.activityResumedLocked(token, handleSplashScreenExit);\n        }\n        Binder.restoreCallingIdentity(origId);\n    }\n\n    @Override\n    public void activityTopResumedStateLost() {\n        final long origId = Binder.clearCallingIdentity();\n        synchronized (mGlobalLock) {\n            mTaskSupervisor.handleTopResumedStateReleased(false /* timeout */);\n        }\n        Binder.restoreCallingIdentity(origId);\n    }\n\n    @Override\n    public void activityPaused(IBinder token) {\n        final long origId = Binder.clearCallingIdentity();\n        synchronized (mGlobalLock) {\n            Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, \"activityPaused\");\n            final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n            if (r != null) {\n                r.activityPaused(false);\n            }\n            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);\n        }\n        Binder.restoreCallingIdentity(origId);\n    }\n\n    @Override\n    public void activityStopped(IBinder token, Bundle icicle, PersistableBundle persistentState,\n            CharSequence description) {\n        if (DEBUG_ALL) Slog.v(TAG, \"Activity stopped: token=\" + token);\n\n        // Refuse possible leaked file descriptors.\n        if (icicle != null && icicle.hasFileDescriptors()) {\n            throw new IllegalArgumentException(\"File descriptors passed in Bundle\");\n        }\n\n        final long origId = Binder.clearCallingIdentity();\n\n        String restartingName = null;\n        int restartingUid = 0;\n        final ActivityRecord r;\n        synchronized (mGlobalLock) {\n            Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, \"activityStopped\");\n            r = ActivityRecord.isInRootTaskLocked(token);\n            if (r != null) {\n                if (r.attachedToProcess() && r.isState(Task.ActivityState.RESTARTING_PROCESS)) {\n                    // The activity was requested to restart from\n                    // {@link #restartActivityProcessIfVisible}.\n                    restartingName = r.app.mName;\n                    restartingUid = r.app.mUid;\n                }\n                r.activityStopped(icicle, persistentState, description);\n            }\n            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);\n        }\n\n        if (restartingName != null) {\n            // In order to let the foreground activity can be restarted with its saved state from\n            // {@link android.app.Activity#onSaveInstanceState}, the kill operation is postponed\n            // until the activity reports stopped with the state. And the activity record will be\n            // kept because the record state is restarting, then the activity will be restarted\n            // immediately if it is still the top one.\n            mTaskSupervisor.removeRestartTimeouts(r);\n            mService.mAmInternal.killProcess(restartingName, restartingUid,\n                    \"restartActivityProcess\");\n        }\n        mService.mAmInternal.trimApplications();\n\n        Binder.restoreCallingIdentity(origId);\n    }\n\n    @Override\n    public void activityDestroyed(IBinder token) {\n        if (DEBUG_SWITCH) Slog.v(TAG_SWITCH, \"ACTIVITY DESTROYED: \" + token);\n        final long origId = Binder.clearCallingIdentity();\n        synchronized (mGlobalLock) {\n            Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, \"activityDestroyed\");\n            try {\n                final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n                if (r != null) {\n                    r.destroyed(\"activityDestroyed\");\n                }\n            } finally {\n                Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public void activityRelaunched(IBinder token) {\n        final long origId = Binder.clearCallingIdentity();\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n            if (r != null) {\n                r.finishRelaunching();\n            }\n        }\n        Binder.restoreCallingIdentity(origId);\n    }\n\n    @Override\n    public void reportSizeConfigurations(IBinder token,\n            SizeConfigurationBuckets sizeConfigurations) {\n        ProtoLog.v(WM_DEBUG_CONFIGURATION, \"Report configuration: %s %s\",\n                token, sizeConfigurations);\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n            if (r != null) {\n                r.setSizeConfigurations(sizeConfigurations);\n            }\n        }\n    }\n\n    /**\n     * Attempts to move a task backwards in z-order (the order of activities within the task is\n     * unchanged).\n     *\n     * There are several possible results of this call:\n     * - if the task is locked, then we will show the lock toast.\n     * - if there is a task behind the provided task, then that task is made visible and resumed as\n     * this task is moved to the back.\n     * - otherwise, if there are no other tasks in the root task:\n     * - if this task is in the pinned mode, then we remove the task completely, which will\n     * have the effect of moving the task to the top or bottom of the fullscreen root task\n     * (depending on whether it is visible).\n     * - otherwise, we simply return home and hide this task.\n     *\n     * @param token   A reference to the activity we wish to move.\n     * @param nonRoot If false then this only works if the activity is the root\n     *                of a task; if true it will work for any activity in a task.\n     * @return Returns true if the move completed, false if not.\n     */\n    @Override\n    public boolean moveActivityTaskToBack(IBinder token, boolean nonRoot) {\n        enforceNotIsolatedCaller(\"moveActivityTaskToBack\");\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final int taskId = ActivityRecord.getTaskForActivityLocked(token, !nonRoot);\n                final Task task = mService.mRootWindowContainer.anyTaskForId(taskId);\n                if (task != null) {\n                    return ActivityRecord.getRootTask(token).moveTaskToBack(task);\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n        return false;\n    }\n\n    @Override\n    public boolean shouldUpRecreateTask(IBinder token, String destAffinity) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord srec = ActivityRecord.forTokenLocked(token);\n            if (srec != null) {\n                return srec.getRootTask().shouldUpRecreateTaskLocked(srec, destAffinity);\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean navigateUpTo(IBinder token, Intent destIntent, int resultCode,\n            Intent resultData) {\n        final ActivityRecord r;\n        synchronized (mGlobalLock) {\n            r = ActivityRecord.isInRootTaskLocked(token);\n            if (r == null) {\n                return false;\n            }\n        }\n\n        // Carefully collect grants without holding lock.\n        final NeededUriGrants destGrants = mService.collectGrants(destIntent, r);\n        final NeededUriGrants resultGrants = mService.collectGrants(resultData, r.resultTo);\n\n        synchronized (mGlobalLock) {\n            return r.getRootTask().navigateUpTo(\n                    r, destIntent, destGrants, resultCode, resultData, resultGrants);\n        }\n    }\n\n    @Override\n    public boolean releaseActivityInstance(IBinder token) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r == null || !r.isDestroyable()) {\n                    return false;\n                }\n                r.destroyImmediately(\"app-req\");\n                return r.isState(DESTROYING, DESTROYED);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    /**\n     * This is the internal entry point for handling Activity.finish().\n     *\n     * @param token      The Binder token referencing the Activity we want to finish.\n     * @param resultCode Result code, if any, from this Activity.\n     * @param resultData Result data (Intent), if any, from this Activity.\n     * @param finishTask Whether to finish the task associated with this Activity.\n     * @return Returns true if the activity successfully finished, or false if it is still running.\n     */\n    @Override\n    public boolean finishActivity(IBinder token, int resultCode, Intent resultData,\n            int finishTask) {\n        // Refuse possible leaked file descriptors.\n        if (resultData != null && resultData.hasFileDescriptors()) {\n            throw new IllegalArgumentException(\"File descriptors passed in Intent\");\n        }\n\n        final ActivityRecord r;\n        synchronized (mGlobalLock) {\n            r = ActivityRecord.isInRootTaskLocked(token);\n            if (r == null) {\n                return true;\n            }\n        }\n\n        // Carefully collect grants without holding lock.\n        final NeededUriGrants resultGrants = mService.collectGrants(resultData, r.resultTo);\n\n        synchronized (mGlobalLock) {\n            // Check again in case activity was removed when collecting grants.\n            if (!r.isInHistory()) {\n                return true;\n            }\n\n            // Keep track of the root activity of the task before we finish it.\n            final Task tr = r.getTask();\n            final ActivityRecord rootR = tr.getRootActivity();\n            if (rootR == null) {\n                Slog.w(TAG, \"Finishing task with all activities already finished\");\n            }\n            // Do not allow task to finish if last task in lockTask mode. Launchable priv-apps can\n            // finish.\n            if (mService.getLockTaskController().activityBlockedFromFinish(r)) {\n                return false;\n            }\n\n            // TODO: There is a dup. of this block of code in ActivityStack.navigateUpToLocked\n            // We should consolidate.\n            if (mService.mController != null) {\n                // Find the first activity that is not finishing.\n                final ActivityRecord next =\n                        r.getRootTask().topRunningActivity(token, INVALID_TASK_ID);\n                if (next != null) {\n                    // ask watcher if this is allowed\n                    boolean resumeOK = true;\n                    try {\n                        resumeOK = mService.mController.activityResuming(next.packageName);\n                    } catch (RemoteException e) {\n                        mService.mController = null;\n                        Watchdog.getInstance().setActivityController(null);\n                    }\n\n                    if (!resumeOK) {\n                        Slog.i(TAG, \"Not finishing activity because controller resumed\");\n                        return false;\n                    }\n                }\n            }\n\n            // Note down that the process has finished an activity and is in background activity\n            // starts grace period.\n            if (r.app != null) {\n                r.app.setLastActivityFinishTimeIfNeeded(SystemClock.uptimeMillis());\n            }\n\n            final long origId = Binder.clearCallingIdentity();\n            Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, \"finishActivity\");\n            try {\n                final boolean res;\n                final boolean finishWithRootActivity =\n                        finishTask == Activity.FINISH_TASK_WITH_ROOT_ACTIVITY;\n                if (finishTask == Activity.FINISH_TASK_WITH_ACTIVITY\n                        || (finishWithRootActivity && r == rootR)) {\n                    // If requested, remove the task that is associated to this activity only if it\n                    // was the root activity in the task. The result code and data is ignored\n                    // because we don't support returning them across task boundaries. Also, to\n                    // keep backwards compatibility we remove the task from recents when finishing\n                    // task with root activity.\n                    mTaskSupervisor.removeTask(tr, false /*killProcess*/,\n                            finishWithRootActivity, \"finish-activity\");\n                    res = true;\n                    // Explicitly dismissing the activity so reset its relaunch flag.\n                    r.mRelaunchReason = RELAUNCH_REASON_NONE;\n                } else {\n                    r.finishIfPossible(resultCode, resultData, resultGrants,\n                            \"app-request\", true /* oomAdj */);\n                    res = r.finishing;\n                    if (!res) {\n                        Slog.i(TAG, \"Failed to finish by app-request\");\n                    }\n                }\n                return res;\n            } finally {\n                Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public boolean finishActivityAffinity(IBinder token) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r == null) {\n                    return false;\n                }\n\n                // Do not allow task to finish if last task in lockTask mode. Launchable priv-apps\n                // can finish.\n                if (mService.getLockTaskController().activityBlockedFromFinish(r)) {\n                    return false;\n                }\n\n                r.getTask().forAllActivities(activity -> r.finishIfSameAffinity(activity),\n                        r /* boundary */, true /* includeBoundary */,\n                        true /* traverseTopToBottom */);\n                return true;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public void finishSubActivity(IBinder token, String resultWho, int requestCode) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r == null) return;\n\n                // TODO: This should probably only loop over the task since you need to be in the\n                // same task to return results.\n                r.getRootTask().forAllActivities(activity -> {\n                    activity.finishIfSubActivity(r /* parent */, resultWho, requestCode);\n                }, true /* traverseTopToBottom */);\n\n                mService.updateOomAdj();\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public boolean isTopOfTask(IBinder token) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n            return r != null && r.getTask().getTopNonFinishingActivity() == r;\n        }\n    }\n\n    @Override\n    public boolean willActivityBeVisible(IBinder token) {\n        synchronized (mGlobalLock) {\n            final Task rootTask = ActivityRecord.getRootTask(token);\n            return rootTask != null && rootTask.willActivityBeVisible(token);\n        }\n    }\n\n    @Override\n    public int getDisplayId(IBinder activityToken) {\n        synchronized (mGlobalLock) {\n            final Task rootTask = ActivityRecord.getRootTask(activityToken);\n            if (rootTask != null) {\n                final int displayId = rootTask.getDisplayId();\n                return displayId != INVALID_DISPLAY ? displayId : DEFAULT_DISPLAY;\n            }\n            return DEFAULT_DISPLAY;\n        }\n    }\n\n    @Override\n    public int getTaskForActivity(IBinder token, boolean onlyRoot) {\n        synchronized (mGlobalLock) {\n            return ActivityRecord.getTaskForActivityLocked(token, onlyRoot);\n        }\n    }\n\n    @Override\n    public ComponentName getCallingActivity(IBinder token) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = getCallingRecord(token);\n            return r != null ? r.intent.getComponent() : null;\n        }\n    }\n\n    @Override\n    public String getCallingPackage(IBinder token) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = getCallingRecord(token);\n            return r != null ? r.info.packageName : null;\n        }\n    }\n\n    private static ActivityRecord getCallingRecord(IBinder token) {\n        final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n        return r != null ? r.resultTo : null;\n    }\n\n    @Override\n    public int getLaunchedFromUid(IBinder token) {\n        if (!canGetLaunchedFrom()) {\n            return INVALID_UID;\n        }\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n            return r != null ? r.launchedFromUid : INVALID_UID;\n        }\n    }\n\n    @Override\n    public String getLaunchedFromPackage(IBinder token) {\n        if (!canGetLaunchedFrom()) {\n            return null;\n        }\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n            return r != null ? r.launchedFromPackage : null;\n        }\n    }\n\n    /** Whether the caller can get the package or uid that launched its activity. */\n    private boolean canGetLaunchedFrom() {\n        final int uid = Binder.getCallingUid();\n        if (UserHandle.getAppId(uid) == SYSTEM_UID) {\n            return true;\n        }\n        final PackageManagerInternal pm = mService.mWindowManager.mPmInternal;\n        final AndroidPackage callingPkg = pm.getPackage(uid);\n        if (callingPkg == null) {\n            return false;\n        }\n        if (callingPkg.isSignedWithPlatformKey()) {\n            return true;\n        }\n        final String[] installerNames = pm.getKnownPackageNames(\n                PackageManagerInternal.PACKAGE_INSTALLER, UserHandle.getUserId(uid));\n        return installerNames.length > 0 && callingPkg.getPackageName().equals(installerNames[0]);\n    }\n\n    @Override\n    public void setRequestedOrientation(IBinder token, int requestedOrientation) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r != null) {\n                    r.setRequestedOrientation(requestedOrientation);\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public int getRequestedOrientation(IBinder token) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n            return r != null\n                    ? r.getRequestedOrientation() : ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;\n        }\n    }\n\n    @Override\n    public boolean convertFromTranslucent(IBinder token) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                return r != null && r.setOccludesParent(true);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public boolean convertToTranslucent(IBinder token, Bundle options) {\n        final SafeActivityOptions safeOptions = SafeActivityOptions.fromBundle(options);\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r == null) {\n                    return false;\n                }\n                final ActivityRecord under = r.getTask().getActivityBelow(r);\n                if (under != null) {\n                    under.returningOptions = safeOptions != null ? safeOptions.getOptions(r) : null;\n                }\n                return r.setOccludesParent(false);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public boolean isImmersive(IBinder token) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n            if (r == null) {\n                throw new IllegalArgumentException();\n            }\n            return r.immersive;\n        }\n    }\n\n    @Override\n    public void setImmersive(IBinder token, boolean immersive) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n            if (r == null) {\n                throw new IllegalArgumentException();\n            }\n            r.immersive = immersive;\n\n            // Update associated state if we're frontmost.\n            if (r.isFocusedActivityOnDisplay()) {\n                ProtoLog.d(WM_DEBUG_IMMERSIVE, \"Frontmost changed immersion: %s\", r);\n                mService.applyUpdateLockStateLocked(r);\n            }\n        }\n    }\n\n    @Override\n    public boolean enterPictureInPictureMode(IBinder token, final PictureInPictureParams params) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            ensureSetPipAspectRatioQuotaTracker();\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ensureValidPictureInPictureActivityParams(\n                        \"enterPictureInPictureMode\", token, params);\n                return mService.enterPictureInPictureMode(r, params);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public void setPictureInPictureParams(IBinder token, final PictureInPictureParams params) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            ensureSetPipAspectRatioQuotaTracker();\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ensureValidPictureInPictureActivityParams(\n                        \"setPictureInPictureParams\", token, params);\n\n                // Only update the saved args from the args that are set.\n                r.setPictureInPictureParams(params);\n                if (r.inPinnedWindowingMode()) {\n                    // If the activity is already in picture-in-picture, update the pinned task now\n                    // if it is not already expanding to fullscreen. Otherwise, the arguments will\n                    // be used the next time the activity enters PiP.\n                    final Task rootTask = r.getRootTask();\n                    rootTask.setPictureInPictureAspectRatio(\n                            r.pictureInPictureArgs.getAspectRatio());\n                    rootTask.setPictureInPictureActions(r.pictureInPictureArgs.getActions());\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    /**\n     * Splash screen view is attached to activity.\n     */\n    @Override\n    public void splashScreenAttached(IBinder token) {\n        final long origId = Binder.clearCallingIdentity();\n        synchronized (mGlobalLock) {\n            ActivityRecord.splashScreenAttachedLocked(token);\n        }\n        Binder.restoreCallingIdentity(origId);\n    }\n\n    /**\n     * Initialize the {@link #mSetPipAspectRatioQuotaTracker} if applicable, which should happen\n     * out of {@link #mGlobalLock} to avoid deadlock (AM lock is used in QuotaTrack ctor).\n     */\n    private void ensureSetPipAspectRatioQuotaTracker() {\n        if (mSetPipAspectRatioQuotaTracker == null) {\n            mSetPipAspectRatioQuotaTracker = new CountQuotaTracker(mContext,\n                    Categorizer.SINGLE_CATEGORIZER);\n            mSetPipAspectRatioQuotaTracker.setCountLimit(Category.SINGLE_CATEGORY,\n                    SET_PIP_ASPECT_RATIO_LIMIT, SET_PIP_ASPECT_RATIO_TIME_WINDOW_MS);\n        }\n    }\n\n    /**\n     * Checks the state of the system and the activity associated with the given {@param token} to\n     * verify that picture-in-picture is supported for that activity.\n     *\n     * @return the activity record for the given {@param token} if all the checks pass.\n     */\n    private ActivityRecord ensureValidPictureInPictureActivityParams(String caller,\n            IBinder token, PictureInPictureParams params) {\n        if (!mService.mSupportsPictureInPicture) {\n            throw new IllegalStateException(caller\n                    + \": Device doesn't support picture-in-picture mode.\");\n        }\n\n        final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n        if (r == null) {\n            throw new IllegalStateException(caller\n                    + \": Can't find activity for token=\" + token);\n        }\n\n        if (!r.supportsPictureInPicture()) {\n            throw new IllegalStateException(caller\n                    + \": Current activity does not support picture-in-picture.\");\n        }\n\n        if (params.hasSetAspectRatio()\n                && !mService.mWindowManager.isValidPictureInPictureAspectRatio(\n                r.mDisplayContent, params.getAspectRatio())) {\n            final float minAspectRatio = mContext.getResources().getFloat(\n                    com.android.internal.R.dimen.config_pictureInPictureMinAspectRatio);\n            final float maxAspectRatio = mContext.getResources().getFloat(\n                    com.android.internal.R.dimen.config_pictureInPictureMaxAspectRatio);\n            throw new IllegalArgumentException(String.format(caller\n                            + \": Aspect ratio is too extreme (must be between %f and %f).\",\n                    minAspectRatio, maxAspectRatio));\n        }\n\n        // Truncate the number of actions if necessary.\n        params.truncateActions(ActivityTaskManager.getMaxNumPictureInPictureActions(mContext));\n        return r;\n    }\n\n    /**\n     * Requests that an activity should enter picture-in-picture mode if possible. This method may\n     * be used by the implementation of non-phone form factors.\n     */\n    void requestPictureInPictureMode(@NonNull ActivityRecord r) {\n        if (r.inPinnedWindowingMode()) {\n            throw new IllegalStateException(\"Activity is already in PIP mode\");\n        }\n\n        final boolean canEnterPictureInPicture = r.checkEnterPictureInPictureState(\n                \"requestPictureInPictureMode\", /* beforeStopping */ false);\n        if (!canEnterPictureInPicture) {\n            throw new IllegalStateException(\n                    \"Requested PIP on an activity that doesn't support it\");\n        }\n\n        if (r.pictureInPictureArgs.isAutoEnterEnabled()) {\n            mService.enterPictureInPictureMode(r, r.pictureInPictureArgs);\n            return;\n        }\n\n        try {\n            final ClientTransaction transaction = ClientTransaction.obtain(\n                    r.app.getThread(), r.token);\n            transaction.addCallback(EnterPipRequestedItem.obtain());\n            mService.getLifecycleManager().scheduleTransaction(transaction);\n        } catch (Exception e) {\n            Slog.w(TAG, \"Failed to send enter pip requested item: \"\n                    + r.intent.getComponent(), e);\n        }\n    }\n\n    /**\n     * Alert the client that the Picture-in-Picture state has changed.\n     */\n    void onPictureInPictureStateChanged(@NonNull ActivityRecord r,\n            PictureInPictureUiState pipState) {\n        if (!r.inPinnedWindowingMode()) {\n            throw new IllegalStateException(\"Activity is not in PIP mode\");\n        }\n\n        try {\n            final ClientTransaction transaction = ClientTransaction.obtain(\n                    r.app.getThread(), r.token);\n            transaction.addCallback(PipStateTransactionItem.obtain(pipState));\n            mService.getLifecycleManager().scheduleTransaction(transaction);\n        } catch (Exception e) {\n            Slog.w(TAG, \"Failed to send pip state transaction item: \"\n                    + r.intent.getComponent(), e);\n        }\n    }\n\n    @Override\n    public void toggleFreeformWindowingMode(IBinder token) {\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n                if (r == null) {\n                    throw new IllegalArgumentException(\n                            \"toggleFreeformWindowingMode: No activity record matching token=\"\n                                    + token);\n                }\n\n                final Task rootTask = r.getRootTask();\n                if (rootTask == null) {\n                    throw new IllegalStateException(\"toggleFreeformWindowingMode: the activity \"\n                            + \"doesn't have a root task\");\n                }\n\n                if (!rootTask.inFreeformWindowingMode()\n                        && rootTask.getWindowingMode() != WINDOWING_MODE_FULLSCREEN) {\n                    throw new IllegalStateException(\"toggleFreeformWindowingMode: You can only \"\n                            + \"toggle between fullscreen and freeform.\");\n                }\n\n                if (rootTask.inFreeformWindowingMode()) {\n                    rootTask.setWindowingMode(WINDOWING_MODE_FULLSCREEN);\n                } else if (!r.supportsFreeform()) {\n                    throw new IllegalStateException(\n                            \"This activity is currently not freeform-enabled\");\n                } else if (rootTask.getParent().inFreeformWindowingMode()) {\n                    // If the window is on a freeform display, set it to undefined. It will be\n                    // resolved to freeform and it can adjust windowing mode when the display mode\n                    // changes in runtime.\n                    rootTask.setWindowingMode(WINDOWING_MODE_UNDEFINED);\n                } else {\n                    rootTask.setWindowingMode(WINDOWING_MODE_FREEFORM);\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public void startLockTaskModeByToken(IBinder token) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n            if (r != null) {\n                mService.startLockTaskMode(r.getTask(), false /* isSystemCaller */);\n            }\n        }\n    }\n\n    @Override\n    public void stopLockTaskModeByToken(IBinder token) {\n        mService.stopLockTaskModeInternal(token, false /* isSystemCaller */);\n    }\n\n    @Override\n    public void showLockTaskEscapeMessage(IBinder token) {\n        synchronized (mGlobalLock) {\n            if (ActivityRecord.forTokenLocked(token) != null) {\n                mService.getLockTaskController().showLockTaskToast();\n            }\n        }\n    }\n\n    @Override\n    public void setTaskDescription(IBinder token, ActivityManager.TaskDescription td) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n            if (r != null) {\n                r.setTaskDescription(td);\n            }\n        }\n    }\n\n    @Override\n    public boolean showAssistFromActivity(IBinder token, Bundle args) {\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord caller = ActivityRecord.forTokenLocked(token);\n                final Task topRootTask = mService.getTopDisplayFocusedRootTask();\n                final ActivityRecord top = topRootTask != null\n                        ? topRootTask.getTopNonFinishingActivity() : null;\n                if (top != caller) {\n                    Slog.w(TAG, \"showAssistFromActivity failed: caller \" + caller\n                            + \" is not current top \" + top);\n                    return false;\n                }\n                if (!top.nowVisible) {\n                    Slog.w(TAG, \"showAssistFromActivity failed: caller \" + caller\n                            + \" is not visible\");\n                    return false;\n                }\n            }\n            return mAssistUtils.showSessionForActiveService(args, SHOW_SOURCE_APPLICATION,\n                    null /* showCallback */, token);\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public boolean isRootVoiceInteraction(IBinder token) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n            return r != null && r.rootVoiceInteraction;\n        }\n    }\n\n    @Override\n    public void startLocalVoiceInteraction(IBinder callingActivity, Bundle options) {\n        Slog.i(TAG, \"Activity tried to startLocalVoiceInteraction\");\n        synchronized (mGlobalLock) {\n            final Task topRootTask = mService.getTopDisplayFocusedRootTask();\n            final ActivityRecord activity = topRootTask != null\n                    ? topRootTask.getTopNonFinishingActivity() : null;\n            if (ActivityRecord.forTokenLocked(callingActivity) != activity) {\n                throw new SecurityException(\"Only focused activity can call startVoiceInteraction\");\n            }\n            if (mService.mRunningVoice != null || activity.getTask().voiceSession != null\n                    || activity.voiceSession != null) {\n                Slog.w(TAG, \"Already in a voice interaction, cannot start new voice interaction\");\n                return;\n            }\n            if (activity.pendingVoiceInteractionStart) {\n                Slog.w(TAG, \"Pending start of voice interaction already.\");\n                return;\n            }\n            activity.pendingVoiceInteractionStart = true;\n        }\n        LocalServices.getService(VoiceInteractionManagerInternal.class)\n                .startLocalVoiceInteraction(callingActivity, options);\n    }\n\n    @Override\n    public void stopLocalVoiceInteraction(IBinder callingActivity) {\n        LocalServices.getService(VoiceInteractionManagerInternal.class)\n                .stopLocalVoiceInteraction(callingActivity);\n    }\n\n    @Override\n    public void setShowWhenLocked(IBinder token, boolean showWhenLocked) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r != null) {\n                    r.setShowWhenLocked(showWhenLocked);\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public void setInheritShowWhenLocked(IBinder token, boolean inheritShowWhenLocked) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r != null) {\n                    r.setInheritShowWhenLocked(inheritShowWhenLocked);\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public void setTurnScreenOn(IBinder token, boolean turnScreenOn) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r != null) {\n                    r.setTurnScreenOn(turnScreenOn);\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public void reportActivityFullyDrawn(IBinder token, boolean restoredFromBundle) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r != null) {\n                    r.reportFullyDrawnLocked(restoredFromBundle);\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public void overridePendingTransition(IBinder token, String packageName,\n            int enterAnim, int exitAnim) {\n        final long origId = Binder.clearCallingIdentity();\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n            if (r != null && r.isState(Task.ActivityState.RESUMED, Task.ActivityState.PAUSING)) {\n                r.mDisplayContent.mAppTransition.overridePendingAppTransition(\n                        packageName, enterAnim, exitAnim, null, null,\n                        r.mOverrideTaskTransition);\n            }\n        }\n        Binder.restoreCallingIdentity(origId);\n    }\n\n    @Override\n    public int setVrMode(IBinder token, boolean enabled, ComponentName packageName) {\n        mService.enforceSystemHasVrFeature();\n\n        final VrManagerInternal vrService = LocalServices.getService(VrManagerInternal.class);\n        final ActivityRecord r;\n        synchronized (mGlobalLock) {\n            r = ActivityRecord.isInRootTaskLocked(token);\n        }\n        if (r == null) {\n            throw new IllegalArgumentException();\n        }\n\n        final int err;\n        if ((err = vrService.hasVrPackage(packageName, r.mUserId)) != VrManagerInternal.NO_ERROR) {\n            return err;\n        }\n\n        // Clear the binder calling uid since this path may call moveToTask().\n        final long callingId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                r.requestedVrComponent = (enabled) ? packageName : null;\n\n                // Update associated state if this activity is currently focused.\n                if (r.isFocusedActivityOnDisplay()) {\n                    mService.applyUpdateVrModeLocked(r);\n                }\n                return 0;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(callingId);\n        }\n    }\n\n    @Override\n    public void setDisablePreviewScreenshots(IBinder token, boolean disable) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r != null) {\n                    r.setDisablePreviewScreenshots(disable);\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    void restartActivityProcessIfVisible(IBinder token) {\n        ActivityTaskManagerService.enforceTaskPermission(\"restartActivityProcess\");\n        final long callingId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r != null) {\n                    r.restartProcessIfVisible();\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(callingId);\n        }\n    }\n\n    @Override\n    public void invalidateHomeTaskSnapshot(IBinder token) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n            if (r != null && r.isActivityTypeHome()) {\n                mService.mWindowManager.mTaskSnapshotController.removeSnapshotCache(\n                        r.getTask().mTaskId);\n            }\n        }\n    }\n\n    @Override\n    public void dismissKeyguard(IBinder token, IKeyguardDismissCallback callback,\n            CharSequence message) {\n        if (message != null) {\n            mService.mAmInternal.enforceCallingPermission(\n                    android.Manifest.permission.SHOW_KEYGUARD_MESSAGE, \"dismissKeyguard\");\n        }\n        final long callingId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                mService.mKeyguardController.dismissKeyguard(token, callback, message);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(callingId);\n        }\n    }\n\n    @Override\n    public void registerRemoteAnimations(IBinder token, RemoteAnimationDefinition definition) {\n        mService.mAmInternal.enforceCallingPermission(CONTROL_REMOTE_APP_TRANSITION_ANIMATIONS,\n                \"registerRemoteAnimations\");\n        definition.setCallingPidUid(Binder.getCallingPid(), Binder.getCallingUid());\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r != null) {\n                    r.registerRemoteAnimations(definition);\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public void unregisterRemoteAnimations(IBinder token) {\n        mService.mAmInternal.enforceCallingPermission(CONTROL_REMOTE_APP_TRANSITION_ANIMATIONS,\n                \"unregisterRemoteAnimations\");\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r != null) {\n                    r.unregisterRemoteAnimations();\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public void onBackPressedOnTaskRoot(IBinder token, IRequestFinishCallback callback) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            final Intent baseActivityIntent;\n            final boolean launchedFromHome;\n\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r == null) return;\n\n                if (mService.mWindowOrganizerController.mTaskOrganizerController\n                        .handleInterceptBackPressedOnTaskRoot(r.getRootTask())) {\n                    // This task is handled by a task organizer that has requested the back pressed\n                    // callback.\n                    return;\n                }\n\n                final Intent baseIntent = r.getTask().getBaseIntent();\n                final boolean activityIsBaseActivity = baseIntent != null\n                        && r.mActivityComponent.equals(baseIntent.getComponent());\n                baseActivityIntent = activityIsBaseActivity ? r.intent : null;\n                launchedFromHome = r.isLaunchSourceType(ActivityRecord.LAUNCH_SOURCE_TYPE_HOME);\n            }\n\n            // If the activity is one of the main entry points for the application, then we should\n            // refrain from finishing the activity and instead move it to the back to keep it in\n            // memory. The requirements for this are:\n            //   1. The current activity is the base activity for the task.\n            //   2. a. If the activity was launched by the home process, we trust that its intent\n            //         was resolved, so we check if the it is a main intent for the application.\n            //      b. Otherwise, we query Package Manager to verify whether the activity is a\n            //         launcher activity for the application.\n            if (baseActivityIntent != null\n                    && ((launchedFromHome && ActivityRecord.isMainIntent(baseActivityIntent))\n                        || isLauncherActivity(baseActivityIntent.getComponent()))) {\n                moveActivityTaskToBack(token, false /* nonRoot */);\n                return;\n            }\n\n            // The default option for handling the back button is to finish the Activity.\n            try {\n                callback.requestFinish();\n            } catch (RemoteException e) {\n                Slog.e(TAG, \"Failed to invoke request finish callback\", e);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    /**\n     * Queries PackageManager to see if the given activity is one of the main entry point for the\n     * application. This should not be called with the WM lock held.\n     */\n    @SuppressWarnings(\"unchecked\")\n    private boolean isLauncherActivity(@NonNull ComponentName activity) {\n        final Intent queryIntent = new Intent(Intent.ACTION_MAIN);\n        queryIntent.addCategory(Intent.CATEGORY_LAUNCHER);\n        queryIntent.setPackage(activity.getPackageName());\n        try {\n            final ParceledListSlice<ResolveInfo> resolved =\n                    mService.getPackageManager().queryIntentActivities(\n                            queryIntent, null, 0, mContext.getUserId());\n            if (resolved == null) return false;\n            for (final ResolveInfo ri : resolved.getList()) {\n                if (ri.getComponentInfo().getComponentName().equals(activity)) {\n                    return true;\n                }\n            }\n        } catch (RemoteException e) {\n            Slog.e(TAG, \"Failed to query intent activities\", e);\n        }\n        return false;\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 10076,
                                        "general": {
                                            "word_based": 4161,
                                            "char_based": 13083
                                        },
                                        "gemini": 11836
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "8d814cc3b2fc94c8c47861abbcb3cec72aceb07e",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 8d814cc3b2fc94c8c47861abbcb3cec72aceb07e\nAuthor: Hongwei Wang <hwwang@google.com>\nDate:   Tue Aug 1 16:00:31 2023 -0700\n\n    Rate limiting PiP aspect ratio change request\n    \n    Using CountQuotaTrack to limit how frequent an app can request aspect\n    ratio change via PictureInPictureParams, which could result flood of PiP\n    resizing requests and freeze the PiP window.\n    \n    Note that CountQuotaTrack is initialized out of the WM lock to avoid\n    dead lock with the AM one.\n    \n    Bug: 283103220\n    Test: Manually, using the POC app\n    Test: Manually, switching YT PiP video functions at a regular rate\n    Test: atest WindowOrganizerTests ActivityThreadTest\n    Merged-In: Icb7dd17bbf7df573a9bb28f3dc56e90e78384f4f\n    Change-Id: Icb7dd17bbf7df573a9bb28f3dc56e90e78384f4f\n\ndiff --git a/services/core/java/com/android/server/wm/ActivityClientController.java b/services/core/java/com/android/server/wm/ActivityClientController.java\nindex f6748de660e2..d05c0d66a3d2 100644\n--- a/services/core/java/com/android/server/wm/ActivityClientController.java\n+++ b/services/core/java/com/android/server/wm/ActivityClientController.java\n@@ -80,6 +80,7 @@ import android.view.RemoteAnimationDefinition;\n import android.window.SizeConfigurationBuckets;\n import android.window.TransitionInfo;\n \n+import com.android.internal.annotations.VisibleForTesting;\n import com.android.internal.app.AssistUtils;\n import com.android.internal.policy.IKeyguardDismissCallback;\n import com.android.internal.protolog.common.ProtoLog;\n@@ -88,6 +89,9 @@ import com.android.server.Watchdog;\n import com.android.server.pm.KnownPackages;\n import com.android.server.pm.parsing.pkg.AndroidPackage;\n import com.android.server.uri.NeededUriGrants;\n+import com.android.server.utils.quota.Categorizer;\n+import com.android.server.utils.quota.Category;\n+import com.android.server.utils.quota.CountQuotaTracker;\n import com.android.server.vr.VrManagerInternal;\n \n /**\n@@ -103,6 +107,13 @@ class ActivityClientController extends IActivityClientController.Stub {\n     private final ActivityTaskSupervisor mTaskSupervisor;\n     private final Context mContext;\n \n+    // Prevent malicious app abusing the Activity#setPictureInPictureParams API\n+    @VisibleForTesting CountQuotaTracker mSetPipAspectRatioQuotaTracker;\n+    // Limit to 60 times / minute\n+    private static final int SET_PIP_ASPECT_RATIO_LIMIT = 60;\n+    // The timeWindowMs here can not be smaller than QuotaTracker#MIN_WINDOW_SIZE_MS\n+    private static final long SET_PIP_ASPECT_RATIO_TIME_WINDOW_MS = 60_000;\n+\n     /** Wrapper around VoiceInteractionServiceManager. */\n     private AssistUtils mAssistUtils;\n \n@@ -734,6 +745,7 @@ class ActivityClientController extends IActivityClientController.Stub {\n     public boolean enterPictureInPictureMode(IBinder token, final PictureInPictureParams params) {\n         final long origId = Binder.clearCallingIdentity();\n         try {\n+            ensureSetPipAspectRatioQuotaTracker();\n             synchronized (mGlobalLock) {\n                 final ActivityRecord r = ensureValidPictureInPictureActivityParams(\n                         \"enterPictureInPictureMode\", token, params);\n@@ -748,6 +760,7 @@ class ActivityClientController extends IActivityClientController.Stub {\n     public void setPictureInPictureParams(IBinder token, final PictureInPictureParams params) {\n         final long origId = Binder.clearCallingIdentity();\n         try {\n+            ensureSetPipAspectRatioQuotaTracker();\n             synchronized (mGlobalLock) {\n                 final ActivityRecord r = ensureValidPictureInPictureActivityParams(\n                         \"setPictureInPictureParams\", token, params);\n@@ -799,6 +812,19 @@ class ActivityClientController extends IActivityClientController.Stub {\n         }\n     }\n \n+    /**\n+     * Initialize the {@link #mSetPipAspectRatioQuotaTracker} if applicable, which should happen\n+     * out of {@link #mGlobalLock} to avoid deadlock (AM lock is used in QuotaTrack ctor).\n+     */\n+    private void ensureSetPipAspectRatioQuotaTracker() {\n+        if (mSetPipAspectRatioQuotaTracker == null) {\n+            mSetPipAspectRatioQuotaTracker = new CountQuotaTracker(mContext,\n+                    Categorizer.SINGLE_CATEGORIZER);\n+            mSetPipAspectRatioQuotaTracker.setCountLimit(Category.SINGLE_CATEGORY,\n+                    SET_PIP_ASPECT_RATIO_LIMIT, SET_PIP_ASPECT_RATIO_TIME_WINDOW_MS);\n+        }\n+    }\n+\n     /**\n      * Checks the state of the system and the activity associated with the given {@param token} to\n      * verify that picture-in-picture is supported for that activity.\n@@ -823,6 +849,19 @@ class ActivityClientController extends IActivityClientController.Stub {\n                     + \": Current activity does not support picture-in-picture.\");\n         }\n \n+        // Rate limit how frequent an app can request aspect ratio change via\n+        // Activity#setPictureInPictureParams\n+        final int userId = UserHandle.getCallingUserId();\n+        if (r.pictureInPictureArgs.hasSetAspectRatio()\n+                && params.hasSetAspectRatio()\n+                && !r.pictureInPictureArgs.getAspectRatio().equals(\n+                params.getAspectRatio())\n+                && !mSetPipAspectRatioQuotaTracker.noteEvent(\n+                userId, r.packageName, \"setPipAspectRatio\")) {\n+            throw new IllegalStateException(caller\n+                    + \": Too many PiP aspect ratio change requests from \" + r.packageName);\n+        }\n+\n         final float minAspectRatio = mContext.getResources().getFloat(\n                 com.android.internal.R.dimen.config_pictureInPictureMinAspectRatio);\n         final float maxAspectRatio = mContext.getResources().getFloat(\ndiff --git a/services/tests/wmtests/src/com/android/server/wm/WindowOrganizerTests.java b/services/tests/wmtests/src/com/android/server/wm/WindowOrganizerTests.java\nindex 40ca2506fab1..223cc25cf7f1 100644\n--- a/services/tests/wmtests/src/com/android/server/wm/WindowOrganizerTests.java\n+++ b/services/tests/wmtests/src/com/android/server/wm/WindowOrganizerTests.java\n@@ -1058,6 +1058,12 @@ public class WindowOrganizerTests extends WindowTestsBase {\n         assertNotNull(o.mInfo);\n         assertNotNull(o.mInfo.pictureInPictureParams);\n \n+        // Bypass the quota check, which causes NPE in current test setup.\n+        if (mWm.mAtmService.mActivityClientController.mSetPipAspectRatioQuotaTracker != null) {\n+            mWm.mAtmService.mActivityClientController.mSetPipAspectRatioQuotaTracker\n+                    .setEnabled(false);\n+        }\n+\n         final PictureInPictureParams p2 = new PictureInPictureParams.Builder()\n                 .setAspectRatio(new Rational(3, 4)).build();\n         mWm.mAtmService.mActivityClientController.setPictureInPictureParams(record.token, p2);\n",
                            "downstream_patch_tokens": {
                                "openai": 1593,
                                "general": {
                                    "word_based": 639,
                                    "char_based": 1703
                                },
                                "gemini": 1895
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "8d814cc3b2fc94c8c47861abbcb3cec72aceb07e",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 8d814cc3b2fc94c8c47861abbcb3cec72aceb07e\nAuthor: Hongwei Wang <hwwang@google.com>\nDate:   Tue Aug 1 16:00:31 2023 -0700\n\n    Rate limiting PiP aspect ratio change request\n    \n    Using CountQuotaTrack to limit how frequent an app can request aspect\n    ratio change via PictureInPictureParams, which could result flood of PiP\n    resizing requests and freeze the PiP window.\n    \n    Note that CountQuotaTrack is initialized out of the WM lock to avoid\n    dead lock with the AM one.\n    \n    Bug: 283103220\n    Test: Manually, using the POC app\n    Test: Manually, switching YT PiP video functions at a regular rate\n    Test: atest WindowOrganizerTests ActivityThreadTest\n    Merged-In: Icb7dd17bbf7df573a9bb28f3dc56e90e78384f4f\n    Change-Id: Icb7dd17bbf7df573a9bb28f3dc56e90e78384f4f\n\ndiff --git a/services/core/java/com/android/server/wm/ActivityClientController.java b/services/core/java/com/android/server/wm/ActivityClientController.java\nindex f6748de660e2..d05c0d66a3d2 100644\n--- a/services/core/java/com/android/server/wm/ActivityClientController.java\n+++ b/services/core/java/com/android/server/wm/ActivityClientController.java\n@@ -80,6 +80,7 @@ import android.view.RemoteAnimationDefinition;\n import android.window.SizeConfigurationBuckets;\n import android.window.TransitionInfo;\n \n+import com.android.internal.annotations.VisibleForTesting;\n import com.android.internal.app.AssistUtils;\n import com.android.internal.policy.IKeyguardDismissCallback;\n import com.android.internal.protolog.common.ProtoLog;\n@@ -88,6 +89,9 @@ import com.android.server.Watchdog;\n import com.android.server.pm.KnownPackages;\n import com.android.server.pm.parsing.pkg.AndroidPackage;\n import com.android.server.uri.NeededUriGrants;\n+import com.android.server.utils.quota.Categorizer;\n+import com.android.server.utils.quota.Category;\n+import com.android.server.utils.quota.CountQuotaTracker;\n import com.android.server.vr.VrManagerInternal;\n \n /**\n@@ -103,6 +107,13 @@ class ActivityClientController extends IActivityClientController.Stub {\n     private final ActivityTaskSupervisor mTaskSupervisor;\n     private final Context mContext;\n \n+    // Prevent malicious app abusing the Activity#setPictureInPictureParams API\n+    @VisibleForTesting CountQuotaTracker mSetPipAspectRatioQuotaTracker;\n+    // Limit to 60 times / minute\n+    private static final int SET_PIP_ASPECT_RATIO_LIMIT = 60;\n+    // The timeWindowMs here can not be smaller than QuotaTracker#MIN_WINDOW_SIZE_MS\n+    private static final long SET_PIP_ASPECT_RATIO_TIME_WINDOW_MS = 60_000;\n+\n     /** Wrapper around VoiceInteractionServiceManager. */\n     private AssistUtils mAssistUtils;\n \n@@ -734,6 +745,7 @@ class ActivityClientController extends IActivityClientController.Stub {\n     public boolean enterPictureInPictureMode(IBinder token, final PictureInPictureParams params) {\n         final long origId = Binder.clearCallingIdentity();\n         try {\n+            ensureSetPipAspectRatioQuotaTracker();\n             synchronized (mGlobalLock) {\n                 final ActivityRecord r = ensureValidPictureInPictureActivityParams(\n                         \"enterPictureInPictureMode\", token, params);\n@@ -748,6 +760,7 @@ class ActivityClientController extends IActivityClientController.Stub {\n     public void setPictureInPictureParams(IBinder token, final PictureInPictureParams params) {\n         final long origId = Binder.clearCallingIdentity();\n         try {\n+            ensureSetPipAspectRatioQuotaTracker();\n             synchronized (mGlobalLock) {\n                 final ActivityRecord r = ensureValidPictureInPictureActivityParams(\n                         \"setPictureInPictureParams\", token, params);\n@@ -799,6 +812,19 @@ class ActivityClientController extends IActivityClientController.Stub {\n         }\n     }\n \n+    /**\n+     * Initialize the {@link #mSetPipAspectRatioQuotaTracker} if applicable, which should happen\n+     * out of {@link #mGlobalLock} to avoid deadlock (AM lock is used in QuotaTrack ctor).\n+     */\n+    private void ensureSetPipAspectRatioQuotaTracker() {\n+        if (mSetPipAspectRatioQuotaTracker == null) {\n+            mSetPipAspectRatioQuotaTracker = new CountQuotaTracker(mContext,\n+                    Categorizer.SINGLE_CATEGORIZER);\n+            mSetPipAspectRatioQuotaTracker.setCountLimit(Category.SINGLE_CATEGORY,\n+                    SET_PIP_ASPECT_RATIO_LIMIT, SET_PIP_ASPECT_RATIO_TIME_WINDOW_MS);\n+        }\n+    }\n+\n     /**\n      * Checks the state of the system and the activity associated with the given {@param token} to\n      * verify that picture-in-picture is supported for that activity.\n@@ -823,6 +849,19 @@ class ActivityClientController extends IActivityClientController.Stub {\n                     + \": Current activity does not support picture-in-picture.\");\n         }\n \n+        // Rate limit how frequent an app can request aspect ratio change via\n+        // Activity#setPictureInPictureParams\n+        final int userId = UserHandle.getCallingUserId();\n+        if (r.pictureInPictureArgs.hasSetAspectRatio()\n+                && params.hasSetAspectRatio()\n+                && !r.pictureInPictureArgs.getAspectRatio().equals(\n+                params.getAspectRatio())\n+                && !mSetPipAspectRatioQuotaTracker.noteEvent(\n+                userId, r.packageName, \"setPipAspectRatio\")) {\n+            throw new IllegalStateException(caller\n+                    + \": Too many PiP aspect ratio change requests from \" + r.packageName);\n+        }\n+\n         final float minAspectRatio = mContext.getResources().getFloat(\n                 com.android.internal.R.dimen.config_pictureInPictureMinAspectRatio);\n         final float maxAspectRatio = mContext.getResources().getFloat(\ndiff --git a/services/tests/wmtests/src/com/android/server/wm/WindowOrganizerTests.java b/services/tests/wmtests/src/com/android/server/wm/WindowOrganizerTests.java\nindex 40ca2506fab1..223cc25cf7f1 100644\n--- a/services/tests/wmtests/src/com/android/server/wm/WindowOrganizerTests.java\n+++ b/services/tests/wmtests/src/com/android/server/wm/WindowOrganizerTests.java\n@@ -1058,6 +1058,12 @@ public class WindowOrganizerTests extends WindowTestsBase {\n         assertNotNull(o.mInfo);\n         assertNotNull(o.mInfo.pictureInPictureParams);\n \n+        // Bypass the quota check, which causes NPE in current test setup.\n+        if (mWm.mAtmService.mActivityClientController.mSetPipAspectRatioQuotaTracker != null) {\n+            mWm.mAtmService.mActivityClientController.mSetPipAspectRatioQuotaTracker\n+                    .setEnabled(false);\n+        }\n+\n         final PictureInPictureParams p2 = new PictureInPictureParams.Builder()\n                 .setAspectRatio(new Rational(3, 4)).build();\n         mWm.mAtmService.mActivityClientController.setPictureInPictureParams(record.token, p2);\n",
                            "downstream_patch_tokens": {
                                "openai": 1593,
                                "general": {
                                    "word_based": 639,
                                    "char_based": 1703
                                },
                                "gemini": 1895
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-299931761",
            "aliases": [
                "A-299931761",
                "CVE-2024-23704"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-299931761",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "51fa3d798ad0397122bbb2143bc24efe1a705be9"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 51fa3d798ad0397122bbb2143bc24efe1a705be9 Mon Sep 17 00:00:00 2001\nFrom: Weng Su <wengsu@google.com>\nDate: Fri, 26 Jan 2024 17:59:40 +0800\nSubject: [PATCH] Restrict WifiDialogActivity\n\n- Don't show WifiDialogActivity if user has DISALLOW_ADD_WIFI_CONFIG\n\nFix: 299931761\nBug: 314867581\nFlag: None\nTest: manual test with TestDPC\natest -c SettingsRoboTests:WifiDialogActivityTest\n\nChange-Id: Icbb8f45922ded163208976be9c2816060dcf09f1\n---\n .../settings/wifi/WifiDialogActivity.java       | 13 ++++++++++++-\n .../settings/wifi/WifiDialogActivityTest.java   | 17 +++++++++++++++--\n 2 files changed, 27 insertions(+), 3 deletions(-)\n\ndiff --git a/src/com/android/settings/wifi/WifiDialogActivity.java b/src/com/android/settings/wifi/WifiDialogActivity.java\nindex 7e901c27ba6..eb3d88a9668 100644\n--- a/src/com/android/settings/wifi/WifiDialogActivity.java\n+++ b/src/com/android/settings/wifi/WifiDialogActivity.java\n@@ -17,6 +17,7 @@\n package com.android.settings.wifi;\n \n import static android.Manifest.permission.ACCESS_FINE_LOCATION;\n+import static android.os.UserManager.DISALLOW_ADD_WIFI_CONFIG;\n import static android.os.UserManager.DISALLOW_CONFIG_WIFI;\n \n import android.app.KeyguardManager;\n@@ -122,7 +123,7 @@ public class WifiDialogActivity extends ObservableActivity implements WifiDialog\n         }\n \n         super.onCreate(savedInstanceState);\n-        if (!isConfigWifiAllowed()) {\n+        if (!isConfigWifiAllowed() || !isAddWifiConfigAllowed()) {\n             finish();\n             return;\n         }\n@@ -393,6 +394,16 @@ public class WifiDialogActivity extends ObservableActivity implements WifiDialog\n         return isConfigWifiAllowed;\n     }\n \n+    @VisibleForTesting\n+    boolean isAddWifiConfigAllowed() {\n+        UserManager userManager = getSystemService(UserManager.class);\n+        if (userManager != null && userManager.hasUserRestriction(DISALLOW_ADD_WIFI_CONFIG)) {\n+            Log.e(TAG, \"The user is not allowed to add Wi-Fi configuration.\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n     private boolean hasWifiManager() {\n         if (mWifiManager != null) return true;\n         mWifiManager = getSystemService(WifiManager.class);\ndiff --git a/tests/robotests/src/com/android/settings/wifi/WifiDialogActivityTest.java b/tests/robotests/src/com/android/settings/wifi/WifiDialogActivityTest.java\nindex ff0395db72f..d1cbd0ee1b7 100644\n--- a/tests/robotests/src/com/android/settings/wifi/WifiDialogActivityTest.java\n+++ b/tests/robotests/src/com/android/settings/wifi/WifiDialogActivityTest.java\n@@ -18,6 +18,7 @@ package com.android.settings.wifi;\n \n import static android.Manifest.permission.ACCESS_COARSE_LOCATION;\n import static android.Manifest.permission.ACCESS_FINE_LOCATION;\n+import static android.os.UserManager.DISALLOW_ADD_WIFI_CONFIG;\n import static android.os.UserManager.DISALLOW_CONFIG_WIFI;\n \n import static com.android.settings.wifi.WifiDialogActivity.REQUEST_CODE_WIFI_DPP_ENROLLEE_QR_CODE_SCANNER;\n@@ -50,7 +51,6 @@ import com.android.wifitrackerlib.WifiEntry;\n import com.google.android.setupcompat.util.WizardManagerHelper;\n \n import org.junit.Before;\n-import org.junit.Ignore;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.mockito.Mock;\n@@ -58,7 +58,6 @@ import org.mockito.MockitoAnnotations;\n import org.robolectric.Robolectric;\n import org.robolectric.RobolectricTestRunner;\n \n-@Ignore(\"b/314867581\")\n @RunWith(RobolectricTestRunner.class)\n public class WifiDialogActivityTest {\n \n@@ -242,6 +241,20 @@ public class WifiDialogActivityTest {\n         assertThat(mActivity.isConfigWifiAllowed()).isFalse();\n     }\n \n+    @Test\n+    public void isAddWifiConfigAllowed_hasNoUserRestriction_returnTrue() {\n+        when(mUserManager.hasUserRestriction(DISALLOW_ADD_WIFI_CONFIG)).thenReturn(false);\n+\n+        assertThat(mActivity.isAddWifiConfigAllowed()).isTrue();\n+    }\n+\n+    @Test\n+    public void isAddWifiConfigAllowed_hasUserRestriction_returnFalse() {\n+        when(mUserManager.hasUserRestriction(DISALLOW_ADD_WIFI_CONFIG)).thenReturn(true);\n+\n+        assertThat(mActivity.isAddWifiConfigAllowed()).isFalse();\n+    }\n+\n     @Test\n     public void hasPermissionForResult_noCallingPackage_returnFalse() {\n         when(mActivity.getCallingPackage()).thenReturn(null);\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 1068,
                        "general": {
                            "word_based": 420,
                            "char_based": 1077
                        },
                        "gemini": 1393
                    },
                    "total_downstream_versions_tested": 2,
                    "successful_patches": 1,
                    "failed_patches": 1,
                    "patch_results": [
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "aabb15de74d4d24a81ed1f5b7789fe0a8407b256",
                            "repo_path": "android_repos/Settings",
                            "result": "failure",
                            "downstream_patch_content": "commit aabb15de74d4d24a81ed1f5b7789fe0a8407b256\nAuthor: Weng Su <wengsu@google.com>\nDate:   Fri Jan 26 17:59:40 2024 +0800\n\n    [RESTRICT AUTOMERGE] Restrict WifiDialogActivity\n    \n    - Don't show WifiDialogActivity if user has DISALLOW_ADD_WIFI_CONFIG\n    \n    Bug: 299931761\n    Flag: None\n    Test: manual test with TestDPC\n    atest -c SettingsRoboTests:WifiDialogActivityTest\n    \n    Merged-In: Icbb8f45922ded163208976be9c2816060dcf09f1\n    Change-Id: Icbb8f45922ded163208976be9c2816060dcf09f1\n    (cherry picked from commit 51fa3d798ad0397122bbb2143bc24efe1a705be9)\n\ndiff --git a/src/com/android/settings/wifi/WifiDialogActivity.java b/src/com/android/settings/wifi/WifiDialogActivity.java\nindex 67f291da49d..ca7d80f8999 100644\n--- a/src/com/android/settings/wifi/WifiDialogActivity.java\n+++ b/src/com/android/settings/wifi/WifiDialogActivity.java\n@@ -17,6 +17,8 @@\n package com.android.settings.wifi;\n \n import static android.Manifest.permission.ACCESS_FINE_LOCATION;\n+import static android.os.UserManager.DISALLOW_ADD_WIFI_CONFIG;\n+import static android.os.UserManager.DISALLOW_CONFIG_WIFI;\n \n import android.content.DialogInterface;\n import android.content.Intent;\n@@ -31,6 +33,7 @@ import android.os.Looper;\n import android.os.Process;\n import android.os.SimpleClock;\n import android.os.SystemClock;\n+import android.os.UserManager;\n import android.text.TextUtils;\n import android.util.EventLog;\n import android.util.Log;\n@@ -115,6 +118,10 @@ public class WifiDialogActivity extends ObservableActivity implements WifiDialog\n         }\n \n         super.onCreate(savedInstanceState);\n+        if (!isConfigWifiAllowed() || !isAddWifiConfigAllowed()) {\n+            finish();\n+            return;\n+        }\n \n         mIsWifiTrackerLib = !TextUtils.isEmpty(mIntent.getStringExtra(KEY_CHOSEN_WIFIENTRY_KEY));\n \n@@ -361,6 +368,29 @@ public class WifiDialogActivity extends ObservableActivity implements WifiDialog\n         }\n     }\n \n+    @VisibleForTesting\n+    boolean isConfigWifiAllowed() {\n+        UserManager userManager = getSystemService(UserManager.class);\n+        if (userManager == null) return true;\n+        final boolean isConfigWifiAllowed = !userManager.hasUserRestriction(DISALLOW_CONFIG_WIFI);\n+        if (!isConfigWifiAllowed) {\n+            Log.e(TAG, \"The user is not allowed to configure Wi-Fi.\");\n+            EventLog.writeEvent(0x534e4554, \"226133034\", getApplicationContext().getUserId(),\n+                    \"The user is not allowed to configure Wi-Fi.\");\n+        }\n+        return isConfigWifiAllowed;\n+    }\n+\n+    @VisibleForTesting\n+    boolean isAddWifiConfigAllowed() {\n+        UserManager userManager = getSystemService(UserManager.class);\n+        if (userManager != null && userManager.hasUserRestriction(DISALLOW_ADD_WIFI_CONFIG)) {\n+            Log.e(TAG, \"The user is not allowed to add Wi-Fi configuration.\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n     private boolean hasWifiManager() {\n         if (mWifiManager != null) return true;\n         mWifiManager = getSystemService(WifiManager.class);\ndiff --git a/tests/robotests/src/com/android/settings/wifi/WifiDialogActivityTest.java b/tests/robotests/src/com/android/settings/wifi/WifiDialogActivityTest.java\nindex 4ceb1e3b002..97cf783e2e2 100644\n--- a/tests/robotests/src/com/android/settings/wifi/WifiDialogActivityTest.java\n+++ b/tests/robotests/src/com/android/settings/wifi/WifiDialogActivityTest.java\n@@ -18,6 +18,8 @@ package com.android.settings.wifi;\n \n import static android.Manifest.permission.ACCESS_COARSE_LOCATION;\n import static android.Manifest.permission.ACCESS_FINE_LOCATION;\n+import static android.os.UserManager.DISALLOW_ADD_WIFI_CONFIG;\n+import static android.os.UserManager.DISALLOW_CONFIG_WIFI;\n \n import static com.android.settings.wifi.WifiDialogActivity.REQUEST_CODE_WIFI_DPP_ENROLLEE_QR_CODE_SCANNER;\n import static com.android.settings.wifi.WifiDialogActivity.RESULT_CONNECTED;\n@@ -36,6 +38,7 @@ import android.content.Intent;\n import android.content.pm.PackageManager;\n import android.net.wifi.WifiConfiguration;\n import android.net.wifi.WifiManager;\n+import android.os.UserManager;\n \n import com.android.settings.testutils.FakeFeatureFactory;\n import com.android.settingslib.wifi.AccessPoint;\n@@ -57,6 +60,8 @@ public class WifiDialogActivityTest {\n     static final String CALLING_PACKAGE = \"calling_package\";\n     static final int REQUEST_CODE = REQUEST_CODE_WIFI_DPP_ENROLLEE_QR_CODE_SCANNER;\n \n+    @Mock\n+    UserManager mUserManager;\n     @Mock\n     PackageManager mPackageManager;\n     @Mock\n@@ -92,6 +97,7 @@ public class WifiDialogActivityTest {\n         FakeFeatureFactory.setupForTest();\n \n         mActivity = spy(Robolectric.setupActivity(WifiDialogActivity.class));\n+        when(mActivity.getSystemService(UserManager.class)).thenReturn(mUserManager);\n         when(mActivity.getSystemService(WifiManager.class)).thenReturn(mWifiManager);\n     }\n \n@@ -211,6 +217,34 @@ public class WifiDialogActivityTest {\n         verify(mActivity).setResult(RESULT_CONNECTED, mResultData);\n     }\n \n+    @Test\n+    public void isConfigWifiAllowed_hasNoUserRestriction_returnTrue() {\n+        when(mUserManager.hasUserRestriction(DISALLOW_CONFIG_WIFI)).thenReturn(false);\n+\n+        assertThat(mActivity.isConfigWifiAllowed()).isTrue();\n+    }\n+\n+    @Test\n+    public void isConfigWifiAllowed_hasUserRestriction_returnFalse() {\n+        when(mUserManager.hasUserRestriction(DISALLOW_CONFIG_WIFI)).thenReturn(true);\n+\n+        assertThat(mActivity.isConfigWifiAllowed()).isFalse();\n+    }\n+\n+    @Test\n+    public void isAddWifiConfigAllowed_hasNoUserRestriction_returnTrue() {\n+        when(mUserManager.hasUserRestriction(DISALLOW_ADD_WIFI_CONFIG)).thenReturn(false);\n+\n+        assertThat(mActivity.isAddWifiConfigAllowed()).isTrue();\n+    }\n+\n+    @Test\n+    public void isAddWifiConfigAllowed_hasUserRestriction_returnFalse() {\n+        when(mUserManager.hasUserRestriction(DISALLOW_ADD_WIFI_CONFIG)).thenReturn(true);\n+\n+        assertThat(mActivity.isAddWifiConfigAllowed()).isFalse();\n+    }\n+\n     @Test\n     public void hasPermissionForResult_noCallingPackage_returnFalse() {\n         when(mActivity.getCallingPackage()).thenReturn(null);\n",
                            "downstream_patch_tokens": {
                                "openai": 1485,
                                "general": {
                                    "word_based": 555,
                                    "char_based": 1553
                                },
                                "gemini": 1924
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "src/com/android/settings/wifi/WifiDialogActivity.java",
                                    "total_hunks": 3,
                                    "failed_hunks": [
                                        1,
                                        2
                                    ],
                                    "inline_merge_conflicts": [],
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    },
                                    "rej_file_content": "```diff\n--- src/com/android/settings/wifi/WifiDialogActivity.java\n+++ src/com/android/settings/wifi/WifiDialogActivity.java\n@@ -17,6 +17,7 @@\n package com.android.settings.wifi;\n \n import static android.Manifest.permission.ACCESS_FINE_LOCATION;\n+import static android.os.UserManager.DISALLOW_ADD_WIFI_CONFIG;\n import static android.os.UserManager.DISALLOW_CONFIG_WIFI;\n \n import android.app.KeyguardManager;\n@@ -122,7 +123,7 @@ public class WifiDialogActivity extends ObservableActivity implements WifiDialog\n         }\n \n         super.onCreate(savedInstanceState);\n-        if (!isConfigWifiAllowed()) {\n+        if (!isConfigWifiAllowed() || !isAddWifiConfigAllowed()) {\n             finish();\n             return;\n         }\n```",
                                    "rej_file_tokens": {
                                        "openai": 151,
                                        "general": {
                                            "word_based": 66,
                                            "char_based": 180
                                        },
                                        "gemini": 202
                                    },
                                    "patch_apply_output": "patching file src/com/android/settings/wifi/WifiDialogActivity.java\nHunk #1 FAILED at 17.\nHunk #2 FAILED at 122.\nHunk #3 succeeded at 361 with fuzz 1 (offset -32 lines).\n2 out of 3 hunks FAILED -- saving rejects to file src/com/android/settings/wifi/WifiDialogActivity.java.rej",
                                    "inline_merge_output": "patching file src/com/android/settings/wifi/WifiDialogActivity.java\nHunk #1 already applied at 20.\nHunk #2 already applied at 126.\nHunk #3 merged at 407-416.",
                                    "upstream_file_tokens": {
                                        "openai": 3639,
                                        "general": {
                                            "word_based": 1431,
                                            "char_based": 4528
                                        },
                                        "gemini": 4419
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2015 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.wifi;\n\nimport static android.Manifest.permission.ACCESS_FINE_LOCATION;\n\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.pm.PackageManager;\nimport android.net.NetworkInfo;\nimport android.net.wifi.WifiConfiguration;\nimport android.net.wifi.WifiManager;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.HandlerThread;\nimport android.os.Looper;\nimport android.os.Process;\nimport android.os.SimpleClock;\nimport android.os.SystemClock;\nimport android.text.TextUtils;\nimport android.util.EventLog;\nimport android.util.Log;\n\nimport androidx.annotation.VisibleForTesting;\n\nimport com.android.settings.R;\nimport com.android.settings.SetupWizardUtils;\nimport com.android.settings.overlay.FeatureFactory;\nimport com.android.settings.wifi.dpp.WifiDppUtils;\nimport com.android.settingslib.core.lifecycle.ObservableActivity;\nimport com.android.settingslib.wifi.AccessPoint;\nimport com.android.wifitrackerlib.NetworkDetailsTracker;\nimport com.android.wifitrackerlib.WifiEntry;\n\nimport com.google.android.setupcompat.util.WizardManagerHelper;\nimport com.google.android.setupdesign.util.ThemeHelper;\n\nimport java.time.Clock;\nimport java.time.ZoneOffset;\n\n/**\n * The activity shows a Wi-fi editor dialog.\n *\n * TODO(b/152571756): This activity supports both WifiTrackerLib and SettingsLib because this is an\n *                    exported UI component, some other APPs (e.g., SetupWizard) still use\n *                    SettingsLib. Remove the SettingsLib compatible part after these APPs use\n *                    WifiTrackerLib.\n */\npublic class WifiDialogActivity extends ObservableActivity implements WifiDialog.WifiDialogListener,\n        WifiDialog2.WifiDialog2Listener, DialogInterface.OnDismissListener {\n\n    private static final String TAG = \"WifiDialogActivity\";\n\n    // For the callers which support WifiTrackerLib.\n    public static final String KEY_CHOSEN_WIFIENTRY_KEY = \"key_chosen_wifientry_key\";\n\n    // For the callers which support SettingsLib.\n    public static final String KEY_ACCESS_POINT_STATE = \"access_point_state\";\n\n    /**\n     * Boolean extra indicating whether this activity should connect to an access point on the\n     * caller's behalf. If this is set to false, the caller should check\n     * {@link #KEY_WIFI_CONFIGURATION} in the result data and save that using\n     * {@link WifiManager#connect(WifiConfiguration, ActionListener)}. Default is true.\n     */\n    @VisibleForTesting\n    static final String KEY_CONNECT_FOR_CALLER = \"connect_for_caller\";\n\n    public static final String KEY_WIFI_CONFIGURATION = \"wifi_configuration\";\n\n    @VisibleForTesting\n    static final int RESULT_CONNECTED = RESULT_FIRST_USER;\n    private static final int RESULT_FORGET = RESULT_FIRST_USER + 1;\n\n    @VisibleForTesting\n    static final int REQUEST_CODE_WIFI_DPP_ENROLLEE_QR_CODE_SCANNER = 0;\n\n    // Max age of tracked WifiEntries.\n    private static final long MAX_SCAN_AGE_MILLIS = 15_000;\n    // Interval between initiating NetworkDetailsTracker scans.\n    private static final long SCAN_INTERVAL_MILLIS = 10_000;\n\n    private WifiDialog mDialog;\n    private AccessPoint mAccessPoint;\n\n    private WifiDialog2 mDialog2;\n\n    // The received intent supports a key of WifiTrackerLib or SettingsLib.\n    private boolean mIsWifiTrackerLib;\n\n    private Intent mIntent;\n    private NetworkDetailsTracker mNetworkDetailsTracker;\n    private HandlerThread mWorkerThread;\n    private WifiManager mWifiManager;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        mIntent = getIntent();\n        if (WizardManagerHelper.isSetupWizardIntent(mIntent)) {\n            setTheme(SetupWizardUtils.getTransparentTheme(this, mIntent));\n        }\n\n        super.onCreate(savedInstanceState);\n\n        mIsWifiTrackerLib = !TextUtils.isEmpty(mIntent.getStringExtra(KEY_CHOSEN_WIFIENTRY_KEY));\n\n        if (mIsWifiTrackerLib) {\n            mWorkerThread = new HandlerThread(\n                    TAG + \"{\" + Integer.toHexString(System.identityHashCode(this)) + \"}\",\n                    Process.THREAD_PRIORITY_BACKGROUND);\n            mWorkerThread.start();\n            final Clock elapsedRealtimeClock = new SimpleClock(ZoneOffset.UTC) {\n                @Override\n                public long millis() {\n                    return SystemClock.elapsedRealtime();\n                }\n            };\n            mNetworkDetailsTracker = FeatureFactory.getFactory(this)\n                    .getWifiTrackerLibProvider()\n                    .createNetworkDetailsTracker(\n                            getLifecycle(),\n                            this,\n                            new Handler(Looper.getMainLooper()),\n                            mWorkerThread.getThreadHandler(),\n                            elapsedRealtimeClock,\n                            MAX_SCAN_AGE_MILLIS,\n                            SCAN_INTERVAL_MILLIS,\n                            mIntent.getStringExtra(KEY_CHOSEN_WIFIENTRY_KEY));\n        } else {\n            final Bundle accessPointState = mIntent.getBundleExtra(KEY_ACCESS_POINT_STATE);\n            if (accessPointState != null) {\n                mAccessPoint = new AccessPoint(this, accessPointState);\n            }\n        }\n    }\n\n    @Override\n    protected void onStart() {\n        super.onStart();\n        if (mDialog2 != null || mDialog != null || !hasWifiManager()) {\n            return;\n        }\n\n        if (WizardManagerHelper.isAnySetupWizard(getIntent())) {\n            createDialogWithSuwTheme();\n        } else {\n            if (mIsWifiTrackerLib) {\n                mDialog2 = WifiDialog2.createModal(this, this,\n                        mNetworkDetailsTracker.getWifiEntry(), WifiConfigUiBase2.MODE_CONNECT);\n            } else {\n                mDialog = WifiDialog.createModal(\n                        this, this, mAccessPoint, WifiConfigUiBase.MODE_CONNECT);\n            }\n        }\n\n        if (mIsWifiTrackerLib) {\n            if (mDialog2 != null) {\n                mDialog2.show();\n                mDialog2.setOnDismissListener(this);\n            }\n        } else {\n            if (mDialog != null) {\n                mDialog.show();\n                mDialog.setOnDismissListener(this);\n            }\n        }\n    }\n\n    @VisibleForTesting\n    protected void createDialogWithSuwTheme() {\n        final int targetStyle = ThemeHelper.isSetupWizardDayNightEnabled(this)\n                ? R.style.SuwAlertDialogThemeCompat_DayNight :\n                R.style.SuwAlertDialogThemeCompat_Light;\n        if (mIsWifiTrackerLib) {\n            mDialog2 = WifiDialog2.createModal(this, this,\n                    mNetworkDetailsTracker.getWifiEntry(),\n                    WifiConfigUiBase2.MODE_CONNECT, targetStyle);\n        } else {\n            mDialog = WifiDialog.createModal(this, this, mAccessPoint,\n                    WifiConfigUiBase.MODE_CONNECT, targetStyle);\n        }\n    }\n\n    @Override\n    public void finish() {\n        overridePendingTransition(0, 0);\n\n        super.finish();\n    }\n\n    @Override\n    public void onDestroy() {\n        if (mIsWifiTrackerLib) {\n            if (mDialog2 != null && mDialog2.isShowing()) {\n                mDialog2 = null;\n            }\n            mWorkerThread.quit();\n        } else {\n            if (mDialog != null && mDialog.isShowing()) {\n                mDialog = null;\n            }\n        }\n\n        super.onDestroy();\n    }\n\n    @Override\n    public void onForget(WifiDialog2 dialog) {\n        final WifiEntry wifiEntry = dialog.getController().getWifiEntry();\n        if (wifiEntry != null && wifiEntry.canForget()) {\n            wifiEntry.forget(null /* callback */);\n        }\n\n        setResult(RESULT_FORGET);\n        finish();\n    }\n\n    @Override\n    public void onForget(WifiDialog dialog) {\n        if (!hasWifiManager()) return;\n        final AccessPoint accessPoint = dialog.getController().getAccessPoint();\n        if (accessPoint != null) {\n            if (!accessPoint.isSaved()) {\n                if (accessPoint.getNetworkInfo() != null &&\n                        accessPoint.getNetworkInfo().getState() != NetworkInfo.State.DISCONNECTED) {\n                    // Network is active but has no network ID - must be ephemeral.\n                    mWifiManager.disableEphemeralNetwork(\n                            AccessPoint.convertToQuotedString(accessPoint.getSsidStr()));\n                } else {\n                    // Should not happen, but a monkey seems to trigger it\n                    Log.e(TAG, \"Failed to forget invalid network \" + accessPoint.getConfig());\n                }\n            } else {\n                mWifiManager.forget(accessPoint.getConfig().networkId, null /* listener */);\n            }\n        }\n\n        Intent resultData = new Intent();\n        if (accessPoint != null) {\n            Bundle accessPointState = new Bundle();\n            accessPoint.saveWifiState(accessPointState);\n            resultData.putExtra(KEY_ACCESS_POINT_STATE, accessPointState);\n        }\n        setResult(RESULT_FORGET);\n        finish();\n    }\n\n    @Override\n    public void onSubmit(WifiDialog2 dialog) {\n        if (!hasWifiManager()) return;\n        final WifiEntry wifiEntry = dialog.getController().getWifiEntry();\n        final WifiConfiguration config = dialog.getController().getConfig();\n\n        if (getIntent().getBooleanExtra(KEY_CONNECT_FOR_CALLER, true)) {\n            if (config == null && wifiEntry != null && wifiEntry.canConnect()) {\n                wifiEntry.connect(null /* callback */);\n            } else {\n                mWifiManager.connect(config, null /* listener */);\n            }\n        }\n\n        Intent resultData = hasPermissionForResult() ? createResultData(config, null) : null;\n        setResult(RESULT_CONNECTED, resultData);\n        finish();\n    }\n\n    @Override\n    public void onSubmit(WifiDialog dialog) {\n        if (!hasWifiManager()) return;\n        final WifiConfiguration config = dialog.getController().getConfig();\n        final AccessPoint accessPoint = dialog.getController().getAccessPoint();\n\n        if (getIntent().getBooleanExtra(KEY_CONNECT_FOR_CALLER, true)) {\n            if (config == null) {\n                if (accessPoint != null && accessPoint.isSaved()) {\n                    mWifiManager.connect(accessPoint.getConfig(), null /* listener */);\n                }\n            } else {\n                mWifiManager.save(config, null /* listener */);\n                if (accessPoint != null) {\n                    // accessPoint is null for \"Add network\"\n                    NetworkInfo networkInfo = accessPoint.getNetworkInfo();\n                    if (networkInfo == null || !networkInfo.isConnected()) {\n                        mWifiManager.connect(config, null /* listener */);\n                    }\n                }\n            }\n        }\n\n        Intent resultData = hasPermissionForResult() ? createResultData(config, accessPoint) : null;\n        setResult(RESULT_CONNECTED, resultData);\n        finish();\n    }\n\n    protected Intent createResultData(WifiConfiguration config, AccessPoint accessPoint) {\n        Intent result = new Intent();\n        if (accessPoint != null) {\n            Bundle accessPointState = new Bundle();\n            accessPoint.saveWifiState(accessPointState);\n            result.putExtra(KEY_ACCESS_POINT_STATE, accessPointState);\n        }\n        if (config != null) {\n            result.putExtra(KEY_WIFI_CONFIGURATION, config);\n        }\n        return result;\n    }\n\n    @Override\n    public void onDismiss(DialogInterface dialogInterface) {\n        mDialog2 = null;\n        mDialog = null;\n        finish();\n    }\n\n    @Override\n    public void onScan(WifiDialog2 dialog, String ssid) {\n        Intent intent = WifiDppUtils.getEnrolleeQrCodeScannerIntent(dialog.getContext(), ssid);\n        WizardManagerHelper.copyWizardManagerExtras(mIntent, intent);\n\n        // Launch QR code scanner to join a network.\n        startActivityForResult(intent, REQUEST_CODE_WIFI_DPP_ENROLLEE_QR_CODE_SCANNER);\n    }\n\n    @Override\n    public void onScan(WifiDialog dialog, String ssid) {\n        Intent intent = WifiDppUtils.getEnrolleeQrCodeScannerIntent(dialog.getContext(), ssid);\n        WizardManagerHelper.copyWizardManagerExtras(mIntent, intent);\n\n        // Launch QR code scanner to join a network.\n        startActivityForResult(intent, REQUEST_CODE_WIFI_DPP_ENROLLEE_QR_CODE_SCANNER);\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n\n        if (requestCode == REQUEST_CODE_WIFI_DPP_ENROLLEE_QR_CODE_SCANNER) {\n            if (resultCode != RESULT_OK) {\n                return;\n            }\n            if (hasPermissionForResult()) {\n                setResult(RESULT_CONNECTED, data);\n            } else {\n                setResult(RESULT_CONNECTED);\n            }\n            finish();\n        }\n    }\n\n    @VisibleForTesting\n    boolean isAddWifiConfigAllowed() {\n        UserManager userManager = getSystemService(UserManager.class);\n        if (userManager != null && userManager.hasUserRestriction(DISALLOW_ADD_WIFI_CONFIG)) {\n            Log.e(TAG, \"The user is not allowed to add Wi-Fi configuration.\");\n            return false;\n        }\n        return true;\n    }\n\n    private boolean hasWifiManager() {\n        if (mWifiManager != null) return true;\n        mWifiManager = getSystemService(WifiManager.class);\n        return (mWifiManager != null);\n    }\n\n    protected boolean hasPermissionForResult() {\n        final String callingPackage = getCallingPackage();\n        if (callingPackage == null) {\n            Log.d(TAG, \"Failed to get the calling package, don't return the result.\");\n            EventLog.writeEvent(0x534e4554, \"185126813\", -1 /* UID */, \"no calling package\");\n            return false;\n        }\n\n        if (getPackageManager().checkPermission(ACCESS_FINE_LOCATION, callingPackage)\n                == PackageManager.PERMISSION_GRANTED) {\n            Log.d(TAG, \"The calling package has ACCESS_FINE_LOCATION permission for result.\");\n            return true;\n        }\n\n        Log.d(TAG, \"The calling package does not have the necessary permissions for result.\");\n        try {\n            EventLog.writeEvent(0x534e4554, \"185126813\",\n                    getPackageManager().getPackageUid(callingPackage, 0 /* flags */),\n                    \"no permission\");\n        } catch (PackageManager.NameNotFoundException e) {\n            EventLog.writeEvent(0x534e4554, \"185126813\", -1 /* UID */, \"no permission\");\n            Log.w(TAG, \"Cannot find the UID, calling package: \" + callingPackage, e);\n        }\n        return false;\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 3060,
                                        "general": {
                                            "word_based": 1226,
                                            "char_based": 3833
                                        },
                                        "gemini": 3724
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "a0409e582c30d2d6ff347eefd173ae169963df75",
                            "repo_path": "android_repos/Settings",
                            "result": "success",
                            "downstream_patch_content": "commit a0409e582c30d2d6ff347eefd173ae169963df75\nAuthor: Weng Su <wengsu@google.com>\nDate:   Fri Jan 26 17:59:40 2024 +0800\n\n    [RESTRICT AUTOMERGE] Restrict WifiDialogActivity\n    \n    - Don't show WifiDialogActivity if user has DISALLOW_ADD_WIFI_CONFIG\n    \n    Bug: 299931761\n    Flag: None\n    Test: manual test with TestDPC\n    atest -c SettingsRoboTests:WifiDialogActivityTest\n    \n    Merged-In: Icbb8f45922ded163208976be9c2816060dcf09f1\n    Change-Id: Icbb8f45922ded163208976be9c2816060dcf09f1\n    (cherry picked from commit 51fa3d798ad0397122bbb2143bc24efe1a705be9)\n\ndiff --git a/src/com/android/settings/wifi/WifiDialogActivity.java b/src/com/android/settings/wifi/WifiDialogActivity.java\nindex e3e77e86000..dda5929a987 100644\n--- a/src/com/android/settings/wifi/WifiDialogActivity.java\n+++ b/src/com/android/settings/wifi/WifiDialogActivity.java\n@@ -17,6 +17,7 @@\n package com.android.settings.wifi;\n \n import static android.Manifest.permission.ACCESS_FINE_LOCATION;\n+import static android.os.UserManager.DISALLOW_ADD_WIFI_CONFIG;\n import static android.os.UserManager.DISALLOW_CONFIG_WIFI;\n \n import android.app.KeyguardManager;\n@@ -122,7 +123,7 @@ public class WifiDialogActivity extends ObservableActivity implements WifiDialog\n         }\n \n         super.onCreate(savedInstanceState);\n-        if (!isConfigWifiAllowed()) {\n+        if (!isConfigWifiAllowed() || !isAddWifiConfigAllowed()) {\n             finish();\n             return;\n         }\n@@ -393,6 +394,16 @@ public class WifiDialogActivity extends ObservableActivity implements WifiDialog\n         return isConfigWifiAllowed;\n     }\n \n+    @VisibleForTesting\n+    boolean isAddWifiConfigAllowed() {\n+        UserManager userManager = getSystemService(UserManager.class);\n+        if (userManager != null && userManager.hasUserRestriction(DISALLOW_ADD_WIFI_CONFIG)) {\n+            Log.e(TAG, \"The user is not allowed to add Wi-Fi configuration.\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n     private boolean hasWifiManager() {\n         if (mWifiManager != null) return true;\n         mWifiManager = getSystemService(WifiManager.class);\ndiff --git a/tests/robotests/src/com/android/settings/wifi/WifiDialogActivityTest.java b/tests/robotests/src/com/android/settings/wifi/WifiDialogActivityTest.java\nindex 8b9faf2ff09..ad3cfd4a2b8 100644\n--- a/tests/robotests/src/com/android/settings/wifi/WifiDialogActivityTest.java\n+++ b/tests/robotests/src/com/android/settings/wifi/WifiDialogActivityTest.java\n@@ -18,6 +18,7 @@ package com.android.settings.wifi;\n \n import static android.Manifest.permission.ACCESS_COARSE_LOCATION;\n import static android.Manifest.permission.ACCESS_FINE_LOCATION;\n+import static android.os.UserManager.DISALLOW_ADD_WIFI_CONFIG;\n import static android.os.UserManager.DISALLOW_CONFIG_WIFI;\n \n import static com.android.settings.wifi.WifiDialogActivity.REQUEST_CODE_WIFI_DPP_ENROLLEE_QR_CODE_SCANNER;\n@@ -240,6 +241,20 @@ public class WifiDialogActivityTest {\n         assertThat(mActivity.isConfigWifiAllowed()).isFalse();\n     }\n \n+    @Test\n+    public void isAddWifiConfigAllowed_hasNoUserRestriction_returnTrue() {\n+        when(mUserManager.hasUserRestriction(DISALLOW_ADD_WIFI_CONFIG)).thenReturn(false);\n+\n+        assertThat(mActivity.isAddWifiConfigAllowed()).isTrue();\n+    }\n+\n+    @Test\n+    public void isAddWifiConfigAllowed_hasUserRestriction_returnFalse() {\n+        when(mUserManager.hasUserRestriction(DISALLOW_ADD_WIFI_CONFIG)).thenReturn(true);\n+\n+        assertThat(mActivity.isAddWifiConfigAllowed()).isFalse();\n+    }\n+\n     @Test\n     public void hasPermissionForResult_noCallingPackage_returnFalse() {\n         when(mActivity.getCallingPackage()).thenReturn(null);\n",
                            "downstream_patch_tokens": {
                                "openai": 921,
                                "general": {
                                    "word_based": 334,
                                    "char_based": 928
                                },
                                "gemini": 1209
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-299441833",
            "aliases": [
                "A-299441833",
                "CVE-2024-0046"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-299441833",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "496e78a1951f2ed69290f03c5625c0f8382f4d31"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 496e78a1951f2ed69290f03c5625c0f8382f4d31 Mon Sep 17 00:00:00 2001\nFrom: Alex Buynytskyy <alexbuy@google.com>\nDate: Wed, 20 Dec 2023 01:50:36 +0000\nSubject: [PATCH] Disallow system apps to be installed/updated as instant.\n\nBug: 299441833\nTest: atest android.content.pm.cts.PackageManagerTest\nChange-Id: Idd89a6dd72f0e68259095f677185f0494391025c\n---\n .../core/java/com/android/server/pm/InstallPackageHelper.java  | 3 +++\n 1 file changed, 3 insertions(+)\n\ndiff --git a/services/core/java/com/android/server/pm/InstallPackageHelper.java b/services/core/java/com/android/server/pm/InstallPackageHelper.java\nindex 65bfb2f258eb..985dadf5835c 100644\n--- a/services/core/java/com/android/server/pm/InstallPackageHelper.java\n+++ b/services/core/java/com/android/server/pm/InstallPackageHelper.java\n@@ -672,6 +672,9 @@ final class InstallPackageHelper {\n                 if (pkgSetting == null || pkgSetting.getPkg() == null) {\n                     return Pair.create(PackageManager.INSTALL_FAILED_INVALID_URI, intentSender);\n                 }\n+                if (instantApp && (pkgSetting.isSystem() || pkgSetting.isUpdatedSystemApp())) {\n+                    return Pair.create(PackageManager.INSTALL_FAILED_INVALID_URI, intentSender);\n+                }\n                 if (!snapshot.canViewInstantApps(callingUid, UserHandle.getUserId(callingUid))) {\n                     // only allow the existing package to be used if it's installed as a full\n                     // application for at least one user\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 404,
                        "general": {
                            "word_based": 172,
                            "char_based": 383
                        },
                        "gemini": 536
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 2,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "0d0f185c0d526c1dac0a8894b2c2f2e378328d73",
                            "repo_path": "android_repos/base",
                            "result": "failure",
                            "downstream_patch_content": "commit 0d0f185c0d526c1dac0a8894b2c2f2e378328d73\nAuthor: Alex Buynytskyy <alexbuy@google.com>\nDate:   Wed Dec 20 01:50:36 2023 +0000\n\n    Disallow system apps to be installed/updated as instant.\n    \n    Bug: 299441833\n    Test: atest android.content.pm.cts.PackageManagerTest\n    Change-Id: Idd89a6dd72f0e68259095f677185f0494391025c\n    Merged-In: Idd89a6dd72f0e68259095f677185f0494391025c\n    (cherry picked from commit 496e78a1951f2ed69290f03c5625c0f8382f4d31)\n\ndiff --git a/services/core/java/com/android/server/pm/PackageManagerService.java b/services/core/java/com/android/server/pm/PackageManagerService.java\nindex c6ed5682c143..17f6c41b3f8b 100644\n--- a/services/core/java/com/android/server/pm/PackageManagerService.java\n+++ b/services/core/java/com/android/server/pm/PackageManagerService.java\n@@ -16181,6 +16181,9 @@ public class PackageManagerService extends IPackageManager.Stub\n                 if (pkgSetting == null) {\n                     return PackageManager.INSTALL_FAILED_INVALID_URI;\n                 }\n+                if (instantApp && (pkgSetting.isSystem() || isUpdatedSystemApp(pkgSetting))) {\n+                    return PackageManager.INSTALL_FAILED_INVALID_URI;\n+                }\n                 if (!canViewInstantApps(callingUid, UserHandle.getUserId(callingUid))) {\n                     // only allow the existing package to be used if it's installed as a full\n                     // application for at least one user\n",
                            "downstream_patch_tokens": {
                                "openai": 394,
                                "general": {
                                    "word_based": 144,
                                    "char_based": 363
                                },
                                "gemini": 534
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "services/core/java/com/android/server/pm/InstallPackageHelper.java",
                                    "total_hunks": 0,
                                    "failed_hunks": [],
                                    "inline_merge_conflicts": [],
                                    "rej_file_content": "",
                                    "patch_apply_output": "can't find file to patch at input line 5\nPerhaps you used the wrong -p or --strip option?\nThe text leading up to this was:\n--------------------------\n|diff --git a/services/core/java/com/android/server/pm/InstallPackageHelper.java b/services/core/java/com/android/server/pm/InstallPackageHelper.java\n|index 65bfb2f258eb..985dadf5835c 100644\n|--- a/services/core/java/com/android/server/pm/InstallPackageHelper.java\n|+++ b/services/core/java/com/android/server/pm/InstallPackageHelper.java\n--------------------------\nFile to patch: \nSkip this patch? [y] \nSkipping patch.\n1 out of 1 hunk ignored",
                                    "inline_merge_output": "",
                                    "reason": "File 'services/core/java/com/android/server/pm/InstallPackageHelper.java' is missing in downstream repo",
                                    "downstream_file_content": "",
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "fbdeb248db7dee192392d82fe15482760b8af941",
                            "repo_path": "android_repos/base",
                            "result": "failure",
                            "downstream_patch_content": "commit fbdeb248db7dee192392d82fe15482760b8af941\nAuthor: Alex Buynytskyy <alexbuy@google.com>\nDate:   Wed Dec 20 01:50:36 2023 +0000\n\n    Disallow system apps to be installed/updated as instant.\n    \n    Bug: 299441833\n    Test: atest android.content.pm.cts.PackageManagerTest\n    Change-Id: Idd89a6dd72f0e68259095f677185f0494391025c\n    Merged-In: Idd89a6dd72f0e68259095f677185f0494391025c\n    (cherry picked from commit 496e78a1951f2ed69290f03c5625c0f8382f4d31)\n\ndiff --git a/services/core/java/com/android/server/pm/PackageManagerService.java b/services/core/java/com/android/server/pm/PackageManagerService.java\nindex b640ef87a952..9f5b4a695467 100644\n--- a/services/core/java/com/android/server/pm/PackageManagerService.java\n+++ b/services/core/java/com/android/server/pm/PackageManagerService.java\n@@ -16291,6 +16291,9 @@ public class PackageManagerService extends IPackageManager.Stub\n                 if (pkgSetting == null) {\n                     return PackageManager.INSTALL_FAILED_INVALID_URI;\n                 }\n+                if (instantApp && (pkgSetting.isSystem() || isUpdatedSystemApp(pkgSetting))) {\n+                    return PackageManager.INSTALL_FAILED_INVALID_URI;\n+                }\n                 if (!canViewInstantApps(callingUid, UserHandle.getUserId(callingUid))) {\n                     // only allow the existing package to be used if it's installed as a full\n                     // application for at least one user\n",
                            "downstream_patch_tokens": {
                                "openai": 381,
                                "general": {
                                    "word_based": 144,
                                    "char_based": 363
                                },
                                "gemini": 527
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "services/core/java/com/android/server/pm/InstallPackageHelper.java",
                                    "total_hunks": 0,
                                    "failed_hunks": [],
                                    "inline_merge_conflicts": [],
                                    "rej_file_content": "",
                                    "patch_apply_output": "can't find file to patch at input line 5\nPerhaps you used the wrong -p or --strip option?\nThe text leading up to this was:\n--------------------------\n|diff --git a/services/core/java/com/android/server/pm/InstallPackageHelper.java b/services/core/java/com/android/server/pm/InstallPackageHelper.java\n|index 65bfb2f258eb..985dadf5835c 100644\n|--- a/services/core/java/com/android/server/pm/InstallPackageHelper.java\n|+++ b/services/core/java/com/android/server/pm/InstallPackageHelper.java\n--------------------------\nFile to patch: \nSkip this patch? [y] \nSkipping patch.\n1 out of 1 hunk ignored",
                                    "inline_merge_output": "",
                                    "reason": "File 'services/core/java/com/android/server/pm/InstallPackageHelper.java' is missing in downstream repo",
                                    "downstream_file_content": "",
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "c61ee9f45233a35da687942d5af24a5d09568a6c",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit c61ee9f45233a35da687942d5af24a5d09568a6c\nAuthor: Alex Buynytskyy <alexbuy@google.com>\nDate:   Wed Dec 20 01:50:36 2023 +0000\n\n    Disallow system apps to be installed/updated as instant.\n    \n    Bug: 299441833\n    Test: atest android.content.pm.cts.PackageManagerTest\n    Change-Id: Idd89a6dd72f0e68259095f677185f0494391025c\n    Merged-In: Idd89a6dd72f0e68259095f677185f0494391025c\n    (cherry picked from commit 496e78a1951f2ed69290f03c5625c0f8382f4d31)\n\ndiff --git a/services/core/java/com/android/server/pm/InstallPackageHelper.java b/services/core/java/com/android/server/pm/InstallPackageHelper.java\nindex 37d4af831c77..b541e33bde9e 100644\n--- a/services/core/java/com/android/server/pm/InstallPackageHelper.java\n+++ b/services/core/java/com/android/server/pm/InstallPackageHelper.java\n@@ -559,6 +559,9 @@ final class InstallPackageHelper {\n                 if (pkgSetting == null) {\n                     return PackageManager.INSTALL_FAILED_INVALID_URI;\n                 }\n+                if (instantApp && (pkgSetting.isSystem() || pkgSetting.isUpdatedSystemApp())) {\n+                    return PackageManager.INSTALL_FAILED_INVALID_URI;\n+                }\n                 if (!snapshot.canViewInstantApps(callingUid, UserHandle.getUserId(callingUid))) {\n                     // only allow the existing package to be used if it's installed as a full\n                     // application for at least one user\n",
                            "downstream_patch_tokens": {
                                "openai": 387,
                                "general": {
                                    "word_based": 142,
                                    "char_based": 356
                                },
                                "gemini": 530
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "b978fdc30bf3dc8babb60ce88be47cf5b0622e84",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit b978fdc30bf3dc8babb60ce88be47cf5b0622e84\nAuthor: Alex Buynytskyy <alexbuy@google.com>\nDate:   Wed Dec 20 01:50:36 2023 +0000\n\n    Disallow system apps to be installed/updated as instant.\n    \n    Bug: 299441833\n    Test: atest android.content.pm.cts.PackageManagerTest\n    Change-Id: Idd89a6dd72f0e68259095f677185f0494391025c\n    Merged-In: Idd89a6dd72f0e68259095f677185f0494391025c\n    (cherry picked from commit 496e78a1951f2ed69290f03c5625c0f8382f4d31)\n\ndiff --git a/services/core/java/com/android/server/pm/InstallPackageHelper.java b/services/core/java/com/android/server/pm/InstallPackageHelper.java\nindex 622cb6609630..d0304b43215e 100644\n--- a/services/core/java/com/android/server/pm/InstallPackageHelper.java\n+++ b/services/core/java/com/android/server/pm/InstallPackageHelper.java\n@@ -668,6 +668,9 @@ final class InstallPackageHelper {\n                 if (pkgSetting == null || pkgSetting.getPkg() == null) {\n                     return Pair.create(PackageManager.INSTALL_FAILED_INVALID_URI, intentSender);\n                 }\n+                if (instantApp && (pkgSetting.isSystem() || pkgSetting.isUpdatedSystemApp())) {\n+                    return Pair.create(PackageManager.INSTALL_FAILED_INVALID_URI, intentSender);\n+                }\n                 if (!snapshot.canViewInstantApps(callingUid, UserHandle.getUserId(callingUid))) {\n                     // only allow the existing package to be used if it's installed as a full\n                     // application for at least one user\n",
                            "downstream_patch_tokens": {
                                "openai": 404,
                                "general": {
                                    "word_based": 151,
                                    "char_based": 377
                                },
                                "gemini": 549
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-230492947",
            "aliases": [
                "A-230492947",
                "CVE-2024-0036"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-230492947",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "e3c537ddea5ce8b28eeb89300ef602753cfe42a4"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From e3c537ddea5ce8b28eeb89300ef602753cfe42a4 Mon Sep 17 00:00:00 2001\nFrom: Christophe Pinelli <cpinelli@google.com>\nDate: Fri, 26 May 2023 22:33:09 +0000\nSubject: [PATCH] Restrict activity launch when caller is running in the\n background\n\nTest: atest BackgroundActivityLaunchTest#testBackgroundActivityBlockedInStartNextMatchingActivity\nBug: 230492947\nChange-Id: Ie3bc5bd88bfd3bd4777210c0740ad34ea6d3311e\n---\n .../server/wm/ActivityTaskManagerService.java | 52 +++++++++++--------\n 1 file changed, 31 insertions(+), 21 deletions(-)\n\ndiff --git a/services/core/java/com/android/server/wm/ActivityTaskManagerService.java b/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\nindex 47b51ac164b9..4a658d6abaf4 100644\n--- a/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\n+++ b/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\n@@ -1411,29 +1411,39 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n \n             final long origId = Binder.clearCallingIdentity();\n             // TODO(b/64750076): Check if calling pid should really be -1.\n-            final int res = getActivityStartController()\n-                    .obtainStarter(intent, \"startNextMatchingActivity\")\n-                    .setCaller(r.app.getThread())\n-                    .setResolvedType(r.resolvedType)\n-                    .setActivityInfo(aInfo)\n-                    .setResultTo(resultTo != null ? resultTo.token : null)\n-                    .setResultWho(resultWho)\n-                    .setRequestCode(requestCode)\n-                    .setCallingPid(-1)\n-                    .setCallingUid(r.launchedFromUid)\n-                    .setCallingPackage(r.launchedFromPackage)\n-                    .setCallingFeatureId(r.launchedFromFeatureId)\n-                    .setRealCallingPid(-1)\n-                    .setRealCallingUid(r.launchedFromUid)\n-                    .setActivityOptions(options)\n-                    .execute();\n-            Binder.restoreCallingIdentity(origId);\n+            try {\n+                if (options == null) {\n+                    options = new SafeActivityOptions(ActivityOptions.makeBasic());\n+                }\n \n-            r.finishing = wasFinishing;\n-            if (res != ActivityManager.START_SUCCESS) {\n-                return false;\n+                // Fixes b/230492947\n+                // Prevents background activity launch through #startNextMatchingActivity\n+                // An activity going into the background could still go back to the foreground\n+                // if the intent used matches both:\n+                // - the activity in the background\n+                // - a second activity.\n+                options.getOptions(r).setAvoidMoveToFront();\n+                final int res = getActivityStartController()\n+                        .obtainStarter(intent, \"startNextMatchingActivity\")\n+                        .setCaller(r.app.getThread())\n+                        .setResolvedType(r.resolvedType)\n+                        .setActivityInfo(aInfo)\n+                        .setResultTo(resultTo != null ? resultTo.token : null)\n+                        .setResultWho(resultWho)\n+                        .setRequestCode(requestCode)\n+                        .setCallingPid(-1)\n+                        .setCallingUid(r.launchedFromUid)\n+                        .setCallingPackage(r.launchedFromPackage)\n+                        .setCallingFeatureId(r.launchedFromFeatureId)\n+                        .setRealCallingPid(-1)\n+                        .setRealCallingUid(r.launchedFromUid)\n+                        .setActivityOptions(options)\n+                        .execute();\n+                r.finishing = wasFinishing;\n+                return res == ActivityManager.START_SUCCESS;\n+            } finally {\n+                Binder.restoreCallingIdentity(origId);\n             }\n-            return true;\n         }\n     }\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 887,
                        "general": {
                            "word_based": 299,
                            "char_based": 996
                        },
                        "gemini": 1071
                    },
                    "total_downstream_versions_tested": 5,
                    "successful_patches": 2,
                    "failed_patches": 3,
                    "patch_results": [
                        {
                            "downstream_version": "11",
                            "branch_used": "android11-release",
                            "downstream_patch": "d8368be4f8fb7019ea24b4798f029301c704092c",
                            "repo_path": "android_repos/base",
                            "result": "failure",
                            "downstream_patch_content": "commit d8368be4f8fb7019ea24b4798f029301c704092c\nAuthor: Christophe Pinelli <cpinelli@google.com>\nDate:   Tue May 16 17:40:02 2023 +0000\n\n    Restrict activity launch when caller is running in the background\n    \n    Test: test on device + atest-src BackgroundActivityLaunchTest#testBackgroundActivityBlockedInStartNextMatchingActivity\n    Bug: 230492947\n    Merged-In: I1a0c13e74622d301866efaca1b5351a6b241ebe5\n    Change-Id: I7ae88eb62e435b9a77d2a724c5a953fe1f35b838\n\ndiff --git a/services/core/java/com/android/server/wm/ActivityTaskManagerService.java b/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\nindex 004fa6b1608d..145d2ce832cd 100644\n--- a/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\n+++ b/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\n@@ -1223,29 +1223,38 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n \n             final long origId = Binder.clearCallingIdentity();\n             // TODO(b/64750076): Check if calling pid should really be -1.\n-            final int res = getActivityStartController()\n-                    .obtainStarter(intent, \"startNextMatchingActivity\")\n-                    .setCaller(r.app.getThread())\n-                    .setResolvedType(r.resolvedType)\n-                    .setActivityInfo(aInfo)\n-                    .setResultTo(resultTo != null ? resultTo.appToken : null)\n-                    .setResultWho(resultWho)\n-                    .setRequestCode(requestCode)\n-                    .setCallingPid(-1)\n-                    .setCallingUid(r.launchedFromUid)\n-                    .setCallingPackage(r.launchedFromPackage)\n-                    .setCallingFeatureId(r.launchedFromFeatureId)\n-                    .setRealCallingPid(-1)\n-                    .setRealCallingUid(r.launchedFromUid)\n-                    .setActivityOptions(options)\n-                    .execute();\n-            Binder.restoreCallingIdentity(origId);\n-\n-            r.finishing = wasFinishing;\n-            if (res != ActivityManager.START_SUCCESS) {\n-                return false;\n+            try {\n+                if (options == null) {\n+                    options = new SafeActivityOptions(ActivityOptions.makeBasic());\n+                }\n+                // Fixes b/230492947\n+                // Prevents background activity launch through #startNextMatchingActivity\n+                // An activity going into the background could still go back to the foreground\n+                // if the intent used matches both:\n+                // - the activity in the background\n+                // - a second activity.\n+                options.getOptions(r).setAvoidMoveToFront();\n+                final int res = getActivityStartController()\n+                        .obtainStarter(intent, \"startNextMatchingActivity\")\n+                        .setCaller(r.app.getThread())\n+                        .setResolvedType(r.resolvedType)\n+                        .setActivityInfo(aInfo)\n+                        .setResultTo(resultTo != null ? resultTo.appToken : null)\n+                        .setResultWho(resultWho)\n+                        .setRequestCode(requestCode)\n+                        .setCallingPid(-1)\n+                        .setCallingUid(r.launchedFromUid)\n+                        .setCallingPackage(r.launchedFromPackage)\n+                        .setCallingFeatureId(r.launchedFromFeatureId)\n+                        .setRealCallingPid(-1)\n+                        .setRealCallingUid(r.launchedFromUid)\n+                        .setActivityOptions(options)\n+                        .execute();\n+                r.finishing = wasFinishing;\n+                return res == ActivityManager.START_SUCCESS;\n+            } finally {\n+                Binder.restoreCallingIdentity(origId);\n             }\n-            return true;\n         }\n     }\n \n",
                            "downstream_patch_tokens": {
                                "openai": 860,
                                "general": {
                                    "word_based": 279,
                                    "char_based": 974
                                },
                                "gemini": 1051
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "services/core/java/com/android/server/wm/ActivityTaskManagerService.java",
                                    "total_hunks": 1,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 11)\n\n=======\n\n            final long origId = Binder.clearCallingIdentity();\n            // TODO(b/64750076): Check if calling pid should really be -1.\n            try {\n                if (options == null) {\n                    options = new SafeActivityOptions(ActivityOptions.makeBasic());\n                }\n\n                // Fixes b/230492947\n                // Prevents background activity launch through #startNextMatchingActivity\n>>>>>>> UPSTREAM PATCH (commit e3c537ddea5ce8b28eeb89300ef602753cfe42a4)",
                                            "merge_conflict_tokens": {
                                                "openai": 118,
                                                "general": {
                                                    "word_based": 41,
                                                    "char_based": 134
                                                },
                                                "gemini": 151
                                            }
                                        }
                                    ],
                                    "inline_merge_token_summary": {
                                        "gemini": 1963,
                                        "openai": 1652,
                                        "general_word": 574,
                                        "general_char": 1876
                                    },
                                    "rej_file_content": "```diff\n--- services/core/java/com/android/server/wm/ActivityTaskManagerService.java\n+++ services/core/java/com/android/server/wm/ActivityTaskManagerService.java\n@@ -1411,29 +1411,39 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n \n             final long origId = Binder.clearCallingIdentity();\n             // TODO(b/64750076): Check if calling pid should really be -1.\n-            final int res = getActivityStartController()\n-                    .obtainStarter(intent, \"startNextMatchingActivity\")\n-                    .setCaller(r.app.getThread())\n-                    .setResolvedType(r.resolvedType)\n-                    .setActivityInfo(aInfo)\n-                    .setResultTo(resultTo != null ? resultTo.token : null)\n-                    .setResultWho(resultWho)\n-                    .setRequestCode(requestCode)\n-                    .setCallingPid(-1)\n-                    .setCallingUid(r.launchedFromUid)\n-                    .setCallingPackage(r.launchedFromPackage)\n-                    .setCallingFeatureId(r.launchedFromFeatureId)\n-                    .setRealCallingPid(-1)\n-                    .setRealCallingUid(r.launchedFromUid)\n-                    .setActivityOptions(options)\n-                    .execute();\n-            Binder.restoreCallingIdentity(origId);\n+            try {\n+                if (options == null) {\n+                    options = new SafeActivityOptions(ActivityOptions.makeBasic());\n+                }\n \n-            r.finishing = wasFinishing;\n-            if (res != ActivityManager.START_SUCCESS) {\n-                return false;\n+                // Fixes b/230492947\n+                // Prevents background activity launch through #startNextMatchingActivity\n+                // An activity going into the background could still go back to the foreground\n+                // if the intent used matches both:\n+                // - the activity in the background\n+                // - a second activity.\n+                options.getOptions(r).setAvoidMoveToFront();\n+                final int res = getActivityStartController()\n+                        .obtainStarter(intent, \"startNextMatchingActivity\")\n+                        .setCaller(r.app.getThread())\n+                        .setResolvedType(r.resolvedType)\n+                        .setActivityInfo(aInfo)\n+                        .setResultTo(resultTo != null ? resultTo.token : null)\n+                        .setResultWho(resultWho)\n+                        .setRequestCode(requestCode)\n+                        .setCallingPid(-1)\n+                        .setCallingUid(r.launchedFromUid)\n+                        .setCallingPackage(r.launchedFromPackage)\n+                        .setCallingFeatureId(r.launchedFromFeatureId)\n+                        .setRealCallingPid(-1)\n+                        .setRealCallingUid(r.launchedFromUid)\n+                        .setActivityOptions(options)\n+                        .execute();\n+                r.finishing = wasFinishing;\n+                return res == ActivityManager.START_SUCCESS;\n+            } finally {\n+                Binder.restoreCallingIdentity(origId);\n             }\n-            return true;\n         }\n     }\n```",
                                    "rej_file_tokens": {
                                        "openai": 635,
                                        "general": {
                                            "word_based": 208,
                                            "char_based": 804
                                        },
                                        "gemini": 743
                                    },
                                    "patch_apply_output": "patching file services/core/java/com/android/server/wm/ActivityTaskManagerService.java\nHunk #1 FAILED at 1411.\n1 out of 1 hunk FAILED -- saving rejects to file services/core/java/com/android/server/wm/ActivityTaskManagerService.java.rej",
                                    "inline_merge_output": "patching file services/core/java/com/android/server/wm/ActivityTaskManagerService.java\nHunk #1 NOT MERGED at 1421-1433, already applied at 1460.",
                                    "upstream_file_tokens": {
                                        "openai": 59312,
                                        "general": {
                                            "word_based": 22835,
                                            "char_based": 77205
                                        },
                                        "gemini": 69378
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2018 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License\n */\n\npackage com.android.server.wm;\n\nimport static android.Manifest.permission.BIND_VOICE_INTERACTION;\nimport static android.Manifest.permission.CHANGE_CONFIGURATION;\nimport static android.Manifest.permission.CONTROL_REMOTE_APP_TRANSITION_ANIMATIONS;\nimport static android.Manifest.permission.INTERACT_ACROSS_USERS;\nimport static android.Manifest.permission.INTERACT_ACROSS_USERS_FULL;\nimport static android.Manifest.permission.INTERNAL_SYSTEM_WINDOW;\nimport static android.Manifest.permission.MANAGE_ACTIVITY_STACKS;\nimport static android.Manifest.permission.READ_FRAME_BUFFER;\nimport static android.Manifest.permission.REMOVE_TASKS;\nimport static android.Manifest.permission.START_TASKS_FROM_RECENTS;\nimport static android.Manifest.permission.STOP_APP_SWITCHES;\nimport static android.app.ActivityManager.LOCK_TASK_MODE_NONE;\nimport static android.app.ActivityManagerInternal.ALLOW_NON_FULL;\nimport static android.app.ActivityTaskManager.INVALID_TASK_ID;\nimport static android.app.ActivityTaskManager.RESIZE_MODE_PRESERVE_WINDOW;\nimport static android.app.WindowConfiguration.ACTIVITY_TYPE_DREAM;\nimport static android.app.WindowConfiguration.WINDOWING_MODE_FREEFORM;\nimport static android.app.WindowConfiguration.WINDOWING_MODE_FULLSCREEN;\nimport static android.app.WindowConfiguration.WINDOWING_MODE_PINNED;\nimport static android.app.WindowConfiguration.WINDOWING_MODE_SPLIT_SCREEN_PRIMARY;\nimport static android.app.WindowConfiguration.WINDOWING_MODE_UNDEFINED;\nimport static android.content.Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;\nimport static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\nimport static android.content.pm.ApplicationInfo.FLAG_FACTORY_TEST;\nimport static android.content.pm.ConfigurationInfo.GL_ES_VERSION_UNDEFINED;\nimport static android.content.pm.PackageManager.FEATURE_ACTIVITIES_ON_SECONDARY_DISPLAYS;\nimport static android.content.pm.PackageManager.FEATURE_CANT_SAVE_STATE;\nimport static android.content.pm.PackageManager.FEATURE_FREEFORM_WINDOW_MANAGEMENT;\nimport static android.content.pm.PackageManager.FEATURE_LEANBACK;\nimport static android.content.pm.PackageManager.FEATURE_PICTURE_IN_PICTURE;\nimport static android.content.pm.PackageManager.PERMISSION_GRANTED;\nimport static android.os.FactoryTest.FACTORY_TEST_HIGH_LEVEL;\nimport static android.os.FactoryTest.FACTORY_TEST_LOW_LEVEL;\nimport static android.os.FactoryTest.FACTORY_TEST_OFF;\nimport static android.os.Process.FIRST_APPLICATION_UID;\nimport static android.os.Process.SYSTEM_UID;\nimport static android.os.Trace.TRACE_TAG_WINDOW_MANAGER;\nimport static android.provider.Settings.Global.DEVELOPMENT_ENABLE_FREEFORM_WINDOWS_SUPPORT;\nimport static android.provider.Settings.Global.DEVELOPMENT_ENABLE_SIZECOMPAT_FREEFORM;\nimport static android.provider.Settings.Global.DEVELOPMENT_FORCE_RESIZABLE_ACTIVITIES;\nimport static android.provider.Settings.Global.DEVELOPMENT_FORCE_RTL;\nimport static android.provider.Settings.Global.HIDE_ERROR_DIALOGS;\nimport static android.provider.Settings.System.FONT_SCALE;\nimport static android.service.voice.VoiceInteractionSession.SHOW_SOURCE_APPLICATION;\nimport static android.text.format.DateUtils.MINUTE_IN_MILLIS;\nimport static android.view.Display.DEFAULT_DISPLAY;\nimport static android.view.Display.INVALID_DISPLAY;\nimport static android.view.WindowManager.TRANSIT_NONE;\n\nimport static com.android.server.am.ActivityManagerService.ANR_TRACE_DIR;\nimport static com.android.server.am.ActivityManagerService.MY_PID;\nimport static com.android.server.am.ActivityManagerService.STOCK_PM_FLAGS;\nimport static com.android.server.am.ActivityManagerService.dumpStackTraces;\nimport static com.android.server.am.ActivityManagerServiceDumpActivitiesProto.ROOT_WINDOW_CONTAINER;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.CONFIG_WILL_CHANGE;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.CONTROLLER;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.CURRENT_TRACKER;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.Controller.IS_A_MONKEY;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.GLOBAL_CONFIGURATION;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.GOING_TO_SLEEP;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.HEAVY_WEIGHT_PROC;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.HOME_PROC;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.LAUNCHING_ACTIVITY;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.PREVIOUS_PROC;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.PREVIOUS_PROC_VISIBLE_TIME_MS;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.SCREEN_COMPAT_PACKAGES;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.ScreenCompatPackage.MODE;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.ScreenCompatPackage.PACKAGE;\nimport static com.android.server.am.EventLogTags.writeBootProgressEnableScreen;\nimport static com.android.server.am.EventLogTags.writeConfigurationChanged;\nimport static com.android.server.wm.ActivityStack.ActivityState.DESTROYED;\nimport static com.android.server.wm.ActivityStack.ActivityState.DESTROYING;\nimport static com.android.server.wm.ActivityStackSupervisor.DEFER_RESUME;\nimport static com.android.server.wm.ActivityStackSupervisor.ON_TOP;\nimport static com.android.server.wm.ActivityStackSupervisor.PRESERVE_WINDOWS;\nimport static com.android.server.wm.ActivityStackSupervisor.REMOVE_FROM_RECENTS;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.DEBUG_ALL;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.DEBUG_CONFIGURATION;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.DEBUG_FOCUS;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.DEBUG_IMMERSIVE;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.DEBUG_LOCKTASK;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.DEBUG_STACK;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.DEBUG_SWITCH;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.DEBUG_TASKS;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.DEBUG_VISIBILITY;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.POSTFIX_CONFIGURATION;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.POSTFIX_FOCUS;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.POSTFIX_IMMERSIVE;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.POSTFIX_LOCKTASK;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.POSTFIX_STACK;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.POSTFIX_SWITCH;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.POSTFIX_VISIBILITY;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.TAG_ATM;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.TAG_WITH_CLASS_NAME;\nimport static com.android.server.wm.ActivityTaskManagerInternal.ASSIST_KEY_CONTENT;\nimport static com.android.server.wm.ActivityTaskManagerInternal.ASSIST_KEY_DATA;\nimport static com.android.server.wm.ActivityTaskManagerInternal.ASSIST_KEY_RECEIVER_EXTRAS;\nimport static com.android.server.wm.ActivityTaskManagerInternal.ASSIST_KEY_STRUCTURE;\nimport static com.android.server.wm.ActivityTaskManagerService.H.REPORT_TIME_TRACKER_MSG;\nimport static com.android.server.wm.ActivityTaskManagerService.UiHandler.DISMISS_DIALOG_UI_MSG;\nimport static com.android.server.wm.RecentsAnimationController.REORDER_KEEP_IN_PLACE;\nimport static com.android.server.wm.RecentsAnimationController.REORDER_MOVE_TO_ORIGINAL_POSITION;\nimport static com.android.server.wm.RootWindowContainer.MATCH_TASK_IN_STACKS_ONLY;\nimport static com.android.server.wm.RootWindowContainer.MATCH_TASK_IN_STACKS_OR_RECENT_TASKS;\nimport static com.android.server.wm.Task.LOCK_TASK_AUTH_DONT_LOCK;\nimport static com.android.server.wm.Task.REPARENT_KEEP_STACK_AT_FRONT;\nimport static com.android.server.wm.Task.REPARENT_LEAVE_STACK_IN_PLACE;\nimport static com.android.server.wm.WindowContainer.POSITION_TOP;\n\nimport android.Manifest;\nimport android.annotation.IntDef;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.UserIdInt;\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.ActivityOptions;\nimport android.app.ActivityTaskManager;\nimport android.app.ActivityThread;\nimport android.app.AlertDialog;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.Dialog;\nimport android.app.IActivityController;\nimport android.app.IActivityTaskManager;\nimport android.app.IApplicationThread;\nimport android.app.IAssistDataReceiver;\nimport android.app.INotificationManager;\nimport android.app.IRequestFinishCallback;\nimport android.app.ITaskStackListener;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.PictureInPictureParams;\nimport android.app.ProfilerInfo;\nimport android.app.RemoteAction;\nimport android.app.WaitResult;\nimport android.app.WindowConfiguration;\nimport android.app.admin.DevicePolicyCache;\nimport android.app.assist.AssistContent;\nimport android.app.assist.AssistStructure;\nimport android.app.servertransaction.ClientTransaction;\nimport android.app.servertransaction.EnterPipRequestedItem;\nimport android.app.usage.UsageStatsManagerInternal;\nimport android.content.ActivityNotFoundException;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.IIntentSender;\nimport android.content.Intent;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.ConfigurationInfo;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.ResolveInfo;\nimport android.content.res.CompatibilityInfo;\nimport android.content.res.Configuration;\nimport android.content.res.Resources;\nimport android.database.ContentObserver;\nimport android.graphics.Bitmap;\nimport android.graphics.Point;\nimport android.graphics.Rect;\nimport android.metrics.LogMaker;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.FactoryTest;\nimport android.os.FileUtils;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.IUserManager;\nimport android.os.LocaleList;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.PersistableBundle;\nimport android.os.PowerManager;\nimport android.os.PowerManagerInternal;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.ServiceManager;\nimport android.os.StrictMode;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.Trace;\nimport android.os.UpdateLock;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.WorkSource;\nimport android.os.storage.IStorageManager;\nimport android.os.storage.StorageManager;\nimport android.provider.Settings;\nimport android.service.dreams.DreamActivity;\nimport android.service.voice.IVoiceInteractionSession;\nimport android.service.voice.VoiceInteractionManagerInternal;\nimport android.sysprop.DisplayProperties;\nimport android.telecom.TelecomManager;\nimport android.text.TextUtils;\nimport android.text.format.TimeMigrationUtils;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.Log;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.TimeUtils;\nimport android.util.proto.ProtoOutputStream;\nimport android.view.IRecentsAnimationRunner;\nimport android.view.RemoteAnimationAdapter;\nimport android.view.RemoteAnimationDefinition;\nimport android.view.WindowManager;\nimport android.window.IWindowOrganizerController;\nimport android.window.WindowContainerTransaction;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.app.AssistUtils;\nimport com.android.internal.app.IVoiceInteractor;\nimport com.android.internal.app.ProcessMap;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto.MetricsEvent;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.os.TransferPipe;\nimport com.android.internal.os.logging.MetricsLoggerWrapper;\nimport com.android.internal.policy.IKeyguardDismissCallback;\nimport com.android.internal.policy.KeyguardDismissCallback;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.FastPrintWriter;\nimport com.android.internal.util.FrameworkStatsLog;\nimport com.android.internal.util.function.pooled.PooledConsumer;\nimport com.android.internal.util.function.pooled.PooledFunction;\nimport com.android.internal.util.function.pooled.PooledLambda;\nimport com.android.server.AttributeCache;\nimport com.android.server.LocalServices;\nimport com.android.server.SystemService;\nimport com.android.server.SystemServiceManager;\nimport com.android.server.UiThread;\nimport com.android.server.Watchdog;\nimport com.android.server.am.ActivityManagerService;\nimport com.android.server.am.ActivityManagerServiceDumpProcessesProto;\nimport com.android.server.am.AppTimeTracker;\nimport com.android.server.am.BaseErrorDialog;\nimport com.android.server.am.PendingIntentController;\nimport com.android.server.am.PendingIntentRecord;\nimport com.android.server.am.UserState;\nimport com.android.server.firewall.IntentFirewall;\nimport com.android.server.inputmethod.InputMethodSystemProperty;\nimport com.android.server.pm.UserManagerService;\nimport com.android.server.policy.PermissionPolicyInternal;\nimport com.android.server.uri.NeededUriGrants;\nimport com.android.server.uri.UriGrantsManagerInternal;\nimport com.android.server.vr.VrManagerInternal;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.ref.WeakReference;\nimport java.text.DateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\n\n/**\n * System service for managing activities and their containers (task, stacks, displays,... ).\n *\n * {@hide}\n */\npublic class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n    private static final String TAG = TAG_WITH_CLASS_NAME ? \"ActivityTaskManagerService\" : TAG_ATM;\n    static final String TAG_STACK = TAG + POSTFIX_STACK;\n    static final String TAG_SWITCH = TAG + POSTFIX_SWITCH;\n    private static final String TAG_IMMERSIVE = TAG + POSTFIX_IMMERSIVE;\n    private static final String TAG_FOCUS = TAG + POSTFIX_FOCUS;\n    private static final String TAG_VISIBILITY = TAG + POSTFIX_VISIBILITY;\n    private static final String TAG_LOCKTASK = TAG + POSTFIX_LOCKTASK;\n    private static final String TAG_CONFIGURATION = TAG + POSTFIX_CONFIGURATION;\n\n    // How long we wait until we timeout on key dispatching.\n    public static final int KEY_DISPATCHING_TIMEOUT_MS = 5 * 1000;\n    // How long we wait until we timeout on key dispatching during instrumentation.\n    static final int INSTRUMENTATION_KEY_DISPATCHING_TIMEOUT_MS = 60 * 1000;\n    // How long we permit background activity starts after an activity in the process\n    // started or finished.\n    static final long ACTIVITY_BG_START_GRACE_PERIOD_MS = 10 * 1000;\n\n    /** Used to indicate that an app transition should be animated. */\n    static final boolean ANIMATE = true;\n\n    /** Hardware-reported OpenGLES version. */\n    final int GL_ES_VERSION;\n\n    public static final String DUMP_ACTIVITIES_CMD = \"activities\" ;\n    public static final String DUMP_ACTIVITIES_SHORT_CMD = \"a\" ;\n    public static final String DUMP_LASTANR_CMD = \"lastanr\" ;\n    public static final String DUMP_LASTANR_TRACES_CMD = \"lastanr-traces\" ;\n    public static final String DUMP_STARTER_CMD = \"starter\" ;\n    public static final String DUMP_CONTAINERS_CMD = \"containers\" ;\n    public static final String DUMP_RECENTS_CMD = \"recents\" ;\n    public static final String DUMP_RECENTS_SHORT_CMD = \"r\" ;\n\n    /** This activity is not being relaunched, or being relaunched for a non-resize reason. */\n    public static final int RELAUNCH_REASON_NONE = 0;\n    /** This activity is being relaunched due to windowing mode change. */\n    public static final int RELAUNCH_REASON_WINDOWING_MODE_RESIZE = 1;\n    /** This activity is being relaunched due to a free-resize operation. */\n    public static final int RELAUNCH_REASON_FREE_RESIZE = 2;\n\n    Context mContext;\n\n    /**\n     * This Context is themable and meant for UI display (AlertDialogs, etc.). The theme can\n     * change at runtime. Use mContext for non-UI purposes.\n     */\n    final Context mUiContext;\n    final ActivityThread mSystemThread;\n    H mH;\n    UiHandler mUiHandler;\n    ActivityManagerInternal mAmInternal;\n    UriGrantsManagerInternal mUgmInternal;\n    private PackageManagerInternal mPmInternal;\n    /** The cached sys ui service component name from package manager. */\n    private ComponentName mSysUiServiceComponent;\n    private PermissionPolicyInternal mPermissionPolicyInternal;\n    @VisibleForTesting\n    final ActivityTaskManagerInternal mInternal;\n    PowerManagerInternal mPowerManagerInternal;\n    private UsageStatsManagerInternal mUsageStatsInternal;\n\n    PendingIntentController mPendingIntentController;\n    IntentFirewall mIntentFirewall;\n\n    /* Global service lock used by the package the owns this service. */\n    final WindowManagerGlobalLock mGlobalLock = new WindowManagerGlobalLock();\n    /**\n     * It is the same instance as {@link #mGlobalLock}, just declared as a type that the\n     * locked-region-code-injection does't recognize it. It is used to skip wrapping priority\n     * booster for places that are already in the scope of another booster (e.g. computing oom-adj).\n     *\n     * @see WindowManagerThreadPriorityBooster\n     */\n    final Object mGlobalLockWithoutBoost = mGlobalLock;\n    ActivityStackSupervisor mStackSupervisor;\n    RootWindowContainer mRootWindowContainer;\n    WindowManagerService mWindowManager;\n    private UserManagerService mUserManager;\n    private AppOpsManager mAppOpsManager;\n    /** All active uids in the system. */\n    private final MirrorActiveUids mActiveUids = new MirrorActiveUids();\n    private final SparseArray<String> mPendingTempWhitelist = new SparseArray<>();\n    /** All processes currently running that might have a window organized by name. */\n    final ProcessMap<WindowProcessController> mProcessNames = new ProcessMap<>();\n    /** All processes we currently have running mapped by pid and uid */\n    final WindowProcessControllerMap mProcessMap = new WindowProcessControllerMap();\n    /** This is the process holding what we currently consider to be the \"home\" activity. */\n    WindowProcessController mHomeProcess;\n    /** The currently running heavy-weight process, if any. */\n    WindowProcessController mHeavyWeightProcess = null;\n    boolean mHasHeavyWeightFeature;\n    boolean mHasLeanbackFeature;\n    /**\n     * This is the process holding the activity the user last visited that is in a different process\n     * from the one they are currently in.\n     */\n    WindowProcessController mPreviousProcess;\n    /** The time at which the previous process was last visible. */\n    long mPreviousProcessVisibleTime;\n\n    /** List of intents that were used to start the most recent tasks. */\n    private RecentTasks mRecentTasks;\n    /** State of external calls telling us if the device is awake or asleep. */\n    private boolean mKeyguardShown = false;\n\n    // Wrapper around VoiceInteractionServiceManager\n    private AssistUtils mAssistUtils;\n\n    // VoiceInteraction session ID that changes for each new request except when\n    // being called for multi-window assist in a single session.\n    private int mViSessionId = 1000;\n\n    // How long to wait in getAssistContextExtras for the activity and foreground services\n    // to respond with the result.\n    private static final int PENDING_ASSIST_EXTRAS_TIMEOUT = 500;\n\n    // How long top wait when going through the modern assist (which doesn't need to block\n    // on getting this result before starting to launch its UI).\n    private static final int PENDING_ASSIST_EXTRAS_LONG_TIMEOUT = 2000;\n\n    // How long to wait in getAutofillAssistStructure() for the activity to respond with the result.\n    private static final int PENDING_AUTOFILL_ASSIST_STRUCTURE_TIMEOUT = 2000;\n\n    // Permission tokens are used to temporarily granted a trusted app the ability to call\n    // #startActivityAsCaller.  A client is expected to dump its token after this time has elapsed,\n    // showing any appropriate error messages to the user.\n    private static final long START_AS_CALLER_TOKEN_TIMEOUT =\n            10 * MINUTE_IN_MILLIS;\n\n    // How long before the service actually expires a token.  This is slightly longer than\n    // START_AS_CALLER_TOKEN_TIMEOUT, to provide a buffer so clients will rarely encounter the\n    // expiration exception.\n    private static final long START_AS_CALLER_TOKEN_TIMEOUT_IMPL =\n            START_AS_CALLER_TOKEN_TIMEOUT + 2 * 1000;\n\n    // How long the service will remember expired tokens, for the purpose of providing error\n    // messaging when a client uses an expired token.\n    private static final long START_AS_CALLER_TOKEN_EXPIRED_TIMEOUT =\n            START_AS_CALLER_TOKEN_TIMEOUT_IMPL + 20 * MINUTE_IN_MILLIS;\n\n    // Activity tokens of system activities that are delegating their call to\n    // #startActivityByCaller, keyed by the permissionToken granted to the delegate.\n    final HashMap<IBinder, IBinder> mStartActivitySources = new HashMap<>();\n\n    // Permission tokens that have expired, but we remember for error reporting.\n    final ArrayList<IBinder> mExpiredStartAsCallerTokens = new ArrayList<>();\n\n    private final ArrayList<PendingAssistExtras> mPendingAssistExtras = new ArrayList<>();\n\n    // Keeps track of the active voice interaction service component, notified from\n    // VoiceInteractionManagerService\n    ComponentName mActiveVoiceInteractionServiceComponent;\n\n    // A map userId and all its companion app uids\n    private final Map<Integer, Set<Integer>> mCompanionAppUidsMap = new ArrayMap<>();\n\n    VrController mVrController;\n    KeyguardController mKeyguardController;\n    private final ClientLifecycleManager mLifecycleManager;\n    private TaskChangeNotificationController mTaskChangeNotificationController;\n    /** The controller for all operations related to locktask. */\n    private LockTaskController mLockTaskController;\n    private ActivityStartController mActivityStartController;\n\n    boolean mSuppressResizeConfigChanges;\n\n    final UpdateConfigurationResult mTmpUpdateConfigurationResult =\n            new UpdateConfigurationResult();\n\n    static final class UpdateConfigurationResult {\n        // Configuration changes that were updated.\n        int changes;\n        // If the activity was relaunched to match the new configuration.\n        boolean activityRelaunched;\n\n        void reset() {\n            changes = 0;\n            activityRelaunched = false;\n        }\n    }\n\n    /** Current sequencing integer of the configuration, for skipping old configurations. */\n    private int mConfigurationSeq;\n    // To cache the list of supported system locales\n    private String[] mSupportedSystemLocales = null;\n\n    /**\n     * Temp object used when global and/or display override configuration is updated. It is also\n     * sent to outer world instead of {@link #getGlobalConfiguration} because we don't trust\n     * anyone...\n     */\n    private Configuration mTempConfig = new Configuration();\n\n    /** Temporary to avoid allocations. */\n    final StringBuilder mStringBuilder = new StringBuilder(256);\n\n    // Amount of time after a call to stopAppSwitches() during which we will\n    // prevent further untrusted switches from happening.\n    private static final long APP_SWITCH_DELAY_TIME = 5 * 1000;\n\n    /**\n     * The time at which we will allow normal application switches again,\n     * after a call to {@link #stopAppSwitches()}.\n     */\n    private long mAppSwitchesAllowedTime;\n    /**\n     * This is set to true after the first switch after mAppSwitchesAllowedTime\n     * is set; any switches after that will clear the time.\n     */\n    private boolean mDidAppSwitch;\n\n    /**\n     * Last stop app switches time, apps finished before this time cannot start background activity\n     * even if they are in grace period.\n     */\n    private long mLastStopAppSwitchesTime;\n\n    IActivityController mController = null;\n    boolean mControllerIsAMonkey = false;\n\n    final int mFactoryTest;\n\n    /** Used to control how we initialize the service. */\n    ComponentName mTopComponent;\n    String mTopAction = Intent.ACTION_MAIN;\n    String mTopData;\n\n    /** Profiling app information. */\n    String mProfileApp = null;\n    WindowProcessController mProfileProc = null;\n    ProfilerInfo mProfilerInfo = null;\n\n    /**\n     * Dump of the activity state at the time of the last ANR. Cleared after\n     * {@link WindowManagerService#LAST_ANR_LIFETIME_DURATION_MSECS}\n     */\n    String mLastANRState;\n\n    /**\n     * Used to retain an update lock when the foreground activity is in\n     * immersive mode.\n     */\n    private final UpdateLock mUpdateLock = new UpdateLock(\"immersive\");\n\n    /**\n     * Packages that are being allowed to perform unrestricted app switches.  Mapping is\n     * User -> Type -> uid.\n     */\n    final SparseArray<ArrayMap<String, Integer>> mAllowAppSwitchUids = new SparseArray<>();\n\n    /** The dimensions of the thumbnails in the Recents UI. */\n    private int mThumbnailWidth;\n    private int mThumbnailHeight;\n\n    /**\n     * Flag that indicates if multi-window is enabled.\n     *\n     * For any particular form of multi-window to be enabled, generic multi-window must be enabled\n     * in {@link com.android.internal.R.bool#config_supportsMultiWindow} config or\n     * {@link Settings.Global#DEVELOPMENT_FORCE_RESIZABLE_ACTIVITIES} development option set.\n     * At least one of the forms of multi-window must be enabled in order for this flag to be\n     * initialized to 'true'.\n     *\n     * @see #mSupportsSplitScreenMultiWindow\n     * @see #mSupportsFreeformWindowManagement\n     * @see #mSupportsPictureInPicture\n     * @see #mSupportsMultiDisplay\n     */\n    boolean mSupportsMultiWindow;\n    boolean mSupportsSplitScreenMultiWindow;\n    boolean mSupportsFreeformWindowManagement;\n    boolean mSupportsPictureInPicture;\n    boolean mSupportsMultiDisplay;\n    boolean mForceResizableActivities;\n    boolean mSizeCompatFreeform;\n\n    final List<ActivityTaskManagerInternal.ScreenObserver> mScreenObservers = new ArrayList<>();\n\n    // VR Vr2d Display Id.\n    int mVr2dDisplayId = INVALID_DISPLAY;\n\n    /**\n     * Set while we are wanting to sleep, to prevent any\n     * activities from being started/resumed.\n     *\n     * TODO(b/33594039): Clarify the actual state transitions represented by mSleeping.\n     *\n     * Currently mSleeping is set to true when transitioning into the sleep state, and remains true\n     * while in the sleep state until there is a pending transition out of sleep, in which case\n     * mSleeping is set to false, and remains false while awake.\n     *\n     * Whether mSleeping can quickly toggled between true/false without the device actually\n     * display changing states is undefined.\n     */\n    private boolean mSleeping = false;\n\n    /**\n     * The mDreaming state is set by the {@link DreamManagerService} when it receives a request to\n     * start/stop the dream. It is set to true shortly  before the {@link DreamService} is started.\n     * It is set to false after the {@link DreamService} is stopped.\n     */\n    private boolean mDreaming = false;\n\n    /**\n     * The process state used for processes that are running the top activities.\n     * This changes between TOP and TOP_SLEEPING to following mSleeping.\n     */\n    int mTopProcessState = ActivityManager.PROCESS_STATE_TOP;\n\n    @Retention(RetentionPolicy.SOURCE)\n    @IntDef({\n            LAYOUT_REASON_CONFIG_CHANGED,\n            LAYOUT_REASON_VISIBILITY_CHANGED,\n    })\n    @interface LayoutReason {}\n    static final int LAYOUT_REASON_CONFIG_CHANGED = 0x1;\n    static final int LAYOUT_REASON_VISIBILITY_CHANGED = 0x2;\n\n    /** The reasons to perform surface placement. */\n    @LayoutReason\n    private int mLayoutReasons;\n\n    // Whether we should show our dialogs (ANR, crash, etc) or just perform their default action\n    // automatically. Important for devices without direct input devices.\n    private boolean mShowDialogs = true;\n\n    /** Set if we are shutting down the system, similar to sleeping. */\n    boolean mShuttingDown = false;\n\n    /**\n     * We want to hold a wake lock while running a voice interaction session, since\n     * this may happen with the screen off and we need to keep the CPU running to\n     * be able to continue to interact with the user.\n     */\n    PowerManager.WakeLock mVoiceWakeLock;\n\n    /**\n     * Set while we are running a voice interaction. This overrides sleeping while it is active.\n     */\n    IVoiceInteractionSession mRunningVoice;\n\n    /**\n     * The last resumed activity. This is identical to the current resumed activity most\n     * of the time but could be different when we're pausing one activity before we resume\n     * another activity.\n     */\n    ActivityRecord mLastResumedActivity;\n\n    /**\n     * The activity that is currently being traced as the active resumed activity.\n     *\n     * @see #updateResumedAppTrace\n     */\n    private @Nullable ActivityRecord mTracedResumedActivity;\n\n    /** If non-null, we are tracking the time the user spends in the currently focused app. */\n    AppTimeTracker mCurAppTimeTracker;\n\n    AppWarnings mAppWarnings;\n\n    /**\n     * Packages that the user has asked to have run in screen size\n     * compatibility mode instead of filling the screen.\n     */\n    CompatModePackages mCompatModePackages;\n\n    private FontScaleSettingObserver mFontScaleSettingObserver;\n\n    WindowOrganizerController mWindowOrganizerController;\n    TaskOrganizerController mTaskOrganizerController;\n\n    private int mDeviceOwnerUid = Process.INVALID_UID;\n\n    private final class FontScaleSettingObserver extends ContentObserver {\n        private final Uri mFontScaleUri = Settings.System.getUriFor(FONT_SCALE);\n        private final Uri mHideErrorDialogsUri = Settings.Global.getUriFor(HIDE_ERROR_DIALOGS);\n\n        public FontScaleSettingObserver() {\n            super(mH);\n            final ContentResolver resolver = mContext.getContentResolver();\n            resolver.registerContentObserver(mFontScaleUri, false, this, UserHandle.USER_ALL);\n            resolver.registerContentObserver(mHideErrorDialogsUri, false, this,\n                    UserHandle.USER_ALL);\n        }\n\n        @Override\n        public void onChange(boolean selfChange, Collection<Uri> uris, int flags,\n                @UserIdInt int userId) {\n            for (Uri uri : uris) {\n                if (mFontScaleUri.equals(uri)) {\n                    updateFontScaleIfNeeded(userId);\n                } else if (mHideErrorDialogsUri.equals(uri)) {\n                    synchronized (mGlobalLock) {\n                        updateShouldShowDialogsLocked(getGlobalConfiguration());\n                    }\n                }\n            }\n        }\n    }\n\n    /** Indicates that the method may be invoked frequently or is sensitive to performance. */\n    @Target(ElementType.METHOD)\n    @Retention(RetentionPolicy.SOURCE)\n    @interface HotPath {\n        int NONE = 0;\n        int OOM_ADJUSTMENT = 1;\n        int LRU_UPDATE = 2;\n        int PROCESS_CHANGE = 3;\n        int caller() default NONE;\n    }\n\n    private final Runnable mUpdateOomAdjRunnable = new Runnable() {\n        @Override\n        public void run() {\n            mAmInternal.updateOomAdj();\n        }\n    };\n\n    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)\n    public ActivityTaskManagerService(Context context) {\n        mContext = context;\n        mFactoryTest = FactoryTest.getMode();\n        mSystemThread = ActivityThread.currentActivityThread();\n        mUiContext = mSystemThread.getSystemUiContext();\n        mLifecycleManager = new ClientLifecycleManager();\n        mInternal = new LocalService();\n        GL_ES_VERSION = SystemProperties.getInt(\"ro.opengles.version\", GL_ES_VERSION_UNDEFINED);\n        mWindowOrganizerController = new WindowOrganizerController(this);\n        mTaskOrganizerController = mWindowOrganizerController.mTaskOrganizerController;\n    }\n\n    public void onSystemReady() {\n        synchronized (mGlobalLock) {\n            final PackageManager pm = mContext.getPackageManager();\n            mHasHeavyWeightFeature = pm.hasSystemFeature(FEATURE_CANT_SAVE_STATE);\n            mHasLeanbackFeature = pm.hasSystemFeature(FEATURE_LEANBACK);\n            mAssistUtils = new AssistUtils(mContext);\n            mVrController.onSystemReady();\n            mRecentTasks.onSystemReadyLocked();\n            mStackSupervisor.onSystemReady();\n        }\n    }\n\n    public void onInitPowerManagement() {\n        synchronized (mGlobalLock) {\n            mStackSupervisor.initPowerManagement();\n            final PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);\n            mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);\n            mVoiceWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, \"*voice*\");\n            mVoiceWakeLock.setReferenceCounted(false);\n        }\n    }\n\n    public void installSystemProviders() {\n        mFontScaleSettingObserver = new FontScaleSettingObserver();\n    }\n\n    public void retrieveSettings(ContentResolver resolver) {\n        final boolean freeformWindowManagement =\n                mContext.getPackageManager().hasSystemFeature(FEATURE_FREEFORM_WINDOW_MANAGEMENT)\n                        || Settings.Global.getInt(\n                        resolver, DEVELOPMENT_ENABLE_FREEFORM_WINDOWS_SUPPORT, 0) != 0;\n\n        final boolean supportsMultiWindow = ActivityTaskManager.supportsMultiWindow(mContext);\n        final boolean supportsPictureInPicture = supportsMultiWindow &&\n                mContext.getPackageManager().hasSystemFeature(FEATURE_PICTURE_IN_PICTURE);\n        final boolean supportsSplitScreenMultiWindow =\n                ActivityTaskManager.supportsSplitScreenMultiWindow(mContext);\n        final boolean supportsMultiDisplay = mContext.getPackageManager()\n                .hasSystemFeature(FEATURE_ACTIVITIES_ON_SECONDARY_DISPLAYS);\n        final boolean forceRtl = Settings.Global.getInt(resolver, DEVELOPMENT_FORCE_RTL, 0) != 0;\n        final boolean forceResizable = Settings.Global.getInt(\n                resolver, DEVELOPMENT_FORCE_RESIZABLE_ACTIVITIES, 0) != 0;\n        final boolean sizeCompatFreeform = Settings.Global.getInt(\n                resolver, DEVELOPMENT_ENABLE_SIZECOMPAT_FREEFORM, 0) != 0;\n\n        // Transfer any global setting for forcing RTL layout, into a System Property\n        DisplayProperties.debug_force_rtl(forceRtl);\n\n        final Configuration configuration = new Configuration();\n        Settings.System.getConfiguration(resolver, configuration);\n        if (forceRtl) {\n            // This will take care of setting the correct layout direction flags\n            configuration.setLayoutDirection(configuration.locale);\n        }\n\n        synchronized (mGlobalLock) {\n            mForceResizableActivities = forceResizable;\n            mSizeCompatFreeform = sizeCompatFreeform;\n            final boolean multiWindowFormEnabled = freeformWindowManagement\n                    || supportsSplitScreenMultiWindow\n                    || supportsPictureInPicture\n                    || supportsMultiDisplay;\n            if ((supportsMultiWindow || forceResizable) && multiWindowFormEnabled) {\n                mSupportsMultiWindow = true;\n                mSupportsFreeformWindowManagement = freeformWindowManagement;\n                mSupportsSplitScreenMultiWindow = supportsSplitScreenMultiWindow;\n                mSupportsPictureInPicture = supportsPictureInPicture;\n                mSupportsMultiDisplay = supportsMultiDisplay;\n            } else {\n                mSupportsMultiWindow = false;\n                mSupportsFreeformWindowManagement = false;\n                mSupportsSplitScreenMultiWindow = false;\n                mSupportsPictureInPicture = false;\n                mSupportsMultiDisplay = false;\n            }\n            mWindowManager.mRoot.onSettingsRetrieved();\n            // This happens before any activities are started, so we can change global configuration\n            // in-place.\n            updateConfigurationLocked(configuration, null, true);\n            final Configuration globalConfig = getGlobalConfiguration();\n            if (DEBUG_CONFIGURATION) Slog.v(TAG_CONFIGURATION, \"Initial config: \" + globalConfig);\n\n            // Load resources only after the current configuration has been set.\n            final Resources res = mContext.getResources();\n            mThumbnailWidth = res.getDimensionPixelSize(\n                    com.android.internal.R.dimen.thumbnail_width);\n            mThumbnailHeight = res.getDimensionPixelSize(\n                    com.android.internal.R.dimen.thumbnail_height);\n        }\n    }\n\n    public WindowManagerGlobalLock getGlobalLock() {\n        return mGlobalLock;\n    }\n\n    /** For test purpose only. */\n    @VisibleForTesting\n    public ActivityTaskManagerInternal getAtmInternal() {\n        return mInternal;\n    }\n\n    public void initialize(IntentFirewall intentFirewall, PendingIntentController intentController,\n            Looper looper) {\n        mH = new H(looper);\n        mUiHandler = new UiHandler();\n        mIntentFirewall = intentFirewall;\n        final File systemDir = SystemServiceManager.ensureSystemDir();\n        mAppWarnings = createAppWarnings(mUiContext, mH, mUiHandler, systemDir);\n        mCompatModePackages = new CompatModePackages(this, systemDir, mH);\n        mPendingIntentController = intentController;\n        mStackSupervisor = createStackSupervisor();\n\n        mTaskChangeNotificationController =\n                new TaskChangeNotificationController(mGlobalLock, mStackSupervisor, mH);\n        mLockTaskController = new LockTaskController(mContext, mStackSupervisor, mH);\n        mActivityStartController = new ActivityStartController(this);\n        setRecentTasks(new RecentTasks(this, mStackSupervisor));\n        mVrController = new VrController(mGlobalLock);\n        mKeyguardController = mStackSupervisor.getKeyguardController();\n    }\n\n    public void onActivityManagerInternalAdded() {\n        synchronized (mGlobalLock) {\n            mAmInternal = LocalServices.getService(ActivityManagerInternal.class);\n            mUgmInternal = LocalServices.getService(UriGrantsManagerInternal.class);\n        }\n    }\n\n    int increaseConfigurationSeqLocked() {\n        mConfigurationSeq = Math.max(++mConfigurationSeq, 1);\n        return mConfigurationSeq;\n    }\n\n    protected ActivityStackSupervisor createStackSupervisor() {\n        final ActivityStackSupervisor supervisor = new ActivityStackSupervisor(this, mH.getLooper());\n        supervisor.initialize();\n        return supervisor;\n    }\n\n    protected AppWarnings createAppWarnings(\n            Context uiContext, Handler handler, Handler uiHandler, File systemDir) {\n        return new AppWarnings(this, uiContext, handler, uiHandler, systemDir);\n    }\n\n    public void setWindowManager(WindowManagerService wm) {\n        synchronized (mGlobalLock) {\n            mWindowManager = wm;\n            mRootWindowContainer = wm.mRoot;\n            mTempConfig.setToDefaults();\n            mTempConfig.setLocales(LocaleList.getDefault());\n            mConfigurationSeq = mTempConfig.seq = 1;\n            mRootWindowContainer.onConfigurationChanged(mTempConfig);\n            mLockTaskController.setWindowManager(wm);\n            mStackSupervisor.setWindowManager(wm);\n            mRootWindowContainer.setWindowManager(wm);\n        }\n    }\n\n    public void setUsageStatsManager(UsageStatsManagerInternal usageStatsManager) {\n        synchronized (mGlobalLock) {\n            mUsageStatsInternal = usageStatsManager;\n        }\n    }\n\n    UserManagerService getUserManager() {\n        if (mUserManager == null) {\n            IBinder b = ServiceManager.getService(Context.USER_SERVICE);\n            mUserManager = (UserManagerService) IUserManager.Stub.asInterface(b);\n        }\n        return mUserManager;\n    }\n\n    AppOpsManager getAppOpsManager() {\n        if (mAppOpsManager == null) {\n            mAppOpsManager = mContext.getSystemService(AppOpsManager.class);\n        }\n        return mAppOpsManager;\n    }\n\n    boolean hasUserRestriction(String restriction, int userId) {\n        return getUserManager().hasUserRestriction(restriction, userId);\n    }\n\n    boolean hasSystemAlertWindowPermission(int callingUid, int callingPid, String callingPackage) {\n        final int mode = getAppOpsManager().noteOpNoThrow(AppOpsManager.OP_SYSTEM_ALERT_WINDOW,\n                callingUid, callingPackage, /* featureId */ null, \"\");\n        if (mode == AppOpsManager.MODE_DEFAULT) {\n            return checkPermission(Manifest.permission.SYSTEM_ALERT_WINDOW, callingPid, callingUid)\n                    == PERMISSION_GRANTED;\n        }\n        return mode == AppOpsManager.MODE_ALLOWED;\n    }\n\n    @VisibleForTesting\n    protected void setRecentTasks(RecentTasks recentTasks) {\n        mRecentTasks = recentTasks;\n        mStackSupervisor.setRecentTasks(recentTasks);\n    }\n\n    RecentTasks getRecentTasks() {\n        return mRecentTasks;\n    }\n\n    ClientLifecycleManager getLifecycleManager() {\n        return mLifecycleManager;\n    }\n\n    ActivityStartController getActivityStartController() {\n        return mActivityStartController;\n    }\n\n    TaskChangeNotificationController getTaskChangeNotificationController() {\n        return mTaskChangeNotificationController;\n    }\n\n    LockTaskController getLockTaskController() {\n        return mLockTaskController;\n    }\n\n    /**\n     * Return the global configuration used by the process corresponding to the input pid. This is\n     * usually the global configuration with some overrides specific to that process.\n     */\n    Configuration getGlobalConfigurationForCallingPid() {\n        final int pid = Binder.getCallingPid();\n        return getGlobalConfigurationForPid(pid);\n    }\n\n    /**\n     * Return the global configuration used by the process corresponding to the given pid.\n     */\n    Configuration getGlobalConfigurationForPid(int pid) {\n        if (pid == MY_PID || pid < 0) {\n            return getGlobalConfiguration();\n        }\n        synchronized (mGlobalLock) {\n            final WindowProcessController app = mProcessMap.getProcess(pid);\n            return app != null ? app.getConfiguration() : getGlobalConfiguration();\n        }\n    }\n\n    /**\n     * Return the device configuration info used by the process corresponding to the input pid.\n     * The value is consistent with the global configuration for the process.\n     */\n    @Override\n    public ConfigurationInfo getDeviceConfigurationInfo() {\n        ConfigurationInfo config = new ConfigurationInfo();\n        synchronized (mGlobalLock) {\n            final Configuration globalConfig = getGlobalConfigurationForCallingPid();\n            config.reqTouchScreen = globalConfig.touchscreen;\n            config.reqKeyboardType = globalConfig.keyboard;\n            config.reqNavigation = globalConfig.navigation;\n            if (globalConfig.navigation == Configuration.NAVIGATION_DPAD\n                    || globalConfig.navigation == Configuration.NAVIGATION_TRACKBALL) {\n                config.reqInputFeatures |= ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;\n            }\n            if (globalConfig.keyboard != Configuration.KEYBOARD_UNDEFINED\n                    && globalConfig.keyboard != Configuration.KEYBOARD_NOKEYS) {\n                config.reqInputFeatures |= ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;\n            }\n            config.reqGlEsVersion = GL_ES_VERSION;\n        }\n        return config;\n    }\n\n    private void start() {\n        LocalServices.addService(ActivityTaskManagerInternal.class, mInternal);\n    }\n\n    public static final class Lifecycle extends SystemService {\n        private final ActivityTaskManagerService mService;\n\n        public Lifecycle(Context context) {\n            super(context);\n            mService = new ActivityTaskManagerService(context);\n        }\n\n        @Override\n        public void onStart() {\n            publishBinderService(Context.ACTIVITY_TASK_SERVICE, mService);\n            mService.start();\n        }\n\n        @Override\n        public void onUnlockUser(int userId) {\n            synchronized (mService.getGlobalLock()) {\n                mService.mStackSupervisor.onUserUnlocked(userId);\n            }\n        }\n\n        @Override\n        public void onCleanupUser(int userId) {\n            synchronized (mService.getGlobalLock()) {\n                mService.mStackSupervisor.mLaunchParamsPersister.onCleanupUser(userId);\n            }\n        }\n\n        public ActivityTaskManagerService getService() {\n            return mService;\n        }\n    }\n\n    @Override\n    public final int startActivity(IApplicationThread caller, String callingPackage,\n            String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,\n            String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo,\n            Bundle bOptions) {\n        return startActivityAsUser(caller, callingPackage, callingFeatureId, intent, resolvedType,\n                resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions,\n                UserHandle.getCallingUserId());\n    }\n\n    @Override\n    public final int startActivities(IApplicationThread caller, String callingPackage,\n            String callingFeatureId, Intent[] intents, String[] resolvedTypes, IBinder resultTo,\n            Bundle bOptions, int userId) {\n        assertPackageMatchesCallingUid(callingPackage);\n        final String reason = \"startActivities\";\n        enforceNotIsolatedCaller(reason);\n        userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, reason);\n        // TODO: Switch to user app stacks here.\n        return getActivityStartController().startActivities(caller, -1, 0, -1, callingPackage,\n                callingFeatureId, intents, resolvedTypes, resultTo,\n                SafeActivityOptions.fromBundle(bOptions), userId, reason,\n                null /* originatingPendingIntent */, false /* allowBackgroundActivityStart */);\n    }\n\n    @Override\n    public int startActivityAsUser(IApplicationThread caller, String callingPackage,\n            String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,\n            String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo,\n            Bundle bOptions, int userId) {\n        return startActivityAsUser(caller, callingPackage, callingFeatureId, intent, resolvedType,\n                resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, userId,\n                true /*validateIncomingUser*/);\n    }\n\n    private int startActivityAsUser(IApplicationThread caller, String callingPackage,\n            @Nullable String callingFeatureId, Intent intent, String resolvedType,\n            IBinder resultTo, String resultWho, int requestCode, int startFlags,\n            ProfilerInfo profilerInfo, Bundle bOptions, int userId, boolean validateIncomingUser) {\n        assertPackageMatchesCallingUid(callingPackage);\n        enforceNotIsolatedCaller(\"startActivityAsUser\");\n\n        userId = getActivityStartController().checkTargetUser(userId, validateIncomingUser,\n                Binder.getCallingPid(), Binder.getCallingUid(), \"startActivityAsUser\");\n\n        // TODO: Switch to user app stacks here.\n        return getActivityStartController().obtainStarter(intent, \"startActivityAsUser\")\n                .setCaller(caller)\n                .setCallingPackage(callingPackage)\n                .setCallingFeatureId(callingFeatureId)\n                .setResolvedType(resolvedType)\n                .setResultTo(resultTo)\n                .setResultWho(resultWho)\n                .setRequestCode(requestCode)\n                .setStartFlags(startFlags)\n                .setProfilerInfo(profilerInfo)\n                .setActivityOptions(bOptions)\n                .setUserId(userId)\n                .execute();\n\n    }\n\n    @Override\n    public int startActivityIntentSender(IApplicationThread caller, IIntentSender target,\n            IBinder whitelistToken, Intent fillInIntent, String resolvedType, IBinder resultTo,\n            String resultWho, int requestCode, int flagsMask, int flagsValues, Bundle bOptions) {\n        enforceNotIsolatedCaller(\"startActivityIntentSender\");\n        // Refuse possible leaked file descriptors\n        if (fillInIntent != null && fillInIntent.hasFileDescriptors()) {\n            throw new IllegalArgumentException(\"File descriptors passed in Intent\");\n        }\n\n        if (!(target instanceof PendingIntentRecord)) {\n            throw new IllegalArgumentException(\"Bad PendingIntent object\");\n        }\n\n        PendingIntentRecord pir = (PendingIntentRecord)target;\n\n        synchronized (mGlobalLock) {\n            // If this is coming from the currently resumed activity, it is\n            // effectively saying that app switches are allowed at this point.\n            final ActivityStack stack = getTopDisplayFocusedStack();\n            if (stack != null && stack.mResumedActivity != null\n                    && stack.mResumedActivity.info.applicationInfo.uid == Binder.getCallingUid()) {\n                mAppSwitchesAllowedTime = 0;\n            }\n        }\n        return pir.sendInner(0, fillInIntent, resolvedType, whitelistToken, null, null,\n                resultTo, resultWho, requestCode, flagsMask, flagsValues, bOptions);\n    }\n\n    @Override\n    public boolean startNextMatchingActivity(IBinder callingActivity, Intent intent,\n            Bundle bOptions) {\n        // Refuse possible leaked file descriptors\n        if (intent != null && intent.hasFileDescriptors()) {\n            throw new IllegalArgumentException(\"File descriptors passed in Intent\");\n        }\n        SafeActivityOptions options = SafeActivityOptions.fromBundle(bOptions);\n\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInStackLocked(callingActivity);\n            if (r == null) {\n                SafeActivityOptions.abort(options);\n                return false;\n            }\n            if (!r.attachedToProcess()) {\n                // The caller is not running...  d'oh!\n                SafeActivityOptions.abort(options);\n                return false;\n            }\n            intent = new Intent(intent);\n            // The caller is not allowed to change the data.\n            intent.setDataAndType(r.intent.getData(), r.intent.getType());\n            // And we are resetting to find the next component...\n            intent.setComponent(null);\n\n            final boolean debug = ((intent.getFlags() & Intent.FLAG_DEBUG_LOG_RESOLUTION) != 0);\n\n            ActivityInfo aInfo = null;\n            try {\n                List<ResolveInfo> resolves =\n                        AppGlobals.getPackageManager().queryIntentActivities(\n                                intent, r.resolvedType,\n                                PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS,\n                                UserHandle.getCallingUserId()).getList();\n\n                // Look for the original activity in the list...\n                final int N = resolves != null ? resolves.size() : 0;\n                for (int i=0; i<N; i++) {\n                    ResolveInfo rInfo = resolves.get(i);\n                    if (rInfo.activityInfo.packageName.equals(r.packageName)\n                            && rInfo.activityInfo.name.equals(r.info.name)) {\n                        // We found the current one...  the next matching is\n                        // after it.\n                        i++;\n                        if (i<N) {\n                            aInfo = resolves.get(i).activityInfo;\n                        }\n                        if (debug) {\n                            Slog.v(TAG, \"Next matching activity: found current \" + r.packageName\n                                    + \"/\" + r.info.name);\n                            Slog.v(TAG, \"Next matching activity: next is \" + ((aInfo == null)\n                                    ? \"null\" : aInfo.packageName + \"/\" + aInfo.name));\n                        }\n                        break;\n                    }\n                }\n            } catch (RemoteException e) {\n            }\n\n            if (aInfo == null) {\n                // Nobody who is next!\n                SafeActivityOptions.abort(options);\n                if (debug) Slog.d(TAG, \"Next matching activity: nothing found\");\n                return false;\n            }\n\n            intent.setComponent(new ComponentName(\n                    aInfo.applicationInfo.packageName, aInfo.name));\n            intent.setFlags(intent.getFlags()&~(\n                    Intent.FLAG_ACTIVITY_FORWARD_RESULT|\n                            Intent.FLAG_ACTIVITY_CLEAR_TOP|\n                            Intent.FLAG_ACTIVITY_MULTIPLE_TASK|\n                            FLAG_ACTIVITY_NEW_TASK));\n\n            // Okay now we need to start the new activity, replacing the currently running activity.\n            // This is a little tricky because we want to start the new one as if the current one is\n            // finished, but not finish the current one first so that there is no flicker.\n            // And thus...\n            final boolean wasFinishing = r.finishing;\n            r.finishing = true;\n\n            // Propagate reply information over to the new activity.\n            final ActivityRecord resultTo = r.resultTo;\n            final String resultWho = r.resultWho;\n            final int requestCode = r.requestCode;\n            r.resultTo = null;\n            if (resultTo != null) {\n                resultTo.removeResultsLocked(r, resultWho, requestCode);\n            }\n\n            final long origId = Binder.clearCallingIdentity();\n            // TODO(b/64750076): Check if calling pid should really be -1.\n            final int res = getActivityStartController()\n                    .obtainStarter(intent, \"startNextMatchingActivity\")\n                    .setCaller(r.app.getThread())\n                    .setResolvedType(r.resolvedType)\n                    .setActivityInfo(aInfo)\n                    .setResultTo(resultTo != null ? resultTo.appToken : null)\n                    .setResultWho(resultWho)\n                    .setRequestCode(requestCode)\n                    .setCallingPid(-1)\n                    .setCallingUid(r.launchedFromUid)\n                    .setCallingPackage(r.launchedFromPackage)\n                    .setCallingFeatureId(r.launchedFromFeatureId)\n                    .setRealCallingPid(-1)\n                    .setRealCallingUid(r.launchedFromUid)\n                    .setActivityOptions(options)\n                    .execute();\n            Binder.restoreCallingIdentity(origId);\n\n            r.finishing = wasFinishing;\n            if (res != ActivityManager.START_SUCCESS) {\n                return false;\n            }\n            return true;\n        }\n    }\n\n    private void enforceCallerIsDream(String callerPackageName) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            if (!ActivityRecord.canLaunchDreamActivity(callerPackageName)) {\n                throw new SecurityException(\"The dream activity can be started only when the device\"\n                        + \" is dreaming and only by the active dream package.\");\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public boolean startDreamActivity(@NonNull Intent intent) {\n        assertPackageMatchesCallingUid(intent.getPackage());\n        enforceCallerIsDream(intent.getPackage());\n\n        final ActivityInfo a = new ActivityInfo();\n        a.theme = com.android.internal.R.style.Theme_Dream;\n        a.exported = true;\n        a.name = DreamActivity.class.getName();\n        a.enabled = true;\n        a.launchMode = ActivityInfo.LAUNCH_SINGLE_INSTANCE;\n        a.persistableMode = ActivityInfo.PERSIST_NEVER;\n        a.screenOrientation = ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;\n        a.colorMode = ActivityInfo.COLOR_MODE_DEFAULT;\n        a.flags |= ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;\n\n        final ActivityOptions options = ActivityOptions.makeBasic();\n        options.setLaunchActivityType(ACTIVITY_TYPE_DREAM);\n\n        synchronized (mGlobalLock) {\n            final WindowProcessController process = mProcessMap.getProcess(Binder.getCallingPid());\n\n            a.packageName = process.mInfo.packageName;\n            a.applicationInfo = process.mInfo;\n            a.processName = process.mInfo.processName;\n            a.uiOptions = process.mInfo.uiOptions;\n            a.taskAffinity = \"android:\" + a.packageName + \"/dream\";\n\n            final int callingUid = Binder.getCallingUid();\n            final int callingPid = Binder.getCallingPid();\n\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                getActivityStartController().obtainStarter(intent, \"dream\")\n                        .setCallingUid(callingUid)\n                        .setCallingPid(callingPid)\n                        .setActivityInfo(a)\n                        .setActivityOptions(options.toBundle())\n                        // To start the dream from background, we need to start it from a persistent\n                        // system process. Here we set the real calling uid to the system server uid\n                        .setRealCallingUid(Binder.getCallingUid())\n                        .setAllowBackgroundActivityStart(true)\n                        .execute();\n                return true;\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public final WaitResult startActivityAndWait(IApplicationThread caller, String callingPackage,\n            String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,\n            String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo,\n            Bundle bOptions, int userId) {\n        assertPackageMatchesCallingUid(callingPackage);\n        final WaitResult res = new WaitResult();\n        enforceNotIsolatedCaller(\"startActivityAndWait\");\n        userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),\n                userId, \"startActivityAndWait\");\n        // TODO: Switch to user app stacks here.\n        getActivityStartController().obtainStarter(intent, \"startActivityAndWait\")\n                .setCaller(caller)\n                .setCallingPackage(callingPackage)\n                .setCallingFeatureId(callingFeatureId)\n                .setResolvedType(resolvedType)\n                .setResultTo(resultTo)\n                .setResultWho(resultWho)\n                .setRequestCode(requestCode)\n                .setStartFlags(startFlags)\n                .setActivityOptions(bOptions)\n                .setUserId(userId)\n                .setProfilerInfo(profilerInfo)\n                .setWaitResult(res)\n                .execute();\n        return res;\n    }\n\n    @Override\n    public final int startActivityWithConfig(IApplicationThread caller, String callingPackage,\n            String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,\n            String resultWho, int requestCode, int startFlags, Configuration config,\n            Bundle bOptions, int userId) {\n        assertPackageMatchesCallingUid(callingPackage);\n        enforceNotIsolatedCaller(\"startActivityWithConfig\");\n        userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,\n                \"startActivityWithConfig\");\n        // TODO: Switch to user app stacks here.\n        return getActivityStartController().obtainStarter(intent, \"startActivityWithConfig\")\n                .setCaller(caller)\n                .setCallingPackage(callingPackage)\n                .setCallingFeatureId(callingFeatureId)\n                .setResolvedType(resolvedType)\n                .setResultTo(resultTo)\n                .setResultWho(resultWho)\n                .setRequestCode(requestCode)\n                .setStartFlags(startFlags)\n                .setGlobalConfiguration(config)\n                .setActivityOptions(bOptions)\n                .setUserId(userId)\n                .execute();\n    }\n\n    @Override\n    public IBinder requestStartActivityPermissionToken(IBinder delegatorToken) {\n        int callingUid = Binder.getCallingUid();\n        if (UserHandle.getAppId(callingUid) != SYSTEM_UID) {\n            throw new SecurityException(\"Only the system process can request a permission token, \"\n                    + \"received request from uid: \" + callingUid);\n        }\n        IBinder permissionToken = new Binder();\n        synchronized (mGlobalLock) {\n            mStartActivitySources.put(permissionToken, delegatorToken);\n        }\n\n        Message expireMsg = PooledLambda.obtainMessage(\n                ActivityTaskManagerService::expireStartAsCallerTokenMsg, this, permissionToken);\n        mUiHandler.sendMessageDelayed(expireMsg, START_AS_CALLER_TOKEN_TIMEOUT_IMPL);\n\n        Message forgetMsg = PooledLambda.obtainMessage(\n                ActivityTaskManagerService::forgetStartAsCallerTokenMsg, this, permissionToken);\n        mUiHandler.sendMessageDelayed(forgetMsg, START_AS_CALLER_TOKEN_EXPIRED_TIMEOUT);\n\n        return permissionToken;\n    }\n\n    @Override\n    public final int startActivityAsCaller(IApplicationThread caller, String callingPackage,\n            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, IBinder permissionToken,\n            boolean ignoreTargetSecurity, int userId) {\n        // This is very dangerous -- it allows you to perform a start activity (including\n        // permission grants) as any app that may launch one of your own activities.  So we only\n        // allow this in two cases:\n        // 1)  The caller is an activity that is part of the core framework, and then only when it\n        //     is running as the system.\n        // 2)  The caller provides a valid permissionToken.  Permission tokens are one-time use and\n        //     can only be requested by a system activity, which may then delegate this call to\n        //     another app.\n        final ActivityRecord sourceRecord;\n        final int targetUid;\n        final String targetPackage;\n        final String targetFeatureId;\n        final boolean isResolver;\n        synchronized (mGlobalLock) {\n            if (resultTo == null) {\n                throw new SecurityException(\"Must be called from an activity\");\n            }\n            final IBinder sourceToken;\n            if (permissionToken != null) {\n                // To even attempt to use a permissionToken, an app must also have this signature\n                // permission.\n                mAmInternal.enforceCallingPermission(\n                        android.Manifest.permission.START_ACTIVITY_AS_CALLER,\n                        \"startActivityAsCaller\");\n                // If called with a permissionToken, we want the sourceRecord from the delegator\n                // activity that requested this token.\n                sourceToken = mStartActivitySources.remove(permissionToken);\n                if (sourceToken == null) {\n                    // Invalid permissionToken, check if it recently expired.\n                    if (mExpiredStartAsCallerTokens.contains(permissionToken)) {\n                        throw new SecurityException(\"Called with expired permission token: \"\n                                + permissionToken);\n                    } else {\n                        throw new SecurityException(\"Called with invalid permission token: \"\n                                + permissionToken);\n                    }\n                }\n            } else {\n                // This method was called directly by the source.\n                sourceToken = resultTo;\n            }\n\n            sourceRecord = mRootWindowContainer.isInAnyStack(sourceToken);\n            if (sourceRecord == null) {\n                throw new SecurityException(\"Called with bad activity token: \" + sourceToken);\n            }\n            if (sourceRecord.app == null) {\n                throw new SecurityException(\"Called without a process attached to activity\");\n            }\n\n            // Whether called directly or from a delegate, the source activity must be from the\n            // android package.\n            if (!sourceRecord.info.packageName.equals(\"android\")) {\n                throw new SecurityException(\"Must be called from an activity that is \"\n                        + \"declared in the android package\");\n            }\n\n            if (UserHandle.getAppId(sourceRecord.app.mUid) != SYSTEM_UID) {\n                // This is still okay, as long as this activity is running under the\n                // uid of the original calling activity.\n                if (sourceRecord.app.mUid != sourceRecord.launchedFromUid) {\n                    throw new SecurityException(\n                            \"Calling activity in uid \" + sourceRecord.app.mUid\n                                    + \" must be system uid or original calling uid \"\n                                    + sourceRecord.launchedFromUid);\n                }\n            }\n            if (ignoreTargetSecurity) {\n                if (intent.getComponent() == null) {\n                    throw new SecurityException(\n                            \"Component must be specified with ignoreTargetSecurity\");\n                }\n                if (intent.getSelector() != null) {\n                    throw new SecurityException(\n                            \"Selector not allowed with ignoreTargetSecurity\");\n                }\n            }\n            targetUid = sourceRecord.launchedFromUid;\n            targetPackage = sourceRecord.launchedFromPackage;\n            targetFeatureId = sourceRecord.launchedFromFeatureId;\n            isResolver = sourceRecord.isResolverOrChildActivity();\n        }\n\n        if (userId == UserHandle.USER_NULL) {\n            userId = UserHandle.getUserId(sourceRecord.app.mUid);\n        }\n\n        // TODO: Switch to user app stacks here.\n        try {\n            return getActivityStartController().obtainStarter(intent, \"startActivityAsCaller\")\n                    .setCallingUid(targetUid)\n                    .setCallingPackage(targetPackage)\n                    .setCallingFeatureId(targetFeatureId)\n                    .setResolvedType(resolvedType)\n                    .setResultTo(resultTo)\n                    .setResultWho(resultWho)\n                    .setRequestCode(requestCode)\n                    .setStartFlags(startFlags)\n                    .setActivityOptions(bOptions)\n                    .setUserId(userId)\n                    .setIgnoreTargetSecurity(ignoreTargetSecurity)\n                    .setFilterCallingUid(isResolver ? 0 /* system */ : targetUid)\n                    // The target may well be in the background, which would normally prevent it\n                    // from starting an activity. Here we definitely want the start to succeed.\n                    .setAllowBackgroundActivityStart(true)\n                    .execute();\n        } catch (SecurityException e) {\n            // XXX need to figure out how to propagate to original app.\n            // A SecurityException here is generally actually a fault of the original\n            // calling activity (such as a fairly granting permissions), so propagate it\n            // back to them.\n            /*\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"While launching\");\n            msg.append(intent.toString());\n            msg.append(\": \");\n            msg.append(e.getMessage());\n            */\n            throw e;\n        }\n    }\n\n    int handleIncomingUser(int callingPid, int callingUid, int userId, String name) {\n        return mAmInternal.handleIncomingUser(callingPid, callingUid, userId, false /* allowAll */,\n                ALLOW_NON_FULL, name, null /* callerPackage */);\n    }\n\n    @Override\n    public int startVoiceActivity(String callingPackage, String callingFeatureId, int callingPid,\n            int callingUid, Intent intent, String resolvedType, IVoiceInteractionSession session,\n            IVoiceInteractor interactor, int startFlags, ProfilerInfo profilerInfo,\n            Bundle bOptions, int userId) {\n        assertPackageMatchesCallingUid(callingPackage);\n        mAmInternal.enforceCallingPermission(BIND_VOICE_INTERACTION, \"startVoiceActivity()\");\n        if (session == null || interactor == null) {\n            throw new NullPointerException(\"null session or interactor\");\n        }\n        userId = handleIncomingUser(callingPid, callingUid, userId, \"startVoiceActivity\");\n        // TODO: Switch to user app stacks here.\n        return getActivityStartController().obtainStarter(intent, \"startVoiceActivity\")\n                .setCallingUid(callingUid)\n                .setCallingPackage(callingPackage)\n                .setCallingFeatureId(callingFeatureId)\n                .setResolvedType(resolvedType)\n                .setVoiceSession(session)\n                .setVoiceInteractor(interactor)\n                .setStartFlags(startFlags)\n                .setProfilerInfo(profilerInfo)\n                .setActivityOptions(bOptions)\n                .setUserId(userId)\n                .setAllowBackgroundActivityStart(true)\n                .execute();\n    }\n\n    @Override\n    public int startAssistantActivity(String callingPackage, @NonNull String callingFeatureId,\n            int callingPid, int callingUid, Intent intent, String resolvedType, Bundle bOptions,\n            int userId) {\n        assertPackageMatchesCallingUid(callingPackage);\n        mAmInternal.enforceCallingPermission(BIND_VOICE_INTERACTION, \"startAssistantActivity()\");\n        userId = handleIncomingUser(callingPid, callingUid, userId, \"startAssistantActivity\");\n\n        return getActivityStartController().obtainStarter(intent, \"startAssistantActivity\")\n                .setCallingUid(callingUid)\n                .setCallingPackage(callingPackage)\n                .setCallingFeatureId(callingFeatureId)\n                .setResolvedType(resolvedType)\n                .setActivityOptions(bOptions)\n                .setUserId(userId)\n                .setAllowBackgroundActivityStart(true)\n                .execute();\n    }\n\n    /**\n     * Start the recents activity to perform the recents animation.\n     *\n     * @param intent The intent to start the recents activity.\n     * @param recentsAnimationRunner Pass {@code null} to only preload the activity.\n     */\n    @Override\n    public void startRecentsActivity(Intent intent, @Deprecated IAssistDataReceiver unused,\n            @Nullable IRecentsAnimationRunner recentsAnimationRunner) {\n        enforceCallerIsRecentsOrHasPermission(MANAGE_ACTIVITY_STACKS, \"startRecentsActivity()\");\n        final int callingPid = Binder.getCallingPid();\n        final int callingUid = Binder.getCallingUid();\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ComponentName recentsComponent = mRecentTasks.getRecentsComponent();\n                final String recentsFeatureId = mRecentTasks.getRecentsComponentFeatureId();\n                final int recentsUid = mRecentTasks.getRecentsComponentUid();\n                final WindowProcessController caller = getProcessController(callingPid, callingUid);\n\n                // Start a new recents animation\n                final RecentsAnimation anim = new RecentsAnimation(this, mStackSupervisor,\n                        getActivityStartController(), mWindowManager, intent, recentsComponent,\n                        recentsFeatureId, recentsUid, caller);\n                if (recentsAnimationRunner == null) {\n                    anim.preloadRecentsActivity();\n                } else {\n                    anim.startRecentsActivity(recentsAnimationRunner);\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public final int startActivityFromRecents(int taskId, Bundle bOptions) {\n        enforceCallerIsRecentsOrHasPermission(START_TASKS_FROM_RECENTS,\n                \"startActivityFromRecents()\");\n\n        final int callingPid = Binder.getCallingPid();\n        final int callingUid = Binder.getCallingUid();\n        final SafeActivityOptions safeOptions = SafeActivityOptions.fromBundle(bOptions);\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                return mStackSupervisor.startActivityFromRecents(callingPid, callingUid, taskId,\n                        safeOptions);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    /**\n     * Public API to check if the client is allowed to start an activity on specified display.\n     *\n     * If the target display is private or virtual, some restrictions will apply.\n     *\n     * @param displayId Target display id.\n     * @param intent Intent used to launch the activity.\n     * @param resolvedType The MIME type of the intent.\n     * @param userId The id of the user for whom the call is made.\n     * @return {@code true} if a call to start an activity on the target display should succeed and\n     *         no {@link SecurityException} will be thrown, {@code false} otherwise.\n     */\n    @Override\n    public final boolean isActivityStartAllowedOnDisplay(int displayId, Intent intent,\n            String resolvedType, int userId) {\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        final long origId = Binder.clearCallingIdentity();\n\n        try {\n            // Collect information about the target of the Intent.\n            ActivityInfo aInfo = mStackSupervisor.resolveActivity(intent, resolvedType,\n                    0 /* startFlags */, null /* profilerInfo */, userId,\n                    ActivityStarter.computeResolveFilterUid(callingUid, callingUid,\n                            UserHandle.USER_NULL));\n            aInfo = mAmInternal.getActivityInfoForUser(aInfo, userId);\n\n            synchronized (mGlobalLock) {\n                return mStackSupervisor.canPlaceEntityOnDisplay(displayId, callingPid, callingUid,\n                        aInfo);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    /**\n     * This is the internal entry point for handling Activity.finish().\n     *\n     * @param token The Binder token referencing the Activity we want to finish.\n     * @param resultCode Result code, if any, from this Activity.\n     * @param resultData Result data (Intent), if any, from this Activity.\n     * @param finishTask Whether to finish the task associated with this Activity.\n     *\n     * @return Returns true if the activity successfully finished, or false if it is still running.\n     */\n    @Override\n    public final boolean finishActivity(IBinder token, int resultCode, Intent resultData,\n            int finishTask) {\n        // Refuse possible leaked file descriptors\n        if (resultData != null && resultData.hasFileDescriptors()) {\n            throw new IllegalArgumentException(\"File descriptors passed in Intent\");\n        }\n\n        final ActivityRecord r;\n        synchronized (mGlobalLock) {\n            r = ActivityRecord.isInStackLocked(token);\n            if (r == null) {\n                return true;\n            }\n        }\n\n        // Carefully collect grants without holding lock\n        final NeededUriGrants resultGrants = collectGrants(resultData, r.resultTo);\n\n        synchronized (mGlobalLock) {\n            // Sanity check in case activity was removed before entering global lock.\n            if (!r.isInHistory()) {\n                return true;\n            }\n\n            // Keep track of the root activity of the task before we finish it\n            final Task tr = r.getTask();\n            final ActivityRecord rootR = tr.getRootActivity();\n            if (rootR == null) {\n                Slog.w(TAG, \"Finishing task with all activities already finished\");\n            }\n            // Do not allow task to finish if last task in lockTask mode. Launchable priv-apps can\n            // finish.\n            if (getLockTaskController().activityBlockedFromFinish(r)) {\n                return false;\n            }\n\n            // TODO: There is a dup. of this block of code in ActivityStack.navigateUpToLocked\n            // We should consolidate.\n            if (mController != null) {\n                // Find the first activity that is not finishing.\n                final ActivityRecord next =\n                        r.getRootTask().topRunningActivity(token, INVALID_TASK_ID);\n                if (next != null) {\n                    // ask watcher if this is allowed\n                    boolean resumeOK = true;\n                    try {\n                        resumeOK = mController.activityResuming(next.packageName);\n                    } catch (RemoteException e) {\n                        mController = null;\n                        Watchdog.getInstance().setActivityController(null);\n                    }\n\n                    if (!resumeOK) {\n                        Slog.i(TAG, \"Not finishing activity because controller resumed\");\n                        return false;\n                    }\n                }\n            }\n\n            // note down that the process has finished an activity and is in background activity\n            // starts grace period\n            if (r.app != null) {\n                r.app.setLastActivityFinishTimeIfNeeded(SystemClock.uptimeMillis());\n            }\n\n            final long origId = Binder.clearCallingIdentity();\n            Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, \"finishActivity\");\n            try {\n                boolean res;\n                final boolean finishWithRootActivity =\n                        finishTask == Activity.FINISH_TASK_WITH_ROOT_ACTIVITY;\n                if (finishTask == Activity.FINISH_TASK_WITH_ACTIVITY\n                        || (finishWithRootActivity && r == rootR)) {\n                    // If requested, remove the task that is associated to this activity only if it\n                    // was the root activity in the task. The result code and data is ignored\n                    // because we don't support returning them across task boundaries. Also, to\n                    // keep backwards compatibility we remove the task from recents when finishing\n                    // task with root activity.\n                    mStackSupervisor.removeTask(tr, false /*killProcess*/,\n                            finishWithRootActivity, \"finish-activity\");\n                    res = true;\n                    // Explicitly dismissing the activity so reset its relaunch flag.\n                    r.mRelaunchReason = RELAUNCH_REASON_NONE;\n                } else {\n                    r.finishIfPossible(resultCode, resultData, resultGrants,\n                            \"app-request\", true /* oomAdj */);\n                    res = r.finishing;\n                    if (!res) {\n                        Slog.i(TAG, \"Failed to finish by app-request\");\n                    }\n                }\n                return res;\n            } finally {\n                Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public boolean finishActivityAffinity(IBinder token) {\n        synchronized (mGlobalLock) {\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                ActivityRecord r = ActivityRecord.isInStackLocked(token);\n                if (r == null) {\n                    return false;\n                }\n\n                // Do not allow task to finish if last task in lockTask mode. Launchable priv-apps\n                // can finish.\n                if (getLockTaskController().activityBlockedFromFinish(r)) {\n                    return false;\n                }\n\n                final PooledFunction p = PooledLambda.obtainFunction(\n                        ActivityRecord::finishIfSameAffinity, r,\n                        PooledLambda.__(ActivityRecord.class));\n                r.getTask().forAllActivities(\n                        p, r, true /*includeBoundary*/, true /*traverseTopToBottom*/);\n                p.recycle();\n\n                return true;\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, \"activityIdle\");\n                final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n                if (r == null) {\n                    return;\n                }\n                mStackSupervisor.activityIdleInternal(r, false /* fromTimeout */,\n                        false /* processPausingActivities */, config);\n                if (stopProfiling && r.hasProcess()) {\n                    r.app.clearProfilerIfNeeded();\n                }\n            }\n        } finally {\n            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public final void activityResumed(IBinder token) {\n        final long origId = Binder.clearCallingIdentity();\n        synchronized (mGlobalLock) {\n            ActivityRecord.activityResumedLocked(token);\n        }\n        Binder.restoreCallingIdentity(origId);\n    }\n\n    @Override\n    public final void activityTopResumedStateLost() {\n        final long origId = Binder.clearCallingIdentity();\n        synchronized (mGlobalLock) {\n            mStackSupervisor.handleTopResumedStateReleased(false /* timeout */);\n        }\n        Binder.restoreCallingIdentity(origId);\n    }\n\n    @Override\n    public final void activityPaused(IBinder token) {\n        final long origId = Binder.clearCallingIdentity();\n        synchronized (mGlobalLock) {\n            Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, \"activityPaused\");\n            final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n            if (r != null) {\n                r.activityPaused(false);\n            }\n            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);\n        }\n        Binder.restoreCallingIdentity(origId);\n    }\n\n    @Override\n    public final void activityStopped(IBinder token, Bundle icicle,\n            PersistableBundle persistentState, CharSequence description) {\n        if (DEBUG_ALL) Slog.v(TAG, \"Activity stopped: token=\" + token);\n\n        // Refuse possible leaked file descriptors\n        if (icicle != null && icicle.hasFileDescriptors()) {\n            throw new IllegalArgumentException(\"File descriptors passed in Bundle\");\n        }\n\n        final long origId = Binder.clearCallingIdentity();\n\n        String restartingName = null;\n        int restartingUid = 0;\n        final ActivityRecord r;\n        synchronized (mGlobalLock) {\n            Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, \"activityStopped\");\n            r = ActivityRecord.isInStackLocked(token);\n            if (r != null) {\n                if (r.attachedToProcess()\n                        && r.isState(ActivityStack.ActivityState.RESTARTING_PROCESS)) {\n                    // The activity was requested to restart from\n                    // {@link #restartActivityProcessIfVisible}.\n                    restartingName = r.app.mName;\n                    restartingUid = r.app.mUid;\n                }\n                r.activityStopped(icicle, persistentState, description);\n            }\n            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);\n        }\n\n        if (restartingName != null) {\n            // In order to let the foreground activity can be restarted with its saved state from\n            // {@link android.app.Activity#onSaveInstanceState}, the kill operation is postponed\n            // until the activity reports stopped with the state. And the activity record will be\n            // kept because the record state is restarting, then the activity will be restarted\n            // immediately if it is still the top one.\n            mStackSupervisor.removeRestartTimeouts(r);\n            mAmInternal.killProcess(restartingName, restartingUid, \"restartActivityProcess\");\n        }\n        mAmInternal.trimApplications();\n\n        Binder.restoreCallingIdentity(origId);\n    }\n\n    @Override\n    public final void activityDestroyed(IBinder token) {\n        if (DEBUG_SWITCH) Slog.v(TAG_SWITCH, \"ACTIVITY DESTROYED: \" + token);\n        synchronized (mGlobalLock) {\n            final long origId = Binder.clearCallingIdentity();\n            Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, \"activityDestroyed\");\n            try {\n                final ActivityRecord activity = ActivityRecord.forTokenLocked(token);\n                if (activity != null) {\n                    activity.destroyed(\"activityDestroyed\");\n                }\n            } finally {\n                Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public final void activityRelaunched(IBinder token) {\n        final long origId = Binder.clearCallingIdentity();\n        synchronized (mGlobalLock) {\n            mStackSupervisor.activityRelaunchedLocked(token);\n        }\n        Binder.restoreCallingIdentity(origId);\n    }\n\n    @Override\n    public void setRequestedOrientation(IBinder token, int requestedOrientation) {\n        synchronized (mGlobalLock) {\n            ActivityRecord r = ActivityRecord.isInStackLocked(token);\n            if (r == null) {\n                return;\n            }\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                r.setRequestedOrientation(requestedOrientation);\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public int getRequestedOrientation(IBinder token) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInStackLocked(token);\n            return (r != null)\n                    ? r.getRequestedOrientation() : ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;\n        }\n    }\n\n    @Override\n    public void setImmersive(IBinder token, boolean immersive) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInStackLocked(token);\n            if (r == null) {\n                throw new IllegalArgumentException();\n            }\n            r.immersive = immersive;\n\n            // update associated state if we're frontmost\n            if (r.isResumedActivityOnDisplay()) {\n                if (DEBUG_IMMERSIVE) Slog.d(TAG_IMMERSIVE, \"Frontmost changed immersion: \"+ r);\n                applyUpdateLockStateLocked(r);\n            }\n        }\n    }\n\n    void applyUpdateLockStateLocked(ActivityRecord r) {\n        // Modifications to the UpdateLock state are done on our handler, outside\n        // the activity manager's locks.  The new state is determined based on the\n        // state *now* of the relevant activity record.  The object is passed to\n        // the handler solely for logging detail, not to be consulted/modified.\n        final boolean nextState = r != null && r.immersive;\n        mH.post(() -> {\n            if (mUpdateLock.isHeld() != nextState) {\n                if (DEBUG_IMMERSIVE) Slog.d(TAG_IMMERSIVE,\n                        \"Applying new update lock state '\" + nextState + \"' for \" + r);\n                if (nextState) {\n                    mUpdateLock.acquire();\n                } else {\n                    mUpdateLock.release();\n                }\n            }\n        });\n    }\n\n    @Override\n    public boolean isImmersive(IBinder token) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInStackLocked(token);\n            if (r == null) {\n                throw new IllegalArgumentException();\n            }\n            return r.immersive;\n        }\n    }\n\n    @Override\n    public boolean isTopActivityImmersive() {\n        enforceNotIsolatedCaller(\"isTopActivityImmersive\");\n        synchronized (mGlobalLock) {\n            final ActivityStack topFocusedStack = getTopDisplayFocusedStack();\n            if (topFocusedStack == null) {\n                return false;\n            }\n\n            final ActivityRecord r = topFocusedStack.topRunningActivity();\n            return r != null && r.immersive;\n        }\n    }\n\n    @Override\n    public void overridePendingTransition(IBinder token, String packageName,\n            int enterAnim, int exitAnim) {\n        synchronized (mGlobalLock) {\n            ActivityRecord self = ActivityRecord.isInStackLocked(token);\n            if (self == null) {\n                return;\n            }\n\n            final long origId = Binder.clearCallingIdentity();\n\n            if (self.isState(\n                    ActivityStack.ActivityState.RESUMED, ActivityStack.ActivityState.PAUSING)) {\n                self.getDisplay().mDisplayContent.mAppTransition.overridePendingAppTransition(\n                        packageName, enterAnim, exitAnim, null, null);\n            }\n\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public int getFrontActivityScreenCompatMode() {\n        enforceNotIsolatedCaller(\"getFrontActivityScreenCompatMode\");\n        synchronized (mGlobalLock) {\n            final ActivityStack stack = getTopDisplayFocusedStack();\n            final ActivityRecord r = stack != null ? stack.topRunningActivity() : null;\n            if (r == null) {\n                return ActivityManager.COMPAT_MODE_UNKNOWN;\n            }\n            return mCompatModePackages.computeCompatModeLocked(r.info.applicationInfo);\n        }\n    }\n\n    @Override\n    public void setFrontActivityScreenCompatMode(int mode) {\n        mAmInternal.enforceCallingPermission(android.Manifest.permission.SET_SCREEN_COMPATIBILITY,\n                \"setFrontActivityScreenCompatMode\");\n        ApplicationInfo ai;\n        synchronized (mGlobalLock) {\n            final ActivityStack stack = getTopDisplayFocusedStack();\n            final ActivityRecord r = stack != null ? stack.topRunningActivity() : null;\n            if (r == null) {\n                Slog.w(TAG, \"setFrontActivityScreenCompatMode failed: no top activity\");\n                return;\n            }\n            ai = r.info.applicationInfo;\n            mCompatModePackages.setPackageScreenCompatModeLocked(ai, mode);\n        }\n    }\n\n    @Override\n    public int getLaunchedFromUid(IBinder activityToken) {\n        ActivityRecord srec;\n        synchronized (mGlobalLock) {\n            srec = ActivityRecord.forTokenLocked(activityToken);\n        }\n        if (srec == null) {\n            return -1;\n        }\n        return srec.launchedFromUid;\n    }\n\n    @Override\n    public String getLaunchedFromPackage(IBinder activityToken) {\n        ActivityRecord srec;\n        synchronized (mGlobalLock) {\n            srec = ActivityRecord.forTokenLocked(activityToken);\n        }\n        if (srec == null) {\n            return null;\n        }\n        return srec.launchedFromPackage;\n    }\n\n    @Override\n    public boolean convertFromTranslucent(IBinder token) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInStackLocked(token);\n                if (r == null) {\n                    return false;\n                }\n                return r.setOccludesParent(true);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public boolean convertToTranslucent(IBinder token, Bundle options) {\n        SafeActivityOptions safeOptions = SafeActivityOptions.fromBundle(options);\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInStackLocked(token);\n                if (r == null) {\n                    return false;\n                }\n                final ActivityRecord under = r.getTask().getActivityBelow(r);\n                if (under != null) {\n                    under.returningOptions = safeOptions != null ? safeOptions.getOptions(r) : null;\n                }\n                return r.setOccludesParent(false);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public void notifyActivityDrawn(IBinder token) {\n        if (DEBUG_VISIBILITY) Slog.d(TAG_VISIBILITY, \"notifyActivityDrawn: token=\" + token);\n        synchronized (mGlobalLock) {\n            ActivityRecord r = mRootWindowContainer.isInAnyStack(token);\n            if (r != null) {\n                r.getRootTask().notifyActivityDrawnLocked(r);\n            }\n        }\n    }\n\n    @Override\n    public void reportActivityFullyDrawn(IBinder token, boolean restoredFromBundle) {\n        synchronized (mGlobalLock) {\n            ActivityRecord r = ActivityRecord.isInStackLocked(token);\n            if (r == null) {\n                return;\n            }\n            r.reportFullyDrawnLocked(restoredFromBundle);\n        }\n    }\n\n    @Override\n    public int getDisplayId(IBinder activityToken) throws RemoteException {\n        synchronized (mGlobalLock) {\n            final ActivityStack stack = ActivityRecord.getStackLocked(activityToken);\n            if (stack != null) {\n                final int displayId = stack.getDisplayId();\n                return displayId != INVALID_DISPLAY ? displayId : DEFAULT_DISPLAY;\n            }\n            return DEFAULT_DISPLAY;\n        }\n    }\n\n    @Override\n    public ActivityManager.StackInfo getFocusedStackInfo() throws RemoteException {\n        enforceCallerIsRecentsOrHasPermission(MANAGE_ACTIVITY_STACKS, \"getStackInfo()\");\n        long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                ActivityStack focusedStack = getTopDisplayFocusedStack();\n                if (focusedStack != null) {\n                    return mRootWindowContainer.getStackInfo(focusedStack.mTaskId);\n                }\n                return null;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public void setFocusedStack(int stackId) {\n        mAmInternal.enforceCallingPermission(MANAGE_ACTIVITY_STACKS, \"setFocusedStack()\");\n        if (DEBUG_FOCUS) Slog.d(TAG_FOCUS, \"setFocusedStack: stackId=\" + stackId);\n        final long callingId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityStack stack = mRootWindowContainer.getStack(stackId);\n                if (stack == null) {\n                    Slog.w(TAG, \"setFocusedStack: No stack with id=\" + stackId);\n                    return;\n                }\n                final ActivityRecord r = stack.topRunningActivity();\n                if (r != null && r.moveFocusableActivityToTop(\"setFocusedStack\")) {\n                    mRootWindowContainer.resumeFocusedStacksTopActivities();\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(callingId);\n        }\n    }\n\n    @Override\n    public void setFocusedTask(int taskId) {\n        mAmInternal.enforceCallingPermission(MANAGE_ACTIVITY_STACKS, \"setFocusedTask()\");\n        if (DEBUG_FOCUS) Slog.d(TAG_FOCUS, \"setFocusedTask: taskId=\" + taskId);\n        final long callingId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final Task task = mRootWindowContainer.anyTaskForId(taskId,\n                        MATCH_TASK_IN_STACKS_ONLY);\n                if (task == null) {\n                    return;\n                }\n                final ActivityRecord r = task.topRunningActivityLocked();\n                if (r != null && r.moveFocusableActivityToTop(\"setFocusedTask\")) {\n                    mRootWindowContainer.resumeFocusedStacksTopActivities();\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(callingId);\n        }\n    }\n\n    @Override\n    public void restartActivityProcessIfVisible(IBinder activityToken) {\n        mAmInternal.enforceCallingPermission(MANAGE_ACTIVITY_STACKS, \"restartActivityProcess()\");\n        final long callingId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInStackLocked(activityToken);\n                if (r == null) {\n                    return;\n                }\n                r.restartProcessIfVisible();\n            }\n        } finally {\n            Binder.restoreCallingIdentity(callingId);\n        }\n    }\n\n    @Override\n    public boolean removeTask(int taskId) {\n        enforceCallerIsRecentsOrHasPermission(REMOVE_TASKS, \"removeTask()\");\n        synchronized (mGlobalLock) {\n            final long ident = Binder.clearCallingIdentity();\n            try {\n                return mStackSupervisor.removeTaskById(taskId, true, REMOVE_FROM_RECENTS,\n                        \"remove-task\");\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n    }\n\n    @Override\n    public void removeAllVisibleRecentTasks() {\n        enforceCallerIsRecentsOrHasPermission(REMOVE_TASKS, \"removeAllVisibleRecentTasks()\");\n        synchronized (mGlobalLock) {\n            final long ident = Binder.clearCallingIdentity();\n            try {\n                getRecentTasks().removeAllVisibleTasks(mAmInternal.getCurrentUserId());\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n    }\n\n    @Override\n    public boolean shouldUpRecreateTask(IBinder token, String destAffinity) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord srec = ActivityRecord.forTokenLocked(token);\n            if (srec != null) {\n                return srec.getRootTask().shouldUpRecreateTaskLocked(srec, destAffinity);\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean navigateUpTo(IBinder token, Intent destIntent, int resultCode,\n            Intent resultData) {\n        final ActivityRecord r;\n        synchronized (mGlobalLock) {\n            r = ActivityRecord.isInStackLocked(token);\n            if (r == null) {\n                return false;\n            }\n        }\n\n        // Carefully collect grants without holding lock\n        final NeededUriGrants destGrants = collectGrants(destIntent, r);\n        final NeededUriGrants resultGrants = collectGrants(resultData, r.resultTo);\n\n        synchronized (mGlobalLock) {\n            return r.getRootTask().navigateUpTo(\n                    r, destIntent, destGrants, resultCode, resultData, resultGrants);\n        }\n    }\n\n    /**\n     * Attempts to move a task backwards in z-order (the order of activities within the task is\n     * unchanged).\n     *\n     * There are several possible results of this call:\n     * - if the task is locked, then we will show the lock toast\n     * - if there is a task behind the provided task, then that task is made visible and resumed as\n     *   this task is moved to the back\n     * - otherwise, if there are no other tasks in the stack:\n     *     - if this task is in the pinned stack, then we remove the stack completely, which will\n     *       have the effect of moving the task to the top or bottom of the fullscreen stack\n     *       (depending on whether it is visible)\n     *     - otherwise, we simply return home and hide this task\n     *\n     * @param token A reference to the activity we wish to move\n     * @param nonRoot If false then this only works if the activity is the root\n     *                of a task; if true it will work for any activity in a task.\n     * @return Returns true if the move completed, false if not.\n     */\n    @Override\n    public boolean moveActivityTaskToBack(IBinder token, boolean nonRoot) {\n        enforceNotIsolatedCaller(\"moveActivityTaskToBack\");\n        synchronized (mGlobalLock) {\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                int taskId = ActivityRecord.getTaskForActivityLocked(token, !nonRoot);\n                final Task task = mRootWindowContainer.anyTaskForId(taskId);\n                if (task != null) {\n                    return ActivityRecord.getStackLocked(token).moveTaskToBack(task);\n                }\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public Rect getTaskBounds(int taskId) {\n        mAmInternal.enforceCallingPermission(MANAGE_ACTIVITY_STACKS, \"getTaskBounds()\");\n        long ident = Binder.clearCallingIdentity();\n        Rect rect = new Rect();\n        try {\n            synchronized (mGlobalLock) {\n                final Task task = mRootWindowContainer.anyTaskForId(taskId,\n                        MATCH_TASK_IN_STACKS_OR_RECENT_TASKS);\n                if (task == null) {\n                    Slog.w(TAG, \"getTaskBounds: taskId=\" + taskId + \" not found\");\n                    return rect;\n                }\n                if (task.getParent() != null) {\n                    rect.set(task.getBounds());\n                } else if (task.mLastNonFullscreenBounds != null) {\n                    rect.set(task.mLastNonFullscreenBounds);\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n        return rect;\n    }\n\n    @Override\n    public ActivityManager.TaskDescription getTaskDescription(int id) {\n        synchronized (mGlobalLock) {\n            enforceCallerIsRecentsOrHasPermission(\n                    MANAGE_ACTIVITY_STACKS, \"getTaskDescription()\");\n            final Task tr = mRootWindowContainer.anyTaskForId(id,\n                    MATCH_TASK_IN_STACKS_OR_RECENT_TASKS);\n            if (tr != null) {\n                return tr.getTaskDescription();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public boolean setTaskWindowingMode(int taskId, int windowingMode, boolean toTop) {\n        if (windowingMode == WINDOWING_MODE_SPLIT_SCREEN_PRIMARY) {\n            return setTaskWindowingModeSplitScreenPrimary(taskId, toTop);\n        }\n        enforceCallerIsRecentsOrHasPermission(MANAGE_ACTIVITY_STACKS, \"setTaskWindowingMode()\");\n        synchronized (mGlobalLock) {\n            final long ident = Binder.clearCallingIdentity();\n            try {\n                if (WindowConfiguration.isSplitScreenWindowingMode(windowingMode)) {\n                    return setTaskWindowingModeSplitScreen(taskId, windowingMode, toTop);\n                }\n                final Task task = mRootWindowContainer.anyTaskForId(taskId,\n                        MATCH_TASK_IN_STACKS_ONLY);\n                if (task == null) {\n                    Slog.w(TAG, \"setTaskWindowingMode: No task for id=\" + taskId);\n                    return false;\n                }\n\n                if (DEBUG_STACK) Slog.d(TAG_STACK, \"setTaskWindowingMode: moving task=\" + taskId\n                        + \" to windowingMode=\" + windowingMode + \" toTop=\" + toTop);\n\n                if (!task.isActivityTypeStandardOrUndefined()) {\n                    throw new IllegalArgumentException(\"setTaskWindowingMode: Attempt to move\"\n                            + \" non-standard task \" + taskId + \" to windowing mode=\"\n                            + windowingMode);\n                }\n\n                final ActivityStack stack = task.getStack();\n                if (toTop) {\n                    stack.moveToFront(\"setTaskWindowingMode\", task);\n                }\n                // Convert some windowing-mode changes into root-task reparents for split-screen.\n                if (stack.inSplitScreenWindowingMode()) {\n                    stack.getDisplayArea().onSplitScreenModeDismissed();\n\n                } else {\n                    stack.setWindowingMode(windowingMode);\n                    stack.getDisplay().ensureActivitiesVisible(null, 0, PRESERVE_WINDOWS,\n                            true /* notifyClients */);\n                }\n                return true;\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n    }\n\n    @Override\n    public String getCallingPackage(IBinder token) {\n        synchronized (mGlobalLock) {\n            ActivityRecord r = getCallingRecordLocked(token);\n            return r != null ? r.info.packageName : null;\n        }\n    }\n\n    @Override\n    public ComponentName getCallingActivity(IBinder token) {\n        synchronized (mGlobalLock) {\n            ActivityRecord r = getCallingRecordLocked(token);\n            return r != null ? r.intent.getComponent() : null;\n        }\n    }\n\n    private ActivityRecord getCallingRecordLocked(IBinder token) {\n        ActivityRecord r = ActivityRecord.isInStackLocked(token);\n        if (r == null) {\n            return null;\n        }\n        return r.resultTo;\n    }\n\n    private NeededUriGrants collectGrants(Intent intent, ActivityRecord target) {\n        if (target != null) {\n            return mUgmInternal.checkGrantUriPermissionFromIntent(intent,\n                    Binder.getCallingUid(), target.packageName, target.mUserId);\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public void unhandledBack() {\n        mAmInternal.enforceCallingPermission(android.Manifest.permission.FORCE_BACK, \"unhandledBack()\");\n\n        synchronized (mGlobalLock) {\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                final ActivityStack topFocusedStack = getTopDisplayFocusedStack();\n                if (topFocusedStack != null) {\n                    topFocusedStack.unhandledBackLocked();\n                }\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public void onBackPressedOnTaskRoot(IBinder token, IRequestFinishCallback callback) {\n        synchronized (mGlobalLock) {\n            ActivityRecord r = ActivityRecord.isInStackLocked(token);\n            if (r == null) {\n                return;\n            }\n            ActivityStack stack = r.getRootTask();\n            final TaskOrganizerController taskOrgController =\n                    mWindowOrganizerController.mTaskOrganizerController;\n            if (taskOrgController.handleInterceptBackPressedOnTaskRoot(stack)) {\n                // This task is handled by a task organizer that has requested the back pressed\n                // callback\n            } else if (stack != null && (stack.isSingleTaskInstance())) {\n                // Single-task stacks are used for activities which are presented in floating\n                // windows above full screen activities. Instead of directly finishing the\n                // task, a task change listener is used to notify SystemUI so the action can be\n                // handled specially.\n                final Task task = r.getTask();\n                mTaskChangeNotificationController\n                        .notifyBackPressedOnTaskRoot(task.getTaskInfo());\n            } else {\n                try {\n                    callback.requestFinish();\n                } catch (RemoteException e) {\n                    Slog.e(TAG, \"Failed to invoke request finish callback\", e);\n                }\n            }\n        }\n    }\n\n    /**\n     * TODO: Add mController hook\n     */\n    @Override\n    public void moveTaskToFront(IApplicationThread appThread, String callingPackage, int taskId,\n            int flags, Bundle bOptions) {\n        mAmInternal.enforceCallingPermission(android.Manifest.permission.REORDER_TASKS, \"moveTaskToFront()\");\n\n        if (DEBUG_STACK) Slog.d(TAG_STACK, \"moveTaskToFront: moving taskId=\" + taskId);\n        synchronized (mGlobalLock) {\n            moveTaskToFrontLocked(appThread, callingPackage, taskId, flags,\n                    SafeActivityOptions.fromBundle(bOptions));\n        }\n    }\n\n    void moveTaskToFrontLocked(@Nullable IApplicationThread appThread,\n            @Nullable String callingPackage, int taskId, int flags, SafeActivityOptions options) {\n        final int callingPid = Binder.getCallingPid();\n        final int callingUid = Binder.getCallingUid();\n        assertPackageMatchesCallingUid(callingPackage);\n        if (!checkAppSwitchAllowedLocked(callingPid, callingUid, -1, -1, \"Task to front\")) {\n            SafeActivityOptions.abort(options);\n            return;\n        }\n        final long origId = Binder.clearCallingIdentity();\n        WindowProcessController callerApp = null;\n        if (appThread != null) {\n            callerApp = getProcessController(appThread);\n        }\n        final ActivityStarter starter = getActivityStartController().obtainStarter(\n                null /* intent */, \"moveTaskToFront\");\n        if (starter.shouldAbortBackgroundActivityStart(callingUid, callingPid, callingPackage, -1,\n                -1, callerApp, null, false, null, null)) {\n            if (!isBackgroundActivityStartsEnabled()) {\n                return;\n            }\n        }\n        try {\n            final Task task = mRootWindowContainer.anyTaskForId(taskId);\n            if (task == null) {\n                Slog.d(TAG, \"Could not find task for id: \"+ taskId);\n                SafeActivityOptions.abort(options);\n                return;\n            }\n            if (getLockTaskController().isLockTaskModeViolation(task)) {\n                Slog.e(TAG, \"moveTaskToFront: Attempt to violate Lock Task Mode\");\n                SafeActivityOptions.abort(options);\n                return;\n            }\n            ActivityOptions realOptions = options != null\n                    ? options.getOptions(mStackSupervisor)\n                    : null;\n            mStackSupervisor.findTaskToMoveToFront(task, flags, realOptions, \"moveTaskToFront\",\n                    false /* forceNonResizable */);\n\n            final ActivityRecord topActivity = task.getTopNonFinishingActivity();\n            if (topActivity != null) {\n\n                // We are reshowing a task, use a starting window to hide the initial draw delay\n                // so the transition can start earlier.\n                topActivity.showStartingWindow(null /* prev */, false /* newTask */,\n                        true /* taskSwitch */);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    /**\n     * Return true if callingUid is system, or packageName belongs to that callingUid.\n     */\n    private boolean isSameApp(int callingUid, @Nullable String packageName) {\n        try {\n            if (callingUid != 0 && callingUid != SYSTEM_UID) {\n                if (packageName == null) {\n                    return false;\n                }\n                final int uid = AppGlobals.getPackageManager().getPackageUid(packageName,\n                        PackageManager.MATCH_DEBUG_TRIAGED_MISSING,\n                        UserHandle.getUserId(callingUid));\n                return UserHandle.isSameApp(callingUid, uid);\n            }\n        } catch (RemoteException e) {\n            // Should not happen\n        }\n        return true;\n    }\n\n    /**\n     * Checks that the provided package name matches the current calling UID, throws a security\n     * exception if it doesn't.\n     */\n    void assertPackageMatchesCallingUid(@Nullable String packageName) {\n        final int callingUid = Binder.getCallingUid();\n        if (isSameApp(callingUid, packageName)) {\n            return;\n        }\n        final String msg = \"Permission Denial: package=\" + packageName\n                + \" does not belong to uid=\" + callingUid;\n        Slog.w(TAG, msg);\n        throw new SecurityException(msg);\n    }\n\n    boolean checkAppSwitchAllowedLocked(int sourcePid, int sourceUid,\n            int callingPid, int callingUid, String name) {\n        if (mAppSwitchesAllowedTime < SystemClock.uptimeMillis()) {\n            return true;\n        }\n\n        if (getRecentTasks().isCallerRecents(sourceUid)) {\n            return true;\n        }\n\n        int perm = checkComponentPermission(STOP_APP_SWITCHES, sourcePid, sourceUid, -1, true);\n        if (perm == PackageManager.PERMISSION_GRANTED) {\n            return true;\n        }\n        if (checkAllowAppSwitchUid(sourceUid)) {\n            return true;\n        }\n\n        // If the actual IPC caller is different from the logical source, then\n        // also see if they are allowed to control app switches.\n        if (callingUid != -1 && callingUid != sourceUid) {\n            perm = checkComponentPermission(STOP_APP_SWITCHES, callingPid, callingUid, -1, true);\n            if (perm == PackageManager.PERMISSION_GRANTED) {\n                return true;\n            }\n            if (checkAllowAppSwitchUid(callingUid)) {\n                return true;\n            }\n        }\n\n        Slog.w(TAG, name + \" request from \" + sourceUid + \" stopped\");\n        return false;\n    }\n\n    private boolean checkAllowAppSwitchUid(int uid) {\n        ArrayMap<String, Integer> types = mAllowAppSwitchUids.get(UserHandle.getUserId(uid));\n        if (types != null) {\n            for (int i = types.size() - 1; i >= 0; i--) {\n                if (types.valueAt(i).intValue() == uid) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public void setActivityController(IActivityController controller, boolean imAMonkey) {\n        mAmInternal.enforceCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER,\n                \"setActivityController()\");\n        synchronized (mGlobalLock) {\n            mController = controller;\n            mControllerIsAMonkey = imAMonkey;\n            Watchdog.getInstance().setActivityController(controller);\n        }\n    }\n\n    public boolean isControllerAMonkey() {\n        synchronized (mGlobalLock) {\n            return mController != null && mControllerIsAMonkey;\n        }\n    }\n\n    @Override\n    public int getTaskForActivity(IBinder token, boolean onlyRoot) {\n        synchronized (mGlobalLock) {\n            return ActivityRecord.getTaskForActivityLocked(token, onlyRoot);\n        }\n    }\n\n    @Override\n    public List<ActivityManager.RunningTaskInfo> getTasks(int maxNum) {\n        return getFilteredTasks(maxNum, false /* filterForVisibleRecents */);\n    }\n\n    /**\n     * @param filterOnlyVisibleRecents whether to filter the tasks based on whether they would ever\n     *                                 be visible in the recent task list in systemui\n     */\n    @Override\n    public List<ActivityManager.RunningTaskInfo> getFilteredTasks(int maxNum,\n            boolean filterOnlyVisibleRecents) {\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        final boolean crossUser = isCrossUserAllowed(callingPid, callingUid);\n        final int[] profileIds = getUserManager().getProfileIds(\n                UserHandle.getUserId(callingUid), true);\n        ArraySet<Integer> callingProfileIds = new ArraySet<>();\n        for (int i = 0; i < profileIds.length; i++) {\n            callingProfileIds.add(profileIds[i]);\n        }\n        ArrayList<ActivityManager.RunningTaskInfo> list = new ArrayList<>();\n\n        synchronized (mGlobalLock) {\n            if (DEBUG_ALL) Slog.v(TAG, \"getTasks: max=\" + maxNum);\n\n            final boolean allowed = isGetTasksAllowed(\"getTasks\", callingPid, callingUid);\n            mRootWindowContainer.getRunningTasks(maxNum, list, filterOnlyVisibleRecents, callingUid,\n                    allowed, crossUser, callingProfileIds);\n        }\n\n        return list;\n    }\n\n    @Override\n    public final void finishSubActivity(IBinder token, String resultWho, int requestCode) {\n        synchronized (mGlobalLock) {\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                ActivityRecord r = ActivityRecord.isInStackLocked(token);\n                if (r == null) return;\n\n                final PooledConsumer c = PooledLambda.obtainConsumer(\n                        ActivityRecord::finishIfSubActivity, PooledLambda.__(ActivityRecord.class),\n                        r, resultWho, requestCode);\n                // TODO: This should probably only loop over the task since you need to be in the\n                // same task to return results.\n                r.getRootTask().forAllActivities(c);\n                c.recycle();\n\n                updateOomAdj();\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public boolean willActivityBeVisible(IBinder token) {\n        synchronized (mGlobalLock) {\n            ActivityStack stack = ActivityRecord.getStackLocked(token);\n            if (stack != null) {\n                return stack.willActivityBeVisible(token);\n            }\n            return false;\n        }\n    }\n\n    @Override\n    public void moveTaskToStack(int taskId, int stackId, boolean toTop) {\n        enforceCallerIsRecentsOrHasPermission(MANAGE_ACTIVITY_STACKS, \"moveTaskToStack()\");\n        synchronized (mGlobalLock) {\n            final long ident = Binder.clearCallingIdentity();\n            try {\n                final Task task = mRootWindowContainer.anyTaskForId(taskId);\n                if (task == null) {\n                    Slog.w(TAG, \"moveTaskToStack: No task for id=\" + taskId);\n                    return;\n                }\n\n                if (DEBUG_STACK) Slog.d(TAG_STACK, \"moveTaskToStack: moving task=\" + taskId\n                        + \" to stackId=\" + stackId + \" toTop=\" + toTop);\n\n                final ActivityStack stack = mRootWindowContainer.getStack(stackId);\n                if (stack == null) {\n                    throw new IllegalStateException(\n                            \"moveTaskToStack: No stack for stackId=\" + stackId);\n                }\n                if (!stack.isActivityTypeStandardOrUndefined()) {\n                    throw new IllegalArgumentException(\"moveTaskToStack: Attempt to move task \"\n                            + taskId + \" to stack \" + stackId);\n                }\n                task.reparent(stack, toTop, REPARENT_KEEP_STACK_AT_FRONT, ANIMATE, !DEFER_RESUME,\n                        \"moveTaskToStack\");\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n    }\n\n    /**\n     * Moves the specified task to the primary-split-screen stack.\n     *\n     * @param taskId Id of task to move.\n     * @param toTop If the task and stack should be moved to the top.\n     * @return Whether the task was successfully put into splitscreen.\n     */\n    @Override\n    public boolean setTaskWindowingModeSplitScreenPrimary(int taskId, boolean toTop) {\n        enforceCallerIsRecentsOrHasPermission(MANAGE_ACTIVITY_STACKS,\n                \"setTaskWindowingModeSplitScreenPrimary()\");\n        synchronized (mGlobalLock) {\n            final long ident = Binder.clearCallingIdentity();\n            try {\n                return setTaskWindowingModeSplitScreen(taskId, WINDOWING_MODE_SPLIT_SCREEN_PRIMARY,\n                        toTop);\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n    }\n\n    /**\n     * Moves the specified task into a split-screen tile.\n     */\n    private boolean setTaskWindowingModeSplitScreen(int taskId, int windowingMode, boolean toTop) {\n        if (!WindowConfiguration.isSplitScreenWindowingMode(windowingMode)) {\n            throw new IllegalArgumentException(\"Calling setTaskWindowingModeSplitScreen with non\"\n                    + \"split-screen mode: \" + windowingMode);\n        }\n        if (isInLockTaskMode()) {\n            Slog.w(TAG, \"setTaskWindowingModeSplitScreen: Is in lock task mode=\"\n                    + getLockTaskModeState());\n            return false;\n        }\n\n        final Task task = mRootWindowContainer.anyTaskForId(taskId,\n                MATCH_TASK_IN_STACKS_ONLY);\n        if (task == null) {\n            Slog.w(TAG, \"setTaskWindowingModeSplitScreenPrimary: No task for id=\" + taskId);\n            return false;\n        }\n        if (!task.isActivityTypeStandardOrUndefined()) {\n            throw new IllegalArgumentException(\"setTaskWindowingMode: Attempt to move\"\n                    + \" non-standard task \" + taskId + \" to split-screen windowing mode\");\n        }\n        if (!task.supportsSplitScreenWindowingMode()) {\n            return false;\n        }\n\n        final int prevMode = task.getWindowingMode();\n        if (prevMode == windowingMode) {\n            // The task is already in split-screen and with correct windowing mode.\n            return true;\n        }\n\n        moveTaskToSplitScreenPrimaryTask(task, toTop);\n        return prevMode != task.getWindowingMode();\n    }\n\n    void moveTaskToSplitScreenPrimaryTask(Task task, boolean toTop) {\n        final TaskDisplayArea taskDisplayArea = task.getDisplayArea();\n        final ActivityStack primarySplitTask = taskDisplayArea.getRootSplitScreenPrimaryTask();\n        if (primarySplitTask == null) {\n            throw new IllegalStateException(\"Can't enter split without associated organized task\");\n        }\n\n        if (toTop) {\n            taskDisplayArea.positionStackAt(POSITION_TOP, primarySplitTask,\n                    false /* includingParents */);\n        }\n        WindowContainerTransaction wct = new WindowContainerTransaction();\n        // Clear out current windowing mode before reparenting to split taks.\n        wct.setWindowingMode(\n                task.getStack().mRemoteToken.toWindowContainerToken(), WINDOWING_MODE_UNDEFINED);\n        wct.reparent(task.getStack().mRemoteToken.toWindowContainerToken(),\n                primarySplitTask.mRemoteToken.toWindowContainerToken(), toTop);\n        mWindowOrganizerController.applyTransaction(wct);\n    }\n\n    /**\n     * Removes stacks in the input windowing modes from the system if they are of activity type\n     * ACTIVITY_TYPE_STANDARD or ACTIVITY_TYPE_UNDEFINED\n     */\n    @Override\n    public void removeStacksInWindowingModes(int[] windowingModes) {\n        enforceCallerIsRecentsOrHasPermission(MANAGE_ACTIVITY_STACKS,\n                \"removeStacksInWindowingModes()\");\n\n        synchronized (mGlobalLock) {\n            final long ident = Binder.clearCallingIdentity();\n            try {\n                mRootWindowContainer.removeStacksInWindowingModes(windowingModes);\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n    }\n\n    @Override\n    public void removeStacksWithActivityTypes(int[] activityTypes) {\n        enforceCallerIsRecentsOrHasPermission(MANAGE_ACTIVITY_STACKS,\n                \"removeStacksWithActivityTypes()\");\n\n        synchronized (mGlobalLock) {\n            final long ident = Binder.clearCallingIdentity();\n            try {\n                mRootWindowContainer.removeStacksWithActivityTypes(activityTypes);\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n    }\n\n    @Override\n    public ParceledListSlice<ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum, int flags,\n            int userId) {\n        final int callingUid = Binder.getCallingUid();\n        userId = handleIncomingUser(Binder.getCallingPid(), callingUid, userId, \"getRecentTasks\");\n        final boolean allowed = isGetTasksAllowed(\"getRecentTasks\", Binder.getCallingPid(),\n                callingUid);\n        synchronized (mGlobalLock) {\n            return mRecentTasks.getRecentTasks(maxNum, flags, allowed, userId, callingUid);\n        }\n    }\n\n    // TODO(148895075): deprecate and replace with task equivalents\n    @Override\n    public List<ActivityManager.StackInfo> getAllStackInfos() {\n        enforceCallerIsRecentsOrHasPermission(MANAGE_ACTIVITY_STACKS, \"getAllStackInfos()\");\n        long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.getAllStackInfos(INVALID_DISPLAY);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public ActivityManager.StackInfo getStackInfo(int windowingMode, int activityType) {\n        enforceCallerIsRecentsOrHasPermission(MANAGE_ACTIVITY_STACKS, \"getStackInfo()\");\n        long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.getStackInfo(windowingMode, activityType);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    // TODO(148895075): deprecate and replace with task equivalents\n    @Override\n    public List<ActivityManager.StackInfo> getAllStackInfosOnDisplay(int displayId) {\n        enforceCallerIsRecentsOrHasPermission(MANAGE_ACTIVITY_STACKS, \"getAllStackInfos()\");\n        long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.getAllStackInfos(displayId);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public ActivityManager.StackInfo getStackInfoOnDisplay(int windowingMode, int activityType,\n            int displayId) {\n        enforceCallerIsRecentsOrHasPermission(MANAGE_ACTIVITY_STACKS, \"getStackInfo()\");\n        long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.getStackInfo(windowingMode, activityType, displayId);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public void cancelRecentsAnimation(boolean restoreHomeStackPosition) {\n        enforceCallerIsRecentsOrHasPermission(MANAGE_ACTIVITY_STACKS, \"cancelRecentsAnimation()\");\n        final long callingUid = Binder.getCallingUid();\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                // Cancel the recents animation synchronously (do not hold the WM lock)\n                mWindowManager.cancelRecentsAnimation(restoreHomeStackPosition\n                        ? REORDER_MOVE_TO_ORIGINAL_POSITION\n                        : REORDER_KEEP_IN_PLACE, \"cancelRecentsAnimation/uid=\" + callingUid);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public void startLockTaskModeByToken(IBinder token) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n            if (r == null) {\n                return;\n            }\n            startLockTaskModeLocked(r.getTask(), false /* isSystemCaller */);\n        }\n    }\n\n    @Override\n    public void startSystemLockTaskMode(int taskId) {\n        mAmInternal.enforceCallingPermission(MANAGE_ACTIVITY_STACKS, \"startSystemLockTaskMode\");\n        // This makes inner call to look as if it was initiated by system.\n        long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final Task task = mRootWindowContainer.anyTaskForId(taskId,\n                        MATCH_TASK_IN_STACKS_ONLY);\n                if (task == null) {\n                    return;\n                }\n\n                // When starting lock task mode the stack must be in front and focused\n                task.getStack().moveToFront(\"startSystemLockTaskMode\");\n                startLockTaskModeLocked(task, true /* isSystemCaller */);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public void stopLockTaskModeByToken(IBinder token) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n            if (r == null) {\n                return;\n            }\n            stopLockTaskModeInternal(r.getTask(), false /* isSystemCaller */);\n        }\n    }\n\n    /**\n     * This API should be called by SystemUI only when user perform certain action to dismiss\n     * lock task mode. We should only dismiss pinned lock task mode in this case.\n     */\n    @Override\n    public void stopSystemLockTaskMode() throws RemoteException {\n        mAmInternal.enforceCallingPermission(MANAGE_ACTIVITY_STACKS, \"stopSystemLockTaskMode\");\n        stopLockTaskModeInternal(null, true /* isSystemCaller */);\n    }\n\n    private void startLockTaskModeLocked(@Nullable Task task, boolean isSystemCaller) {\n        if (DEBUG_LOCKTASK) Slog.w(TAG_LOCKTASK, \"startLockTaskModeLocked: \" + task);\n        if (task == null || task.mLockTaskAuth == LOCK_TASK_AUTH_DONT_LOCK) {\n            return;\n        }\n\n        final ActivityStack stack = mRootWindowContainer.getTopDisplayFocusedStack();\n        if (stack == null || task != stack.getTopMostTask()) {\n            throw new IllegalArgumentException(\"Invalid task, not in foreground\");\n        }\n\n        // {@code isSystemCaller} is used to distinguish whether this request is initiated by the\n        // system or a specific app.\n        // * System-initiated requests will only start the pinned mode (screen pinning)\n        // * App-initiated requests\n        //   - will put the device in fully locked mode (LockTask), if the app is whitelisted\n        //   - will start the pinned mode, otherwise\n        final int callingUid = Binder.getCallingUid();\n        long ident = Binder.clearCallingIdentity();\n        try {\n            // When a task is locked, dismiss the pinned stack if it exists\n            mRootWindowContainer.removeStacksInWindowingModes(WINDOWING_MODE_PINNED);\n\n            getLockTaskController().startLockTaskMode(task, isSystemCaller, callingUid);\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    private void stopLockTaskModeInternal(@Nullable Task task, boolean isSystemCaller) {\n        final int callingUid = Binder.getCallingUid();\n        long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                getLockTaskController().stopLockTaskMode(task, isSystemCaller, callingUid);\n            }\n            // Launch in-call UI if a call is ongoing. This is necessary to allow stopping the lock\n            // task and jumping straight into a call in the case of emergency call back.\n            TelecomManager tm = (TelecomManager) mContext.getSystemService(Context.TELECOM_SERVICE);\n            if (tm != null) {\n                tm.showInCallScreen(false);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public void updateLockTaskPackages(int userId, String[] packages) {\n        final int callingUid = Binder.getCallingUid();\n        if (callingUid != 0 && callingUid != SYSTEM_UID) {\n            mAmInternal.enforceCallingPermission(Manifest.permission.UPDATE_LOCK_TASK_PACKAGES,\n                    \"updateLockTaskPackages()\");\n        }\n        synchronized (mGlobalLock) {\n            if (DEBUG_LOCKTASK) Slog.w(TAG_LOCKTASK, \"Whitelisting \" + userId + \":\"\n                    + Arrays.toString(packages));\n            getLockTaskController().updateLockTaskPackages(userId, packages);\n        }\n    }\n\n    @Override\n    public boolean isInLockTaskMode() {\n        return getLockTaskModeState() != LOCK_TASK_MODE_NONE;\n    }\n\n    @Override\n    public int getLockTaskModeState() {\n        synchronized (mGlobalLock) {\n            return getLockTaskController().getLockTaskModeState();\n        }\n    }\n\n    @Override\n    public void setTaskDescription(IBinder token, ActivityManager.TaskDescription td) {\n        synchronized (mGlobalLock) {\n            ActivityRecord r = ActivityRecord.isInStackLocked(token);\n            if (r != null) {\n                r.setTaskDescription(td);\n            }\n        }\n    }\n\n    @Override\n    public Bundle getActivityOptions(IBinder token) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInStackLocked(token);\n                if (r != null) {\n                    final ActivityOptions activityOptions = r.takeOptionsLocked(\n                            true /* fromClient */);\n                    return activityOptions == null ? null : activityOptions.toBundle();\n                }\n                return null;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public List<IBinder> getAppTasks(String callingPackage) {\n        int callingUid = Binder.getCallingUid();\n        assertPackageMatchesCallingUid(callingPackage);\n        long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                return mRecentTasks.getAppTasksList(callingUid, callingPackage);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public void finishVoiceTask(IVoiceInteractionSession session) {\n        synchronized (mGlobalLock) {\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                // TODO: VI Consider treating local voice interactions and voice tasks\n                // differently here\n                mRootWindowContainer.finishVoiceTask(session);\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n\n    }\n\n    @Override\n    public boolean isTopOfTask(IBinder token) {\n        synchronized (mGlobalLock) {\n            ActivityRecord r = ActivityRecord.isInStackLocked(token);\n            return r != null && r.getTask().getTopNonFinishingActivity() == r;\n        }\n    }\n\n    @Override\n    public void notifyLaunchTaskBehindComplete(IBinder token) {\n        mStackSupervisor.scheduleLaunchTaskBehindComplete(token);\n    }\n\n    @Override\n    public void notifyEnterAnimationComplete(IBinder token) {\n        mH.post(() -> {\n            synchronized (mGlobalLock) {\n                ActivityRecord r = ActivityRecord.forTokenLocked(token);\n                if (r != null && r.attachedToProcess()) {\n                    try {\n                        r.app.getThread().scheduleEnterAnimationComplete(r.appToken);\n                    } catch (RemoteException e) {\n                    }\n                }\n            }\n\n        });\n    }\n\n    /** Called from an app when assist data is ready. */\n    @Override\n    public void reportAssistContextExtras(IBinder token, Bundle extras, AssistStructure structure,\n            AssistContent content, Uri referrer) {\n        PendingAssistExtras pae = (PendingAssistExtras) token;\n        synchronized (pae) {\n            pae.result = extras;\n            pae.structure = structure;\n            pae.content = content;\n            if (referrer != null) {\n                pae.extras.putParcelable(Intent.EXTRA_REFERRER, referrer);\n            }\n            if (structure != null) {\n                // Pre-fill the task/activity component for all assist data receivers\n                structure.setTaskId(pae.activity.getTask().mTaskId);\n                structure.setActivityComponent(pae.activity.mActivityComponent);\n                structure.setHomeActivity(pae.isHome);\n            }\n            pae.haveResult = true;\n            pae.notifyAll();\n            if (pae.intent == null && pae.receiver == null) {\n                // Caller is just waiting for the result.\n                return;\n            }\n        }\n        // We are now ready to launch the assist activity.\n        IAssistDataReceiver sendReceiver = null;\n        Bundle sendBundle = null;\n        synchronized (mGlobalLock) {\n            buildAssistBundleLocked(pae, extras);\n            boolean exists = mPendingAssistExtras.remove(pae);\n            mUiHandler.removeCallbacks(pae);\n            if (!exists) {\n                // Timed out.\n                return;\n            }\n\n            if ((sendReceiver = pae.receiver) != null) {\n                // Caller wants result sent back to them.\n                sendBundle = new Bundle();\n                sendBundle.putInt(ActivityTaskManagerInternal.ASSIST_TASK_ID,\n                        pae.activity.getTask().mTaskId);\n                sendBundle.putBinder(ActivityTaskManagerInternal.ASSIST_ACTIVITY_ID,\n                        pae.activity.assistToken);\n                sendBundle.putBundle(ASSIST_KEY_DATA, pae.extras);\n                sendBundle.putParcelable(ASSIST_KEY_STRUCTURE, pae.structure);\n                sendBundle.putParcelable(ASSIST_KEY_CONTENT, pae.content);\n                sendBundle.putBundle(ASSIST_KEY_RECEIVER_EXTRAS, pae.receiverExtras);\n            }\n        }\n        if (sendReceiver != null) {\n            try {\n                sendReceiver.onHandleAssistData(sendBundle);\n            } catch (RemoteException e) {\n            }\n            return;\n        }\n\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            if (TextUtils.equals(pae.intent.getAction(),\n                    android.service.voice.VoiceInteractionService.SERVICE_INTERFACE)) {\n                // Start voice interaction through VoiceInteractionManagerService.\n                mAssistUtils.showSessionForActiveService(pae.extras, SHOW_SOURCE_APPLICATION,\n                        null, null);\n            } else {\n                pae.intent.replaceExtras(pae.extras);\n                pae.intent.setFlags(FLAG_ACTIVITY_NEW_TASK\n                        | Intent.FLAG_ACTIVITY_SINGLE_TOP\n                        | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                mInternal.closeSystemDialogs(\"assist\");\n\n                try {\n                    mContext.startActivityAsUser(pae.intent, new UserHandle(pae.userHandle));\n                } catch (ActivityNotFoundException e) {\n                    Slog.w(TAG, \"No activity to handle assist action.\", e);\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public int addAppTask(IBinder activityToken, Intent intent,\n            ActivityManager.TaskDescription description, Bitmap thumbnail) throws RemoteException {\n        final int callingUid = Binder.getCallingUid();\n        final long callingIdent = Binder.clearCallingIdentity();\n\n        try {\n            synchronized (mGlobalLock) {\n                ActivityRecord r = ActivityRecord.isInStackLocked(activityToken);\n                if (r == null) {\n                    throw new IllegalArgumentException(\"Activity does not exist; token=\"\n                            + activityToken);\n                }\n                ComponentName comp = intent.getComponent();\n                if (comp == null) {\n                    throw new IllegalArgumentException(\"Intent \" + intent\n                            + \" must specify explicit component\");\n                }\n                if (thumbnail.getWidth() != mThumbnailWidth\n                        || thumbnail.getHeight() != mThumbnailHeight) {\n                    throw new IllegalArgumentException(\"Bad thumbnail size: got \"\n                            + thumbnail.getWidth() + \"x\" + thumbnail.getHeight() + \", require \"\n                            + mThumbnailWidth + \"x\" + mThumbnailHeight);\n                }\n                if (intent.getSelector() != null) {\n                    intent.setSelector(null);\n                }\n                if (intent.getSourceBounds() != null) {\n                    intent.setSourceBounds(null);\n                }\n                if ((intent.getFlags()&Intent.FLAG_ACTIVITY_NEW_DOCUMENT) != 0) {\n                    if ((intent.getFlags()&Intent.FLAG_ACTIVITY_RETAIN_IN_RECENTS) == 0) {\n                        // The caller has added this as an auto-remove task...  that makes no\n                        // sense, so turn off auto-remove.\n                        intent.addFlags(Intent.FLAG_ACTIVITY_RETAIN_IN_RECENTS);\n                    }\n                }\n                final ActivityInfo ainfo = AppGlobals.getPackageManager().getActivityInfo(comp,\n                        STOCK_PM_FLAGS, UserHandle.getUserId(callingUid));\n                if (ainfo.applicationInfo.uid != callingUid) {\n                    throw new SecurityException(\n                            \"Can't add task for another application: target uid=\"\n                                    + ainfo.applicationInfo.uid + \", calling uid=\" + callingUid);\n                }\n\n                final ActivityStack stack = r.getRootTask();\n                final Task task = stack.getDisplayArea().createStack(stack.getWindowingMode(),\n                        stack.getActivityType(), !ON_TOP, ainfo, intent,\n                        false /* createdByOrganizer */);\n\n                if (!mRecentTasks.addToBottom(task)) {\n                    // The app has too many tasks already and we can't add any more\n                    stack.removeChild(task, \"addAppTask\");\n                    return INVALID_TASK_ID;\n                }\n                task.getTaskDescription().copyFrom(description);\n\n                // TODO: Send the thumbnail to WM to store it.\n\n                return task.mTaskId;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(callingIdent);\n        }\n    }\n\n    @Override\n    public Point getAppTaskThumbnailSize() {\n        synchronized (mGlobalLock) {\n            return new Point(mThumbnailWidth, mThumbnailHeight);\n        }\n    }\n\n    @Override\n    public void setTaskResizeable(int taskId, int resizeableMode) {\n        synchronized (mGlobalLock) {\n            final Task task = mRootWindowContainer.anyTaskForId(\n                    taskId, MATCH_TASK_IN_STACKS_OR_RECENT_TASKS);\n            if (task == null) {\n                Slog.w(TAG, \"setTaskResizeable: taskId=\" + taskId + \" not found\");\n                return;\n            }\n            task.setResizeMode(resizeableMode);\n        }\n    }\n\n    @Override\n    public boolean resizeTask(int taskId, Rect bounds, int resizeMode) {\n        mAmInternal.enforceCallingPermission(MANAGE_ACTIVITY_STACKS, \"resizeTask()\");\n        long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final Task task = mRootWindowContainer.anyTaskForId(taskId,\n                        MATCH_TASK_IN_STACKS_ONLY);\n                if (task == null) {\n                    Slog.w(TAG, \"resizeTask: taskId=\" + taskId + \" not found\");\n                    return false;\n                }\n                if (!task.getWindowConfiguration().canResizeTask()) {\n                    Slog.w(TAG, \"resizeTask not allowed on task=\" + task);\n                    return false;\n                }\n\n                // Reparent the task to the right stack if necessary\n                boolean preserveWindow = (resizeMode & RESIZE_MODE_PRESERVE_WINDOW) != 0;\n\n                // After reparenting (which only resizes the task to the stack bounds), resize the\n                // task to the actual bounds provided\n                return task.resize(bounds, resizeMode, preserveWindow);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public boolean releaseActivityInstance(IBinder token) {\n        synchronized (mGlobalLock) {\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                final ActivityRecord r = ActivityRecord.isInStackLocked(token);\n                if (r == null || !r.isDestroyable()) {\n                    return false;\n                }\n                r.destroyImmediately(true /* removeFromApp */, \"app-req\");\n                return r.isState(DESTROYING, DESTROYED);\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public void releaseSomeActivities(IApplicationThread appInt) {\n        synchronized (mGlobalLock) {\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                final WindowProcessController app = getProcessController(appInt);\n                app.releaseSomeActivities(\"low-mem\");\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public void setLockScreenShown(boolean keyguardShowing, boolean aodShowing) {\n        if (checkCallingPermission(android.Manifest.permission.DEVICE_POWER)\n                != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"Requires permission \"\n                    + android.Manifest.permission.DEVICE_POWER);\n        }\n\n        synchronized (mGlobalLock) {\n            long ident = Binder.clearCallingIdentity();\n            if (mKeyguardShown != keyguardShowing) {\n                mKeyguardShown = keyguardShowing;\n                final Message msg = PooledLambda.obtainMessage(\n                        ActivityManagerInternal::reportCurKeyguardUsageEvent, mAmInternal,\n                        keyguardShowing);\n                mH.sendMessage(msg);\n            }\n            try {\n                mKeyguardController.setKeyguardShown(keyguardShowing, aodShowing);\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n\n        mH.post(() -> {\n            for (int i = mScreenObservers.size() - 1; i >= 0; i--) {\n                mScreenObservers.get(i).onKeyguardStateChanged(keyguardShowing);\n            }\n        });\n    }\n\n    public void onScreenAwakeChanged(boolean isAwake) {\n        mH.post(() -> {\n            for (int i = mScreenObservers.size() - 1; i >= 0; i--) {\n                mScreenObservers.get(i).onAwakeStateChanged(isAwake);\n            }\n        });\n    }\n\n    @Override\n    public Bitmap getTaskDescriptionIcon(String filePath, int userId) {\n        userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),\n                userId, \"getTaskDescriptionIcon\");\n\n        final File passedIconFile = new File(filePath);\n        final File legitIconFile = new File(TaskPersister.getUserImagesDir(userId),\n                passedIconFile.getName());\n        if (!legitIconFile.getPath().equals(filePath)\n                || !filePath.contains(ActivityRecord.ACTIVITY_ICON_SUFFIX)) {\n            throw new IllegalArgumentException(\"Bad file path: \" + filePath\n                    + \" passed for userId \" + userId);\n        }\n        return mRecentTasks.getTaskDescriptionIcon(filePath);\n    }\n\n    @Override\n    public void removeStack(int stackId) {\n        enforceCallerIsRecentsOrHasPermission(MANAGE_ACTIVITY_STACKS, \"removeStack()\");\n        synchronized (mGlobalLock) {\n            final long ident = Binder.clearCallingIdentity();\n            try {\n                final ActivityStack stack = mRootWindowContainer.getStack(stackId);\n                if (stack == null) {\n                    Slog.w(TAG, \"removeStack: No stack with id=\" + stackId);\n                    return;\n                }\n                if (!stack.isActivityTypeStandardOrUndefined()) {\n                    throw new IllegalArgumentException(\n                            \"Removing non-standard stack is not allowed.\");\n                }\n                mStackSupervisor.removeStack(stack);\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n    }\n\n    @Override\n    public void moveStackToDisplay(int stackId, int displayId) {\n        mAmInternal.enforceCallingPermission(INTERNAL_SYSTEM_WINDOW, \"moveStackToDisplay()\");\n\n        synchronized (mGlobalLock) {\n            final long ident = Binder.clearCallingIdentity();\n            try {\n                if (DEBUG_STACK) Slog.d(TAG_STACK, \"moveStackToDisplay: moving stackId=\" + stackId\n                        + \" to displayId=\" + displayId);\n                mRootWindowContainer.moveStackToDisplay(stackId, displayId, ON_TOP);\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n    }\n\n    @Override\n    public void toggleFreeformWindowingMode(IBinder token) {\n        synchronized (mGlobalLock) {\n            long ident = Binder.clearCallingIdentity();\n            try {\n                final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n                if (r == null) {\n                    throw new IllegalArgumentException(\n                            \"toggleFreeformWindowingMode: No activity record matching token=\"\n                                    + token);\n                }\n\n                final ActivityStack stack = r.getRootTask();\n                if (stack == null) {\n                    throw new IllegalStateException(\"toggleFreeformWindowingMode: the activity \"\n                            + \"doesn't have a stack\");\n                }\n\n                if (!stack.inFreeformWindowingMode()\n                        && stack.getWindowingMode() != WINDOWING_MODE_FULLSCREEN) {\n                    throw new IllegalStateException(\"toggleFreeformWindowingMode: You can only \"\n                            + \"toggle between fullscreen and freeform.\");\n                }\n\n                if (stack.inFreeformWindowingMode()) {\n                    stack.setWindowingMode(WINDOWING_MODE_FULLSCREEN);\n                } else if (!mSizeCompatFreeform && r.inSizeCompatMode()) {\n                    throw new IllegalStateException(\"Size-compat windows are currently not\"\n                            + \"freeform-enabled\");\n                } else if (stack.getParent().inFreeformWindowingMode()) {\n                    // If the window is on a freeform display, set it to undefined. It will be\n                    // resolved to freeform and it can adjust windowing mode when the display mode\n                    // changes in runtime.\n                    stack.setWindowingMode(WINDOWING_MODE_UNDEFINED);\n                } else {\n                    stack.setWindowingMode(WINDOWING_MODE_FREEFORM);\n                }\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n    }\n\n    /** Sets the task stack listener that gets callbacks when a task stack changes. */\n    @Override\n    public void registerTaskStackListener(ITaskStackListener listener) {\n        enforceCallerIsRecentsOrHasPermission(MANAGE_ACTIVITY_STACKS,\n                \"registerTaskStackListener()\");\n        mTaskChangeNotificationController.registerTaskStackListener(listener);\n    }\n\n    /** Unregister a task stack listener so that it stops receiving callbacks. */\n    @Override\n    public void unregisterTaskStackListener(ITaskStackListener listener) {\n        enforceCallerIsRecentsOrHasPermission(MANAGE_ACTIVITY_STACKS,\n                \"unregisterTaskStackListener()\");\n        mTaskChangeNotificationController.unregisterTaskStackListener(listener);\n    }\n\n    @Override\n    public boolean requestAssistContextExtras(int requestType, IAssistDataReceiver receiver,\n            Bundle receiverExtras, IBinder activityToken, boolean focused, boolean newSessionId) {\n        return enqueueAssistContext(requestType, null, null, receiver, receiverExtras,\n                activityToken, focused, newSessionId, UserHandle.getCallingUserId(), null,\n                PENDING_ASSIST_EXTRAS_LONG_TIMEOUT, 0) != null;\n    }\n\n    @Override\n    public boolean requestAutofillData(IAssistDataReceiver receiver, Bundle receiverExtras,\n            IBinder activityToken, int flags) {\n        return enqueueAssistContext(ActivityManager.ASSIST_CONTEXT_AUTOFILL, null, null,\n                receiver, receiverExtras, activityToken, true, true, UserHandle.getCallingUserId(),\n                null, PENDING_AUTOFILL_ASSIST_STRUCTURE_TIMEOUT, flags) != null;\n    }\n\n    @Override\n    public boolean launchAssistIntent(Intent intent, int requestType, String hint, int userHandle,\n            Bundle args) {\n        return enqueueAssistContext(requestType, intent, hint, null, null, null,\n                true /* focused */, true /* newSessionId */, userHandle, args,\n                PENDING_ASSIST_EXTRAS_TIMEOUT, 0) != null;\n    }\n\n    @Override\n    public Bundle getAssistContextExtras(int requestType) {\n        PendingAssistExtras pae = enqueueAssistContext(requestType, null, null, null,\n                null, null, true /* focused */, true /* newSessionId */,\n                UserHandle.getCallingUserId(), null, PENDING_ASSIST_EXTRAS_TIMEOUT, 0);\n        if (pae == null) {\n            return null;\n        }\n        synchronized (pae) {\n            while (!pae.haveResult) {\n                try {\n                    pae.wait();\n                } catch (InterruptedException e) {\n                }\n            }\n        }\n        synchronized (mGlobalLock) {\n            buildAssistBundleLocked(pae, pae.result);\n            mPendingAssistExtras.remove(pae);\n            mUiHandler.removeCallbacks(pae);\n        }\n        return pae.extras;\n    }\n\n    /**\n     * Binder IPC calls go through the public entry point.\n     * This can be called with or without the global lock held.\n     */\n    private static int checkCallingPermission(String permission) {\n        return checkPermission(\n                permission, Binder.getCallingPid(), UserHandle.getAppId(Binder.getCallingUid()));\n    }\n\n    /** This can be called with or without the global lock held. */\n    private void enforceCallerIsRecentsOrHasPermission(String permission, String func) {\n        if (!getRecentTasks().isCallerRecents(Binder.getCallingUid())) {\n            mAmInternal.enforceCallingPermission(permission, func);\n        }\n    }\n\n    @VisibleForTesting\n    int checkGetTasksPermission(String permission, int pid, int uid) {\n        return checkPermission(permission, pid, uid);\n    }\n\n    static int checkPermission(String permission, int pid, int uid) {\n        if (permission == null) {\n            return PackageManager.PERMISSION_DENIED;\n        }\n        return checkComponentPermission(permission, pid, uid, -1, true);\n    }\n\n    public static int checkComponentPermission(String permission, int pid, int uid,\n            int owningUid, boolean exported) {\n        return ActivityManagerService.checkComponentPermission(\n                permission, pid, uid, owningUid, exported);\n    }\n\n    boolean isGetTasksAllowed(String caller, int callingPid, int callingUid) {\n        if (getRecentTasks().isCallerRecents(callingUid)) {\n            // Always allow the recents component to get tasks\n            return true;\n        }\n\n        boolean allowed = checkGetTasksPermission(android.Manifest.permission.REAL_GET_TASKS,\n                callingPid, callingUid) == PackageManager.PERMISSION_GRANTED;\n        if (!allowed) {\n            if (checkGetTasksPermission(android.Manifest.permission.GET_TASKS,\n                    callingPid, callingUid) == PackageManager.PERMISSION_GRANTED) {\n                // Temporary compatibility: some existing apps on the system image may\n                // still be requesting the old permission and not switched to the new\n                // one; if so, we'll still allow them full access.  This means we need\n                // to see if they are holding the old permission and are a system app.\n                try {\n                    if (AppGlobals.getPackageManager().isUidPrivileged(callingUid)) {\n                        allowed = true;\n                        if (DEBUG_TASKS) Slog.w(TAG, caller + \": caller \" + callingUid\n                                + \" is using old GET_TASKS but privileged; allowing\");\n                    }\n                } catch (RemoteException e) {\n                }\n            }\n            if (DEBUG_TASKS) Slog.w(TAG, caller + \": caller \" + callingUid\n                    + \" does not hold REAL_GET_TASKS; limiting output\");\n        }\n        return allowed;\n    }\n\n    boolean isCrossUserAllowed(int pid, int uid) {\n        return checkPermission(INTERACT_ACROSS_USERS, pid, uid) == PERMISSION_GRANTED\n                || checkPermission(INTERACT_ACROSS_USERS_FULL, pid, uid) == PERMISSION_GRANTED;\n    }\n\n    private PendingAssistExtras enqueueAssistContext(int requestType, Intent intent, String hint,\n            IAssistDataReceiver receiver, Bundle receiverExtras, IBinder activityToken,\n            boolean focused, boolean newSessionId, int userHandle, Bundle args, long timeout,\n            int flags) {\n        mAmInternal.enforceCallingPermission(android.Manifest.permission.GET_TOP_ACTIVITY_INFO,\n                \"enqueueAssistContext()\");\n\n        synchronized (mGlobalLock) {\n            final ActivityStack stack = getTopDisplayFocusedStack();\n            ActivityRecord activity = stack != null ? stack.getTopNonFinishingActivity() : null;\n            if (activity == null) {\n                Slog.w(TAG, \"getAssistContextExtras failed: no top activity\");\n                return null;\n            }\n            if (!activity.attachedToProcess()) {\n                Slog.w(TAG, \"getAssistContextExtras failed: no process for \" + activity);\n                return null;\n            }\n            if (focused) {\n                if (activityToken != null) {\n                    ActivityRecord caller = ActivityRecord.forTokenLocked(activityToken);\n                    if (activity != caller) {\n                        Slog.w(TAG, \"enqueueAssistContext failed: caller \" + caller\n                                + \" is not current top \" + activity);\n                        return null;\n                    }\n                }\n            } else {\n                activity = ActivityRecord.forTokenLocked(activityToken);\n                if (activity == null) {\n                    Slog.w(TAG, \"enqueueAssistContext failed: activity for token=\" + activityToken\n                            + \" couldn't be found\");\n                    return null;\n                }\n                if (!activity.attachedToProcess()) {\n                    Slog.w(TAG, \"enqueueAssistContext failed: no process for \" + activity);\n                    return null;\n                }\n            }\n\n            PendingAssistExtras pae;\n            Bundle extras = new Bundle();\n            if (args != null) {\n                extras.putAll(args);\n            }\n            extras.putString(Intent.EXTRA_ASSIST_PACKAGE, activity.packageName);\n            extras.putInt(Intent.EXTRA_ASSIST_UID, activity.app.mUid);\n\n            pae = new PendingAssistExtras(activity, extras, intent, hint, receiver, receiverExtras,\n                    userHandle);\n            pae.isHome = activity.isActivityTypeHome();\n\n            // Increment the sessionId if necessary\n            if (newSessionId) {\n                mViSessionId++;\n            }\n            try {\n                activity.app.getThread().requestAssistContextExtras(activity.appToken, pae,\n                        requestType, mViSessionId, flags);\n                mPendingAssistExtras.add(pae);\n                mUiHandler.postDelayed(pae, timeout);\n            } catch (RemoteException e) {\n                Slog.w(TAG, \"getAssistContextExtras failed: crash calling \" + activity);\n                return null;\n            }\n            return pae;\n        }\n    }\n\n    private void buildAssistBundleLocked(PendingAssistExtras pae, Bundle result) {\n        if (result != null) {\n            pae.extras.putBundle(Intent.EXTRA_ASSIST_CONTEXT, result);\n        }\n        if (pae.hint != null) {\n            pae.extras.putBoolean(pae.hint, true);\n        }\n    }\n\n    private void pendingAssistExtrasTimedOut(PendingAssistExtras pae) {\n        IAssistDataReceiver receiver;\n        synchronized (mGlobalLock) {\n            mPendingAssistExtras.remove(pae);\n            receiver = pae.receiver;\n        }\n        if (receiver != null) {\n            // Caller wants result sent back to them.\n            Bundle sendBundle = new Bundle();\n            // At least return the receiver extras\n            sendBundle.putBundle(ASSIST_KEY_RECEIVER_EXTRAS, pae.receiverExtras);\n            try {\n                pae.receiver.onHandleAssistData(sendBundle);\n            } catch (RemoteException e) {\n            }\n        }\n    }\n\n    public class PendingAssistExtras extends Binder implements Runnable {\n        public final ActivityRecord activity;\n        public boolean isHome;\n        public final Bundle extras;\n        public final Intent intent;\n        public final String hint;\n        public final IAssistDataReceiver receiver;\n        public final int userHandle;\n        public boolean haveResult = false;\n        public Bundle result = null;\n        public AssistStructure structure = null;\n        public AssistContent content = null;\n        public Bundle receiverExtras;\n\n        public PendingAssistExtras(ActivityRecord _activity, Bundle _extras, Intent _intent,\n                String _hint, IAssistDataReceiver _receiver, Bundle _receiverExtras,\n                int _userHandle) {\n            activity = _activity;\n            extras = _extras;\n            intent = _intent;\n            hint = _hint;\n            receiver = _receiver;\n            receiverExtras = _receiverExtras;\n            userHandle = _userHandle;\n        }\n\n        @Override\n        public void run() {\n            Slog.w(TAG, \"getAssistContextExtras failed: timeout retrieving from \" + activity);\n            synchronized (this) {\n                haveResult = true;\n                notifyAll();\n            }\n            pendingAssistExtrasTimedOut(this);\n        }\n    }\n\n    @Override\n    public boolean isAssistDataAllowedOnCurrentActivity() {\n        int userId;\n        synchronized (mGlobalLock) {\n            final ActivityStack focusedStack = getTopDisplayFocusedStack();\n            if (focusedStack == null || focusedStack.isActivityTypeAssistant()) {\n                return false;\n            }\n\n            final ActivityRecord activity = focusedStack.getTopNonFinishingActivity();\n            if (activity == null) {\n                return false;\n            }\n            userId = activity.mUserId;\n        }\n        return DevicePolicyCache.getInstance().isScreenCaptureAllowed(userId, false);\n    }\n\n    @Override\n    public boolean showAssistFromActivity(IBinder token, Bundle args) {\n        long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                ActivityRecord caller = ActivityRecord.forTokenLocked(token);\n                ActivityRecord top = getTopDisplayFocusedStack().getTopNonFinishingActivity();\n                if (top != caller) {\n                    Slog.w(TAG, \"showAssistFromActivity failed: caller \" + caller\n                            + \" is not current top \" + top);\n                    return false;\n                }\n                if (!top.nowVisible) {\n                    Slog.w(TAG, \"showAssistFromActivity failed: caller \" + caller\n                            + \" is not visible\");\n                    return false;\n                }\n            }\n            return mAssistUtils.showSessionForActiveService(args, SHOW_SOURCE_APPLICATION, null,\n                    token);\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public boolean isRootVoiceInteraction(IBinder token) {\n        synchronized (mGlobalLock) {\n            ActivityRecord r = ActivityRecord.isInStackLocked(token);\n            if (r == null) {\n                return false;\n            }\n            return r.rootVoiceInteraction;\n        }\n    }\n\n    private void onLocalVoiceInteractionStartedLocked(IBinder activity,\n            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor) {\n        ActivityRecord activityToCallback = ActivityRecord.forTokenLocked(activity);\n        if (activityToCallback == null) return;\n        activityToCallback.setVoiceSessionLocked(voiceSession);\n\n        // Inform the activity\n        try {\n            activityToCallback.app.getThread().scheduleLocalVoiceInteractionStarted(activity,\n                    voiceInteractor);\n            long token = Binder.clearCallingIdentity();\n            try {\n                startRunningVoiceLocked(voiceSession, activityToCallback.info.applicationInfo.uid);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            // TODO: VI Should we cache the activity so that it's easier to find later\n            // rather than scan through all the stacks and activities?\n        } catch (RemoteException re) {\n            activityToCallback.clearVoiceSessionLocked();\n            // TODO: VI Should this terminate the voice session?\n        }\n    }\n\n    private void startRunningVoiceLocked(IVoiceInteractionSession session, int targetUid) {\n        Slog.d(TAG, \"<<<  startRunningVoiceLocked()\");\n        mVoiceWakeLock.setWorkSource(new WorkSource(targetUid));\n        if (mRunningVoice == null || mRunningVoice.asBinder() != session.asBinder()) {\n            boolean wasRunningVoice = mRunningVoice != null;\n            mRunningVoice = session;\n            if (!wasRunningVoice) {\n                mVoiceWakeLock.acquire();\n                updateSleepIfNeededLocked();\n            }\n        }\n    }\n\n    void finishRunningVoiceLocked() {\n        if (mRunningVoice != null) {\n            mRunningVoice = null;\n            mVoiceWakeLock.release();\n            updateSleepIfNeededLocked();\n        }\n    }\n\n    @Override\n    public void setVoiceKeepAwake(IVoiceInteractionSession session, boolean keepAwake) {\n        synchronized (mGlobalLock) {\n            if (mRunningVoice != null && mRunningVoice.asBinder() == session.asBinder()) {\n                if (keepAwake) {\n                    mVoiceWakeLock.acquire();\n                } else {\n                    mVoiceWakeLock.release();\n                }\n            }\n        }\n    }\n\n    @Override\n    public ComponentName getActivityClassForToken(IBinder token) {\n        synchronized (mGlobalLock) {\n            ActivityRecord r = ActivityRecord.isInStackLocked(token);\n            if (r == null) {\n                return null;\n            }\n            return r.intent.getComponent();\n        }\n    }\n\n    @Override\n    public String getPackageForToken(IBinder token) {\n        synchronized (mGlobalLock) {\n            ActivityRecord r = ActivityRecord.isInStackLocked(token);\n            if (r == null) {\n                return null;\n            }\n            return r.packageName;\n        }\n    }\n\n    @Override\n    public void showLockTaskEscapeMessage(IBinder token) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n            if (r == null) {\n                return;\n            }\n            getLockTaskController().showLockTaskToast();\n        }\n    }\n\n    @Override\n    public void keyguardGoingAway(int flags) {\n        enforceNotIsolatedCaller(\"keyguardGoingAway\");\n        final long token = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                mKeyguardController.keyguardGoingAway(flags);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Try to place task to provided position. The final position might be different depending on\n     * current user and stacks state. The task will be moved to target stack if it's currently in\n     * different stack.\n     */\n    @Override\n    public void positionTaskInStack(int taskId, int stackId, int position) {\n        mAmInternal.enforceCallingPermission(MANAGE_ACTIVITY_STACKS, \"positionTaskInStack()\");\n        synchronized (mGlobalLock) {\n            long ident = Binder.clearCallingIdentity();\n            try {\n                if (DEBUG_STACK) Slog.d(TAG_STACK, \"positionTaskInStack: positioning task=\"\n                        + taskId + \" in stackId=\" + stackId + \" at position=\" + position);\n                final Task task = mRootWindowContainer.anyTaskForId(taskId);\n                if (task == null) {\n                    throw new IllegalArgumentException(\"positionTaskInStack: no task for id=\"\n                            + taskId);\n                }\n\n                final ActivityStack stack = mRootWindowContainer.getStack(stackId);\n\n                if (stack == null) {\n                    throw new IllegalArgumentException(\"positionTaskInStack: no stack for id=\"\n                            + stackId);\n                }\n                if (!stack.isActivityTypeStandardOrUndefined()) {\n                    throw new IllegalArgumentException(\"positionTaskInStack: Attempt to change\"\n                            + \" the position of task \" + taskId + \" in/to non-standard stack\");\n                }\n\n                // TODO: Have the callers of this API call a separate reparent method if that is\n                // what they intended to do vs. having this method also do reparenting.\n                if (task.getStack() == stack) {\n                    // Change position in current stack.\n                    stack.positionChildAt(task, position);\n                } else {\n                    // Reparent to new stack.\n                    task.reparent(stack, position, REPARENT_LEAVE_STACK_IN_PLACE, !ANIMATE,\n                            !DEFER_RESUME, \"positionTaskInStack\");\n                }\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n    }\n\n    @Override\n    public void reportSizeConfigurations(IBinder token, int[] horizontalSizeConfiguration,\n            int[] verticalSizeConfigurations, int[] smallestSizeConfigurations) {\n        if (DEBUG_CONFIGURATION) Slog.v(TAG, \"Report configuration: \" + token + \" \"\n                + Arrays.toString(horizontalSizeConfiguration) + \" \"\n                + Arrays.toString(verticalSizeConfigurations));\n        synchronized (mGlobalLock) {\n            ActivityRecord record = ActivityRecord.isInStackLocked(token);\n            if (record == null) {\n                throw new IllegalArgumentException(\"reportSizeConfigurations: ActivityRecord not \"\n                        + \"found for: \" + token);\n            }\n            record.setSizeConfigurations(horizontalSizeConfiguration,\n                    verticalSizeConfigurations, smallestSizeConfigurations);\n        }\n    }\n\n    @Override\n    public void suppressResizeConfigChanges(boolean suppress) throws RemoteException {\n        mAmInternal.enforceCallingPermission(MANAGE_ACTIVITY_STACKS, \"suppressResizeConfigChanges()\");\n        synchronized (mGlobalLock) {\n            mSuppressResizeConfigChanges = suppress;\n        }\n    }\n\n    /**\n     * Moves the top activity in the input stackId to the pinned stack.\n     *\n     * @param stackId Id of stack to move the top activity to pinned stack.\n     * @param bounds Bounds to use for pinned stack.\n     *\n     * @return True if the top activity of the input stack was successfully moved to the pinned\n     *          stack.\n     */\n    @Override\n    public boolean moveTopActivityToPinnedStack(int stackId, Rect bounds) {\n        enforceCallerIsRecentsOrHasPermission(MANAGE_ACTIVITY_STACKS,\n                \"moveTopActivityToPinnedStack()\");\n        synchronized (mGlobalLock) {\n            if (!mSupportsPictureInPicture) {\n                throw new IllegalStateException(\"moveTopActivityToPinnedStack:\"\n                        + \"Device doesn't support picture-in-picture mode\");\n            }\n\n            long ident = Binder.clearCallingIdentity();\n            try {\n                return mRootWindowContainer.moveTopStackActivityToPinnedStack(stackId);\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n    }\n\n    @VisibleForTesting\n    boolean isInPictureInPictureMode(ActivityRecord r) {\n        return r != null\n                && r.getRootTask() != null\n                && r.inPinnedWindowingMode()\n                && r.getRootTask().isInTask(r) != null;\n    }\n\n    @Override\n    public boolean enterPictureInPictureMode(IBinder token, final PictureInPictureParams params) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ensureValidPictureInPictureActivityParamsLocked(\n                        \"enterPictureInPictureMode\", token, params);\n\n                // If the activity is already in picture in picture mode, then just return early\n                if (isInPictureInPictureMode(r)) {\n                    return true;\n                }\n\n                // Activity supports picture-in-picture, now check that we can enter PiP at this\n                // point, if it is\n                if (!r.checkEnterPictureInPictureState(\"enterPictureInPictureMode\",\n                        false /* beforeStopping */)) {\n                    return false;\n                }\n\n                final Runnable enterPipRunnable = () -> {\n                    synchronized (mGlobalLock) {\n                        if (r.getParent() == null) {\n                            Slog.e(TAG, \"Skip enterPictureInPictureMode, destroyed \" + r);\n                            return;\n                        }\n                        // Only update the saved args from the args that are set\n                        r.setPictureInPictureParams(params);\n                        final float aspectRatio = r.pictureInPictureArgs.getAspectRatio();\n                        final List<RemoteAction> actions = r.pictureInPictureArgs.getActions();\n                        mRootWindowContainer.moveActivityToPinnedStack(\n                                r, \"enterPictureInPictureMode\");\n                        final ActivityStack stack = r.getRootTask();\n                        stack.setPictureInPictureAspectRatio(aspectRatio);\n                        stack.setPictureInPictureActions(actions);\n                        MetricsLoggerWrapper.logPictureInPictureEnter(mContext,\n                                r.info.applicationInfo.uid, r.shortComponentName,\n                                r.supportsEnterPipOnTaskSwitch);\n                        logPictureInPictureArgs(params);\n                    }\n                };\n\n                if (isKeyguardLocked()) {\n                    // If the keyguard is showing or occluded, then try and dismiss it before\n                    // entering picture-in-picture (this will prompt the user to authenticate if the\n                    // device is currently locked).\n                    dismissKeyguard(token, new KeyguardDismissCallback() {\n                        @Override\n                        public void onDismissSucceeded() {\n                            mH.post(enterPipRunnable);\n                        }\n                    }, null /* message */);\n                } else {\n                    // Enter picture in picture immediately otherwise\n                    enterPipRunnable.run();\n                }\n                return true;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public void setPictureInPictureParams(IBinder token, final PictureInPictureParams params) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ensureValidPictureInPictureActivityParamsLocked(\n                        \"setPictureInPictureParams\", token, params);\n\n                // Only update the saved args from the args that are set\n                r.setPictureInPictureParams(params);\n                if (r.inPinnedWindowingMode()) {\n                    // If the activity is already in picture-in-picture, update the pinned stack now\n                    // if it is not already expanding to fullscreen. Otherwise, the arguments will\n                    // be used the next time the activity enters PiP\n                    final ActivityStack stack = r.getRootTask();\n                    stack.setPictureInPictureAspectRatio(\n                            r.pictureInPictureArgs.getAspectRatio());\n                    stack.setPictureInPictureActions(r.pictureInPictureArgs.getActions());\n                }\n                logPictureInPictureArgs(params);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public int getMaxNumPictureInPictureActions(IBinder token) {\n        // Currently, this is a static constant, but later, we may change this to be dependent on\n        // the context of the activity\n        return 3;\n    }\n\n    private void logPictureInPictureArgs(PictureInPictureParams params) {\n        if (params.hasSetActions()) {\n            MetricsLogger.histogram(mContext, \"tron_varz_picture_in_picture_actions_count\",\n                    params.getActions().size());\n        }\n        if (params.hasSetAspectRatio()) {\n            LogMaker lm = new LogMaker(MetricsEvent.ACTION_PICTURE_IN_PICTURE_ASPECT_RATIO_CHANGED);\n            lm.addTaggedData(MetricsEvent.PICTURE_IN_PICTURE_ASPECT_RATIO, params.getAspectRatio());\n            MetricsLogger.action(lm);\n        }\n    }\n\n    /**\n     * Checks the state of the system and the activity associated with the given {@param token} to\n     * verify that picture-in-picture is supported for that activity.\n     *\n     * @return the activity record for the given {@param token} if all the checks pass.\n     */\n    private ActivityRecord ensureValidPictureInPictureActivityParamsLocked(String caller,\n            IBinder token, PictureInPictureParams params) {\n        if (!mSupportsPictureInPicture) {\n            throw new IllegalStateException(caller\n                    + \": Device doesn't support picture-in-picture mode.\");\n        }\n\n        final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n        if (r == null) {\n            throw new IllegalStateException(caller\n                    + \": Can't find activity for token=\" + token);\n        }\n\n        if (!r.supportsPictureInPicture()) {\n            throw new IllegalStateException(caller\n                    + \": Current activity does not support picture-in-picture.\");\n        }\n\n        if (params.hasSetAspectRatio()\n                && !mWindowManager.isValidPictureInPictureAspectRatio(\n                        r.getDisplay(), params.getAspectRatio())) {\n            final float minAspectRatio = mContext.getResources().getFloat(\n                    com.android.internal.R.dimen.config_pictureInPictureMinAspectRatio);\n            final float maxAspectRatio = mContext.getResources().getFloat(\n                    com.android.internal.R.dimen.config_pictureInPictureMaxAspectRatio);\n            throw new IllegalArgumentException(String.format(caller\n                            + \": Aspect ratio is too extreme (must be between %f and %f).\",\n                    minAspectRatio, maxAspectRatio));\n        }\n\n        // Truncate the number of actions if necessary\n        params.truncateActions(getMaxNumPictureInPictureActions(token));\n\n        return r;\n    }\n\n    @Override\n    public IBinder getUriPermissionOwnerForActivity(IBinder activityToken) {\n        enforceNotIsolatedCaller(\"getUriPermissionOwnerForActivity\");\n        synchronized (mGlobalLock) {\n            ActivityRecord r = ActivityRecord.isInStackLocked(activityToken);\n            if (r == null) {\n                throw new IllegalArgumentException(\"Activity does not exist; token=\"\n                        + activityToken);\n            }\n            return r.getUriPermissionsLocked().getExternalToken();\n        }\n    }\n\n    // TODO(b/149338177): remove when CTS no-longer requires it\n    @Override\n    public void resizeDockedStack(Rect dockedBounds, Rect tempDockedTaskBounds,\n            Rect tempDockedTaskInsetBounds,\n            Rect tempOtherTaskBounds, Rect tempOtherTaskInsetBounds) {\n        enforceCallerIsRecentsOrHasPermission(MANAGE_ACTIVITY_STACKS, \"resizeDockedStack()\");\n        long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final TaskDisplayArea tc = mRootWindowContainer.getDefaultTaskDisplayArea();\n                final Task primary = tc.getRootSplitScreenPrimaryTask();\n                final Task secondary = tc.getTask(t -> t.mCreatedByOrganizer && t.isRootTask()\n                        && t.inSplitScreenSecondaryWindowingMode());\n                if (primary == null || secondary == null) {\n                    return;\n                }\n                final WindowContainerTransaction wct = new WindowContainerTransaction();\n                final Rect primaryRect =\n                        tempDockedTaskInsetBounds != null ? tempDockedTaskInsetBounds\n                            : (tempDockedTaskBounds != null ? tempDockedTaskBounds\n                                    : dockedBounds);\n                wct.setBounds(primary.mRemoteToken.toWindowContainerToken(), primaryRect);\n                Rect otherRect = tempOtherTaskInsetBounds != null ? tempOtherTaskInsetBounds\n                        : tempOtherTaskBounds;\n                if (otherRect == null) {\n                    // Temporary estimation... again this is just for tests.\n                    otherRect = new Rect(secondary.getBounds());\n                    if (tc.getBounds().width() > tc.getBounds().height()) {\n                        otherRect.left = primaryRect.right + 6;\n                    } else {\n                        otherRect.top = primaryRect.bottom + 6;\n                    }\n                }\n                wct.setBounds(secondary.mRemoteToken.toWindowContainerToken(), otherRect);\n                mWindowOrganizerController.applyTransaction(wct);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public void setSplitScreenResizing(boolean resizing) {\n        enforceCallerIsRecentsOrHasPermission(MANAGE_ACTIVITY_STACKS, \"setSplitScreenResizing()\");\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                mStackSupervisor.setSplitScreenResizing(resizing);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public IWindowOrganizerController getWindowOrganizerController() {\n        mAmInternal.enforceCallingPermission(MANAGE_ACTIVITY_STACKS,\n                \"getWindowOrganizerController()\");\n        return mWindowOrganizerController;\n    }\n\n    /**\n     * Check that we have the features required for VR-related API calls, and throw an exception if\n     * not.\n     */\n    public void enforceSystemHasVrFeature() {\n        if (!mContext.getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE)) {\n            throw new UnsupportedOperationException(\"VR mode not supported on this device!\");\n        }\n    }\n\n    @Override\n    public int setVrMode(IBinder token, boolean enabled, ComponentName packageName) {\n        enforceSystemHasVrFeature();\n\n        final VrManagerInternal vrService = LocalServices.getService(VrManagerInternal.class);\n\n        ActivityRecord r;\n        synchronized (mGlobalLock) {\n            r = ActivityRecord.isInStackLocked(token);\n        }\n\n        if (r == null) {\n            throw new IllegalArgumentException();\n        }\n\n        int err;\n        if ((err = vrService.hasVrPackage(packageName, r.mUserId)) !=\n                VrManagerInternal.NO_ERROR) {\n            return err;\n        }\n\n        // Clear the binder calling uid since this path may call moveToTask().\n        final long callingId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                r.requestedVrComponent = (enabled) ? packageName : null;\n\n                // Update associated state if this activity is currently focused\n                if (r.isResumedActivityOnDisplay()) {\n                    applyUpdateVrModeLocked(r);\n                }\n                return 0;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(callingId);\n        }\n    }\n\n    @Override\n    public void startLocalVoiceInteraction(IBinder callingActivity, Bundle options) {\n        Slog.i(TAG, \"Activity tried to startLocalVoiceInteraction\");\n        synchronized (mGlobalLock) {\n            ActivityRecord activity = getTopDisplayFocusedStack().getTopNonFinishingActivity();\n            if (ActivityRecord.forTokenLocked(callingActivity) != activity) {\n                throw new SecurityException(\"Only focused activity can call startVoiceInteraction\");\n            }\n            if (mRunningVoice != null || activity.getTask().voiceSession != null\n                    || activity.voiceSession != null) {\n                Slog.w(TAG, \"Already in a voice interaction, cannot start new voice interaction\");\n                return;\n            }\n            if (activity.pendingVoiceInteractionStart) {\n                Slog.w(TAG, \"Pending start of voice interaction already.\");\n                return;\n            }\n            activity.pendingVoiceInteractionStart = true;\n        }\n        LocalServices.getService(VoiceInteractionManagerInternal.class)\n                .startLocalVoiceInteraction(callingActivity, options);\n    }\n\n    @Override\n    public void stopLocalVoiceInteraction(IBinder callingActivity) {\n        LocalServices.getService(VoiceInteractionManagerInternal.class)\n                .stopLocalVoiceInteraction(callingActivity);\n    }\n\n    @Override\n    public boolean supportsLocalVoiceInteraction() {\n        return LocalServices.getService(VoiceInteractionManagerInternal.class)\n                .supportsLocalVoiceInteraction();\n    }\n\n    @Override\n    public boolean updateConfiguration(Configuration values) {\n        mAmInternal.enforceCallingPermission(CHANGE_CONFIGURATION, \"updateConfiguration()\");\n\n        synchronized (mGlobalLock) {\n            if (mWindowManager == null) {\n                Slog.w(TAG, \"Skip updateConfiguration because mWindowManager isn't set\");\n                return false;\n            }\n\n            if (values == null) {\n                // sentinel: fetch the current configuration from the window manager\n                values = mWindowManager.computeNewConfiguration(DEFAULT_DISPLAY);\n            }\n\n            mH.sendMessage(PooledLambda.obtainMessage(\n                    ActivityManagerInternal::updateOomLevelsForDisplay, mAmInternal,\n                    DEFAULT_DISPLAY));\n\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                if (values != null) {\n                    Settings.System.clearConfiguration(values);\n                }\n                updateConfigurationLocked(values, null, false, false /* persistent */,\n                        UserHandle.USER_NULL, false /* deferResume */,\n                        mTmpUpdateConfigurationResult);\n                return mTmpUpdateConfigurationResult.changes != 0;\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public void dismissKeyguard(IBinder token, IKeyguardDismissCallback callback,\n            CharSequence message) {\n        if (message != null) {\n            mAmInternal.enforceCallingPermission(\n                    Manifest.permission.SHOW_KEYGUARD_MESSAGE, \"dismissKeyguard()\");\n        }\n        final long callingId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                mKeyguardController.dismissKeyguard(token, callback, message);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(callingId);\n        }\n    }\n\n    @Override\n    public void cancelTaskWindowTransition(int taskId) {\n        enforceCallerIsRecentsOrHasPermission(MANAGE_ACTIVITY_STACKS,\n                \"cancelTaskWindowTransition()\");\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final Task task = mRootWindowContainer.anyTaskForId(taskId,\n                        MATCH_TASK_IN_STACKS_ONLY);\n                if (task == null) {\n                    Slog.w(TAG, \"cancelTaskWindowTransition: taskId=\" + taskId + \" not found\");\n                    return;\n                }\n                task.cancelTaskWindowTransition();\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public ActivityManager.TaskSnapshot getTaskSnapshot(int taskId, boolean isLowResolution) {\n        enforceCallerIsRecentsOrHasPermission(READ_FRAME_BUFFER, \"getTaskSnapshot()\");\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            return getTaskSnapshot(taskId, isLowResolution, true /* restoreFromDisk */);\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    private ActivityManager.TaskSnapshot getTaskSnapshot(int taskId, boolean isLowResolution,\n            boolean restoreFromDisk) {\n        final Task task;\n        synchronized (mGlobalLock) {\n            task = mRootWindowContainer.anyTaskForId(taskId,\n                    MATCH_TASK_IN_STACKS_OR_RECENT_TASKS);\n            if (task == null) {\n                Slog.w(TAG, \"getTaskSnapshot: taskId=\" + taskId + \" not found\");\n                return null;\n            }\n        }\n        // Don't call this while holding the lock as this operation might hit the disk.\n        return task.getSnapshot(isLowResolution, restoreFromDisk);\n    }\n\n    @Override\n    public void setDisablePreviewScreenshots(IBinder token, boolean disable) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInStackLocked(token);\n            if (r == null) {\n                Slog.w(TAG, \"setDisablePreviewScreenshots: Unable to find activity for token=\"\n                        + token);\n                return;\n            }\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                r.setDisablePreviewScreenshots(disable);\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public void invalidateHomeTaskSnapshot(IBinder token) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInStackLocked(token);\n            if (r == null || !r.isActivityTypeHome()) {\n                return;\n            }\n            mWindowManager.mTaskSnapshotController.removeSnapshotCache(r.getTask().mTaskId);\n        }\n    }\n\n    /** Return the user id of the last resumed activity. */\n    @Override\n    public @UserIdInt\n    int getLastResumedActivityUserId() {\n        mAmInternal.enforceCallingPermission(\n                Manifest.permission.INTERACT_ACROSS_USERS_FULL, \"getLastResumedActivityUserId()\");\n        synchronized (mGlobalLock) {\n            if (mLastResumedActivity == null) {\n                return getCurrentUserId();\n            }\n            return mLastResumedActivity.mUserId;\n        }\n    }\n\n    @Override\n    public void updateLockTaskFeatures(int userId, int flags) {\n        final int callingUid = Binder.getCallingUid();\n        if (callingUid != 0 && callingUid != SYSTEM_UID) {\n            mAmInternal.enforceCallingPermission(android.Manifest.permission.UPDATE_LOCK_TASK_PACKAGES,\n                    \"updateLockTaskFeatures()\");\n        }\n        synchronized (mGlobalLock) {\n            if (DEBUG_LOCKTASK) Slog.w(TAG_LOCKTASK, \"Allowing features \" + userId + \":0x\" +\n                    Integer.toHexString(flags));\n            getLockTaskController().updateLockTaskFeatures(userId, flags);\n        }\n    }\n\n    @Override\n    public void setShowWhenLocked(IBinder token, boolean showWhenLocked) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInStackLocked(token);\n            if (r == null) {\n                return;\n            }\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                r.setShowWhenLocked(showWhenLocked);\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public void setInheritShowWhenLocked(IBinder token, boolean inheritShowWhenLocked) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInStackLocked(token);\n            if (r == null) {\n                return;\n            }\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                r.setInheritShowWhenLocked(inheritShowWhenLocked);\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public void setTurnScreenOn(IBinder token, boolean turnScreenOn) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInStackLocked(token);\n            if (r == null) {\n                return;\n            }\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                r.setTurnScreenOn(turnScreenOn);\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public void registerRemoteAnimations(IBinder token, RemoteAnimationDefinition definition) {\n        mAmInternal.enforceCallingPermission(CONTROL_REMOTE_APP_TRANSITION_ANIMATIONS,\n                \"registerRemoteAnimations\");\n        definition.setCallingPidUid(Binder.getCallingPid(), Binder.getCallingUid());\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInStackLocked(token);\n            if (r == null) {\n                return;\n            }\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                r.registerRemoteAnimations(definition);\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public void unregisterRemoteAnimations(IBinder token) {\n        mAmInternal.enforceCallingPermission(CONTROL_REMOTE_APP_TRANSITION_ANIMATIONS,\n                \"unregisterRemoteAnimations\");\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInStackLocked(token);\n            if (r == null) {\n                return;\n            }\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                r.unregisterRemoteAnimations();\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public void registerRemoteAnimationForNextActivityStart(String packageName,\n            RemoteAnimationAdapter adapter) {\n        mAmInternal.enforceCallingPermission(CONTROL_REMOTE_APP_TRANSITION_ANIMATIONS,\n                \"registerRemoteAnimationForNextActivityStart\");\n        adapter.setCallingPidUid(Binder.getCallingPid(), Binder.getCallingUid());\n        synchronized (mGlobalLock) {\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                getActivityStartController().registerRemoteAnimationForNextActivityStart(\n                        packageName, adapter);\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public void registerRemoteAnimationsForDisplay(int displayId,\n            RemoteAnimationDefinition definition) {\n        mAmInternal.enforceCallingPermission(CONTROL_REMOTE_APP_TRANSITION_ANIMATIONS,\n                \"registerRemoteAnimations\");\n        definition.setCallingPidUid(Binder.getCallingPid(), Binder.getCallingUid());\n        synchronized (mGlobalLock) {\n            final DisplayContent display = mRootWindowContainer.getDisplayContent(displayId);\n            if (display == null) {\n                Slog.e(TAG, \"Couldn't find display with id: \" + displayId);\n                return;\n            }\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                display.mDisplayContent.registerRemoteAnimations(definition);\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    /** @see android.app.ActivityManager#alwaysShowUnsupportedCompileSdkWarning */\n    @Override\n    public void alwaysShowUnsupportedCompileSdkWarning(ComponentName activity) {\n        synchronized (mGlobalLock) {\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                mAppWarnings.alwaysShowUnsupportedCompileSdkWarning(activity);\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public void setVrThread(int tid) {\n        enforceSystemHasVrFeature();\n        synchronized (mGlobalLock) {\n            final int pid = Binder.getCallingPid();\n            final WindowProcessController wpc = mProcessMap.getProcess(pid);\n            mVrController.setVrThreadLocked(tid, pid, wpc);\n        }\n    }\n\n    @Override\n    public void setPersistentVrThread(int tid) {\n        if (checkCallingPermission(Manifest.permission.RESTRICTED_VR_ACCESS)\n                != PERMISSION_GRANTED) {\n            final String msg = \"Permission Denial: setPersistentVrThread() from pid=\"\n                    + Binder.getCallingPid()\n                    + \", uid=\" + Binder.getCallingUid()\n                    + \" requires \" + Manifest.permission.RESTRICTED_VR_ACCESS;\n            Slog.w(TAG, msg);\n            throw new SecurityException(msg);\n        }\n        enforceSystemHasVrFeature();\n        synchronized (mGlobalLock) {\n            final int pid = Binder.getCallingPid();\n            final WindowProcessController proc = mProcessMap.getProcess(pid);\n            mVrController.setPersistentVrThreadLocked(tid, pid, proc);\n        }\n    }\n\n    @Override\n    public void stopAppSwitches() {\n        enforceCallerIsRecentsOrHasPermission(STOP_APP_SWITCHES, \"stopAppSwitches\");\n        synchronized (mGlobalLock) {\n            mAppSwitchesAllowedTime = SystemClock.uptimeMillis() + APP_SWITCH_DELAY_TIME;\n            mLastStopAppSwitchesTime = SystemClock.uptimeMillis();\n            mDidAppSwitch = false;\n            getActivityStartController().schedulePendingActivityLaunches(APP_SWITCH_DELAY_TIME);\n        }\n    }\n\n    @Override\n    public void resumeAppSwitches() {\n        enforceCallerIsRecentsOrHasPermission(STOP_APP_SWITCHES, \"resumeAppSwitches\");\n        synchronized (mGlobalLock) {\n            // Note that we don't execute any pending app switches... we will\n            // let those wait until either the timeout, or the next start\n            // activity request.\n            mAppSwitchesAllowedTime = 0;\n        }\n    }\n\n    long getLastStopAppSwitchesTime() {\n        return mLastStopAppSwitchesTime;\n    }\n\n    void onStartActivitySetDidAppSwitch() {\n        if (mDidAppSwitch) {\n            // This is the second allowed switch since we stopped switches, so now just generally\n            // allow switches. Use case:\n            // - user presses home (switches disabled, switch to home, mDidAppSwitch now true);\n            // - user taps a home icon (coming from home so allowed, we hit here and now allow\n            // anyone to switch again).\n            mAppSwitchesAllowedTime = 0;\n        } else {\n            mDidAppSwitch = true;\n        }\n    }\n\n    /** @return whether the system should disable UI modes incompatible with VR mode. */\n    boolean shouldDisableNonVrUiLocked() {\n        return mVrController.shouldDisableNonVrUiLocked();\n    }\n\n    private void applyUpdateVrModeLocked(ActivityRecord r) {\n        // VR apps are expected to run in a main display. If an app is turning on VR for\n        // itself, but isn't on the main display, then move it there before enabling VR Mode.\n        if (r.requestedVrComponent != null && r.getDisplayId() != DEFAULT_DISPLAY) {\n            Slog.i(TAG, \"Moving \" + r.shortComponentName + \" from display \" + r.getDisplayId()\n                    + \" to main display for VR\");\n            mRootWindowContainer.moveStackToDisplay(\n                    r.getRootTaskId(), DEFAULT_DISPLAY, true /* toTop */);\n        }\n        mH.post(() -> {\n            if (!mVrController.onVrModeChanged(r)) {\n                return;\n            }\n            synchronized (mGlobalLock) {\n                final boolean disableNonVrUi = mVrController.shouldDisableNonVrUiLocked();\n                mWindowManager.disableNonVrUi(disableNonVrUi);\n                if (disableNonVrUi) {\n                    // If we are in a VR mode where Picture-in-Picture mode is unsupported,\n                    // then remove the pinned stack.\n                    mRootWindowContainer.removeStacksInWindowingModes(WINDOWING_MODE_PINNED);\n                }\n            }\n        });\n    }\n\n    @Override\n    public int getPackageScreenCompatMode(String packageName) {\n        enforceNotIsolatedCaller(\"getPackageScreenCompatMode\");\n        synchronized (mGlobalLock) {\n            return mCompatModePackages.getPackageScreenCompatModeLocked(packageName);\n        }\n    }\n\n    @Override\n    public void setPackageScreenCompatMode(String packageName, int mode) {\n        mAmInternal.enforceCallingPermission(android.Manifest.permission.SET_SCREEN_COMPATIBILITY,\n                \"setPackageScreenCompatMode\");\n        synchronized (mGlobalLock) {\n            mCompatModePackages.setPackageScreenCompatModeLocked(packageName, mode);\n        }\n    }\n\n    @Override\n    public boolean getPackageAskScreenCompat(String packageName) {\n        enforceNotIsolatedCaller(\"getPackageAskScreenCompat\");\n        synchronized (mGlobalLock) {\n            return mCompatModePackages.getPackageAskCompatModeLocked(packageName);\n        }\n    }\n\n    @Override\n    public void setPackageAskScreenCompat(String packageName, boolean ask) {\n        mAmInternal.enforceCallingPermission(android.Manifest.permission.SET_SCREEN_COMPATIBILITY,\n                \"setPackageAskScreenCompat\");\n        synchronized (mGlobalLock) {\n            mCompatModePackages.setPackageAskCompatModeLocked(packageName, ask);\n        }\n    }\n\n    public static String relaunchReasonToString(int relaunchReason) {\n        switch (relaunchReason) {\n            case RELAUNCH_REASON_WINDOWING_MODE_RESIZE:\n                return \"window_resize\";\n            case RELAUNCH_REASON_FREE_RESIZE:\n                return \"free_resize\";\n            default:\n                return null;\n        }\n    }\n\n    ActivityStack getTopDisplayFocusedStack() {\n        return mRootWindowContainer.getTopDisplayFocusedStack();\n    }\n\n    /** Pokes the task persister. */\n    void notifyTaskPersisterLocked(Task task, boolean flush) {\n        mRecentTasks.notifyTaskPersisterLocked(task, flush);\n    }\n\n    boolean isKeyguardLocked() {\n        return mKeyguardController.isKeyguardLocked();\n    }\n\n    /**\n     * Clears launch params for the given package.\n     * @param packageNames the names of the packages of which the launch params are to be cleared\n     */\n    @Override\n    public void clearLaunchParamsForPackages(List<String> packageNames) {\n        mAmInternal.enforceCallingPermission(Manifest.permission.MANAGE_ACTIVITY_STACKS,\n                \"clearLaunchParamsForPackages\");\n        synchronized (mGlobalLock) {\n            for (int i = 0; i < packageNames.size(); ++i) {\n                mStackSupervisor.mLaunchParamsPersister.removeRecordForPackage(packageNames.get(i));\n            }\n        }\n    }\n\n    /**\n     * Makes the display with the given id a single task instance display. I.e the display can only\n     * contain one task.\n     */\n    @Override\n    public void setDisplayToSingleTaskInstance(int displayId) {\n        mAmInternal.enforceCallingPermission(Manifest.permission.MANAGE_ACTIVITY_STACKS,\n                \"setDisplayToSingleTaskInstance\");\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            final DisplayContent display =\n                    mRootWindowContainer.getDisplayContentOrCreate(displayId);\n            if (display != null) {\n                display.setDisplayToSingleTaskInstance();\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    /**\n     * Requests that an activity should enter picture-in-picture mode if possible.\n     */\n    @Override\n    public void requestPictureInPictureMode(IBinder token) throws RemoteException {\n        mAmInternal.enforceCallingPermission(Manifest.permission.MANAGE_ACTIVITY_STACKS,\n                \"requestPictureInPictureMode\");\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ActivityRecord activity = ActivityRecord.forTokenLocked(token);\n                if (activity == null) {\n                    return;\n                }\n\n                if (isInPictureInPictureMode(activity)) {\n                    throw new IllegalStateException(\"Activity is already in PIP mode\");\n                }\n\n                final boolean canEnterPictureInPicture = activity.checkEnterPictureInPictureState(\n                        \"requestPictureInPictureMode\", /* beforeStopping */ false);\n                if (!canEnterPictureInPicture) {\n                    throw new IllegalStateException(\n                            \"Requested PIP on an activity that doesn't support it\");\n                }\n\n                try {\n                    final ClientTransaction transaction = ClientTransaction.obtain(\n                            activity.app.getThread(),\n                            activity.token);\n                    transaction.addCallback(EnterPipRequestedItem.obtain());\n                    getLifecycleManager().scheduleTransaction(transaction);\n                } catch (Exception e) {\n                    Slog.w(TAG, \"Failed to send enter pip requested item: \"\n                            + activity.intent.getComponent(), e);\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    void dumpLastANRLocked(PrintWriter pw) {\n        pw.println(\"ACTIVITY MANAGER LAST ANR (dumpsys activity lastanr)\");\n        if (mLastANRState == null) {\n            pw.println(\"  <no ANR has occurred since boot>\");\n        } else {\n            pw.println(mLastANRState);\n        }\n    }\n\n    void dumpLastANRTracesLocked(PrintWriter pw) {\n        pw.println(\"ACTIVITY MANAGER LAST ANR TRACES (dumpsys activity lastanr-traces)\");\n\n        final File[] files = new File(ANR_TRACE_DIR).listFiles();\n        if (ArrayUtils.isEmpty(files)) {\n            pw.println(\"  <no ANR has occurred since boot>\");\n            return;\n        }\n        // Find the latest file.\n        File latest = null;\n        for (File f : files) {\n            if ((latest == null) || (latest.lastModified() < f.lastModified())) {\n                latest = f;\n            }\n        }\n        pw.print(\"File: \");\n        pw.print(latest.getName());\n        pw.println();\n        try (BufferedReader in = new BufferedReader(new FileReader(latest))) {\n            String line;\n            while ((line = in.readLine()) != null) {\n                pw.println(line);\n            }\n        } catch (IOException e) {\n            pw.print(\"Unable to read: \");\n            pw.print(e);\n            pw.println();\n        }\n    }\n\n    void dumpActivitiesLocked(FileDescriptor fd, PrintWriter pw, String[] args,\n            int opti, boolean dumpAll, boolean dumpClient, String dumpPackage) {\n        dumpActivitiesLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage,\n                \"ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)\");\n    }\n\n    void dumpActivitiesLocked(FileDescriptor fd, PrintWriter pw, String[] args,\n            int opti, boolean dumpAll, boolean dumpClient, String dumpPackage, String header) {\n        pw.println(header);\n\n        boolean printedAnything = mRootWindowContainer.dumpActivities(fd, pw, dumpAll, dumpClient,\n                dumpPackage);\n        boolean needSep = printedAnything;\n\n        boolean printed = ActivityStackSupervisor.printThisActivity(pw,\n                mRootWindowContainer.getTopResumedActivity(),  dumpPackage, needSep,\n                \"  ResumedActivity: \", null);\n        if (printed) {\n            printedAnything = true;\n            needSep = false;\n        }\n\n        if (dumpPackage == null) {\n            if (needSep) {\n                pw.println();\n            }\n            printedAnything = true;\n            mStackSupervisor.dump(pw, \"  \");\n            mTaskOrganizerController.dump(pw, \"  \");\n        }\n\n        if (!printedAnything) {\n            pw.println(\"  (nothing)\");\n        }\n    }\n\n    void dumpActivityContainersLocked(PrintWriter pw) {\n        pw.println(\"ACTIVITY MANAGER CONTAINERS (dumpsys activity containers)\");\n        mRootWindowContainer.dumpChildrenNames(pw, \" \");\n        pw.println(\" \");\n    }\n\n    void dumpActivityStarterLocked(PrintWriter pw, String dumpPackage) {\n        pw.println(\"ACTIVITY MANAGER STARTER (dumpsys activity starter)\");\n        getActivityStartController().dump(pw, \"\", dumpPackage);\n    }\n\n    /**\n     * There are three things that cmd can be:\n     *  - a flattened component name that matches an existing activity\n     *  - the cmd arg isn't the flattened component name of an existing activity:\n     *    dump all activity whose component contains the cmd as a substring\n     *  - A hex number of the ActivityRecord object instance.\n     * <p>\n     * The caller should not hold lock when calling this method because it will wait for the\n     * activities to complete the dump.\n     *\n     *  @param dumpVisibleStacksOnly dump activity with {@param name} only if in a visible stack\n     *  @param dumpFocusedStackOnly dump activity with {@param name} only if in the focused stack\n     */\n    protected boolean dumpActivity(FileDescriptor fd, PrintWriter pw, String name, String[] args,\n            int opti, boolean dumpAll, boolean dumpVisibleStacksOnly, boolean dumpFocusedStackOnly) {\n        ArrayList<ActivityRecord> activities;\n\n        synchronized (mGlobalLock) {\n            activities = mRootWindowContainer.getDumpActivities(name, dumpVisibleStacksOnly,\n                    dumpFocusedStackOnly);\n        }\n\n        if (activities.size() <= 0) {\n            return false;\n        }\n\n        String[] newArgs = new String[args.length - opti];\n        System.arraycopy(args, opti, newArgs, 0, args.length - opti);\n\n        Task lastTask = null;\n        boolean needSep = false;\n        for (int i = activities.size() - 1; i >= 0; i--) {\n            ActivityRecord r = activities.get(i);\n            if (needSep) {\n                pw.println();\n            }\n            needSep = true;\n            synchronized (mGlobalLock) {\n                final Task task = r.getTask();\n                if (lastTask != task) {\n                    lastTask = task;\n                    pw.print(\"TASK \"); pw.print(lastTask.affinity);\n                    pw.print(\" id=\"); pw.print(lastTask.mTaskId);\n                    pw.print(\" userId=\"); pw.println(lastTask.mUserId);\n                    if (dumpAll) {\n                        lastTask.dump(pw, \"  \");\n                    }\n                }\n            }\n            dumpActivity(\"  \", fd, pw, activities.get(i), newArgs, dumpAll);\n        }\n        return true;\n    }\n\n    /**\n     * Invokes IApplicationThread.dumpActivity() on the thread of the specified activity if\n     * there is a thread associated with the activity.\n     */\n    private void dumpActivity(String prefix, FileDescriptor fd, PrintWriter pw,\n            final ActivityRecord r, String[] args, boolean dumpAll) {\n        String innerPrefix = prefix + \"  \";\n        IApplicationThread appThread = null;\n        synchronized (mGlobalLock) {\n            pw.print(prefix); pw.print(\"ACTIVITY \"); pw.print(r.shortComponentName);\n            pw.print(\" \"); pw.print(Integer.toHexString(System.identityHashCode(r)));\n            pw.print(\" pid=\");\n            if (r.hasProcess()) {\n                pw.println(r.app.getPid());\n                appThread = r.app.getThread();\n            } else {\n                pw.println(\"(not running)\");\n            }\n            if (dumpAll) {\n                r.dump(pw, innerPrefix, true /* dumpAll */);\n            }\n        }\n        if (appThread != null) {\n            // flush anything that is already in the PrintWriter since the thread is going\n            // to write to the file descriptor directly\n            pw.flush();\n            try (TransferPipe tp = new TransferPipe()) {\n                appThread.dumpActivity(tp.getWriteFd(), r.appToken, innerPrefix, args);\n                tp.go(fd);\n            } catch (IOException e) {\n                pw.println(innerPrefix + \"Failure while dumping the activity: \" + e);\n            } catch (RemoteException e) {\n                pw.println(innerPrefix + \"Got a RemoteException while dumping the activity\");\n            }\n        }\n    }\n\n    private void writeSleepStateToProto(ProtoOutputStream proto, int wakeFullness,\n            boolean testPssMode) {\n        final long sleepToken = proto.start(ActivityManagerServiceDumpProcessesProto.SLEEP_STATUS);\n        proto.write(ActivityManagerServiceDumpProcessesProto.SleepStatus.WAKEFULNESS,\n                PowerManagerInternal.wakefulnessToProtoEnum(wakeFullness));\n        for (ActivityTaskManagerInternal.SleepToken st : mRootWindowContainer.mSleepTokens) {\n            proto.write(ActivityManagerServiceDumpProcessesProto.SleepStatus.SLEEP_TOKENS,\n                    st.toString());\n        }\n        proto.write(ActivityManagerServiceDumpProcessesProto.SleepStatus.SLEEPING, mSleeping);\n        proto.write(ActivityManagerServiceDumpProcessesProto.SleepStatus.SHUTTING_DOWN,\n                mShuttingDown);\n        proto.write(ActivityManagerServiceDumpProcessesProto.SleepStatus.TEST_PSS_MODE,\n                testPssMode);\n        proto.end(sleepToken);\n    }\n\n    int getCurrentUserId() {\n        return mAmInternal.getCurrentUserId();\n    }\n\n    private void enforceNotIsolatedCaller(String caller) {\n        if (UserHandle.isIsolated(Binder.getCallingUid())) {\n            throw new SecurityException(\"Isolated process not allowed to call \" + caller);\n        }\n    }\n\n    public Configuration getConfiguration() {\n        Configuration ci;\n        synchronized(mGlobalLock) {\n            ci = new Configuration(getGlobalConfigurationForCallingPid());\n            ci.userSetLocale = false;\n        }\n        return ci;\n    }\n\n    /**\n     * Current global configuration information. Contains general settings for the entire system,\n     * also corresponds to the merged configuration of the default display.\n     */\n    Configuration getGlobalConfiguration() {\n        // Return default configuration before mRootWindowContainer initialized, which happens\n        // while initializing process record for system, see {@link\n        // ActivityManagerService#setSystemProcess}.\n        return mRootWindowContainer != null ? mRootWindowContainer.getConfiguration()\n                : new Configuration();\n    }\n\n    boolean updateConfigurationLocked(Configuration values, ActivityRecord starting,\n            boolean initLocale) {\n        return updateConfigurationLocked(values, starting, initLocale, false /* deferResume */);\n    }\n\n    boolean updateConfigurationLocked(Configuration values, ActivityRecord starting,\n            boolean initLocale, boolean deferResume) {\n        // pass UserHandle.USER_NULL as userId because we don't persist configuration for any user\n        return updateConfigurationLocked(values, starting, initLocale, false /* persistent */,\n                UserHandle.USER_NULL, deferResume);\n    }\n\n    public void updatePersistentConfiguration(Configuration values, @UserIdInt int userId) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                updateConfigurationLocked(values, null, false, true, userId,\n                        false /* deferResume */);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    private boolean updateConfigurationLocked(Configuration values, ActivityRecord starting,\n            boolean initLocale, boolean persistent, int userId, boolean deferResume) {\n        return updateConfigurationLocked(values, starting, initLocale, persistent, userId,\n                deferResume, null /* result */);\n    }\n\n    /**\n     * Do either or both things: (1) change the current configuration, and (2)\n     * make sure the given activity is running with the (now) current\n     * configuration.  Returns true if the activity has been left running, or\n     * false if <var>starting</var> is being destroyed to match the new\n     * configuration.\n     *\n     * @param userId is only used when persistent parameter is set to true to persist configuration\n     *               for that particular user\n     */\n    boolean updateConfigurationLocked(Configuration values, ActivityRecord starting,\n            boolean initLocale, boolean persistent, int userId, boolean deferResume,\n            ActivityTaskManagerService.UpdateConfigurationResult result) {\n        int changes = 0;\n        boolean kept = true;\n\n        deferWindowLayout();\n        try {\n            if (values != null) {\n                changes = updateGlobalConfigurationLocked(values, initLocale, persistent, userId,\n                        deferResume);\n            }\n\n            kept = ensureConfigAndVisibilityAfterUpdate(starting, changes);\n        } finally {\n            continueWindowLayout();\n        }\n\n        if (result != null) {\n            result.changes = changes;\n            result.activityRelaunched = !kept;\n        }\n        return kept;\n    }\n\n    /** Update default (global) configuration and notify listeners about changes. */\n    int updateGlobalConfigurationLocked(@NonNull Configuration values, boolean initLocale,\n            boolean persistent, int userId, boolean deferResume) {\n\n        final DisplayContent defaultDisplay =\n                mRootWindowContainer.getDisplayContent(DEFAULT_DISPLAY);\n\n        mTempConfig.setTo(getGlobalConfiguration());\n        final int changes = mTempConfig.updateFrom(values);\n        if (changes == 0) {\n            // Since calling to Activity.setRequestedOrientation leads to freezing the window with\n            // setting WindowManagerService.mWaitingForConfig to true, it is important that we call\n            // performDisplayOverrideConfigUpdate in order to send the new display configuration\n            // (even if there are no actual changes) to unfreeze the window.\n            defaultDisplay.performDisplayOverrideConfigUpdate(values, deferResume);\n            return 0;\n        }\n\n        if (DEBUG_SWITCH || DEBUG_CONFIGURATION) Slog.i(TAG_CONFIGURATION,\n                \"Updating global configuration to: \" + values);\n        writeConfigurationChanged(changes);\n        FrameworkStatsLog.write(FrameworkStatsLog.RESOURCE_CONFIGURATION_CHANGED,\n                values.colorMode,\n                values.densityDpi,\n                values.fontScale,\n                values.hardKeyboardHidden,\n                values.keyboard,\n                values.keyboardHidden,\n                values.mcc,\n                values.mnc,\n                values.navigation,\n                values.navigationHidden,\n                values.orientation,\n                values.screenHeightDp,\n                values.screenLayout,\n                values.screenWidthDp,\n                values.smallestScreenWidthDp,\n                values.touchscreen,\n                values.uiMode);\n\n\n        if (!initLocale && !values.getLocales().isEmpty() && values.userSetLocale) {\n            final LocaleList locales = values.getLocales();\n            int bestLocaleIndex = 0;\n            if (locales.size() > 1) {\n                if (mSupportedSystemLocales == null) {\n                    mSupportedSystemLocales = Resources.getSystem().getAssets().getLocales();\n                }\n                bestLocaleIndex = Math.max(0, locales.getFirstMatchIndex(mSupportedSystemLocales));\n            }\n            SystemProperties.set(\"persist.sys.locale\",\n                    locales.get(bestLocaleIndex).toLanguageTag());\n            LocaleList.setDefault(locales, bestLocaleIndex);\n\n            final Message m = PooledLambda.obtainMessage(\n                    ActivityTaskManagerService::sendLocaleToMountDaemonMsg, this,\n                    locales.get(bestLocaleIndex));\n            mH.sendMessage(m);\n        }\n\n        mTempConfig.seq = increaseConfigurationSeqLocked();\n\n        // Update stored global config and notify everyone about the change.\n        mRootWindowContainer.onConfigurationChanged(mTempConfig);\n\n        Slog.i(TAG, \"Config changes=\" + Integer.toHexString(changes) + \" \" + mTempConfig);\n        // TODO(multi-display): Update UsageEvents#Event to include displayId.\n        mUsageStatsInternal.reportConfigurationChange(mTempConfig, mAmInternal.getCurrentUserId());\n\n        // TODO: If our config changes, should we auto dismiss any currently showing dialogs?\n        updateShouldShowDialogsLocked(mTempConfig);\n\n        AttributeCache ac = AttributeCache.instance();\n        if (ac != null) {\n            ac.updateConfiguration(mTempConfig);\n        }\n\n        // Make sure all resources in our process are updated right now, so that anyone who is going\n        // to retrieve resource values after we return will be sure to get the new ones. This is\n        // especially important during boot, where the first config change needs to guarantee all\n        // resources have that config before following boot code is executed.\n        mSystemThread.applyConfigurationToResources(mTempConfig);\n\n        // We need another copy of global config because we're scheduling some calls instead of\n        // running them in place. We need to be sure that object we send will be handled unchanged.\n        final Configuration configCopy = new Configuration(mTempConfig);\n        if (persistent && Settings.System.hasInterestingConfigurationChanges(changes)) {\n            final Message msg = PooledLambda.obtainMessage(\n                    ActivityTaskManagerService::sendPutConfigurationForUserMsg,\n                    this, userId, configCopy);\n            mH.sendMessage(msg);\n        }\n\n        SparseArray<WindowProcessController> pidMap = mProcessMap.getPidMap();\n        for (int i = pidMap.size() - 1; i >= 0; i--) {\n            final int pid = pidMap.keyAt(i);\n            final WindowProcessController app = pidMap.get(pid);\n            if (DEBUG_CONFIGURATION) {\n                Slog.v(TAG_CONFIGURATION, \"Update process config of \"\n                        + app.mName + \" to new config \" + configCopy);\n            }\n            app.onConfigurationChanged(configCopy);\n        }\n\n        final Message msg = PooledLambda.obtainMessage(\n                ActivityManagerInternal::broadcastGlobalConfigurationChanged,\n                mAmInternal, changes, initLocale);\n        mH.sendMessage(msg);\n\n        // Override configuration of the default display duplicates global config, so we need to\n        // update it also. This will also notify WindowManager about changes.\n        defaultDisplay.performDisplayOverrideConfigUpdate(mRootWindowContainer.getConfiguration(),\n                deferResume);\n\n        return changes;\n    }\n\n    /** @see WindowSurfacePlacer#deferLayout */\n    void deferWindowLayout() {\n        if (!mWindowManager.mWindowPlacerLocked.isLayoutDeferred()) {\n            // Reset the reasons at the first entrance because we only care about the changes in the\n            // deferred scope.\n            mLayoutReasons = 0;\n        }\n\n        mWindowManager.mWindowPlacerLocked.deferLayout();\n    }\n\n    /** @see WindowSurfacePlacer#continueLayout */\n    void continueWindowLayout() {\n        mWindowManager.mWindowPlacerLocked.continueLayout(mLayoutReasons != 0);\n        if (DEBUG_ALL && !mWindowManager.mWindowPlacerLocked.isLayoutDeferred()) {\n            Slog.i(TAG, \"continueWindowLayout reason=\" + mLayoutReasons);\n        }\n    }\n\n    /**\n     * If a reason is added between {@link #deferWindowLayout} and {@link #continueWindowLayout},\n     * it will make sure {@link WindowSurfacePlacer#performSurfacePlacement} is called when the last\n     * defer count is gone.\n     */\n    void addWindowLayoutReasons(@LayoutReason int reasons) {\n        mLayoutReasons |= reasons;\n    }\n\n    private void updateEventDispatchingLocked(boolean booted) {\n        mWindowManager.setEventDispatching(booted && !mShuttingDown);\n    }\n\n    private void sendPutConfigurationForUserMsg(int userId, Configuration config) {\n        final ContentResolver resolver = mContext.getContentResolver();\n        Settings.System.putConfigurationForUser(resolver, config, userId);\n    }\n\n    private void sendLocaleToMountDaemonMsg(Locale l) {\n        try {\n            IBinder service = ServiceManager.getService(\"mount\");\n            IStorageManager storageManager = IStorageManager.Stub.asInterface(service);\n            Log.d(TAG, \"Storing locale \" + l.toLanguageTag() + \" for decryption UI\");\n            storageManager.setField(StorageManager.SYSTEM_LOCALE_KEY, l.toLanguageTag());\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Error storing locale for decryption UI\", e);\n        }\n    }\n\n    private void expireStartAsCallerTokenMsg(IBinder permissionToken) {\n        mStartActivitySources.remove(permissionToken);\n        mExpiredStartAsCallerTokens.add(permissionToken);\n    }\n\n    private void forgetStartAsCallerTokenMsg(IBinder permissionToken) {\n        mExpiredStartAsCallerTokens.remove(permissionToken);\n    }\n\n    boolean isActivityStartsLoggingEnabled() {\n        return mAmInternal.isActivityStartsLoggingEnabled();\n    }\n\n    boolean isBackgroundActivityStartsEnabled() {\n        return mAmInternal.isBackgroundActivityStartsEnabled();\n    }\n\n    void enableScreenAfterBoot(boolean booted) {\n        writeBootProgressEnableScreen(SystemClock.uptimeMillis());\n        mWindowManager.enableScreenAfterBoot();\n\n        synchronized (mGlobalLock) {\n            updateEventDispatchingLocked(booted);\n        }\n    }\n\n    static long getInputDispatchingTimeoutLocked(ActivityRecord r) {\n        if (r == null || !r.hasProcess()) {\n            return KEY_DISPATCHING_TIMEOUT_MS;\n        }\n        return getInputDispatchingTimeoutLocked(r.app);\n    }\n\n    private static long getInputDispatchingTimeoutLocked(WindowProcessController r) {\n        return r != null ? r.getInputDispatchingTimeout() : KEY_DISPATCHING_TIMEOUT_MS;\n    }\n\n    /**\n     * Decide based on the configuration whether we should show the ANR,\n     * crash, etc dialogs.  The idea is that if there is no affordance to\n     * press the on-screen buttons, or the user experience would be more\n     * greatly impacted than the crash itself, we shouldn't show the dialog.\n     *\n     * A thought: SystemUI might also want to get told about this, the Power\n     * dialog / global actions also might want different behaviors.\n     */\n    private void updateShouldShowDialogsLocked(Configuration config) {\n        final boolean inputMethodExists = !(config.keyboard == Configuration.KEYBOARD_NOKEYS\n                && config.touchscreen == Configuration.TOUCHSCREEN_NOTOUCH\n                && config.navigation == Configuration.NAVIGATION_NONAV);\n        final boolean hideDialogsSet = Settings.Global.getInt(mContext.getContentResolver(),\n                HIDE_ERROR_DIALOGS, 0) != 0;\n        mShowDialogs = inputMethodExists\n                && ActivityTaskManager.currentUiModeSupportsErrorDialogs(config)\n                && !hideDialogsSet;\n    }\n\n    private void updateFontScaleIfNeeded(@UserIdInt int userId) {\n        final float scaleFactor = Settings.System.getFloatForUser(mContext.getContentResolver(),\n                FONT_SCALE, 1.0f, userId);\n\n        synchronized (mGlobalLock) {\n            if (getGlobalConfiguration().fontScale == scaleFactor) {\n                return;\n            }\n\n            final Configuration configuration\n                    = mWindowManager.computeNewConfiguration(DEFAULT_DISPLAY);\n            configuration.fontScale = scaleFactor;\n            updatePersistentConfiguration(configuration, userId);\n        }\n    }\n\n    // Actually is sleeping or shutting down or whatever else in the future\n    // is an inactive state.\n    boolean isSleepingOrShuttingDownLocked() {\n        return isSleepingLocked() || mShuttingDown;\n    }\n\n    boolean isSleepingLocked() {\n        return mSleeping;\n    }\n\n    /** Update AMS states when an activity is resumed. */\n    void setResumedActivityUncheckLocked(ActivityRecord r, String reason) {\n        final Task task = r.getTask();\n        if (task.isActivityTypeStandard()) {\n            if (mCurAppTimeTracker != r.appTimeTracker) {\n                // We are switching app tracking.  Complete the current one.\n                if (mCurAppTimeTracker != null) {\n                    mCurAppTimeTracker.stop();\n                    mH.obtainMessage(\n                            REPORT_TIME_TRACKER_MSG, mCurAppTimeTracker).sendToTarget();\n                    mRootWindowContainer.clearOtherAppTimeTrackers(r.appTimeTracker);\n                    mCurAppTimeTracker = null;\n                }\n                if (r.appTimeTracker != null) {\n                    mCurAppTimeTracker = r.appTimeTracker;\n                    startTimeTrackingFocusedActivityLocked();\n                }\n            } else {\n                startTimeTrackingFocusedActivityLocked();\n            }\n        } else {\n            r.appTimeTracker = null;\n        }\n        // TODO: VI Maybe r.task.voiceInteractor || r.voiceInteractor != null\n        // TODO: Probably not, because we don't want to resume voice on switching\n        // back to this activity\n        if (task.voiceInteractor != null) {\n            startRunningVoiceLocked(task.voiceSession, r.info.applicationInfo.uid);\n        } else {\n            finishRunningVoiceLocked();\n\n            if (mLastResumedActivity != null) {\n                final IVoiceInteractionSession session;\n\n                final Task lastResumedActivityTask = mLastResumedActivity.getTask();\n                if (lastResumedActivityTask != null\n                        && lastResumedActivityTask.voiceSession != null) {\n                    session = lastResumedActivityTask.voiceSession;\n                } else {\n                    session = mLastResumedActivity.voiceSession;\n                }\n\n                if (session != null) {\n                    // We had been in a voice interaction session, but now focused has\n                    // move to something different.  Just finish the session, we can't\n                    // return to it and retain the proper state and synchronization with\n                    // the voice interaction service.\n                    finishVoiceTask(session);\n                }\n            }\n        }\n\n        if (mLastResumedActivity != null && r.mUserId != mLastResumedActivity.mUserId) {\n            mAmInternal.sendForegroundProfileChanged(r.mUserId);\n        }\n        final Task prevTask = mLastResumedActivity != null ? mLastResumedActivity.getTask() : null;\n\n        updateResumedAppTrace(r);\n        mLastResumedActivity = r;\n\n        r.getDisplay().setFocusedApp(r, true);\n\n        if (prevTask == null || task != prevTask) {\n            if (prevTask != null) {\n                mTaskChangeNotificationController.notifyTaskFocusChanged(prevTask.mTaskId, false);\n            }\n            mTaskChangeNotificationController.notifyTaskFocusChanged(task.mTaskId, true);\n        }\n\n        applyUpdateLockStateLocked(r);\n        applyUpdateVrModeLocked(r);\n\n        EventLogTags.writeWmSetResumedActivity(\n                r == null ? -1 : r.mUserId,\n                r == null ? \"NULL\" : r.shortComponentName,\n                reason);\n    }\n\n    ActivityTaskManagerInternal.SleepToken acquireSleepToken(String tag, int displayId) {\n        synchronized (mGlobalLock) {\n            final ActivityTaskManagerInternal.SleepToken token =\n                    mRootWindowContainer.createSleepToken(tag, displayId);\n            updateSleepIfNeededLocked();\n            return token;\n        }\n    }\n\n    void updateSleepIfNeededLocked() {\n        final boolean shouldSleep = !mRootWindowContainer.hasAwakeDisplay();\n        final boolean wasSleeping = mSleeping;\n        boolean updateOomAdj = false;\n\n        if (!shouldSleep) {\n            // If wasSleeping is true, we need to wake up activity manager state from when\n            // we started sleeping. In either case, we need to apply the sleep tokens, which\n            // will wake up stacks or put them to sleep as appropriate.\n            if (wasSleeping) {\n                mSleeping = false;\n                FrameworkStatsLog.write(FrameworkStatsLog.ACTIVITY_MANAGER_SLEEP_STATE_CHANGED,\n                        FrameworkStatsLog.ACTIVITY_MANAGER_SLEEP_STATE_CHANGED__STATE__AWAKE);\n                startTimeTrackingFocusedActivityLocked();\n                mTopProcessState = ActivityManager.PROCESS_STATE_TOP;\n                Slog.d(TAG, \"Top Process State changed to PROCESS_STATE_TOP\");\n                mStackSupervisor.comeOutOfSleepIfNeededLocked();\n            }\n            mRootWindowContainer.applySleepTokens(true /* applyToStacks */);\n            if (wasSleeping) {\n                updateOomAdj = true;\n            }\n        } else if (!mSleeping && shouldSleep) {\n            mSleeping = true;\n            FrameworkStatsLog.write(FrameworkStatsLog.ACTIVITY_MANAGER_SLEEP_STATE_CHANGED,\n                    FrameworkStatsLog.ACTIVITY_MANAGER_SLEEP_STATE_CHANGED__STATE__ASLEEP);\n            if (mCurAppTimeTracker != null) {\n                mCurAppTimeTracker.stop();\n            }\n            mTopProcessState = ActivityManager.PROCESS_STATE_TOP_SLEEPING;\n            Slog.d(TAG, \"Top Process State changed to PROCESS_STATE_TOP_SLEEPING\");\n            mStackSupervisor.goingToSleepLocked();\n            updateResumedAppTrace(null /* resumed */);\n            updateOomAdj = true;\n        }\n        if (updateOomAdj) {\n            updateOomAdj();\n        }\n    }\n\n    void updateOomAdj() {\n        mH.removeCallbacks(mUpdateOomAdjRunnable);\n        mH.post(mUpdateOomAdjRunnable);\n    }\n\n    void updateCpuStats() {\n        mH.post(mAmInternal::updateCpuStats);\n    }\n\n    void updateBatteryStats(ActivityRecord component, boolean resumed) {\n        final Message m = PooledLambda.obtainMessage(ActivityManagerInternal::updateBatteryStats,\n                mAmInternal, component.mActivityComponent, component.app.mUid, component.mUserId,\n                resumed);\n        mH.sendMessage(m);\n    }\n\n    void updateActivityUsageStats(ActivityRecord activity, int event) {\n        ComponentName taskRoot = null;\n        final Task task = activity.getTask();\n        if (task != null) {\n            final ActivityRecord rootActivity = task.getRootActivity();\n            if (rootActivity != null) {\n                taskRoot = rootActivity.mActivityComponent;\n            }\n        }\n\n        final Message m = PooledLambda.obtainMessage(\n                ActivityManagerInternal::updateActivityUsageStats, mAmInternal,\n                activity.mActivityComponent, activity.mUserId, event, activity.appToken, taskRoot);\n        mH.sendMessage(m);\n    }\n\n    void startProcessAsync(ActivityRecord activity, boolean knownToBeDead, boolean isTop,\n            String hostingType) {\n        try {\n            if (Trace.isTagEnabled(TRACE_TAG_WINDOW_MANAGER)) {\n                Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, \"dispatchingStartProcess:\"\n                        + activity.processName);\n            }\n            // Post message to start process to avoid possible deadlock of calling into AMS with the\n            // ATMS lock held.\n            final Message m = PooledLambda.obtainMessage(ActivityManagerInternal::startProcess,\n                    mAmInternal, activity.processName, activity.info.applicationInfo, knownToBeDead,\n                    isTop, hostingType, activity.intent.getComponent());\n            mH.sendMessage(m);\n        } finally {\n            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);\n        }\n    }\n\n    void setBooting(boolean booting) {\n        mAmInternal.setBooting(booting);\n    }\n\n    boolean isBooting() {\n        return mAmInternal.isBooting();\n    }\n\n    void setBooted(boolean booted) {\n        mAmInternal.setBooted(booted);\n    }\n\n    boolean isBooted() {\n        return mAmInternal.isBooted();\n    }\n\n    void postFinishBooting(boolean finishBooting, boolean enableScreen) {\n        mH.post(() -> {\n            if (finishBooting) {\n                mAmInternal.finishBooting();\n            }\n            if (enableScreen) {\n                mInternal.enableScreenAfterBoot(isBooted());\n            }\n        });\n    }\n\n    void setHeavyWeightProcess(ActivityRecord root) {\n        mHeavyWeightProcess = root.app;\n        final Message m = PooledLambda.obtainMessage(\n                ActivityTaskManagerService::postHeavyWeightProcessNotification, this,\n                root.app, root.intent, root.mUserId);\n        mH.sendMessage(m);\n    }\n\n    void clearHeavyWeightProcessIfEquals(WindowProcessController proc) {\n        if (mHeavyWeightProcess == null || mHeavyWeightProcess != proc) {\n            return;\n        }\n\n        mHeavyWeightProcess = null;\n        final Message m = PooledLambda.obtainMessage(\n                ActivityTaskManagerService::cancelHeavyWeightProcessNotification, this,\n                proc.mUserId);\n        mH.sendMessage(m);\n    }\n\n    private void cancelHeavyWeightProcessNotification(int userId) {\n        final INotificationManager inm = NotificationManager.getService();\n        if (inm == null) {\n            return;\n        }\n        try {\n            inm.cancelNotificationWithTag(\"android\", \"android\", null,\n                    SystemMessage.NOTE_HEAVY_WEIGHT_NOTIFICATION, userId);\n        } catch (RuntimeException e) {\n            Slog.w(TAG, \"Error canceling notification for service\", e);\n        } catch (RemoteException e) {\n        }\n\n    }\n\n    private void postHeavyWeightProcessNotification(\n            WindowProcessController proc, Intent intent, int userId) {\n        if (proc == null) {\n            return;\n        }\n\n        final INotificationManager inm = NotificationManager.getService();\n        if (inm == null) {\n            return;\n        }\n\n        try {\n            Context context = mContext.createPackageContext(proc.mInfo.packageName, 0);\n            String text = mContext.getString(R.string.heavy_weight_notification,\n                    context.getApplicationInfo().loadLabel(context.getPackageManager()));\n            Notification notification =\n                    new Notification.Builder(context,\n                            SystemNotificationChannels.HEAVY_WEIGHT_APP)\n                            .setSmallIcon(com.android.internal.R.drawable.stat_sys_adb)\n                            .setWhen(0)\n                            .setOngoing(true)\n                            .setTicker(text)\n                            .setColor(mContext.getColor(\n                                    com.android.internal.R.color.system_notification_accent_color))\n                            .setContentTitle(text)\n                            .setContentText(\n                                    mContext.getText(R.string.heavy_weight_notification_detail))\n                            .setContentIntent(PendingIntent.getActivityAsUser(mContext, 0,\n                                    intent, PendingIntent.FLAG_CANCEL_CURRENT, null,\n                                    new UserHandle(userId)))\n                            .build();\n            try {\n                inm.enqueueNotificationWithTag(\"android\", \"android\", null,\n                        SystemMessage.NOTE_HEAVY_WEIGHT_NOTIFICATION, notification, userId);\n            } catch (RuntimeException e) {\n                Slog.w(TAG, \"Error showing notification for heavy-weight app\", e);\n            } catch (RemoteException e) {\n            }\n        } catch (PackageManager.NameNotFoundException e) {\n            Slog.w(TAG, \"Unable to create context for heavy notification\", e);\n        }\n\n    }\n\n    IIntentSender getIntentSenderLocked(int type, String packageName, String featureId,\n            int callingUid, int userId, IBinder token, String resultWho, int requestCode,\n            Intent[] intents, String[] resolvedTypes, int flags, Bundle bOptions) {\n\n        ActivityRecord activity = null;\n        if (type == ActivityManager.INTENT_SENDER_ACTIVITY_RESULT) {\n            activity = ActivityRecord.isInStackLocked(token);\n            if (activity == null) {\n                Slog.w(TAG, \"Failed createPendingResult: activity \" + token + \" not in any stack\");\n                return null;\n            }\n            if (activity.finishing) {\n                Slog.w(TAG, \"Failed createPendingResult: activity \" + activity + \" is finishing\");\n                return null;\n            }\n        }\n\n        final PendingIntentRecord rec = mPendingIntentController.getIntentSender(type, packageName,\n                featureId, callingUid, userId, token, resultWho, requestCode, intents,\n                resolvedTypes, flags, bOptions);\n        final boolean noCreate = (flags & PendingIntent.FLAG_NO_CREATE) != 0;\n        if (noCreate) {\n            return rec;\n        }\n        if (type == ActivityManager.INTENT_SENDER_ACTIVITY_RESULT) {\n            if (activity.pendingResults == null) {\n                activity.pendingResults = new HashSet<>();\n            }\n            activity.pendingResults.add(rec.ref);\n        }\n        return rec;\n    }\n\n    // TODO(b/111541062): Update app time tracking to make it aware of multiple resumed activities\n    private void startTimeTrackingFocusedActivityLocked() {\n        final ActivityRecord resumedActivity = mRootWindowContainer.getTopResumedActivity();\n        if (!mSleeping && mCurAppTimeTracker != null && resumedActivity != null) {\n            mCurAppTimeTracker.start(resumedActivity.packageName);\n        }\n    }\n\n    private void updateResumedAppTrace(@Nullable ActivityRecord resumed) {\n        if (mTracedResumedActivity != null) {\n            Trace.asyncTraceEnd(TRACE_TAG_WINDOW_MANAGER,\n                    constructResumedTraceName(mTracedResumedActivity.packageName), 0);\n        }\n        if (resumed != null) {\n            Trace.asyncTraceBegin(TRACE_TAG_WINDOW_MANAGER,\n                    constructResumedTraceName(resumed.packageName), 0);\n        }\n        mTracedResumedActivity = resumed;\n    }\n\n    private String constructResumedTraceName(String packageName) {\n        return \"focused app: \" + packageName;\n    }\n\n    /** Applies latest configuration and/or visibility updates if needed. */\n    boolean ensureConfigAndVisibilityAfterUpdate(ActivityRecord starting, int changes) {\n        boolean kept = true;\n        final ActivityStack mainStack = mRootWindowContainer.getTopDisplayFocusedStack();\n        // mainStack is null during startup.\n        if (mainStack != null) {\n            if (changes != 0 && starting == null) {\n                // If the configuration changed, and the caller is not already\n                // in the process of starting an activity, then find the top\n                // activity to check if its configuration needs to change.\n                starting = mainStack.topRunningActivity();\n            }\n\n            if (starting != null) {\n                kept = starting.ensureActivityConfiguration(changes,\n                        false /* preserveWindow */);\n                // And we need to make sure at this point that all other activities\n                // are made visible with the correct configuration.\n                mRootWindowContainer.ensureActivitiesVisible(starting, changes,\n                        !PRESERVE_WINDOWS);\n            }\n        }\n\n        return kept;\n    }\n\n    void scheduleAppGcsLocked() {\n        mH.post(() -> mAmInternal.scheduleAppGcs());\n    }\n\n    CompatibilityInfo compatibilityInfoForPackageLocked(ApplicationInfo ai) {\n        return mCompatModePackages.compatibilityInfoForPackageLocked(ai);\n    }\n\n    /**\n     * Returns the PackageManager. Used by classes hosted by {@link ActivityTaskManagerService}. The\n     * PackageManager could be unavailable at construction time and therefore needs to be accessed\n     * on demand.\n     */\n    IPackageManager getPackageManager() {\n        return AppGlobals.getPackageManager();\n    }\n\n    PackageManagerInternal getPackageManagerInternalLocked() {\n        if (mPmInternal == null) {\n            mPmInternal = LocalServices.getService(PackageManagerInternal.class);\n        }\n        return mPmInternal;\n    }\n\n    ComponentName getSysUiServiceComponentLocked() {\n        if (mSysUiServiceComponent == null) {\n            final PackageManagerInternal pm = getPackageManagerInternalLocked();\n            mSysUiServiceComponent = pm.getSystemUiServiceComponent();\n        }\n        return mSysUiServiceComponent;\n    }\n\n    PermissionPolicyInternal getPermissionPolicyInternal() {\n        if (mPermissionPolicyInternal == null) {\n            mPermissionPolicyInternal = LocalServices.getService(PermissionPolicyInternal.class);\n        }\n        return mPermissionPolicyInternal;\n    }\n\n    AppWarnings getAppWarningsLocked() {\n        return mAppWarnings;\n    }\n\n    Intent getHomeIntent() {\n        Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null);\n        intent.setComponent(mTopComponent);\n        intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING);\n        if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) {\n            intent.addCategory(Intent.CATEGORY_HOME);\n        }\n        return intent;\n    }\n\n    /**\n     * Return the intent set with {@link Intent#CATEGORY_SECONDARY_HOME} to resolve secondary home\n     * activities.\n     *\n     * @param preferredPackage Specify a preferred package name, otherwise use the package name\n     *                         defined in config_secondaryHomePackage.\n     * @return the intent set with {@link Intent#CATEGORY_SECONDARY_HOME}\n     */\n    Intent getSecondaryHomeIntent(String preferredPackage) {\n        final Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null);\n        final boolean useSystemProvidedLauncher = mContext.getResources().getBoolean(\n                com.android.internal.R.bool.config_useSystemProvidedLauncherForSecondary);\n        if (preferredPackage == null || useSystemProvidedLauncher) {\n            // Using the package name stored in config if no preferred package name or forced.\n            final String secondaryHomePackage = mContext.getResources().getString(\n                    com.android.internal.R.string.config_secondaryHomePackage);\n            intent.setPackage(secondaryHomePackage);\n        } else {\n            intent.setPackage(preferredPackage);\n        }\n        intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING);\n        if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) {\n            intent.addCategory(Intent.CATEGORY_SECONDARY_HOME);\n        }\n        return intent;\n    }\n\n    ApplicationInfo getAppInfoForUser(ApplicationInfo info, int userId) {\n        if (info == null) return null;\n        ApplicationInfo newInfo = new ApplicationInfo(info);\n        newInfo.initForUser(userId);\n        return newInfo;\n    }\n\n    WindowProcessController getProcessController(String processName, int uid) {\n        if (uid == SYSTEM_UID) {\n            // The system gets to run in any process. If there are multiple processes with the same\n            // uid, just pick the first (this should never happen).\n            final SparseArray<WindowProcessController> procs =\n                    mProcessNames.getMap().get(processName);\n            if (procs == null) return null;\n            final int procCount = procs.size();\n            for (int i = 0; i < procCount; i++) {\n                final int procUid = procs.keyAt(i);\n                if (UserHandle.isApp(procUid) || !UserHandle.isSameUser(procUid, uid)) {\n                    // Don't use an app process or different user process for system component.\n                    continue;\n                }\n                return procs.valueAt(i);\n            }\n        }\n\n        return mProcessNames.get(processName, uid);\n    }\n\n    WindowProcessController getProcessController(IApplicationThread thread) {\n        if (thread == null) {\n            return null;\n        }\n\n        final IBinder threadBinder = thread.asBinder();\n        final ArrayMap<String, SparseArray<WindowProcessController>> pmap = mProcessNames.getMap();\n        for (int i = pmap.size()-1; i >= 0; i--) {\n            final SparseArray<WindowProcessController> procs = pmap.valueAt(i);\n            for (int j = procs.size() - 1; j >= 0; j--) {\n                final WindowProcessController proc = procs.valueAt(j);\n                if (proc.hasThread() && proc.getThread().asBinder() == threadBinder) {\n                    return proc;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    WindowProcessController getProcessController(int pid, int uid) {\n        final WindowProcessController proc = mProcessMap.getProcess(pid);\n        if (proc == null) return null;\n        if (UserHandle.isApp(uid) && proc.mUid == uid) {\n            return proc;\n        }\n        return null;\n    }\n\n    int getUidState(int uid) {\n        return mActiveUids.getUidState(uid);\n    }\n\n    boolean isUidForeground(int uid) {\n        // A uid is considered to be foreground if it has a visible non-toast window.\n        return mWindowManager.mRoot.isAnyNonToastWindowVisibleForUid(uid);\n    }\n\n    boolean isDeviceOwner(int uid) {\n        return uid >= 0 && mDeviceOwnerUid == uid;\n    }\n\n    void setDeviceOwnerUid(int uid) {\n        mDeviceOwnerUid = uid;\n    }\n\n    /**\n     * @return whitelist tag for a uid from mPendingTempWhitelist, null if not currently on\n     * the whitelist\n     */\n    String getPendingTempWhitelistTagForUidLocked(int uid) {\n        return mPendingTempWhitelist.get(uid);\n    }\n\n    void logAppTooSlow(WindowProcessController app, long startTime, String msg) {\n        if (true || Build.IS_USER) {\n            return;\n        }\n\n        StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();\n        StrictMode.allowThreadDiskWrites();\n        try {\n            File tracesDir = new File(\"/data/anr\");\n            File tracesFile = null;\n            try {\n                tracesFile = File.createTempFile(\"app_slow\", null, tracesDir);\n\n                StringBuilder sb = new StringBuilder();\n                String timeString =\n                        TimeMigrationUtils.formatMillisWithFixedFormat(System.currentTimeMillis());\n                sb.append(timeString);\n                sb.append(\": \");\n                TimeUtils.formatDuration(SystemClock.uptimeMillis()-startTime, sb);\n                sb.append(\" since \");\n                sb.append(msg);\n                FileOutputStream fos = new FileOutputStream(tracesFile);\n                fos.write(sb.toString().getBytes());\n                if (app == null) {\n                    fos.write(\"\\n*** No application process!\".getBytes());\n                }\n                fos.close();\n                FileUtils.setPermissions(tracesFile.getPath(), 0666, -1, -1); // -rw-rw-rw-\n            } catch (IOException e) {\n                Slog.w(TAG, \"Unable to prepare slow app traces file: \" + tracesFile, e);\n                return;\n            }\n\n            if (app != null && app.getPid() > 0) {\n                ArrayList<Integer> firstPids = new ArrayList<Integer>();\n                firstPids.add(app.getPid());\n                dumpStackTraces(tracesFile.getAbsolutePath(), firstPids, null, null);\n            }\n\n            File lastTracesFile = null;\n            File curTracesFile = null;\n            for (int i=9; i>=0; i--) {\n                String name = String.format(Locale.US, \"slow%02d.txt\", i);\n                curTracesFile = new File(tracesDir, name);\n                if (curTracesFile.exists()) {\n                    if (lastTracesFile != null) {\n                        curTracesFile.renameTo(lastTracesFile);\n                    } else {\n                        curTracesFile.delete();\n                    }\n                }\n                lastTracesFile = curTracesFile;\n            }\n            tracesFile.renameTo(curTracesFile);\n        } finally {\n            StrictMode.setThreadPolicy(oldPolicy);\n        }\n    }\n\n    boolean isAssociatedCompanionApp(int userId, int uid) {\n        final Set<Integer> allUids = mCompanionAppUidsMap.get(userId);\n        if (allUids == null) {\n            return false;\n        }\n        return allUids.contains(uid);\n    }\n\n    void notifySingleTaskDisplayEmpty(int displayId) {\n        mTaskChangeNotificationController.notifySingleTaskDisplayEmpty(displayId);\n    }\n\n    final class H extends Handler {\n        static final int REPORT_TIME_TRACKER_MSG = 1;\n\n\n        static final int FIRST_ACTIVITY_STACK_MSG = 100;\n        static final int FIRST_SUPERVISOR_STACK_MSG = 200;\n\n        H(Looper looper) {\n            super(looper);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case REPORT_TIME_TRACKER_MSG: {\n                    AppTimeTracker tracker = (AppTimeTracker) msg.obj;\n                    tracker.deliverResult(mContext);\n                } break;\n            }\n        }\n    }\n\n    final class UiHandler extends Handler {\n        static final int DISMISS_DIALOG_UI_MSG = 1;\n\n        public UiHandler() {\n            super(UiThread.get().getLooper(), null, true);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case DISMISS_DIALOG_UI_MSG: {\n                    final Dialog d = (Dialog) msg.obj;\n                    d.dismiss();\n                    break;\n                }\n            }\n        }\n    }\n\n    final class LocalService extends ActivityTaskManagerInternal {\n        @Override\n        public SleepToken acquireSleepToken(String tag, int displayId) {\n            Objects.requireNonNull(tag);\n            return ActivityTaskManagerService.this.acquireSleepToken(tag, displayId);\n        }\n\n        @Override\n        public ComponentName getHomeActivityForUser(int userId) {\n            synchronized (mGlobalLock) {\n                final ActivityRecord homeActivity =\n                        mRootWindowContainer.getDefaultDisplayHomeActivityForUser(userId);\n                return homeActivity == null ? null : homeActivity.mActivityComponent;\n            }\n        }\n\n        @Override\n        public void onLocalVoiceInteractionStarted(IBinder activity,\n                IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor) {\n            synchronized (mGlobalLock) {\n                onLocalVoiceInteractionStartedLocked(activity, voiceSession, voiceInteractor);\n            }\n        }\n\n        @Override\n        public void notifySingleTaskDisplayDrawn(int displayId) {\n            mTaskChangeNotificationController.notifySingleTaskDisplayDrawn(displayId);\n        }\n\n        @Override\n        public List<IBinder> getTopVisibleActivities() {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.getTopVisibleActivities();\n            }\n        }\n\n        @Override\n        public boolean hasResumedActivity(int uid) {\n            synchronized (mGlobalLock) {\n                final ArraySet<WindowProcessController> processes = mProcessMap.getProcesses(uid);\n                for (int i = 0, n = processes.size(); i < n; i++) {\n                    final WindowProcessController process = processes.valueAt(i);\n                    if (process.hasResumedActivity()) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public int startActivitiesAsPackage(String packageName, @Nullable String featureId,\n                int userId, Intent[] intents, Bundle bOptions) {\n            Objects.requireNonNull(intents, \"intents\");\n            final String[] resolvedTypes = new String[intents.length];\n\n            // UID of the package on user userId.\n            // \"= 0\" is needed because otherwise catch(RemoteException) would make it look like\n            // packageUid may not be initialized.\n            int packageUid = 0;\n            final long ident = Binder.clearCallingIdentity();\n\n            try {\n                for (int i = 0; i < intents.length; i++) {\n                    resolvedTypes[i] =\n                            intents[i].resolveTypeIfNeeded(mContext.getContentResolver());\n                }\n\n                packageUid = AppGlobals.getPackageManager().getPackageUid(\n                        packageName, PackageManager.MATCH_DEBUG_TRIAGED_MISSING, userId);\n            } catch (RemoteException e) {\n                // Shouldn't happen.\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n\n            return getActivityStartController().startActivitiesInPackage(\n                    packageUid, packageName, featureId,\n                    intents, resolvedTypes, null /* resultTo */,\n                    SafeActivityOptions.fromBundle(bOptions), userId,\n                    false /* validateIncomingUser */, null /* originatingPendingIntent */,\n                    false /* allowBackgroundActivityStart */);\n        }\n\n        @Override\n        public int startActivitiesInPackage(int uid, int realCallingPid, int realCallingUid,\n                String callingPackage, @Nullable String callingFeatureId, Intent[] intents,\n                String[] resolvedTypes, IBinder resultTo, SafeActivityOptions options, int userId,\n                boolean validateIncomingUser, PendingIntentRecord originatingPendingIntent,\n                boolean allowBackgroundActivityStart) {\n            assertPackageMatchesCallingUid(callingPackage);\n            return getActivityStartController().startActivitiesInPackage(uid, realCallingPid,\n                    realCallingUid, callingPackage, callingFeatureId, intents, resolvedTypes,\n                    resultTo, options, userId, validateIncomingUser, originatingPendingIntent,\n                    allowBackgroundActivityStart);\n        }\n\n        @Override\n        public int startActivityInPackage(int uid, int realCallingPid, int realCallingUid,\n                String callingPackage, @Nullable String callingFeatureId, Intent intent,\n                String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n                int startFlags, SafeActivityOptions options, int userId, Task inTask, String reason,\n                boolean validateIncomingUser, PendingIntentRecord originatingPendingIntent,\n                boolean allowBackgroundActivityStart) {\n            assertPackageMatchesCallingUid(callingPackage);\n            return getActivityStartController().startActivityInPackage(uid, realCallingPid,\n                    realCallingUid, callingPackage, callingFeatureId, intent, resolvedType,\n                    resultTo, resultWho, requestCode, startFlags, options, userId, inTask,\n                    reason, validateIncomingUser, originatingPendingIntent,\n                    allowBackgroundActivityStart);\n        }\n\n        @Override\n        public int startActivityAsUser(IApplicationThread caller, String callerPackage,\n                @Nullable String callerFeatureId, Intent intent, @Nullable IBinder resultTo,\n                int startFlags, Bundle options, int userId) {\n            return ActivityTaskManagerService.this.startActivityAsUser(\n                    caller, callerPackage, callerFeatureId, intent,\n                    intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                    resultTo, null, 0, startFlags, null, options, userId,\n                    false /*validateIncomingUser*/);\n        }\n\n        @Override\n        public void notifyKeyguardFlagsChanged(@Nullable Runnable callback, int displayId) {\n            synchronized (mGlobalLock) {\n\n                // We might change the visibilities here, so prepare an empty app transition which\n                // might be overridden later if we actually change visibilities.\n                final DisplayContent displayContent =\n                        mRootWindowContainer.getDisplayContent(displayId);\n                if (displayContent == null) {\n                    return;\n                }\n                final DisplayContent dc = displayContent.mDisplayContent;\n                final boolean wasTransitionSet =\n                        dc.mAppTransition.getAppTransition() != TRANSIT_NONE;\n                if (!wasTransitionSet) {\n                    dc.prepareAppTransition(TRANSIT_NONE, false /* alwaysKeepCurrent */);\n                }\n                mRootWindowContainer.ensureActivitiesVisible(null, 0, !PRESERVE_WINDOWS);\n\n                // If there was a transition set already we don't want to interfere with it as we\n                // might be starting it too early.\n                if (!wasTransitionSet) {\n                    dc.executeAppTransition();\n                }\n            }\n            if (callback != null) {\n                callback.run();\n            }\n        }\n\n        @Override\n        public void notifyKeyguardTrustedChanged() {\n            synchronized (mGlobalLock) {\n                if (mKeyguardController.isKeyguardShowing(DEFAULT_DISPLAY)) {\n                    mRootWindowContainer.ensureActivitiesVisible(null, 0, !PRESERVE_WINDOWS);\n                }\n            }\n        }\n\n        /**\n         * Called after virtual display Id is updated by\n         * {@link com.android.server.vr.Vr2dDisplay} with a specific\n         * {@param vrVr2dDisplayId}.\n         */\n        @Override\n        public void setVr2dDisplayId(int vr2dDisplayId) {\n            if (DEBUG_STACK) Slog.d(TAG, \"setVr2dDisplayId called for: \" + vr2dDisplayId);\n            synchronized (mGlobalLock) {\n                mVr2dDisplayId = vr2dDisplayId;\n            }\n        }\n\n        @Override\n        public void setFocusedActivity(IBinder token) {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n                if (r == null) {\n                    throw new IllegalArgumentException(\n                            \"setFocusedActivity: No activity record matching token=\" + token);\n                }\n                if (r.moveFocusableActivityToTop(\"setFocusedActivity\")) {\n                    mRootWindowContainer.resumeFocusedStacksTopActivities();\n                }\n            }\n        }\n\n        @Override\n        public void registerScreenObserver(ScreenObserver observer) {\n            mScreenObservers.add(observer);\n        }\n\n        @Override\n        public boolean isCallerRecents(int callingUid) {\n            return getRecentTasks().isCallerRecents(callingUid);\n        }\n\n        @Override\n        public boolean isRecentsComponentHomeActivity(int userId) {\n            return getRecentTasks().isRecentsComponentHomeActivity(userId);\n        }\n\n        @Override\n        public void cancelRecentsAnimation(boolean restoreHomeStackPosition) {\n            ActivityTaskManagerService.this.cancelRecentsAnimation(restoreHomeStackPosition);\n        }\n\n        @Override\n        public void enforceCallerIsRecentsOrHasPermission(String permission, String func) {\n            ActivityTaskManagerService.this.enforceCallerIsRecentsOrHasPermission(permission, func);\n        }\n\n        @Override\n        public void notifyActiveVoiceInteractionServiceChanged(ComponentName component) {\n            synchronized (mGlobalLock) {\n                mActiveVoiceInteractionServiceComponent = component;\n            }\n        }\n\n        @Override\n        public void notifyDreamStateChanged(boolean dreaming) {\n            synchronized (mGlobalLock) {\n                mDreaming = dreaming;\n            }\n        }\n\n        @Override\n        public void setAllowAppSwitches(@NonNull String type, int uid, int userId) {\n            if (!mAmInternal.isUserRunning(userId, ActivityManager.FLAG_OR_STOPPED)) {\n                return;\n            }\n            synchronized (mGlobalLock) {\n                ArrayMap<String, Integer> types = mAllowAppSwitchUids.get(userId);\n                if (types == null) {\n                    if (uid < 0) {\n                        return;\n                    }\n                    types = new ArrayMap<>();\n                    mAllowAppSwitchUids.put(userId, types);\n                }\n                if (uid < 0) {\n                    types.remove(type);\n                } else {\n                    types.put(type, uid);\n                }\n            }\n        }\n\n        @Override\n        public void onUserStopped(int userId) {\n            synchronized (mGlobalLock) {\n                getRecentTasks().unloadUserDataFromMemoryLocked(userId);\n                mAllowAppSwitchUids.remove(userId);\n            }\n        }\n\n        @Override\n        public boolean isGetTasksAllowed(String caller, int callingPid, int callingUid) {\n            synchronized (mGlobalLock) {\n                return ActivityTaskManagerService.this.isGetTasksAllowed(\n                        caller, callingPid, callingUid);\n            }\n        }\n\n        @HotPath(caller = HotPath.PROCESS_CHANGE)\n        @Override\n        public void onProcessAdded(WindowProcessController proc) {\n            synchronized (mGlobalLockWithoutBoost) {\n                mProcessNames.put(proc.mName, proc.mUid, proc);\n            }\n        }\n\n        @HotPath(caller = HotPath.PROCESS_CHANGE)\n        @Override\n        public void onProcessRemoved(String name, int uid) {\n            synchronized (mGlobalLockWithoutBoost) {\n                mProcessNames.remove(name, uid);\n            }\n        }\n\n        @HotPath(caller = HotPath.PROCESS_CHANGE)\n        @Override\n        public void onCleanUpApplicationRecord(WindowProcessController proc) {\n            synchronized (mGlobalLockWithoutBoost) {\n                if (proc == mHomeProcess) {\n                    mHomeProcess = null;\n                }\n                if (proc == mPreviousProcess) {\n                    mPreviousProcess = null;\n                }\n            }\n        }\n\n        @HotPath(caller = HotPath.OOM_ADJUSTMENT)\n        @Override\n        public int getTopProcessState() {\n            synchronized (mGlobalLockWithoutBoost) {\n                return mTopProcessState;\n            }\n        }\n\n        @HotPath(caller = HotPath.OOM_ADJUSTMENT)\n        @Override\n        public boolean isHeavyWeightProcess(WindowProcessController proc) {\n            synchronized (mGlobalLockWithoutBoost) {\n                return proc == mHeavyWeightProcess;\n            }\n        }\n\n        @HotPath(caller = HotPath.PROCESS_CHANGE)\n        @Override\n        public void clearHeavyWeightProcessIfEquals(WindowProcessController proc) {\n            synchronized (mGlobalLockWithoutBoost) {\n                ActivityTaskManagerService.this.clearHeavyWeightProcessIfEquals(proc);\n            }\n        }\n\n        @Override\n        public void finishHeavyWeightApp() {\n            synchronized (mGlobalLock) {\n                if (mHeavyWeightProcess != null) {\n                    mHeavyWeightProcess.finishActivities();\n                }\n                ActivityTaskManagerService.this.clearHeavyWeightProcessIfEquals(\n                        mHeavyWeightProcess);\n            }\n        }\n\n        @Override\n        public boolean isDreaming() {\n            synchronized (mGlobalLock) {\n                return mDreaming;\n            }\n        }\n\n        @HotPath(caller = HotPath.OOM_ADJUSTMENT)\n        @Override\n        public boolean isSleeping() {\n            synchronized (mGlobalLockWithoutBoost) {\n                return isSleepingLocked();\n            }\n        }\n\n        @Override\n        public boolean isShuttingDown() {\n            synchronized (mGlobalLock) {\n                return mShuttingDown;\n            }\n        }\n\n        @Override\n        public boolean shuttingDown(boolean booted, int timeout) {\n            synchronized (mGlobalLock) {\n                mShuttingDown = true;\n                mRootWindowContainer.prepareForShutdown();\n                updateEventDispatchingLocked(booted);\n                notifyTaskPersisterLocked(null, true);\n                return mStackSupervisor.shutdownLocked(timeout);\n            }\n        }\n\n        @Override\n        public void enableScreenAfterBoot(boolean booted) {\n            synchronized (mGlobalLock) {\n                writeBootProgressEnableScreen(SystemClock.uptimeMillis());\n                mWindowManager.enableScreenAfterBoot();\n                updateEventDispatchingLocked(booted);\n            }\n        }\n\n        @Override\n        public boolean showStrictModeViolationDialog() {\n            synchronized (mGlobalLock) {\n                return mShowDialogs && !mSleeping && !mShuttingDown;\n            }\n        }\n\n        @Override\n        public void showSystemReadyErrorDialogsIfNeeded() {\n            synchronized (mGlobalLock) {\n                try {\n                    if (AppGlobals.getPackageManager().hasSystemUidErrors()) {\n                        Slog.e(TAG, \"UIDs on the system are inconsistent, you need to wipe your\"\n                                + \" data partition or your device will be unstable.\");\n                        mUiHandler.post(() -> {\n                            if (mShowDialogs) {\n                                AlertDialog d = new BaseErrorDialog(mUiContext);\n                                d.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);\n                                d.setCancelable(false);\n                                d.setTitle(mUiContext.getText(R.string.android_system_label));\n                                d.setMessage(mUiContext.getText(R.string.system_error_wipe_data));\n                                d.setButton(DialogInterface.BUTTON_POSITIVE,\n                                        mUiContext.getText(R.string.ok),\n                                        mUiHandler.obtainMessage(DISMISS_DIALOG_UI_MSG, d));\n                                d.show();\n                            }\n                        });\n                    }\n                } catch (RemoteException e) {\n                }\n\n                if (!Build.isBuildConsistent()) {\n                    Slog.e(TAG, \"Build fingerprint is not consistent, warning user\");\n                    mUiHandler.post(() -> {\n                        if (mShowDialogs) {\n                            AlertDialog d = new BaseErrorDialog(mUiContext);\n                            d.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);\n                            d.setCancelable(false);\n                            d.setTitle(mUiContext.getText(R.string.android_system_label));\n                            d.setMessage(mUiContext.getText(R.string.system_error_manufacturer));\n                            d.setButton(DialogInterface.BUTTON_POSITIVE,\n                                    mUiContext.getText(R.string.ok),\n                                    mUiHandler.obtainMessage(DISMISS_DIALOG_UI_MSG, d));\n                            d.show();\n                        }\n                    });\n                }\n            }\n        }\n\n        @Override\n        public void onProcessMapped(int pid, WindowProcessController proc) {\n            synchronized (mGlobalLock) {\n                mProcessMap.put(pid, proc);\n            }\n        }\n\n        @Override\n        public void onProcessUnMapped(int pid) {\n            synchronized (mGlobalLock) {\n                mProcessMap.remove(pid);\n            }\n        }\n\n        @Override\n        public void onPackageDataCleared(String name) {\n            synchronized (mGlobalLock) {\n                mCompatModePackages.handlePackageDataClearedLocked(name);\n                mAppWarnings.onPackageDataCleared(name);\n            }\n        }\n\n        @Override\n        public void onPackageUninstalled(String name) {\n            synchronized (mGlobalLock) {\n                mAppWarnings.onPackageUninstalled(name);\n                mCompatModePackages.handlePackageUninstalledLocked(name);\n            }\n        }\n\n        @Override\n        public void onPackageAdded(String name, boolean replacing) {\n            synchronized (mGlobalLock) {\n                mCompatModePackages.handlePackageAddedLocked(name, replacing);\n            }\n        }\n\n        @Override\n        public void onPackageReplaced(ApplicationInfo aInfo) {\n            synchronized (mGlobalLock) {\n                mRootWindowContainer.updateActivityApplicationInfo(aInfo);\n            }\n        }\n\n        @Override\n        public CompatibilityInfo compatibilityInfoForPackage(ApplicationInfo ai) {\n            synchronized (mGlobalLock) {\n                return compatibilityInfoForPackageLocked(ai);\n            }\n        }\n\n        /**\n         * Set the corresponding display information for the process global configuration. To be\n         * called when we need to show IME on a different display.\n         *\n         * @param pid The process id associated with the IME window.\n         * @param displayId The ID of the display showing the IME.\n         */\n        @Override\n        public void onImeWindowSetOnDisplay(final int pid, final int displayId) {\n            // Don't update process-level configuration for Multi-Client IME process since other\n            // IMEs on other displays will also receive this configuration change due to IME\n            // services use the same application config/context.\n            if (InputMethodSystemProperty.MULTI_CLIENT_IME_ENABLED) return;\n\n            if (pid == MY_PID || pid < 0) {\n                if (DEBUG_CONFIGURATION) {\n                    Slog.w(TAG,\n                            \"Trying to update display configuration for system/invalid process.\");\n                }\n                return;\n            }\n            synchronized (mGlobalLock) {\n                final DisplayContent displayContent =\n                        mRootWindowContainer.getDisplayContent(displayId);\n                if (displayContent == null) {\n                    // Call might come when display is not yet added or has been removed.\n                    if (DEBUG_CONFIGURATION) {\n                        Slog.w(TAG, \"Trying to update display configuration for non-existing \"\n                                + \"displayId=\" + displayId);\n                    }\n                    return;\n                }\n                final WindowProcessController process = mProcessMap.getProcess(pid);\n                if (process == null) {\n                    if (DEBUG_CONFIGURATION) {\n                        Slog.w(TAG, \"Trying to update display configuration for invalid \"\n                                + \"process, pid=\" + pid);\n                    }\n                    return;\n                }\n                process.registerDisplayConfigurationListener(displayContent);\n            }\n        }\n\n        @Override\n        public void sendActivityResult(int callingUid, IBinder activityToken, String resultWho,\n                int requestCode, int resultCode, Intent data) {\n            final ActivityRecord r;\n            synchronized (mGlobalLock) {\n                r = ActivityRecord.isInStackLocked(activityToken);\n                if (r == null || r.getRootTask() == null) {\n                    return;\n                }\n            }\n\n            // Carefully collect grants without holding lock\n            final NeededUriGrants dataGrants = collectGrants(data, r);\n\n            synchronized (mGlobalLock) {\n                r.sendResult(callingUid, resultWho, requestCode, resultCode, data, dataGrants);\n            }\n        }\n\n        @Override\n        public void clearPendingResultForActivity(IBinder activityToken,\n                WeakReference<PendingIntentRecord> pir) {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInStackLocked(activityToken);\n                if (r != null && r.pendingResults != null) {\n                    r.pendingResults.remove(pir);\n                }\n            }\n        }\n\n        @Override\n        public ActivityTokens getTopActivityForTask(int taskId) {\n            synchronized (mGlobalLock) {\n                final Task task = mRootWindowContainer.anyTaskForId(taskId);\n                if (task == null) {\n                    Slog.w(TAG, \"getApplicationThreadForTopActivity failed:\"\n                            + \" Requested task not found\");\n                    return null;\n                }\n                final ActivityRecord activity = task.getTopNonFinishingActivity();\n                if (activity == null) {\n                    Slog.w(TAG, \"getApplicationThreadForTopActivity failed:\"\n                            + \" Requested activity not found\");\n                    return null;\n                }\n                if (!activity.attachedToProcess()) {\n                    Slog.w(TAG, \"getApplicationThreadForTopActivity failed: No process for \"\n                            + activity);\n                    return null;\n                }\n                return new ActivityTokens(activity.appToken, activity.assistToken,\n                        activity.app.getThread());\n            }\n        }\n\n        @Override\n        public IIntentSender getIntentSender(int type, String packageName,\n                @Nullable String featureId, int callingUid, int userId, IBinder token,\n                String resultWho, int requestCode, Intent[] intents, String[] resolvedTypes,\n                int flags, Bundle bOptions) {\n            synchronized (mGlobalLock) {\n                return getIntentSenderLocked(type, packageName, featureId, callingUid, userId,\n                        token, resultWho, requestCode, intents, resolvedTypes, flags, bOptions);\n            }\n        }\n\n        @Override\n        public ActivityServiceConnectionsHolder getServiceConnectionsHolder(IBinder token) {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInStackLocked(token);\n                if (r == null) {\n                    return null;\n                }\n                if (r.mServiceConnectionsHolder == null) {\n                    r.mServiceConnectionsHolder = new ActivityServiceConnectionsHolder(\n                            ActivityTaskManagerService.this, r);\n                }\n\n                return r.mServiceConnectionsHolder;\n            }\n        }\n\n        @Override\n        public Intent getHomeIntent() {\n            synchronized (mGlobalLock) {\n                return ActivityTaskManagerService.this.getHomeIntent();\n            }\n        }\n\n        @Override\n        public boolean startHomeActivity(int userId, String reason) {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.startHomeOnDisplay(userId, reason, DEFAULT_DISPLAY);\n            }\n        }\n\n        @Override\n        public boolean startHomeOnDisplay(int userId, String reason, int displayId,\n                boolean allowInstrumenting, boolean fromHomeKey) {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.startHomeOnDisplay(userId, reason, displayId,\n                        allowInstrumenting, fromHomeKey);\n            }\n        }\n\n        @Override\n        public boolean startHomeOnAllDisplays(int userId, String reason) {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.startHomeOnAllDisplays(userId, reason);\n            }\n        }\n\n        @HotPath(caller = HotPath.PROCESS_CHANGE)\n        @Override\n        public boolean isFactoryTestProcess(WindowProcessController wpc) {\n            synchronized (mGlobalLockWithoutBoost) {\n                if (mFactoryTest == FACTORY_TEST_OFF) {\n                    return false;\n                }\n                if (mFactoryTest == FACTORY_TEST_LOW_LEVEL && mTopComponent != null\n                        && wpc.mName.equals(mTopComponent.getPackageName())) {\n                    return true;\n                }\n                return mFactoryTest == FACTORY_TEST_HIGH_LEVEL\n                        && (wpc.mInfo.flags & FLAG_FACTORY_TEST) != 0;\n            }\n        }\n\n        @Override\n        public void updateTopComponentForFactoryTest() {\n            synchronized (mGlobalLock) {\n                if (mFactoryTest != FACTORY_TEST_LOW_LEVEL) {\n                    return;\n                }\n                final ResolveInfo ri = mContext.getPackageManager()\n                        .resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST), STOCK_PM_FLAGS);\n                final CharSequence errorMsg;\n                if (ri != null) {\n                    final ActivityInfo ai = ri.activityInfo;\n                    final ApplicationInfo app = ai.applicationInfo;\n                    if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {\n                        mTopAction = Intent.ACTION_FACTORY_TEST;\n                        mTopData = null;\n                        mTopComponent = new ComponentName(app.packageName, ai.name);\n                        errorMsg = null;\n                    } else {\n                        errorMsg = mContext.getResources().getText(\n                                com.android.internal.R.string.factorytest_not_system);\n                    }\n                } else {\n                    errorMsg = mContext.getResources().getText(\n                            com.android.internal.R.string.factorytest_no_action);\n                }\n                if (errorMsg == null) {\n                    return;\n                }\n\n                mTopAction = null;\n                mTopData = null;\n                mTopComponent = null;\n                mUiHandler.post(() -> {\n                    Dialog d = new FactoryErrorDialog(mUiContext, errorMsg);\n                    d.show();\n                    mAmInternal.ensureBootCompleted();\n                });\n            }\n        }\n\n        @HotPath(caller = HotPath.PROCESS_CHANGE)\n        @Override\n        public void handleAppDied(WindowProcessController wpc, boolean restarting,\n                Runnable finishInstrumentationCallback) {\n            synchronized (mGlobalLockWithoutBoost) {\n                // Remove this application's activities from active lists.\n                boolean hasVisibleActivities = mRootWindowContainer.handleAppDied(wpc);\n\n                wpc.clearRecentTasks();\n                wpc.clearActivities();\n\n                if (wpc.isInstrumenting()) {\n                    finishInstrumentationCallback.run();\n                }\n\n                if (!restarting && hasVisibleActivities) {\n                    deferWindowLayout();\n                    try {\n                        if (!mRootWindowContainer.resumeFocusedStacksTopActivities()) {\n                            // If there was nothing to resume, and we are not already restarting\n                            // this process, but there is a visible activity that is hosted by the\n                            // process...then make sure all visible activities are running, taking\n                            // care of restarting this process.\n                            mRootWindowContainer.ensureActivitiesVisible(null, 0,\n                                    !PRESERVE_WINDOWS);\n                        }\n                    } finally {\n                        continueWindowLayout();\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void closeSystemDialogs(String reason) {\n            enforceNotIsolatedCaller(\"closeSystemDialogs\");\n\n            final int pid = Binder.getCallingPid();\n            final int uid = Binder.getCallingUid();\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                synchronized (mGlobalLock) {\n                    // Only allow this from foreground processes, so that background\n                    // applications can't abuse it to prevent system UI from being shown.\n                    if (uid >= FIRST_APPLICATION_UID) {\n                        final WindowProcessController proc = mProcessMap.getProcess(pid);\n                        if (!proc.isPerceptible()) {\n                            Slog.w(TAG, \"Ignoring closeSystemDialogs \" + reason\n                                    + \" from background process \" + proc);\n                            return;\n                        }\n                    }\n                    mWindowManager.closeSystemDialogs(reason);\n\n                    mRootWindowContainer.closeSystemDialogActivities(reason);\n                }\n                // Call into AM outside the synchronized block.\n                mAmInternal.broadcastCloseSystemDialogs(reason);\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n\n        @Override\n        public void cleanupDisabledPackageComponents(\n                String packageName, Set<String> disabledClasses, int userId, boolean booted) {\n            synchronized (mGlobalLock) {\n                // Clean-up disabled activities.\n                if (mRootWindowContainer.finishDisabledPackageActivities(\n                        packageName, disabledClasses, true, false, userId) && booted) {\n                    mRootWindowContainer.resumeFocusedStacksTopActivities();\n                    mStackSupervisor.scheduleIdle();\n                }\n\n                // Clean-up disabled tasks\n                getRecentTasks().cleanupDisabledPackageTasksLocked(\n                        packageName, disabledClasses, userId);\n            }\n        }\n\n        @Override\n        public boolean onForceStopPackage(String packageName, boolean doit, boolean evenPersistent,\n                int userId) {\n            synchronized (mGlobalLock) {\n\n                boolean didSomething =\n                        getActivityStartController().clearPendingActivityLaunches(packageName);\n                didSomething |= mRootWindowContainer.finishDisabledPackageActivities(packageName,\n                        null, doit, evenPersistent, userId);\n                return didSomething;\n            }\n        }\n\n        @Override\n        public void resumeTopActivities(boolean scheduleIdle) {\n            synchronized (mGlobalLock) {\n                mRootWindowContainer.resumeFocusedStacksTopActivities();\n                if (scheduleIdle) {\n                    mStackSupervisor.scheduleIdle();\n                }\n            }\n        }\n\n        @HotPath(caller = HotPath.PROCESS_CHANGE)\n        @Override\n        public void preBindApplication(WindowProcessController wpc) {\n            synchronized (mGlobalLockWithoutBoost) {\n                mStackSupervisor.getActivityMetricsLogger().notifyBindApplication(wpc.mInfo);\n            }\n        }\n\n        @HotPath(caller = HotPath.PROCESS_CHANGE)\n        @Override\n        public boolean attachApplication(WindowProcessController wpc) throws RemoteException {\n            synchronized (mGlobalLockWithoutBoost) {\n                if (Trace.isTagEnabled(TRACE_TAG_WINDOW_MANAGER)) {\n                    Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, \"attachApplication:\" + wpc.mName);\n                }\n                try {\n                    return mRootWindowContainer.attachApplication(wpc);\n                } finally {\n                    Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);\n                }\n            }\n        }\n\n        @Override\n        public void notifyLockedProfile(@UserIdInt int userId, int currentUserId) {\n            try {\n                if (!AppGlobals.getPackageManager().isUidPrivileged(Binder.getCallingUid())) {\n                    throw new SecurityException(\"Only privileged app can call notifyLockedProfile\");\n                }\n            } catch (RemoteException ex) {\n                throw new SecurityException(\"Fail to check is caller a privileged app\", ex);\n            }\n\n            synchronized (mGlobalLock) {\n                final long ident = Binder.clearCallingIdentity();\n                try {\n                    if (mAmInternal.shouldConfirmCredentials(userId)) {\n                        if (mKeyguardController.isKeyguardLocked()) {\n                            // Showing launcher to avoid user entering credential twice.\n                            startHomeActivity(currentUserId, \"notifyLockedProfile\");\n                        }\n                        mRootWindowContainer.lockAllProfileTasks(userId);\n                    }\n                } finally {\n                    Binder.restoreCallingIdentity(ident);\n                }\n            }\n        }\n\n        @Override\n        public void startConfirmDeviceCredentialIntent(Intent intent, Bundle options) {\n            mAmInternal.enforceCallingPermission(\n                    MANAGE_ACTIVITY_STACKS, \"startConfirmDeviceCredentialIntent\");\n\n            synchronized (mGlobalLock) {\n                final long ident = Binder.clearCallingIdentity();\n                try {\n                    intent.addFlags(FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);\n                    final ActivityOptions activityOptions = options != null\n                            ? new ActivityOptions(options) : ActivityOptions.makeBasic();\n                    mContext.startActivityAsUser(intent, activityOptions.toBundle(),\n                            UserHandle.CURRENT);\n                } finally {\n                    Binder.restoreCallingIdentity(ident);\n                }\n            }\n        }\n\n        @Override\n        public void writeActivitiesToProto(ProtoOutputStream proto) {\n            synchronized (mGlobalLock) {\n                // The output proto of \"activity --proto activities\"\n                mRootWindowContainer.dumpDebug(\n                        proto, ROOT_WINDOW_CONTAINER, WindowTraceLogLevel.ALL);\n            }\n        }\n\n        @Override\n        public void saveANRState(String reason) {\n            synchronized (mGlobalLock) {\n                final StringWriter sw = new StringWriter();\n                final PrintWriter pw = new FastPrintWriter(sw, false, 1024);\n                pw.println(\"  ANR time: \" + DateFormat.getDateTimeInstance().format(new Date()));\n                if (reason != null) {\n                    pw.println(\"  Reason: \" + reason);\n                }\n                pw.println();\n                getActivityStartController().dump(pw, \"  \", null);\n                pw.println();\n                pw.println(\"-------------------------------------------------------------------------------\");\n                dumpActivitiesLocked(null /* fd */, pw, null /* args */, 0 /* opti */,\n                        true /* dumpAll */, false /* dumpClient */, null /* dumpPackage */,\n                        \"\" /* header */);\n                pw.println();\n                pw.close();\n\n                mLastANRState = sw.toString();\n            }\n        }\n\n        @Override\n        public void clearSavedANRState() {\n            synchronized (mGlobalLock) {\n                mLastANRState = null;\n            }\n        }\n\n        @Override\n        public void dump(String cmd, FileDescriptor fd, PrintWriter pw, String[] args, int opti,\n                boolean dumpAll, boolean dumpClient, String dumpPackage) {\n            synchronized (mGlobalLock) {\n                if (DUMP_ACTIVITIES_CMD.equals(cmd) || DUMP_ACTIVITIES_SHORT_CMD.equals(cmd)) {\n                    dumpActivitiesLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage);\n                } else if (DUMP_LASTANR_CMD.equals(cmd)) {\n                    dumpLastANRLocked(pw);\n                } else if (DUMP_LASTANR_TRACES_CMD.equals(cmd)) {\n                    dumpLastANRTracesLocked(pw);\n                } else if (DUMP_STARTER_CMD.equals(cmd)) {\n                    dumpActivityStarterLocked(pw, dumpPackage);\n                } else if (DUMP_CONTAINERS_CMD.equals(cmd)) {\n                    dumpActivityContainersLocked(pw);\n                } else if (DUMP_RECENTS_CMD.equals(cmd) || DUMP_RECENTS_SHORT_CMD.equals(cmd)) {\n                    if (getRecentTasks() != null) {\n                        getRecentTasks().dump(pw, dumpAll, dumpPackage);\n                    }\n                }\n            }\n        }\n\n        @Override\n        public boolean dumpForProcesses(FileDescriptor fd, PrintWriter pw, boolean dumpAll,\n                String dumpPackage, int dumpAppId, boolean needSep, boolean testPssMode,\n                int wakefulness) {\n            synchronized (mGlobalLock) {\n                if (mHomeProcess != null && (dumpPackage == null\n                        || mHomeProcess.mPkgList.contains(dumpPackage))) {\n                    if (needSep) {\n                        pw.println();\n                        needSep = false;\n                    }\n                    pw.println(\"  mHomeProcess: \" + mHomeProcess);\n                }\n                if (mPreviousProcess != null && (dumpPackage == null\n                        || mPreviousProcess.mPkgList.contains(dumpPackage))) {\n                    if (needSep) {\n                        pw.println();\n                        needSep = false;\n                    }\n                    pw.println(\"  mPreviousProcess: \" + mPreviousProcess);\n                }\n                if (dumpAll && (mPreviousProcess == null || dumpPackage == null\n                        || mPreviousProcess.mPkgList.contains(dumpPackage))) {\n                    StringBuilder sb = new StringBuilder(128);\n                    sb.append(\"  mPreviousProcessVisibleTime: \");\n                    TimeUtils.formatDuration(mPreviousProcessVisibleTime, sb);\n                    pw.println(sb);\n                }\n                if (mHeavyWeightProcess != null && (dumpPackage == null\n                        || mHeavyWeightProcess.mPkgList.contains(dumpPackage))) {\n                    if (needSep) {\n                        pw.println();\n                        needSep = false;\n                    }\n                    pw.println(\"  mHeavyWeightProcess: \" + mHeavyWeightProcess);\n                }\n                if (dumpPackage == null) {\n                    pw.println(\"  mGlobalConfiguration: \" + getGlobalConfiguration());\n                    mRootWindowContainer.dumpDisplayConfigs(pw, \"  \");\n                }\n                if (dumpAll) {\n                    final ActivityStack topFocusedStack = getTopDisplayFocusedStack();\n                    if (dumpPackage == null && topFocusedStack != null) {\n                        pw.println(\"  mConfigWillChange: \" + topFocusedStack.mConfigWillChange);\n                    }\n                    if (mCompatModePackages.getPackages().size() > 0) {\n                        boolean printed = false;\n                        for (Map.Entry<String, Integer> entry\n                                : mCompatModePackages.getPackages().entrySet()) {\n                            String pkg = entry.getKey();\n                            int mode = entry.getValue();\n                            if (dumpPackage != null && !dumpPackage.equals(pkg)) {\n                                continue;\n                            }\n                            if (!printed) {\n                                pw.println(\"  mScreenCompatPackages:\");\n                                printed = true;\n                            }\n                            pw.println(\"    \" + pkg + \": \" + mode);\n                        }\n                    }\n                }\n\n                if (dumpPackage == null) {\n                    pw.println(\"  mWakefulness=\"\n                            + PowerManagerInternal.wakefulnessToString(wakefulness));\n                    pw.println(\"  mSleepTokens=\" + mRootWindowContainer.mSleepTokens);\n                    if (mRunningVoice != null) {\n                        pw.println(\"  mRunningVoice=\" + mRunningVoice);\n                        pw.println(\"  mVoiceWakeLock\" + mVoiceWakeLock);\n                    }\n                    pw.println(\"  mSleeping=\" + mSleeping);\n                    pw.println(\"  mShuttingDown=\" + mShuttingDown + \" mTestPssMode=\" + testPssMode);\n                    pw.println(\"  mVrController=\" + mVrController);\n                }\n                if (mCurAppTimeTracker != null) {\n                    mCurAppTimeTracker.dumpWithHeader(pw, \"  \", true);\n                }\n                if (mAllowAppSwitchUids.size() > 0) {\n                    boolean printed = false;\n                    for (int i = 0; i < mAllowAppSwitchUids.size(); i++) {\n                        ArrayMap<String, Integer> types = mAllowAppSwitchUids.valueAt(i);\n                        for (int j = 0; j < types.size(); j++) {\n                            if (dumpPackage == null ||\n                                    UserHandle.getAppId(types.valueAt(j).intValue()) == dumpAppId) {\n                                if (needSep) {\n                                    pw.println();\n                                    needSep = false;\n                                }\n                                if (!printed) {\n                                    pw.println(\"  mAllowAppSwitchUids:\");\n                                    printed = true;\n                                }\n                                pw.print(\"    User \");\n                                pw.print(mAllowAppSwitchUids.keyAt(i));\n                                pw.print(\": Type \");\n                                pw.print(types.keyAt(j));\n                                pw.print(\" = \");\n                                UserHandle.formatUid(pw, types.valueAt(j).intValue());\n                                pw.println();\n                            }\n                        }\n                    }\n                }\n                if (dumpPackage == null) {\n                    if (mController != null) {\n                        pw.println(\"  mController=\" + mController\n                                + \" mControllerIsAMonkey=\" + mControllerIsAMonkey);\n                    }\n                    pw.println(\"  mGoingToSleepWakeLock=\" + mStackSupervisor.mGoingToSleepWakeLock);\n                    pw.println(\"  mLaunchingActivityWakeLock=\"\n                            + mStackSupervisor.mLaunchingActivityWakeLock);\n                }\n\n                return needSep;\n            }\n        }\n\n        @Override\n        public void writeProcessesToProto(ProtoOutputStream proto, String dumpPackage,\n                int wakeFullness, boolean testPssMode) {\n            synchronized (mGlobalLock) {\n                if (dumpPackage == null) {\n                    getGlobalConfiguration().dumpDebug(proto, GLOBAL_CONFIGURATION);\n                    final ActivityStack topFocusedStack = getTopDisplayFocusedStack();\n                    if (topFocusedStack != null) {\n                        proto.write(CONFIG_WILL_CHANGE, topFocusedStack.mConfigWillChange);\n                    }\n                    writeSleepStateToProto(proto, wakeFullness, testPssMode);\n                    if (mRunningVoice != null) {\n                        final long vrToken = proto.start(\n                                ActivityManagerServiceDumpProcessesProto.RUNNING_VOICE);\n                        proto.write(ActivityManagerServiceDumpProcessesProto.Voice.SESSION,\n                                mRunningVoice.toString());\n                        mVoiceWakeLock.dumpDebug(\n                                proto, ActivityManagerServiceDumpProcessesProto.Voice.WAKELOCK);\n                        proto.end(vrToken);\n                    }\n                    mVrController.dumpDebug(proto,\n                            ActivityManagerServiceDumpProcessesProto.VR_CONTROLLER);\n                    if (mController != null) {\n                        final long token = proto.start(CONTROLLER);\n                        proto.write(ActivityManagerServiceDumpProcessesProto.Controller.CONTROLLER,\n                                mController.toString());\n                        proto.write(IS_A_MONKEY, mControllerIsAMonkey);\n                        proto.end(token);\n                    }\n                    mStackSupervisor.mGoingToSleepWakeLock.dumpDebug(proto, GOING_TO_SLEEP);\n                    mStackSupervisor.mLaunchingActivityWakeLock.dumpDebug(proto,\n                            LAUNCHING_ACTIVITY);\n                }\n\n                if (mHomeProcess != null && (dumpPackage == null\n                        || mHomeProcess.mPkgList.contains(dumpPackage))) {\n                    mHomeProcess.dumpDebug(proto, HOME_PROC);\n                }\n\n                if (mPreviousProcess != null && (dumpPackage == null\n                        || mPreviousProcess.mPkgList.contains(dumpPackage))) {\n                    mPreviousProcess.dumpDebug(proto, PREVIOUS_PROC);\n                    proto.write(PREVIOUS_PROC_VISIBLE_TIME_MS, mPreviousProcessVisibleTime);\n                }\n\n                if (mHeavyWeightProcess != null && (dumpPackage == null\n                        || mHeavyWeightProcess.mPkgList.contains(dumpPackage))) {\n                    mHeavyWeightProcess.dumpDebug(proto, HEAVY_WEIGHT_PROC);\n                }\n\n                for (Map.Entry<String, Integer> entry\n                        : mCompatModePackages.getPackages().entrySet()) {\n                    String pkg = entry.getKey();\n                    int mode = entry.getValue();\n                    if (dumpPackage == null || dumpPackage.equals(pkg)) {\n                        long compatToken = proto.start(SCREEN_COMPAT_PACKAGES);\n                        proto.write(PACKAGE, pkg);\n                        proto.write(MODE, mode);\n                        proto.end(compatToken);\n                    }\n                }\n\n                if (mCurAppTimeTracker != null) {\n                    mCurAppTimeTracker.dumpDebug(proto, CURRENT_TRACKER, true);\n                }\n\n            }\n        }\n\n        @Override\n        public boolean dumpActivity(FileDescriptor fd, PrintWriter pw, String name,\n                String[] args, int opti, boolean dumpAll, boolean dumpVisibleStacksOnly,\n                boolean dumpFocusedStackOnly) {\n            return ActivityTaskManagerService.this.dumpActivity(fd, pw, name, args, opti, dumpAll,\n                    dumpVisibleStacksOnly, dumpFocusedStackOnly);\n        }\n\n        @Override\n        public void dumpForOom(PrintWriter pw) {\n            synchronized (mGlobalLock) {\n                pw.println(\"  mHomeProcess: \" + mHomeProcess);\n                pw.println(\"  mPreviousProcess: \" + mPreviousProcess);\n                if (mHeavyWeightProcess != null) {\n                    pw.println(\"  mHeavyWeightProcess: \" + mHeavyWeightProcess);\n                }\n            }\n        }\n\n        @Override\n        public boolean canGcNow() {\n            synchronized (mGlobalLock) {\n                return isSleeping() || mRootWindowContainer.allResumedActivitiesIdle();\n            }\n        }\n\n        @HotPath(caller = HotPath.OOM_ADJUSTMENT)\n        @Override\n        public WindowProcessController getTopApp() {\n            synchronized (mGlobalLockWithoutBoost) {\n                if (mRootWindowContainer == null) {\n                    // Return null if mRootWindowContainer not yet initialize, while update\n                    // oomadj after AMS created.\n                    return null;\n                }\n                final ActivityRecord top = mRootWindowContainer.getTopResumedActivity();\n                return top != null ? top.app : null;\n            }\n        }\n\n        @HotPath(caller = HotPath.OOM_ADJUSTMENT)\n        @Override\n        public void rankTaskLayersIfNeeded() {\n            synchronized (mGlobalLockWithoutBoost) {\n                if (mRootWindowContainer != null) {\n                    mRootWindowContainer.rankTaskLayersIfNeeded();\n                }\n            }\n        }\n\n        @Override\n        public void scheduleDestroyAllActivities(String reason) {\n            synchronized (mGlobalLock) {\n                mRootWindowContainer.scheduleDestroyAllActivities(reason);\n            }\n        }\n\n        @Override\n        public void removeUser(int userId) {\n            synchronized (mGlobalLock) {\n                mRootWindowContainer.removeUser(userId);\n            }\n        }\n\n        @Override\n        public boolean switchUser(int userId, UserState userState) {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.switchUser(userId, userState);\n            }\n        }\n\n        @Override\n        public void onHandleAppCrash(WindowProcessController wpc) {\n            synchronized (mGlobalLock) {\n                mRootWindowContainer.handleAppCrash(wpc);\n            }\n        }\n\n        @Override\n        public int finishTopCrashedActivities(WindowProcessController crashedApp, String reason) {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.finishTopCrashedActivities(crashedApp, reason);\n            }\n        }\n\n        @HotPath(caller = HotPath.OOM_ADJUSTMENT)\n        @Override\n        public void onUidActive(int uid, int procState) {\n            mActiveUids.onUidActive(uid, procState);\n        }\n\n        @HotPath(caller = HotPath.OOM_ADJUSTMENT)\n        @Override\n        public void onUidInactive(int uid) {\n            mActiveUids.onUidInactive(uid);\n        }\n\n        @HotPath(caller = HotPath.OOM_ADJUSTMENT)\n        @Override\n        public void onActiveUidsCleared() {\n            mActiveUids.onActiveUidsCleared();\n        }\n\n        @HotPath(caller = HotPath.OOM_ADJUSTMENT)\n        @Override\n        public void onUidProcStateChanged(int uid, int procState) {\n            mActiveUids.onUidProcStateChanged(uid, procState);\n        }\n\n        @Override\n        public void onUidAddedToPendingTempWhitelist(int uid, String tag) {\n            synchronized (mGlobalLockWithoutBoost) {\n                mPendingTempWhitelist.put(uid, tag);\n            }\n        }\n\n        @Override\n        public void onUidRemovedFromPendingTempWhitelist(int uid) {\n            synchronized (mGlobalLockWithoutBoost) {\n                mPendingTempWhitelist.remove(uid);\n            }\n        }\n\n        @Override\n        public boolean handleAppCrashInActivityController(String processName, int pid,\n                String shortMsg, String longMsg, long timeMillis, String stackTrace,\n                Runnable killCrashingAppCallback) {\n            synchronized (mGlobalLock) {\n                if (mController == null) {\n                    return false;\n                }\n\n                try {\n                    if (!mController.appCrashed(processName, pid, shortMsg, longMsg, timeMillis,\n                            stackTrace)) {\n                        killCrashingAppCallback.run();\n                        return true;\n                    }\n                } catch (RemoteException e) {\n                    mController = null;\n                    Watchdog.getInstance().setActivityController(null);\n                }\n                return false;\n            }\n        }\n\n        @Override\n        public void removeRecentTasksByPackageName(String packageName, int userId) {\n            synchronized (mGlobalLock) {\n                mRecentTasks.removeTasksByPackageName(packageName, userId);\n            }\n        }\n\n        @Override\n        public void cleanupRecentTasksForUser(int userId) {\n            synchronized (mGlobalLock) {\n                mRecentTasks.cleanupLocked(userId);\n            }\n        }\n\n        @Override\n        public void loadRecentTasksForUser(int userId) {\n            synchronized (mGlobalLock) {\n                mRecentTasks.loadUserRecentsLocked(userId);\n            }\n        }\n\n        @Override\n        public void onPackagesSuspendedChanged(String[] packages, boolean suspended, int userId) {\n            synchronized (mGlobalLock) {\n                mRecentTasks.onPackagesSuspendedChanged(packages, suspended, userId);\n            }\n        }\n\n        @Override\n        public void flushRecentTasks() {\n            mRecentTasks.flush();\n        }\n\n        @Override\n        public WindowProcessController getHomeProcess() {\n            synchronized (mGlobalLock) {\n                return mHomeProcess;\n            }\n        }\n\n        @Override\n        public WindowProcessController getPreviousProcess() {\n            synchronized (mGlobalLock) {\n                return mPreviousProcess;\n            }\n        }\n\n        @Override\n        public void clearLockedTasks(String reason) {\n            synchronized (mGlobalLock) {\n                getLockTaskController().clearLockedTasks(reason);\n            }\n        }\n\n        @Override\n        public void updateUserConfiguration() {\n            synchronized (mGlobalLock) {\n                final Configuration configuration = new Configuration(getGlobalConfiguration());\n                final int currentUserId = mAmInternal.getCurrentUserId();\n                Settings.System.adjustConfigurationForUser(mContext.getContentResolver(),\n                        configuration, currentUserId, Settings.System.canWrite(mContext));\n                updateConfigurationLocked(configuration, null /* starting */,\n                        false /* initLocale */, false /* persistent */, currentUserId,\n                        false /* deferResume */);\n            }\n        }\n\n        @Override\n        public boolean canShowErrorDialogs() {\n            synchronized (mGlobalLock) {\n                return mShowDialogs && !mSleeping && !mShuttingDown\n                        && !mKeyguardController.isKeyguardOrAodShowing(DEFAULT_DISPLAY)\n                        && !hasUserRestriction(UserManager.DISALLOW_SYSTEM_ERROR_DIALOGS,\n                        mAmInternal.getCurrentUserId())\n                        && !(UserManager.isDeviceInDemoMode(mContext)\n                        && mAmInternal.getCurrentUser().isDemo());\n            }\n        }\n\n        @Override\n        public void setProfileApp(String profileApp) {\n            synchronized (mGlobalLock) {\n                mProfileApp = profileApp;\n            }\n        }\n\n        @Override\n        public void setProfileProc(WindowProcessController wpc) {\n            synchronized (mGlobalLock) {\n                mProfileProc = wpc;\n            }\n        }\n\n        @Override\n        public void setProfilerInfo(ProfilerInfo profilerInfo) {\n            synchronized (mGlobalLock) {\n                mProfilerInfo = profilerInfo;\n            }\n        }\n\n        @Override\n        public ActivityMetricsLaunchObserverRegistry getLaunchObserverRegistry() {\n            synchronized (mGlobalLock) {\n                return mStackSupervisor.getActivityMetricsLogger().getLaunchObserverRegistry();\n            }\n        }\n\n        @Override\n        public ActivityManager.TaskSnapshot getTaskSnapshotBlocking(\n                int taskId, boolean isLowResolution) {\n            return ActivityTaskManagerService.this.getTaskSnapshot(taskId, isLowResolution,\n                    true /* restoreFromDisk */);\n        }\n\n        @Override\n        public boolean isUidForeground(int uid) {\n            synchronized (mGlobalLock) {\n                return ActivityTaskManagerService.this.isUidForeground(uid);\n            }\n        }\n\n        @Override\n        public void setDeviceOwnerUid(int uid) {\n            synchronized (mGlobalLock) {\n                ActivityTaskManagerService.this.setDeviceOwnerUid(uid);\n            }\n        }\n\n        @Override\n        public void setCompanionAppPackages(int userId, Set<String> companionAppPackages) {\n            // Translate package names into UIDs\n            final Set<Integer> result = new HashSet<>();\n            for (String pkg : companionAppPackages) {\n                final int uid = getPackageManagerInternalLocked().getPackageUid(pkg, 0, userId);\n                if (uid >= 0) {\n                    result.add(uid);\n                }\n            }\n            synchronized (mGlobalLock) {\n                mCompanionAppUidsMap.put(userId, result);\n            }\n        }\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 60324,
                                        "general": {
                                            "word_based": 23195,
                                            "char_based": 78790
                                        },
                                        "gemini": 70716
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "d54a64bdf71d1c91542b6885149fd176622ad0b4",
                            "repo_path": "android_repos/base",
                            "result": "failure",
                            "downstream_patch_content": "commit d54a64bdf71d1c91542b6885149fd176622ad0b4\nAuthor: Christophe Pinelli <cpinelli@google.com>\nDate:   Fri May 12 21:44:08 2023 +0000\n\n    Restrict activity launch when caller is running in the background\n    \n    Test: test on device + atest-src BackgroundActivityLaunchTest#testBackgroundActivityBlockedInStartNextMatchingActivity\n    Bug: 230492947\n    Merged-In: Ie774b142a7fab12d596ccd64872b781e3825e9ba\n    Change-Id: I1a0c13e74622d301866efaca1b5351a6b241ebe5\n\ndiff --git a/services/core/java/com/android/server/wm/ActivityTaskManagerService.java b/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\nindex 987cff95bba3..c1006914c6a3 100644\n--- a/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\n+++ b/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\n@@ -1324,29 +1324,38 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n \n             final long origId = Binder.clearCallingIdentity();\n             // TODO(b/64750076): Check if calling pid should really be -1.\n-            final int res = getActivityStartController()\n-                    .obtainStarter(intent, \"startNextMatchingActivity\")\n-                    .setCaller(r.app.getThread())\n-                    .setResolvedType(r.resolvedType)\n-                    .setActivityInfo(aInfo)\n-                    .setResultTo(resultTo != null ? resultTo.appToken : null)\n-                    .setResultWho(resultWho)\n-                    .setRequestCode(requestCode)\n-                    .setCallingPid(-1)\n-                    .setCallingUid(r.launchedFromUid)\n-                    .setCallingPackage(r.launchedFromPackage)\n-                    .setCallingFeatureId(r.launchedFromFeatureId)\n-                    .setRealCallingPid(-1)\n-                    .setRealCallingUid(r.launchedFromUid)\n-                    .setActivityOptions(options)\n-                    .execute();\n-            Binder.restoreCallingIdentity(origId);\n-\n-            r.finishing = wasFinishing;\n-            if (res != ActivityManager.START_SUCCESS) {\n-                return false;\n+            try {\n+                if (options == null) {\n+                    options = new SafeActivityOptions(ActivityOptions.makeBasic());\n+                }\n+                // Fixes b/230492947\n+                // Prevents background activity launch through #startNextMatchingActivity\n+                // An activity going into the background could still go back to the foreground\n+                // if the intent used matches both:\n+                // - the activity in the background\n+                // - a second activity.\n+                options.getOptions(r).setAvoidMoveToFront();\n+                final int res = getActivityStartController()\n+                        .obtainStarter(intent, \"startNextMatchingActivity\")\n+                        .setCaller(r.app.getThread())\n+                        .setResolvedType(r.resolvedType)\n+                        .setActivityInfo(aInfo)\n+                        .setResultTo(resultTo != null ? resultTo.appToken : null)\n+                        .setResultWho(resultWho)\n+                        .setRequestCode(requestCode)\n+                        .setCallingPid(-1)\n+                        .setCallingUid(r.launchedFromUid)\n+                        .setCallingPackage(r.launchedFromPackage)\n+                        .setCallingFeatureId(r.launchedFromFeatureId)\n+                        .setRealCallingPid(-1)\n+                        .setRealCallingUid(r.launchedFromUid)\n+                        .setActivityOptions(options)\n+                        .execute();\n+                r.finishing = wasFinishing;\n+                return res == ActivityManager.START_SUCCESS;\n+            } finally {\n+                Binder.restoreCallingIdentity(origId);\n             }\n-            return true;\n         }\n     }\n \n",
                            "downstream_patch_tokens": {
                                "openai": 858,
                                "general": {
                                    "word_based": 279,
                                    "char_based": 974
                                },
                                "gemini": 1046
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "services/core/java/com/android/server/wm/ActivityTaskManagerService.java",
                                    "total_hunks": 1,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12)\n\n=======\n\n            final long origId = Binder.clearCallingIdentity();\n            // TODO(b/64750076): Check if calling pid should really be -1.\n            try {\n                if (options == null) {\n                    options = new SafeActivityOptions(ActivityOptions.makeBasic());\n                }\n\n                // Fixes b/230492947\n                // Prevents background activity launch through #startNextMatchingActivity\n>>>>>>> UPSTREAM PATCH (commit e3c537ddea5ce8b28eeb89300ef602753cfe42a4)",
                                            "merge_conflict_tokens": {
                                                "openai": 118,
                                                "general": {
                                                    "word_based": 41,
                                                    "char_based": 134
                                                },
                                                "gemini": 151
                                            }
                                        }
                                    ],
                                    "inline_merge_token_summary": {
                                        "gemini": 1963,
                                        "openai": 1652,
                                        "general_word": 574,
                                        "general_char": 1876
                                    },
                                    "rej_file_content": "```diff\n--- services/core/java/com/android/server/wm/ActivityTaskManagerService.java\n+++ services/core/java/com/android/server/wm/ActivityTaskManagerService.java\n@@ -1411,29 +1411,39 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n \n             final long origId = Binder.clearCallingIdentity();\n             // TODO(b/64750076): Check if calling pid should really be -1.\n-            final int res = getActivityStartController()\n-                    .obtainStarter(intent, \"startNextMatchingActivity\")\n-                    .setCaller(r.app.getThread())\n-                    .setResolvedType(r.resolvedType)\n-                    .setActivityInfo(aInfo)\n-                    .setResultTo(resultTo != null ? resultTo.token : null)\n-                    .setResultWho(resultWho)\n-                    .setRequestCode(requestCode)\n-                    .setCallingPid(-1)\n-                    .setCallingUid(r.launchedFromUid)\n-                    .setCallingPackage(r.launchedFromPackage)\n-                    .setCallingFeatureId(r.launchedFromFeatureId)\n-                    .setRealCallingPid(-1)\n-                    .setRealCallingUid(r.launchedFromUid)\n-                    .setActivityOptions(options)\n-                    .execute();\n-            Binder.restoreCallingIdentity(origId);\n+            try {\n+                if (options == null) {\n+                    options = new SafeActivityOptions(ActivityOptions.makeBasic());\n+                }\n \n-            r.finishing = wasFinishing;\n-            if (res != ActivityManager.START_SUCCESS) {\n-                return false;\n+                // Fixes b/230492947\n+                // Prevents background activity launch through #startNextMatchingActivity\n+                // An activity going into the background could still go back to the foreground\n+                // if the intent used matches both:\n+                // - the activity in the background\n+                // - a second activity.\n+                options.getOptions(r).setAvoidMoveToFront();\n+                final int res = getActivityStartController()\n+                        .obtainStarter(intent, \"startNextMatchingActivity\")\n+                        .setCaller(r.app.getThread())\n+                        .setResolvedType(r.resolvedType)\n+                        .setActivityInfo(aInfo)\n+                        .setResultTo(resultTo != null ? resultTo.token : null)\n+                        .setResultWho(resultWho)\n+                        .setRequestCode(requestCode)\n+                        .setCallingPid(-1)\n+                        .setCallingUid(r.launchedFromUid)\n+                        .setCallingPackage(r.launchedFromPackage)\n+                        .setCallingFeatureId(r.launchedFromFeatureId)\n+                        .setRealCallingPid(-1)\n+                        .setRealCallingUid(r.launchedFromUid)\n+                        .setActivityOptions(options)\n+                        .execute();\n+                r.finishing = wasFinishing;\n+                return res == ActivityManager.START_SUCCESS;\n+            } finally {\n+                Binder.restoreCallingIdentity(origId);\n             }\n-            return true;\n         }\n     }\n```",
                                    "rej_file_tokens": {
                                        "openai": 635,
                                        "general": {
                                            "word_based": 208,
                                            "char_based": 804
                                        },
                                        "gemini": 743
                                    },
                                    "patch_apply_output": "patching file services/core/java/com/android/server/wm/ActivityTaskManagerService.java\nHunk #1 FAILED at 1411.\n1 out of 1 hunk FAILED -- saving rejects to file services/core/java/com/android/server/wm/ActivityTaskManagerService.java.rej",
                                    "inline_merge_output": "patching file services/core/java/com/android/server/wm/ActivityTaskManagerService.java\nHunk #1 NOT MERGED at 1421-1433, already applied at 1460.",
                                    "upstream_file_tokens": {
                                        "openai": 59312,
                                        "general": {
                                            "word_based": 22835,
                                            "char_based": 77205
                                        },
                                        "gemini": 69378
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2018 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License\n */\n\npackage com.android.server.wm;\n\nimport static android.Manifest.permission.BIND_VOICE_INTERACTION;\nimport static android.Manifest.permission.CHANGE_CONFIGURATION;\nimport static android.Manifest.permission.CONTROL_REMOTE_APP_TRANSITION_ANIMATIONS;\nimport static android.Manifest.permission.INTERACT_ACROSS_USERS;\nimport static android.Manifest.permission.INTERACT_ACROSS_USERS_FULL;\nimport static android.Manifest.permission.INTERNAL_SYSTEM_WINDOW;\nimport static android.Manifest.permission.MANAGE_ACTIVITY_STACKS;\nimport static android.Manifest.permission.MANAGE_ACTIVITY_TASKS;\nimport static android.Manifest.permission.READ_FRAME_BUFFER;\nimport static android.Manifest.permission.REMOVE_TASKS;\nimport static android.Manifest.permission.START_TASKS_FROM_RECENTS;\nimport static android.Manifest.permission.STOP_APP_SWITCHES;\nimport static android.app.ActivityManager.DROP_CLOSE_SYSTEM_DIALOGS;\nimport static android.app.ActivityManager.LOCK_DOWN_CLOSE_SYSTEM_DIALOGS;\nimport static android.app.ActivityManager.LOCK_TASK_MODE_NONE;\nimport static android.app.ActivityManagerInternal.ALLOW_NON_FULL;\nimport static android.app.ActivityTaskManager.INVALID_TASK_ID;\nimport static android.app.ActivityTaskManager.RESIZE_MODE_PRESERVE_WINDOW;\nimport static android.app.WindowConfiguration.ACTIVITY_TYPE_DREAM;\nimport static android.app.WindowConfiguration.WINDOWING_MODE_PINNED;\nimport static android.content.Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;\nimport static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\nimport static android.content.pm.ActivityInfo.RESIZE_MODE_UNRESIZEABLE;\nimport static android.content.pm.ApplicationInfo.FLAG_FACTORY_TEST;\nimport static android.content.pm.ConfigurationInfo.GL_ES_VERSION_UNDEFINED;\nimport static android.content.pm.PackageManager.FEATURE_ACTIVITIES_ON_SECONDARY_DISPLAYS;\nimport static android.content.pm.PackageManager.FEATURE_CANT_SAVE_STATE;\nimport static android.content.pm.PackageManager.FEATURE_FREEFORM_WINDOW_MANAGEMENT;\nimport static android.content.pm.PackageManager.FEATURE_LEANBACK;\nimport static android.content.pm.PackageManager.FEATURE_PICTURE_IN_PICTURE;\nimport static android.content.pm.PackageManager.PERMISSION_GRANTED;\nimport static android.os.FactoryTest.FACTORY_TEST_HIGH_LEVEL;\nimport static android.os.FactoryTest.FACTORY_TEST_LOW_LEVEL;\nimport static android.os.FactoryTest.FACTORY_TEST_OFF;\nimport static android.os.InputConstants.DEFAULT_DISPATCHING_TIMEOUT_MILLIS;\nimport static android.os.Process.FIRST_APPLICATION_UID;\nimport static android.os.Process.SYSTEM_UID;\nimport static android.os.Trace.TRACE_TAG_WINDOW_MANAGER;\nimport static android.provider.Settings.Global.DEVELOPMENT_ENABLE_FREEFORM_WINDOWS_SUPPORT;\nimport static android.provider.Settings.Global.DEVELOPMENT_ENABLE_NON_RESIZABLE_MULTI_WINDOW;\nimport static android.provider.Settings.Global.DEVELOPMENT_FORCE_RESIZABLE_ACTIVITIES;\nimport static android.provider.Settings.Global.DEVELOPMENT_FORCE_RTL;\nimport static android.provider.Settings.Global.HIDE_ERROR_DIALOGS;\nimport static android.provider.Settings.System.FONT_SCALE;\nimport static android.text.format.DateUtils.MINUTE_IN_MILLIS;\nimport static android.view.Display.DEFAULT_DISPLAY;\nimport static android.view.Display.INVALID_DISPLAY;\nimport static android.view.WindowManager.TRANSIT_NONE;\n\nimport static com.android.internal.protolog.ProtoLogGroup.WM_DEBUG_CONFIGURATION;\nimport static com.android.internal.protolog.ProtoLogGroup.WM_DEBUG_FOCUS;\nimport static com.android.internal.protolog.ProtoLogGroup.WM_DEBUG_IMMERSIVE;\nimport static com.android.internal.protolog.ProtoLogGroup.WM_DEBUG_LOCKTASK;\nimport static com.android.internal.protolog.ProtoLogGroup.WM_DEBUG_TASKS;\nimport static com.android.server.am.ActivityManagerService.ANR_TRACE_DIR;\nimport static com.android.server.am.ActivityManagerService.MY_PID;\nimport static com.android.server.am.ActivityManagerService.STOCK_PM_FLAGS;\nimport static com.android.server.am.ActivityManagerService.dumpStackTraces;\nimport static com.android.server.am.ActivityManagerServiceDumpActivitiesProto.ROOT_WINDOW_CONTAINER;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.CONFIG_WILL_CHANGE;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.CONTROLLER;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.CURRENT_TRACKER;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.Controller.IS_A_MONKEY;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.GLOBAL_CONFIGURATION;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.GOING_TO_SLEEP;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.HEAVY_WEIGHT_PROC;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.HOME_PROC;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.LAUNCHING_ACTIVITY;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.PREVIOUS_PROC;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.PREVIOUS_PROC_VISIBLE_TIME_MS;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.SCREEN_COMPAT_PACKAGES;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.ScreenCompatPackage.MODE;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.ScreenCompatPackage.PACKAGE;\nimport static com.android.server.am.EventLogTags.writeBootProgressEnableScreen;\nimport static com.android.server.am.EventLogTags.writeConfigurationChanged;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.DEBUG_ALL;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.POSTFIX_ROOT_TASK;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.POSTFIX_SWITCH;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.TAG_ATM;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.TAG_WITH_CLASS_NAME;\nimport static com.android.server.wm.ActivityTaskManagerInternal.ASSIST_KEY_CONTENT;\nimport static com.android.server.wm.ActivityTaskManagerInternal.ASSIST_KEY_DATA;\nimport static com.android.server.wm.ActivityTaskManagerInternal.ASSIST_KEY_RECEIVER_EXTRAS;\nimport static com.android.server.wm.ActivityTaskManagerInternal.ASSIST_KEY_STRUCTURE;\nimport static com.android.server.wm.ActivityTaskManagerService.H.REPORT_TIME_TRACKER_MSG;\nimport static com.android.server.wm.ActivityTaskManagerService.UiHandler.DISMISS_DIALOG_UI_MSG;\nimport static com.android.server.wm.ActivityTaskSupervisor.DEFER_RESUME;\nimport static com.android.server.wm.ActivityTaskSupervisor.ON_TOP;\nimport static com.android.server.wm.ActivityTaskSupervisor.PRESERVE_WINDOWS;\nimport static com.android.server.wm.ActivityTaskSupervisor.REMOVE_FROM_RECENTS;\nimport static com.android.server.wm.LockTaskController.LOCK_TASK_AUTH_DONT_LOCK;\nimport static com.android.server.wm.RecentsAnimationController.REORDER_KEEP_IN_PLACE;\nimport static com.android.server.wm.RecentsAnimationController.REORDER_MOVE_TO_ORIGINAL_POSITION;\nimport static com.android.server.wm.RootWindowContainer.MATCH_ATTACHED_TASK_ONLY;\nimport static com.android.server.wm.RootWindowContainer.MATCH_ATTACHED_TASK_OR_RECENT_TASKS;\nimport static com.android.server.wm.Task.REPARENT_KEEP_ROOT_TASK_AT_FRONT;\nimport static com.android.server.wm.WindowManagerService.UPDATE_FOCUS_NORMAL;\n\nimport android.Manifest;\nimport android.annotation.IntDef;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.UserIdInt;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.ActivityOptions;\nimport android.app.ActivityTaskManager;\nimport android.app.ActivityTaskManager.RootTaskInfo;\nimport android.app.ActivityThread;\nimport android.app.AlertDialog;\nimport android.app.AnrController;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.Dialog;\nimport android.app.IActivityClientController;\nimport android.app.IActivityController;\nimport android.app.IActivityTaskManager;\nimport android.app.IApplicationThread;\nimport android.app.IAssistDataReceiver;\nimport android.app.INotificationManager;\nimport android.app.ITaskStackListener;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.PictureInPictureParams;\nimport android.app.PictureInPictureUiState;\nimport android.app.ProfilerInfo;\nimport android.app.RemoteAction;\nimport android.app.WaitResult;\nimport android.app.admin.DevicePolicyCache;\nimport android.app.assist.AssistContent;\nimport android.app.assist.AssistStructure;\nimport android.app.compat.CompatChanges;\nimport android.app.usage.UsageStatsManagerInternal;\nimport android.content.ActivityNotFoundException;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.IIntentSender;\nimport android.content.Intent;\nimport android.content.LocusId;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.ConfigurationInfo;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.ResolveInfo;\nimport android.content.res.CompatibilityInfo;\nimport android.content.res.Configuration;\nimport android.content.res.Resources;\nimport android.database.ContentObserver;\nimport android.graphics.Bitmap;\nimport android.graphics.Point;\nimport android.graphics.Rect;\nimport android.hardware.power.Mode;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.FactoryTest;\nimport android.os.FileUtils;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.IUserManager;\nimport android.os.LocaleList;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.Parcel;\nimport android.os.PowerManager;\nimport android.os.PowerManagerInternal;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.ServiceManager;\nimport android.os.StrictMode;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.Trace;\nimport android.os.UpdateLock;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.WorkSource;\nimport android.os.storage.IStorageManager;\nimport android.os.storage.StorageManager;\nimport android.provider.Settings;\nimport android.service.dreams.DreamActivity;\nimport android.service.voice.IVoiceInteractionSession;\nimport android.service.voice.VoiceInteractionManagerInternal;\nimport android.sysprop.DisplayProperties;\nimport android.telecom.TelecomManager;\nimport android.text.format.TimeMigrationUtils;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.IntArray;\nimport android.util.Log;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.TimeUtils;\nimport android.util.proto.ProtoOutputStream;\nimport android.view.IRecentsAnimationRunner;\nimport android.view.RemoteAnimationAdapter;\nimport android.view.RemoteAnimationDefinition;\nimport android.view.WindowManager;\nimport android.window.IWindowOrganizerController;\nimport android.window.SplashScreenView.SplashScreenViewParcelable;\nimport android.window.TaskSnapshot;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.app.IVoiceInteractor;\nimport com.android.internal.app.ProcessMap;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.os.TransferPipe;\nimport com.android.internal.policy.AttributeCache;\nimport com.android.internal.policy.KeyguardDismissCallback;\nimport com.android.internal.protolog.common.ProtoLog;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.FastPrintWriter;\nimport com.android.internal.util.FrameworkStatsLog;\nimport com.android.internal.util.function.pooled.PooledLambda;\nimport com.android.server.LocalServices;\nimport com.android.server.SystemService;\nimport com.android.server.SystemServiceManager;\nimport com.android.server.UiThread;\nimport com.android.server.Watchdog;\nimport com.android.server.am.ActivityManagerService;\nimport com.android.server.am.ActivityManagerServiceDumpProcessesProto;\nimport com.android.server.am.AppTimeTracker;\nimport com.android.server.am.AssistDataRequester;\nimport com.android.server.am.BaseErrorDialog;\nimport com.android.server.am.PendingIntentController;\nimport com.android.server.am.PendingIntentRecord;\nimport com.android.server.am.UserState;\nimport com.android.server.firewall.IntentFirewall;\nimport com.android.server.inputmethod.InputMethodSystemProperty;\nimport com.android.server.pm.UserManagerService;\nimport com.android.server.policy.PermissionPolicyInternal;\nimport com.android.server.statusbar.StatusBarManagerInternal;\nimport com.android.server.uri.NeededUriGrants;\nimport com.android.server.uri.UriGrantsManagerInternal;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.ref.WeakReference;\nimport java.text.DateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\n\n/**\n * System service for managing activities and their containers (task, displays,... ).\n *\n * {@hide}\n */\npublic class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n    private static final String TAG = TAG_WITH_CLASS_NAME ? \"ActivityTaskManagerService\" : TAG_ATM;\n    static final String TAG_ROOT_TASK = TAG + POSTFIX_ROOT_TASK;\n    static final String TAG_SWITCH = TAG + POSTFIX_SWITCH;\n\n    // How long we wait until we timeout on key dispatching during instrumentation.\n    static final long INSTRUMENTATION_KEY_DISPATCHING_TIMEOUT_MILLIS = 60 * 1000;\n    // How long we permit background activity starts after an activity in the process\n    // started or finished.\n    static final long ACTIVITY_BG_START_GRACE_PERIOD_MS = 10 * 1000;\n\n    /**\n     * The duration to keep a process in animating state (top scheduling group) when the\n     * wakefulness is changing from awake to doze or sleep.\n     */\n    private static final long DOZE_ANIMATING_STATE_RETAIN_TIME_MS = 2000;\n\n    /** Used to indicate that an app transition should be animated. */\n    static final boolean ANIMATE = true;\n\n    /** Hardware-reported OpenGLES version. */\n    final int GL_ES_VERSION;\n\n    public static final String DUMP_ACTIVITIES_CMD = \"activities\";\n    public static final String DUMP_ACTIVITIES_SHORT_CMD = \"a\";\n    public static final String DUMP_LASTANR_CMD = \"lastanr\";\n    public static final String DUMP_LASTANR_TRACES_CMD = \"lastanr-traces\";\n    public static final String DUMP_STARTER_CMD = \"starter\";\n    public static final String DUMP_CONTAINERS_CMD = \"containers\";\n    public static final String DUMP_RECENTS_CMD = \"recents\";\n    public static final String DUMP_RECENTS_SHORT_CMD = \"r\";\n    public static final String DUMP_TOP_RESUMED_ACTIVITY = \"top-resumed\";\n\n    /** This activity is not being relaunched, or being relaunched for a non-resize reason. */\n    public static final int RELAUNCH_REASON_NONE = 0;\n    /** This activity is being relaunched due to windowing mode change. */\n    public static final int RELAUNCH_REASON_WINDOWING_MODE_RESIZE = 1;\n    /** This activity is being relaunched due to a free-resize operation. */\n    public static final int RELAUNCH_REASON_FREE_RESIZE = 2;\n\n    Context mContext;\n\n    /**\n     * This Context is themable and meant for UI display (AlertDialogs, etc.). The theme can\n     * change at runtime. Use mContext for non-UI purposes.\n     */\n    final Context mUiContext;\n    final ActivityThread mSystemThread;\n    H mH;\n    UiHandler mUiHandler;\n    ActivityManagerInternal mAmInternal;\n    UriGrantsManagerInternal mUgmInternal;\n    private PackageManagerInternal mPmInternal;\n    /** The cached sys ui service component name from package manager. */\n    private ComponentName mSysUiServiceComponent;\n    private PermissionPolicyInternal mPermissionPolicyInternal;\n    private StatusBarManagerInternal mStatusBarManagerInternal;\n    @VisibleForTesting\n    final ActivityTaskManagerInternal mInternal;\n    private PowerManagerInternal mPowerManagerInternal;\n    private UsageStatsManagerInternal mUsageStatsInternal;\n\n    PendingIntentController mPendingIntentController;\n    IntentFirewall mIntentFirewall;\n\n    final VisibleActivityProcessTracker mVisibleActivityProcessTracker;\n\n    /* Global service lock used by the package the owns this service. */\n    final WindowManagerGlobalLock mGlobalLock = new WindowManagerGlobalLock();\n    /**\n     * It is the same instance as {@link #mGlobalLock}, just declared as a type that the\n     * locked-region-code-injection does't recognize it. It is used to skip wrapping priority\n     * booster for places that are already in the scope of another booster (e.g. computing oom-adj).\n     *\n     * @see WindowManagerThreadPriorityBooster\n     */\n    final Object mGlobalLockWithoutBoost = mGlobalLock;\n    ActivityTaskSupervisor mTaskSupervisor;\n    ActivityClientController mActivityClientController;\n    RootWindowContainer mRootWindowContainer;\n    WindowManagerService mWindowManager;\n    private UserManagerService mUserManager;\n    private AppOpsManager mAppOpsManager;\n    /** All active uids in the system. */\n    final MirrorActiveUids mActiveUids = new MirrorActiveUids();\n    private final SparseArray<String> mPendingTempAllowlist = new SparseArray<>();\n    /** All processes currently running that might have a window organized by name. */\n    final ProcessMap<WindowProcessController> mProcessNames = new ProcessMap<>();\n    /** All processes we currently have running mapped by pid and uid */\n    final WindowProcessControllerMap mProcessMap = new WindowProcessControllerMap();\n    /** This is the process holding what we currently consider to be the \"home\" activity. */\n    volatile WindowProcessController mHomeProcess;\n    /** The currently running heavy-weight process, if any. */\n    volatile WindowProcessController mHeavyWeightProcess;\n    boolean mHasHeavyWeightFeature;\n    boolean mHasLeanbackFeature;\n    /** The process of the top most activity. */\n    volatile WindowProcessController mTopApp;\n    /**\n     * This is the process holding the activity the user last visited that is in a different process\n     * from the one they are currently in.\n     */\n    volatile WindowProcessController mPreviousProcess;\n    /** The time at which the previous process was last visible. */\n    long mPreviousProcessVisibleTime;\n\n    /** List of intents that were used to start the most recent tasks. */\n    private RecentTasks mRecentTasks;\n    /** State of external calls telling us if the device is awake or asleep. */\n    private boolean mKeyguardShown = false;\n\n    // VoiceInteraction session ID that changes for each new request except when\n    // being called for multi-window assist in a single session.\n    private int mViSessionId = 1000;\n\n    // How long to wait in getAssistContextExtras for the activity and foreground services\n    // to respond with the result.\n    private static final int PENDING_ASSIST_EXTRAS_TIMEOUT = 500;\n\n    // How long top wait when going through the modern assist (which doesn't need to block\n    // on getting this result before starting to launch its UI).\n    private static final int PENDING_ASSIST_EXTRAS_LONG_TIMEOUT = 2000;\n\n    // How long to wait in getAutofillAssistStructure() for the activity to respond with the result.\n    private static final int PENDING_AUTOFILL_ASSIST_STRUCTURE_TIMEOUT = 2000;\n\n    // Permission tokens are used to temporarily granted a trusted app the ability to call\n    // #startActivityAsCaller.  A client is expected to dump its token after this time has elapsed,\n    // showing any appropriate error messages to the user.\n    private static final long START_AS_CALLER_TOKEN_TIMEOUT =\n            10 * MINUTE_IN_MILLIS;\n\n    // How long before the service actually expires a token.  This is slightly longer than\n    // START_AS_CALLER_TOKEN_TIMEOUT, to provide a buffer so clients will rarely encounter the\n    // expiration exception.\n    private static final long START_AS_CALLER_TOKEN_TIMEOUT_IMPL =\n            START_AS_CALLER_TOKEN_TIMEOUT + 2 * 1000;\n\n    // How long the service will remember expired tokens, for the purpose of providing error\n    // messaging when a client uses an expired token.\n    private static final long START_AS_CALLER_TOKEN_EXPIRED_TIMEOUT =\n            START_AS_CALLER_TOKEN_TIMEOUT_IMPL + 20 * MINUTE_IN_MILLIS;\n\n    // Activity tokens of system activities that are delegating their call to\n    // #startActivityByCaller, keyed by the permissionToken granted to the delegate.\n    final HashMap<IBinder, IBinder> mStartActivitySources = new HashMap<>();\n\n    // Permission tokens that have expired, but we remember for error reporting.\n    final ArrayList<IBinder> mExpiredStartAsCallerTokens = new ArrayList<>();\n\n    private final ArrayList<PendingAssistExtras> mPendingAssistExtras = new ArrayList<>();\n\n    // Keeps track of the active voice interaction service component, notified from\n    // VoiceInteractionManagerService\n    ComponentName mActiveVoiceInteractionServiceComponent;\n\n    // A map userId and all its companion app uids\n    private final Map<Integer, Set<Integer>> mCompanionAppUidsMap = new ArrayMap<>();\n\n    VrController mVrController;\n    KeyguardController mKeyguardController;\n    private final ClientLifecycleManager mLifecycleManager;\n    private TaskChangeNotificationController mTaskChangeNotificationController;\n    /** The controller for all operations related to locktask. */\n    private LockTaskController mLockTaskController;\n    private ActivityStartController mActivityStartController;\n    PackageConfigPersister mPackageConfigPersister;\n\n    boolean mSuppressResizeConfigChanges;\n\n    final UpdateConfigurationResult mTmpUpdateConfigurationResult =\n            new UpdateConfigurationResult();\n\n    static final class UpdateConfigurationResult {\n        // Configuration changes that were updated.\n        int changes;\n        // If the activity was relaunched to match the new configuration.\n        boolean activityRelaunched;\n\n        void reset() {\n            changes = 0;\n            activityRelaunched = false;\n        }\n    }\n\n    /** Current sequencing integer of the configuration, for skipping old configurations. */\n    private int mConfigurationSeq;\n\n    /** Current sequencing integer of the asset changes, for skipping old resources overlays. */\n    private int mGlobalAssetsSeq;\n\n    // To cache the list of supported system locales\n    private String[] mSupportedSystemLocales = null;\n\n    /**\n     * Temp object used when global and/or display override configuration is updated. It is also\n     * sent to outer world instead of {@link #getGlobalConfiguration} because we don't trust\n     * anyone...\n     */\n    private Configuration mTempConfig = new Configuration();\n\n    /** Temporary to avoid allocations. */\n    final StringBuilder mStringBuilder = new StringBuilder(256);\n\n    /**\n     * Whether normal application switches are allowed; a call to {@link #stopAppSwitches()\n     * disables this.\n     */\n    private volatile boolean mAppSwitchesAllowed = true;\n\n    /**\n     * Last stop app switches time, apps finished before this time cannot start background activity\n     * even if they are in grace period.\n     */\n    private volatile long mLastStopAppSwitchesTime;\n\n    private final List<AnrController> mAnrController = new ArrayList<>();\n    IActivityController mController = null;\n    boolean mControllerIsAMonkey = false;\n\n    final int mFactoryTest;\n\n    /** Used to control how we initialize the service. */\n    ComponentName mTopComponent;\n    String mTopAction = Intent.ACTION_MAIN;\n    String mTopData;\n\n    /** Profiling app information. */\n    String mProfileApp = null;\n    WindowProcessController mProfileProc = null;\n    ProfilerInfo mProfilerInfo = null;\n\n    /**\n     * Dump of the activity state at the time of the last ANR. Cleared after\n     * {@link WindowManagerService#LAST_ANR_LIFETIME_DURATION_MSECS}\n     */\n    String mLastANRState;\n\n    /**\n     * Used to retain an update lock when the foreground activity is in\n     * immersive mode.\n     */\n    private final UpdateLock mUpdateLock = new UpdateLock(\"immersive\");\n\n    /**\n     * Packages that are being allowed to perform unrestricted app switches.  Mapping is\n     * User -> Type -> uid.\n     */\n    final SparseArray<ArrayMap<String, Integer>> mAllowAppSwitchUids = new SparseArray<>();\n\n    /** The dimensions of the thumbnails in the Recents UI. */\n    private int mThumbnailWidth;\n    private int mThumbnailHeight;\n\n    /**\n     * Flag that indicates if multi-window is enabled.\n     *\n     * For any particular form of multi-window to be enabled, generic multi-window must be enabled\n     * in {@link com.android.internal.R.bool#config_supportsMultiWindow} config or\n     * {@link Settings.Global#DEVELOPMENT_FORCE_RESIZABLE_ACTIVITIES} development option set.\n     * At least one of the forms of multi-window must be enabled in order for this flag to be\n     * initialized to 'true'.\n     *\n     * @see #mSupportsSplitScreenMultiWindow\n     * @see #mSupportsFreeformWindowManagement\n     * @see #mSupportsPictureInPicture\n     * @see #mSupportsMultiDisplay\n     */\n    boolean mSupportsMultiWindow;\n    boolean mSupportsSplitScreenMultiWindow;\n    boolean mSupportsFreeformWindowManagement;\n    boolean mSupportsPictureInPicture;\n    boolean mSupportsMultiDisplay;\n    boolean mForceResizableActivities;\n\n    /** Development option to enable non resizable in multi window. */\n    // TODO(b/176061101) change the default value to false.\n    boolean mDevEnableNonResizableMultiWindow;\n\n    /**\n     * Whether the device supports non-resizable in multi windowing modes.\n     * -1: The device doesn't support non-resizable in multi windowing modes.\n     *  0: The device supports non-resizable in multi windowing modes only if this is a large\n     *     screen (smallest width >= {@link #mLargeScreenSmallestScreenWidthDp}).\n     *  1: The device always supports non-resizable in multi windowing modes.\n     */\n    int mSupportsNonResizableMultiWindow;\n\n    /**\n     * Whether the device checks activity min width/height to determine if it can be shown in multi\n     * windowing modes.\n     * -1: The device ignores activity min width/height when determining if it can be shown in multi\n     *     windowing modes.\n     *  0: If it is a small screen (smallest width < {@link #mLargeScreenSmallestScreenWidthDp}),\n     *     the device compares the activity min width/height with the min multi windowing modes\n     *     dimensions {@link #mMinPercentageMultiWindowSupportHeight} the device supports to\n     *     determine whether the activity can be shown in multi windowing modes\n     *  1: The device always compare the activity min width/height with the min multi windowing\n     *     modes dimensions {@link #mMinPercentageMultiWindowSupportHeight} the device supports to\n     *     determine whether it can be shown in multi windowing modes.\n     */\n    int mRespectsActivityMinWidthHeightMultiWindow;\n\n    /**\n     * This value is only used when the device checks activity min height to determine if it\n     * can be shown in multi windowing modes.\n     * If the activity min height is greater than this percentage of the display height in portrait,\n     * it will not be allowed to be shown in multi windowing modes.\n     * The value should be between [0 - 1].\n     */\n    float mMinPercentageMultiWindowSupportHeight;\n\n    /**\n     * This value is only used when the device checks activity min width to determine if it\n     * can be shown in multi windowing modes.\n     * If the activity min width is greater than this percentage of the display width in landscape,\n     * it will not be allowed to be shown in multi windowing modes.\n     * The value should be between [0 - 1].\n     */\n    float mMinPercentageMultiWindowSupportWidth;\n\n    /**\n     * If the display {@link Configuration#smallestScreenWidthDp} is greater or equal to this value,\n     * we will treat it as a large screen device, which will have some multi window features enabled\n     * by default.\n     */\n    int mLargeScreenSmallestScreenWidthDp;\n\n    final List<ActivityTaskManagerInternal.ScreenObserver> mScreenObservers = new ArrayList<>();\n\n    // VR Vr2d Display Id.\n    int mVr2dDisplayId = INVALID_DISPLAY;\n\n    /**\n     * Set while we are wanting to sleep, to prevent any\n     * activities from being started/resumed.\n     *\n     * TODO(b/33594039): Clarify the actual state transitions represented by mSleeping.\n     *\n     * Currently mSleeping is set to true when transitioning into the sleep state, and remains true\n     * while in the sleep state until there is a pending transition out of sleep, in which case\n     * mSleeping is set to false, and remains false while awake.\n     *\n     * Whether mSleeping can quickly toggled between true/false without the device actually\n     * display changing states is undefined.\n     */\n    private volatile boolean mSleeping;\n\n    /**\n     * The mDreaming state is set by the {@link DreamManagerService} when it receives a request to\n     * start/stop the dream. It is set to true shortly  before the {@link DreamService} is started.\n     * It is set to false after the {@link DreamService} is stopped.\n     */\n    private boolean mDreaming = false;\n\n    /**\n     * The process state used for processes that are running the top activities.\n     * This changes between TOP and TOP_SLEEPING to following mSleeping.\n     */\n    volatile int mTopProcessState = ActivityManager.PROCESS_STATE_TOP;\n\n    @Retention(RetentionPolicy.SOURCE)\n    @IntDef({\n            POWER_MODE_REASON_START_ACTIVITY,\n            POWER_MODE_REASON_FREEZE_DISPLAY,\n            POWER_MODE_REASON_ALL,\n    })\n    @interface PowerModeReason {}\n\n    static final int POWER_MODE_REASON_START_ACTIVITY = 1 << 0;\n    static final int POWER_MODE_REASON_FREEZE_DISPLAY = 1 << 1;\n    /** This can only be used by {@link #endLaunchPowerMode(int)}.*/\n    static final int POWER_MODE_REASON_ALL = (1 << 2) - 1;\n\n    /** The reasons to use {@link Mode#LAUNCH} power mode. */\n    private @PowerModeReason int mLaunchPowerModeReasons;\n\n    @Retention(RetentionPolicy.SOURCE)\n    @IntDef({\n            LAYOUT_REASON_CONFIG_CHANGED,\n            LAYOUT_REASON_VISIBILITY_CHANGED,\n    })\n    @interface LayoutReason {\n    }\n\n    static final int LAYOUT_REASON_CONFIG_CHANGED = 0x1;\n    static final int LAYOUT_REASON_VISIBILITY_CHANGED = 0x2;\n\n    /** The reasons to perform surface placement. */\n    @LayoutReason\n    private int mLayoutReasons;\n\n    // Whether we should show our dialogs (ANR, crash, etc) or just perform their default action\n    // automatically. Important for devices without direct input devices.\n    private boolean mShowDialogs = true;\n\n    /** Set if we are shutting down the system, similar to sleeping. */\n    boolean mShuttingDown = false;\n\n    /**\n     * We want to hold a wake lock while running a voice interaction session, since\n     * this may happen with the screen off and we need to keep the CPU running to\n     * be able to continue to interact with the user.\n     */\n    PowerManager.WakeLock mVoiceWakeLock;\n\n    /**\n     * Set while we are running a voice interaction. This overrides sleeping while it is active.\n     */\n    IVoiceInteractionSession mRunningVoice;\n\n    /**\n     * The last resumed activity. This is identical to the current resumed activity most\n     * of the time but could be different when we're pausing one activity before we resume\n     * another activity.\n     */\n    ActivityRecord mLastResumedActivity;\n\n    /**\n     * The activity that is currently being traced as the active resumed activity.\n     *\n     * @see #updateResumedAppTrace\n     */\n    @Nullable\n    private ActivityRecord mTracedResumedActivity;\n\n    /** If non-null, we are tracking the time the user spends in the currently focused app. */\n    AppTimeTracker mCurAppTimeTracker;\n\n    AppWarnings mAppWarnings;\n\n    /**\n     * Packages that the user has asked to have run in screen size\n     * compatibility mode instead of filling the screen.\n     */\n    CompatModePackages mCompatModePackages;\n\n    private SettingObserver mSettingsObserver;\n\n    WindowOrganizerController mWindowOrganizerController;\n    TaskOrganizerController mTaskOrganizerController;\n\n    @Nullable\n    private BackgroundActivityStartCallback mBackgroundActivityStartCallback;\n\n    private int[] mAccessibilityServiceUids = new int[0];\n\n    private int mDeviceOwnerUid = Process.INVALID_UID;\n\n    private final class SettingObserver extends ContentObserver {\n        private final Uri mFontScaleUri = Settings.System.getUriFor(FONT_SCALE);\n        private final Uri mHideErrorDialogsUri = Settings.Global.getUriFor(HIDE_ERROR_DIALOGS);\n        private final Uri mFontWeightAdjustmentUri = Settings.Secure.getUriFor(\n                Settings.Secure.FONT_WEIGHT_ADJUSTMENT);\n\n        SettingObserver() {\n            super(mH);\n            final ContentResolver resolver = mContext.getContentResolver();\n            resolver.registerContentObserver(mFontScaleUri, false, this, UserHandle.USER_ALL);\n            resolver.registerContentObserver(mHideErrorDialogsUri, false, this,\n                    UserHandle.USER_ALL);\n            resolver.registerContentObserver(\n                    mFontWeightAdjustmentUri, false, this, UserHandle.USER_ALL);\n        }\n\n        @Override\n        public void onChange(boolean selfChange, Collection<Uri> uris, int flags,\n                @UserIdInt int userId) {\n            for (Uri uri : uris) {\n                if (mFontScaleUri.equals(uri)) {\n                    updateFontScaleIfNeeded(userId);\n                } else if (mHideErrorDialogsUri.equals(uri)) {\n                    synchronized (mGlobalLock) {\n                        updateShouldShowDialogsLocked(getGlobalConfiguration());\n                    }\n                } else if (mFontWeightAdjustmentUri.equals(uri)) {\n                    updateFontWeightAdjustmentIfNeeded(userId);\n                }\n            }\n        }\n    }\n\n    /** Indicates that the method may be invoked frequently or is sensitive to performance. */\n    @Target(ElementType.METHOD)\n    @Retention(RetentionPolicy.SOURCE)\n    @interface HotPath {\n        int NONE = 0;\n        int OOM_ADJUSTMENT = 1;\n        int LRU_UPDATE = 2;\n        int PROCESS_CHANGE = 3;\n        int START_SERVICE = 4;\n\n        int caller() default NONE;\n    }\n\n    private final Runnable mUpdateOomAdjRunnable = new Runnable() {\n        @Override\n        public void run() {\n            mAmInternal.updateOomAdj();\n        }\n    };\n\n    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)\n    public ActivityTaskManagerService(Context context) {\n        mContext = context;\n        mFactoryTest = FactoryTest.getMode();\n        mSystemThread = ActivityThread.currentActivityThread();\n        mUiContext = mSystemThread.getSystemUiContext();\n        mLifecycleManager = new ClientLifecycleManager();\n        mVisibleActivityProcessTracker = new VisibleActivityProcessTracker(this);\n        mInternal = new LocalService();\n        GL_ES_VERSION = SystemProperties.getInt(\"ro.opengles.version\", GL_ES_VERSION_UNDEFINED);\n        mWindowOrganizerController = new WindowOrganizerController(this);\n        mTaskOrganizerController = mWindowOrganizerController.mTaskOrganizerController;\n    }\n\n    public void onSystemReady() {\n        synchronized (mGlobalLock) {\n            final PackageManager pm = mContext.getPackageManager();\n            mHasHeavyWeightFeature = pm.hasSystemFeature(FEATURE_CANT_SAVE_STATE);\n            mHasLeanbackFeature = pm.hasSystemFeature(FEATURE_LEANBACK);\n            mVrController.onSystemReady();\n            mRecentTasks.onSystemReadyLocked();\n            mTaskSupervisor.onSystemReady();\n            mActivityClientController.onSystemReady();\n        }\n    }\n\n    public void onInitPowerManagement() {\n        synchronized (mGlobalLock) {\n            mTaskSupervisor.initPowerManagement();\n            final PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);\n            mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);\n            mVoiceWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, \"*voice*\");\n            mVoiceWakeLock.setReferenceCounted(false);\n        }\n    }\n\n    public void installSystemProviders() {\n        mSettingsObserver = new SettingObserver();\n    }\n\n    public void retrieveSettings(ContentResolver resolver) {\n        final boolean freeformWindowManagement =\n                mContext.getPackageManager().hasSystemFeature(FEATURE_FREEFORM_WINDOW_MANAGEMENT)\n                        || Settings.Global.getInt(\n                        resolver, DEVELOPMENT_ENABLE_FREEFORM_WINDOWS_SUPPORT, 0) != 0;\n\n        final boolean supportsMultiWindow = ActivityTaskManager.supportsMultiWindow(mContext);\n        final boolean supportsPictureInPicture = supportsMultiWindow &&\n                mContext.getPackageManager().hasSystemFeature(FEATURE_PICTURE_IN_PICTURE);\n        final boolean supportsSplitScreenMultiWindow =\n                ActivityTaskManager.supportsSplitScreenMultiWindow(mContext);\n        final boolean supportsMultiDisplay = mContext.getPackageManager()\n                .hasSystemFeature(FEATURE_ACTIVITIES_ON_SECONDARY_DISPLAYS);\n        final boolean forceRtl = Settings.Global.getInt(resolver, DEVELOPMENT_FORCE_RTL, 0) != 0;\n        final boolean forceResizable = Settings.Global.getInt(\n                resolver, DEVELOPMENT_FORCE_RESIZABLE_ACTIVITIES, 0) != 0;\n        final boolean devEnableNonResizableMultiWindow = Settings.Global.getInt(\n                resolver, DEVELOPMENT_ENABLE_NON_RESIZABLE_MULTI_WINDOW, 0) != 0;\n        final int supportsNonResizableMultiWindow = mContext.getResources().getInteger(\n                com.android.internal.R.integer.config_supportsNonResizableMultiWindow);\n        final int respectsActivityMinWidthHeightMultiWindow = mContext.getResources().getInteger(\n                com.android.internal.R.integer.config_respectsActivityMinWidthHeightMultiWindow);\n        final float minPercentageMultiWindowSupportHeight = mContext.getResources().getFloat(\n                com.android.internal.R.dimen.config_minPercentageMultiWindowSupportHeight);\n        final float minPercentageMultiWindowSupportWidth = mContext.getResources().getFloat(\n                com.android.internal.R.dimen.config_minPercentageMultiWindowSupportWidth);\n        final int largeScreenSmallestScreenWidthDp = mContext.getResources().getInteger(\n                com.android.internal.R.integer.config_largeScreenSmallestScreenWidthDp);\n\n        // Transfer any global setting for forcing RTL layout, into a System Property\n        DisplayProperties.debug_force_rtl(forceRtl);\n\n        final Configuration configuration = new Configuration();\n        Settings.System.getConfiguration(resolver, configuration);\n        if (forceRtl) {\n            // This will take care of setting the correct layout direction flags\n            configuration.setLayoutDirection(configuration.locale);\n        }\n\n        synchronized (mGlobalLock) {\n            mForceResizableActivities = forceResizable;\n            mDevEnableNonResizableMultiWindow = devEnableNonResizableMultiWindow;\n            mSupportsNonResizableMultiWindow = supportsNonResizableMultiWindow;\n            mRespectsActivityMinWidthHeightMultiWindow = respectsActivityMinWidthHeightMultiWindow;\n            mMinPercentageMultiWindowSupportHeight = minPercentageMultiWindowSupportHeight;\n            mMinPercentageMultiWindowSupportWidth = minPercentageMultiWindowSupportWidth;\n            mLargeScreenSmallestScreenWidthDp = largeScreenSmallestScreenWidthDp;\n            final boolean multiWindowFormEnabled = freeformWindowManagement\n                    || supportsSplitScreenMultiWindow\n                    || supportsPictureInPicture\n                    || supportsMultiDisplay;\n            if ((supportsMultiWindow || forceResizable) && multiWindowFormEnabled) {\n                mSupportsMultiWindow = true;\n                mSupportsFreeformWindowManagement = freeformWindowManagement;\n                mSupportsSplitScreenMultiWindow = supportsSplitScreenMultiWindow;\n                mSupportsPictureInPicture = supportsPictureInPicture;\n                mSupportsMultiDisplay = supportsMultiDisplay;\n            } else {\n                mSupportsMultiWindow = false;\n                mSupportsFreeformWindowManagement = false;\n                mSupportsSplitScreenMultiWindow = false;\n                mSupportsPictureInPicture = false;\n                mSupportsMultiDisplay = false;\n            }\n            mWindowManager.mRoot.onSettingsRetrieved();\n            // This happens before any activities are started, so we can change global configuration\n            // in-place.\n            updateConfigurationLocked(configuration, null, true);\n            final Configuration globalConfig = getGlobalConfiguration();\n            ProtoLog.v(WM_DEBUG_CONFIGURATION, \"Initial config: %s\", globalConfig);\n\n            // Load resources only after the current configuration has been set.\n            final Resources res = mContext.getResources();\n            mThumbnailWidth = res.getDimensionPixelSize(\n                    com.android.internal.R.dimen.thumbnail_width);\n            mThumbnailHeight = res.getDimensionPixelSize(\n                    com.android.internal.R.dimen.thumbnail_height);\n        }\n    }\n\n    public WindowManagerGlobalLock getGlobalLock() {\n        return mGlobalLock;\n    }\n\n    /** For test purpose only. */\n    @VisibleForTesting\n    public ActivityTaskManagerInternal getAtmInternal() {\n        return mInternal;\n    }\n\n    public void initialize(IntentFirewall intentFirewall, PendingIntentController intentController,\n            Looper looper) {\n        mH = new H(looper);\n        mUiHandler = new UiHandler();\n        mIntentFirewall = intentFirewall;\n        final File systemDir = SystemServiceManager.ensureSystemDir();\n        mAppWarnings = createAppWarnings(mUiContext, mH, mUiHandler, systemDir);\n        mCompatModePackages = new CompatModePackages(this, systemDir, mH);\n        mPendingIntentController = intentController;\n        mTaskSupervisor = createTaskSupervisor();\n        mActivityClientController = new ActivityClientController(this);\n\n        mTaskChangeNotificationController =\n                new TaskChangeNotificationController(mGlobalLock, mTaskSupervisor, mH);\n        mLockTaskController = new LockTaskController(mContext, mTaskSupervisor, mH,\n                mTaskChangeNotificationController);\n        mActivityStartController = new ActivityStartController(this);\n        setRecentTasks(new RecentTasks(this, mTaskSupervisor));\n        mVrController = new VrController(mGlobalLock);\n        mKeyguardController = mTaskSupervisor.getKeyguardController();\n        mPackageConfigPersister = new PackageConfigPersister(mTaskSupervisor.mPersisterQueue);\n    }\n\n    public void onActivityManagerInternalAdded() {\n        synchronized (mGlobalLock) {\n            mAmInternal = LocalServices.getService(ActivityManagerInternal.class);\n            mUgmInternal = LocalServices.getService(UriGrantsManagerInternal.class);\n        }\n    }\n\n    int increaseConfigurationSeqLocked() {\n        mConfigurationSeq = Math.max(++mConfigurationSeq, 1);\n        return mConfigurationSeq;\n    }\n\n    protected ActivityTaskSupervisor createTaskSupervisor() {\n        final ActivityTaskSupervisor supervisor = new ActivityTaskSupervisor(this,\n                mH.getLooper());\n        supervisor.initialize();\n        return supervisor;\n    }\n\n    protected AppWarnings createAppWarnings(\n            Context uiContext, Handler handler, Handler uiHandler, File systemDir) {\n        return new AppWarnings(this, uiContext, handler, uiHandler, systemDir);\n    }\n\n    public void setWindowManager(WindowManagerService wm) {\n        synchronized (mGlobalLock) {\n            mWindowManager = wm;\n            mRootWindowContainer = wm.mRoot;\n            mTempConfig.setToDefaults();\n            mTempConfig.setLocales(LocaleList.getDefault());\n            mConfigurationSeq = mTempConfig.seq = 1;\n            mRootWindowContainer.onConfigurationChanged(mTempConfig);\n            mLockTaskController.setWindowManager(wm);\n            mTaskSupervisor.setWindowManager(wm);\n            mRootWindowContainer.setWindowManager(wm);\n        }\n    }\n\n    public void setUsageStatsManager(UsageStatsManagerInternal usageStatsManager) {\n        synchronized (mGlobalLock) {\n            mUsageStatsInternal = usageStatsManager;\n        }\n    }\n\n    UserManagerService getUserManager() {\n        if (mUserManager == null) {\n            IBinder b = ServiceManager.getService(Context.USER_SERVICE);\n            mUserManager = (UserManagerService) IUserManager.Stub.asInterface(b);\n        }\n        return mUserManager;\n    }\n\n    AppOpsManager getAppOpsManager() {\n        if (mAppOpsManager == null) {\n            mAppOpsManager = mContext.getSystemService(AppOpsManager.class);\n        }\n        return mAppOpsManager;\n    }\n\n    boolean hasUserRestriction(String restriction, int userId) {\n        return getUserManager().hasUserRestriction(restriction, userId);\n    }\n\n    boolean hasSystemAlertWindowPermission(int callingUid, int callingPid,\n            String callingPackage) {\n        final int mode = getAppOpsManager().noteOpNoThrow(AppOpsManager.OP_SYSTEM_ALERT_WINDOW,\n                callingUid, callingPackage, /* featureId */ null, \"\");\n        if (mode == AppOpsManager.MODE_DEFAULT) {\n            return checkPermission(Manifest.permission.SYSTEM_ALERT_WINDOW, callingPid, callingUid)\n                    == PERMISSION_GRANTED;\n        }\n        return mode == AppOpsManager.MODE_ALLOWED;\n    }\n\n    @VisibleForTesting\n    protected void setRecentTasks(RecentTasks recentTasks) {\n        mRecentTasks = recentTasks;\n        mTaskSupervisor.setRecentTasks(recentTasks);\n    }\n\n    RecentTasks getRecentTasks() {\n        return mRecentTasks;\n    }\n\n    ClientLifecycleManager getLifecycleManager() {\n        return mLifecycleManager;\n    }\n\n    ActivityStartController getActivityStartController() {\n        return mActivityStartController;\n    }\n\n    TaskChangeNotificationController getTaskChangeNotificationController() {\n        return mTaskChangeNotificationController;\n    }\n\n    LockTaskController getLockTaskController() {\n        return mLockTaskController;\n    }\n\n    TransitionController getTransitionController() {\n        return mWindowOrganizerController.getTransitionController();\n    }\n\n    /**\n     * Return the global configuration used by the process corresponding to the input pid. This is\n     * usually the global configuration with some overrides specific to that process.\n     */\n    Configuration getGlobalConfigurationForCallingPid() {\n        final int pid = Binder.getCallingPid();\n        return getGlobalConfigurationForPid(pid);\n    }\n\n    /**\n     * Return the global configuration used by the process corresponding to the given pid.\n     */\n    Configuration getGlobalConfigurationForPid(int pid) {\n        if (pid == MY_PID || pid < 0) {\n            return getGlobalConfiguration();\n        }\n        synchronized (mGlobalLock) {\n            final WindowProcessController app = mProcessMap.getProcess(pid);\n            return app != null ? app.getConfiguration() : getGlobalConfiguration();\n        }\n    }\n\n    /**\n     * Return the device configuration info used by the process corresponding to the input pid.\n     * The value is consistent with the global configuration for the process.\n     */\n    @Override\n    public ConfigurationInfo getDeviceConfigurationInfo() {\n        ConfigurationInfo config = new ConfigurationInfo();\n        synchronized (mGlobalLock) {\n            final Configuration globalConfig = getGlobalConfigurationForCallingPid();\n            config.reqTouchScreen = globalConfig.touchscreen;\n            config.reqKeyboardType = globalConfig.keyboard;\n            config.reqNavigation = globalConfig.navigation;\n            if (globalConfig.navigation == Configuration.NAVIGATION_DPAD\n                    || globalConfig.navigation == Configuration.NAVIGATION_TRACKBALL) {\n                config.reqInputFeatures |= ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;\n            }\n            if (globalConfig.keyboard != Configuration.KEYBOARD_UNDEFINED\n                    && globalConfig.keyboard != Configuration.KEYBOARD_NOKEYS) {\n                config.reqInputFeatures |= ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;\n            }\n            config.reqGlEsVersion = GL_ES_VERSION;\n        }\n        return config;\n    }\n\n    @Nullable\n    public BackgroundActivityStartCallback getBackgroundActivityStartCallback() {\n        return mBackgroundActivityStartCallback;\n    }\n\n    private void start() {\n        LocalServices.addService(ActivityTaskManagerInternal.class, mInternal);\n    }\n\n    public static final class Lifecycle extends SystemService {\n        private final ActivityTaskManagerService mService;\n\n        public Lifecycle(Context context) {\n            super(context);\n            mService = new ActivityTaskManagerService(context);\n        }\n\n        @Override\n        public void onStart() {\n            publishBinderService(Context.ACTIVITY_TASK_SERVICE, mService);\n            mService.start();\n        }\n\n        @Override\n        public void onUserUnlocked(@NonNull TargetUser user) {\n            synchronized (mService.getGlobalLock()) {\n                mService.mTaskSupervisor.onUserUnlocked(user.getUserIdentifier());\n            }\n        }\n\n        @Override\n        public void onUserStopped(@NonNull TargetUser user) {\n            synchronized (mService.getGlobalLock()) {\n                mService.mTaskSupervisor.mLaunchParamsPersister\n                        .onCleanupUser(user.getUserIdentifier());\n            }\n        }\n\n        public ActivityTaskManagerService getService() {\n            return mService;\n        }\n    }\n\n    @Override\n    public final int startActivity(IApplicationThread caller, String callingPackage,\n            String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,\n            String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo,\n            Bundle bOptions) {\n        return startActivityAsUser(caller, callingPackage, callingFeatureId, intent, resolvedType,\n                resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions,\n                UserHandle.getCallingUserId());\n    }\n\n    @Override\n    public final int startActivities(IApplicationThread caller, String callingPackage,\n            String callingFeatureId, Intent[] intents, String[] resolvedTypes, IBinder resultTo,\n            Bundle bOptions, int userId) {\n        assertPackageMatchesCallingUid(callingPackage);\n        final String reason = \"startActivities\";\n        enforceNotIsolatedCaller(reason);\n        userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, reason);\n        // TODO: Switch to user app stacks here.\n        return getActivityStartController().startActivities(caller, -1, 0, -1, callingPackage,\n                callingFeatureId, intents, resolvedTypes, resultTo,\n                SafeActivityOptions.fromBundle(bOptions), userId, reason,\n                null /* originatingPendingIntent */, false /* allowBackgroundActivityStart */);\n    }\n\n    @Override\n    public int startActivityAsUser(IApplicationThread caller, String callingPackage,\n            String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,\n            String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo,\n            Bundle bOptions, int userId) {\n        return startActivityAsUser(caller, callingPackage, callingFeatureId, intent, resolvedType,\n                resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, userId,\n                true /*validateIncomingUser*/);\n    }\n\n    private int startActivityAsUser(IApplicationThread caller, String callingPackage,\n            @Nullable String callingFeatureId, Intent intent, String resolvedType,\n            IBinder resultTo, String resultWho, int requestCode, int startFlags,\n            ProfilerInfo profilerInfo, Bundle bOptions, int userId, boolean validateIncomingUser) {\n        assertPackageMatchesCallingUid(callingPackage);\n        enforceNotIsolatedCaller(\"startActivityAsUser\");\n\n        userId = getActivityStartController().checkTargetUser(userId, validateIncomingUser,\n                Binder.getCallingPid(), Binder.getCallingUid(), \"startActivityAsUser\");\n\n        // TODO: Switch to user app stacks here.\n        return getActivityStartController().obtainStarter(intent, \"startActivityAsUser\")\n                .setCaller(caller)\n                .setCallingPackage(callingPackage)\n                .setCallingFeatureId(callingFeatureId)\n                .setResolvedType(resolvedType)\n                .setResultTo(resultTo)\n                .setResultWho(resultWho)\n                .setRequestCode(requestCode)\n                .setStartFlags(startFlags)\n                .setProfilerInfo(profilerInfo)\n                .setActivityOptions(bOptions)\n                .setUserId(userId)\n                .execute();\n\n    }\n\n    @Override\n    public int startActivityIntentSender(IApplicationThread caller, IIntentSender target,\n            IBinder allowlistToken, Intent fillInIntent, String resolvedType, IBinder resultTo,\n            String resultWho, int requestCode, int flagsMask, int flagsValues, Bundle bOptions) {\n        enforceNotIsolatedCaller(\"startActivityIntentSender\");\n        // Refuse possible leaked file descriptors\n        if (fillInIntent != null && fillInIntent.hasFileDescriptors()) {\n            throw new IllegalArgumentException(\"File descriptors passed in Intent\");\n        }\n\n        if (!(target instanceof PendingIntentRecord)) {\n            throw new IllegalArgumentException(\"Bad PendingIntent object\");\n        }\n\n        PendingIntentRecord pir = (PendingIntentRecord) target;\n\n        synchronized (mGlobalLock) {\n            // If this is coming from the currently resumed activity, it is\n            // effectively saying that app switches are allowed at this point.\n            final Task topFocusedRootTask = getTopDisplayFocusedRootTask();\n            if (topFocusedRootTask != null && topFocusedRootTask.getResumedActivity() != null\n                    && topFocusedRootTask.getResumedActivity().info.applicationInfo.uid\n                    == Binder.getCallingUid()) {\n                mAppSwitchesAllowed = true;\n            }\n        }\n        return pir.sendInner(0, fillInIntent, resolvedType, allowlistToken, null, null,\n                resultTo, resultWho, requestCode, flagsMask, flagsValues, bOptions);\n    }\n\n    @Override\n    public boolean startNextMatchingActivity(IBinder callingActivity, Intent intent,\n            Bundle bOptions) {\n        // Refuse possible leaked file descriptors\n        if (intent != null && intent.hasFileDescriptors()) {\n            throw new IllegalArgumentException(\"File descriptors passed in Intent\");\n        }\n        SafeActivityOptions options = SafeActivityOptions.fromBundle(bOptions);\n\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInRootTaskLocked(callingActivity);\n            if (r == null) {\n                SafeActivityOptions.abort(options);\n                return false;\n            }\n            if (!r.attachedToProcess()) {\n                // The caller is not running...  d'oh!\n                SafeActivityOptions.abort(options);\n                return false;\n            }\n            intent = new Intent(intent);\n            // The caller is not allowed to change the data.\n            intent.setDataAndType(r.intent.getData(), r.intent.getType());\n            // And we are resetting to find the next component...\n            intent.setComponent(null);\n\n            final boolean debug = ((intent.getFlags() & Intent.FLAG_DEBUG_LOG_RESOLUTION) != 0);\n\n            ActivityInfo aInfo = null;\n            try {\n                List<ResolveInfo> resolves =\n                        AppGlobals.getPackageManager().queryIntentActivities(\n                                intent, r.resolvedType,\n                                PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS,\n                                UserHandle.getCallingUserId()).getList();\n\n                // Look for the original activity in the list...\n                final int N = resolves != null ? resolves.size() : 0;\n                for (int i = 0; i < N; i++) {\n                    ResolveInfo rInfo = resolves.get(i);\n                    if (rInfo.activityInfo.packageName.equals(r.packageName)\n                            && rInfo.activityInfo.name.equals(r.info.name)) {\n                        // We found the current one...  the next matching is\n                        // after it.\n                        i++;\n                        if (i < N) {\n                            aInfo = resolves.get(i).activityInfo;\n                        }\n                        if (debug) {\n                            Slog.v(TAG, \"Next matching activity: found current \" + r.packageName\n                                    + \"/\" + r.info.name);\n                            Slog.v(TAG, \"Next matching activity: next is \" + ((aInfo == null)\n                                    ? \"null\" : aInfo.packageName + \"/\" + aInfo.name));\n                        }\n                        break;\n                    }\n                }\n            } catch (RemoteException e) {\n            }\n\n            if (aInfo == null) {\n                // Nobody who is next!\n                SafeActivityOptions.abort(options);\n                if (debug) Slog.d(TAG, \"Next matching activity: nothing found\");\n                return false;\n            }\n\n            intent.setComponent(new ComponentName(\n                    aInfo.applicationInfo.packageName, aInfo.name));\n            intent.setFlags(intent.getFlags() & ~(Intent.FLAG_ACTIVITY_FORWARD_RESULT\n                    | Intent.FLAG_ACTIVITY_CLEAR_TOP\n                    | Intent.FLAG_ACTIVITY_MULTIPLE_TASK\n                    | FLAG_ACTIVITY_NEW_TASK));\n\n            // Okay now we need to start the new activity, replacing the currently running activity.\n            // This is a little tricky because we want to start the new one as if the current one is\n            // finished, but not finish the current one first so that there is no flicker.\n            // And thus...\n            final boolean wasFinishing = r.finishing;\n            r.finishing = true;\n\n            // Propagate reply information over to the new activity.\n            final ActivityRecord resultTo = r.resultTo;\n            final String resultWho = r.resultWho;\n            final int requestCode = r.requestCode;\n            r.resultTo = null;\n            if (resultTo != null) {\n                resultTo.removeResultsLocked(r, resultWho, requestCode);\n            }\n\n            final long origId = Binder.clearCallingIdentity();\n            // TODO(b/64750076): Check if calling pid should really be -1.\n            final int res = getActivityStartController()\n                    .obtainStarter(intent, \"startNextMatchingActivity\")\n                    .setCaller(r.app.getThread())\n                    .setResolvedType(r.resolvedType)\n                    .setActivityInfo(aInfo)\n                    .setResultTo(resultTo != null ? resultTo.appToken : null)\n                    .setResultWho(resultWho)\n                    .setRequestCode(requestCode)\n                    .setCallingPid(-1)\n                    .setCallingUid(r.launchedFromUid)\n                    .setCallingPackage(r.launchedFromPackage)\n                    .setCallingFeatureId(r.launchedFromFeatureId)\n                    .setRealCallingPid(-1)\n                    .setRealCallingUid(r.launchedFromUid)\n                    .setActivityOptions(options)\n                    .execute();\n            Binder.restoreCallingIdentity(origId);\n\n            r.finishing = wasFinishing;\n            if (res != ActivityManager.START_SUCCESS) {\n                return false;\n            }\n            return true;\n        }\n    }\n\n    private void enforceCallerIsDream(String callerPackageName) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            if (!ActivityRecord.canLaunchDreamActivity(callerPackageName)) {\n                throw new SecurityException(\"The dream activity can be started only when the device\"\n                        + \" is dreaming and only by the active dream package.\");\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public boolean startDreamActivity(@NonNull Intent intent) {\n        assertPackageMatchesCallingUid(intent.getPackage());\n        enforceCallerIsDream(intent.getPackage());\n\n        final ActivityInfo a = new ActivityInfo();\n        a.theme = com.android.internal.R.style.Theme_Dream;\n        a.exported = true;\n        a.name = DreamActivity.class.getName();\n        a.enabled = true;\n        a.launchMode = ActivityInfo.LAUNCH_SINGLE_INSTANCE;\n        a.persistableMode = ActivityInfo.PERSIST_NEVER;\n        a.screenOrientation = ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;\n        a.colorMode = ActivityInfo.COLOR_MODE_DEFAULT;\n        a.flags |= ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;\n        a.resizeMode = RESIZE_MODE_UNRESIZEABLE;\n\n        final ActivityOptions options = ActivityOptions.makeBasic();\n        options.setLaunchActivityType(ACTIVITY_TYPE_DREAM);\n\n        synchronized (mGlobalLock) {\n            final WindowProcessController process = mProcessMap.getProcess(Binder.getCallingPid());\n\n            a.packageName = process.mInfo.packageName;\n            a.applicationInfo = process.mInfo;\n            a.processName = process.mInfo.processName;\n            a.uiOptions = process.mInfo.uiOptions;\n            a.taskAffinity = \"android:\" + a.packageName + \"/dream\";\n\n            final int callingUid = Binder.getCallingUid();\n            final int callingPid = Binder.getCallingPid();\n\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                getActivityStartController().obtainStarter(intent, \"dream\")\n                        .setCallingUid(callingUid)\n                        .setCallingPid(callingPid)\n                        .setCallingPackage(intent.getPackage())\n                        .setActivityInfo(a)\n                        .setActivityOptions(options.toBundle())\n                        // To start the dream from background, we need to start it from a persistent\n                        // system process. Here we set the real calling uid to the system server uid\n                        .setRealCallingUid(Binder.getCallingUid())\n                        .setAllowBackgroundActivityStart(true)\n                        .execute();\n                return true;\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public final WaitResult startActivityAndWait(IApplicationThread caller, String callingPackage,\n            String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,\n            String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo,\n            Bundle bOptions, int userId) {\n        assertPackageMatchesCallingUid(callingPackage);\n        final WaitResult res = new WaitResult();\n        enforceNotIsolatedCaller(\"startActivityAndWait\");\n        userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),\n                userId, \"startActivityAndWait\");\n        // TODO: Switch to user app stacks here.\n        getActivityStartController().obtainStarter(intent, \"startActivityAndWait\")\n                .setCaller(caller)\n                .setCallingPackage(callingPackage)\n                .setCallingFeatureId(callingFeatureId)\n                .setResolvedType(resolvedType)\n                .setResultTo(resultTo)\n                .setResultWho(resultWho)\n                .setRequestCode(requestCode)\n                .setStartFlags(startFlags)\n                .setActivityOptions(bOptions)\n                .setUserId(userId)\n                .setProfilerInfo(profilerInfo)\n                .setWaitResult(res)\n                .execute();\n        return res;\n    }\n\n    @Override\n    public final int startActivityWithConfig(IApplicationThread caller, String callingPackage,\n            String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,\n            String resultWho, int requestCode, int startFlags, Configuration config,\n            Bundle bOptions, int userId) {\n        assertPackageMatchesCallingUid(callingPackage);\n        enforceNotIsolatedCaller(\"startActivityWithConfig\");\n        userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,\n                \"startActivityWithConfig\");\n        // TODO: Switch to user app stacks here.\n        return getActivityStartController().obtainStarter(intent, \"startActivityWithConfig\")\n                .setCaller(caller)\n                .setCallingPackage(callingPackage)\n                .setCallingFeatureId(callingFeatureId)\n                .setResolvedType(resolvedType)\n                .setResultTo(resultTo)\n                .setResultWho(resultWho)\n                .setRequestCode(requestCode)\n                .setStartFlags(startFlags)\n                .setGlobalConfiguration(config)\n                .setActivityOptions(bOptions)\n                .setUserId(userId)\n                .execute();\n    }\n\n    @Override\n    public IBinder requestStartActivityPermissionToken(IBinder delegatorToken) {\n        int callingUid = Binder.getCallingUid();\n        if (UserHandle.getAppId(callingUid) != SYSTEM_UID) {\n            throw new SecurityException(\"Only the system process can request a permission token, \"\n                    + \"received request from uid: \" + callingUid);\n        }\n        IBinder permissionToken = new Binder();\n        synchronized (mGlobalLock) {\n            mStartActivitySources.put(permissionToken, delegatorToken);\n        }\n\n        Message expireMsg = PooledLambda.obtainMessage(\n                ActivityTaskManagerService::expireStartAsCallerTokenMsg, this, permissionToken);\n        mUiHandler.sendMessageDelayed(expireMsg, START_AS_CALLER_TOKEN_TIMEOUT_IMPL);\n\n        Message forgetMsg = PooledLambda.obtainMessage(\n                ActivityTaskManagerService::forgetStartAsCallerTokenMsg, this, permissionToken);\n        mUiHandler.sendMessageDelayed(forgetMsg, START_AS_CALLER_TOKEN_EXPIRED_TIMEOUT);\n\n        return permissionToken;\n    }\n\n    @Override\n    public final int startActivityAsCaller(IApplicationThread caller, String callingPackage,\n            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, IBinder permissionToken,\n            boolean ignoreTargetSecurity, int userId) {\n        // This is very dangerous -- it allows you to perform a start activity (including\n        // permission grants) as any app that may launch one of your own activities.  So we only\n        // allow this in two cases:\n        // 1)  The caller is an activity that is part of the core framework, and then only when it\n        //     is running as the system.\n        // 2)  The caller provides a valid permissionToken.  Permission tokens are one-time use and\n        //     can only be requested by a system activity, which may then delegate this call to\n        //     another app.\n        final ActivityRecord sourceRecord;\n        final int targetUid;\n        final String targetPackage;\n        final String targetFeatureId;\n        final boolean isResolver;\n        synchronized (mGlobalLock) {\n            if (resultTo == null) {\n                throw new SecurityException(\"Must be called from an activity\");\n            }\n            final IBinder sourceToken;\n            if (permissionToken != null) {\n                // To even attempt to use a permissionToken, an app must also have this signature\n                // permission.\n                mAmInternal.enforceCallingPermission(\n                        android.Manifest.permission.START_ACTIVITY_AS_CALLER,\n                        \"startActivityAsCaller\");\n                // If called with a permissionToken, we want the sourceRecord from the delegator\n                // activity that requested this token.\n                sourceToken = mStartActivitySources.remove(permissionToken);\n                if (sourceToken == null) {\n                    // Invalid permissionToken, check if it recently expired.\n                    if (mExpiredStartAsCallerTokens.contains(permissionToken)) {\n                        throw new SecurityException(\"Called with expired permission token: \"\n                                + permissionToken);\n                    } else {\n                        throw new SecurityException(\"Called with invalid permission token: \"\n                                + permissionToken);\n                    }\n                }\n            } else {\n                // This method was called directly by the source.\n                sourceToken = resultTo;\n            }\n\n            sourceRecord = mRootWindowContainer.isInAnyTask(sourceToken);\n            if (sourceRecord == null) {\n                throw new SecurityException(\"Called with bad activity token: \" + sourceToken);\n            }\n            if (sourceRecord.app == null) {\n                throw new SecurityException(\"Called without a process attached to activity\");\n            }\n\n            // Whether called directly or from a delegate, the source activity must be from the\n            // android package.\n            if (!sourceRecord.info.packageName.equals(\"android\")) {\n                throw new SecurityException(\"Must be called from an activity that is \"\n                        + \"declared in the android package\");\n            }\n\n            if (UserHandle.getAppId(sourceRecord.app.mUid) != SYSTEM_UID) {\n                // This is still okay, as long as this activity is running under the\n                // uid of the original calling activity.\n                if (sourceRecord.app.mUid != sourceRecord.launchedFromUid) {\n                    throw new SecurityException(\n                            \"Calling activity in uid \" + sourceRecord.app.mUid\n                                    + \" must be system uid or original calling uid \"\n                                    + sourceRecord.launchedFromUid);\n                }\n            }\n            if (ignoreTargetSecurity) {\n                if (intent.getComponent() == null) {\n                    throw new SecurityException(\n                            \"Component must be specified with ignoreTargetSecurity\");\n                }\n                if (intent.getSelector() != null) {\n                    throw new SecurityException(\n                            \"Selector not allowed with ignoreTargetSecurity\");\n                }\n            }\n            targetUid = sourceRecord.launchedFromUid;\n            targetPackage = sourceRecord.launchedFromPackage;\n            targetFeatureId = sourceRecord.launchedFromFeatureId;\n            isResolver = sourceRecord.isResolverOrChildActivity();\n        }\n\n        if (userId == UserHandle.USER_NULL) {\n            userId = UserHandle.getUserId(sourceRecord.app.mUid);\n        }\n\n        // TODO: Switch to user app stacks here.\n        try {\n            return getActivityStartController().obtainStarter(intent, \"startActivityAsCaller\")\n                    .setCallingUid(targetUid)\n                    .setCallingPackage(targetPackage)\n                    .setCallingFeatureId(targetFeatureId)\n                    .setResolvedType(resolvedType)\n                    .setResultTo(resultTo)\n                    .setResultWho(resultWho)\n                    .setRequestCode(requestCode)\n                    .setStartFlags(startFlags)\n                    .setActivityOptions(bOptions)\n                    .setUserId(userId)\n                    .setIgnoreTargetSecurity(ignoreTargetSecurity)\n                    .setFilterCallingUid(isResolver ? 0 /* system */ : targetUid)\n                    // The target may well be in the background, which would normally prevent it\n                    // from starting an activity. Here we definitely want the start to succeed.\n                    .setAllowBackgroundActivityStart(true)\n                    .execute();\n        } catch (SecurityException e) {\n            // XXX need to figure out how to propagate to original app.\n            // A SecurityException here is generally actually a fault of the original\n            // calling activity (such as a fairly granting permissions), so propagate it\n            // back to them.\n            /*\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"While launching\");\n            msg.append(intent.toString());\n            msg.append(\": \");\n            msg.append(e.getMessage());\n            */\n            throw e;\n        }\n    }\n\n    int handleIncomingUser(int callingPid, int callingUid, int userId, String name) {\n        return mAmInternal.handleIncomingUser(callingPid, callingUid, userId, false /* allowAll */,\n                ALLOW_NON_FULL, name, null /* callerPackage */);\n    }\n\n    @Override\n    public int startVoiceActivity(String callingPackage, String callingFeatureId, int callingPid,\n            int callingUid, Intent intent, String resolvedType, IVoiceInteractionSession session,\n            IVoiceInteractor interactor, int startFlags, ProfilerInfo profilerInfo,\n            Bundle bOptions, int userId) {\n        assertPackageMatchesCallingUid(callingPackage);\n        mAmInternal.enforceCallingPermission(BIND_VOICE_INTERACTION, \"startVoiceActivity()\");\n        if (session == null || interactor == null) {\n            throw new NullPointerException(\"null session or interactor\");\n        }\n        userId = handleIncomingUser(callingPid, callingUid, userId, \"startVoiceActivity\");\n        // TODO: Switch to user app stacks here.\n        return getActivityStartController().obtainStarter(intent, \"startVoiceActivity\")\n                .setCallingUid(callingUid)\n                .setCallingPackage(callingPackage)\n                .setCallingFeatureId(callingFeatureId)\n                .setResolvedType(resolvedType)\n                .setVoiceSession(session)\n                .setVoiceInteractor(interactor)\n                .setStartFlags(startFlags)\n                .setProfilerInfo(profilerInfo)\n                .setActivityOptions(bOptions)\n                .setUserId(userId)\n                .setAllowBackgroundActivityStart(true)\n                .execute();\n    }\n\n    @Override\n    public int startAssistantActivity(String callingPackage, @NonNull String callingFeatureId,\n            int callingPid, int callingUid, Intent intent, String resolvedType, Bundle bOptions,\n            int userId) {\n        assertPackageMatchesCallingUid(callingPackage);\n        mAmInternal.enforceCallingPermission(BIND_VOICE_INTERACTION, \"startAssistantActivity()\");\n        userId = handleIncomingUser(callingPid, callingUid, userId, \"startAssistantActivity\");\n\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            return getActivityStartController().obtainStarter(intent, \"startAssistantActivity\")\n                    .setCallingUid(callingUid)\n                    .setCallingPackage(callingPackage)\n                    .setCallingFeatureId(callingFeatureId)\n                    .setResolvedType(resolvedType)\n                    .setActivityOptions(bOptions)\n                    .setUserId(userId)\n                    .setAllowBackgroundActivityStart(true)\n                    .execute();\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    /**\n     * Start the recents activity to perform the recents animation.\n     *\n     * @param intent                 The intent to start the recents activity.\n     * @param eventTime              When the (touch) event is triggered to start recents activity.\n     * @param recentsAnimationRunner Pass {@code null} to only preload the activity.\n     */\n    @Override\n    public void startRecentsActivity(Intent intent, long eventTime,\n            @Nullable IRecentsAnimationRunner recentsAnimationRunner) {\n        enforceTaskPermission(\"startRecentsActivity()\");\n        final int callingPid = Binder.getCallingPid();\n        final int callingUid = Binder.getCallingUid();\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ComponentName recentsComponent = mRecentTasks.getRecentsComponent();\n                final String recentsFeatureId = mRecentTasks.getRecentsComponentFeatureId();\n                final int recentsUid = mRecentTasks.getRecentsComponentUid();\n                final WindowProcessController caller = getProcessController(callingPid, callingUid);\n\n                // Start a new recents animation\n                final RecentsAnimation anim = new RecentsAnimation(this, mTaskSupervisor,\n                        getActivityStartController(), mWindowManager, intent, recentsComponent,\n                        recentsFeatureId, recentsUid, caller);\n                if (recentsAnimationRunner == null) {\n                    anim.preloadRecentsActivity();\n                } else {\n                    anim.startRecentsActivity(recentsAnimationRunner, eventTime);\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public final int startActivityFromRecents(int taskId, Bundle bOptions) {\n        mAmInternal.enforceCallingPermission(START_TASKS_FROM_RECENTS,\n                \"startActivityFromRecents()\");\n\n        final int callingPid = Binder.getCallingPid();\n        final int callingUid = Binder.getCallingUid();\n        final SafeActivityOptions safeOptions = SafeActivityOptions.fromBundle(bOptions);\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                return mTaskSupervisor.startActivityFromRecents(callingPid, callingUid, taskId,\n                        safeOptions);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    /**\n     * Public API to check if the client is allowed to start an activity on specified display.\n     *\n     * If the target display is private or virtual, some restrictions will apply.\n     *\n     * @param displayId    Target display id.\n     * @param intent       Intent used to launch the activity.\n     * @param resolvedType The MIME type of the intent.\n     * @param userId       The id of the user for whom the call is made.\n     * @return {@code true} if a call to start an activity on the target display should succeed and\n     * no {@link SecurityException} will be thrown, {@code false} otherwise.\n     */\n    @Override\n    public final boolean isActivityStartAllowedOnDisplay(int displayId, Intent intent,\n            String resolvedType, int userId) {\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        final long origId = Binder.clearCallingIdentity();\n\n        try {\n            // Collect information about the target of the Intent.\n            final ActivityInfo aInfo = resolveActivityInfoForIntent(intent, resolvedType, userId,\n                    callingUid);\n\n            synchronized (mGlobalLock) {\n                return mTaskSupervisor.canPlaceEntityOnDisplay(displayId, callingPid, callingUid,\n                        aInfo);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    ActivityInfo resolveActivityInfoForIntent(Intent intent, String resolvedType,\n            int userId, int callingUid) {\n        ActivityInfo aInfo = mTaskSupervisor.resolveActivity(intent, resolvedType,\n                0 /* startFlags */, null /* profilerInfo */, userId,\n                ActivityStarter.computeResolveFilterUid(callingUid, callingUid,\n                        UserHandle.USER_NULL));\n        return mAmInternal.getActivityInfoForUser(aInfo, userId);\n    }\n\n    @Override\n    public IActivityClientController getActivityClientController() {\n        return mActivityClientController;\n    }\n\n    void applyUpdateLockStateLocked(ActivityRecord r) {\n        // Modifications to the UpdateLock state are done on our handler, outside\n        // the activity manager's locks.  The new state is determined based on the\n        // state *now* of the relevant activity record.  The object is passed to\n        // the handler solely for logging detail, not to be consulted/modified.\n        final boolean nextState = r != null && r.immersive;\n        mH.post(() -> {\n            if (mUpdateLock.isHeld() != nextState) {\n                ProtoLog.d(WM_DEBUG_IMMERSIVE, \"Applying new update lock state '%s' for %s\",\n                        nextState, r);\n                if (nextState) {\n                    mUpdateLock.acquire();\n                } else {\n                    mUpdateLock.release();\n                }\n            }\n        });\n    }\n\n    @Override\n    public boolean isTopActivityImmersive() {\n        enforceNotIsolatedCaller(\"isTopActivityImmersive\");\n        synchronized (mGlobalLock) {\n            final Task topFocusedRootTask = getTopDisplayFocusedRootTask();\n            if (topFocusedRootTask == null) {\n                return false;\n            }\n\n            final ActivityRecord r = topFocusedRootTask.topRunningActivity();\n            return r != null && r.immersive;\n        }\n    }\n\n    @Override\n    public int getFrontActivityScreenCompatMode() {\n        enforceNotIsolatedCaller(\"getFrontActivityScreenCompatMode\");\n        synchronized (mGlobalLock) {\n            final Task rootTask = getTopDisplayFocusedRootTask();\n            final ActivityRecord r = rootTask != null ? rootTask.topRunningActivity() : null;\n            if (r == null) {\n                return ActivityManager.COMPAT_MODE_UNKNOWN;\n            }\n            return mCompatModePackages.computeCompatModeLocked(r.info.applicationInfo);\n        }\n    }\n\n    @Override\n    public void setFrontActivityScreenCompatMode(int mode) {\n        mAmInternal.enforceCallingPermission(android.Manifest.permission.SET_SCREEN_COMPATIBILITY,\n                \"setFrontActivityScreenCompatMode\");\n        ApplicationInfo ai;\n        synchronized (mGlobalLock) {\n            final Task rootTask = getTopDisplayFocusedRootTask();\n            final ActivityRecord r = rootTask != null ? rootTask.topRunningActivity() : null;\n            if (r == null) {\n                Slog.w(TAG, \"setFrontActivityScreenCompatMode failed: no top activity\");\n                return;\n            }\n            ai = r.info.applicationInfo;\n            mCompatModePackages.setPackageScreenCompatModeLocked(ai, mode);\n        }\n    }\n\n\n    @Override\n    public RootTaskInfo getFocusedRootTaskInfo() throws RemoteException {\n        enforceTaskPermission(\"getFocusedRootTaskInfo()\");\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                Task focusedRootTask = getTopDisplayFocusedRootTask();\n                if (focusedRootTask != null) {\n                    return mRootWindowContainer.getRootTaskInfo(focusedRootTask.mTaskId);\n                }\n                return null;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public void setFocusedRootTask(int taskId) {\n        enforceTaskPermission(\"setFocusedRootTask()\");\n        ProtoLog.d(WM_DEBUG_FOCUS, \"setFocusedRootTask: taskId=%d\", taskId);\n        final long callingId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final Task task = mRootWindowContainer.getRootTask(taskId);\n                if (task == null) {\n                    Slog.w(TAG, \"setFocusedRootTask: No task with id=\" + taskId);\n                    return;\n                }\n                final ActivityRecord r = task.topRunningActivity();\n                if (r != null && r.moveFocusableActivityToTop(\"setFocusedRootTask\")) {\n                    mRootWindowContainer.resumeFocusedTasksTopActivities();\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(callingId);\n        }\n    }\n\n    @Override\n    public void setFocusedTask(int taskId) {\n        enforceTaskPermission(\"setFocusedTask()\");\n        ProtoLog.d(WM_DEBUG_FOCUS, \"setFocusedTask: taskId=%d\", taskId);\n        final long callingId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final Task task = mRootWindowContainer.anyTaskForId(taskId,\n                        MATCH_ATTACHED_TASK_ONLY);\n                if (task == null) {\n                    return;\n                }\n                final ActivityRecord r = task.topRunningActivityLocked();\n                if (r != null && r.moveFocusableActivityToTop(\"setFocusedTask\")) {\n                    mRootWindowContainer.resumeFocusedTasksTopActivities();\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(callingId);\n        }\n    }\n\n    @Override\n    public boolean removeTask(int taskId) {\n        mAmInternal.enforceCallingPermission(REMOVE_TASKS, \"removeTask()\");\n        synchronized (mGlobalLock) {\n            final long ident = Binder.clearCallingIdentity();\n            try {\n                final Task task = mRootWindowContainer.anyTaskForId(taskId,\n                        MATCH_ATTACHED_TASK_OR_RECENT_TASKS);\n                if (task == null) {\n                    Slog.w(TAG, \"removeTask: No task remove with id=\" + taskId);\n                    return false;\n                }\n\n                if (task.isLeafTask()) {\n                    mTaskSupervisor.removeTask(task, true, REMOVE_FROM_RECENTS, \"remove-task\");\n                } else {\n                    mTaskSupervisor.removeRootTask(task);\n                }\n                return true;\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n    }\n\n    @Override\n    public void removeAllVisibleRecentTasks() {\n        mAmInternal.enforceCallingPermission(REMOVE_TASKS, \"removeAllVisibleRecentTasks()\");\n        synchronized (mGlobalLock) {\n            final long ident = Binder.clearCallingIdentity();\n            try {\n                getRecentTasks().removeAllVisibleTasks(mAmInternal.getCurrentUserId());\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n    }\n\n    @Override\n    public Rect getTaskBounds(int taskId) {\n        enforceTaskPermission(\"getTaskBounds()\");\n        final long ident = Binder.clearCallingIdentity();\n        Rect rect = new Rect();\n        try {\n            synchronized (mGlobalLock) {\n                final Task task = mRootWindowContainer.anyTaskForId(taskId,\n                        MATCH_ATTACHED_TASK_OR_RECENT_TASKS);\n                if (task == null) {\n                    Slog.w(TAG, \"getTaskBounds: taskId=\" + taskId + \" not found\");\n                    return rect;\n                }\n                if (task.getParent() != null) {\n                    rect.set(task.getBounds());\n                } else if (task.mLastNonFullscreenBounds != null) {\n                    rect.set(task.mLastNonFullscreenBounds);\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n        return rect;\n    }\n\n    @Override\n    public ActivityManager.TaskDescription getTaskDescription(int id) {\n        synchronized (mGlobalLock) {\n            enforceTaskPermission(\"getTaskDescription()\");\n            final Task tr = mRootWindowContainer.anyTaskForId(id,\n                    MATCH_ATTACHED_TASK_OR_RECENT_TASKS);\n            if (tr != null) {\n                return tr.getTaskDescription();\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Sets the locusId for a particular activity.\n     *\n     * @param locusId the locusId to set.\n     * @param appToken the ActivityRecord's appToken.\n     */\n    public void setLocusId(LocusId locusId, IBinder appToken) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInRootTaskLocked(appToken);\n            if (r != null) {\n                r.setLocusId(locusId);\n            }\n        }\n    }\n\n    NeededUriGrants collectGrants(Intent intent, ActivityRecord target) {\n        if (target != null) {\n            return mUgmInternal.checkGrantUriPermissionFromIntent(intent,\n                    Binder.getCallingUid(), target.packageName, target.mUserId);\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public void unhandledBack() {\n        mAmInternal.enforceCallingPermission(android.Manifest.permission.FORCE_BACK,\n                \"unhandledBack()\");\n\n        synchronized (mGlobalLock) {\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                final Task topFocusedRootTask = getTopDisplayFocusedRootTask();\n                if (topFocusedRootTask != null) {\n                    topFocusedRootTask.unhandledBackLocked();\n                }\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    /**\n     * TODO: Add mController hook\n     */\n    @Override\n    public void moveTaskToFront(IApplicationThread appThread, String callingPackage, int taskId,\n            int flags, Bundle bOptions) {\n        mAmInternal.enforceCallingPermission(android.Manifest.permission.REORDER_TASKS,\n                \"moveTaskToFront()\");\n\n        ProtoLog.d(WM_DEBUG_TASKS, \"moveTaskToFront: moving taskId=%d\", taskId);\n        synchronized (mGlobalLock) {\n            moveTaskToFrontLocked(appThread, callingPackage, taskId, flags,\n                    SafeActivityOptions.fromBundle(bOptions));\n        }\n    }\n\n    void moveTaskToFrontLocked(@Nullable IApplicationThread appThread,\n            @Nullable String callingPackage, int taskId, int flags, SafeActivityOptions options) {\n        final int callingPid = Binder.getCallingPid();\n        final int callingUid = Binder.getCallingUid();\n        assertPackageMatchesCallingUid(callingPackage);\n\n        final long origId = Binder.clearCallingIdentity();\n        WindowProcessController callerApp = null;\n        if (appThread != null) {\n            callerApp = getProcessController(appThread);\n        }\n        final ActivityStarter starter = getActivityStartController().obtainStarter(\n                null /* intent */, \"moveTaskToFront\");\n        if (starter.shouldAbortBackgroundActivityStart(callingUid, callingPid, callingPackage, -1,\n                -1, callerApp, null, false, null, null)) {\n            if (!isBackgroundActivityStartsEnabled()) {\n                return;\n            }\n        }\n        try {\n            final Task task = mRootWindowContainer.anyTaskForId(taskId);\n            if (task == null) {\n                ProtoLog.d(WM_DEBUG_TASKS, \"Could not find task for id: %d\", taskId);\n                SafeActivityOptions.abort(options);\n                return;\n            }\n            if (getLockTaskController().isLockTaskModeViolation(task)) {\n                Slog.e(TAG, \"moveTaskToFront: Attempt to violate Lock Task Mode\");\n                SafeActivityOptions.abort(options);\n                return;\n            }\n            ActivityOptions realOptions = options != null\n                    ? options.getOptions(mTaskSupervisor)\n                    : null;\n            mTaskSupervisor.findTaskToMoveToFront(task, flags, realOptions, \"moveTaskToFront\",\n                    false /* forceNonResizable */);\n\n            final ActivityRecord topActivity = task.getTopNonFinishingActivity();\n            if (topActivity != null) {\n\n                // We are reshowing a task, use a starting window to hide the initial draw delay\n                // so the transition can start earlier.\n                topActivity.showStartingWindow(true /* taskSwitch */);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    /**\n     * Return true if callingUid is system, or packageName belongs to that callingUid.\n     */\n    private boolean isSameApp(int callingUid, @Nullable String packageName) {\n        try {\n            if (callingUid != 0 && callingUid != SYSTEM_UID) {\n                if (packageName == null) {\n                    return false;\n                }\n                final int uid = AppGlobals.getPackageManager().getPackageUid(packageName,\n                        PackageManager.MATCH_DEBUG_TRIAGED_MISSING,\n                        UserHandle.getUserId(callingUid));\n                return UserHandle.isSameApp(callingUid, uid);\n            }\n        } catch (RemoteException e) {\n            // Should not happen\n        }\n        return true;\n    }\n\n    /**\n     * Checks that the provided package name matches the current calling UID, throws a security\n     * exception if it doesn't.\n     */\n    void assertPackageMatchesCallingUid(@Nullable String packageName) {\n        final int callingUid = Binder.getCallingUid();\n        if (isSameApp(callingUid, packageName)) {\n            return;\n        }\n        final String msg = \"Permission Denial: package=\" + packageName\n                + \" does not belong to uid=\" + callingUid;\n        Slog.w(TAG, msg);\n        throw new SecurityException(msg);\n    }\n\n    /**\n     * Return true if app switching is allowed.\n     */\n    boolean getBalAppSwitchesAllowed() {\n        return mAppSwitchesAllowed;\n    }\n\n    /** Register an {@link AnrController} to control the ANR dialog behavior */\n    public void registerAnrController(AnrController controller) {\n        synchronized (mGlobalLock) {\n            mAnrController.add(controller);\n        }\n    }\n\n    /** Unregister an {@link AnrController} */\n    public void unregisterAnrController(AnrController controller) {\n        synchronized (mGlobalLock) {\n            mAnrController.remove(controller);\n        }\n    }\n\n    /**\n     * @return the controller with the max ANR delay from all registered\n     * {@link AnrController} instances\n     */\n    @Nullable\n    public AnrController getAnrController(ApplicationInfo info) {\n        if (info == null || info.packageName == null) {\n            return null;\n        }\n\n        final ArrayList<AnrController> controllers;\n        synchronized (mGlobalLock) {\n            controllers = new ArrayList<>(mAnrController);\n        }\n\n        final String packageName = info.packageName;\n        final int uid = info.uid;\n        long maxDelayMs = 0;\n        AnrController controllerWithMaxDelay = null;\n\n        for (AnrController controller : controllers) {\n            long delayMs = controller.getAnrDelayMillis(packageName, uid);\n            if (delayMs > 0 && delayMs > maxDelayMs) {\n                controllerWithMaxDelay = controller;\n                maxDelayMs = delayMs;\n            }\n        }\n\n        return controllerWithMaxDelay;\n    }\n\n    @Override\n    public void setActivityController(IActivityController controller, boolean imAMonkey) {\n        mAmInternal.enforceCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER,\n                \"setActivityController()\");\n        synchronized (mGlobalLock) {\n            mController = controller;\n            mControllerIsAMonkey = imAMonkey;\n            Watchdog.getInstance().setActivityController(controller);\n        }\n    }\n\n    public boolean isControllerAMonkey() {\n        synchronized (mGlobalLock) {\n            return mController != null && mControllerIsAMonkey;\n        }\n    }\n\n    /**\n     * Gets info of running tasks up to the given number.\n     *\n     * @param maxNum the maximum number of task info returned by this method. If the total number of\n     *               running tasks is larger than it then there is no guarantee which task will be\n     *               left out.\n     * @return a list of {@link ActivityManager.RunningTaskInfo} with up to {@code maxNum} items\n     */\n    public List<ActivityManager.RunningTaskInfo> getTasks(int maxNum) {\n        return getTasks(maxNum, false /* filterForVisibleRecents */, false /* keepIntentExtra */);\n    }\n\n    /**\n     * @param filterOnlyVisibleRecents whether to filter the tasks based on whether they would ever\n     *                                 be visible in the recent task list in systemui\n     */\n    @Override\n    public List<ActivityManager.RunningTaskInfo> getTasks(int maxNum,\n            boolean filterOnlyVisibleRecents, boolean keepIntentExtra) {\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n\n        int flags = filterOnlyVisibleRecents ? RunningTasks.FLAG_FILTER_ONLY_VISIBLE_RECENTS : 0;\n        flags |= (keepIntentExtra ? RunningTasks.FLAG_KEEP_INTENT_EXTRA : 0);\n        final boolean crossUser = isCrossUserAllowed(callingPid, callingUid);\n        flags |= (crossUser ? RunningTasks.FLAG_CROSS_USERS : 0);\n        final int[] profileIds = getUserManager().getProfileIds(\n                UserHandle.getUserId(callingUid), true);\n        ArraySet<Integer> callingProfileIds = new ArraySet<>();\n        for (int i = 0; i < profileIds.length; i++) {\n            callingProfileIds.add(profileIds[i]);\n        }\n        ArrayList<ActivityManager.RunningTaskInfo> list = new ArrayList<>();\n\n        synchronized (mGlobalLock) {\n            if (DEBUG_ALL) Slog.v(TAG, \"getTasks: max=\" + maxNum);\n\n            final boolean allowed = isGetTasksAllowed(\"getTasks\", callingPid, callingUid);\n            flags |= (allowed ? RunningTasks.FLAG_ALLOWED : 0);\n            mRootWindowContainer.getRunningTasks(\n                    maxNum, list, flags, callingUid, callingProfileIds);\n        }\n\n        return list;\n    }\n\n    @Override\n    public void moveTaskToRootTask(int taskId, int rootTaskId, boolean toTop) {\n        enforceTaskPermission(\"moveTaskToRootTask()\");\n        synchronized (mGlobalLock) {\n            final long ident = Binder.clearCallingIdentity();\n            try {\n                final Task task = mRootWindowContainer.anyTaskForId(taskId);\n                if (task == null) {\n                    Slog.w(TAG, \"moveTaskToRootTask: No task for id=\" + taskId);\n                    return;\n                }\n\n                ProtoLog.d(WM_DEBUG_TASKS, \"moveTaskToRootTask: moving task=%d to \"\n                        + \"rootTaskId=%d toTop=%b\", taskId, rootTaskId, toTop);\n\n                final Task rootTask = mRootWindowContainer.getRootTask(rootTaskId);\n                if (rootTask == null) {\n                    throw new IllegalStateException(\n                            \"moveTaskToRootTask: No rootTask for rootTaskId=\" + rootTaskId);\n                }\n                if (!rootTask.isActivityTypeStandardOrUndefined()) {\n                    throw new IllegalArgumentException(\"moveTaskToRootTask: Attempt to move task \"\n                            + taskId + \" to rootTask \" + rootTaskId);\n                }\n                task.reparent(rootTask, toTop, REPARENT_KEEP_ROOT_TASK_AT_FRONT, ANIMATE,\n                        !DEFER_RESUME, \"moveTaskToRootTask\");\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n    }\n\n    /**\n     * Removes root tasks in the input windowing modes from the system if they are of activity type\n     * ACTIVITY_TYPE_STANDARD or ACTIVITY_TYPE_UNDEFINED\n     */\n    @Override\n    public void removeRootTasksInWindowingModes(int[] windowingModes) {\n        enforceTaskPermission(\"removeRootTasksInWindowingModes()\");\n\n        synchronized (mGlobalLock) {\n            final long ident = Binder.clearCallingIdentity();\n            try {\n                mRootWindowContainer.removeRootTasksInWindowingModes(windowingModes);\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n    }\n\n    @Override\n    public void removeRootTasksWithActivityTypes(int[] activityTypes) {\n        enforceTaskPermission(\"removeRootTasksWithActivityTypes()\");\n\n        synchronized (mGlobalLock) {\n            final long ident = Binder.clearCallingIdentity();\n            try {\n                mRootWindowContainer.removeRootTasksWithActivityTypes(activityTypes);\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n    }\n\n    @Override\n    public ParceledListSlice<ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum, int flags,\n            int userId) {\n        final int callingUid = Binder.getCallingUid();\n        userId = handleIncomingUser(Binder.getCallingPid(), callingUid, userId, \"getRecentTasks\");\n        final boolean allowed = isGetTasksAllowed(\"getRecentTasks\", Binder.getCallingPid(),\n                callingUid);\n        synchronized (mGlobalLock) {\n            return mRecentTasks.getRecentTasks(maxNum, flags, allowed, userId, callingUid);\n        }\n    }\n\n    @Override\n    public List<RootTaskInfo> getAllRootTaskInfos() {\n        enforceTaskPermission(\"getAllRootTaskInfos()\");\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.getAllRootTaskInfos(INVALID_DISPLAY);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public RootTaskInfo getRootTaskInfo(int windowingMode, int activityType) {\n        enforceTaskPermission(\"getRootTaskInfo()\");\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.getRootTaskInfo(windowingMode, activityType);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public List<RootTaskInfo> getAllRootTaskInfosOnDisplay(int displayId) {\n        enforceTaskPermission(\"getAllRootTaskInfosOnDisplay()\");\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.getAllRootTaskInfos(displayId);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public RootTaskInfo getRootTaskInfoOnDisplay(int windowingMode, int activityType,\n            int displayId) {\n        enforceTaskPermission(\"getRootTaskInfoOnDisplay()\");\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.getRootTaskInfo(windowingMode, activityType, displayId);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public void cancelRecentsAnimation(boolean restoreHomeRootTaskPosition) {\n        enforceTaskPermission(\"cancelRecentsAnimation()\");\n        final long callingUid = Binder.getCallingUid();\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                // Cancel the recents animation synchronously (do not hold the WM lock)\n                mWindowManager.cancelRecentsAnimation(restoreHomeRootTaskPosition\n                        ? REORDER_MOVE_TO_ORIGINAL_POSITION\n                        : REORDER_KEEP_IN_PLACE, \"cancelRecentsAnimation/uid=\" + callingUid);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public void startSystemLockTaskMode(int taskId) {\n        enforceTaskPermission(\"startSystemLockTaskMode\");\n        // This makes inner call to look as if it was initiated by system.\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final Task task = mRootWindowContainer.anyTaskForId(taskId,\n                        MATCH_ATTACHED_TASK_ONLY);\n                if (task == null) {\n                    return;\n                }\n\n                // When starting lock task mode the root task must be in front and focused\n                task.getRootTask().moveToFront(\"startSystemLockTaskMode\");\n                startLockTaskMode(task, true /* isSystemCaller */);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    /**\n     * This API should be called by SystemUI only when user perform certain action to dismiss\n     * lock task mode. We should only dismiss pinned lock task mode in this case.\n     */\n    @Override\n    public void stopSystemLockTaskMode() throws RemoteException {\n        enforceTaskPermission(\"stopSystemLockTaskMode\");\n        stopLockTaskModeInternal(null, true /* isSystemCaller */);\n    }\n\n    void startLockTaskMode(@Nullable Task task, boolean isSystemCaller) {\n        ProtoLog.w(WM_DEBUG_LOCKTASK, \"startLockTaskMode: %s\", task);\n        if (task == null || task.mLockTaskAuth == LOCK_TASK_AUTH_DONT_LOCK) {\n            return;\n        }\n\n        final Task rootTask = mRootWindowContainer.getTopDisplayFocusedRootTask();\n        if (rootTask == null || task != rootTask.getTopMostTask()) {\n            throw new IllegalArgumentException(\"Invalid task, not in foreground\");\n        }\n\n        // {@code isSystemCaller} is used to distinguish whether this request is initiated by the\n        // system or a specific app.\n        // * System-initiated requests will only start the pinned mode (screen pinning)\n        // * App-initiated requests\n        //   - will put the device in fully locked mode (LockTask), if the app is allowlisted\n        //   - will start the pinned mode, otherwise\n        final int callingUid = Binder.getCallingUid();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            // When a task is locked, dismiss the root pinned task if it exists\n            mRootWindowContainer.removeRootTasksInWindowingModes(WINDOWING_MODE_PINNED);\n\n            getLockTaskController().startLockTaskMode(task, isSystemCaller, callingUid);\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    void stopLockTaskModeInternal(@Nullable IBinder token, boolean isSystemCaller) {\n        final int callingUid = Binder.getCallingUid();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                Task task = null;\n                if (token != null) {\n                    final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n                    if (r == null) {\n                        return;\n                    }\n                    task = r.getTask();\n                }\n                getLockTaskController().stopLockTaskMode(task, isSystemCaller, callingUid);\n            }\n            // Launch in-call UI if a call is ongoing. This is necessary to allow stopping the lock\n            // task and jumping straight into a call in the case of emergency call back.\n            TelecomManager tm = (TelecomManager) mContext.getSystemService(Context.TELECOM_SERVICE);\n            if (tm != null) {\n                tm.showInCallScreen(false);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public void updateLockTaskPackages(int userId, String[] packages) {\n        final int callingUid = Binder.getCallingUid();\n        if (callingUid != 0 && callingUid != SYSTEM_UID) {\n            mAmInternal.enforceCallingPermission(Manifest.permission.UPDATE_LOCK_TASK_PACKAGES,\n                    \"updateLockTaskPackages()\");\n        }\n        synchronized (mGlobalLock) {\n            ProtoLog.w(WM_DEBUG_LOCKTASK, \"Allowlisting %d:%s\", userId, Arrays.toString(packages));\n            getLockTaskController().updateLockTaskPackages(userId, packages);\n        }\n    }\n\n    @Override\n    public boolean isInLockTaskMode() {\n        return getLockTaskModeState() != LOCK_TASK_MODE_NONE;\n    }\n\n    @Override\n    public int getLockTaskModeState() {\n        return getLockTaskController().getLockTaskModeState();\n    }\n\n    @Override\n    public List<IBinder> getAppTasks(String callingPackage) {\n        int callingUid = Binder.getCallingUid();\n        assertPackageMatchesCallingUid(callingPackage);\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                return mRecentTasks.getAppTasksList(callingUid, callingPackage);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public void finishVoiceTask(IVoiceInteractionSession session) {\n        synchronized (mGlobalLock) {\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                // TODO: VI Consider treating local voice interactions and voice tasks\n                // differently here\n                mRootWindowContainer.finishVoiceTask(session);\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n\n    }\n\n    @Override\n    public void reportAssistContextExtras(IBinder assistToken, Bundle extras,\n            AssistStructure structure, AssistContent content, Uri referrer) {\n        final PendingAssistExtras pae = (PendingAssistExtras) assistToken;\n        synchronized (pae) {\n            pae.result = extras;\n            pae.structure = structure;\n            pae.content = content;\n            if (referrer != null) {\n                pae.extras.putParcelable(Intent.EXTRA_REFERRER, referrer);\n            }\n            if (!pae.activity.isAttached()) {\n                // Skip directly because the caller activity may have been destroyed. If a caller\n                // is waiting for the assist data, it will be notified by timeout\n                // (see PendingAssistExtras#run()) and then pendingAssistExtrasTimedOut will clean\n                // up the request.\n                return;\n            }\n            if (structure != null) {\n                // Pre-fill the task/activity component for all assist data receivers\n                structure.setTaskId(pae.activity.getTask().mTaskId);\n                structure.setActivityComponent(pae.activity.mActivityComponent);\n                structure.setHomeActivity(pae.isHome);\n            }\n            pae.haveResult = true;\n            pae.notifyAll();\n            if (pae.intent == null && pae.receiver == null) {\n                // Caller is just waiting for the result.\n                return;\n            }\n        }\n        // We are now ready to launch the assist activity.\n        IAssistDataReceiver sendReceiver = null;\n        Bundle sendBundle = null;\n        synchronized (mGlobalLock) {\n            buildAssistBundleLocked(pae, extras);\n            boolean exists = mPendingAssistExtras.remove(pae);\n            mUiHandler.removeCallbacks(pae);\n            if (!exists) {\n                // Timed out.\n                return;\n            }\n\n            if ((sendReceiver = pae.receiver) != null) {\n                // Caller wants result sent back to them.\n                sendBundle = new Bundle();\n                sendBundle.putInt(ActivityTaskManagerInternal.ASSIST_TASK_ID,\n                        pae.activity.getTask().mTaskId);\n                sendBundle.putBinder(ActivityTaskManagerInternal.ASSIST_ACTIVITY_ID,\n                        pae.activity.assistToken);\n                sendBundle.putBundle(ASSIST_KEY_DATA, pae.extras);\n                sendBundle.putParcelable(ASSIST_KEY_STRUCTURE, pae.structure);\n                sendBundle.putParcelable(ASSIST_KEY_CONTENT, pae.content);\n                sendBundle.putBundle(ASSIST_KEY_RECEIVER_EXTRAS, pae.receiverExtras);\n            }\n        }\n        if (sendReceiver != null) {\n            try {\n                sendReceiver.onHandleAssistData(sendBundle);\n            } catch (RemoteException e) {\n            }\n            return;\n        }\n\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            pae.intent.replaceExtras(pae.extras);\n            pae.intent.setFlags(FLAG_ACTIVITY_NEW_TASK\n                    | Intent.FLAG_ACTIVITY_SINGLE_TOP\n                    | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n            mInternal.closeSystemDialogs(\"assist\");\n\n            try {\n                mContext.startActivityAsUser(pae.intent, new UserHandle(pae.userHandle));\n            } catch (ActivityNotFoundException e) {\n                Slog.w(TAG, \"No activity to handle assist action.\", e);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public int addAppTask(IBinder activityToken, Intent intent,\n            ActivityManager.TaskDescription description, Bitmap thumbnail) throws RemoteException {\n        final int callingUid = Binder.getCallingUid();\n        final long callingIdent = Binder.clearCallingIdentity();\n\n        try {\n            synchronized (mGlobalLock) {\n                ActivityRecord r = ActivityRecord.isInRootTaskLocked(activityToken);\n                if (r == null) {\n                    throw new IllegalArgumentException(\"Activity does not exist; token=\"\n                            + activityToken);\n                }\n                ComponentName comp = intent.getComponent();\n                if (comp == null) {\n                    throw new IllegalArgumentException(\"Intent \" + intent\n                            + \" must specify explicit component\");\n                }\n                if (thumbnail.getWidth() != mThumbnailWidth\n                        || thumbnail.getHeight() != mThumbnailHeight) {\n                    throw new IllegalArgumentException(\"Bad thumbnail size: got \"\n                            + thumbnail.getWidth() + \"x\" + thumbnail.getHeight() + \", require \"\n                            + mThumbnailWidth + \"x\" + mThumbnailHeight);\n                }\n                if (intent.getSelector() != null) {\n                    intent.setSelector(null);\n                }\n                if (intent.getSourceBounds() != null) {\n                    intent.setSourceBounds(null);\n                }\n                if ((intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_DOCUMENT) != 0) {\n                    if ((intent.getFlags() & Intent.FLAG_ACTIVITY_RETAIN_IN_RECENTS) == 0) {\n                        // The caller has added this as an auto-remove task...  that makes no\n                        // sense, so turn off auto-remove.\n                        intent.addFlags(Intent.FLAG_ACTIVITY_RETAIN_IN_RECENTS);\n                    }\n                }\n                final ActivityInfo ainfo = AppGlobals.getPackageManager().getActivityInfo(comp,\n                        STOCK_PM_FLAGS, UserHandle.getUserId(callingUid));\n                if (ainfo == null || ainfo.applicationInfo.uid != callingUid) {\n                    Slog.e(TAG, \"Can't add task for another application: target uid=\"\n                            + (ainfo == null ? Process.INVALID_UID : ainfo.applicationInfo.uid)\n                            + \", calling uid=\" + callingUid);\n                    return INVALID_TASK_ID;\n                }\n\n                final Task rootTask = r.getRootTask();\n                final Task task = new Task.Builder(this)\n                        .setWindowingMode(rootTask.getWindowingMode())\n                        .setActivityType(rootTask.getActivityType())\n                        .setActivityInfo(ainfo)\n                        .setIntent(intent)\n                        .setTaskId(rootTask.getDisplayArea().getNextRootTaskId())\n                        .build();\n\n                if (!mRecentTasks.addToBottom(task)) {\n                    // The app has too many tasks already and we can't add any more\n                    rootTask.removeChild(task, \"addAppTask\");\n                    return INVALID_TASK_ID;\n                }\n                task.getTaskDescription().copyFrom(description);\n\n                // TODO: Send the thumbnail to WM to store it.\n\n                return task.mTaskId;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(callingIdent);\n        }\n    }\n\n    @Override\n    public Point getAppTaskThumbnailSize() {\n        synchronized (mGlobalLock) {\n            return new Point(mThumbnailWidth, mThumbnailHeight);\n        }\n    }\n\n    @Override\n    public void setTaskResizeable(int taskId, int resizeableMode) {\n        synchronized (mGlobalLock) {\n            final Task task = mRootWindowContainer.anyTaskForId(\n                    taskId, MATCH_ATTACHED_TASK_OR_RECENT_TASKS);\n            if (task == null) {\n                Slog.w(TAG, \"setTaskResizeable: taskId=\" + taskId + \" not found\");\n                return;\n            }\n            task.setResizeMode(resizeableMode);\n        }\n    }\n\n    @Override\n    public boolean resizeTask(int taskId, Rect bounds, int resizeMode) {\n        enforceTaskPermission(\"resizeTask()\");\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final Task task = mRootWindowContainer.anyTaskForId(taskId,\n                        MATCH_ATTACHED_TASK_ONLY);\n                if (task == null) {\n                    Slog.w(TAG, \"resizeTask: taskId=\" + taskId + \" not found\");\n                    return false;\n                }\n                if (!task.getWindowConfiguration().canResizeTask()) {\n                    Slog.w(TAG, \"resizeTask not allowed on task=\" + task);\n                    return false;\n                }\n\n                // Reparent the task to the right root task if necessary\n                boolean preserveWindow = (resizeMode & RESIZE_MODE_PRESERVE_WINDOW) != 0;\n\n                // After reparenting (which only resizes the task to the root task bounds),\n                // resize the task to the actual bounds provided\n                return task.resize(bounds, resizeMode, preserveWindow);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public void releaseSomeActivities(IApplicationThread appInt) {\n        synchronized (mGlobalLock) {\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                final WindowProcessController app = getProcessController(appInt);\n                app.releaseSomeActivities(\"low-mem\");\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public void setLockScreenShown(boolean keyguardShowing, boolean aodShowing) {\n        if (checkCallingPermission(android.Manifest.permission.DEVICE_POWER)\n                != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"Requires permission \"\n                    + android.Manifest.permission.DEVICE_POWER);\n        }\n\n        synchronized (mGlobalLock) {\n            final long ident = Binder.clearCallingIdentity();\n            if (mKeyguardShown != keyguardShowing) {\n                mKeyguardShown = keyguardShowing;\n                final Message msg = PooledLambda.obtainMessage(\n                        ActivityManagerInternal::reportCurKeyguardUsageEvent, mAmInternal,\n                        keyguardShowing);\n                mH.sendMessage(msg);\n            }\n            try {\n                mKeyguardController.setKeyguardShown(keyguardShowing, aodShowing);\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n\n        mH.post(() -> {\n            for (int i = mScreenObservers.size() - 1; i >= 0; i--) {\n                mScreenObservers.get(i).onKeyguardStateChanged(keyguardShowing);\n            }\n        });\n    }\n\n    // The caller MUST NOT hold the global lock.\n    public void onScreenAwakeChanged(boolean isAwake) {\n        mH.post(() -> {\n            for (int i = mScreenObservers.size() - 1; i >= 0; i--) {\n                mScreenObservers.get(i).onAwakeStateChanged(isAwake);\n            }\n        });\n\n        if (isAwake) {\n            return;\n        }\n        // If the device is going to sleep, keep a higher priority temporarily for potential\n        // animation of system UI. Even if AOD is not enabled, it should be no harm.\n        final WindowProcessController proc;\n        synchronized (mGlobalLockWithoutBoost) {\n            final WindowState notificationShade = mRootWindowContainer.getDefaultDisplay()\n                    .getDisplayPolicy().getNotificationShade();\n            proc = notificationShade != null\n                    ? mProcessMap.getProcess(notificationShade.mSession.mPid) : null;\n        }\n        if (proc == null) {\n            return;\n        }\n        // Set to activity manager directly to make sure the state can be seen by the subsequent\n        // update of scheduling group.\n        proc.setRunningAnimationUnsafe();\n        mH.removeMessages(H.UPDATE_PROCESS_ANIMATING_STATE, proc);\n        mH.sendMessageDelayed(mH.obtainMessage(H.UPDATE_PROCESS_ANIMATING_STATE, proc),\n                DOZE_ANIMATING_STATE_RETAIN_TIME_MS);\n    }\n\n    @Override\n    public Bitmap getTaskDescriptionIcon(String filePath, int userId) {\n        userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),\n                userId, \"getTaskDescriptionIcon\");\n\n        final File passedIconFile = new File(filePath);\n        final File legitIconFile = new File(TaskPersister.getUserImagesDir(userId),\n                passedIconFile.getName());\n        if (!legitIconFile.getPath().equals(filePath)\n                || !filePath.contains(ActivityRecord.ACTIVITY_ICON_SUFFIX)) {\n            throw new IllegalArgumentException(\"Bad file path: \" + filePath\n                    + \" passed for userId \" + userId);\n        }\n        return mRecentTasks.getTaskDescriptionIcon(filePath);\n    }\n\n    @Override\n    public void moveRootTaskToDisplay(int taskId, int displayId) {\n        mAmInternal.enforceCallingPermission(INTERNAL_SYSTEM_WINDOW, \"moveRootTaskToDisplay()\");\n\n        synchronized (mGlobalLock) {\n            final long ident = Binder.clearCallingIdentity();\n            try {\n                ProtoLog.d(WM_DEBUG_TASKS, \"moveRootTaskToDisplay: moving taskId=%d to \"\n                        + \"displayId=%d\", taskId, displayId);\n                mRootWindowContainer.moveRootTaskToDisplay(taskId, displayId, ON_TOP);\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n    }\n\n    /** Sets the task stack listener that gets callbacks when a task stack changes. */\n    @Override\n    public void registerTaskStackListener(ITaskStackListener listener) {\n        enforceTaskPermission(\"registerTaskStackListener()\");\n        mTaskChangeNotificationController.registerTaskStackListener(listener);\n    }\n\n    /** Unregister a task stack listener so that it stops receiving callbacks. */\n    @Override\n    public void unregisterTaskStackListener(ITaskStackListener listener) {\n        enforceTaskPermission(\"unregisterTaskStackListener()\");\n        mTaskChangeNotificationController.unregisterTaskStackListener(listener);\n    }\n\n    @Override\n    public boolean requestAssistContextExtras(int requestType, IAssistDataReceiver receiver,\n            Bundle receiverExtras, IBinder activityToken, boolean checkActivityIsTop,\n            boolean newSessionId) {\n        return enqueueAssistContext(requestType, null, null, receiver, receiverExtras,\n                activityToken, checkActivityIsTop, newSessionId, UserHandle.getCallingUserId(),\n                null, PENDING_ASSIST_EXTRAS_LONG_TIMEOUT, 0) != null;\n    }\n\n    @Override\n    public boolean requestAssistDataForTask(IAssistDataReceiver receiver, int taskId,\n            String callingPackageName) {\n        mAmInternal.enforceCallingPermission(android.Manifest.permission.GET_TOP_ACTIVITY_INFO,\n                \"requestAssistDataForTask()\");\n        final long callingId = Binder.clearCallingIdentity();\n        LocalService.ActivityTokens tokens = null;\n        try {\n            tokens = mInternal.getTopActivityForTask(taskId);\n        } finally {\n            Binder.restoreCallingIdentity(callingId);\n        }\n        if (tokens == null) {\n            Log.e(TAG, \"Could not find activity for task \" + taskId);\n            return false;\n        }\n\n        final AssistDataReceiverProxy proxy =\n                new AssistDataReceiverProxy(receiver, callingPackageName);\n        Object lock = new Object();\n        AssistDataRequester requester = new AssistDataRequester(mContext, mWindowManager,\n                getAppOpsManager(), proxy, lock, AppOpsManager.OP_ASSIST_STRUCTURE,\n                AppOpsManager.OP_NONE);\n\n        List<IBinder> topActivityToken = new ArrayList<>();\n        topActivityToken.add(tokens.getActivityToken());\n        requester.requestAssistData(topActivityToken, true /* fetchData */,\n                false /* fetchScreenshot */, false /* fetchStructure */, true /* allowFetchData */,\n                false /* allowFetchScreenshot*/, true /* ignoreFocusCheck */,\n                Binder.getCallingUid(), callingPackageName);\n\n        return true;\n    }\n\n    @Override\n    public boolean requestAutofillData(IAssistDataReceiver receiver, Bundle receiverExtras,\n            IBinder activityToken, int flags) {\n        return enqueueAssistContext(ActivityManager.ASSIST_CONTEXT_AUTOFILL, null, null,\n                receiver, receiverExtras, activityToken, true, true, UserHandle.getCallingUserId(),\n                null, PENDING_AUTOFILL_ASSIST_STRUCTURE_TIMEOUT, flags) != null;\n    }\n\n    @Override\n    public Bundle getAssistContextExtras(int requestType) {\n        PendingAssistExtras pae = enqueueAssistContext(requestType, null, null, null,\n                null, null, true /* checkActivityIsTop */, true /* newSessionId */,\n                UserHandle.getCallingUserId(), null, PENDING_ASSIST_EXTRAS_TIMEOUT, 0);\n        if (pae == null) {\n            return null;\n        }\n        synchronized (pae) {\n            while (!pae.haveResult) {\n                try {\n                    pae.wait();\n                } catch (InterruptedException e) {\n                }\n            }\n        }\n        synchronized (mGlobalLock) {\n            buildAssistBundleLocked(pae, pae.result);\n            mPendingAssistExtras.remove(pae);\n            mUiHandler.removeCallbacks(pae);\n        }\n        return pae.extras;\n    }\n\n    /**\n     * Binder IPC calls go through the public entry point.\n     * This can be called with or without the global lock held.\n     */\n    private static int checkCallingPermission(String permission) {\n        return checkPermission(\n                permission, Binder.getCallingPid(), Binder.getCallingUid());\n    }\n\n    /**\n     * Returns true if the app can close system dialogs. Otherwise it either throws a {@link\n     * SecurityException} or returns false with a logcat message depending on whether the app\n     * targets SDK level {@link android.os.Build.VERSION_CODES#S} or not.\n     */\n    private boolean checkCanCloseSystemDialogs(int pid, int uid, @Nullable String packageName) {\n        final WindowProcessController process;\n        synchronized (mGlobalLock) {\n            process = mProcessMap.getProcess(pid);\n        }\n        if (packageName == null && process != null) {\n            // WindowProcessController.mInfo is final, so after the synchronized memory barrier\n            // above, process.mInfo can't change. As for reading mInfo.packageName,\n            // WindowProcessController doesn't own the ApplicationInfo object referenced by mInfo.\n            // ProcessRecord for example also holds a reference to that object, so protecting access\n            // to packageName with the WM lock would not be enough as we'd also need to synchronize\n            // on the AM lock if we are worried about races, but we can't synchronize on AM lock\n            // here. Hence, since this is only used for logging, we don't synchronize here.\n            packageName = process.mInfo.packageName;\n        }\n        String caller = \"(pid=\" + pid + \", uid=\" + uid + \")\";\n        if (packageName != null) {\n            caller = packageName + \" \" + caller;\n        }\n        if (!canCloseSystemDialogs(pid, uid)) {\n            // The app can't close system dialogs, throw only if it targets S+\n            if (CompatChanges.isChangeEnabled(LOCK_DOWN_CLOSE_SYSTEM_DIALOGS, uid)) {\n                throw new SecurityException(\n                        \"Permission Denial: \" + Intent.ACTION_CLOSE_SYSTEM_DIALOGS\n                                + \" broadcast from \" + caller + \" requires \"\n                                + Manifest.permission.BROADCAST_CLOSE_SYSTEM_DIALOGS + \".\");\n            } else if (CompatChanges.isChangeEnabled(DROP_CLOSE_SYSTEM_DIALOGS, uid)) {\n                Slog.e(TAG,\n                        \"Permission Denial: \" + Intent.ACTION_CLOSE_SYSTEM_DIALOGS\n                                + \" broadcast from \" + caller + \" requires \"\n                                + Manifest.permission.BROADCAST_CLOSE_SYSTEM_DIALOGS\n                                + \", dropping broadcast.\");\n                return false;\n            } else {\n                Slog.w(TAG, Intent.ACTION_CLOSE_SYSTEM_DIALOGS\n                        + \" broadcast from \" + caller + \" will require \"\n                        + Manifest.permission.BROADCAST_CLOSE_SYSTEM_DIALOGS\n                        + \" in future builds.\");\n                return true;\n            }\n        }\n        return true;\n    }\n\n    private boolean canCloseSystemDialogs(int pid, int uid) {\n        if (checkPermission(Manifest.permission.BROADCAST_CLOSE_SYSTEM_DIALOGS, pid, uid)\n                == PERMISSION_GRANTED) {\n            return true;\n        }\n        synchronized (mGlobalLock) {\n            // Check all the processes from the given uid, especially since for PendingIntents sent\n            // the pid equals -1\n            ArraySet<WindowProcessController> processes = mProcessMap.getProcesses(uid);\n            if (processes != null) {\n                for (int i = 0, n = processes.size(); i < n; i++) {\n                    WindowProcessController process = processes.valueAt(i);\n                    // Check if the instrumentation of the process has the permission. This covers\n                    // the usual test started from the shell (which has the permission) case. This\n                    // is needed for apps targeting SDK level < S but we are also allowing for\n                    // targetSdk S+ as a convenience to avoid breaking a bunch of existing tests and\n                    // asking them to adopt shell permissions to do this.\n                    int sourceUid = process.getInstrumentationSourceUid();\n                    if (process.isInstrumenting() && sourceUid != -1 && checkPermission(\n                            Manifest.permission.BROADCAST_CLOSE_SYSTEM_DIALOGS, -1, sourceUid)\n                            == PERMISSION_GRANTED) {\n                        return true;\n                    }\n                    // This is the notification trampoline use-case for example, where apps use\n                    // Intent.ACSD to close the shade prior to starting an activity.\n                    if (process.canCloseSystemDialogsByToken()) {\n                        return true;\n                    }\n                }\n            }\n            if (!CompatChanges.isChangeEnabled(LOCK_DOWN_CLOSE_SYSTEM_DIALOGS, uid)) {\n                // This covers the case where the app is displaying some UI on top of the\n                // notification shade and wants to start an activity. The app then sends the intent\n                // in order to move the notification shade out of the way and show the activity to\n                // the user. This is fine since the caller already has privilege to show a visible\n                // window on top of the notification shade, so it can already prevent the user from\n                // accessing the shade if it wants to. We only allow for targetSdk < S, for S+ we\n                // automatically collapse the shade on startActivity() for these apps.\n                // It's ok that the owner of the shade is not allowed *per this rule* because it has\n                // BROADCAST_CLOSE_SYSTEM_DIALOGS (SystemUI), so it would fall into that rule.\n                if (mRootWindowContainer.hasVisibleWindowAboveButDoesNotOwnNotificationShade(uid)) {\n                    return true;\n                }\n                // Accessibility services are allowed to send the intent unless they are targeting\n                // S+, in which case they should use {@link AccessibilityService\n                // #GLOBAL_ACTION_DISMISS_NOTIFICATION_SHADE} to dismiss the notification shade.\n                if (ArrayUtils.contains(mAccessibilityServiceUids, uid)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    static void enforceTaskPermission(String func) {\n        if (checkCallingPermission(MANAGE_ACTIVITY_TASKS) == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n\n        if (checkCallingPermission(MANAGE_ACTIVITY_STACKS) == PackageManager.PERMISSION_GRANTED) {\n            Slog.w(TAG, \"MANAGE_ACTIVITY_STACKS is deprecated, \"\n                    + \"please use alternative permission: MANAGE_ACTIVITY_TASKS\");\n            return;\n        }\n\n        String msg = \"Permission Denial: \" + func + \" from pid=\" + Binder.getCallingPid() + \", uid=\"\n                + Binder.getCallingUid() + \" requires android.permission.MANAGE_ACTIVITY_TASKS\";\n        Slog.w(TAG, msg);\n        throw new SecurityException(msg);\n    }\n\n    @VisibleForTesting\n    int checkGetTasksPermission(String permission, int pid, int uid) {\n        return checkPermission(permission, pid, uid);\n    }\n\n    static int checkPermission(String permission, int pid, int uid) {\n        if (permission == null) {\n            return PackageManager.PERMISSION_DENIED;\n        }\n        return checkComponentPermission(permission, pid, uid, -1, true);\n    }\n\n    public static int checkComponentPermission(String permission, int pid, int uid,\n            int owningUid, boolean exported) {\n        return ActivityManagerService.checkComponentPermission(\n                permission, pid, uid, owningUid, exported);\n    }\n\n    boolean isGetTasksAllowed(String caller, int callingPid, int callingUid) {\n        if (getRecentTasks().isCallerRecents(callingUid)) {\n            // Always allow the recents component to get tasks\n            return true;\n        }\n\n        boolean allowed = checkGetTasksPermission(android.Manifest.permission.REAL_GET_TASKS,\n                callingPid, callingUid) == PackageManager.PERMISSION_GRANTED;\n        if (!allowed) {\n            if (checkGetTasksPermission(android.Manifest.permission.GET_TASKS,\n                    callingPid, callingUid) == PackageManager.PERMISSION_GRANTED) {\n                // Temporary compatibility: some existing apps on the system image may\n                // still be requesting the old permission and not switched to the new\n                // one; if so, we'll still allow them full access.  This means we need\n                // to see if they are holding the old permission and are a system app.\n                try {\n                    if (AppGlobals.getPackageManager().isUidPrivileged(callingUid)) {\n                        allowed = true;\n                        ProtoLog.w(WM_DEBUG_TASKS,\n                                \"%s: caller %d is using old GET_TASKS but privileged; allowing\",\n                                caller, callingUid);\n                    }\n                } catch (RemoteException e) {\n                }\n            }\n            ProtoLog.w(WM_DEBUG_TASKS,\n                    \"%s: caller %d does not hold REAL_GET_TASKS; limiting output\", caller,\n                    callingUid);\n        }\n        return allowed;\n    }\n\n    boolean isCrossUserAllowed(int pid, int uid) {\n        return checkPermission(INTERACT_ACROSS_USERS, pid, uid) == PERMISSION_GRANTED\n                || checkPermission(INTERACT_ACROSS_USERS_FULL, pid, uid) == PERMISSION_GRANTED;\n    }\n\n    private PendingAssistExtras enqueueAssistContext(int requestType, Intent intent, String hint,\n            IAssistDataReceiver receiver, Bundle receiverExtras, IBinder activityToken,\n            boolean checkActivityIsTop, boolean newSessionId, int userHandle, Bundle args,\n            long timeout, int flags) {\n        mAmInternal.enforceCallingPermission(android.Manifest.permission.GET_TOP_ACTIVITY_INFO,\n                \"enqueueAssistContext()\");\n\n        synchronized (mGlobalLock) {\n            final Task rootTask = getTopDisplayFocusedRootTask();\n            ActivityRecord activity =\n                    rootTask != null ? rootTask.getTopNonFinishingActivity() : null;\n            if (activity == null) {\n                Slog.w(TAG, \"getAssistContextExtras failed: no top activity\");\n                return null;\n            }\n            if (!activity.attachedToProcess()) {\n                Slog.w(TAG, \"getAssistContextExtras failed: no process for \" + activity);\n                return null;\n            }\n            if (checkActivityIsTop) {\n                if (activityToken != null) {\n                    ActivityRecord caller = ActivityRecord.forTokenLocked(activityToken);\n                    if (activity != caller) {\n                        Slog.w(TAG, \"enqueueAssistContext failed: caller \" + caller\n                                + \" is not current top \" + activity);\n                        return null;\n                    }\n                }\n            } else {\n                activity = ActivityRecord.forTokenLocked(activityToken);\n                if (activity == null) {\n                    Slog.w(TAG, \"enqueueAssistContext failed: activity for token=\" + activityToken\n                            + \" couldn't be found\");\n                    return null;\n                }\n                if (!activity.attachedToProcess()) {\n                    Slog.w(TAG, \"enqueueAssistContext failed: no process for \" + activity);\n                    return null;\n                }\n            }\n\n            PendingAssistExtras pae;\n            Bundle extras = new Bundle();\n            if (args != null) {\n                extras.putAll(args);\n            }\n            extras.putString(Intent.EXTRA_ASSIST_PACKAGE, activity.packageName);\n            extras.putInt(Intent.EXTRA_ASSIST_UID, activity.app.mUid);\n\n            pae = new PendingAssistExtras(activity, extras, intent, hint, receiver, receiverExtras,\n                    userHandle);\n            pae.isHome = activity.isActivityTypeHome();\n\n            // Increment the sessionId if necessary\n            if (newSessionId) {\n                mViSessionId++;\n            }\n            try {\n                activity.app.getThread().requestAssistContextExtras(activity.appToken, pae,\n                        requestType, mViSessionId, flags);\n                mPendingAssistExtras.add(pae);\n                mUiHandler.postDelayed(pae, timeout);\n            } catch (RemoteException e) {\n                Slog.w(TAG, \"getAssistContextExtras failed: crash calling \" + activity);\n                return null;\n            }\n            return pae;\n        }\n    }\n\n    private void buildAssistBundleLocked(PendingAssistExtras pae, Bundle result) {\n        if (result != null) {\n            pae.extras.putBundle(Intent.EXTRA_ASSIST_CONTEXT, result);\n        }\n        if (pae.hint != null) {\n            pae.extras.putBoolean(pae.hint, true);\n        }\n    }\n\n    private void pendingAssistExtrasTimedOut(PendingAssistExtras pae) {\n        IAssistDataReceiver receiver;\n        synchronized (mGlobalLock) {\n            mPendingAssistExtras.remove(pae);\n            receiver = pae.receiver;\n        }\n        if (receiver != null) {\n            // Caller wants result sent back to them.\n            Bundle sendBundle = new Bundle();\n            // At least return the receiver extras\n            sendBundle.putBundle(ASSIST_KEY_RECEIVER_EXTRAS, pae.receiverExtras);\n            try {\n                pae.receiver.onHandleAssistData(sendBundle);\n            } catch (RemoteException e) {\n            }\n        }\n    }\n\n    public class PendingAssistExtras extends Binder implements Runnable {\n        public final ActivityRecord activity;\n        public boolean isHome;\n        public final Bundle extras;\n        public final Intent intent;\n        public final String hint;\n        public final IAssistDataReceiver receiver;\n        public final int userHandle;\n        public boolean haveResult = false;\n        public Bundle result = null;\n        public AssistStructure structure = null;\n        public AssistContent content = null;\n        public Bundle receiverExtras;\n\n        public PendingAssistExtras(ActivityRecord _activity, Bundle _extras, Intent _intent,\n                String _hint, IAssistDataReceiver _receiver, Bundle _receiverExtras,\n                int _userHandle) {\n            activity = _activity;\n            extras = _extras;\n            intent = _intent;\n            hint = _hint;\n            receiver = _receiver;\n            receiverExtras = _receiverExtras;\n            userHandle = _userHandle;\n        }\n\n        @Override\n        public void run() {\n            Slog.w(TAG, \"getAssistContextExtras failed: timeout retrieving from \" + activity);\n            synchronized (this) {\n                haveResult = true;\n                notifyAll();\n            }\n            pendingAssistExtrasTimedOut(this);\n        }\n    }\n\n    @Override\n    public boolean isAssistDataAllowedOnCurrentActivity() {\n        int userId;\n        synchronized (mGlobalLock) {\n            final Task focusedRootTask = getTopDisplayFocusedRootTask();\n            if (focusedRootTask == null || focusedRootTask.isActivityTypeAssistant()) {\n                return false;\n            }\n\n            final ActivityRecord activity = focusedRootTask.getTopNonFinishingActivity();\n            if (activity == null) {\n                return false;\n            }\n            userId = activity.mUserId;\n        }\n        return DevicePolicyCache.getInstance().isScreenCaptureAllowed(userId, false);\n    }\n\n    private void onLocalVoiceInteractionStartedLocked(IBinder activity,\n            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor) {\n        ActivityRecord activityToCallback = ActivityRecord.forTokenLocked(activity);\n        if (activityToCallback == null) return;\n        activityToCallback.setVoiceSessionLocked(voiceSession);\n\n        // Inform the activity\n        try {\n            activityToCallback.app.getThread().scheduleLocalVoiceInteractionStarted(activity,\n                    voiceInteractor);\n            final long token = Binder.clearCallingIdentity();\n            try {\n                startRunningVoiceLocked(voiceSession, activityToCallback.info.applicationInfo.uid);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            // TODO: VI Should we cache the activity so that it's easier to find later\n            // rather than scan through all the root tasks and activities?\n        } catch (RemoteException re) {\n            activityToCallback.clearVoiceSessionLocked();\n            // TODO: VI Should this terminate the voice session?\n        }\n    }\n\n    private void startRunningVoiceLocked(IVoiceInteractionSession session, int targetUid) {\n        Slog.d(TAG, \"<<<  startRunningVoiceLocked()\");\n        mVoiceWakeLock.setWorkSource(new WorkSource(targetUid));\n        if (mRunningVoice == null || mRunningVoice.asBinder() != session.asBinder()) {\n            boolean wasRunningVoice = mRunningVoice != null;\n            mRunningVoice = session;\n            if (!wasRunningVoice) {\n                mVoiceWakeLock.acquire();\n                updateSleepIfNeededLocked();\n            }\n        }\n    }\n\n    void finishRunningVoiceLocked() {\n        if (mRunningVoice != null) {\n            mRunningVoice = null;\n            mVoiceWakeLock.release();\n            updateSleepIfNeededLocked();\n        }\n    }\n\n    @Override\n    public void setVoiceKeepAwake(IVoiceInteractionSession session, boolean keepAwake) {\n        synchronized (mGlobalLock) {\n            if (mRunningVoice != null && mRunningVoice.asBinder() == session.asBinder()) {\n                if (keepAwake) {\n                    mVoiceWakeLock.acquire();\n                } else {\n                    mVoiceWakeLock.release();\n                }\n            }\n        }\n    }\n\n    @Override\n    public void keyguardGoingAway(int flags) {\n        enforceNotIsolatedCaller(\"keyguardGoingAway\");\n        final long token = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                mKeyguardController.keyguardGoingAway(flags);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public void suppressResizeConfigChanges(boolean suppress) throws RemoteException {\n        mAmInternal.enforceCallingPermission(MANAGE_ACTIVITY_TASKS,\n                \"suppressResizeConfigChanges()\");\n        synchronized (mGlobalLock) {\n            mSuppressResizeConfigChanges = suppress;\n        }\n    }\n\n    /**\n     * A splash screen view has copied, pass it to an activity.\n     *\n     * @param taskId Id of task to handle the material to reconstruct the view.\n     * @param parcelable Used to reconstruct the view, null means the surface is un-copyable.\n     * @hide\n     */\n    @Override\n    public void onSplashScreenViewCopyFinished(int taskId, SplashScreenViewParcelable parcelable)\n            throws RemoteException {\n        mAmInternal.enforceCallingPermission(MANAGE_ACTIVITY_TASKS,\n                \"copySplashScreenViewFinish()\");\n        synchronized (mGlobalLock) {\n            final Task task = mRootWindowContainer.anyTaskForId(taskId,\n                    MATCH_ATTACHED_TASK_ONLY);\n            if (task != null) {\n                final ActivityRecord r = task.getTopWaitSplashScreenActivity();\n                if (r != null) {\n                    r.onCopySplashScreenFinish(parcelable);\n                }\n            }\n        }\n    }\n\n    /**\n     * Puts the given activity in picture in picture mode if possible.\n     *\n     * @return true if the activity is now in picture-in-picture mode, or false if it could not\n     * enter picture-in-picture mode.\n     */\n    boolean enterPictureInPictureMode(@NonNull ActivityRecord r, PictureInPictureParams params) {\n        // If the activity is already in picture in picture mode, then just return early\n        if (r.inPinnedWindowingMode()) {\n            return true;\n        }\n\n        // Activity supports picture-in-picture, now check that we can enter PiP at this\n        // point, if it is\n        if (!r.checkEnterPictureInPictureState(\"enterPictureInPictureMode\",\n                false /* beforeStopping */)) {\n            return false;\n        }\n\n        final Runnable enterPipRunnable = () -> {\n            synchronized (mGlobalLock) {\n                if (r.getParent() == null) {\n                    Slog.e(TAG, \"Skip enterPictureInPictureMode, destroyed \" + r);\n                    return;\n                }\n                // Only update the saved args from the args that are set\n                r.setPictureInPictureParams(params);\n                final float aspectRatio = r.pictureInPictureArgs.getAspectRatio();\n                final List<RemoteAction> actions = r.pictureInPictureArgs.getActions();\n                mRootWindowContainer.moveActivityToPinnedRootTask(\n                        r, \"enterPictureInPictureMode\");\n                final Task rootTask = r.getRootTask();\n                rootTask.setPictureInPictureAspectRatio(aspectRatio);\n                rootTask.setPictureInPictureActions(actions);\n            }\n        };\n\n        if (isKeyguardLocked()) {\n            // If the keyguard is showing or occluded, then try and dismiss it before\n            // entering picture-in-picture (this will prompt the user to authenticate if the\n            // device is currently locked).\n            mActivityClientController.dismissKeyguard(r.appToken, new KeyguardDismissCallback() {\n                @Override\n                public void onDismissSucceeded() {\n                    mH.post(enterPipRunnable);\n                }\n            }, null /* message */);\n        } else {\n            // Enter picture in picture immediately otherwise\n            enterPipRunnable.run();\n        }\n        return true;\n    }\n\n    @Override\n    public void setSplitScreenResizing(boolean resizing) {\n        enforceTaskPermission(\"setSplitScreenResizing()\");\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                mTaskSupervisor.setSplitScreenResizing(resizing);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public IWindowOrganizerController getWindowOrganizerController() {\n        enforceTaskPermission(\"getWindowOrganizerController()\");\n        return mWindowOrganizerController;\n    }\n\n    /**\n     * Check that we have the features required for VR-related API calls, and throw an exception if\n     * not.\n     */\n    public void enforceSystemHasVrFeature() {\n        if (!mContext.getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE)) {\n            throw new UnsupportedOperationException(\"VR mode not supported on this device!\");\n        }\n    }\n\n    @Override\n    public boolean supportsLocalVoiceInteraction() {\n        return LocalServices.getService(VoiceInteractionManagerInternal.class)\n                .supportsLocalVoiceInteraction();\n    }\n\n    @Override\n    public boolean updateConfiguration(Configuration values) {\n        mAmInternal.enforceCallingPermission(CHANGE_CONFIGURATION, \"updateConfiguration()\");\n\n        synchronized (mGlobalLock) {\n            if (mWindowManager == null) {\n                Slog.w(TAG, \"Skip updateConfiguration because mWindowManager isn't set\");\n                return false;\n            }\n\n            if (values == null) {\n                // sentinel: fetch the current configuration from the window manager\n                values = mWindowManager.computeNewConfiguration(DEFAULT_DISPLAY);\n            }\n\n            mH.sendMessage(PooledLambda.obtainMessage(\n                    ActivityManagerInternal::updateOomLevelsForDisplay, mAmInternal,\n                    DEFAULT_DISPLAY));\n\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                if (values != null) {\n                    Settings.System.clearConfiguration(values);\n                }\n                updateConfigurationLocked(values, null, false, false /* persistent */,\n                        UserHandle.USER_NULL, false /* deferResume */,\n                        mTmpUpdateConfigurationResult);\n                return mTmpUpdateConfigurationResult.changes != 0;\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public void cancelTaskWindowTransition(int taskId) {\n        enforceTaskPermission(\"cancelTaskWindowTransition()\");\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final Task task = mRootWindowContainer.anyTaskForId(taskId,\n                        MATCH_ATTACHED_TASK_ONLY);\n                if (task == null) {\n                    Slog.w(TAG, \"cancelTaskWindowTransition: taskId=\" + taskId + \" not found\");\n                    return;\n                }\n                task.cancelTaskWindowTransition();\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public TaskSnapshot getTaskSnapshot(int taskId, boolean isLowResolution) {\n        mAmInternal.enforceCallingPermission(READ_FRAME_BUFFER, \"getTaskSnapshot()\");\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            return getTaskSnapshot(taskId, isLowResolution, true /* restoreFromDisk */);\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    private TaskSnapshot getTaskSnapshot(int taskId, boolean isLowResolution,\n            boolean restoreFromDisk) {\n        final Task task;\n        synchronized (mGlobalLock) {\n            task = mRootWindowContainer.anyTaskForId(taskId,\n                    MATCH_ATTACHED_TASK_OR_RECENT_TASKS);\n            if (task == null) {\n                Slog.w(TAG, \"getTaskSnapshot: taskId=\" + taskId + \" not found\");\n                return null;\n            }\n        }\n        // Don't call this while holding the lock as this operation might hit the disk.\n        return task.getSnapshot(isLowResolution, restoreFromDisk);\n    }\n\n    /** Return the user id of the last resumed activity. */\n    @Override\n    public @UserIdInt\n    int getLastResumedActivityUserId() {\n        mAmInternal.enforceCallingPermission(\n                Manifest.permission.INTERACT_ACROSS_USERS_FULL, \"getLastResumedActivityUserId()\");\n        synchronized (mGlobalLock) {\n            if (mLastResumedActivity == null) {\n                return getCurrentUserId();\n            }\n            return mLastResumedActivity.mUserId;\n        }\n    }\n\n    @Override\n    public void updateLockTaskFeatures(int userId, int flags) {\n        final int callingUid = Binder.getCallingUid();\n        if (callingUid != 0 && callingUid != SYSTEM_UID) {\n            mAmInternal.enforceCallingPermission(\n                    android.Manifest.permission.UPDATE_LOCK_TASK_PACKAGES,\n                    \"updateLockTaskFeatures()\");\n        }\n        synchronized (mGlobalLock) {\n            ProtoLog.w(WM_DEBUG_LOCKTASK, \"Allowing features %d:0x%s\",\n                    userId, Integer.toHexString(flags));\n            getLockTaskController().updateLockTaskFeatures(userId, flags);\n        }\n    }\n\n    @Override\n    public void registerRemoteAnimationForNextActivityStart(String packageName,\n            RemoteAnimationAdapter adapter) {\n        mAmInternal.enforceCallingPermission(CONTROL_REMOTE_APP_TRANSITION_ANIMATIONS,\n                \"registerRemoteAnimationForNextActivityStart\");\n        adapter.setCallingPidUid(Binder.getCallingPid(), Binder.getCallingUid());\n        synchronized (mGlobalLock) {\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                getActivityStartController().registerRemoteAnimationForNextActivityStart(\n                        packageName, adapter);\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public void registerRemoteAnimationsForDisplay(int displayId,\n            RemoteAnimationDefinition definition) {\n        mAmInternal.enforceCallingPermission(CONTROL_REMOTE_APP_TRANSITION_ANIMATIONS,\n                \"registerRemoteAnimations\");\n        definition.setCallingPidUid(Binder.getCallingPid(), Binder.getCallingUid());\n        synchronized (mGlobalLock) {\n            final DisplayContent display = mRootWindowContainer.getDisplayContent(displayId);\n            if (display == null) {\n                Slog.e(TAG, \"Couldn't find display with id: \" + displayId);\n                return;\n            }\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                display.registerRemoteAnimations(definition);\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    /** @see android.app.ActivityManager#alwaysShowUnsupportedCompileSdkWarning */\n    @Override\n    public void alwaysShowUnsupportedCompileSdkWarning(ComponentName activity) {\n        synchronized (mGlobalLock) {\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                mAppWarnings.alwaysShowUnsupportedCompileSdkWarning(activity);\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public void setVrThread(int tid) {\n        enforceSystemHasVrFeature();\n        synchronized (mGlobalLock) {\n            final int pid = Binder.getCallingPid();\n            final WindowProcessController wpc = mProcessMap.getProcess(pid);\n            mVrController.setVrThreadLocked(tid, pid, wpc);\n        }\n    }\n\n    @Override\n    public void setPersistentVrThread(int tid) {\n        if (checkCallingPermission(Manifest.permission.RESTRICTED_VR_ACCESS)\n                != PERMISSION_GRANTED) {\n            final String msg = \"Permission Denial: setPersistentVrThread() from pid=\"\n                    + Binder.getCallingPid()\n                    + \", uid=\" + Binder.getCallingUid()\n                    + \" requires \" + Manifest.permission.RESTRICTED_VR_ACCESS;\n            Slog.w(TAG, msg);\n            throw new SecurityException(msg);\n        }\n        enforceSystemHasVrFeature();\n        synchronized (mGlobalLock) {\n            final int pid = Binder.getCallingPid();\n            final WindowProcessController proc = mProcessMap.getProcess(pid);\n            mVrController.setPersistentVrThreadLocked(tid, pid, proc);\n        }\n    }\n\n    @Override\n    public void stopAppSwitches() {\n        mAmInternal.enforceCallingPermission(STOP_APP_SWITCHES, \"stopAppSwitches\");\n        synchronized (mGlobalLock) {\n            mAppSwitchesAllowed = false;\n            mLastStopAppSwitchesTime = SystemClock.uptimeMillis();\n        }\n    }\n\n    @Override\n    public void resumeAppSwitches() {\n        mAmInternal.enforceCallingPermission(STOP_APP_SWITCHES, \"resumeAppSwitches\");\n        synchronized (mGlobalLock) {\n            mAppSwitchesAllowed = true;\n        }\n    }\n\n    long getLastStopAppSwitchesTime() {\n        return mLastStopAppSwitchesTime;\n    }\n\n    /** @return whether the system should disable UI modes incompatible with VR mode. */\n    boolean shouldDisableNonVrUiLocked() {\n        return mVrController.shouldDisableNonVrUiLocked();\n    }\n\n    void applyUpdateVrModeLocked(ActivityRecord r) {\n        // VR apps are expected to run in a main display. If an app is turning on VR for\n        // itself, but isn't on the main display, then move it there before enabling VR Mode.\n        if (r.requestedVrComponent != null && r.getDisplayId() != DEFAULT_DISPLAY) {\n            Slog.i(TAG, \"Moving \" + r.shortComponentName + \" from display \" + r.getDisplayId()\n                    + \" to main display for VR\");\n            mRootWindowContainer.moveRootTaskToDisplay(\n                    r.getRootTaskId(), DEFAULT_DISPLAY, true /* toTop */);\n        }\n        mH.post(() -> {\n            if (!mVrController.onVrModeChanged(r)) {\n                return;\n            }\n            synchronized (mGlobalLock) {\n                final boolean disableNonVrUi = mVrController.shouldDisableNonVrUiLocked();\n                mWindowManager.disableNonVrUi(disableNonVrUi);\n                if (disableNonVrUi) {\n                    // If we are in a VR mode where Picture-in-Picture mode is unsupported,\n                    // then remove the root pinned task.\n                    mRootWindowContainer.removeRootTasksInWindowingModes(WINDOWING_MODE_PINNED);\n                }\n            }\n        });\n    }\n\n    @Override\n    public int getPackageScreenCompatMode(String packageName) {\n        enforceNotIsolatedCaller(\"getPackageScreenCompatMode\");\n        synchronized (mGlobalLock) {\n            return mCompatModePackages.getPackageScreenCompatModeLocked(packageName);\n        }\n    }\n\n    @Override\n    public void setPackageScreenCompatMode(String packageName, int mode) {\n        mAmInternal.enforceCallingPermission(android.Manifest.permission.SET_SCREEN_COMPATIBILITY,\n                \"setPackageScreenCompatMode\");\n        synchronized (mGlobalLock) {\n            mCompatModePackages.setPackageScreenCompatModeLocked(packageName, mode);\n        }\n    }\n\n    @Override\n    public boolean getPackageAskScreenCompat(String packageName) {\n        enforceNotIsolatedCaller(\"getPackageAskScreenCompat\");\n        synchronized (mGlobalLock) {\n            return mCompatModePackages.getPackageAskCompatModeLocked(packageName);\n        }\n    }\n\n    @Override\n    public void setPackageAskScreenCompat(String packageName, boolean ask) {\n        mAmInternal.enforceCallingPermission(android.Manifest.permission.SET_SCREEN_COMPATIBILITY,\n                \"setPackageAskScreenCompat\");\n        synchronized (mGlobalLock) {\n            mCompatModePackages.setPackageAskCompatModeLocked(packageName, ask);\n        }\n    }\n\n    public static String relaunchReasonToString(int relaunchReason) {\n        switch (relaunchReason) {\n            case RELAUNCH_REASON_WINDOWING_MODE_RESIZE:\n                return \"window_resize\";\n            case RELAUNCH_REASON_FREE_RESIZE:\n                return \"free_resize\";\n            default:\n                return null;\n        }\n    }\n\n    Task getTopDisplayFocusedRootTask() {\n        return mRootWindowContainer.getTopDisplayFocusedRootTask();\n    }\n\n    /** Pokes the task persister. */\n    void notifyTaskPersisterLocked(Task task, boolean flush) {\n        mRecentTasks.notifyTaskPersisterLocked(task, flush);\n    }\n\n    boolean isKeyguardLocked() {\n        return mKeyguardController.isKeyguardLocked();\n    }\n\n    /**\n     * Clears launch params for the given package.\n     *\n     * @param packageNames the names of the packages of which the launch params are to be cleared\n     */\n    @Override\n    public void clearLaunchParamsForPackages(List<String> packageNames) {\n        enforceTaskPermission(\"clearLaunchParamsForPackages\");\n        synchronized (mGlobalLock) {\n            for (int i = 0; i < packageNames.size(); ++i) {\n                mTaskSupervisor.mLaunchParamsPersister.removeRecordForPackage(packageNames.get(i));\n            }\n        }\n    }\n\n    @Override\n    public void onPictureInPictureStateChanged(PictureInPictureUiState pipState) {\n        enforceTaskPermission(\"onPictureInPictureStateChanged\");\n        final Task rootPinnedStask = mRootWindowContainer.getDefaultTaskDisplayArea()\n                .getRootPinnedTask();\n        if (rootPinnedStask != null && rootPinnedStask.getTopMostActivity() != null) {\n            mWindowManager.mAtmService.mActivityClientController.onPictureInPictureStateChanged(\n                    rootPinnedStask.getTopMostActivity(), pipState);\n        }\n    }\n\n    void dumpLastANRLocked(PrintWriter pw) {\n        pw.println(\"ACTIVITY MANAGER LAST ANR (dumpsys activity lastanr)\");\n        if (mLastANRState == null) {\n            pw.println(\"  <no ANR has occurred since boot>\");\n        } else {\n            pw.println(mLastANRState);\n        }\n    }\n\n    void dumpLastANRTracesLocked(PrintWriter pw) {\n        pw.println(\"ACTIVITY MANAGER LAST ANR TRACES (dumpsys activity lastanr-traces)\");\n\n        final File[] files = new File(ANR_TRACE_DIR).listFiles();\n        if (ArrayUtils.isEmpty(files)) {\n            pw.println(\"  <no ANR has occurred since boot>\");\n            return;\n        }\n        // Find the latest file.\n        File latest = null;\n        for (File f : files) {\n            if ((latest == null) || (latest.lastModified() < f.lastModified())) {\n                latest = f;\n            }\n        }\n        pw.print(\"File: \");\n        pw.print(latest.getName());\n        pw.println();\n        try (BufferedReader in = new BufferedReader(new FileReader(latest))) {\n            String line;\n            while ((line = in.readLine()) != null) {\n                pw.println(line);\n            }\n        } catch (IOException e) {\n            pw.print(\"Unable to read: \");\n            pw.print(e);\n            pw.println();\n        }\n    }\n\n    void dumpTopResumedActivityLocked(PrintWriter pw) {\n        pw.println(\"ACTIVITY MANAGER TOP-RESUMED (dumpsys activity top-resumed)\");\n        ActivityRecord topRecord = mRootWindowContainer.getTopResumedActivity();\n        if (topRecord != null) {\n            topRecord.dump(pw, \"\", true);\n        }\n    }\n\n    void dumpActivitiesLocked(FileDescriptor fd, PrintWriter pw, String[] args,\n            int opti, boolean dumpAll, boolean dumpClient, String dumpPackage) {\n        dumpActivitiesLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage,\n                \"ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)\");\n    }\n\n    void dumpActivitiesLocked(FileDescriptor fd, PrintWriter pw, String[] args,\n            int opti, boolean dumpAll, boolean dumpClient, String dumpPackage, String header) {\n        pw.println(header);\n\n        boolean printedAnything = mRootWindowContainer.dumpActivities(fd, pw, dumpAll, dumpClient,\n                dumpPackage);\n        boolean needSep = printedAnything;\n\n        boolean printed = ActivityTaskSupervisor.printThisActivity(pw,\n                mRootWindowContainer.getTopResumedActivity(), dumpPackage, needSep,\n                \"  ResumedActivity: \", null);\n        if (printed) {\n            printedAnything = true;\n            needSep = false;\n        }\n\n        if (dumpPackage == null) {\n            if (needSep) {\n                pw.println();\n            }\n            printedAnything = true;\n            mTaskSupervisor.dump(pw, \"  \");\n            mTaskOrganizerController.dump(pw, \"  \");\n            mVisibleActivityProcessTracker.dump(pw, \"  \");\n            mActiveUids.dump(pw, \"  \");\n        }\n\n        if (!printedAnything) {\n            pw.println(\"  (nothing)\");\n        }\n    }\n\n    void dumpActivityContainersLocked(PrintWriter pw) {\n        pw.println(\"ACTIVITY MANAGER CONTAINERS (dumpsys activity containers)\");\n        mRootWindowContainer.dumpChildrenNames(pw, \" \");\n        pw.println(\" \");\n    }\n\n    void dumpActivityStarterLocked(PrintWriter pw, String dumpPackage) {\n        pw.println(\"ACTIVITY MANAGER STARTER (dumpsys activity starter)\");\n        getActivityStartController().dump(pw, \"\", dumpPackage);\n    }\n\n    /**\n     * There are three things that cmd can be:\n     * - a flattened component name that matches an existing activity\n     * - the cmd arg isn't the flattened component name of an existing activity:\n     * dump all activity whose component contains the cmd as a substring\n     * - A hex number of the ActivityRecord object instance.\n     * <p>\n     * The caller should not hold lock when calling this method because it will wait for the\n     * activities to complete the dump.\n     *\n     * @param dumpVisibleRootTasksOnly dump activity with {@param name} only if in a visible root\n     *                                 task\n     * @param dumpFocusedRootTaskOnly  dump activity with {@param name} only if in the focused\n     *                                 root task\n     */\n    protected boolean dumpActivity(FileDescriptor fd, PrintWriter pw, String name, String[] args,\n            int opti, boolean dumpAll, boolean dumpVisibleRootTasksOnly,\n            boolean dumpFocusedRootTaskOnly) {\n        ArrayList<ActivityRecord> activities;\n\n        synchronized (mGlobalLock) {\n            activities = mRootWindowContainer.getDumpActivities(name, dumpVisibleRootTasksOnly,\n                    dumpFocusedRootTaskOnly);\n        }\n\n        if (activities.size() <= 0) {\n            return false;\n        }\n\n        String[] newArgs = new String[args.length - opti];\n        System.arraycopy(args, opti, newArgs, 0, args.length - opti);\n\n        Task lastTask = null;\n        boolean needSep = false;\n        for (int i = activities.size() - 1; i >= 0; i--) {\n            ActivityRecord r = activities.get(i);\n            if (needSep) {\n                pw.println();\n            }\n            needSep = true;\n            synchronized (mGlobalLock) {\n                final Task task = r.getTask();\n                if (lastTask != task) {\n                    lastTask = task;\n                    pw.print(\"TASK \");\n                    pw.print(lastTask.affinity);\n                    pw.print(\" id=\");\n                    pw.print(lastTask.mTaskId);\n                    pw.print(\" userId=\");\n                    pw.println(lastTask.mUserId);\n                    if (dumpAll) {\n                        lastTask.dump(pw, \"  \");\n                    }\n                }\n            }\n            dumpActivity(\"  \", fd, pw, activities.get(i), newArgs, dumpAll);\n        }\n        return true;\n    }\n\n    /**\n     * Invokes IApplicationThread.dumpActivity() on the thread of the specified activity if\n     * there is a thread associated with the activity.\n     */\n    private void dumpActivity(String prefix, FileDescriptor fd, PrintWriter pw,\n            final ActivityRecord r, String[] args, boolean dumpAll) {\n        String innerPrefix = prefix + \"  \";\n        IApplicationThread appThread = null;\n        synchronized (mGlobalLock) {\n            pw.print(prefix);\n            pw.print(\"ACTIVITY \");\n            pw.print(r.shortComponentName);\n            pw.print(\" \");\n            pw.print(Integer.toHexString(System.identityHashCode(r)));\n            pw.print(\" pid=\");\n            if (r.hasProcess()) {\n                pw.println(r.app.getPid());\n                appThread = r.app.getThread();\n            } else {\n                pw.println(\"(not running)\");\n            }\n            if (dumpAll) {\n                r.dump(pw, innerPrefix, true /* dumpAll */);\n            }\n        }\n        if (appThread != null) {\n            // flush anything that is already in the PrintWriter since the thread is going\n            // to write to the file descriptor directly\n            pw.flush();\n            try (TransferPipe tp = new TransferPipe()) {\n                appThread.dumpActivity(tp.getWriteFd(), r.appToken, innerPrefix, args);\n                tp.go(fd);\n            } catch (IOException e) {\n                pw.println(innerPrefix + \"Failure while dumping the activity: \" + e);\n            } catch (RemoteException e) {\n                pw.println(innerPrefix + \"Got a RemoteException while dumping the activity\");\n            }\n        }\n    }\n\n    private void writeSleepStateToProto(ProtoOutputStream proto, int wakeFullness,\n            boolean testPssMode) {\n        final long sleepToken = proto.start(ActivityManagerServiceDumpProcessesProto.SLEEP_STATUS);\n        proto.write(ActivityManagerServiceDumpProcessesProto.SleepStatus.WAKEFULNESS,\n                PowerManagerInternal.wakefulnessToProtoEnum(wakeFullness));\n        final int tokenSize = mRootWindowContainer.mSleepTokens.size();\n        for (int i = 0; i < tokenSize; i++) {\n            final RootWindowContainer.SleepToken st =\n                    mRootWindowContainer.mSleepTokens.valueAt(i);\n            proto.write(ActivityManagerServiceDumpProcessesProto.SleepStatus.SLEEP_TOKENS,\n                    st.toString());\n        }\n        proto.write(ActivityManagerServiceDumpProcessesProto.SleepStatus.SLEEPING, mSleeping);\n        proto.write(ActivityManagerServiceDumpProcessesProto.SleepStatus.SHUTTING_DOWN,\n                mShuttingDown);\n        proto.write(ActivityManagerServiceDumpProcessesProto.SleepStatus.TEST_PSS_MODE,\n                testPssMode);\n        proto.end(sleepToken);\n    }\n\n    int getCurrentUserId() {\n        return mAmInternal.getCurrentUserId();\n    }\n\n    static void enforceNotIsolatedCaller(String caller) {\n        if (UserHandle.isIsolated(Binder.getCallingUid())) {\n            throw new SecurityException(\"Isolated process not allowed to call \" + caller);\n        }\n    }\n\n    public Configuration getConfiguration() {\n        Configuration ci;\n        synchronized (mGlobalLock) {\n            ci = new Configuration(getGlobalConfigurationForCallingPid());\n            ci.userSetLocale = false;\n        }\n        return ci;\n    }\n\n    /**\n     * Current global configuration information. Contains general settings for the entire system,\n     * also corresponds to the merged configuration of the default display.\n     */\n    Configuration getGlobalConfiguration() {\n        // Return default configuration before mRootWindowContainer initialized, which happens\n        // while initializing process record for system, see {@link\n        // ActivityManagerService#setSystemProcess}.\n        return mRootWindowContainer != null ? mRootWindowContainer.getConfiguration()\n                : new Configuration();\n    }\n\n    boolean updateConfigurationLocked(Configuration values, ActivityRecord starting,\n            boolean initLocale) {\n        return updateConfigurationLocked(values, starting, initLocale, false /* deferResume */);\n    }\n\n    boolean updateConfigurationLocked(Configuration values, ActivityRecord starting,\n            boolean initLocale, boolean deferResume) {\n        // pass UserHandle.USER_NULL as userId because we don't persist configuration for any user\n        return updateConfigurationLocked(values, starting, initLocale, false /* persistent */,\n                UserHandle.USER_NULL, deferResume);\n    }\n\n    public void updatePersistentConfiguration(Configuration values, @UserIdInt int userId) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                updateConfigurationLocked(values, null, false, true, userId,\n                        false /* deferResume */);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    private boolean updateConfigurationLocked(Configuration values, ActivityRecord starting,\n            boolean initLocale, boolean persistent, int userId, boolean deferResume) {\n        return updateConfigurationLocked(values, starting, initLocale, persistent, userId,\n                deferResume, null /* result */);\n    }\n\n    /**\n     * Do either or both things: (1) change the current configuration, and (2)\n     * make sure the given activity is running with the (now) current\n     * configuration.  Returns true if the activity has been left running, or\n     * false if <var>starting</var> is being destroyed to match the new\n     * configuration.\n     *\n     * @param userId is only used when persistent parameter is set to true to persist configuration\n     *               for that particular user\n     */\n    boolean updateConfigurationLocked(Configuration values, ActivityRecord starting,\n            boolean initLocale, boolean persistent, int userId, boolean deferResume,\n            ActivityTaskManagerService.UpdateConfigurationResult result) {\n        int changes = 0;\n        boolean kept = true;\n\n        deferWindowLayout();\n        try {\n            if (values != null) {\n                changes = updateGlobalConfigurationLocked(values, initLocale, persistent, userId);\n            }\n\n            if (!deferResume) {\n                kept = ensureConfigAndVisibilityAfterUpdate(starting, changes);\n            }\n        } finally {\n            continueWindowLayout();\n        }\n\n        if (result != null) {\n            result.changes = changes;\n            result.activityRelaunched = !kept;\n        }\n        return kept;\n    }\n\n    /** Update default (global) configuration and notify listeners about changes. */\n    int updateGlobalConfigurationLocked(@NonNull Configuration values, boolean initLocale,\n            boolean persistent, int userId) {\n\n        mTempConfig.setTo(getGlobalConfiguration());\n        final int changes = mTempConfig.updateFrom(values);\n        if (changes == 0) {\n            return 0;\n        }\n\n        ProtoLog.i(WM_DEBUG_CONFIGURATION, \"Updating global configuration \"\n                + \"to: %s\", values);\n        writeConfigurationChanged(changes);\n        FrameworkStatsLog.write(FrameworkStatsLog.RESOURCE_CONFIGURATION_CHANGED,\n                values.colorMode,\n                values.densityDpi,\n                values.fontScale,\n                values.hardKeyboardHidden,\n                values.keyboard,\n                values.keyboardHidden,\n                values.mcc,\n                values.mnc,\n                values.navigation,\n                values.navigationHidden,\n                values.orientation,\n                values.screenHeightDp,\n                values.screenLayout,\n                values.screenWidthDp,\n                values.smallestScreenWidthDp,\n                values.touchscreen,\n                values.uiMode);\n\n\n        if (!initLocale && !values.getLocales().isEmpty() && values.userSetLocale) {\n            final LocaleList locales = values.getLocales();\n            int bestLocaleIndex = 0;\n            if (locales.size() > 1) {\n                if (mSupportedSystemLocales == null) {\n                    mSupportedSystemLocales = Resources.getSystem().getAssets().getLocales();\n                }\n                bestLocaleIndex = Math.max(0, locales.getFirstMatchIndex(mSupportedSystemLocales));\n            }\n            SystemProperties.set(\"persist.sys.locale\",\n                    locales.get(bestLocaleIndex).toLanguageTag());\n            LocaleList.setDefault(locales, bestLocaleIndex);\n\n            final Message m = PooledLambda.obtainMessage(\n                    ActivityTaskManagerService::sendLocaleToMountDaemonMsg, this,\n                    locales.get(bestLocaleIndex));\n            mH.sendMessage(m);\n        }\n\n        mTempConfig.seq = increaseConfigurationSeqLocked();\n\n        Slog.i(TAG, \"Config changes=\" + Integer.toHexString(changes) + \" \" + mTempConfig);\n        // TODO(multi-display): Update UsageEvents#Event to include displayId.\n        mUsageStatsInternal.reportConfigurationChange(mTempConfig, mAmInternal.getCurrentUserId());\n\n        // TODO: If our config changes, should we auto dismiss any currently showing dialogs?\n        updateShouldShowDialogsLocked(mTempConfig);\n\n        AttributeCache ac = AttributeCache.instance();\n        if (ac != null) {\n            ac.updateConfiguration(mTempConfig);\n        }\n\n        // Make sure all resources in our process are updated right now, so that anyone who is going\n        // to retrieve resource values after we return will be sure to get the new ones. This is\n        // especially important during boot, where the first config change needs to guarantee all\n        // resources have that config before following boot code is executed.\n        mSystemThread.applyConfigurationToResources(mTempConfig);\n\n        if (persistent && Settings.System.hasInterestingConfigurationChanges(changes)) {\n            final Message msg = PooledLambda.obtainMessage(\n                    ActivityTaskManagerService::sendPutConfigurationForUserMsg,\n                    this, userId, new Configuration(mTempConfig));\n            mH.sendMessage(msg);\n        }\n\n        SparseArray<WindowProcessController> pidMap = mProcessMap.getPidMap();\n        for (int i = pidMap.size() - 1; i >= 0; i--) {\n            final int pid = pidMap.keyAt(i);\n            final WindowProcessController app = pidMap.get(pid);\n            ProtoLog.v(WM_DEBUG_CONFIGURATION, \"Update process config of %s to new \"\n                    + \"config %s\", app.mName, mTempConfig);\n            app.onConfigurationChanged(mTempConfig);\n        }\n\n        final Message msg = PooledLambda.obtainMessage(\n                ActivityManagerInternal::broadcastGlobalConfigurationChanged,\n                mAmInternal, changes, initLocale);\n        mH.sendMessage(msg);\n\n        // Update stored global config and notify everyone about the change.\n        mRootWindowContainer.onConfigurationChanged(mTempConfig);\n\n        return changes;\n    }\n\n    private int increaseAssetConfigurationSeq() {\n        mGlobalAssetsSeq = Math.max(++mGlobalAssetsSeq, 1);\n        return mGlobalAssetsSeq;\n    }\n\n    /**\n     * Update the asset configuration and increase the assets sequence number.\n     * @param processes the processes that needs to update the asset configuration\n     */\n    public void updateAssetConfiguration(List<WindowProcessController> processes,\n            boolean updateFrameworkRes) {\n        synchronized (mGlobalLock) {\n            final int assetSeq = increaseAssetConfigurationSeq();\n\n            if (updateFrameworkRes) {\n                Configuration newConfig = new Configuration();\n                newConfig.assetsSeq = assetSeq;\n                updateConfiguration(newConfig);\n            }\n\n            // Always update the override of every process so the asset sequence of the process is\n            // always greater than or equal to the global configuration.\n            for (int i = processes.size() - 1; i >= 0; i--) {\n                final WindowProcessController wpc = processes.get(i);\n                wpc.updateAssetConfiguration(assetSeq);\n            }\n        }\n    }\n\n    void startLaunchPowerMode(@PowerModeReason int reason) {\n        if (mPowerManagerInternal == null) return;\n        mPowerManagerInternal.setPowerMode(Mode.LAUNCH, true);\n        mLaunchPowerModeReasons |= reason;\n    }\n\n    void endLaunchPowerMode(@PowerModeReason int reason) {\n        if (mPowerManagerInternal == null || mLaunchPowerModeReasons == 0) return;\n        mLaunchPowerModeReasons &= ~reason;\n        if (mLaunchPowerModeReasons == 0) {\n            mPowerManagerInternal.setPowerMode(Mode.LAUNCH, false);\n        }\n    }\n\n    /** @see WindowSurfacePlacer#deferLayout */\n    void deferWindowLayout() {\n        if (!mWindowManager.mWindowPlacerLocked.isLayoutDeferred()) {\n            // Reset the reasons at the first entrance because we only care about the changes in the\n            // deferred scope.\n            mLayoutReasons = 0;\n        }\n\n        mWindowManager.mWindowPlacerLocked.deferLayout();\n    }\n\n    /** @see WindowSurfacePlacer#continueLayout */\n    void continueWindowLayout() {\n        mWindowManager.mWindowPlacerLocked.continueLayout(mLayoutReasons != 0);\n        if (DEBUG_ALL && !mWindowManager.mWindowPlacerLocked.isLayoutDeferred()) {\n            Slog.i(TAG, \"continueWindowLayout reason=\" + mLayoutReasons);\n        }\n    }\n\n    /**\n     * If a reason is added between {@link #deferWindowLayout} and {@link #continueWindowLayout},\n     * it will make sure {@link WindowSurfacePlacer#performSurfacePlacement} is called when the last\n     * defer count is gone.\n     */\n    void addWindowLayoutReasons(@LayoutReason int reasons) {\n        mLayoutReasons |= reasons;\n    }\n\n    private void updateEventDispatchingLocked(boolean booted) {\n        mWindowManager.setEventDispatching(booted && !mShuttingDown);\n    }\n\n    private void sendPutConfigurationForUserMsg(int userId, Configuration config) {\n        final ContentResolver resolver = mContext.getContentResolver();\n        Settings.System.putConfigurationForUser(resolver, config, userId);\n    }\n\n    private void sendLocaleToMountDaemonMsg(Locale l) {\n        try {\n            IBinder service = ServiceManager.getService(\"mount\");\n            IStorageManager storageManager = IStorageManager.Stub.asInterface(service);\n            Log.d(TAG, \"Storing locale \" + l.toLanguageTag() + \" for decryption UI\");\n            storageManager.setField(StorageManager.SYSTEM_LOCALE_KEY, l.toLanguageTag());\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Error storing locale for decryption UI\", e);\n        }\n    }\n\n    private void expireStartAsCallerTokenMsg(IBinder permissionToken) {\n        mStartActivitySources.remove(permissionToken);\n        mExpiredStartAsCallerTokens.add(permissionToken);\n    }\n\n    private void forgetStartAsCallerTokenMsg(IBinder permissionToken) {\n        mExpiredStartAsCallerTokens.remove(permissionToken);\n    }\n\n    boolean isActivityStartsLoggingEnabled() {\n        return mAmInternal.isActivityStartsLoggingEnabled();\n    }\n\n    boolean isBackgroundActivityStartsEnabled() {\n        return mAmInternal.isBackgroundActivityStartsEnabled();\n    }\n\n    static long getInputDispatchingTimeoutMillisLocked(ActivityRecord r) {\n        if (r == null || !r.hasProcess()) {\n            return DEFAULT_DISPATCHING_TIMEOUT_MILLIS;\n        }\n        return getInputDispatchingTimeoutMillisLocked(r.app);\n    }\n\n    private static long getInputDispatchingTimeoutMillisLocked(WindowProcessController r) {\n        if (r == null) {\n            return DEFAULT_DISPATCHING_TIMEOUT_MILLIS;\n        }\n        return r.getInputDispatchingTimeoutMillis();\n    }\n\n    /**\n     * Decide based on the configuration whether we should show the ANR,\n     * crash, etc dialogs.  The idea is that if there is no affordance to\n     * press the on-screen buttons, or the user experience would be more\n     * greatly impacted than the crash itself, we shouldn't show the dialog.\n     *\n     * A thought: SystemUI might also want to get told about this, the Power\n     * dialog / global actions also might want different behaviors.\n     */\n    private void updateShouldShowDialogsLocked(Configuration config) {\n        final boolean inputMethodExists = !(config.keyboard == Configuration.KEYBOARD_NOKEYS\n                && config.touchscreen == Configuration.TOUCHSCREEN_NOTOUCH\n                && config.navigation == Configuration.NAVIGATION_NONAV);\n        final boolean hideDialogsSet = Settings.Global.getInt(mContext.getContentResolver(),\n                HIDE_ERROR_DIALOGS, 0) != 0;\n        mShowDialogs = inputMethodExists\n                && ActivityTaskManager.currentUiModeSupportsErrorDialogs(config)\n                && !hideDialogsSet;\n    }\n\n    private void updateFontScaleIfNeeded(@UserIdInt int userId) {\n        final float scaleFactor = Settings.System.getFloatForUser(mContext.getContentResolver(),\n                FONT_SCALE, 1.0f, userId);\n\n        synchronized (mGlobalLock) {\n            if (getGlobalConfiguration().fontScale == scaleFactor) {\n                return;\n            }\n\n            final Configuration configuration\n                    = mWindowManager.computeNewConfiguration(DEFAULT_DISPLAY);\n            configuration.fontScale = scaleFactor;\n            updatePersistentConfiguration(configuration, userId);\n        }\n    }\n\n    private void updateFontWeightAdjustmentIfNeeded(@UserIdInt int userId) {\n        final int fontWeightAdjustment =\n                Settings.Secure.getIntForUser(\n                        mContext.getContentResolver(),\n                        Settings.Secure.FONT_WEIGHT_ADJUSTMENT,\n                        Configuration.FONT_WEIGHT_ADJUSTMENT_UNDEFINED,\n                        userId);\n\n        synchronized (mGlobalLock) {\n            if (getGlobalConfiguration().fontWeightAdjustment == fontWeightAdjustment) {\n                return;\n            }\n\n            final Configuration configuration =\n                    mWindowManager.computeNewConfiguration(DEFAULT_DISPLAY);\n            configuration.fontWeightAdjustment = fontWeightAdjustment;\n            updatePersistentConfiguration(configuration, userId);\n        }\n    }\n\n    // Actually is sleeping or shutting down or whatever else in the future\n    // is an inactive state.\n    boolean isSleepingOrShuttingDownLocked() {\n        return isSleepingLocked() || mShuttingDown;\n    }\n\n    boolean isSleepingLocked() {\n        return mSleeping;\n    }\n\n    /** Update AMS states when an activity is resumed. */\n    void setResumedActivityUncheckLocked(ActivityRecord r, String reason) {\n        final Task task = r.getTask();\n        if (task.isActivityTypeStandard()) {\n            if (mCurAppTimeTracker != r.appTimeTracker) {\n                // We are switching app tracking.  Complete the current one.\n                if (mCurAppTimeTracker != null) {\n                    mCurAppTimeTracker.stop();\n                    mH.obtainMessage(\n                            REPORT_TIME_TRACKER_MSG, mCurAppTimeTracker).sendToTarget();\n                    mRootWindowContainer.clearOtherAppTimeTrackers(r.appTimeTracker);\n                    mCurAppTimeTracker = null;\n                }\n                if (r.appTimeTracker != null) {\n                    mCurAppTimeTracker = r.appTimeTracker;\n                    startTimeTrackingFocusedActivityLocked();\n                }\n            } else {\n                startTimeTrackingFocusedActivityLocked();\n            }\n        } else {\n            r.appTimeTracker = null;\n        }\n        // TODO: VI Maybe r.task.voiceInteractor || r.voiceInteractor != null\n        // TODO: Probably not, because we don't want to resume voice on switching\n        // back to this activity\n        if (task.voiceInteractor != null) {\n            startRunningVoiceLocked(task.voiceSession, r.info.applicationInfo.uid);\n        } else {\n            finishRunningVoiceLocked();\n\n            if (mLastResumedActivity != null) {\n                final IVoiceInteractionSession session;\n\n                final Task lastResumedActivityTask = mLastResumedActivity.getTask();\n                if (lastResumedActivityTask != null\n                        && lastResumedActivityTask.voiceSession != null) {\n                    session = lastResumedActivityTask.voiceSession;\n                } else {\n                    session = mLastResumedActivity.voiceSession;\n                }\n\n                if (session != null) {\n                    // We had been in a voice interaction session, but now focused has\n                    // move to something different.  Just finish the session, we can't\n                    // return to it and retain the proper state and synchronization with\n                    // the voice interaction service.\n                    finishVoiceTask(session);\n                }\n            }\n        }\n\n        if (mLastResumedActivity != null && r.mUserId != mLastResumedActivity.mUserId) {\n            mAmInternal.sendForegroundProfileChanged(r.mUserId);\n        }\n        final Task prevTask = mLastResumedActivity != null ? mLastResumedActivity.getTask() : null;\n\n        updateResumedAppTrace(r);\n        mLastResumedActivity = r;\n\n        final boolean changed = r.mDisplayContent.setFocusedApp(r);\n        if (changed) {\n            mWindowManager.updateFocusedWindowLocked(UPDATE_FOCUS_NORMAL,\n                    true /*updateInputWindows*/);\n        }\n        if (prevTask == null || task != prevTask) {\n            if (prevTask != null) {\n                mTaskChangeNotificationController.notifyTaskFocusChanged(prevTask.mTaskId, false);\n            }\n            mTaskChangeNotificationController.notifyTaskFocusChanged(task.mTaskId, true);\n        }\n\n        applyUpdateLockStateLocked(r);\n        applyUpdateVrModeLocked(r);\n\n        EventLogTags.writeWmSetResumedActivity(\n                r == null ? -1 : r.mUserId,\n                r == null ? \"NULL\" : r.shortComponentName,\n                reason);\n    }\n\n    final class SleepTokenAcquirerImpl implements ActivityTaskManagerInternal.SleepTokenAcquirer {\n        private final String mTag;\n        private final SparseArray<RootWindowContainer.SleepToken> mSleepTokens =\n                new SparseArray<>();\n\n        SleepTokenAcquirerImpl(@NonNull String tag) {\n            mTag = tag;\n        }\n\n        @Override\n        public void acquire(int displayId) {\n            synchronized (mGlobalLock) {\n                if (!mSleepTokens.contains(displayId)) {\n                    mSleepTokens.append(displayId,\n                            mRootWindowContainer.createSleepToken(mTag, displayId));\n                    updateSleepIfNeededLocked();\n                }\n            }\n        }\n\n        @Override\n        public void release(int displayId) {\n            synchronized (mGlobalLock) {\n                final RootWindowContainer.SleepToken token = mSleepTokens.get(displayId);\n                if (token != null) {\n                    mRootWindowContainer.removeSleepToken(token);\n                    mSleepTokens.remove(displayId);\n                }\n            }\n        }\n    }\n\n    void updateSleepIfNeededLocked() {\n        final boolean shouldSleep = !mRootWindowContainer.hasAwakeDisplay();\n        final boolean wasSleeping = mSleeping;\n        boolean updateOomAdj = false;\n\n        if (!shouldSleep) {\n            // If wasSleeping is true, we need to wake up activity manager state from when\n            // we started sleeping. In either case, we need to apply the sleep tokens, which\n            // will wake up root tasks or put them to sleep as appropriate.\n            if (wasSleeping) {\n                mSleeping = false;\n                FrameworkStatsLog.write(FrameworkStatsLog.ACTIVITY_MANAGER_SLEEP_STATE_CHANGED,\n                        FrameworkStatsLog.ACTIVITY_MANAGER_SLEEP_STATE_CHANGED__STATE__AWAKE);\n                startTimeTrackingFocusedActivityLocked();\n                mTopProcessState = ActivityManager.PROCESS_STATE_TOP;\n                Slog.d(TAG, \"Top Process State changed to PROCESS_STATE_TOP\");\n                mTaskSupervisor.comeOutOfSleepIfNeededLocked();\n            }\n            mRootWindowContainer.applySleepTokens(true /* applyToRootTasks */);\n            if (wasSleeping) {\n                updateOomAdj = true;\n            }\n        } else if (!mSleeping && shouldSleep) {\n            mSleeping = true;\n            FrameworkStatsLog.write(FrameworkStatsLog.ACTIVITY_MANAGER_SLEEP_STATE_CHANGED,\n                    FrameworkStatsLog.ACTIVITY_MANAGER_SLEEP_STATE_CHANGED__STATE__ASLEEP);\n            if (mCurAppTimeTracker != null) {\n                mCurAppTimeTracker.stop();\n            }\n            mTopProcessState = ActivityManager.PROCESS_STATE_TOP_SLEEPING;\n            Slog.d(TAG, \"Top Process State changed to PROCESS_STATE_TOP_SLEEPING\");\n            mTaskSupervisor.goingToSleepLocked();\n            updateResumedAppTrace(null /* resumed */);\n            updateOomAdj = true;\n        }\n        if (updateOomAdj) {\n            updateOomAdj();\n        }\n    }\n\n    void updateOomAdj() {\n        mH.removeCallbacks(mUpdateOomAdjRunnable);\n        mH.post(mUpdateOomAdjRunnable);\n    }\n\n    void updateCpuStats() {\n        mH.post(mAmInternal::updateCpuStats);\n    }\n\n    void updateBatteryStats(ActivityRecord component, boolean resumed) {\n        final Message m = PooledLambda.obtainMessage(ActivityManagerInternal::updateBatteryStats,\n                mAmInternal, component.mActivityComponent, component.app.mUid, component.mUserId,\n                resumed);\n        mH.sendMessage(m);\n    }\n\n    void updateTopApp(ActivityRecord topResumedActivity) {\n        final ActivityRecord top = topResumedActivity != null ? topResumedActivity\n                // If there is no resumed activity, it will choose the pausing or focused activity.\n                : mRootWindowContainer.getTopResumedActivity();\n        mTopApp = top != null ? top.app : null;\n    }\n\n    void updateActivityUsageStats(ActivityRecord activity, int event) {\n        ComponentName taskRoot = null;\n        final Task task = activity.getTask();\n        if (task != null) {\n            final ActivityRecord rootActivity = task.getRootActivity();\n            if (rootActivity != null) {\n                taskRoot = rootActivity.mActivityComponent;\n            }\n        }\n\n        final Message m = PooledLambda.obtainMessage(\n                ActivityManagerInternal::updateActivityUsageStats, mAmInternal,\n                activity.mActivityComponent, activity.mUserId, event, activity.appToken, taskRoot);\n        mH.sendMessage(m);\n    }\n\n    void startProcessAsync(ActivityRecord activity, boolean knownToBeDead, boolean isTop,\n            String hostingType) {\n        try {\n            if (Trace.isTagEnabled(TRACE_TAG_WINDOW_MANAGER)) {\n                Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, \"dispatchingStartProcess:\"\n                        + activity.processName);\n            }\n            // Post message to start process to avoid possible deadlock of calling into AMS with the\n            // ATMS lock held.\n            final Message m = PooledLambda.obtainMessage(ActivityManagerInternal::startProcess,\n                    mAmInternal, activity.processName, activity.info.applicationInfo, knownToBeDead,\n                    isTop, hostingType, activity.intent.getComponent());\n            mH.sendMessage(m);\n        } finally {\n            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);\n        }\n    }\n\n    void setBooting(boolean booting) {\n        mAmInternal.setBooting(booting);\n    }\n\n    boolean isBooting() {\n        return mAmInternal.isBooting();\n    }\n\n    void setBooted(boolean booted) {\n        mAmInternal.setBooted(booted);\n    }\n\n    boolean isBooted() {\n        return mAmInternal.isBooted();\n    }\n\n    void postFinishBooting(boolean finishBooting, boolean enableScreen) {\n        mH.post(() -> {\n            if (finishBooting) {\n                mAmInternal.finishBooting();\n            }\n            if (enableScreen) {\n                mInternal.enableScreenAfterBoot(isBooted());\n            }\n        });\n    }\n\n    void setHeavyWeightProcess(ActivityRecord root) {\n        mHeavyWeightProcess = root.app;\n        final Message m = PooledLambda.obtainMessage(\n                ActivityTaskManagerService::postHeavyWeightProcessNotification, this,\n                root.app, root.intent, root.mUserId);\n        mH.sendMessage(m);\n    }\n\n    void clearHeavyWeightProcessIfEquals(WindowProcessController proc) {\n        if (mHeavyWeightProcess == null || mHeavyWeightProcess != proc) {\n            return;\n        }\n\n        mHeavyWeightProcess = null;\n        final Message m = PooledLambda.obtainMessage(\n                ActivityTaskManagerService::cancelHeavyWeightProcessNotification, this,\n                proc.mUserId);\n        mH.sendMessage(m);\n    }\n\n    private void cancelHeavyWeightProcessNotification(int userId) {\n        final INotificationManager inm = NotificationManager.getService();\n        if (inm == null) {\n            return;\n        }\n        try {\n            inm.cancelNotificationWithTag(\"android\", \"android\", null,\n                    SystemMessage.NOTE_HEAVY_WEIGHT_NOTIFICATION, userId);\n        } catch (RuntimeException e) {\n            Slog.w(TAG, \"Error canceling notification for service\", e);\n        } catch (RemoteException e) {\n        }\n\n    }\n\n    private void postHeavyWeightProcessNotification(\n            WindowProcessController proc, Intent intent, int userId) {\n        if (proc == null) {\n            return;\n        }\n\n        final INotificationManager inm = NotificationManager.getService();\n        if (inm == null) {\n            return;\n        }\n\n        try {\n            Context context = mContext.createPackageContext(proc.mInfo.packageName, 0);\n            String text = mContext.getString(R.string.heavy_weight_notification,\n                    context.getApplicationInfo().loadLabel(context.getPackageManager()));\n            Notification notification =\n                    new Notification.Builder(context,\n                            SystemNotificationChannels.HEAVY_WEIGHT_APP)\n                            .setSmallIcon(com.android.internal.R.drawable.stat_sys_adb)\n                            .setWhen(0)\n                            .setOngoing(true)\n                            .setTicker(text)\n                            .setColor(mContext.getColor(\n                                    com.android.internal.R.color.system_notification_accent_color))\n                            .setContentTitle(text)\n                            .setContentText(\n                                    mContext.getText(R.string.heavy_weight_notification_detail))\n                            .setContentIntent(PendingIntent.getActivityAsUser(mContext, 0,\n                                    intent, PendingIntent.FLAG_CANCEL_CURRENT\n                                    | PendingIntent.FLAG_IMMUTABLE, null,\n                                    new UserHandle(userId)))\n                            .build();\n            try {\n                inm.enqueueNotificationWithTag(\"android\", \"android\", null,\n                        SystemMessage.NOTE_HEAVY_WEIGHT_NOTIFICATION, notification, userId);\n            } catch (RuntimeException e) {\n                Slog.w(TAG, \"Error showing notification for heavy-weight app\", e);\n            } catch (RemoteException e) {\n            }\n        } catch (PackageManager.NameNotFoundException e) {\n            Slog.w(TAG, \"Unable to create context for heavy notification\", e);\n        }\n\n    }\n\n    IIntentSender getIntentSenderLocked(int type, String packageName, String featureId,\n            int callingUid, int userId, IBinder token, String resultWho, int requestCode,\n            Intent[] intents, String[] resolvedTypes, int flags, Bundle bOptions) {\n\n        ActivityRecord activity = null;\n        if (type == ActivityManager.INTENT_SENDER_ACTIVITY_RESULT) {\n            activity = ActivityRecord.isInRootTaskLocked(token);\n            if (activity == null) {\n                Slog.w(TAG, \"Failed createPendingResult: activity \" + token\n                        + \" not in any root task\");\n                return null;\n            }\n            if (activity.finishing) {\n                Slog.w(TAG, \"Failed createPendingResult: activity \" + activity + \" is finishing\");\n                return null;\n            }\n        }\n\n        final PendingIntentRecord rec = mPendingIntentController.getIntentSender(type, packageName,\n                featureId, callingUid, userId, token, resultWho, requestCode, intents,\n                resolvedTypes, flags, bOptions);\n        final boolean noCreate = (flags & PendingIntent.FLAG_NO_CREATE) != 0;\n        if (noCreate) {\n            return rec;\n        }\n        if (type == ActivityManager.INTENT_SENDER_ACTIVITY_RESULT) {\n            if (activity.pendingResults == null) {\n                activity.pendingResults = new HashSet<>();\n            }\n            activity.pendingResults.add(rec.ref);\n        }\n        return rec;\n    }\n\n    // TODO(b/111541062): Update app time tracking to make it aware of multiple resumed activities\n    private void startTimeTrackingFocusedActivityLocked() {\n        final ActivityRecord resumedActivity = mRootWindowContainer.getTopResumedActivity();\n        if (!mSleeping && mCurAppTimeTracker != null && resumedActivity != null) {\n            mCurAppTimeTracker.start(resumedActivity.packageName);\n        }\n    }\n\n    private void updateResumedAppTrace(@Nullable ActivityRecord resumed) {\n        if (mTracedResumedActivity != null) {\n            Trace.asyncTraceEnd(TRACE_TAG_WINDOW_MANAGER,\n                    constructResumedTraceName(mTracedResumedActivity.packageName), 0);\n        }\n        if (resumed != null) {\n            Trace.asyncTraceBegin(TRACE_TAG_WINDOW_MANAGER,\n                    constructResumedTraceName(resumed.packageName), 0);\n        }\n        mTracedResumedActivity = resumed;\n    }\n\n    private String constructResumedTraceName(String packageName) {\n        return \"focused app: \" + packageName;\n    }\n\n    /** Applies latest configuration and/or visibility updates if needed. */\n    boolean ensureConfigAndVisibilityAfterUpdate(ActivityRecord starting, int changes) {\n        boolean kept = true;\n        final Task mainRootTask = mRootWindowContainer.getTopDisplayFocusedRootTask();\n        // mainRootTask is null during startup.\n        if (mainRootTask != null) {\n            if (changes != 0 && starting == null) {\n                // If the configuration changed, and the caller is not already\n                // in the process of starting an activity, then find the top\n                // activity to check if its configuration needs to change.\n                starting = mainRootTask.topRunningActivity();\n            }\n\n            if (starting != null) {\n                kept = starting.ensureActivityConfiguration(changes,\n                        false /* preserveWindow */);\n                // And we need to make sure at this point that all other activities\n                // are made visible with the correct configuration.\n                mRootWindowContainer.ensureActivitiesVisible(starting, changes,\n                        !PRESERVE_WINDOWS);\n            }\n        }\n\n        return kept;\n    }\n\n    void scheduleAppGcsLocked() {\n        mH.post(() -> mAmInternal.scheduleAppGcs());\n    }\n\n    CompatibilityInfo compatibilityInfoForPackageLocked(ApplicationInfo ai) {\n        return mCompatModePackages.compatibilityInfoForPackageLocked(ai);\n    }\n\n    /**\n     * Returns the PackageManager. Used by classes hosted by {@link ActivityTaskManagerService}. The\n     * PackageManager could be unavailable at construction time and therefore needs to be accessed\n     * on demand.\n     */\n    IPackageManager getPackageManager() {\n        return AppGlobals.getPackageManager();\n    }\n\n    PackageManagerInternal getPackageManagerInternalLocked() {\n        if (mPmInternal == null) {\n            mPmInternal = LocalServices.getService(PackageManagerInternal.class);\n        }\n        return mPmInternal;\n    }\n\n    ComponentName getSysUiServiceComponentLocked() {\n        if (mSysUiServiceComponent == null) {\n            final PackageManagerInternal pm = getPackageManagerInternalLocked();\n            mSysUiServiceComponent = pm.getSystemUiServiceComponent();\n        }\n        return mSysUiServiceComponent;\n    }\n\n    PermissionPolicyInternal getPermissionPolicyInternal() {\n        if (mPermissionPolicyInternal == null) {\n            mPermissionPolicyInternal = LocalServices.getService(PermissionPolicyInternal.class);\n        }\n        return mPermissionPolicyInternal;\n    }\n\n    StatusBarManagerInternal getStatusBarManagerInternal() {\n        if (mStatusBarManagerInternal == null) {\n            mStatusBarManagerInternal = LocalServices.getService(StatusBarManagerInternal.class);\n        }\n        return mStatusBarManagerInternal;\n    }\n\n    AppWarnings getAppWarningsLocked() {\n        return mAppWarnings;\n    }\n\n    Intent getHomeIntent() {\n        Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null);\n        intent.setComponent(mTopComponent);\n        intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING);\n        if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) {\n            intent.addCategory(Intent.CATEGORY_HOME);\n        }\n        return intent;\n    }\n\n    /**\n     * Return the intent set with {@link Intent#CATEGORY_SECONDARY_HOME} to resolve secondary home\n     * activities.\n     *\n     * @param preferredPackage Specify a preferred package name, otherwise use the package name\n     *                         defined in config_secondaryHomePackage.\n     * @return the intent set with {@link Intent#CATEGORY_SECONDARY_HOME}\n     */\n    Intent getSecondaryHomeIntent(String preferredPackage) {\n        final Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null);\n        final boolean useSystemProvidedLauncher = mContext.getResources().getBoolean(\n                com.android.internal.R.bool.config_useSystemProvidedLauncherForSecondary);\n        if (preferredPackage == null || useSystemProvidedLauncher) {\n            // Using the package name stored in config if no preferred package name or forced.\n            final String secondaryHomePackage = mContext.getResources().getString(\n                    com.android.internal.R.string.config_secondaryHomePackage);\n            intent.setPackage(secondaryHomePackage);\n        } else {\n            intent.setPackage(preferredPackage);\n        }\n        intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING);\n        if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) {\n            intent.addCategory(Intent.CATEGORY_SECONDARY_HOME);\n        }\n        return intent;\n    }\n\n    ApplicationInfo getAppInfoForUser(ApplicationInfo info, int userId) {\n        if (info == null) return null;\n        ApplicationInfo newInfo = new ApplicationInfo(info);\n        newInfo.initForUser(userId);\n        return newInfo;\n    }\n\n    WindowProcessController getProcessController(String processName, int uid) {\n        if (uid == SYSTEM_UID) {\n            // The system gets to run in any process. If there are multiple processes with the same\n            // uid, just pick the first (this should never happen).\n            final SparseArray<WindowProcessController> procs =\n                    mProcessNames.getMap().get(processName);\n            if (procs == null) return null;\n            final int procCount = procs.size();\n            for (int i = 0; i < procCount; i++) {\n                final int procUid = procs.keyAt(i);\n                if (UserHandle.isApp(procUid) || !UserHandle.isSameUser(procUid, uid)) {\n                    // Don't use an app process or different user process for system component.\n                    continue;\n                }\n                return procs.valueAt(i);\n            }\n        }\n\n        return mProcessNames.get(processName, uid);\n    }\n\n    WindowProcessController getProcessController(IApplicationThread thread) {\n        if (thread == null) {\n            return null;\n        }\n\n        final IBinder threadBinder = thread.asBinder();\n        final ArrayMap<String, SparseArray<WindowProcessController>> pmap = mProcessNames.getMap();\n        for (int i = pmap.size() - 1; i >= 0; i--) {\n            final SparseArray<WindowProcessController> procs = pmap.valueAt(i);\n            for (int j = procs.size() - 1; j >= 0; j--) {\n                final WindowProcessController proc = procs.valueAt(j);\n                if (proc.hasThread() && proc.getThread().asBinder() == threadBinder) {\n                    return proc;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    WindowProcessController getProcessController(int pid, int uid) {\n        final WindowProcessController proc = mProcessMap.getProcess(pid);\n        if (proc == null) return null;\n        if (UserHandle.isApp(uid) && proc.mUid == uid) {\n            return proc;\n        }\n        return null;\n    }\n\n    /** A uid is considered to be foreground if it has a visible non-toast window. */\n    @HotPath(caller = HotPath.START_SERVICE)\n    boolean hasActiveVisibleWindow(int uid) {\n        if (mVisibleActivityProcessTracker.hasVisibleActivity(uid)) {\n            return true;\n        }\n        return mActiveUids.hasNonAppVisibleWindow(uid);\n    }\n\n    boolean isDeviceOwner(int uid) {\n        return uid >= 0 && mDeviceOwnerUid == uid;\n    }\n\n    void setDeviceOwnerUid(int uid) {\n        mDeviceOwnerUid = uid;\n    }\n\n    /**\n     * @return allowlist tag for a uid from mPendingTempAllowlist, null if not currently on\n     * the allowlist\n     */\n    String getPendingTempAllowlistTagForUidLocked(int uid) {\n        return mPendingTempAllowlist.get(uid);\n    }\n\n    void logAppTooSlow(WindowProcessController app, long startTime, String msg) {\n        if (true || Build.IS_USER) {\n            return;\n        }\n\n        StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();\n        StrictMode.allowThreadDiskWrites();\n        try {\n            File tracesDir = new File(\"/data/anr\");\n            File tracesFile = null;\n            try {\n                tracesFile = File.createTempFile(\"app_slow\", null, tracesDir);\n\n                StringBuilder sb = new StringBuilder();\n                String timeString =\n                        TimeMigrationUtils.formatMillisWithFixedFormat(System.currentTimeMillis());\n                sb.append(timeString);\n                sb.append(\": \");\n                TimeUtils.formatDuration(SystemClock.uptimeMillis() - startTime, sb);\n                sb.append(\" since \");\n                sb.append(msg);\n                FileOutputStream fos = new FileOutputStream(tracesFile);\n                fos.write(sb.toString().getBytes());\n                if (app == null) {\n                    fos.write(\"\\n*** No application process!\".getBytes());\n                }\n                fos.close();\n                FileUtils.setPermissions(tracesFile.getPath(), 0666, -1, -1); // -rw-rw-rw-\n            } catch (IOException e) {\n                Slog.w(TAG, \"Unable to prepare slow app traces file: \" + tracesFile, e);\n                return;\n            }\n\n            if (app != null && app.getPid() > 0) {\n                ArrayList<Integer> firstPids = new ArrayList<Integer>();\n                firstPids.add(app.getPid());\n                dumpStackTraces(tracesFile.getAbsolutePath(), firstPids, null, null);\n            }\n\n            File lastTracesFile = null;\n            File curTracesFile = null;\n            for (int i = 9; i >= 0; i--) {\n                String name = String.format(Locale.US, \"slow%02d.txt\", i);\n                curTracesFile = new File(tracesDir, name);\n                if (curTracesFile.exists()) {\n                    if (lastTracesFile != null) {\n                        curTracesFile.renameTo(lastTracesFile);\n                    } else {\n                        curTracesFile.delete();\n                    }\n                }\n                lastTracesFile = curTracesFile;\n            }\n            tracesFile.renameTo(curTracesFile);\n        } finally {\n            StrictMode.setThreadPolicy(oldPolicy);\n        }\n    }\n\n    boolean isAssociatedCompanionApp(int userId, int uid) {\n        final Set<Integer> allUids = mCompanionAppUidsMap.get(userId);\n        if (allUids == null) {\n            return false;\n        }\n        return allUids.contains(uid);\n    }\n\n    @Override\n    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)\n            throws RemoteException {\n        try {\n            return super.onTransact(code, data, reply, flags);\n        } catch (RuntimeException e) {\n            throw logAndRethrowRuntimeExceptionOnTransact(TAG, e);\n        }\n    }\n\n    /** Provides the full stack traces of non-security exception that occurs in onTransact. */\n    static RuntimeException logAndRethrowRuntimeExceptionOnTransact(String name,\n            RuntimeException e) {\n        if (!(e instanceof SecurityException)) {\n            Slog.w(TAG, name + \" onTransact aborts\"\n                    + \" UID:\" + Binder.getCallingUid()\n                    + \" PID:\" + Binder.getCallingPid(), e);\n        }\n        throw e;\n    }\n\n    /**\n     * Sets the corresponding {@link DisplayArea} information for the process global\n     * configuration. To be called when we need to show IME on a different {@link DisplayArea}\n     * or display.\n     *\n     * @param pid The process id associated with the IME window.\n     * @param imeContainer The DisplayArea that contains the IME window.\n     */\n    void onImeWindowSetOnDisplayArea(final int pid, @NonNull final DisplayArea imeContainer) {\n        // Don't update process-level configuration for Multi-Client IME process since other\n        // IMEs on other displays will also receive this configuration change due to IME\n        // services use the same application config/context.\n        if (InputMethodSystemProperty.MULTI_CLIENT_IME_ENABLED) return;\n\n        if (pid == MY_PID || pid < 0) {\n            ProtoLog.w(WM_DEBUG_CONFIGURATION,\n                    \"Trying to update display configuration for system/invalid process.\");\n            return;\n        }\n        final WindowProcessController process = mProcessMap.getProcess(pid);\n        if (process == null) {\n            ProtoLog.w(WM_DEBUG_CONFIGURATION, \"Trying to update display \"\n                    + \"configuration for invalid process, pid=%d\", pid);\n            return;\n        }\n        process.registerDisplayAreaConfigurationListener(imeContainer);\n    }\n\n    final class H extends Handler {\n        static final int REPORT_TIME_TRACKER_MSG = 1;\n        static final int UPDATE_PROCESS_ANIMATING_STATE = 2;\n\n        static final int FIRST_ACTIVITY_TASK_MSG = 100;\n        static final int FIRST_SUPERVISOR_TASK_MSG = 200;\n\n        H(Looper looper) {\n            super(looper);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case REPORT_TIME_TRACKER_MSG: {\n                    AppTimeTracker tracker = (AppTimeTracker) msg.obj;\n                    tracker.deliverResult(mContext);\n                }\n                break;\n                case UPDATE_PROCESS_ANIMATING_STATE: {\n                    final WindowProcessController proc = (WindowProcessController) msg.obj;\n                    synchronized (mGlobalLock) {\n                        proc.updateRunningRemoteOrRecentsAnimation();\n                    }\n                }\n                break;\n            }\n        }\n    }\n\n    final class UiHandler extends Handler {\n        static final int DISMISS_DIALOG_UI_MSG = 1;\n\n        public UiHandler() {\n            super(UiThread.get().getLooper(), null, true);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case DISMISS_DIALOG_UI_MSG: {\n                    final Dialog d = (Dialog) msg.obj;\n                    d.dismiss();\n                    break;\n                }\n            }\n        }\n    }\n\n    final class LocalService extends ActivityTaskManagerInternal {\n        @Override\n        public SleepTokenAcquirer createSleepTokenAcquirer(@NonNull String tag) {\n            Objects.requireNonNull(tag);\n            return new SleepTokenAcquirerImpl(tag);\n        }\n\n        @Override\n        public ComponentName getHomeActivityForUser(int userId) {\n            synchronized (mGlobalLock) {\n                final ActivityRecord homeActivity =\n                        mRootWindowContainer.getDefaultDisplayHomeActivityForUser(userId);\n                return homeActivity == null ? null : homeActivity.mActivityComponent;\n            }\n        }\n\n        @Override\n        public void onLocalVoiceInteractionStarted(IBinder activity,\n                IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor) {\n            synchronized (mGlobalLock) {\n                onLocalVoiceInteractionStartedLocked(activity, voiceSession, voiceInteractor);\n            }\n        }\n\n        @Override\n        public List<ActivityAssistInfo> getTopVisibleActivities() {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.getTopVisibleActivities();\n            }\n        }\n\n        @Override\n        public boolean hasResumedActivity(int uid) {\n            return mVisibleActivityProcessTracker.hasResumedActivity(uid);\n        }\n\n        @Override\n        public void setBackgroundActivityStartCallback(\n                @Nullable BackgroundActivityStartCallback backgroundActivityStartCallback) {\n            mBackgroundActivityStartCallback = backgroundActivityStartCallback;\n        }\n\n        @Override\n        public void setAccessibilityServiceUids(IntArray uids) {\n            synchronized (mGlobalLock) {\n                mAccessibilityServiceUids = uids.toArray();\n            }\n        }\n\n        @Override\n        public int startActivitiesAsPackage(String packageName, @Nullable String featureId,\n                int userId, Intent[] intents, Bundle bOptions) {\n            Objects.requireNonNull(intents, \"intents\");\n            final String[] resolvedTypes = new String[intents.length];\n\n            // UID of the package on user userId.\n            // \"= 0\" is needed because otherwise catch(RemoteException) would make it look like\n            // packageUid may not be initialized.\n            int packageUid = 0;\n            final long ident = Binder.clearCallingIdentity();\n\n            try {\n                for (int i = 0; i < intents.length; i++) {\n                    resolvedTypes[i] =\n                            intents[i].resolveTypeIfNeeded(mContext.getContentResolver());\n                }\n\n                packageUid = AppGlobals.getPackageManager().getPackageUid(\n                        packageName, PackageManager.MATCH_DEBUG_TRIAGED_MISSING, userId);\n            } catch (RemoteException e) {\n                // Shouldn't happen.\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n\n            return getActivityStartController().startActivitiesInPackage(\n                    packageUid, packageName, featureId,\n                    intents, resolvedTypes, null /* resultTo */,\n                    SafeActivityOptions.fromBundle(bOptions), userId,\n                    false /* validateIncomingUser */, null /* originatingPendingIntent */,\n                    false /* allowBackgroundActivityStart */);\n        }\n\n        @Override\n        public int startActivitiesInPackage(int uid, int realCallingPid, int realCallingUid,\n                String callingPackage, @Nullable String callingFeatureId, Intent[] intents,\n                String[] resolvedTypes, IBinder resultTo, SafeActivityOptions options, int userId,\n                boolean validateIncomingUser, PendingIntentRecord originatingPendingIntent,\n                boolean allowBackgroundActivityStart) {\n            assertPackageMatchesCallingUid(callingPackage);\n            return getActivityStartController().startActivitiesInPackage(uid, realCallingPid,\n                    realCallingUid, callingPackage, callingFeatureId, intents, resolvedTypes,\n                    resultTo, options, userId, validateIncomingUser, originatingPendingIntent,\n                    allowBackgroundActivityStart);\n        }\n\n        @Override\n        public int startActivityInPackage(int uid, int realCallingPid, int realCallingUid,\n                String callingPackage, @Nullable String callingFeatureId, Intent intent,\n                String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n                int startFlags, SafeActivityOptions options, int userId, Task inTask, String reason,\n                boolean validateIncomingUser, PendingIntentRecord originatingPendingIntent,\n                boolean allowBackgroundActivityStart) {\n            assertPackageMatchesCallingUid(callingPackage);\n            return getActivityStartController().startActivityInPackage(uid, realCallingPid,\n                    realCallingUid, callingPackage, callingFeatureId, intent, resolvedType,\n                    resultTo, resultWho, requestCode, startFlags, options, userId, inTask,\n                    reason, validateIncomingUser, originatingPendingIntent,\n                    allowBackgroundActivityStart);\n        }\n\n        @Override\n        public int startActivityAsUser(IApplicationThread caller, String callerPackage,\n                @Nullable String callerFeatureId, Intent intent, @Nullable IBinder resultTo,\n                int startFlags, Bundle options, int userId) {\n            return ActivityTaskManagerService.this.startActivityAsUser(\n                    caller, callerPackage, callerFeatureId, intent,\n                    intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                    resultTo, null, 0, startFlags, null, options, userId,\n                    false /*validateIncomingUser*/);\n        }\n\n        @Override\n        public void notifyKeyguardFlagsChanged(@Nullable Runnable callback, int displayId) {\n            synchronized (mGlobalLock) {\n\n                // We might change the visibilities here, so prepare an empty app transition which\n                // might be overridden later if we actually change visibilities.\n                final DisplayContent dc = mRootWindowContainer.getDisplayContent(displayId);\n                if (dc == null) {\n                    return;\n                }\n                final boolean wasTransitionSet = dc.mAppTransition.isTransitionSet();\n                if (!wasTransitionSet) {\n                    dc.prepareAppTransition(TRANSIT_NONE);\n                }\n                mRootWindowContainer.ensureActivitiesVisible(null, 0, !PRESERVE_WINDOWS);\n\n                // If there was a transition set already we don't want to interfere with it as we\n                // might be starting it too early.\n                if (!wasTransitionSet) {\n                    dc.executeAppTransition();\n                }\n            }\n            if (callback != null) {\n                callback.run();\n            }\n        }\n\n        @Override\n        public void notifyKeyguardTrustedChanged() {\n            synchronized (mGlobalLock) {\n                if (mKeyguardController.isKeyguardShowing(DEFAULT_DISPLAY)) {\n                    mRootWindowContainer.ensureActivitiesVisible(null, 0, !PRESERVE_WINDOWS);\n                }\n            }\n        }\n\n        /**\n         * Called after virtual display Id is updated by\n         * {@link com.android.server.vr.Vr2dDisplay} with a specific\n         * {@param vrVr2dDisplayId}.\n         */\n        @Override\n        public void setVr2dDisplayId(int vr2dDisplayId) {\n            ProtoLog.d(WM_DEBUG_TASKS, \"setVr2dDisplayId called for: %d\", vr2dDisplayId);\n            synchronized (mGlobalLock) {\n                mVr2dDisplayId = vr2dDisplayId;\n            }\n        }\n\n        @Override\n        public void setFocusedActivity(IBinder token) {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n                if (r == null) {\n                    throw new IllegalArgumentException(\n                            \"setFocusedActivity: No activity record matching token=\" + token);\n                }\n                if (r.moveFocusableActivityToTop(\"setFocusedActivity\")) {\n                    mRootWindowContainer.resumeFocusedTasksTopActivities();\n                }\n            }\n        }\n\n        @Override\n        public void registerScreenObserver(ScreenObserver observer) {\n            mScreenObservers.add(observer);\n        }\n\n        @Override\n        public boolean isCallerRecents(int callingUid) {\n            return getRecentTasks().isCallerRecents(callingUid);\n        }\n\n        @Override\n        public boolean isRecentsComponentHomeActivity(int userId) {\n            return getRecentTasks().isRecentsComponentHomeActivity(userId);\n        }\n\n        @Override\n        public boolean checkCanCloseSystemDialogs(int pid, int uid, @Nullable String packageName) {\n            return ActivityTaskManagerService.this.checkCanCloseSystemDialogs(pid, uid,\n                    packageName);\n        }\n\n        @Override\n        public boolean canCloseSystemDialogs(int pid, int uid) {\n            return ActivityTaskManagerService.this.canCloseSystemDialogs(pid, uid);\n        }\n\n        @Override\n        public void notifyActiveVoiceInteractionServiceChanged(ComponentName component) {\n            synchronized (mGlobalLock) {\n                mActiveVoiceInteractionServiceComponent = component;\n            }\n        }\n\n        @Override\n        public void notifyDreamStateChanged(boolean dreaming) {\n            synchronized (mGlobalLock) {\n                mDreaming = dreaming;\n            }\n        }\n\n        @Override\n        public void setAllowAppSwitches(@NonNull String type, int uid, int userId) {\n            if (!mAmInternal.isUserRunning(userId, ActivityManager.FLAG_OR_STOPPED)) {\n                return;\n            }\n            synchronized (mGlobalLock) {\n                ArrayMap<String, Integer> types = mAllowAppSwitchUids.get(userId);\n                if (types == null) {\n                    if (uid < 0) {\n                        return;\n                    }\n                    types = new ArrayMap<>();\n                    mAllowAppSwitchUids.put(userId, types);\n                }\n                if (uid < 0) {\n                    types.remove(type);\n                } else {\n                    types.put(type, uid);\n                }\n            }\n        }\n\n        @Override\n        public void onUserStopped(int userId) {\n            synchronized (mGlobalLock) {\n                getRecentTasks().unloadUserDataFromMemoryLocked(userId);\n                mAllowAppSwitchUids.remove(userId);\n            }\n        }\n\n        @Override\n        public boolean isGetTasksAllowed(String caller, int callingPid, int callingUid) {\n            synchronized (mGlobalLock) {\n                return ActivityTaskManagerService.this.isGetTasksAllowed(\n                        caller, callingPid, callingUid);\n            }\n        }\n\n        @HotPath(caller = HotPath.PROCESS_CHANGE)\n        @Override\n        public void onProcessAdded(WindowProcessController proc) {\n            synchronized (mGlobalLockWithoutBoost) {\n                mProcessNames.put(proc.mName, proc.mUid, proc);\n            }\n        }\n\n        @HotPath(caller = HotPath.PROCESS_CHANGE)\n        @Override\n        public void onProcessRemoved(String name, int uid) {\n            synchronized (mGlobalLockWithoutBoost) {\n                mProcessNames.remove(name, uid);\n            }\n        }\n\n        @HotPath(caller = HotPath.PROCESS_CHANGE)\n        @Override\n        public void onCleanUpApplicationRecord(WindowProcessController proc) {\n            synchronized (mGlobalLockWithoutBoost) {\n                if (proc == mHomeProcess) {\n                    mHomeProcess = null;\n                }\n                if (proc == mPreviousProcess) {\n                    mPreviousProcess = null;\n                }\n            }\n        }\n\n        @HotPath(caller = HotPath.OOM_ADJUSTMENT)\n        @Override\n        public int getTopProcessState() {\n            return mTopProcessState;\n        }\n\n        @HotPath(caller = HotPath.PROCESS_CHANGE)\n        @Override\n        public void clearHeavyWeightProcessIfEquals(WindowProcessController proc) {\n            synchronized (mGlobalLockWithoutBoost) {\n                ActivityTaskManagerService.this.clearHeavyWeightProcessIfEquals(proc);\n            }\n        }\n\n        @Override\n        public void finishHeavyWeightApp() {\n            synchronized (mGlobalLock) {\n                if (mHeavyWeightProcess != null) {\n                    mHeavyWeightProcess.finishActivities();\n                }\n                ActivityTaskManagerService.this.clearHeavyWeightProcessIfEquals(\n                        mHeavyWeightProcess);\n            }\n        }\n\n        @Override\n        public boolean isDreaming() {\n            synchronized (mGlobalLock) {\n                return mDreaming;\n            }\n        }\n\n        @HotPath(caller = HotPath.OOM_ADJUSTMENT)\n        @Override\n        public boolean isSleeping() {\n            return mSleeping;\n        }\n\n        @Override\n        public boolean isShuttingDown() {\n            synchronized (mGlobalLock) {\n                return mShuttingDown;\n            }\n        }\n\n        @Override\n        public boolean shuttingDown(boolean booted, int timeout) {\n            synchronized (mGlobalLock) {\n                mShuttingDown = true;\n                mRootWindowContainer.prepareForShutdown();\n                updateEventDispatchingLocked(booted);\n                notifyTaskPersisterLocked(null, true);\n                return mTaskSupervisor.shutdownLocked(timeout);\n            }\n        }\n\n        @Override\n        public void enableScreenAfterBoot(boolean booted) {\n            writeBootProgressEnableScreen(SystemClock.uptimeMillis());\n            mWindowManager.enableScreenAfterBoot();\n            synchronized (mGlobalLock) {\n                updateEventDispatchingLocked(booted);\n            }\n        }\n\n        @Override\n        public boolean showStrictModeViolationDialog() {\n            synchronized (mGlobalLock) {\n                return mShowDialogs && !mSleeping && !mShuttingDown;\n            }\n        }\n\n        @Override\n        public void showSystemReadyErrorDialogsIfNeeded() {\n            synchronized (mGlobalLock) {\n                try {\n                    if (AppGlobals.getPackageManager().hasSystemUidErrors()) {\n                        Slog.e(TAG, \"UIDs on the system are inconsistent, you need to wipe your\"\n                                + \" data partition or your device will be unstable.\");\n                        mUiHandler.post(() -> {\n                            if (mShowDialogs) {\n                                AlertDialog d = new BaseErrorDialog(mUiContext);\n                                d.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);\n                                d.setCancelable(false);\n                                d.setTitle(mUiContext.getText(R.string.android_system_label));\n                                d.setMessage(mUiContext.getText(R.string.system_error_wipe_data));\n                                d.setButton(DialogInterface.BUTTON_POSITIVE,\n                                        mUiContext.getText(R.string.ok),\n                                        mUiHandler.obtainMessage(DISMISS_DIALOG_UI_MSG, d));\n                                d.show();\n                            }\n                        });\n                    }\n                } catch (RemoteException e) {\n                }\n\n                if (!Build.isBuildConsistent()) {\n                    Slog.e(TAG, \"Build fingerprint is not consistent, warning user\");\n                    mUiHandler.post(() -> {\n                        if (mShowDialogs) {\n                            AlertDialog d = new BaseErrorDialog(mUiContext);\n                            d.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);\n                            d.setCancelable(false);\n                            d.setTitle(mUiContext.getText(R.string.android_system_label));\n                            d.setMessage(mUiContext.getText(R.string.system_error_manufacturer));\n                            d.setButton(DialogInterface.BUTTON_POSITIVE,\n                                    mUiContext.getText(R.string.ok),\n                                    mUiHandler.obtainMessage(DISMISS_DIALOG_UI_MSG, d));\n                            d.show();\n                        }\n                    });\n                }\n            }\n        }\n\n        @Override\n        public void onProcessMapped(int pid, WindowProcessController proc) {\n            synchronized (mGlobalLock) {\n                mProcessMap.put(pid, proc);\n            }\n        }\n\n        @Override\n        public void onProcessUnMapped(int pid) {\n            synchronized (mGlobalLock) {\n                mProcessMap.remove(pid);\n            }\n        }\n\n        @Override\n        public void onPackageDataCleared(String name) {\n            synchronized (mGlobalLock) {\n                mCompatModePackages.handlePackageDataClearedLocked(name);\n                mAppWarnings.onPackageDataCleared(name);\n            }\n        }\n\n        @Override\n        public void onPackageUninstalled(String name) {\n            synchronized (mGlobalLock) {\n                mAppWarnings.onPackageUninstalled(name);\n                mCompatModePackages.handlePackageUninstalledLocked(name);\n                mPackageConfigPersister.onPackageUninstall(name);\n            }\n        }\n\n        @Override\n        public void onPackageAdded(String name, boolean replacing) {\n            synchronized (mGlobalLock) {\n                mCompatModePackages.handlePackageAddedLocked(name, replacing);\n            }\n        }\n\n        @Override\n        public void onPackageReplaced(ApplicationInfo aInfo) {\n            synchronized (mGlobalLock) {\n                mRootWindowContainer.updateActivityApplicationInfo(aInfo);\n            }\n        }\n\n        @Override\n        public CompatibilityInfo compatibilityInfoForPackage(ApplicationInfo ai) {\n            synchronized (mGlobalLock) {\n                return compatibilityInfoForPackageLocked(ai);\n            }\n        }\n\n        @Override\n        public void sendActivityResult(int callingUid, IBinder activityToken, String resultWho,\n                int requestCode, int resultCode, Intent data) {\n            final ActivityRecord r;\n            synchronized (mGlobalLock) {\n                r = ActivityRecord.isInRootTaskLocked(activityToken);\n                if (r == null || r.getRootTask() == null) {\n                    return;\n                }\n            }\n\n            // Carefully collect grants without holding lock\n            final NeededUriGrants dataGrants = collectGrants(data, r);\n\n            synchronized (mGlobalLock) {\n                r.sendResult(callingUid, resultWho, requestCode, resultCode, data, dataGrants);\n            }\n        }\n\n        @Override\n        public void clearPendingResultForActivity(IBinder activityToken,\n                WeakReference<PendingIntentRecord> pir) {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(activityToken);\n                if (r != null && r.pendingResults != null) {\n                    r.pendingResults.remove(pir);\n                }\n            }\n        }\n\n        @Override\n        public ComponentName getActivityName(IBinder activityToken) {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(activityToken);\n                return r != null ? r.intent.getComponent() : null;\n            }\n        }\n\n        @Override\n        public ActivityTokens getTopActivityForTask(int taskId) {\n            synchronized (mGlobalLock) {\n                final Task task = mRootWindowContainer.anyTaskForId(taskId,\n                        MATCH_ATTACHED_TASK_ONLY);\n                if (task == null) {\n                    Slog.w(TAG, \"getApplicationThreadForTopActivity failed:\"\n                            + \" Requested task not found\");\n                    return null;\n                }\n                final ActivityRecord activity = task.getTopNonFinishingActivity();\n                if (activity == null) {\n                    Slog.w(TAG, \"getApplicationThreadForTopActivity failed:\"\n                            + \" Requested activity not found\");\n                    return null;\n                }\n                if (!activity.attachedToProcess()) {\n                    Slog.w(TAG, \"getApplicationThreadForTopActivity failed: No process for \"\n                            + activity);\n                    return null;\n                }\n                return new ActivityTokens(activity.appToken, activity.assistToken,\n                        activity.app.getThread(), activity.shareableActivityToken);\n            }\n        }\n\n        @Override\n        public IIntentSender getIntentSender(int type, String packageName,\n                @Nullable String featureId, int callingUid, int userId, IBinder token,\n                String resultWho, int requestCode, Intent[] intents, String[] resolvedTypes,\n                int flags, Bundle bOptions) {\n            synchronized (mGlobalLock) {\n                return getIntentSenderLocked(type, packageName, featureId, callingUid, userId,\n                        token, resultWho, requestCode, intents, resolvedTypes, flags, bOptions);\n            }\n        }\n\n        @Override\n        public ActivityServiceConnectionsHolder getServiceConnectionsHolder(IBinder token) {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r == null) {\n                    return null;\n                }\n                if (r.mServiceConnectionsHolder == null) {\n                    r.mServiceConnectionsHolder = new ActivityServiceConnectionsHolder(\n                            ActivityTaskManagerService.this, r);\n                }\n\n                return r.mServiceConnectionsHolder;\n            }\n        }\n\n        @Override\n        public Intent getHomeIntent() {\n            synchronized (mGlobalLock) {\n                return ActivityTaskManagerService.this.getHomeIntent();\n            }\n        }\n\n        @Override\n        public boolean startHomeActivity(int userId, String reason) {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.startHomeOnDisplay(userId, reason, DEFAULT_DISPLAY);\n            }\n        }\n\n        @Override\n        public boolean startHomeOnDisplay(int userId, String reason, int displayId,\n                boolean allowInstrumenting, boolean fromHomeKey) {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.startHomeOnDisplay(userId, reason, displayId,\n                        allowInstrumenting, fromHomeKey);\n            }\n        }\n\n        @Override\n        public boolean startHomeOnAllDisplays(int userId, String reason) {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.startHomeOnAllDisplays(userId, reason);\n            }\n        }\n\n        @HotPath(caller = HotPath.PROCESS_CHANGE)\n        @Override\n        public boolean isFactoryTestProcess(WindowProcessController wpc) {\n            synchronized (mGlobalLockWithoutBoost) {\n                if (mFactoryTest == FACTORY_TEST_OFF) {\n                    return false;\n                }\n                if (mFactoryTest == FACTORY_TEST_LOW_LEVEL && mTopComponent != null\n                        && wpc.mName.equals(mTopComponent.getPackageName())) {\n                    return true;\n                }\n                return mFactoryTest == FACTORY_TEST_HIGH_LEVEL\n                        && (wpc.mInfo.flags & FLAG_FACTORY_TEST) != 0;\n            }\n        }\n\n        @Override\n        public void updateTopComponentForFactoryTest() {\n            synchronized (mGlobalLock) {\n                if (mFactoryTest != FACTORY_TEST_LOW_LEVEL) {\n                    return;\n                }\n                final ResolveInfo ri = mContext.getPackageManager()\n                        .resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST), STOCK_PM_FLAGS);\n                final CharSequence errorMsg;\n                if (ri != null) {\n                    final ActivityInfo ai = ri.activityInfo;\n                    final ApplicationInfo app = ai.applicationInfo;\n                    if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {\n                        mTopAction = Intent.ACTION_FACTORY_TEST;\n                        mTopData = null;\n                        mTopComponent = new ComponentName(app.packageName, ai.name);\n                        errorMsg = null;\n                    } else {\n                        errorMsg = mContext.getResources().getText(\n                                com.android.internal.R.string.factorytest_not_system);\n                    }\n                } else {\n                    errorMsg = mContext.getResources().getText(\n                            com.android.internal.R.string.factorytest_no_action);\n                }\n                if (errorMsg == null) {\n                    return;\n                }\n\n                mTopAction = null;\n                mTopData = null;\n                mTopComponent = null;\n                mUiHandler.post(() -> {\n                    Dialog d = new FactoryErrorDialog(mUiContext, errorMsg);\n                    d.show();\n                    mAmInternal.ensureBootCompleted();\n                });\n            }\n        }\n\n        @HotPath(caller = HotPath.PROCESS_CHANGE)\n        @Override\n        public void handleAppDied(WindowProcessController wpc, boolean restarting,\n                Runnable finishInstrumentationCallback) {\n            synchronized (mGlobalLockWithoutBoost) {\n                mTaskSupervisor.beginDeferResume();\n                final boolean hasVisibleActivities;\n                try {\n                    // Remove this application's activities from active lists.\n                    hasVisibleActivities = wpc.handleAppDied();\n                } finally {\n                    mTaskSupervisor.endDeferResume();\n                }\n\n                if (!restarting && hasVisibleActivities) {\n                    deferWindowLayout();\n                    try {\n                        if (!mRootWindowContainer.resumeFocusedTasksTopActivities()) {\n                            // If there was nothing to resume, and we are not already restarting\n                            // this process, but there is a visible activity that is hosted by the\n                            // process...then make sure all visible activities are running, taking\n                            // care of restarting this process.\n                            mRootWindowContainer.ensureActivitiesVisible(null, 0,\n                                    !PRESERVE_WINDOWS);\n                        }\n                    } finally {\n                        continueWindowLayout();\n                    }\n                }\n            }\n            if (wpc.isInstrumenting()) {\n                finishInstrumentationCallback.run();\n            }\n        }\n\n        @Override\n        public void closeSystemDialogs(String reason) {\n            enforceNotIsolatedCaller(\"closeSystemDialogs\");\n            final int pid = Binder.getCallingPid();\n            final int uid = Binder.getCallingUid();\n            if (!checkCanCloseSystemDialogs(pid, uid, null)) {\n                return;\n            }\n\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                synchronized (mGlobalLock) {\n                    // Only allow this from foreground processes, so that background\n                    // applications can't abuse it to prevent system UI from being shown.\n                    if (uid >= FIRST_APPLICATION_UID) {\n                        final WindowProcessController proc = mProcessMap.getProcess(pid);\n                        if (!proc.isPerceptible()) {\n                            Slog.w(TAG, \"Ignoring closeSystemDialogs \" + reason\n                                    + \" from background process \" + proc);\n                            return;\n                        }\n                    }\n                    mWindowManager.closeSystemDialogs(reason);\n\n                    mRootWindowContainer.closeSystemDialogActivities(reason);\n                }\n                // Call into AM outside the synchronized block.\n                mAmInternal.broadcastCloseSystemDialogs(reason);\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n\n        @Override\n        public void cleanupDisabledPackageComponents(\n                String packageName, Set<String> disabledClasses, int userId, boolean booted) {\n            synchronized (mGlobalLock) {\n                // Clean-up disabled activities.\n                if (mRootWindowContainer.finishDisabledPackageActivities(\n                        packageName, disabledClasses, true /* doit */, false /* evenPersistent */,\n                        userId, false /* onlyRemoveNoProcess */) && booted) {\n                    mRootWindowContainer.resumeFocusedTasksTopActivities();\n                    mTaskSupervisor.scheduleIdle();\n                }\n\n                // Clean-up disabled tasks\n                getRecentTasks().cleanupDisabledPackageTasksLocked(\n                        packageName, disabledClasses, userId);\n            }\n        }\n\n        @Override\n        public boolean onForceStopPackage(String packageName, boolean doit, boolean evenPersistent,\n                int userId) {\n            synchronized (mGlobalLock) {\n\n                return mRootWindowContainer.finishDisabledPackageActivities(packageName,\n                        null /* filterByClasses */, doit, evenPersistent, userId,\n                        // Only remove the activities without process because the activities with\n                        // attached process will be removed when handling process died with\n                        // WindowProcessController#isRemoved == true.\n                        true /* onlyRemoveNoProcess */);\n            }\n        }\n\n        @Override\n        public void resumeTopActivities(boolean scheduleIdle) {\n            synchronized (mGlobalLock) {\n                mRootWindowContainer.resumeFocusedTasksTopActivities();\n                if (scheduleIdle) {\n                    mTaskSupervisor.scheduleIdle();\n                }\n            }\n        }\n\n        @HotPath(caller = HotPath.PROCESS_CHANGE)\n        @Override\n        public void preBindApplication(WindowProcessController wpc) {\n            synchronized (mGlobalLockWithoutBoost) {\n                mTaskSupervisor.getActivityMetricsLogger().notifyBindApplication(wpc.mInfo);\n            }\n        }\n\n        @HotPath(caller = HotPath.PROCESS_CHANGE)\n        @Override\n        public boolean attachApplication(WindowProcessController wpc) throws RemoteException {\n            synchronized (mGlobalLockWithoutBoost) {\n                if (Trace.isTagEnabled(TRACE_TAG_WINDOW_MANAGER)) {\n                    Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, \"attachApplication:\" + wpc.mName);\n                }\n                try {\n                    return mRootWindowContainer.attachApplication(wpc);\n                } finally {\n                    Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);\n                }\n            }\n        }\n\n        @Override\n        public void notifyLockedProfile(@UserIdInt int userId, int currentUserId) {\n            try {\n                if (!AppGlobals.getPackageManager().isUidPrivileged(Binder.getCallingUid())) {\n                    throw new SecurityException(\"Only privileged app can call notifyLockedProfile\");\n                }\n            } catch (RemoteException ex) {\n                throw new SecurityException(\"Fail to check is caller a privileged app\", ex);\n            }\n\n            synchronized (mGlobalLock) {\n                final long ident = Binder.clearCallingIdentity();\n                try {\n                    if (mAmInternal.shouldConfirmCredentials(userId)) {\n                        if (mKeyguardController.isKeyguardLocked()) {\n                            // Showing launcher to avoid user entering credential twice.\n                            startHomeActivity(currentUserId, \"notifyLockedProfile\");\n                        }\n                        mRootWindowContainer.lockAllProfileTasks(userId);\n                    }\n                } finally {\n                    Binder.restoreCallingIdentity(ident);\n                }\n            }\n        }\n\n        @Override\n        public void startConfirmDeviceCredentialIntent(Intent intent, Bundle options) {\n            enforceTaskPermission(\"startConfirmDeviceCredentialIntent\");\n\n            synchronized (mGlobalLock) {\n                final long ident = Binder.clearCallingIdentity();\n                try {\n                    intent.addFlags(FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);\n                    final ActivityOptions activityOptions = options != null\n                            ? new ActivityOptions(options) : ActivityOptions.makeBasic();\n                    mContext.startActivityAsUser(intent, activityOptions.toBundle(),\n                            UserHandle.CURRENT);\n                } finally {\n                    Binder.restoreCallingIdentity(ident);\n                }\n            }\n        }\n\n        @Override\n        public void writeActivitiesToProto(ProtoOutputStream proto) {\n            synchronized (mGlobalLock) {\n                // The output proto of \"activity --proto activities\"\n                mRootWindowContainer.dumpDebug(\n                        proto, ROOT_WINDOW_CONTAINER, WindowTraceLogLevel.ALL);\n            }\n        }\n\n        @Override\n        public void saveANRState(String reason) {\n            synchronized (mGlobalLock) {\n                final StringWriter sw = new StringWriter();\n                final PrintWriter pw = new FastPrintWriter(sw, false, 1024);\n                pw.println(\"  ANR time: \" + DateFormat.getDateTimeInstance().format(new Date()));\n                if (reason != null) {\n                    pw.println(\"  Reason: \" + reason);\n                }\n                pw.println();\n                getActivityStartController().dump(pw, \"  \", null);\n                pw.println();\n                pw.println(\"-------------------------------------------------------------------\"\n                        + \"------------\");\n                dumpActivitiesLocked(null /* fd */, pw, null /* args */, 0 /* opti */,\n                        true /* dumpAll */, false /* dumpClient */, null /* dumpPackage */,\n                        \"\" /* header */);\n                pw.println();\n                pw.close();\n\n                mLastANRState = sw.toString();\n            }\n        }\n\n        @Override\n        public void clearSavedANRState() {\n            synchronized (mGlobalLock) {\n                mLastANRState = null;\n            }\n        }\n\n        @Override\n        public void dump(String cmd, FileDescriptor fd, PrintWriter pw, String[] args, int opti,\n                boolean dumpAll, boolean dumpClient, String dumpPackage) {\n            synchronized (mGlobalLock) {\n                if (DUMP_ACTIVITIES_CMD.equals(cmd) || DUMP_ACTIVITIES_SHORT_CMD.equals(cmd)) {\n                    dumpActivitiesLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage);\n                } else if (DUMP_LASTANR_CMD.equals(cmd)) {\n                    dumpLastANRLocked(pw);\n                } else if (DUMP_LASTANR_TRACES_CMD.equals(cmd)) {\n                    dumpLastANRTracesLocked(pw);\n                } else if (DUMP_STARTER_CMD.equals(cmd)) {\n                    dumpActivityStarterLocked(pw, dumpPackage);\n                } else if (DUMP_CONTAINERS_CMD.equals(cmd)) {\n                    dumpActivityContainersLocked(pw);\n                } else if (DUMP_RECENTS_CMD.equals(cmd) || DUMP_RECENTS_SHORT_CMD.equals(cmd)) {\n                    if (getRecentTasks() != null) {\n                        getRecentTasks().dump(pw, dumpAll, dumpPackage);\n                    }\n                } else if (DUMP_TOP_RESUMED_ACTIVITY.equals(cmd)) {\n                    dumpTopResumedActivityLocked(pw);\n                }\n            }\n        }\n\n        @Override\n        public boolean dumpForProcesses(FileDescriptor fd, PrintWriter pw, boolean dumpAll,\n                String dumpPackage, int dumpAppId, boolean needSep, boolean testPssMode,\n                int wakefulness) {\n            synchronized (mGlobalLock) {\n                if (mHomeProcess != null && (dumpPackage == null\n                        || mHomeProcess.mPkgList.contains(dumpPackage))) {\n                    if (needSep) {\n                        pw.println();\n                        needSep = false;\n                    }\n                    pw.println(\"  mHomeProcess: \" + mHomeProcess);\n                }\n                if (mPreviousProcess != null && (dumpPackage == null\n                        || mPreviousProcess.mPkgList.contains(dumpPackage))) {\n                    if (needSep) {\n                        pw.println();\n                        needSep = false;\n                    }\n                    pw.println(\"  mPreviousProcess: \" + mPreviousProcess);\n                }\n                if (dumpAll && (mPreviousProcess == null || dumpPackage == null\n                        || mPreviousProcess.mPkgList.contains(dumpPackage))) {\n                    StringBuilder sb = new StringBuilder(128);\n                    sb.append(\"  mPreviousProcessVisibleTime: \");\n                    TimeUtils.formatDuration(mPreviousProcessVisibleTime, sb);\n                    pw.println(sb);\n                }\n                if (mHeavyWeightProcess != null && (dumpPackage == null\n                        || mHeavyWeightProcess.mPkgList.contains(dumpPackage))) {\n                    if (needSep) {\n                        pw.println();\n                        needSep = false;\n                    }\n                    pw.println(\"  mHeavyWeightProcess: \" + mHeavyWeightProcess);\n                }\n                if (dumpPackage == null) {\n                    pw.println(\"  mGlobalConfiguration: \" + getGlobalConfiguration());\n                    mRootWindowContainer.dumpDisplayConfigs(pw, \"  \");\n                }\n                if (dumpAll) {\n                    final Task topFocusedRootTask = getTopDisplayFocusedRootTask();\n                    if (dumpPackage == null && topFocusedRootTask != null) {\n                        pw.println(\"  mConfigWillChange: \" + topFocusedRootTask.mConfigWillChange);\n                    }\n                    if (mCompatModePackages.getPackages().size() > 0) {\n                        boolean printed = false;\n                        for (Map.Entry<String, Integer> entry\n                                : mCompatModePackages.getPackages().entrySet()) {\n                            String pkg = entry.getKey();\n                            int mode = entry.getValue();\n                            if (dumpPackage != null && !dumpPackage.equals(pkg)) {\n                                continue;\n                            }\n                            if (!printed) {\n                                pw.println(\"  mScreenCompatPackages:\");\n                                printed = true;\n                            }\n                            pw.println(\"    \" + pkg + \": \" + mode);\n                        }\n                    }\n                }\n\n                if (dumpPackage == null) {\n                    pw.println(\"  mWakefulness=\"\n                            + PowerManagerInternal.wakefulnessToString(wakefulness));\n                    pw.println(\"  mSleepTokens=\" + mRootWindowContainer.mSleepTokens);\n                    if (mRunningVoice != null) {\n                        pw.println(\"  mRunningVoice=\" + mRunningVoice);\n                        pw.println(\"  mVoiceWakeLock\" + mVoiceWakeLock);\n                    }\n                    pw.println(\"  mSleeping=\" + mSleeping);\n                    pw.println(\"  mShuttingDown=\" + mShuttingDown + \" mTestPssMode=\" + testPssMode);\n                    pw.println(\"  mVrController=\" + mVrController);\n                }\n                if (mCurAppTimeTracker != null) {\n                    mCurAppTimeTracker.dumpWithHeader(pw, \"  \", true);\n                }\n                if (mAllowAppSwitchUids.size() > 0) {\n                    boolean printed = false;\n                    for (int i = 0; i < mAllowAppSwitchUids.size(); i++) {\n                        ArrayMap<String, Integer> types = mAllowAppSwitchUids.valueAt(i);\n                        for (int j = 0; j < types.size(); j++) {\n                            if (dumpPackage == null ||\n                                    UserHandle.getAppId(types.valueAt(j).intValue()) == dumpAppId) {\n                                if (needSep) {\n                                    pw.println();\n                                    needSep = false;\n                                }\n                                if (!printed) {\n                                    pw.println(\"  mAllowAppSwitchUids:\");\n                                    printed = true;\n                                }\n                                pw.print(\"    User \");\n                                pw.print(mAllowAppSwitchUids.keyAt(i));\n                                pw.print(\": Type \");\n                                pw.print(types.keyAt(j));\n                                pw.print(\" = \");\n                                UserHandle.formatUid(pw, types.valueAt(j).intValue());\n                                pw.println();\n                            }\n                        }\n                    }\n                }\n                if (dumpPackage == null) {\n                    if (mController != null) {\n                        pw.println(\"  mController=\" + mController\n                                + \" mControllerIsAMonkey=\" + mControllerIsAMonkey);\n                    }\n                    pw.println(\"  mGoingToSleepWakeLock=\" + mTaskSupervisor.mGoingToSleepWakeLock);\n                    pw.println(\"  mLaunchingActivityWakeLock=\"\n                            + mTaskSupervisor.mLaunchingActivityWakeLock);\n                }\n\n                return needSep;\n            }\n        }\n\n        @Override\n        public void writeProcessesToProto(ProtoOutputStream proto, String dumpPackage,\n                int wakeFullness, boolean testPssMode) {\n            synchronized (mGlobalLock) {\n                if (dumpPackage == null) {\n                    getGlobalConfiguration().dumpDebug(proto, GLOBAL_CONFIGURATION);\n                    final Task topFocusedRootTask = getTopDisplayFocusedRootTask();\n                    if (topFocusedRootTask != null) {\n                        proto.write(CONFIG_WILL_CHANGE, topFocusedRootTask.mConfigWillChange);\n                    }\n                    writeSleepStateToProto(proto, wakeFullness, testPssMode);\n                    if (mRunningVoice != null) {\n                        final long vrToken = proto.start(\n                                ActivityManagerServiceDumpProcessesProto.RUNNING_VOICE);\n                        proto.write(ActivityManagerServiceDumpProcessesProto.Voice.SESSION,\n                                mRunningVoice.toString());\n                        mVoiceWakeLock.dumpDebug(\n                                proto, ActivityManagerServiceDumpProcessesProto.Voice.WAKELOCK);\n                        proto.end(vrToken);\n                    }\n                    mVrController.dumpDebug(proto,\n                            ActivityManagerServiceDumpProcessesProto.VR_CONTROLLER);\n                    if (mController != null) {\n                        final long token = proto.start(CONTROLLER);\n                        proto.write(ActivityManagerServiceDumpProcessesProto.Controller.CONTROLLER,\n                                mController.toString());\n                        proto.write(IS_A_MONKEY, mControllerIsAMonkey);\n                        proto.end(token);\n                    }\n                    mTaskSupervisor.mGoingToSleepWakeLock.dumpDebug(proto, GOING_TO_SLEEP);\n                    mTaskSupervisor.mLaunchingActivityWakeLock.dumpDebug(proto,\n                            LAUNCHING_ACTIVITY);\n                }\n\n                if (mHomeProcess != null && (dumpPackage == null\n                        || mHomeProcess.mPkgList.contains(dumpPackage))) {\n                    mHomeProcess.dumpDebug(proto, HOME_PROC);\n                }\n\n                if (mPreviousProcess != null && (dumpPackage == null\n                        || mPreviousProcess.mPkgList.contains(dumpPackage))) {\n                    mPreviousProcess.dumpDebug(proto, PREVIOUS_PROC);\n                    proto.write(PREVIOUS_PROC_VISIBLE_TIME_MS, mPreviousProcessVisibleTime);\n                }\n\n                if (mHeavyWeightProcess != null && (dumpPackage == null\n                        || mHeavyWeightProcess.mPkgList.contains(dumpPackage))) {\n                    mHeavyWeightProcess.dumpDebug(proto, HEAVY_WEIGHT_PROC);\n                }\n\n                for (Map.Entry<String, Integer> entry\n                        : mCompatModePackages.getPackages().entrySet()) {\n                    String pkg = entry.getKey();\n                    int mode = entry.getValue();\n                    if (dumpPackage == null || dumpPackage.equals(pkg)) {\n                        long compatToken = proto.start(SCREEN_COMPAT_PACKAGES);\n                        proto.write(PACKAGE, pkg);\n                        proto.write(MODE, mode);\n                        proto.end(compatToken);\n                    }\n                }\n\n                if (mCurAppTimeTracker != null) {\n                    mCurAppTimeTracker.dumpDebug(proto, CURRENT_TRACKER, true);\n                }\n\n            }\n        }\n\n        @Override\n        public boolean dumpActivity(FileDescriptor fd, PrintWriter pw, String name,\n                String[] args, int opti, boolean dumpAll, boolean dumpVisibleRootTasksOnly,\n                boolean dumpFocusedRootTaskOnly) {\n            return ActivityTaskManagerService.this.dumpActivity(fd, pw, name, args, opti, dumpAll,\n                    dumpVisibleRootTasksOnly, dumpFocusedRootTaskOnly);\n        }\n\n        @Override\n        public void dumpForOom(PrintWriter pw) {\n            synchronized (mGlobalLock) {\n                pw.println(\"  mHomeProcess: \" + mHomeProcess);\n                pw.println(\"  mPreviousProcess: \" + mPreviousProcess);\n                if (mHeavyWeightProcess != null) {\n                    pw.println(\"  mHeavyWeightProcess: \" + mHeavyWeightProcess);\n                }\n            }\n        }\n\n        @Override\n        public boolean canGcNow() {\n            synchronized (mGlobalLock) {\n                return isSleeping() || mRootWindowContainer.allResumedActivitiesIdle();\n            }\n        }\n\n        @HotPath(caller = HotPath.OOM_ADJUSTMENT)\n        @Override\n        public WindowProcessController getTopApp() {\n            return mTopApp;\n        }\n\n        @Override\n        public void scheduleDestroyAllActivities(String reason) {\n            synchronized (mGlobalLock) {\n                mRootWindowContainer.scheduleDestroyAllActivities(reason);\n            }\n        }\n\n        @Override\n        public void removeUser(int userId) {\n            synchronized (mGlobalLock) {\n                mRootWindowContainer.removeUser(userId);\n                mPackageConfigPersister.removeUser(userId);\n            }\n        }\n\n        @Override\n        public boolean switchUser(int userId, UserState userState) {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.switchUser(userId, userState);\n            }\n        }\n\n        @Override\n        public void onHandleAppCrash(WindowProcessController wpc) {\n            synchronized (mGlobalLock) {\n                mRootWindowContainer.handleAppCrash(wpc);\n            }\n        }\n\n        @Override\n        public int finishTopCrashedActivities(WindowProcessController crashedApp, String reason) {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.finishTopCrashedActivities(crashedApp, reason);\n            }\n        }\n\n        @HotPath(caller = HotPath.OOM_ADJUSTMENT)\n        @Override\n        public void onUidActive(int uid, int procState) {\n            mActiveUids.onUidActive(uid, procState);\n        }\n\n        @HotPath(caller = HotPath.OOM_ADJUSTMENT)\n        @Override\n        public void onUidInactive(int uid) {\n            mActiveUids.onUidInactive(uid);\n        }\n\n        @HotPath(caller = HotPath.OOM_ADJUSTMENT)\n        @Override\n        public void onUidProcStateChanged(int uid, int procState) {\n            mActiveUids.onUidProcStateChanged(uid, procState);\n        }\n\n        @Override\n        public void onUidAddedToPendingTempAllowlist(int uid, String tag) {\n            synchronized (mGlobalLockWithoutBoost) {\n                mPendingTempAllowlist.put(uid, tag);\n            }\n        }\n\n        @Override\n        public void onUidRemovedFromPendingTempAllowlist(int uid) {\n            synchronized (mGlobalLockWithoutBoost) {\n                mPendingTempAllowlist.remove(uid);\n            }\n        }\n\n        @Override\n        public boolean handleAppCrashInActivityController(String processName, int pid,\n                String shortMsg, String longMsg, long timeMillis, String stackTrace,\n                Runnable killCrashingAppCallback) {\n            Runnable targetRunnable = null;\n            synchronized (mGlobalLock) {\n                if (mController == null) {\n                    return false;\n                }\n\n                try {\n                    if (!mController.appCrashed(processName, pid, shortMsg, longMsg, timeMillis,\n                            stackTrace)) {\n                        targetRunnable = killCrashingAppCallback;\n                    }\n                } catch (RemoteException e) {\n                    mController = null;\n                    Watchdog.getInstance().setActivityController(null);\n                }\n            }\n            if (targetRunnable != null) {\n                targetRunnable.run();\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public void removeRecentTasksByPackageName(String packageName, int userId) {\n            synchronized (mGlobalLock) {\n                mRecentTasks.removeTasksByPackageName(packageName, userId);\n            }\n        }\n\n        @Override\n        public void cleanupRecentTasksForUser(int userId) {\n            synchronized (mGlobalLock) {\n                mRecentTasks.cleanupLocked(userId);\n            }\n        }\n\n        @Override\n        public void loadRecentTasksForUser(int userId) {\n            synchronized (mGlobalLock) {\n                mRecentTasks.loadUserRecentsLocked(userId);\n                // TODO renaming the methods(?)\n                mPackageConfigPersister.loadUserPackages(userId);\n            }\n        }\n\n        @Override\n        public void onPackagesSuspendedChanged(String[] packages, boolean suspended, int userId) {\n            synchronized (mGlobalLock) {\n                mRecentTasks.onPackagesSuspendedChanged(packages, suspended, userId);\n            }\n        }\n\n        @Override\n        public void flushRecentTasks() {\n            mRecentTasks.flush();\n        }\n\n        @Override\n        public void clearLockedTasks(String reason) {\n            synchronized (mGlobalLock) {\n                getLockTaskController().clearLockedTasks(reason);\n            }\n        }\n\n        @Override\n        public void updateUserConfiguration() {\n            synchronized (mGlobalLock) {\n                final Configuration configuration = new Configuration(getGlobalConfiguration());\n                final int currentUserId = mAmInternal.getCurrentUserId();\n                Settings.System.adjustConfigurationForUser(mContext.getContentResolver(),\n                        configuration, currentUserId, Settings.System.canWrite(mContext));\n                updateConfigurationLocked(configuration, null /* starting */,\n                        false /* initLocale */, false /* persistent */, currentUserId,\n                        false /* deferResume */);\n            }\n        }\n\n        @Override\n        public boolean canShowErrorDialogs() {\n            synchronized (mGlobalLock) {\n                return mShowDialogs && !mSleeping && !mShuttingDown\n                        && !mKeyguardController.isKeyguardOrAodShowing(DEFAULT_DISPLAY)\n                        && !hasUserRestriction(UserManager.DISALLOW_SYSTEM_ERROR_DIALOGS,\n                        mAmInternal.getCurrentUserId())\n                        && !(UserManager.isDeviceInDemoMode(mContext)\n                        && mAmInternal.getCurrentUser().isDemo());\n            }\n        }\n\n        @Override\n        public void setProfileApp(String profileApp) {\n            synchronized (mGlobalLock) {\n                mProfileApp = profileApp;\n            }\n        }\n\n        @Override\n        public void setProfileProc(WindowProcessController wpc) {\n            synchronized (mGlobalLock) {\n                mProfileProc = wpc;\n            }\n        }\n\n        @Override\n        public void setProfilerInfo(ProfilerInfo profilerInfo) {\n            synchronized (mGlobalLock) {\n                mProfilerInfo = profilerInfo;\n            }\n        }\n\n        @Override\n        public ActivityMetricsLaunchObserverRegistry getLaunchObserverRegistry() {\n            synchronized (mGlobalLock) {\n                return mTaskSupervisor.getActivityMetricsLogger().getLaunchObserverRegistry();\n            }\n        }\n\n        @Nullable\n        @Override\n        public IBinder getUriPermissionOwnerForActivity(@NonNull IBinder activityToken) {\n            ActivityTaskManagerService.enforceNotIsolatedCaller(\"getUriPermissionOwnerForActivity\");\n            synchronized (mGlobalLock) {\n                ActivityRecord r = ActivityRecord.isInRootTaskLocked(activityToken);\n                return (r == null) ? null : r.getUriPermissionsLocked().getExternalToken();\n            }\n        }\n\n        @Override\n        public TaskSnapshot getTaskSnapshotBlocking(\n                int taskId, boolean isLowResolution) {\n            return ActivityTaskManagerService.this.getTaskSnapshot(taskId, isLowResolution,\n                    true /* restoreFromDisk */);\n        }\n\n        @Override\n        public boolean isUidForeground(int uid) {\n            return ActivityTaskManagerService.this.hasActiveVisibleWindow(uid);\n        }\n\n        @Override\n        public void setDeviceOwnerUid(int uid) {\n            synchronized (mGlobalLock) {\n                ActivityTaskManagerService.this.setDeviceOwnerUid(uid);\n            }\n        }\n\n        @Override\n        public void setCompanionAppUids(int userId, Set<Integer> companionAppUids) {\n            synchronized (mGlobalLock) {\n                mCompanionAppUidsMap.put(userId, companionAppUids);\n            }\n        }\n\n\n        @Override\n        public boolean isBaseOfLockedTask(String packageName) {\n            synchronized (mGlobalLock) {\n                return getLockTaskController().isBaseOfLockedTask(packageName);\n            }\n        }\n\n        @Override\n        public PackageConfigurationUpdater createPackageConfigurationUpdater() {\n            return new PackageConfigurationUpdaterImpl(Binder.getCallingPid());\n        }\n\n        @Override\n        public boolean hasSystemAlertWindowPermission(int callingUid, int callingPid,\n                String callingPackage) {\n            return ActivityTaskManagerService.this.hasSystemAlertWindowPermission(callingUid,\n                    callingPid, callingPackage);\n        }\n    }\n\n    final class PackageConfigurationUpdaterImpl implements\n            ActivityTaskManagerInternal.PackageConfigurationUpdater {\n        private final int mPid;\n        private int mNightMode;\n\n        PackageConfigurationUpdaterImpl(int pid) {\n            mPid = pid;\n        }\n\n        @Override\n        public ActivityTaskManagerInternal.PackageConfigurationUpdater setNightMode(int nightMode) {\n            mNightMode = nightMode;\n            return this;\n        }\n\n        @Override\n        public void commit() {\n            synchronized (mGlobalLock) {\n                final long ident = Binder.clearCallingIdentity();\n                try {\n                    final WindowProcessController wpc = mProcessMap.getProcess(mPid);\n                    if (wpc == null) {\n                        Slog.w(TAG, \"Override application configuration: cannot find pid \" + mPid);\n                        return;\n                    }\n                    wpc.setOverrideNightMode(mNightMode);\n                    wpc.updateNightModeForAllActivities(mNightMode);\n                    mPackageConfigPersister.updateFromImpl(wpc.mName, wpc.mUserId, this);\n                } finally {\n                    Binder.restoreCallingIdentity(ident);\n                }\n            }\n        }\n\n        int getNightMode() {\n            return mNightMode;\n        }\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 53145,
                                        "general": {
                                            "word_based": 20567,
                                            "char_based": 69066
                                        },
                                        "gemini": 62147
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "d54a64bdf71d1c91542b6885149fd176622ad0b4",
                            "repo_path": "android_repos/base",
                            "result": "failure",
                            "downstream_patch_content": "commit d54a64bdf71d1c91542b6885149fd176622ad0b4\nAuthor: Christophe Pinelli <cpinelli@google.com>\nDate:   Fri May 12 21:44:08 2023 +0000\n\n    Restrict activity launch when caller is running in the background\n    \n    Test: test on device + atest-src BackgroundActivityLaunchTest#testBackgroundActivityBlockedInStartNextMatchingActivity\n    Bug: 230492947\n    Merged-In: Ie774b142a7fab12d596ccd64872b781e3825e9ba\n    Change-Id: I1a0c13e74622d301866efaca1b5351a6b241ebe5\n\ndiff --git a/services/core/java/com/android/server/wm/ActivityTaskManagerService.java b/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\nindex 987cff95bba3..c1006914c6a3 100644\n--- a/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\n+++ b/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\n@@ -1324,29 +1324,38 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n \n             final long origId = Binder.clearCallingIdentity();\n             // TODO(b/64750076): Check if calling pid should really be -1.\n-            final int res = getActivityStartController()\n-                    .obtainStarter(intent, \"startNextMatchingActivity\")\n-                    .setCaller(r.app.getThread())\n-                    .setResolvedType(r.resolvedType)\n-                    .setActivityInfo(aInfo)\n-                    .setResultTo(resultTo != null ? resultTo.appToken : null)\n-                    .setResultWho(resultWho)\n-                    .setRequestCode(requestCode)\n-                    .setCallingPid(-1)\n-                    .setCallingUid(r.launchedFromUid)\n-                    .setCallingPackage(r.launchedFromPackage)\n-                    .setCallingFeatureId(r.launchedFromFeatureId)\n-                    .setRealCallingPid(-1)\n-                    .setRealCallingUid(r.launchedFromUid)\n-                    .setActivityOptions(options)\n-                    .execute();\n-            Binder.restoreCallingIdentity(origId);\n-\n-            r.finishing = wasFinishing;\n-            if (res != ActivityManager.START_SUCCESS) {\n-                return false;\n+            try {\n+                if (options == null) {\n+                    options = new SafeActivityOptions(ActivityOptions.makeBasic());\n+                }\n+                // Fixes b/230492947\n+                // Prevents background activity launch through #startNextMatchingActivity\n+                // An activity going into the background could still go back to the foreground\n+                // if the intent used matches both:\n+                // - the activity in the background\n+                // - a second activity.\n+                options.getOptions(r).setAvoidMoveToFront();\n+                final int res = getActivityStartController()\n+                        .obtainStarter(intent, \"startNextMatchingActivity\")\n+                        .setCaller(r.app.getThread())\n+                        .setResolvedType(r.resolvedType)\n+                        .setActivityInfo(aInfo)\n+                        .setResultTo(resultTo != null ? resultTo.appToken : null)\n+                        .setResultWho(resultWho)\n+                        .setRequestCode(requestCode)\n+                        .setCallingPid(-1)\n+                        .setCallingUid(r.launchedFromUid)\n+                        .setCallingPackage(r.launchedFromPackage)\n+                        .setCallingFeatureId(r.launchedFromFeatureId)\n+                        .setRealCallingPid(-1)\n+                        .setRealCallingUid(r.launchedFromUid)\n+                        .setActivityOptions(options)\n+                        .execute();\n+                r.finishing = wasFinishing;\n+                return res == ActivityManager.START_SUCCESS;\n+            } finally {\n+                Binder.restoreCallingIdentity(origId);\n             }\n-            return true;\n         }\n     }\n \n",
                            "downstream_patch_tokens": {
                                "openai": 858,
                                "general": {
                                    "word_based": 279,
                                    "char_based": 974
                                },
                                "gemini": 1046
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "services/core/java/com/android/server/wm/ActivityTaskManagerService.java",
                                    "total_hunks": 1,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12L)\n\n=======\n\n            final long origId = Binder.clearCallingIdentity();\n            // TODO(b/64750076): Check if calling pid should really be -1.\n            try {\n                if (options == null) {\n                    options = new SafeActivityOptions(ActivityOptions.makeBasic());\n                }\n\n                // Fixes b/230492947\n                // Prevents background activity launch through #startNextMatchingActivity\n>>>>>>> UPSTREAM PATCH (commit e3c537ddea5ce8b28eeb89300ef602753cfe42a4)",
                                            "merge_conflict_tokens": {
                                                "openai": 119,
                                                "general": {
                                                    "word_based": 41,
                                                    "char_based": 135
                                                },
                                                "gemini": 152
                                            }
                                        }
                                    ],
                                    "inline_merge_token_summary": {
                                        "gemini": 1976,
                                        "openai": 1666,
                                        "general_word": 574,
                                        "general_char": 1890
                                    },
                                    "rej_file_content": "```diff\n--- services/core/java/com/android/server/wm/ActivityTaskManagerService.java\n+++ services/core/java/com/android/server/wm/ActivityTaskManagerService.java\n@@ -1411,29 +1411,39 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n \n             final long origId = Binder.clearCallingIdentity();\n             // TODO(b/64750076): Check if calling pid should really be -1.\n-            final int res = getActivityStartController()\n-                    .obtainStarter(intent, \"startNextMatchingActivity\")\n-                    .setCaller(r.app.getThread())\n-                    .setResolvedType(r.resolvedType)\n-                    .setActivityInfo(aInfo)\n-                    .setResultTo(resultTo != null ? resultTo.token : null)\n-                    .setResultWho(resultWho)\n-                    .setRequestCode(requestCode)\n-                    .setCallingPid(-1)\n-                    .setCallingUid(r.launchedFromUid)\n-                    .setCallingPackage(r.launchedFromPackage)\n-                    .setCallingFeatureId(r.launchedFromFeatureId)\n-                    .setRealCallingPid(-1)\n-                    .setRealCallingUid(r.launchedFromUid)\n-                    .setActivityOptions(options)\n-                    .execute();\n-            Binder.restoreCallingIdentity(origId);\n+            try {\n+                if (options == null) {\n+                    options = new SafeActivityOptions(ActivityOptions.makeBasic());\n+                }\n \n-            r.finishing = wasFinishing;\n-            if (res != ActivityManager.START_SUCCESS) {\n-                return false;\n+                // Fixes b/230492947\n+                // Prevents background activity launch through #startNextMatchingActivity\n+                // An activity going into the background could still go back to the foreground\n+                // if the intent used matches both:\n+                // - the activity in the background\n+                // - a second activity.\n+                options.getOptions(r).setAvoidMoveToFront();\n+                final int res = getActivityStartController()\n+                        .obtainStarter(intent, \"startNextMatchingActivity\")\n+                        .setCaller(r.app.getThread())\n+                        .setResolvedType(r.resolvedType)\n+                        .setActivityInfo(aInfo)\n+                        .setResultTo(resultTo != null ? resultTo.token : null)\n+                        .setResultWho(resultWho)\n+                        .setRequestCode(requestCode)\n+                        .setCallingPid(-1)\n+                        .setCallingUid(r.launchedFromUid)\n+                        .setCallingPackage(r.launchedFromPackage)\n+                        .setCallingFeatureId(r.launchedFromFeatureId)\n+                        .setRealCallingPid(-1)\n+                        .setRealCallingUid(r.launchedFromUid)\n+                        .setActivityOptions(options)\n+                        .execute();\n+                r.finishing = wasFinishing;\n+                return res == ActivityManager.START_SUCCESS;\n+            } finally {\n+                Binder.restoreCallingIdentity(origId);\n             }\n-            return true;\n         }\n     }\n```",
                                    "rej_file_tokens": {
                                        "openai": 635,
                                        "general": {
                                            "word_based": 208,
                                            "char_based": 804
                                        },
                                        "gemini": 743
                                    },
                                    "patch_apply_output": "patching file services/core/java/com/android/server/wm/ActivityTaskManagerService.java\nHunk #1 FAILED at 1411.\n1 out of 1 hunk FAILED -- saving rejects to file services/core/java/com/android/server/wm/ActivityTaskManagerService.java.rej",
                                    "inline_merge_output": "patching file services/core/java/com/android/server/wm/ActivityTaskManagerService.java\nHunk #1 NOT MERGED at 1421-1433, already applied at 1460.",
                                    "upstream_file_tokens": {
                                        "openai": 59312,
                                        "general": {
                                            "word_based": 22835,
                                            "char_based": 77205
                                        },
                                        "gemini": 69378
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2018 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License\n */\n\npackage com.android.server.wm;\n\nimport static android.Manifest.permission.BIND_VOICE_INTERACTION;\nimport static android.Manifest.permission.CHANGE_CONFIGURATION;\nimport static android.Manifest.permission.CONTROL_REMOTE_APP_TRANSITION_ANIMATIONS;\nimport static android.Manifest.permission.INTERACT_ACROSS_USERS;\nimport static android.Manifest.permission.INTERACT_ACROSS_USERS_FULL;\nimport static android.Manifest.permission.INTERNAL_SYSTEM_WINDOW;\nimport static android.Manifest.permission.MANAGE_ACTIVITY_STACKS;\nimport static android.Manifest.permission.MANAGE_ACTIVITY_TASKS;\nimport static android.Manifest.permission.READ_FRAME_BUFFER;\nimport static android.Manifest.permission.REMOVE_TASKS;\nimport static android.Manifest.permission.START_TASKS_FROM_RECENTS;\nimport static android.Manifest.permission.STOP_APP_SWITCHES;\nimport static android.app.ActivityManager.DROP_CLOSE_SYSTEM_DIALOGS;\nimport static android.app.ActivityManager.LOCK_DOWN_CLOSE_SYSTEM_DIALOGS;\nimport static android.app.ActivityManager.LOCK_TASK_MODE_NONE;\nimport static android.app.ActivityManagerInternal.ALLOW_NON_FULL;\nimport static android.app.ActivityTaskManager.INVALID_TASK_ID;\nimport static android.app.ActivityTaskManager.RESIZE_MODE_PRESERVE_WINDOW;\nimport static android.app.WindowConfiguration.ACTIVITY_TYPE_DREAM;\nimport static android.app.WindowConfiguration.WINDOWING_MODE_PINNED;\nimport static android.content.Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;\nimport static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\nimport static android.content.pm.ActivityInfo.RESIZE_MODE_UNRESIZEABLE;\nimport static android.content.pm.ApplicationInfo.FLAG_FACTORY_TEST;\nimport static android.content.pm.ConfigurationInfo.GL_ES_VERSION_UNDEFINED;\nimport static android.content.pm.PackageManager.FEATURE_ACTIVITIES_ON_SECONDARY_DISPLAYS;\nimport static android.content.pm.PackageManager.FEATURE_CANT_SAVE_STATE;\nimport static android.content.pm.PackageManager.FEATURE_FREEFORM_WINDOW_MANAGEMENT;\nimport static android.content.pm.PackageManager.FEATURE_LEANBACK;\nimport static android.content.pm.PackageManager.FEATURE_PICTURE_IN_PICTURE;\nimport static android.content.pm.PackageManager.PERMISSION_GRANTED;\nimport static android.os.FactoryTest.FACTORY_TEST_HIGH_LEVEL;\nimport static android.os.FactoryTest.FACTORY_TEST_LOW_LEVEL;\nimport static android.os.FactoryTest.FACTORY_TEST_OFF;\nimport static android.os.InputConstants.DEFAULT_DISPATCHING_TIMEOUT_MILLIS;\nimport static android.os.Process.FIRST_APPLICATION_UID;\nimport static android.os.Process.SYSTEM_UID;\nimport static android.os.Trace.TRACE_TAG_WINDOW_MANAGER;\nimport static android.provider.Settings.Global.DEVELOPMENT_ENABLE_FREEFORM_WINDOWS_SUPPORT;\nimport static android.provider.Settings.Global.DEVELOPMENT_ENABLE_NON_RESIZABLE_MULTI_WINDOW;\nimport static android.provider.Settings.Global.DEVELOPMENT_FORCE_RESIZABLE_ACTIVITIES;\nimport static android.provider.Settings.Global.DEVELOPMENT_FORCE_RTL;\nimport static android.provider.Settings.Global.HIDE_ERROR_DIALOGS;\nimport static android.provider.Settings.System.FONT_SCALE;\nimport static android.text.format.DateUtils.MINUTE_IN_MILLIS;\nimport static android.view.Display.DEFAULT_DISPLAY;\nimport static android.view.Display.INVALID_DISPLAY;\nimport static android.view.WindowManager.TRANSIT_NONE;\n\nimport static com.android.internal.protolog.ProtoLogGroup.WM_DEBUG_CONFIGURATION;\nimport static com.android.internal.protolog.ProtoLogGroup.WM_DEBUG_FOCUS;\nimport static com.android.internal.protolog.ProtoLogGroup.WM_DEBUG_IMMERSIVE;\nimport static com.android.internal.protolog.ProtoLogGroup.WM_DEBUG_LOCKTASK;\nimport static com.android.internal.protolog.ProtoLogGroup.WM_DEBUG_TASKS;\nimport static com.android.server.am.ActivityManagerService.ANR_TRACE_DIR;\nimport static com.android.server.am.ActivityManagerService.MY_PID;\nimport static com.android.server.am.ActivityManagerService.STOCK_PM_FLAGS;\nimport static com.android.server.am.ActivityManagerService.dumpStackTraces;\nimport static com.android.server.am.ActivityManagerServiceDumpActivitiesProto.ROOT_WINDOW_CONTAINER;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.CONFIG_WILL_CHANGE;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.CONTROLLER;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.CURRENT_TRACKER;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.Controller.IS_A_MONKEY;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.GLOBAL_CONFIGURATION;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.GOING_TO_SLEEP;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.HEAVY_WEIGHT_PROC;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.HOME_PROC;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.LAUNCHING_ACTIVITY;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.PREVIOUS_PROC;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.PREVIOUS_PROC_VISIBLE_TIME_MS;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.SCREEN_COMPAT_PACKAGES;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.ScreenCompatPackage.MODE;\nimport static com.android.server.am.ActivityManagerServiceDumpProcessesProto.ScreenCompatPackage.PACKAGE;\nimport static com.android.server.am.EventLogTags.writeBootProgressEnableScreen;\nimport static com.android.server.am.EventLogTags.writeConfigurationChanged;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.DEBUG_ALL;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.POSTFIX_ROOT_TASK;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.POSTFIX_SWITCH;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.TAG_ATM;\nimport static com.android.server.wm.ActivityTaskManagerDebugConfig.TAG_WITH_CLASS_NAME;\nimport static com.android.server.wm.ActivityTaskManagerInternal.ASSIST_KEY_CONTENT;\nimport static com.android.server.wm.ActivityTaskManagerInternal.ASSIST_KEY_DATA;\nimport static com.android.server.wm.ActivityTaskManagerInternal.ASSIST_KEY_RECEIVER_EXTRAS;\nimport static com.android.server.wm.ActivityTaskManagerInternal.ASSIST_KEY_STRUCTURE;\nimport static com.android.server.wm.ActivityTaskManagerService.H.REPORT_TIME_TRACKER_MSG;\nimport static com.android.server.wm.ActivityTaskManagerService.UiHandler.DISMISS_DIALOG_UI_MSG;\nimport static com.android.server.wm.ActivityTaskSupervisor.DEFER_RESUME;\nimport static com.android.server.wm.ActivityTaskSupervisor.ON_TOP;\nimport static com.android.server.wm.ActivityTaskSupervisor.PRESERVE_WINDOWS;\nimport static com.android.server.wm.ActivityTaskSupervisor.REMOVE_FROM_RECENTS;\nimport static com.android.server.wm.LockTaskController.LOCK_TASK_AUTH_DONT_LOCK;\nimport static com.android.server.wm.RecentsAnimationController.REORDER_KEEP_IN_PLACE;\nimport static com.android.server.wm.RecentsAnimationController.REORDER_MOVE_TO_ORIGINAL_POSITION;\nimport static com.android.server.wm.RootWindowContainer.MATCH_ATTACHED_TASK_ONLY;\nimport static com.android.server.wm.RootWindowContainer.MATCH_ATTACHED_TASK_OR_RECENT_TASKS;\nimport static com.android.server.wm.Task.REPARENT_KEEP_ROOT_TASK_AT_FRONT;\nimport static com.android.server.wm.WindowManagerService.UPDATE_FOCUS_NORMAL;\n\nimport android.Manifest;\nimport android.annotation.IntDef;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.UserIdInt;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.ActivityOptions;\nimport android.app.ActivityTaskManager;\nimport android.app.ActivityTaskManager.RootTaskInfo;\nimport android.app.ActivityThread;\nimport android.app.AlertDialog;\nimport android.app.AnrController;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.Dialog;\nimport android.app.IActivityClientController;\nimport android.app.IActivityController;\nimport android.app.IActivityTaskManager;\nimport android.app.IApplicationThread;\nimport android.app.IAssistDataReceiver;\nimport android.app.INotificationManager;\nimport android.app.ITaskStackListener;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.PictureInPictureParams;\nimport android.app.PictureInPictureUiState;\nimport android.app.ProfilerInfo;\nimport android.app.RemoteAction;\nimport android.app.WaitResult;\nimport android.app.admin.DevicePolicyCache;\nimport android.app.assist.AssistContent;\nimport android.app.assist.AssistStructure;\nimport android.app.compat.CompatChanges;\nimport android.app.usage.UsageStatsManagerInternal;\nimport android.content.ActivityNotFoundException;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.IIntentSender;\nimport android.content.Intent;\nimport android.content.LocusId;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.ConfigurationInfo;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.ResolveInfo;\nimport android.content.res.CompatibilityInfo;\nimport android.content.res.Configuration;\nimport android.content.res.Resources;\nimport android.database.ContentObserver;\nimport android.graphics.Bitmap;\nimport android.graphics.Point;\nimport android.graphics.Rect;\nimport android.hardware.power.Mode;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.FactoryTest;\nimport android.os.FileUtils;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.IUserManager;\nimport android.os.LocaleList;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.Parcel;\nimport android.os.PowerManager;\nimport android.os.PowerManagerInternal;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.ServiceManager;\nimport android.os.StrictMode;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.Trace;\nimport android.os.UpdateLock;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.WorkSource;\nimport android.os.storage.IStorageManager;\nimport android.os.storage.StorageManager;\nimport android.provider.Settings;\nimport android.service.dreams.DreamActivity;\nimport android.service.voice.IVoiceInteractionSession;\nimport android.service.voice.VoiceInteractionManagerInternal;\nimport android.sysprop.DisplayProperties;\nimport android.telecom.TelecomManager;\nimport android.text.format.TimeMigrationUtils;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.IntArray;\nimport android.util.Log;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.TimeUtils;\nimport android.util.proto.ProtoOutputStream;\nimport android.view.IRecentsAnimationRunner;\nimport android.view.RemoteAnimationAdapter;\nimport android.view.RemoteAnimationDefinition;\nimport android.view.WindowManager;\nimport android.window.IWindowOrganizerController;\nimport android.window.SplashScreenView.SplashScreenViewParcelable;\nimport android.window.TaskSnapshot;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.app.IVoiceInteractor;\nimport com.android.internal.app.ProcessMap;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.os.TransferPipe;\nimport com.android.internal.policy.AttributeCache;\nimport com.android.internal.policy.KeyguardDismissCallback;\nimport com.android.internal.protolog.common.ProtoLog;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.FastPrintWriter;\nimport com.android.internal.util.FrameworkStatsLog;\nimport com.android.internal.util.function.pooled.PooledLambda;\nimport com.android.server.LocalServices;\nimport com.android.server.SystemService;\nimport com.android.server.SystemServiceManager;\nimport com.android.server.UiThread;\nimport com.android.server.Watchdog;\nimport com.android.server.am.ActivityManagerService;\nimport com.android.server.am.ActivityManagerServiceDumpProcessesProto;\nimport com.android.server.am.AppTimeTracker;\nimport com.android.server.am.AssistDataRequester;\nimport com.android.server.am.BaseErrorDialog;\nimport com.android.server.am.PendingIntentController;\nimport com.android.server.am.PendingIntentRecord;\nimport com.android.server.am.UserState;\nimport com.android.server.firewall.IntentFirewall;\nimport com.android.server.inputmethod.InputMethodSystemProperty;\nimport com.android.server.pm.UserManagerService;\nimport com.android.server.policy.PermissionPolicyInternal;\nimport com.android.server.statusbar.StatusBarManagerInternal;\nimport com.android.server.uri.NeededUriGrants;\nimport com.android.server.uri.UriGrantsManagerInternal;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.ref.WeakReference;\nimport java.text.DateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\n\n/**\n * System service for managing activities and their containers (task, displays,... ).\n *\n * {@hide}\n */\npublic class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n    private static final String TAG = TAG_WITH_CLASS_NAME ? \"ActivityTaskManagerService\" : TAG_ATM;\n    static final String TAG_ROOT_TASK = TAG + POSTFIX_ROOT_TASK;\n    static final String TAG_SWITCH = TAG + POSTFIX_SWITCH;\n\n    // How long we wait until we timeout on key dispatching during instrumentation.\n    static final long INSTRUMENTATION_KEY_DISPATCHING_TIMEOUT_MILLIS = 60 * 1000;\n    // How long we permit background activity starts after an activity in the process\n    // started or finished.\n    static final long ACTIVITY_BG_START_GRACE_PERIOD_MS = 10 * 1000;\n\n    /**\n     * The duration to keep a process in animating state (top scheduling group) when the\n     * wakefulness is changing from awake to doze or sleep.\n     */\n    private static final long DOZE_ANIMATING_STATE_RETAIN_TIME_MS = 2000;\n\n    /** Used to indicate that an app transition should be animated. */\n    static final boolean ANIMATE = true;\n\n    /** Hardware-reported OpenGLES version. */\n    final int GL_ES_VERSION;\n\n    public static final String DUMP_ACTIVITIES_CMD = \"activities\";\n    public static final String DUMP_ACTIVITIES_SHORT_CMD = \"a\";\n    public static final String DUMP_LASTANR_CMD = \"lastanr\";\n    public static final String DUMP_LASTANR_TRACES_CMD = \"lastanr-traces\";\n    public static final String DUMP_STARTER_CMD = \"starter\";\n    public static final String DUMP_CONTAINERS_CMD = \"containers\";\n    public static final String DUMP_RECENTS_CMD = \"recents\";\n    public static final String DUMP_RECENTS_SHORT_CMD = \"r\";\n    public static final String DUMP_TOP_RESUMED_ACTIVITY = \"top-resumed\";\n\n    /** This activity is not being relaunched, or being relaunched for a non-resize reason. */\n    public static final int RELAUNCH_REASON_NONE = 0;\n    /** This activity is being relaunched due to windowing mode change. */\n    public static final int RELAUNCH_REASON_WINDOWING_MODE_RESIZE = 1;\n    /** This activity is being relaunched due to a free-resize operation. */\n    public static final int RELAUNCH_REASON_FREE_RESIZE = 2;\n\n    Context mContext;\n\n    /**\n     * This Context is themable and meant for UI display (AlertDialogs, etc.). The theme can\n     * change at runtime. Use mContext for non-UI purposes.\n     */\n    final Context mUiContext;\n    final ActivityThread mSystemThread;\n    H mH;\n    UiHandler mUiHandler;\n    ActivityManagerInternal mAmInternal;\n    UriGrantsManagerInternal mUgmInternal;\n    private PackageManagerInternal mPmInternal;\n    /** The cached sys ui service component name from package manager. */\n    private ComponentName mSysUiServiceComponent;\n    private PermissionPolicyInternal mPermissionPolicyInternal;\n    private StatusBarManagerInternal mStatusBarManagerInternal;\n    @VisibleForTesting\n    final ActivityTaskManagerInternal mInternal;\n    private PowerManagerInternal mPowerManagerInternal;\n    private UsageStatsManagerInternal mUsageStatsInternal;\n\n    PendingIntentController mPendingIntentController;\n    IntentFirewall mIntentFirewall;\n\n    final VisibleActivityProcessTracker mVisibleActivityProcessTracker;\n\n    /* Global service lock used by the package the owns this service. */\n    final WindowManagerGlobalLock mGlobalLock = new WindowManagerGlobalLock();\n    /**\n     * It is the same instance as {@link #mGlobalLock}, just declared as a type that the\n     * locked-region-code-injection does't recognize it. It is used to skip wrapping priority\n     * booster for places that are already in the scope of another booster (e.g. computing oom-adj).\n     *\n     * @see WindowManagerThreadPriorityBooster\n     */\n    final Object mGlobalLockWithoutBoost = mGlobalLock;\n    ActivityTaskSupervisor mTaskSupervisor;\n    ActivityClientController mActivityClientController;\n    RootWindowContainer mRootWindowContainer;\n    WindowManagerService mWindowManager;\n    private UserManagerService mUserManager;\n    private AppOpsManager mAppOpsManager;\n    /** All active uids in the system. */\n    final MirrorActiveUids mActiveUids = new MirrorActiveUids();\n    private final SparseArray<String> mPendingTempAllowlist = new SparseArray<>();\n    /** All processes currently running that might have a window organized by name. */\n    final ProcessMap<WindowProcessController> mProcessNames = new ProcessMap<>();\n    /** All processes we currently have running mapped by pid and uid */\n    final WindowProcessControllerMap mProcessMap = new WindowProcessControllerMap();\n    /** This is the process holding what we currently consider to be the \"home\" activity. */\n    volatile WindowProcessController mHomeProcess;\n    /** The currently running heavy-weight process, if any. */\n    volatile WindowProcessController mHeavyWeightProcess;\n    boolean mHasHeavyWeightFeature;\n    boolean mHasLeanbackFeature;\n    /** The process of the top most activity. */\n    volatile WindowProcessController mTopApp;\n    /**\n     * This is the process holding the activity the user last visited that is in a different process\n     * from the one they are currently in.\n     */\n    volatile WindowProcessController mPreviousProcess;\n    /** The time at which the previous process was last visible. */\n    long mPreviousProcessVisibleTime;\n\n    /** List of intents that were used to start the most recent tasks. */\n    private RecentTasks mRecentTasks;\n    /** State of external calls telling us if the device is awake or asleep. */\n    private boolean mKeyguardShown = false;\n\n    // VoiceInteraction session ID that changes for each new request except when\n    // being called for multi-window assist in a single session.\n    private int mViSessionId = 1000;\n\n    // How long to wait in getAssistContextExtras for the activity and foreground services\n    // to respond with the result.\n    private static final int PENDING_ASSIST_EXTRAS_TIMEOUT = 500;\n\n    // How long top wait when going through the modern assist (which doesn't need to block\n    // on getting this result before starting to launch its UI).\n    private static final int PENDING_ASSIST_EXTRAS_LONG_TIMEOUT = 2000;\n\n    // How long to wait in getAutofillAssistStructure() for the activity to respond with the result.\n    private static final int PENDING_AUTOFILL_ASSIST_STRUCTURE_TIMEOUT = 2000;\n\n    // Permission tokens are used to temporarily granted a trusted app the ability to call\n    // #startActivityAsCaller.  A client is expected to dump its token after this time has elapsed,\n    // showing any appropriate error messages to the user.\n    private static final long START_AS_CALLER_TOKEN_TIMEOUT =\n            10 * MINUTE_IN_MILLIS;\n\n    // How long before the service actually expires a token.  This is slightly longer than\n    // START_AS_CALLER_TOKEN_TIMEOUT, to provide a buffer so clients will rarely encounter the\n    // expiration exception.\n    private static final long START_AS_CALLER_TOKEN_TIMEOUT_IMPL =\n            START_AS_CALLER_TOKEN_TIMEOUT + 2 * 1000;\n\n    // How long the service will remember expired tokens, for the purpose of providing error\n    // messaging when a client uses an expired token.\n    private static final long START_AS_CALLER_TOKEN_EXPIRED_TIMEOUT =\n            START_AS_CALLER_TOKEN_TIMEOUT_IMPL + 20 * MINUTE_IN_MILLIS;\n\n    // Activity tokens of system activities that are delegating their call to\n    // #startActivityByCaller, keyed by the permissionToken granted to the delegate.\n    final HashMap<IBinder, IBinder> mStartActivitySources = new HashMap<>();\n\n    // Permission tokens that have expired, but we remember for error reporting.\n    final ArrayList<IBinder> mExpiredStartAsCallerTokens = new ArrayList<>();\n\n    private final ArrayList<PendingAssistExtras> mPendingAssistExtras = new ArrayList<>();\n\n    // Keeps track of the active voice interaction service component, notified from\n    // VoiceInteractionManagerService\n    ComponentName mActiveVoiceInteractionServiceComponent;\n\n    // A map userId and all its companion app uids\n    private final Map<Integer, Set<Integer>> mCompanionAppUidsMap = new ArrayMap<>();\n\n    VrController mVrController;\n    KeyguardController mKeyguardController;\n    private final ClientLifecycleManager mLifecycleManager;\n    private TaskChangeNotificationController mTaskChangeNotificationController;\n    /** The controller for all operations related to locktask. */\n    private LockTaskController mLockTaskController;\n    private ActivityStartController mActivityStartController;\n    PackageConfigPersister mPackageConfigPersister;\n\n    boolean mSuppressResizeConfigChanges;\n\n    final UpdateConfigurationResult mTmpUpdateConfigurationResult =\n            new UpdateConfigurationResult();\n\n    static final class UpdateConfigurationResult {\n        // Configuration changes that were updated.\n        int changes;\n        // If the activity was relaunched to match the new configuration.\n        boolean activityRelaunched;\n\n        void reset() {\n            changes = 0;\n            activityRelaunched = false;\n        }\n    }\n\n    /** Current sequencing integer of the configuration, for skipping old configurations. */\n    private int mConfigurationSeq;\n\n    /** Current sequencing integer of the asset changes, for skipping old resources overlays. */\n    private int mGlobalAssetsSeq;\n\n    // To cache the list of supported system locales\n    private String[] mSupportedSystemLocales = null;\n\n    /**\n     * Temp object used when global and/or display override configuration is updated. It is also\n     * sent to outer world instead of {@link #getGlobalConfiguration} because we don't trust\n     * anyone...\n     */\n    private Configuration mTempConfig = new Configuration();\n\n    /** Temporary to avoid allocations. */\n    final StringBuilder mStringBuilder = new StringBuilder(256);\n\n    /**\n     * Whether normal application switches are allowed; a call to {@link #stopAppSwitches()\n     * disables this.\n     */\n    private volatile boolean mAppSwitchesAllowed = true;\n\n    /**\n     * Last stop app switches time, apps finished before this time cannot start background activity\n     * even if they are in grace period.\n     */\n    private volatile long mLastStopAppSwitchesTime;\n\n    private final List<AnrController> mAnrController = new ArrayList<>();\n    IActivityController mController = null;\n    boolean mControllerIsAMonkey = false;\n\n    final int mFactoryTest;\n\n    /** Used to control how we initialize the service. */\n    ComponentName mTopComponent;\n    String mTopAction = Intent.ACTION_MAIN;\n    String mTopData;\n\n    /** Profiling app information. */\n    String mProfileApp = null;\n    WindowProcessController mProfileProc = null;\n    ProfilerInfo mProfilerInfo = null;\n\n    /**\n     * Dump of the activity state at the time of the last ANR. Cleared after\n     * {@link WindowManagerService#LAST_ANR_LIFETIME_DURATION_MSECS}\n     */\n    String mLastANRState;\n\n    /**\n     * Used to retain an update lock when the foreground activity is in\n     * immersive mode.\n     */\n    private final UpdateLock mUpdateLock = new UpdateLock(\"immersive\");\n\n    /**\n     * Packages that are being allowed to perform unrestricted app switches.  Mapping is\n     * User -> Type -> uid.\n     */\n    final SparseArray<ArrayMap<String, Integer>> mAllowAppSwitchUids = new SparseArray<>();\n\n    /** The dimensions of the thumbnails in the Recents UI. */\n    private int mThumbnailWidth;\n    private int mThumbnailHeight;\n\n    /**\n     * Flag that indicates if multi-window is enabled.\n     *\n     * For any particular form of multi-window to be enabled, generic multi-window must be enabled\n     * in {@link com.android.internal.R.bool#config_supportsMultiWindow} config or\n     * {@link Settings.Global#DEVELOPMENT_FORCE_RESIZABLE_ACTIVITIES} development option set.\n     * At least one of the forms of multi-window must be enabled in order for this flag to be\n     * initialized to 'true'.\n     *\n     * @see #mSupportsSplitScreenMultiWindow\n     * @see #mSupportsFreeformWindowManagement\n     * @see #mSupportsPictureInPicture\n     * @see #mSupportsMultiDisplay\n     */\n    boolean mSupportsMultiWindow;\n    boolean mSupportsSplitScreenMultiWindow;\n    boolean mSupportsFreeformWindowManagement;\n    boolean mSupportsPictureInPicture;\n    boolean mSupportsMultiDisplay;\n    boolean mForceResizableActivities;\n\n    /** Development option to enable non resizable in multi window. */\n    // TODO(b/176061101) change the default value to false.\n    boolean mDevEnableNonResizableMultiWindow;\n\n    /**\n     * Whether the device supports non-resizable in multi windowing modes.\n     * -1: The device doesn't support non-resizable in multi windowing modes.\n     *  0: The device supports non-resizable in multi windowing modes only if this is a large\n     *     screen (smallest width >= {@link #mLargeScreenSmallestScreenWidthDp}).\n     *  1: The device always supports non-resizable in multi windowing modes.\n     */\n    int mSupportsNonResizableMultiWindow;\n\n    /**\n     * Whether the device checks activity min width/height to determine if it can be shown in multi\n     * windowing modes.\n     * -1: The device ignores activity min width/height when determining if it can be shown in multi\n     *     windowing modes.\n     *  0: If it is a small screen (smallest width < {@link #mLargeScreenSmallestScreenWidthDp}),\n     *     the device compares the activity min width/height with the min multi windowing modes\n     *     dimensions {@link #mMinPercentageMultiWindowSupportHeight} the device supports to\n     *     determine whether the activity can be shown in multi windowing modes\n     *  1: The device always compare the activity min width/height with the min multi windowing\n     *     modes dimensions {@link #mMinPercentageMultiWindowSupportHeight} the device supports to\n     *     determine whether it can be shown in multi windowing modes.\n     */\n    int mRespectsActivityMinWidthHeightMultiWindow;\n\n    /**\n     * This value is only used when the device checks activity min height to determine if it\n     * can be shown in multi windowing modes.\n     * If the activity min height is greater than this percentage of the display height in portrait,\n     * it will not be allowed to be shown in multi windowing modes.\n     * The value should be between [0 - 1].\n     */\n    float mMinPercentageMultiWindowSupportHeight;\n\n    /**\n     * This value is only used when the device checks activity min width to determine if it\n     * can be shown in multi windowing modes.\n     * If the activity min width is greater than this percentage of the display width in landscape,\n     * it will not be allowed to be shown in multi windowing modes.\n     * The value should be between [0 - 1].\n     */\n    float mMinPercentageMultiWindowSupportWidth;\n\n    /**\n     * If the display {@link Configuration#smallestScreenWidthDp} is greater or equal to this value,\n     * we will treat it as a large screen device, which will have some multi window features enabled\n     * by default.\n     */\n    int mLargeScreenSmallestScreenWidthDp;\n\n    final List<ActivityTaskManagerInternal.ScreenObserver> mScreenObservers = new ArrayList<>();\n\n    // VR Vr2d Display Id.\n    int mVr2dDisplayId = INVALID_DISPLAY;\n\n    /**\n     * Set while we are wanting to sleep, to prevent any\n     * activities from being started/resumed.\n     *\n     * TODO(b/33594039): Clarify the actual state transitions represented by mSleeping.\n     *\n     * Currently mSleeping is set to true when transitioning into the sleep state, and remains true\n     * while in the sleep state until there is a pending transition out of sleep, in which case\n     * mSleeping is set to false, and remains false while awake.\n     *\n     * Whether mSleeping can quickly toggled between true/false without the device actually\n     * display changing states is undefined.\n     */\n    private volatile boolean mSleeping;\n\n    /**\n     * The mDreaming state is set by the {@link DreamManagerService} when it receives a request to\n     * start/stop the dream. It is set to true shortly  before the {@link DreamService} is started.\n     * It is set to false after the {@link DreamService} is stopped.\n     */\n    private boolean mDreaming = false;\n\n    /**\n     * The process state used for processes that are running the top activities.\n     * This changes between TOP and TOP_SLEEPING to following mSleeping.\n     */\n    volatile int mTopProcessState = ActivityManager.PROCESS_STATE_TOP;\n\n    @Retention(RetentionPolicy.SOURCE)\n    @IntDef({\n            POWER_MODE_REASON_START_ACTIVITY,\n            POWER_MODE_REASON_FREEZE_DISPLAY,\n            POWER_MODE_REASON_ALL,\n    })\n    @interface PowerModeReason {}\n\n    static final int POWER_MODE_REASON_START_ACTIVITY = 1 << 0;\n    static final int POWER_MODE_REASON_FREEZE_DISPLAY = 1 << 1;\n    /** This can only be used by {@link #endLaunchPowerMode(int)}.*/\n    static final int POWER_MODE_REASON_ALL = (1 << 2) - 1;\n\n    /** The reasons to use {@link Mode#LAUNCH} power mode. */\n    private @PowerModeReason int mLaunchPowerModeReasons;\n\n    @Retention(RetentionPolicy.SOURCE)\n    @IntDef({\n            LAYOUT_REASON_CONFIG_CHANGED,\n            LAYOUT_REASON_VISIBILITY_CHANGED,\n    })\n    @interface LayoutReason {\n    }\n\n    static final int LAYOUT_REASON_CONFIG_CHANGED = 0x1;\n    static final int LAYOUT_REASON_VISIBILITY_CHANGED = 0x2;\n\n    /** The reasons to perform surface placement. */\n    @LayoutReason\n    private int mLayoutReasons;\n\n    // Whether we should show our dialogs (ANR, crash, etc) or just perform their default action\n    // automatically. Important for devices without direct input devices.\n    private boolean mShowDialogs = true;\n\n    /** Set if we are shutting down the system, similar to sleeping. */\n    boolean mShuttingDown = false;\n\n    /**\n     * We want to hold a wake lock while running a voice interaction session, since\n     * this may happen with the screen off and we need to keep the CPU running to\n     * be able to continue to interact with the user.\n     */\n    PowerManager.WakeLock mVoiceWakeLock;\n\n    /**\n     * Set while we are running a voice interaction. This overrides sleeping while it is active.\n     */\n    IVoiceInteractionSession mRunningVoice;\n\n    /**\n     * The last resumed activity. This is identical to the current resumed activity most\n     * of the time but could be different when we're pausing one activity before we resume\n     * another activity.\n     */\n    ActivityRecord mLastResumedActivity;\n\n    /**\n     * The activity that is currently being traced as the active resumed activity.\n     *\n     * @see #updateResumedAppTrace\n     */\n    @Nullable\n    private ActivityRecord mTracedResumedActivity;\n\n    /** If non-null, we are tracking the time the user spends in the currently focused app. */\n    AppTimeTracker mCurAppTimeTracker;\n\n    AppWarnings mAppWarnings;\n\n    /**\n     * Packages that the user has asked to have run in screen size\n     * compatibility mode instead of filling the screen.\n     */\n    CompatModePackages mCompatModePackages;\n\n    private SettingObserver mSettingsObserver;\n\n    WindowOrganizerController mWindowOrganizerController;\n    TaskOrganizerController mTaskOrganizerController;\n\n    @Nullable\n    private BackgroundActivityStartCallback mBackgroundActivityStartCallback;\n\n    private int[] mAccessibilityServiceUids = new int[0];\n\n    private int mDeviceOwnerUid = Process.INVALID_UID;\n\n    private final class SettingObserver extends ContentObserver {\n        private final Uri mFontScaleUri = Settings.System.getUriFor(FONT_SCALE);\n        private final Uri mHideErrorDialogsUri = Settings.Global.getUriFor(HIDE_ERROR_DIALOGS);\n        private final Uri mFontWeightAdjustmentUri = Settings.Secure.getUriFor(\n                Settings.Secure.FONT_WEIGHT_ADJUSTMENT);\n\n        SettingObserver() {\n            super(mH);\n            final ContentResolver resolver = mContext.getContentResolver();\n            resolver.registerContentObserver(mFontScaleUri, false, this, UserHandle.USER_ALL);\n            resolver.registerContentObserver(mHideErrorDialogsUri, false, this,\n                    UserHandle.USER_ALL);\n            resolver.registerContentObserver(\n                    mFontWeightAdjustmentUri, false, this, UserHandle.USER_ALL);\n        }\n\n        @Override\n        public void onChange(boolean selfChange, Collection<Uri> uris, int flags,\n                @UserIdInt int userId) {\n            for (Uri uri : uris) {\n                if (mFontScaleUri.equals(uri)) {\n                    updateFontScaleIfNeeded(userId);\n                } else if (mHideErrorDialogsUri.equals(uri)) {\n                    synchronized (mGlobalLock) {\n                        updateShouldShowDialogsLocked(getGlobalConfiguration());\n                    }\n                } else if (mFontWeightAdjustmentUri.equals(uri)) {\n                    updateFontWeightAdjustmentIfNeeded(userId);\n                }\n            }\n        }\n    }\n\n    /** Indicates that the method may be invoked frequently or is sensitive to performance. */\n    @Target(ElementType.METHOD)\n    @Retention(RetentionPolicy.SOURCE)\n    @interface HotPath {\n        int NONE = 0;\n        int OOM_ADJUSTMENT = 1;\n        int LRU_UPDATE = 2;\n        int PROCESS_CHANGE = 3;\n        int START_SERVICE = 4;\n\n        int caller() default NONE;\n    }\n\n    private final Runnable mUpdateOomAdjRunnable = new Runnable() {\n        @Override\n        public void run() {\n            mAmInternal.updateOomAdj();\n        }\n    };\n\n    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)\n    public ActivityTaskManagerService(Context context) {\n        mContext = context;\n        mFactoryTest = FactoryTest.getMode();\n        mSystemThread = ActivityThread.currentActivityThread();\n        mUiContext = mSystemThread.getSystemUiContext();\n        mLifecycleManager = new ClientLifecycleManager();\n        mVisibleActivityProcessTracker = new VisibleActivityProcessTracker(this);\n        mInternal = new LocalService();\n        GL_ES_VERSION = SystemProperties.getInt(\"ro.opengles.version\", GL_ES_VERSION_UNDEFINED);\n        mWindowOrganizerController = new WindowOrganizerController(this);\n        mTaskOrganizerController = mWindowOrganizerController.mTaskOrganizerController;\n    }\n\n    public void onSystemReady() {\n        synchronized (mGlobalLock) {\n            final PackageManager pm = mContext.getPackageManager();\n            mHasHeavyWeightFeature = pm.hasSystemFeature(FEATURE_CANT_SAVE_STATE);\n            mHasLeanbackFeature = pm.hasSystemFeature(FEATURE_LEANBACK);\n            mVrController.onSystemReady();\n            mRecentTasks.onSystemReadyLocked();\n            mTaskSupervisor.onSystemReady();\n            mActivityClientController.onSystemReady();\n        }\n    }\n\n    public void onInitPowerManagement() {\n        synchronized (mGlobalLock) {\n            mTaskSupervisor.initPowerManagement();\n            final PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);\n            mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);\n            mVoiceWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, \"*voice*\");\n            mVoiceWakeLock.setReferenceCounted(false);\n        }\n    }\n\n    public void installSystemProviders() {\n        mSettingsObserver = new SettingObserver();\n    }\n\n    public void retrieveSettings(ContentResolver resolver) {\n        final boolean freeformWindowManagement =\n                mContext.getPackageManager().hasSystemFeature(FEATURE_FREEFORM_WINDOW_MANAGEMENT)\n                        || Settings.Global.getInt(\n                        resolver, DEVELOPMENT_ENABLE_FREEFORM_WINDOWS_SUPPORT, 0) != 0;\n\n        final boolean supportsMultiWindow = ActivityTaskManager.supportsMultiWindow(mContext);\n        final boolean supportsPictureInPicture = supportsMultiWindow &&\n                mContext.getPackageManager().hasSystemFeature(FEATURE_PICTURE_IN_PICTURE);\n        final boolean supportsSplitScreenMultiWindow =\n                ActivityTaskManager.supportsSplitScreenMultiWindow(mContext);\n        final boolean supportsMultiDisplay = mContext.getPackageManager()\n                .hasSystemFeature(FEATURE_ACTIVITIES_ON_SECONDARY_DISPLAYS);\n        final boolean forceRtl = Settings.Global.getInt(resolver, DEVELOPMENT_FORCE_RTL, 0) != 0;\n        final boolean forceResizable = Settings.Global.getInt(\n                resolver, DEVELOPMENT_FORCE_RESIZABLE_ACTIVITIES, 0) != 0;\n        final boolean devEnableNonResizableMultiWindow = Settings.Global.getInt(\n                resolver, DEVELOPMENT_ENABLE_NON_RESIZABLE_MULTI_WINDOW, 0) != 0;\n        final int supportsNonResizableMultiWindow = mContext.getResources().getInteger(\n                com.android.internal.R.integer.config_supportsNonResizableMultiWindow);\n        final int respectsActivityMinWidthHeightMultiWindow = mContext.getResources().getInteger(\n                com.android.internal.R.integer.config_respectsActivityMinWidthHeightMultiWindow);\n        final float minPercentageMultiWindowSupportHeight = mContext.getResources().getFloat(\n                com.android.internal.R.dimen.config_minPercentageMultiWindowSupportHeight);\n        final float minPercentageMultiWindowSupportWidth = mContext.getResources().getFloat(\n                com.android.internal.R.dimen.config_minPercentageMultiWindowSupportWidth);\n        final int largeScreenSmallestScreenWidthDp = mContext.getResources().getInteger(\n                com.android.internal.R.integer.config_largeScreenSmallestScreenWidthDp);\n\n        // Transfer any global setting for forcing RTL layout, into a System Property\n        DisplayProperties.debug_force_rtl(forceRtl);\n\n        final Configuration configuration = new Configuration();\n        Settings.System.getConfiguration(resolver, configuration);\n        if (forceRtl) {\n            // This will take care of setting the correct layout direction flags\n            configuration.setLayoutDirection(configuration.locale);\n        }\n\n        synchronized (mGlobalLock) {\n            mForceResizableActivities = forceResizable;\n            mDevEnableNonResizableMultiWindow = devEnableNonResizableMultiWindow;\n            mSupportsNonResizableMultiWindow = supportsNonResizableMultiWindow;\n            mRespectsActivityMinWidthHeightMultiWindow = respectsActivityMinWidthHeightMultiWindow;\n            mMinPercentageMultiWindowSupportHeight = minPercentageMultiWindowSupportHeight;\n            mMinPercentageMultiWindowSupportWidth = minPercentageMultiWindowSupportWidth;\n            mLargeScreenSmallestScreenWidthDp = largeScreenSmallestScreenWidthDp;\n            final boolean multiWindowFormEnabled = freeformWindowManagement\n                    || supportsSplitScreenMultiWindow\n                    || supportsPictureInPicture\n                    || supportsMultiDisplay;\n            if ((supportsMultiWindow || forceResizable) && multiWindowFormEnabled) {\n                mSupportsMultiWindow = true;\n                mSupportsFreeformWindowManagement = freeformWindowManagement;\n                mSupportsSplitScreenMultiWindow = supportsSplitScreenMultiWindow;\n                mSupportsPictureInPicture = supportsPictureInPicture;\n                mSupportsMultiDisplay = supportsMultiDisplay;\n            } else {\n                mSupportsMultiWindow = false;\n                mSupportsFreeformWindowManagement = false;\n                mSupportsSplitScreenMultiWindow = false;\n                mSupportsPictureInPicture = false;\n                mSupportsMultiDisplay = false;\n            }\n            mWindowManager.mRoot.onSettingsRetrieved();\n            // This happens before any activities are started, so we can change global configuration\n            // in-place.\n            updateConfigurationLocked(configuration, null, true);\n            final Configuration globalConfig = getGlobalConfiguration();\n            ProtoLog.v(WM_DEBUG_CONFIGURATION, \"Initial config: %s\", globalConfig);\n\n            // Load resources only after the current configuration has been set.\n            final Resources res = mContext.getResources();\n            mThumbnailWidth = res.getDimensionPixelSize(\n                    com.android.internal.R.dimen.thumbnail_width);\n            mThumbnailHeight = res.getDimensionPixelSize(\n                    com.android.internal.R.dimen.thumbnail_height);\n        }\n    }\n\n    public WindowManagerGlobalLock getGlobalLock() {\n        return mGlobalLock;\n    }\n\n    /** For test purpose only. */\n    @VisibleForTesting\n    public ActivityTaskManagerInternal getAtmInternal() {\n        return mInternal;\n    }\n\n    public void initialize(IntentFirewall intentFirewall, PendingIntentController intentController,\n            Looper looper) {\n        mH = new H(looper);\n        mUiHandler = new UiHandler();\n        mIntentFirewall = intentFirewall;\n        final File systemDir = SystemServiceManager.ensureSystemDir();\n        mAppWarnings = createAppWarnings(mUiContext, mH, mUiHandler, systemDir);\n        mCompatModePackages = new CompatModePackages(this, systemDir, mH);\n        mPendingIntentController = intentController;\n        mTaskSupervisor = createTaskSupervisor();\n        mActivityClientController = new ActivityClientController(this);\n\n        mTaskChangeNotificationController =\n                new TaskChangeNotificationController(mGlobalLock, mTaskSupervisor, mH);\n        mLockTaskController = new LockTaskController(mContext, mTaskSupervisor, mH,\n                mTaskChangeNotificationController);\n        mActivityStartController = new ActivityStartController(this);\n        setRecentTasks(new RecentTasks(this, mTaskSupervisor));\n        mVrController = new VrController(mGlobalLock);\n        mKeyguardController = mTaskSupervisor.getKeyguardController();\n        mPackageConfigPersister = new PackageConfigPersister(mTaskSupervisor.mPersisterQueue);\n    }\n\n    public void onActivityManagerInternalAdded() {\n        synchronized (mGlobalLock) {\n            mAmInternal = LocalServices.getService(ActivityManagerInternal.class);\n            mUgmInternal = LocalServices.getService(UriGrantsManagerInternal.class);\n        }\n    }\n\n    int increaseConfigurationSeqLocked() {\n        mConfigurationSeq = Math.max(++mConfigurationSeq, 1);\n        return mConfigurationSeq;\n    }\n\n    protected ActivityTaskSupervisor createTaskSupervisor() {\n        final ActivityTaskSupervisor supervisor = new ActivityTaskSupervisor(this,\n                mH.getLooper());\n        supervisor.initialize();\n        return supervisor;\n    }\n\n    protected AppWarnings createAppWarnings(\n            Context uiContext, Handler handler, Handler uiHandler, File systemDir) {\n        return new AppWarnings(this, uiContext, handler, uiHandler, systemDir);\n    }\n\n    public void setWindowManager(WindowManagerService wm) {\n        synchronized (mGlobalLock) {\n            mWindowManager = wm;\n            mRootWindowContainer = wm.mRoot;\n            mTempConfig.setToDefaults();\n            mTempConfig.setLocales(LocaleList.getDefault());\n            mConfigurationSeq = mTempConfig.seq = 1;\n            mRootWindowContainer.onConfigurationChanged(mTempConfig);\n            mLockTaskController.setWindowManager(wm);\n            mTaskSupervisor.setWindowManager(wm);\n            mRootWindowContainer.setWindowManager(wm);\n        }\n    }\n\n    public void setUsageStatsManager(UsageStatsManagerInternal usageStatsManager) {\n        synchronized (mGlobalLock) {\n            mUsageStatsInternal = usageStatsManager;\n        }\n    }\n\n    UserManagerService getUserManager() {\n        if (mUserManager == null) {\n            IBinder b = ServiceManager.getService(Context.USER_SERVICE);\n            mUserManager = (UserManagerService) IUserManager.Stub.asInterface(b);\n        }\n        return mUserManager;\n    }\n\n    AppOpsManager getAppOpsManager() {\n        if (mAppOpsManager == null) {\n            mAppOpsManager = mContext.getSystemService(AppOpsManager.class);\n        }\n        return mAppOpsManager;\n    }\n\n    boolean hasUserRestriction(String restriction, int userId) {\n        return getUserManager().hasUserRestriction(restriction, userId);\n    }\n\n    boolean hasSystemAlertWindowPermission(int callingUid, int callingPid,\n            String callingPackage) {\n        final int mode = getAppOpsManager().noteOpNoThrow(AppOpsManager.OP_SYSTEM_ALERT_WINDOW,\n                callingUid, callingPackage, /* featureId */ null, \"\");\n        if (mode == AppOpsManager.MODE_DEFAULT) {\n            return checkPermission(Manifest.permission.SYSTEM_ALERT_WINDOW, callingPid, callingUid)\n                    == PERMISSION_GRANTED;\n        }\n        return mode == AppOpsManager.MODE_ALLOWED;\n    }\n\n    @VisibleForTesting\n    protected void setRecentTasks(RecentTasks recentTasks) {\n        mRecentTasks = recentTasks;\n        mTaskSupervisor.setRecentTasks(recentTasks);\n    }\n\n    RecentTasks getRecentTasks() {\n        return mRecentTasks;\n    }\n\n    ClientLifecycleManager getLifecycleManager() {\n        return mLifecycleManager;\n    }\n\n    ActivityStartController getActivityStartController() {\n        return mActivityStartController;\n    }\n\n    TaskChangeNotificationController getTaskChangeNotificationController() {\n        return mTaskChangeNotificationController;\n    }\n\n    LockTaskController getLockTaskController() {\n        return mLockTaskController;\n    }\n\n    TransitionController getTransitionController() {\n        return mWindowOrganizerController.getTransitionController();\n    }\n\n    /**\n     * Return the global configuration used by the process corresponding to the input pid. This is\n     * usually the global configuration with some overrides specific to that process.\n     */\n    Configuration getGlobalConfigurationForCallingPid() {\n        final int pid = Binder.getCallingPid();\n        return getGlobalConfigurationForPid(pid);\n    }\n\n    /**\n     * Return the global configuration used by the process corresponding to the given pid.\n     */\n    Configuration getGlobalConfigurationForPid(int pid) {\n        if (pid == MY_PID || pid < 0) {\n            return getGlobalConfiguration();\n        }\n        synchronized (mGlobalLock) {\n            final WindowProcessController app = mProcessMap.getProcess(pid);\n            return app != null ? app.getConfiguration() : getGlobalConfiguration();\n        }\n    }\n\n    /**\n     * Return the device configuration info used by the process corresponding to the input pid.\n     * The value is consistent with the global configuration for the process.\n     */\n    @Override\n    public ConfigurationInfo getDeviceConfigurationInfo() {\n        ConfigurationInfo config = new ConfigurationInfo();\n        synchronized (mGlobalLock) {\n            final Configuration globalConfig = getGlobalConfigurationForCallingPid();\n            config.reqTouchScreen = globalConfig.touchscreen;\n            config.reqKeyboardType = globalConfig.keyboard;\n            config.reqNavigation = globalConfig.navigation;\n            if (globalConfig.navigation == Configuration.NAVIGATION_DPAD\n                    || globalConfig.navigation == Configuration.NAVIGATION_TRACKBALL) {\n                config.reqInputFeatures |= ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;\n            }\n            if (globalConfig.keyboard != Configuration.KEYBOARD_UNDEFINED\n                    && globalConfig.keyboard != Configuration.KEYBOARD_NOKEYS) {\n                config.reqInputFeatures |= ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;\n            }\n            config.reqGlEsVersion = GL_ES_VERSION;\n        }\n        return config;\n    }\n\n    @Nullable\n    public BackgroundActivityStartCallback getBackgroundActivityStartCallback() {\n        return mBackgroundActivityStartCallback;\n    }\n\n    private void start() {\n        LocalServices.addService(ActivityTaskManagerInternal.class, mInternal);\n    }\n\n    public static final class Lifecycle extends SystemService {\n        private final ActivityTaskManagerService mService;\n\n        public Lifecycle(Context context) {\n            super(context);\n            mService = new ActivityTaskManagerService(context);\n        }\n\n        @Override\n        public void onStart() {\n            publishBinderService(Context.ACTIVITY_TASK_SERVICE, mService);\n            mService.start();\n        }\n\n        @Override\n        public void onUserUnlocked(@NonNull TargetUser user) {\n            synchronized (mService.getGlobalLock()) {\n                mService.mTaskSupervisor.onUserUnlocked(user.getUserIdentifier());\n            }\n        }\n\n        @Override\n        public void onUserStopped(@NonNull TargetUser user) {\n            synchronized (mService.getGlobalLock()) {\n                mService.mTaskSupervisor.mLaunchParamsPersister\n                        .onCleanupUser(user.getUserIdentifier());\n            }\n        }\n\n        public ActivityTaskManagerService getService() {\n            return mService;\n        }\n    }\n\n    @Override\n    public final int startActivity(IApplicationThread caller, String callingPackage,\n            String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,\n            String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo,\n            Bundle bOptions) {\n        return startActivityAsUser(caller, callingPackage, callingFeatureId, intent, resolvedType,\n                resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions,\n                UserHandle.getCallingUserId());\n    }\n\n    @Override\n    public final int startActivities(IApplicationThread caller, String callingPackage,\n            String callingFeatureId, Intent[] intents, String[] resolvedTypes, IBinder resultTo,\n            Bundle bOptions, int userId) {\n        assertPackageMatchesCallingUid(callingPackage);\n        final String reason = \"startActivities\";\n        enforceNotIsolatedCaller(reason);\n        userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, reason);\n        // TODO: Switch to user app stacks here.\n        return getActivityStartController().startActivities(caller, -1, 0, -1, callingPackage,\n                callingFeatureId, intents, resolvedTypes, resultTo,\n                SafeActivityOptions.fromBundle(bOptions), userId, reason,\n                null /* originatingPendingIntent */, false /* allowBackgroundActivityStart */);\n    }\n\n    @Override\n    public int startActivityAsUser(IApplicationThread caller, String callingPackage,\n            String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,\n            String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo,\n            Bundle bOptions, int userId) {\n        return startActivityAsUser(caller, callingPackage, callingFeatureId, intent, resolvedType,\n                resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, userId,\n                true /*validateIncomingUser*/);\n    }\n\n    private int startActivityAsUser(IApplicationThread caller, String callingPackage,\n            @Nullable String callingFeatureId, Intent intent, String resolvedType,\n            IBinder resultTo, String resultWho, int requestCode, int startFlags,\n            ProfilerInfo profilerInfo, Bundle bOptions, int userId, boolean validateIncomingUser) {\n        assertPackageMatchesCallingUid(callingPackage);\n        enforceNotIsolatedCaller(\"startActivityAsUser\");\n\n        userId = getActivityStartController().checkTargetUser(userId, validateIncomingUser,\n                Binder.getCallingPid(), Binder.getCallingUid(), \"startActivityAsUser\");\n\n        // TODO: Switch to user app stacks here.\n        return getActivityStartController().obtainStarter(intent, \"startActivityAsUser\")\n                .setCaller(caller)\n                .setCallingPackage(callingPackage)\n                .setCallingFeatureId(callingFeatureId)\n                .setResolvedType(resolvedType)\n                .setResultTo(resultTo)\n                .setResultWho(resultWho)\n                .setRequestCode(requestCode)\n                .setStartFlags(startFlags)\n                .setProfilerInfo(profilerInfo)\n                .setActivityOptions(bOptions)\n                .setUserId(userId)\n                .execute();\n\n    }\n\n    @Override\n    public int startActivityIntentSender(IApplicationThread caller, IIntentSender target,\n            IBinder allowlistToken, Intent fillInIntent, String resolvedType, IBinder resultTo,\n            String resultWho, int requestCode, int flagsMask, int flagsValues, Bundle bOptions) {\n        enforceNotIsolatedCaller(\"startActivityIntentSender\");\n        // Refuse possible leaked file descriptors\n        if (fillInIntent != null && fillInIntent.hasFileDescriptors()) {\n            throw new IllegalArgumentException(\"File descriptors passed in Intent\");\n        }\n\n        if (!(target instanceof PendingIntentRecord)) {\n            throw new IllegalArgumentException(\"Bad PendingIntent object\");\n        }\n\n        PendingIntentRecord pir = (PendingIntentRecord) target;\n\n        synchronized (mGlobalLock) {\n            // If this is coming from the currently resumed activity, it is\n            // effectively saying that app switches are allowed at this point.\n            final Task topFocusedRootTask = getTopDisplayFocusedRootTask();\n            if (topFocusedRootTask != null && topFocusedRootTask.getResumedActivity() != null\n                    && topFocusedRootTask.getResumedActivity().info.applicationInfo.uid\n                    == Binder.getCallingUid()) {\n                mAppSwitchesAllowed = true;\n            }\n        }\n        return pir.sendInner(0, fillInIntent, resolvedType, allowlistToken, null, null,\n                resultTo, resultWho, requestCode, flagsMask, flagsValues, bOptions);\n    }\n\n    @Override\n    public boolean startNextMatchingActivity(IBinder callingActivity, Intent intent,\n            Bundle bOptions) {\n        // Refuse possible leaked file descriptors\n        if (intent != null && intent.hasFileDescriptors()) {\n            throw new IllegalArgumentException(\"File descriptors passed in Intent\");\n        }\n        SafeActivityOptions options = SafeActivityOptions.fromBundle(bOptions);\n\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInRootTaskLocked(callingActivity);\n            if (r == null) {\n                SafeActivityOptions.abort(options);\n                return false;\n            }\n            if (!r.attachedToProcess()) {\n                // The caller is not running...  d'oh!\n                SafeActivityOptions.abort(options);\n                return false;\n            }\n            intent = new Intent(intent);\n            // The caller is not allowed to change the data.\n            intent.setDataAndType(r.intent.getData(), r.intent.getType());\n            // And we are resetting to find the next component...\n            intent.setComponent(null);\n\n            final boolean debug = ((intent.getFlags() & Intent.FLAG_DEBUG_LOG_RESOLUTION) != 0);\n\n            ActivityInfo aInfo = null;\n            try {\n                List<ResolveInfo> resolves =\n                        AppGlobals.getPackageManager().queryIntentActivities(\n                                intent, r.resolvedType,\n                                PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS,\n                                UserHandle.getCallingUserId()).getList();\n\n                // Look for the original activity in the list...\n                final int N = resolves != null ? resolves.size() : 0;\n                for (int i = 0; i < N; i++) {\n                    ResolveInfo rInfo = resolves.get(i);\n                    if (rInfo.activityInfo.packageName.equals(r.packageName)\n                            && rInfo.activityInfo.name.equals(r.info.name)) {\n                        // We found the current one...  the next matching is\n                        // after it.\n                        i++;\n                        if (i < N) {\n                            aInfo = resolves.get(i).activityInfo;\n                        }\n                        if (debug) {\n                            Slog.v(TAG, \"Next matching activity: found current \" + r.packageName\n                                    + \"/\" + r.info.name);\n                            Slog.v(TAG, \"Next matching activity: next is \" + ((aInfo == null)\n                                    ? \"null\" : aInfo.packageName + \"/\" + aInfo.name));\n                        }\n                        break;\n                    }\n                }\n            } catch (RemoteException e) {\n            }\n\n            if (aInfo == null) {\n                // Nobody who is next!\n                SafeActivityOptions.abort(options);\n                if (debug) Slog.d(TAG, \"Next matching activity: nothing found\");\n                return false;\n            }\n\n            intent.setComponent(new ComponentName(\n                    aInfo.applicationInfo.packageName, aInfo.name));\n            intent.setFlags(intent.getFlags() & ~(Intent.FLAG_ACTIVITY_FORWARD_RESULT\n                    | Intent.FLAG_ACTIVITY_CLEAR_TOP\n                    | Intent.FLAG_ACTIVITY_MULTIPLE_TASK\n                    | FLAG_ACTIVITY_NEW_TASK));\n\n            // Okay now we need to start the new activity, replacing the currently running activity.\n            // This is a little tricky because we want to start the new one as if the current one is\n            // finished, but not finish the current one first so that there is no flicker.\n            // And thus...\n            final boolean wasFinishing = r.finishing;\n            r.finishing = true;\n\n            // Propagate reply information over to the new activity.\n            final ActivityRecord resultTo = r.resultTo;\n            final String resultWho = r.resultWho;\n            final int requestCode = r.requestCode;\n            r.resultTo = null;\n            if (resultTo != null) {\n                resultTo.removeResultsLocked(r, resultWho, requestCode);\n            }\n\n            final long origId = Binder.clearCallingIdentity();\n            // TODO(b/64750076): Check if calling pid should really be -1.\n            final int res = getActivityStartController()\n                    .obtainStarter(intent, \"startNextMatchingActivity\")\n                    .setCaller(r.app.getThread())\n                    .setResolvedType(r.resolvedType)\n                    .setActivityInfo(aInfo)\n                    .setResultTo(resultTo != null ? resultTo.appToken : null)\n                    .setResultWho(resultWho)\n                    .setRequestCode(requestCode)\n                    .setCallingPid(-1)\n                    .setCallingUid(r.launchedFromUid)\n                    .setCallingPackage(r.launchedFromPackage)\n                    .setCallingFeatureId(r.launchedFromFeatureId)\n                    .setRealCallingPid(-1)\n                    .setRealCallingUid(r.launchedFromUid)\n                    .setActivityOptions(options)\n                    .execute();\n            Binder.restoreCallingIdentity(origId);\n\n            r.finishing = wasFinishing;\n            if (res != ActivityManager.START_SUCCESS) {\n                return false;\n            }\n            return true;\n        }\n    }\n\n    private void enforceCallerIsDream(String callerPackageName) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            if (!ActivityRecord.canLaunchDreamActivity(callerPackageName)) {\n                throw new SecurityException(\"The dream activity can be started only when the device\"\n                        + \" is dreaming and only by the active dream package.\");\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public boolean startDreamActivity(@NonNull Intent intent) {\n        assertPackageMatchesCallingUid(intent.getPackage());\n        enforceCallerIsDream(intent.getPackage());\n\n        final ActivityInfo a = new ActivityInfo();\n        a.theme = com.android.internal.R.style.Theme_Dream;\n        a.exported = true;\n        a.name = DreamActivity.class.getName();\n        a.enabled = true;\n        a.launchMode = ActivityInfo.LAUNCH_SINGLE_INSTANCE;\n        a.persistableMode = ActivityInfo.PERSIST_NEVER;\n        a.screenOrientation = ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;\n        a.colorMode = ActivityInfo.COLOR_MODE_DEFAULT;\n        a.flags |= ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;\n        a.resizeMode = RESIZE_MODE_UNRESIZEABLE;\n\n        final ActivityOptions options = ActivityOptions.makeBasic();\n        options.setLaunchActivityType(ACTIVITY_TYPE_DREAM);\n\n        synchronized (mGlobalLock) {\n            final WindowProcessController process = mProcessMap.getProcess(Binder.getCallingPid());\n\n            a.packageName = process.mInfo.packageName;\n            a.applicationInfo = process.mInfo;\n            a.processName = process.mInfo.processName;\n            a.uiOptions = process.mInfo.uiOptions;\n            a.taskAffinity = \"android:\" + a.packageName + \"/dream\";\n\n            final int callingUid = Binder.getCallingUid();\n            final int callingPid = Binder.getCallingPid();\n\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                getActivityStartController().obtainStarter(intent, \"dream\")\n                        .setCallingUid(callingUid)\n                        .setCallingPid(callingPid)\n                        .setCallingPackage(intent.getPackage())\n                        .setActivityInfo(a)\n                        .setActivityOptions(options.toBundle())\n                        // To start the dream from background, we need to start it from a persistent\n                        // system process. Here we set the real calling uid to the system server uid\n                        .setRealCallingUid(Binder.getCallingUid())\n                        .setAllowBackgroundActivityStart(true)\n                        .execute();\n                return true;\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public final WaitResult startActivityAndWait(IApplicationThread caller, String callingPackage,\n            String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,\n            String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo,\n            Bundle bOptions, int userId) {\n        assertPackageMatchesCallingUid(callingPackage);\n        final WaitResult res = new WaitResult();\n        enforceNotIsolatedCaller(\"startActivityAndWait\");\n        userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),\n                userId, \"startActivityAndWait\");\n        // TODO: Switch to user app stacks here.\n        getActivityStartController().obtainStarter(intent, \"startActivityAndWait\")\n                .setCaller(caller)\n                .setCallingPackage(callingPackage)\n                .setCallingFeatureId(callingFeatureId)\n                .setResolvedType(resolvedType)\n                .setResultTo(resultTo)\n                .setResultWho(resultWho)\n                .setRequestCode(requestCode)\n                .setStartFlags(startFlags)\n                .setActivityOptions(bOptions)\n                .setUserId(userId)\n                .setProfilerInfo(profilerInfo)\n                .setWaitResult(res)\n                .execute();\n        return res;\n    }\n\n    @Override\n    public final int startActivityWithConfig(IApplicationThread caller, String callingPackage,\n            String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,\n            String resultWho, int requestCode, int startFlags, Configuration config,\n            Bundle bOptions, int userId) {\n        assertPackageMatchesCallingUid(callingPackage);\n        enforceNotIsolatedCaller(\"startActivityWithConfig\");\n        userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,\n                \"startActivityWithConfig\");\n        // TODO: Switch to user app stacks here.\n        return getActivityStartController().obtainStarter(intent, \"startActivityWithConfig\")\n                .setCaller(caller)\n                .setCallingPackage(callingPackage)\n                .setCallingFeatureId(callingFeatureId)\n                .setResolvedType(resolvedType)\n                .setResultTo(resultTo)\n                .setResultWho(resultWho)\n                .setRequestCode(requestCode)\n                .setStartFlags(startFlags)\n                .setGlobalConfiguration(config)\n                .setActivityOptions(bOptions)\n                .setUserId(userId)\n                .execute();\n    }\n\n    @Override\n    public IBinder requestStartActivityPermissionToken(IBinder delegatorToken) {\n        int callingUid = Binder.getCallingUid();\n        if (UserHandle.getAppId(callingUid) != SYSTEM_UID) {\n            throw new SecurityException(\"Only the system process can request a permission token, \"\n                    + \"received request from uid: \" + callingUid);\n        }\n        IBinder permissionToken = new Binder();\n        synchronized (mGlobalLock) {\n            mStartActivitySources.put(permissionToken, delegatorToken);\n        }\n\n        Message expireMsg = PooledLambda.obtainMessage(\n                ActivityTaskManagerService::expireStartAsCallerTokenMsg, this, permissionToken);\n        mUiHandler.sendMessageDelayed(expireMsg, START_AS_CALLER_TOKEN_TIMEOUT_IMPL);\n\n        Message forgetMsg = PooledLambda.obtainMessage(\n                ActivityTaskManagerService::forgetStartAsCallerTokenMsg, this, permissionToken);\n        mUiHandler.sendMessageDelayed(forgetMsg, START_AS_CALLER_TOKEN_EXPIRED_TIMEOUT);\n\n        return permissionToken;\n    }\n\n    @Override\n    public final int startActivityAsCaller(IApplicationThread caller, String callingPackage,\n            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, IBinder permissionToken,\n            boolean ignoreTargetSecurity, int userId) {\n        // This is very dangerous -- it allows you to perform a start activity (including\n        // permission grants) as any app that may launch one of your own activities.  So we only\n        // allow this in two cases:\n        // 1)  The caller is an activity that is part of the core framework, and then only when it\n        //     is running as the system.\n        // 2)  The caller provides a valid permissionToken.  Permission tokens are one-time use and\n        //     can only be requested by a system activity, which may then delegate this call to\n        //     another app.\n        final ActivityRecord sourceRecord;\n        final int targetUid;\n        final String targetPackage;\n        final String targetFeatureId;\n        final boolean isResolver;\n        synchronized (mGlobalLock) {\n            if (resultTo == null) {\n                throw new SecurityException(\"Must be called from an activity\");\n            }\n            final IBinder sourceToken;\n            if (permissionToken != null) {\n                // To even attempt to use a permissionToken, an app must also have this signature\n                // permission.\n                mAmInternal.enforceCallingPermission(\n                        android.Manifest.permission.START_ACTIVITY_AS_CALLER,\n                        \"startActivityAsCaller\");\n                // If called with a permissionToken, we want the sourceRecord from the delegator\n                // activity that requested this token.\n                sourceToken = mStartActivitySources.remove(permissionToken);\n                if (sourceToken == null) {\n                    // Invalid permissionToken, check if it recently expired.\n                    if (mExpiredStartAsCallerTokens.contains(permissionToken)) {\n                        throw new SecurityException(\"Called with expired permission token: \"\n                                + permissionToken);\n                    } else {\n                        throw new SecurityException(\"Called with invalid permission token: \"\n                                + permissionToken);\n                    }\n                }\n            } else {\n                // This method was called directly by the source.\n                sourceToken = resultTo;\n            }\n\n            sourceRecord = mRootWindowContainer.isInAnyTask(sourceToken);\n            if (sourceRecord == null) {\n                throw new SecurityException(\"Called with bad activity token: \" + sourceToken);\n            }\n            if (sourceRecord.app == null) {\n                throw new SecurityException(\"Called without a process attached to activity\");\n            }\n\n            // Whether called directly or from a delegate, the source activity must be from the\n            // android package.\n            if (!sourceRecord.info.packageName.equals(\"android\")) {\n                throw new SecurityException(\"Must be called from an activity that is \"\n                        + \"declared in the android package\");\n            }\n\n            if (UserHandle.getAppId(sourceRecord.app.mUid) != SYSTEM_UID) {\n                // This is still okay, as long as this activity is running under the\n                // uid of the original calling activity.\n                if (sourceRecord.app.mUid != sourceRecord.launchedFromUid) {\n                    throw new SecurityException(\n                            \"Calling activity in uid \" + sourceRecord.app.mUid\n                                    + \" must be system uid or original calling uid \"\n                                    + sourceRecord.launchedFromUid);\n                }\n            }\n            if (ignoreTargetSecurity) {\n                if (intent.getComponent() == null) {\n                    throw new SecurityException(\n                            \"Component must be specified with ignoreTargetSecurity\");\n                }\n                if (intent.getSelector() != null) {\n                    throw new SecurityException(\n                            \"Selector not allowed with ignoreTargetSecurity\");\n                }\n            }\n            targetUid = sourceRecord.launchedFromUid;\n            targetPackage = sourceRecord.launchedFromPackage;\n            targetFeatureId = sourceRecord.launchedFromFeatureId;\n            isResolver = sourceRecord.isResolverOrChildActivity();\n        }\n\n        if (userId == UserHandle.USER_NULL) {\n            userId = UserHandle.getUserId(sourceRecord.app.mUid);\n        }\n\n        // TODO: Switch to user app stacks here.\n        try {\n            return getActivityStartController().obtainStarter(intent, \"startActivityAsCaller\")\n                    .setCallingUid(targetUid)\n                    .setCallingPackage(targetPackage)\n                    .setCallingFeatureId(targetFeatureId)\n                    .setResolvedType(resolvedType)\n                    .setResultTo(resultTo)\n                    .setResultWho(resultWho)\n                    .setRequestCode(requestCode)\n                    .setStartFlags(startFlags)\n                    .setActivityOptions(bOptions)\n                    .setUserId(userId)\n                    .setIgnoreTargetSecurity(ignoreTargetSecurity)\n                    .setFilterCallingUid(isResolver ? 0 /* system */ : targetUid)\n                    // The target may well be in the background, which would normally prevent it\n                    // from starting an activity. Here we definitely want the start to succeed.\n                    .setAllowBackgroundActivityStart(true)\n                    .execute();\n        } catch (SecurityException e) {\n            // XXX need to figure out how to propagate to original app.\n            // A SecurityException here is generally actually a fault of the original\n            // calling activity (such as a fairly granting permissions), so propagate it\n            // back to them.\n            /*\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"While launching\");\n            msg.append(intent.toString());\n            msg.append(\": \");\n            msg.append(e.getMessage());\n            */\n            throw e;\n        }\n    }\n\n    int handleIncomingUser(int callingPid, int callingUid, int userId, String name) {\n        return mAmInternal.handleIncomingUser(callingPid, callingUid, userId, false /* allowAll */,\n                ALLOW_NON_FULL, name, null /* callerPackage */);\n    }\n\n    @Override\n    public int startVoiceActivity(String callingPackage, String callingFeatureId, int callingPid,\n            int callingUid, Intent intent, String resolvedType, IVoiceInteractionSession session,\n            IVoiceInteractor interactor, int startFlags, ProfilerInfo profilerInfo,\n            Bundle bOptions, int userId) {\n        assertPackageMatchesCallingUid(callingPackage);\n        mAmInternal.enforceCallingPermission(BIND_VOICE_INTERACTION, \"startVoiceActivity()\");\n        if (session == null || interactor == null) {\n            throw new NullPointerException(\"null session or interactor\");\n        }\n        userId = handleIncomingUser(callingPid, callingUid, userId, \"startVoiceActivity\");\n        // TODO: Switch to user app stacks here.\n        return getActivityStartController().obtainStarter(intent, \"startVoiceActivity\")\n                .setCallingUid(callingUid)\n                .setCallingPackage(callingPackage)\n                .setCallingFeatureId(callingFeatureId)\n                .setResolvedType(resolvedType)\n                .setVoiceSession(session)\n                .setVoiceInteractor(interactor)\n                .setStartFlags(startFlags)\n                .setProfilerInfo(profilerInfo)\n                .setActivityOptions(bOptions)\n                .setUserId(userId)\n                .setAllowBackgroundActivityStart(true)\n                .execute();\n    }\n\n    @Override\n    public int startAssistantActivity(String callingPackage, @NonNull String callingFeatureId,\n            int callingPid, int callingUid, Intent intent, String resolvedType, Bundle bOptions,\n            int userId) {\n        assertPackageMatchesCallingUid(callingPackage);\n        mAmInternal.enforceCallingPermission(BIND_VOICE_INTERACTION, \"startAssistantActivity()\");\n        userId = handleIncomingUser(callingPid, callingUid, userId, \"startAssistantActivity\");\n\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            return getActivityStartController().obtainStarter(intent, \"startAssistantActivity\")\n                    .setCallingUid(callingUid)\n                    .setCallingPackage(callingPackage)\n                    .setCallingFeatureId(callingFeatureId)\n                    .setResolvedType(resolvedType)\n                    .setActivityOptions(bOptions)\n                    .setUserId(userId)\n                    .setAllowBackgroundActivityStart(true)\n                    .execute();\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    /**\n     * Start the recents activity to perform the recents animation.\n     *\n     * @param intent                 The intent to start the recents activity.\n     * @param eventTime              When the (touch) event is triggered to start recents activity.\n     * @param recentsAnimationRunner Pass {@code null} to only preload the activity.\n     */\n    @Override\n    public void startRecentsActivity(Intent intent, long eventTime,\n            @Nullable IRecentsAnimationRunner recentsAnimationRunner) {\n        enforceTaskPermission(\"startRecentsActivity()\");\n        final int callingPid = Binder.getCallingPid();\n        final int callingUid = Binder.getCallingUid();\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final ComponentName recentsComponent = mRecentTasks.getRecentsComponent();\n                final String recentsFeatureId = mRecentTasks.getRecentsComponentFeatureId();\n                final int recentsUid = mRecentTasks.getRecentsComponentUid();\n                final WindowProcessController caller = getProcessController(callingPid, callingUid);\n\n                // Start a new recents animation\n                final RecentsAnimation anim = new RecentsAnimation(this, mTaskSupervisor,\n                        getActivityStartController(), mWindowManager, intent, recentsComponent,\n                        recentsFeatureId, recentsUid, caller);\n                if (recentsAnimationRunner == null) {\n                    anim.preloadRecentsActivity();\n                } else {\n                    anim.startRecentsActivity(recentsAnimationRunner, eventTime);\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public final int startActivityFromRecents(int taskId, Bundle bOptions) {\n        mAmInternal.enforceCallingPermission(START_TASKS_FROM_RECENTS,\n                \"startActivityFromRecents()\");\n\n        final int callingPid = Binder.getCallingPid();\n        final int callingUid = Binder.getCallingUid();\n        final SafeActivityOptions safeOptions = SafeActivityOptions.fromBundle(bOptions);\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                return mTaskSupervisor.startActivityFromRecents(callingPid, callingUid, taskId,\n                        safeOptions);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    /**\n     * Public API to check if the client is allowed to start an activity on specified display.\n     *\n     * If the target display is private or virtual, some restrictions will apply.\n     *\n     * @param displayId    Target display id.\n     * @param intent       Intent used to launch the activity.\n     * @param resolvedType The MIME type of the intent.\n     * @param userId       The id of the user for whom the call is made.\n     * @return {@code true} if a call to start an activity on the target display should succeed and\n     * no {@link SecurityException} will be thrown, {@code false} otherwise.\n     */\n    @Override\n    public final boolean isActivityStartAllowedOnDisplay(int displayId, Intent intent,\n            String resolvedType, int userId) {\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        final long origId = Binder.clearCallingIdentity();\n\n        try {\n            // Collect information about the target of the Intent.\n            final ActivityInfo aInfo = resolveActivityInfoForIntent(intent, resolvedType, userId,\n                    callingUid);\n\n            synchronized (mGlobalLock) {\n                return mTaskSupervisor.canPlaceEntityOnDisplay(displayId, callingPid, callingUid,\n                        aInfo);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    ActivityInfo resolveActivityInfoForIntent(Intent intent, String resolvedType,\n            int userId, int callingUid) {\n        ActivityInfo aInfo = mTaskSupervisor.resolveActivity(intent, resolvedType,\n                0 /* startFlags */, null /* profilerInfo */, userId,\n                ActivityStarter.computeResolveFilterUid(callingUid, callingUid,\n                        UserHandle.USER_NULL));\n        return mAmInternal.getActivityInfoForUser(aInfo, userId);\n    }\n\n    @Override\n    public IActivityClientController getActivityClientController() {\n        return mActivityClientController;\n    }\n\n    void applyUpdateLockStateLocked(ActivityRecord r) {\n        // Modifications to the UpdateLock state are done on our handler, outside\n        // the activity manager's locks.  The new state is determined based on the\n        // state *now* of the relevant activity record.  The object is passed to\n        // the handler solely for logging detail, not to be consulted/modified.\n        final boolean nextState = r != null && r.immersive;\n        mH.post(() -> {\n            if (mUpdateLock.isHeld() != nextState) {\n                ProtoLog.d(WM_DEBUG_IMMERSIVE, \"Applying new update lock state '%s' for %s\",\n                        nextState, r);\n                if (nextState) {\n                    mUpdateLock.acquire();\n                } else {\n                    mUpdateLock.release();\n                }\n            }\n        });\n    }\n\n    @Override\n    public boolean isTopActivityImmersive() {\n        enforceNotIsolatedCaller(\"isTopActivityImmersive\");\n        synchronized (mGlobalLock) {\n            final Task topFocusedRootTask = getTopDisplayFocusedRootTask();\n            if (topFocusedRootTask == null) {\n                return false;\n            }\n\n            final ActivityRecord r = topFocusedRootTask.topRunningActivity();\n            return r != null && r.immersive;\n        }\n    }\n\n    @Override\n    public int getFrontActivityScreenCompatMode() {\n        enforceNotIsolatedCaller(\"getFrontActivityScreenCompatMode\");\n        synchronized (mGlobalLock) {\n            final Task rootTask = getTopDisplayFocusedRootTask();\n            final ActivityRecord r = rootTask != null ? rootTask.topRunningActivity() : null;\n            if (r == null) {\n                return ActivityManager.COMPAT_MODE_UNKNOWN;\n            }\n            return mCompatModePackages.computeCompatModeLocked(r.info.applicationInfo);\n        }\n    }\n\n    @Override\n    public void setFrontActivityScreenCompatMode(int mode) {\n        mAmInternal.enforceCallingPermission(android.Manifest.permission.SET_SCREEN_COMPATIBILITY,\n                \"setFrontActivityScreenCompatMode\");\n        ApplicationInfo ai;\n        synchronized (mGlobalLock) {\n            final Task rootTask = getTopDisplayFocusedRootTask();\n            final ActivityRecord r = rootTask != null ? rootTask.topRunningActivity() : null;\n            if (r == null) {\n                Slog.w(TAG, \"setFrontActivityScreenCompatMode failed: no top activity\");\n                return;\n            }\n            ai = r.info.applicationInfo;\n            mCompatModePackages.setPackageScreenCompatModeLocked(ai, mode);\n        }\n    }\n\n\n    @Override\n    public RootTaskInfo getFocusedRootTaskInfo() throws RemoteException {\n        enforceTaskPermission(\"getFocusedRootTaskInfo()\");\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                Task focusedRootTask = getTopDisplayFocusedRootTask();\n                if (focusedRootTask != null) {\n                    return mRootWindowContainer.getRootTaskInfo(focusedRootTask.mTaskId);\n                }\n                return null;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public void setFocusedRootTask(int taskId) {\n        enforceTaskPermission(\"setFocusedRootTask()\");\n        ProtoLog.d(WM_DEBUG_FOCUS, \"setFocusedRootTask: taskId=%d\", taskId);\n        final long callingId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final Task task = mRootWindowContainer.getRootTask(taskId);\n                if (task == null) {\n                    Slog.w(TAG, \"setFocusedRootTask: No task with id=\" + taskId);\n                    return;\n                }\n                final ActivityRecord r = task.topRunningActivity();\n                if (r != null && r.moveFocusableActivityToTop(\"setFocusedRootTask\")) {\n                    mRootWindowContainer.resumeFocusedTasksTopActivities();\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(callingId);\n        }\n    }\n\n    @Override\n    public void setFocusedTask(int taskId) {\n        enforceTaskPermission(\"setFocusedTask()\");\n        ProtoLog.d(WM_DEBUG_FOCUS, \"setFocusedTask: taskId=%d\", taskId);\n        final long callingId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final Task task = mRootWindowContainer.anyTaskForId(taskId,\n                        MATCH_ATTACHED_TASK_ONLY);\n                if (task == null) {\n                    return;\n                }\n                final ActivityRecord r = task.topRunningActivityLocked();\n                if (r != null && r.moveFocusableActivityToTop(\"setFocusedTask\")) {\n                    mRootWindowContainer.resumeFocusedTasksTopActivities();\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(callingId);\n        }\n    }\n\n    @Override\n    public boolean removeTask(int taskId) {\n        mAmInternal.enforceCallingPermission(REMOVE_TASKS, \"removeTask()\");\n        synchronized (mGlobalLock) {\n            final long ident = Binder.clearCallingIdentity();\n            try {\n                final Task task = mRootWindowContainer.anyTaskForId(taskId,\n                        MATCH_ATTACHED_TASK_OR_RECENT_TASKS);\n                if (task == null) {\n                    Slog.w(TAG, \"removeTask: No task remove with id=\" + taskId);\n                    return false;\n                }\n\n                if (task.isLeafTask()) {\n                    mTaskSupervisor.removeTask(task, true, REMOVE_FROM_RECENTS, \"remove-task\");\n                } else {\n                    mTaskSupervisor.removeRootTask(task);\n                }\n                return true;\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n    }\n\n    @Override\n    public void removeAllVisibleRecentTasks() {\n        mAmInternal.enforceCallingPermission(REMOVE_TASKS, \"removeAllVisibleRecentTasks()\");\n        synchronized (mGlobalLock) {\n            final long ident = Binder.clearCallingIdentity();\n            try {\n                getRecentTasks().removeAllVisibleTasks(mAmInternal.getCurrentUserId());\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n    }\n\n    @Override\n    public Rect getTaskBounds(int taskId) {\n        enforceTaskPermission(\"getTaskBounds()\");\n        final long ident = Binder.clearCallingIdentity();\n        Rect rect = new Rect();\n        try {\n            synchronized (mGlobalLock) {\n                final Task task = mRootWindowContainer.anyTaskForId(taskId,\n                        MATCH_ATTACHED_TASK_OR_RECENT_TASKS);\n                if (task == null) {\n                    Slog.w(TAG, \"getTaskBounds: taskId=\" + taskId + \" not found\");\n                    return rect;\n                }\n                if (task.getParent() != null) {\n                    rect.set(task.getBounds());\n                } else if (task.mLastNonFullscreenBounds != null) {\n                    rect.set(task.mLastNonFullscreenBounds);\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n        return rect;\n    }\n\n    @Override\n    public ActivityManager.TaskDescription getTaskDescription(int id) {\n        synchronized (mGlobalLock) {\n            enforceTaskPermission(\"getTaskDescription()\");\n            final Task tr = mRootWindowContainer.anyTaskForId(id,\n                    MATCH_ATTACHED_TASK_OR_RECENT_TASKS);\n            if (tr != null) {\n                return tr.getTaskDescription();\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Sets the locusId for a particular activity.\n     *\n     * @param locusId the locusId to set.\n     * @param appToken the ActivityRecord's appToken.\n     */\n    public void setLocusId(LocusId locusId, IBinder appToken) {\n        synchronized (mGlobalLock) {\n            final ActivityRecord r = ActivityRecord.isInRootTaskLocked(appToken);\n            if (r != null) {\n                r.setLocusId(locusId);\n            }\n        }\n    }\n\n    NeededUriGrants collectGrants(Intent intent, ActivityRecord target) {\n        if (target != null) {\n            return mUgmInternal.checkGrantUriPermissionFromIntent(intent,\n                    Binder.getCallingUid(), target.packageName, target.mUserId);\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public void unhandledBack() {\n        mAmInternal.enforceCallingPermission(android.Manifest.permission.FORCE_BACK,\n                \"unhandledBack()\");\n\n        synchronized (mGlobalLock) {\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                final Task topFocusedRootTask = getTopDisplayFocusedRootTask();\n                if (topFocusedRootTask != null) {\n                    topFocusedRootTask.unhandledBackLocked();\n                }\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    /**\n     * TODO: Add mController hook\n     */\n    @Override\n    public void moveTaskToFront(IApplicationThread appThread, String callingPackage, int taskId,\n            int flags, Bundle bOptions) {\n        mAmInternal.enforceCallingPermission(android.Manifest.permission.REORDER_TASKS,\n                \"moveTaskToFront()\");\n\n        ProtoLog.d(WM_DEBUG_TASKS, \"moveTaskToFront: moving taskId=%d\", taskId);\n        synchronized (mGlobalLock) {\n            moveTaskToFrontLocked(appThread, callingPackage, taskId, flags,\n                    SafeActivityOptions.fromBundle(bOptions));\n        }\n    }\n\n    void moveTaskToFrontLocked(@Nullable IApplicationThread appThread,\n            @Nullable String callingPackage, int taskId, int flags, SafeActivityOptions options) {\n        final int callingPid = Binder.getCallingPid();\n        final int callingUid = Binder.getCallingUid();\n        assertPackageMatchesCallingUid(callingPackage);\n\n        final long origId = Binder.clearCallingIdentity();\n        WindowProcessController callerApp = null;\n        if (appThread != null) {\n            callerApp = getProcessController(appThread);\n        }\n        final ActivityStarter starter = getActivityStartController().obtainStarter(\n                null /* intent */, \"moveTaskToFront\");\n        if (starter.shouldAbortBackgroundActivityStart(callingUid, callingPid, callingPackage, -1,\n                -1, callerApp, null, false, null, null)) {\n            if (!isBackgroundActivityStartsEnabled()) {\n                return;\n            }\n        }\n        try {\n            final Task task = mRootWindowContainer.anyTaskForId(taskId);\n            if (task == null) {\n                ProtoLog.d(WM_DEBUG_TASKS, \"Could not find task for id: %d\", taskId);\n                SafeActivityOptions.abort(options);\n                return;\n            }\n            if (getLockTaskController().isLockTaskModeViolation(task)) {\n                Slog.e(TAG, \"moveTaskToFront: Attempt to violate Lock Task Mode\");\n                SafeActivityOptions.abort(options);\n                return;\n            }\n            ActivityOptions realOptions = options != null\n                    ? options.getOptions(mTaskSupervisor)\n                    : null;\n            mTaskSupervisor.findTaskToMoveToFront(task, flags, realOptions, \"moveTaskToFront\",\n                    false /* forceNonResizable */);\n\n            final ActivityRecord topActivity = task.getTopNonFinishingActivity();\n            if (topActivity != null) {\n\n                // We are reshowing a task, use a starting window to hide the initial draw delay\n                // so the transition can start earlier.\n                topActivity.showStartingWindow(true /* taskSwitch */);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    /**\n     * Return true if callingUid is system, or packageName belongs to that callingUid.\n     */\n    private boolean isSameApp(int callingUid, @Nullable String packageName) {\n        try {\n            if (callingUid != 0 && callingUid != SYSTEM_UID) {\n                if (packageName == null) {\n                    return false;\n                }\n                final int uid = AppGlobals.getPackageManager().getPackageUid(packageName,\n                        PackageManager.MATCH_DEBUG_TRIAGED_MISSING,\n                        UserHandle.getUserId(callingUid));\n                return UserHandle.isSameApp(callingUid, uid);\n            }\n        } catch (RemoteException e) {\n            // Should not happen\n        }\n        return true;\n    }\n\n    /**\n     * Checks that the provided package name matches the current calling UID, throws a security\n     * exception if it doesn't.\n     */\n    void assertPackageMatchesCallingUid(@Nullable String packageName) {\n        final int callingUid = Binder.getCallingUid();\n        if (isSameApp(callingUid, packageName)) {\n            return;\n        }\n        final String msg = \"Permission Denial: package=\" + packageName\n                + \" does not belong to uid=\" + callingUid;\n        Slog.w(TAG, msg);\n        throw new SecurityException(msg);\n    }\n\n    /**\n     * Return true if app switching is allowed.\n     */\n    boolean getBalAppSwitchesAllowed() {\n        return mAppSwitchesAllowed;\n    }\n\n    /** Register an {@link AnrController} to control the ANR dialog behavior */\n    public void registerAnrController(AnrController controller) {\n        synchronized (mGlobalLock) {\n            mAnrController.add(controller);\n        }\n    }\n\n    /** Unregister an {@link AnrController} */\n    public void unregisterAnrController(AnrController controller) {\n        synchronized (mGlobalLock) {\n            mAnrController.remove(controller);\n        }\n    }\n\n    /**\n     * @return the controller with the max ANR delay from all registered\n     * {@link AnrController} instances\n     */\n    @Nullable\n    public AnrController getAnrController(ApplicationInfo info) {\n        if (info == null || info.packageName == null) {\n            return null;\n        }\n\n        final ArrayList<AnrController> controllers;\n        synchronized (mGlobalLock) {\n            controllers = new ArrayList<>(mAnrController);\n        }\n\n        final String packageName = info.packageName;\n        final int uid = info.uid;\n        long maxDelayMs = 0;\n        AnrController controllerWithMaxDelay = null;\n\n        for (AnrController controller : controllers) {\n            long delayMs = controller.getAnrDelayMillis(packageName, uid);\n            if (delayMs > 0 && delayMs > maxDelayMs) {\n                controllerWithMaxDelay = controller;\n                maxDelayMs = delayMs;\n            }\n        }\n\n        return controllerWithMaxDelay;\n    }\n\n    @Override\n    public void setActivityController(IActivityController controller, boolean imAMonkey) {\n        mAmInternal.enforceCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER,\n                \"setActivityController()\");\n        synchronized (mGlobalLock) {\n            mController = controller;\n            mControllerIsAMonkey = imAMonkey;\n            Watchdog.getInstance().setActivityController(controller);\n        }\n    }\n\n    public boolean isControllerAMonkey() {\n        synchronized (mGlobalLock) {\n            return mController != null && mControllerIsAMonkey;\n        }\n    }\n\n    /**\n     * Gets info of running tasks up to the given number.\n     *\n     * @param maxNum the maximum number of task info returned by this method. If the total number of\n     *               running tasks is larger than it then there is no guarantee which task will be\n     *               left out.\n     * @return a list of {@link ActivityManager.RunningTaskInfo} with up to {@code maxNum} items\n     */\n    public List<ActivityManager.RunningTaskInfo> getTasks(int maxNum) {\n        return getTasks(maxNum, false /* filterForVisibleRecents */, false /* keepIntentExtra */);\n    }\n\n    /**\n     * @param filterOnlyVisibleRecents whether to filter the tasks based on whether they would ever\n     *                                 be visible in the recent task list in systemui\n     */\n    @Override\n    public List<ActivityManager.RunningTaskInfo> getTasks(int maxNum,\n            boolean filterOnlyVisibleRecents, boolean keepIntentExtra) {\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n\n        int flags = filterOnlyVisibleRecents ? RunningTasks.FLAG_FILTER_ONLY_VISIBLE_RECENTS : 0;\n        flags |= (keepIntentExtra ? RunningTasks.FLAG_KEEP_INTENT_EXTRA : 0);\n        final boolean crossUser = isCrossUserAllowed(callingPid, callingUid);\n        flags |= (crossUser ? RunningTasks.FLAG_CROSS_USERS : 0);\n        final int[] profileIds = getUserManager().getProfileIds(\n                UserHandle.getUserId(callingUid), true);\n        ArraySet<Integer> callingProfileIds = new ArraySet<>();\n        for (int i = 0; i < profileIds.length; i++) {\n            callingProfileIds.add(profileIds[i]);\n        }\n        ArrayList<ActivityManager.RunningTaskInfo> list = new ArrayList<>();\n\n        synchronized (mGlobalLock) {\n            if (DEBUG_ALL) Slog.v(TAG, \"getTasks: max=\" + maxNum);\n\n            final boolean allowed = isGetTasksAllowed(\"getTasks\", callingPid, callingUid);\n            flags |= (allowed ? RunningTasks.FLAG_ALLOWED : 0);\n            mRootWindowContainer.getRunningTasks(\n                    maxNum, list, flags, callingUid, callingProfileIds);\n        }\n\n        return list;\n    }\n\n    @Override\n    public void moveTaskToRootTask(int taskId, int rootTaskId, boolean toTop) {\n        enforceTaskPermission(\"moveTaskToRootTask()\");\n        synchronized (mGlobalLock) {\n            final long ident = Binder.clearCallingIdentity();\n            try {\n                final Task task = mRootWindowContainer.anyTaskForId(taskId);\n                if (task == null) {\n                    Slog.w(TAG, \"moveTaskToRootTask: No task for id=\" + taskId);\n                    return;\n                }\n\n                ProtoLog.d(WM_DEBUG_TASKS, \"moveTaskToRootTask: moving task=%d to \"\n                        + \"rootTaskId=%d toTop=%b\", taskId, rootTaskId, toTop);\n\n                final Task rootTask = mRootWindowContainer.getRootTask(rootTaskId);\n                if (rootTask == null) {\n                    throw new IllegalStateException(\n                            \"moveTaskToRootTask: No rootTask for rootTaskId=\" + rootTaskId);\n                }\n                if (!rootTask.isActivityTypeStandardOrUndefined()) {\n                    throw new IllegalArgumentException(\"moveTaskToRootTask: Attempt to move task \"\n                            + taskId + \" to rootTask \" + rootTaskId);\n                }\n                task.reparent(rootTask, toTop, REPARENT_KEEP_ROOT_TASK_AT_FRONT, ANIMATE,\n                        !DEFER_RESUME, \"moveTaskToRootTask\");\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n    }\n\n    /**\n     * Removes root tasks in the input windowing modes from the system if they are of activity type\n     * ACTIVITY_TYPE_STANDARD or ACTIVITY_TYPE_UNDEFINED\n     */\n    @Override\n    public void removeRootTasksInWindowingModes(int[] windowingModes) {\n        enforceTaskPermission(\"removeRootTasksInWindowingModes()\");\n\n        synchronized (mGlobalLock) {\n            final long ident = Binder.clearCallingIdentity();\n            try {\n                mRootWindowContainer.removeRootTasksInWindowingModes(windowingModes);\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n    }\n\n    @Override\n    public void removeRootTasksWithActivityTypes(int[] activityTypes) {\n        enforceTaskPermission(\"removeRootTasksWithActivityTypes()\");\n\n        synchronized (mGlobalLock) {\n            final long ident = Binder.clearCallingIdentity();\n            try {\n                mRootWindowContainer.removeRootTasksWithActivityTypes(activityTypes);\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n    }\n\n    @Override\n    public ParceledListSlice<ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum, int flags,\n            int userId) {\n        final int callingUid = Binder.getCallingUid();\n        userId = handleIncomingUser(Binder.getCallingPid(), callingUid, userId, \"getRecentTasks\");\n        final boolean allowed = isGetTasksAllowed(\"getRecentTasks\", Binder.getCallingPid(),\n                callingUid);\n        synchronized (mGlobalLock) {\n            return mRecentTasks.getRecentTasks(maxNum, flags, allowed, userId, callingUid);\n        }\n    }\n\n    @Override\n    public List<RootTaskInfo> getAllRootTaskInfos() {\n        enforceTaskPermission(\"getAllRootTaskInfos()\");\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.getAllRootTaskInfos(INVALID_DISPLAY);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public RootTaskInfo getRootTaskInfo(int windowingMode, int activityType) {\n        enforceTaskPermission(\"getRootTaskInfo()\");\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.getRootTaskInfo(windowingMode, activityType);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public List<RootTaskInfo> getAllRootTaskInfosOnDisplay(int displayId) {\n        enforceTaskPermission(\"getAllRootTaskInfosOnDisplay()\");\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.getAllRootTaskInfos(displayId);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public RootTaskInfo getRootTaskInfoOnDisplay(int windowingMode, int activityType,\n            int displayId) {\n        enforceTaskPermission(\"getRootTaskInfoOnDisplay()\");\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.getRootTaskInfo(windowingMode, activityType, displayId);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public void cancelRecentsAnimation(boolean restoreHomeRootTaskPosition) {\n        enforceTaskPermission(\"cancelRecentsAnimation()\");\n        final long callingUid = Binder.getCallingUid();\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                // Cancel the recents animation synchronously (do not hold the WM lock)\n                mWindowManager.cancelRecentsAnimation(restoreHomeRootTaskPosition\n                        ? REORDER_MOVE_TO_ORIGINAL_POSITION\n                        : REORDER_KEEP_IN_PLACE, \"cancelRecentsAnimation/uid=\" + callingUid);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    @Override\n    public void startSystemLockTaskMode(int taskId) {\n        enforceTaskPermission(\"startSystemLockTaskMode\");\n        // This makes inner call to look as if it was initiated by system.\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final Task task = mRootWindowContainer.anyTaskForId(taskId,\n                        MATCH_ATTACHED_TASK_ONLY);\n                if (task == null) {\n                    return;\n                }\n\n                // When starting lock task mode the root task must be in front and focused\n                task.getRootTask().moveToFront(\"startSystemLockTaskMode\");\n                startLockTaskMode(task, true /* isSystemCaller */);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    /**\n     * This API should be called by SystemUI only when user perform certain action to dismiss\n     * lock task mode. We should only dismiss pinned lock task mode in this case.\n     */\n    @Override\n    public void stopSystemLockTaskMode() throws RemoteException {\n        enforceTaskPermission(\"stopSystemLockTaskMode\");\n        stopLockTaskModeInternal(null, true /* isSystemCaller */);\n    }\n\n    void startLockTaskMode(@Nullable Task task, boolean isSystemCaller) {\n        ProtoLog.w(WM_DEBUG_LOCKTASK, \"startLockTaskMode: %s\", task);\n        if (task == null || task.mLockTaskAuth == LOCK_TASK_AUTH_DONT_LOCK) {\n            return;\n        }\n\n        final Task rootTask = mRootWindowContainer.getTopDisplayFocusedRootTask();\n        if (rootTask == null || task != rootTask.getTopMostTask()) {\n            throw new IllegalArgumentException(\"Invalid task, not in foreground\");\n        }\n\n        // {@code isSystemCaller} is used to distinguish whether this request is initiated by the\n        // system or a specific app.\n        // * System-initiated requests will only start the pinned mode (screen pinning)\n        // * App-initiated requests\n        //   - will put the device in fully locked mode (LockTask), if the app is allowlisted\n        //   - will start the pinned mode, otherwise\n        final int callingUid = Binder.getCallingUid();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            // When a task is locked, dismiss the root pinned task if it exists\n            mRootWindowContainer.removeRootTasksInWindowingModes(WINDOWING_MODE_PINNED);\n\n            getLockTaskController().startLockTaskMode(task, isSystemCaller, callingUid);\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    void stopLockTaskModeInternal(@Nullable IBinder token, boolean isSystemCaller) {\n        final int callingUid = Binder.getCallingUid();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                Task task = null;\n                if (token != null) {\n                    final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n                    if (r == null) {\n                        return;\n                    }\n                    task = r.getTask();\n                }\n                getLockTaskController().stopLockTaskMode(task, isSystemCaller, callingUid);\n            }\n            // Launch in-call UI if a call is ongoing. This is necessary to allow stopping the lock\n            // task and jumping straight into a call in the case of emergency call back.\n            TelecomManager tm = (TelecomManager) mContext.getSystemService(Context.TELECOM_SERVICE);\n            if (tm != null) {\n                tm.showInCallScreen(false);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public void updateLockTaskPackages(int userId, String[] packages) {\n        final int callingUid = Binder.getCallingUid();\n        if (callingUid != 0 && callingUid != SYSTEM_UID) {\n            mAmInternal.enforceCallingPermission(Manifest.permission.UPDATE_LOCK_TASK_PACKAGES,\n                    \"updateLockTaskPackages()\");\n        }\n        synchronized (mGlobalLock) {\n            ProtoLog.w(WM_DEBUG_LOCKTASK, \"Allowlisting %d:%s\", userId, Arrays.toString(packages));\n            getLockTaskController().updateLockTaskPackages(userId, packages);\n        }\n    }\n\n    @Override\n    public boolean isInLockTaskMode() {\n        return getLockTaskModeState() != LOCK_TASK_MODE_NONE;\n    }\n\n    @Override\n    public int getLockTaskModeState() {\n        return getLockTaskController().getLockTaskModeState();\n    }\n\n    @Override\n    public List<IBinder> getAppTasks(String callingPackage) {\n        int callingUid = Binder.getCallingUid();\n        assertPackageMatchesCallingUid(callingPackage);\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                return mRecentTasks.getAppTasksList(callingUid, callingPackage);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public void finishVoiceTask(IVoiceInteractionSession session) {\n        synchronized (mGlobalLock) {\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                // TODO: VI Consider treating local voice interactions and voice tasks\n                // differently here\n                mRootWindowContainer.finishVoiceTask(session);\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n\n    }\n\n    @Override\n    public void reportAssistContextExtras(IBinder assistToken, Bundle extras,\n            AssistStructure structure, AssistContent content, Uri referrer) {\n        final PendingAssistExtras pae = (PendingAssistExtras) assistToken;\n        synchronized (pae) {\n            pae.result = extras;\n            pae.structure = structure;\n            pae.content = content;\n            if (referrer != null) {\n                pae.extras.putParcelable(Intent.EXTRA_REFERRER, referrer);\n            }\n            if (!pae.activity.isAttached()) {\n                // Skip directly because the caller activity may have been destroyed. If a caller\n                // is waiting for the assist data, it will be notified by timeout\n                // (see PendingAssistExtras#run()) and then pendingAssistExtrasTimedOut will clean\n                // up the request.\n                return;\n            }\n            if (structure != null) {\n                // Pre-fill the task/activity component for all assist data receivers\n                structure.setTaskId(pae.activity.getTask().mTaskId);\n                structure.setActivityComponent(pae.activity.mActivityComponent);\n                structure.setHomeActivity(pae.isHome);\n            }\n            pae.haveResult = true;\n            pae.notifyAll();\n            if (pae.intent == null && pae.receiver == null) {\n                // Caller is just waiting for the result.\n                return;\n            }\n        }\n        // We are now ready to launch the assist activity.\n        IAssistDataReceiver sendReceiver = null;\n        Bundle sendBundle = null;\n        synchronized (mGlobalLock) {\n            buildAssistBundleLocked(pae, extras);\n            boolean exists = mPendingAssistExtras.remove(pae);\n            mUiHandler.removeCallbacks(pae);\n            if (!exists) {\n                // Timed out.\n                return;\n            }\n\n            if ((sendReceiver = pae.receiver) != null) {\n                // Caller wants result sent back to them.\n                sendBundle = new Bundle();\n                sendBundle.putInt(ActivityTaskManagerInternal.ASSIST_TASK_ID,\n                        pae.activity.getTask().mTaskId);\n                sendBundle.putBinder(ActivityTaskManagerInternal.ASSIST_ACTIVITY_ID,\n                        pae.activity.assistToken);\n                sendBundle.putBundle(ASSIST_KEY_DATA, pae.extras);\n                sendBundle.putParcelable(ASSIST_KEY_STRUCTURE, pae.structure);\n                sendBundle.putParcelable(ASSIST_KEY_CONTENT, pae.content);\n                sendBundle.putBundle(ASSIST_KEY_RECEIVER_EXTRAS, pae.receiverExtras);\n            }\n        }\n        if (sendReceiver != null) {\n            try {\n                sendReceiver.onHandleAssistData(sendBundle);\n            } catch (RemoteException e) {\n            }\n            return;\n        }\n\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            pae.intent.replaceExtras(pae.extras);\n            pae.intent.setFlags(FLAG_ACTIVITY_NEW_TASK\n                    | Intent.FLAG_ACTIVITY_SINGLE_TOP\n                    | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n            mInternal.closeSystemDialogs(\"assist\");\n\n            try {\n                mContext.startActivityAsUser(pae.intent, new UserHandle(pae.userHandle));\n            } catch (ActivityNotFoundException e) {\n                Slog.w(TAG, \"No activity to handle assist action.\", e);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public int addAppTask(IBinder activityToken, Intent intent,\n            ActivityManager.TaskDescription description, Bitmap thumbnail) throws RemoteException {\n        final int callingUid = Binder.getCallingUid();\n        final long callingIdent = Binder.clearCallingIdentity();\n\n        try {\n            synchronized (mGlobalLock) {\n                ActivityRecord r = ActivityRecord.isInRootTaskLocked(activityToken);\n                if (r == null) {\n                    throw new IllegalArgumentException(\"Activity does not exist; token=\"\n                            + activityToken);\n                }\n                ComponentName comp = intent.getComponent();\n                if (comp == null) {\n                    throw new IllegalArgumentException(\"Intent \" + intent\n                            + \" must specify explicit component\");\n                }\n                if (thumbnail.getWidth() != mThumbnailWidth\n                        || thumbnail.getHeight() != mThumbnailHeight) {\n                    throw new IllegalArgumentException(\"Bad thumbnail size: got \"\n                            + thumbnail.getWidth() + \"x\" + thumbnail.getHeight() + \", require \"\n                            + mThumbnailWidth + \"x\" + mThumbnailHeight);\n                }\n                if (intent.getSelector() != null) {\n                    intent.setSelector(null);\n                }\n                if (intent.getSourceBounds() != null) {\n                    intent.setSourceBounds(null);\n                }\n                if ((intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_DOCUMENT) != 0) {\n                    if ((intent.getFlags() & Intent.FLAG_ACTIVITY_RETAIN_IN_RECENTS) == 0) {\n                        // The caller has added this as an auto-remove task...  that makes no\n                        // sense, so turn off auto-remove.\n                        intent.addFlags(Intent.FLAG_ACTIVITY_RETAIN_IN_RECENTS);\n                    }\n                }\n                final ActivityInfo ainfo = AppGlobals.getPackageManager().getActivityInfo(comp,\n                        STOCK_PM_FLAGS, UserHandle.getUserId(callingUid));\n                if (ainfo == null || ainfo.applicationInfo.uid != callingUid) {\n                    Slog.e(TAG, \"Can't add task for another application: target uid=\"\n                            + (ainfo == null ? Process.INVALID_UID : ainfo.applicationInfo.uid)\n                            + \", calling uid=\" + callingUid);\n                    return INVALID_TASK_ID;\n                }\n\n                final Task rootTask = r.getRootTask();\n                final Task task = new Task.Builder(this)\n                        .setWindowingMode(rootTask.getWindowingMode())\n                        .setActivityType(rootTask.getActivityType())\n                        .setActivityInfo(ainfo)\n                        .setIntent(intent)\n                        .setTaskId(rootTask.getDisplayArea().getNextRootTaskId())\n                        .build();\n\n                if (!mRecentTasks.addToBottom(task)) {\n                    // The app has too many tasks already and we can't add any more\n                    rootTask.removeChild(task, \"addAppTask\");\n                    return INVALID_TASK_ID;\n                }\n                task.getTaskDescription().copyFrom(description);\n\n                // TODO: Send the thumbnail to WM to store it.\n\n                return task.mTaskId;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(callingIdent);\n        }\n    }\n\n    @Override\n    public Point getAppTaskThumbnailSize() {\n        synchronized (mGlobalLock) {\n            return new Point(mThumbnailWidth, mThumbnailHeight);\n        }\n    }\n\n    @Override\n    public void setTaskResizeable(int taskId, int resizeableMode) {\n        synchronized (mGlobalLock) {\n            final Task task = mRootWindowContainer.anyTaskForId(\n                    taskId, MATCH_ATTACHED_TASK_OR_RECENT_TASKS);\n            if (task == null) {\n                Slog.w(TAG, \"setTaskResizeable: taskId=\" + taskId + \" not found\");\n                return;\n            }\n            task.setResizeMode(resizeableMode);\n        }\n    }\n\n    @Override\n    public boolean resizeTask(int taskId, Rect bounds, int resizeMode) {\n        enforceTaskPermission(\"resizeTask()\");\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final Task task = mRootWindowContainer.anyTaskForId(taskId,\n                        MATCH_ATTACHED_TASK_ONLY);\n                if (task == null) {\n                    Slog.w(TAG, \"resizeTask: taskId=\" + taskId + \" not found\");\n                    return false;\n                }\n                if (!task.getWindowConfiguration().canResizeTask()) {\n                    Slog.w(TAG, \"resizeTask not allowed on task=\" + task);\n                    return false;\n                }\n\n                // Reparent the task to the right root task if necessary\n                boolean preserveWindow = (resizeMode & RESIZE_MODE_PRESERVE_WINDOW) != 0;\n\n                // After reparenting (which only resizes the task to the root task bounds),\n                // resize the task to the actual bounds provided\n                return task.resize(bounds, resizeMode, preserveWindow);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public void releaseSomeActivities(IApplicationThread appInt) {\n        synchronized (mGlobalLock) {\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                final WindowProcessController app = getProcessController(appInt);\n                app.releaseSomeActivities(\"low-mem\");\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public void setLockScreenShown(boolean keyguardShowing, boolean aodShowing) {\n        if (checkCallingPermission(android.Manifest.permission.DEVICE_POWER)\n                != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"Requires permission \"\n                    + android.Manifest.permission.DEVICE_POWER);\n        }\n\n        synchronized (mGlobalLock) {\n            final long ident = Binder.clearCallingIdentity();\n            if (mKeyguardShown != keyguardShowing) {\n                mKeyguardShown = keyguardShowing;\n                final Message msg = PooledLambda.obtainMessage(\n                        ActivityManagerInternal::reportCurKeyguardUsageEvent, mAmInternal,\n                        keyguardShowing);\n                mH.sendMessage(msg);\n            }\n            try {\n                mKeyguardController.setKeyguardShown(keyguardShowing, aodShowing);\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n\n        mH.post(() -> {\n            for (int i = mScreenObservers.size() - 1; i >= 0; i--) {\n                mScreenObservers.get(i).onKeyguardStateChanged(keyguardShowing);\n            }\n        });\n    }\n\n    // The caller MUST NOT hold the global lock.\n    public void onScreenAwakeChanged(boolean isAwake) {\n        mH.post(() -> {\n            for (int i = mScreenObservers.size() - 1; i >= 0; i--) {\n                mScreenObservers.get(i).onAwakeStateChanged(isAwake);\n            }\n        });\n\n        if (isAwake) {\n            return;\n        }\n        // If the device is going to sleep, keep a higher priority temporarily for potential\n        // animation of system UI. Even if AOD is not enabled, it should be no harm.\n        final WindowProcessController proc;\n        synchronized (mGlobalLockWithoutBoost) {\n            final WindowState notificationShade = mRootWindowContainer.getDefaultDisplay()\n                    .getDisplayPolicy().getNotificationShade();\n            proc = notificationShade != null\n                    ? mProcessMap.getProcess(notificationShade.mSession.mPid) : null;\n        }\n        if (proc == null) {\n            return;\n        }\n        // Set to activity manager directly to make sure the state can be seen by the subsequent\n        // update of scheduling group.\n        proc.setRunningAnimationUnsafe();\n        mH.removeMessages(H.UPDATE_PROCESS_ANIMATING_STATE, proc);\n        mH.sendMessageDelayed(mH.obtainMessage(H.UPDATE_PROCESS_ANIMATING_STATE, proc),\n                DOZE_ANIMATING_STATE_RETAIN_TIME_MS);\n    }\n\n    @Override\n    public Bitmap getTaskDescriptionIcon(String filePath, int userId) {\n        userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),\n                userId, \"getTaskDescriptionIcon\");\n\n        final File passedIconFile = new File(filePath);\n        final File legitIconFile = new File(TaskPersister.getUserImagesDir(userId),\n                passedIconFile.getName());\n        if (!legitIconFile.getPath().equals(filePath)\n                || !filePath.contains(ActivityRecord.ACTIVITY_ICON_SUFFIX)) {\n            throw new IllegalArgumentException(\"Bad file path: \" + filePath\n                    + \" passed for userId \" + userId);\n        }\n        return mRecentTasks.getTaskDescriptionIcon(filePath);\n    }\n\n    @Override\n    public void moveRootTaskToDisplay(int taskId, int displayId) {\n        mAmInternal.enforceCallingPermission(INTERNAL_SYSTEM_WINDOW, \"moveRootTaskToDisplay()\");\n\n        synchronized (mGlobalLock) {\n            final long ident = Binder.clearCallingIdentity();\n            try {\n                ProtoLog.d(WM_DEBUG_TASKS, \"moveRootTaskToDisplay: moving taskId=%d to \"\n                        + \"displayId=%d\", taskId, displayId);\n                mRootWindowContainer.moveRootTaskToDisplay(taskId, displayId, ON_TOP);\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n    }\n\n    /** Sets the task stack listener that gets callbacks when a task stack changes. */\n    @Override\n    public void registerTaskStackListener(ITaskStackListener listener) {\n        enforceTaskPermission(\"registerTaskStackListener()\");\n        mTaskChangeNotificationController.registerTaskStackListener(listener);\n    }\n\n    /** Unregister a task stack listener so that it stops receiving callbacks. */\n    @Override\n    public void unregisterTaskStackListener(ITaskStackListener listener) {\n        enforceTaskPermission(\"unregisterTaskStackListener()\");\n        mTaskChangeNotificationController.unregisterTaskStackListener(listener);\n    }\n\n    @Override\n    public boolean requestAssistContextExtras(int requestType, IAssistDataReceiver receiver,\n            Bundle receiverExtras, IBinder activityToken, boolean checkActivityIsTop,\n            boolean newSessionId) {\n        return enqueueAssistContext(requestType, null, null, receiver, receiverExtras,\n                activityToken, checkActivityIsTop, newSessionId, UserHandle.getCallingUserId(),\n                null, PENDING_ASSIST_EXTRAS_LONG_TIMEOUT, 0) != null;\n    }\n\n    @Override\n    public boolean requestAssistDataForTask(IAssistDataReceiver receiver, int taskId,\n            String callingPackageName) {\n        mAmInternal.enforceCallingPermission(android.Manifest.permission.GET_TOP_ACTIVITY_INFO,\n                \"requestAssistDataForTask()\");\n        final long callingId = Binder.clearCallingIdentity();\n        LocalService.ActivityTokens tokens = null;\n        try {\n            tokens = mInternal.getTopActivityForTask(taskId);\n        } finally {\n            Binder.restoreCallingIdentity(callingId);\n        }\n        if (tokens == null) {\n            Log.e(TAG, \"Could not find activity for task \" + taskId);\n            return false;\n        }\n\n        final AssistDataReceiverProxy proxy =\n                new AssistDataReceiverProxy(receiver, callingPackageName);\n        Object lock = new Object();\n        AssistDataRequester requester = new AssistDataRequester(mContext, mWindowManager,\n                getAppOpsManager(), proxy, lock, AppOpsManager.OP_ASSIST_STRUCTURE,\n                AppOpsManager.OP_NONE);\n\n        List<IBinder> topActivityToken = new ArrayList<>();\n        topActivityToken.add(tokens.getActivityToken());\n        requester.requestAssistData(topActivityToken, true /* fetchData */,\n                false /* fetchScreenshot */, false /* fetchStructure */, true /* allowFetchData */,\n                false /* allowFetchScreenshot*/, true /* ignoreFocusCheck */,\n                Binder.getCallingUid(), callingPackageName);\n\n        return true;\n    }\n\n    @Override\n    public boolean requestAutofillData(IAssistDataReceiver receiver, Bundle receiverExtras,\n            IBinder activityToken, int flags) {\n        return enqueueAssistContext(ActivityManager.ASSIST_CONTEXT_AUTOFILL, null, null,\n                receiver, receiverExtras, activityToken, true, true, UserHandle.getCallingUserId(),\n                null, PENDING_AUTOFILL_ASSIST_STRUCTURE_TIMEOUT, flags) != null;\n    }\n\n    @Override\n    public Bundle getAssistContextExtras(int requestType) {\n        PendingAssistExtras pae = enqueueAssistContext(requestType, null, null, null,\n                null, null, true /* checkActivityIsTop */, true /* newSessionId */,\n                UserHandle.getCallingUserId(), null, PENDING_ASSIST_EXTRAS_TIMEOUT, 0);\n        if (pae == null) {\n            return null;\n        }\n        synchronized (pae) {\n            while (!pae.haveResult) {\n                try {\n                    pae.wait();\n                } catch (InterruptedException e) {\n                }\n            }\n        }\n        synchronized (mGlobalLock) {\n            buildAssistBundleLocked(pae, pae.result);\n            mPendingAssistExtras.remove(pae);\n            mUiHandler.removeCallbacks(pae);\n        }\n        return pae.extras;\n    }\n\n    /**\n     * Binder IPC calls go through the public entry point.\n     * This can be called with or without the global lock held.\n     */\n    private static int checkCallingPermission(String permission) {\n        return checkPermission(\n                permission, Binder.getCallingPid(), Binder.getCallingUid());\n    }\n\n    /**\n     * Returns true if the app can close system dialogs. Otherwise it either throws a {@link\n     * SecurityException} or returns false with a logcat message depending on whether the app\n     * targets SDK level {@link android.os.Build.VERSION_CODES#S} or not.\n     */\n    private boolean checkCanCloseSystemDialogs(int pid, int uid, @Nullable String packageName) {\n        final WindowProcessController process;\n        synchronized (mGlobalLock) {\n            process = mProcessMap.getProcess(pid);\n        }\n        if (packageName == null && process != null) {\n            // WindowProcessController.mInfo is final, so after the synchronized memory barrier\n            // above, process.mInfo can't change. As for reading mInfo.packageName,\n            // WindowProcessController doesn't own the ApplicationInfo object referenced by mInfo.\n            // ProcessRecord for example also holds a reference to that object, so protecting access\n            // to packageName with the WM lock would not be enough as we'd also need to synchronize\n            // on the AM lock if we are worried about races, but we can't synchronize on AM lock\n            // here. Hence, since this is only used for logging, we don't synchronize here.\n            packageName = process.mInfo.packageName;\n        }\n        String caller = \"(pid=\" + pid + \", uid=\" + uid + \")\";\n        if (packageName != null) {\n            caller = packageName + \" \" + caller;\n        }\n        if (!canCloseSystemDialogs(pid, uid)) {\n            // The app can't close system dialogs, throw only if it targets S+\n            if (CompatChanges.isChangeEnabled(LOCK_DOWN_CLOSE_SYSTEM_DIALOGS, uid)) {\n                throw new SecurityException(\n                        \"Permission Denial: \" + Intent.ACTION_CLOSE_SYSTEM_DIALOGS\n                                + \" broadcast from \" + caller + \" requires \"\n                                + Manifest.permission.BROADCAST_CLOSE_SYSTEM_DIALOGS + \".\");\n            } else if (CompatChanges.isChangeEnabled(DROP_CLOSE_SYSTEM_DIALOGS, uid)) {\n                Slog.e(TAG,\n                        \"Permission Denial: \" + Intent.ACTION_CLOSE_SYSTEM_DIALOGS\n                                + \" broadcast from \" + caller + \" requires \"\n                                + Manifest.permission.BROADCAST_CLOSE_SYSTEM_DIALOGS\n                                + \", dropping broadcast.\");\n                return false;\n            } else {\n                Slog.w(TAG, Intent.ACTION_CLOSE_SYSTEM_DIALOGS\n                        + \" broadcast from \" + caller + \" will require \"\n                        + Manifest.permission.BROADCAST_CLOSE_SYSTEM_DIALOGS\n                        + \" in future builds.\");\n                return true;\n            }\n        }\n        return true;\n    }\n\n    private boolean canCloseSystemDialogs(int pid, int uid) {\n        if (checkPermission(Manifest.permission.BROADCAST_CLOSE_SYSTEM_DIALOGS, pid, uid)\n                == PERMISSION_GRANTED) {\n            return true;\n        }\n        synchronized (mGlobalLock) {\n            // Check all the processes from the given uid, especially since for PendingIntents sent\n            // the pid equals -1\n            ArraySet<WindowProcessController> processes = mProcessMap.getProcesses(uid);\n            if (processes != null) {\n                for (int i = 0, n = processes.size(); i < n; i++) {\n                    WindowProcessController process = processes.valueAt(i);\n                    // Check if the instrumentation of the process has the permission. This covers\n                    // the usual test started from the shell (which has the permission) case. This\n                    // is needed for apps targeting SDK level < S but we are also allowing for\n                    // targetSdk S+ as a convenience to avoid breaking a bunch of existing tests and\n                    // asking them to adopt shell permissions to do this.\n                    int sourceUid = process.getInstrumentationSourceUid();\n                    if (process.isInstrumenting() && sourceUid != -1 && checkPermission(\n                            Manifest.permission.BROADCAST_CLOSE_SYSTEM_DIALOGS, -1, sourceUid)\n                            == PERMISSION_GRANTED) {\n                        return true;\n                    }\n                    // This is the notification trampoline use-case for example, where apps use\n                    // Intent.ACSD to close the shade prior to starting an activity.\n                    if (process.canCloseSystemDialogsByToken()) {\n                        return true;\n                    }\n                }\n            }\n            if (!CompatChanges.isChangeEnabled(LOCK_DOWN_CLOSE_SYSTEM_DIALOGS, uid)) {\n                // This covers the case where the app is displaying some UI on top of the\n                // notification shade and wants to start an activity. The app then sends the intent\n                // in order to move the notification shade out of the way and show the activity to\n                // the user. This is fine since the caller already has privilege to show a visible\n                // window on top of the notification shade, so it can already prevent the user from\n                // accessing the shade if it wants to. We only allow for targetSdk < S, for S+ we\n                // automatically collapse the shade on startActivity() for these apps.\n                // It's ok that the owner of the shade is not allowed *per this rule* because it has\n                // BROADCAST_CLOSE_SYSTEM_DIALOGS (SystemUI), so it would fall into that rule.\n                if (mRootWindowContainer.hasVisibleWindowAboveButDoesNotOwnNotificationShade(uid)) {\n                    return true;\n                }\n                // Accessibility services are allowed to send the intent unless they are targeting\n                // S+, in which case they should use {@link AccessibilityService\n                // #GLOBAL_ACTION_DISMISS_NOTIFICATION_SHADE} to dismiss the notification shade.\n                if (ArrayUtils.contains(mAccessibilityServiceUids, uid)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    static void enforceTaskPermission(String func) {\n        if (checkCallingPermission(MANAGE_ACTIVITY_TASKS) == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n\n        if (checkCallingPermission(MANAGE_ACTIVITY_STACKS) == PackageManager.PERMISSION_GRANTED) {\n            Slog.w(TAG, \"MANAGE_ACTIVITY_STACKS is deprecated, \"\n                    + \"please use alternative permission: MANAGE_ACTIVITY_TASKS\");\n            return;\n        }\n\n        String msg = \"Permission Denial: \" + func + \" from pid=\" + Binder.getCallingPid() + \", uid=\"\n                + Binder.getCallingUid() + \" requires android.permission.MANAGE_ACTIVITY_TASKS\";\n        Slog.w(TAG, msg);\n        throw new SecurityException(msg);\n    }\n\n    @VisibleForTesting\n    int checkGetTasksPermission(String permission, int pid, int uid) {\n        return checkPermission(permission, pid, uid);\n    }\n\n    static int checkPermission(String permission, int pid, int uid) {\n        if (permission == null) {\n            return PackageManager.PERMISSION_DENIED;\n        }\n        return checkComponentPermission(permission, pid, uid, -1, true);\n    }\n\n    public static int checkComponentPermission(String permission, int pid, int uid,\n            int owningUid, boolean exported) {\n        return ActivityManagerService.checkComponentPermission(\n                permission, pid, uid, owningUid, exported);\n    }\n\n    boolean isGetTasksAllowed(String caller, int callingPid, int callingUid) {\n        if (getRecentTasks().isCallerRecents(callingUid)) {\n            // Always allow the recents component to get tasks\n            return true;\n        }\n\n        boolean allowed = checkGetTasksPermission(android.Manifest.permission.REAL_GET_TASKS,\n                callingPid, callingUid) == PackageManager.PERMISSION_GRANTED;\n        if (!allowed) {\n            if (checkGetTasksPermission(android.Manifest.permission.GET_TASKS,\n                    callingPid, callingUid) == PackageManager.PERMISSION_GRANTED) {\n                // Temporary compatibility: some existing apps on the system image may\n                // still be requesting the old permission and not switched to the new\n                // one; if so, we'll still allow them full access.  This means we need\n                // to see if they are holding the old permission and are a system app.\n                try {\n                    if (AppGlobals.getPackageManager().isUidPrivileged(callingUid)) {\n                        allowed = true;\n                        ProtoLog.w(WM_DEBUG_TASKS,\n                                \"%s: caller %d is using old GET_TASKS but privileged; allowing\",\n                                caller, callingUid);\n                    }\n                } catch (RemoteException e) {\n                }\n            }\n            ProtoLog.w(WM_DEBUG_TASKS,\n                    \"%s: caller %d does not hold REAL_GET_TASKS; limiting output\", caller,\n                    callingUid);\n        }\n        return allowed;\n    }\n\n    boolean isCrossUserAllowed(int pid, int uid) {\n        return checkPermission(INTERACT_ACROSS_USERS, pid, uid) == PERMISSION_GRANTED\n                || checkPermission(INTERACT_ACROSS_USERS_FULL, pid, uid) == PERMISSION_GRANTED;\n    }\n\n    private PendingAssistExtras enqueueAssistContext(int requestType, Intent intent, String hint,\n            IAssistDataReceiver receiver, Bundle receiverExtras, IBinder activityToken,\n            boolean checkActivityIsTop, boolean newSessionId, int userHandle, Bundle args,\n            long timeout, int flags) {\n        mAmInternal.enforceCallingPermission(android.Manifest.permission.GET_TOP_ACTIVITY_INFO,\n                \"enqueueAssistContext()\");\n\n        synchronized (mGlobalLock) {\n            final Task rootTask = getTopDisplayFocusedRootTask();\n            ActivityRecord activity =\n                    rootTask != null ? rootTask.getTopNonFinishingActivity() : null;\n            if (activity == null) {\n                Slog.w(TAG, \"getAssistContextExtras failed: no top activity\");\n                return null;\n            }\n            if (!activity.attachedToProcess()) {\n                Slog.w(TAG, \"getAssistContextExtras failed: no process for \" + activity);\n                return null;\n            }\n            if (checkActivityIsTop) {\n                if (activityToken != null) {\n                    ActivityRecord caller = ActivityRecord.forTokenLocked(activityToken);\n                    if (activity != caller) {\n                        Slog.w(TAG, \"enqueueAssistContext failed: caller \" + caller\n                                + \" is not current top \" + activity);\n                        return null;\n                    }\n                }\n            } else {\n                activity = ActivityRecord.forTokenLocked(activityToken);\n                if (activity == null) {\n                    Slog.w(TAG, \"enqueueAssistContext failed: activity for token=\" + activityToken\n                            + \" couldn't be found\");\n                    return null;\n                }\n                if (!activity.attachedToProcess()) {\n                    Slog.w(TAG, \"enqueueAssistContext failed: no process for \" + activity);\n                    return null;\n                }\n            }\n\n            PendingAssistExtras pae;\n            Bundle extras = new Bundle();\n            if (args != null) {\n                extras.putAll(args);\n            }\n            extras.putString(Intent.EXTRA_ASSIST_PACKAGE, activity.packageName);\n            extras.putInt(Intent.EXTRA_ASSIST_UID, activity.app.mUid);\n\n            pae = new PendingAssistExtras(activity, extras, intent, hint, receiver, receiverExtras,\n                    userHandle);\n            pae.isHome = activity.isActivityTypeHome();\n\n            // Increment the sessionId if necessary\n            if (newSessionId) {\n                mViSessionId++;\n            }\n            try {\n                activity.app.getThread().requestAssistContextExtras(activity.appToken, pae,\n                        requestType, mViSessionId, flags);\n                mPendingAssistExtras.add(pae);\n                mUiHandler.postDelayed(pae, timeout);\n            } catch (RemoteException e) {\n                Slog.w(TAG, \"getAssistContextExtras failed: crash calling \" + activity);\n                return null;\n            }\n            return pae;\n        }\n    }\n\n    private void buildAssistBundleLocked(PendingAssistExtras pae, Bundle result) {\n        if (result != null) {\n            pae.extras.putBundle(Intent.EXTRA_ASSIST_CONTEXT, result);\n        }\n        if (pae.hint != null) {\n            pae.extras.putBoolean(pae.hint, true);\n        }\n    }\n\n    private void pendingAssistExtrasTimedOut(PendingAssistExtras pae) {\n        IAssistDataReceiver receiver;\n        synchronized (mGlobalLock) {\n            mPendingAssistExtras.remove(pae);\n            receiver = pae.receiver;\n        }\n        if (receiver != null) {\n            // Caller wants result sent back to them.\n            Bundle sendBundle = new Bundle();\n            // At least return the receiver extras\n            sendBundle.putBundle(ASSIST_KEY_RECEIVER_EXTRAS, pae.receiverExtras);\n            try {\n                pae.receiver.onHandleAssistData(sendBundle);\n            } catch (RemoteException e) {\n            }\n        }\n    }\n\n    public class PendingAssistExtras extends Binder implements Runnable {\n        public final ActivityRecord activity;\n        public boolean isHome;\n        public final Bundle extras;\n        public final Intent intent;\n        public final String hint;\n        public final IAssistDataReceiver receiver;\n        public final int userHandle;\n        public boolean haveResult = false;\n        public Bundle result = null;\n        public AssistStructure structure = null;\n        public AssistContent content = null;\n        public Bundle receiverExtras;\n\n        public PendingAssistExtras(ActivityRecord _activity, Bundle _extras, Intent _intent,\n                String _hint, IAssistDataReceiver _receiver, Bundle _receiverExtras,\n                int _userHandle) {\n            activity = _activity;\n            extras = _extras;\n            intent = _intent;\n            hint = _hint;\n            receiver = _receiver;\n            receiverExtras = _receiverExtras;\n            userHandle = _userHandle;\n        }\n\n        @Override\n        public void run() {\n            Slog.w(TAG, \"getAssistContextExtras failed: timeout retrieving from \" + activity);\n            synchronized (this) {\n                haveResult = true;\n                notifyAll();\n            }\n            pendingAssistExtrasTimedOut(this);\n        }\n    }\n\n    @Override\n    public boolean isAssistDataAllowedOnCurrentActivity() {\n        int userId;\n        synchronized (mGlobalLock) {\n            final Task focusedRootTask = getTopDisplayFocusedRootTask();\n            if (focusedRootTask == null || focusedRootTask.isActivityTypeAssistant()) {\n                return false;\n            }\n\n            final ActivityRecord activity = focusedRootTask.getTopNonFinishingActivity();\n            if (activity == null) {\n                return false;\n            }\n            userId = activity.mUserId;\n        }\n        return DevicePolicyCache.getInstance().isScreenCaptureAllowed(userId, false);\n    }\n\n    private void onLocalVoiceInteractionStartedLocked(IBinder activity,\n            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor) {\n        ActivityRecord activityToCallback = ActivityRecord.forTokenLocked(activity);\n        if (activityToCallback == null) return;\n        activityToCallback.setVoiceSessionLocked(voiceSession);\n\n        // Inform the activity\n        try {\n            activityToCallback.app.getThread().scheduleLocalVoiceInteractionStarted(activity,\n                    voiceInteractor);\n            final long token = Binder.clearCallingIdentity();\n            try {\n                startRunningVoiceLocked(voiceSession, activityToCallback.info.applicationInfo.uid);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            // TODO: VI Should we cache the activity so that it's easier to find later\n            // rather than scan through all the root tasks and activities?\n        } catch (RemoteException re) {\n            activityToCallback.clearVoiceSessionLocked();\n            // TODO: VI Should this terminate the voice session?\n        }\n    }\n\n    private void startRunningVoiceLocked(IVoiceInteractionSession session, int targetUid) {\n        Slog.d(TAG, \"<<<  startRunningVoiceLocked()\");\n        mVoiceWakeLock.setWorkSource(new WorkSource(targetUid));\n        if (mRunningVoice == null || mRunningVoice.asBinder() != session.asBinder()) {\n            boolean wasRunningVoice = mRunningVoice != null;\n            mRunningVoice = session;\n            if (!wasRunningVoice) {\n                mVoiceWakeLock.acquire();\n                updateSleepIfNeededLocked();\n            }\n        }\n    }\n\n    void finishRunningVoiceLocked() {\n        if (mRunningVoice != null) {\n            mRunningVoice = null;\n            mVoiceWakeLock.release();\n            updateSleepIfNeededLocked();\n        }\n    }\n\n    @Override\n    public void setVoiceKeepAwake(IVoiceInteractionSession session, boolean keepAwake) {\n        synchronized (mGlobalLock) {\n            if (mRunningVoice != null && mRunningVoice.asBinder() == session.asBinder()) {\n                if (keepAwake) {\n                    mVoiceWakeLock.acquire();\n                } else {\n                    mVoiceWakeLock.release();\n                }\n            }\n        }\n    }\n\n    @Override\n    public void keyguardGoingAway(int flags) {\n        enforceNotIsolatedCaller(\"keyguardGoingAway\");\n        final long token = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                mKeyguardController.keyguardGoingAway(flags);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public void suppressResizeConfigChanges(boolean suppress) throws RemoteException {\n        mAmInternal.enforceCallingPermission(MANAGE_ACTIVITY_TASKS,\n                \"suppressResizeConfigChanges()\");\n        synchronized (mGlobalLock) {\n            mSuppressResizeConfigChanges = suppress;\n        }\n    }\n\n    /**\n     * A splash screen view has copied, pass it to an activity.\n     *\n     * @param taskId Id of task to handle the material to reconstruct the view.\n     * @param parcelable Used to reconstruct the view, null means the surface is un-copyable.\n     * @hide\n     */\n    @Override\n    public void onSplashScreenViewCopyFinished(int taskId, SplashScreenViewParcelable parcelable)\n            throws RemoteException {\n        mAmInternal.enforceCallingPermission(MANAGE_ACTIVITY_TASKS,\n                \"copySplashScreenViewFinish()\");\n        synchronized (mGlobalLock) {\n            final Task task = mRootWindowContainer.anyTaskForId(taskId,\n                    MATCH_ATTACHED_TASK_ONLY);\n            if (task != null) {\n                final ActivityRecord r = task.getTopWaitSplashScreenActivity();\n                if (r != null) {\n                    r.onCopySplashScreenFinish(parcelable);\n                }\n            }\n        }\n    }\n\n    /**\n     * Puts the given activity in picture in picture mode if possible.\n     *\n     * @return true if the activity is now in picture-in-picture mode, or false if it could not\n     * enter picture-in-picture mode.\n     */\n    boolean enterPictureInPictureMode(@NonNull ActivityRecord r, PictureInPictureParams params) {\n        // If the activity is already in picture in picture mode, then just return early\n        if (r.inPinnedWindowingMode()) {\n            return true;\n        }\n\n        // Activity supports picture-in-picture, now check that we can enter PiP at this\n        // point, if it is\n        if (!r.checkEnterPictureInPictureState(\"enterPictureInPictureMode\",\n                false /* beforeStopping */)) {\n            return false;\n        }\n\n        final Runnable enterPipRunnable = () -> {\n            synchronized (mGlobalLock) {\n                if (r.getParent() == null) {\n                    Slog.e(TAG, \"Skip enterPictureInPictureMode, destroyed \" + r);\n                    return;\n                }\n                // Only update the saved args from the args that are set\n                r.setPictureInPictureParams(params);\n                final float aspectRatio = r.pictureInPictureArgs.getAspectRatio();\n                final List<RemoteAction> actions = r.pictureInPictureArgs.getActions();\n                mRootWindowContainer.moveActivityToPinnedRootTask(\n                        r, \"enterPictureInPictureMode\");\n                final Task rootTask = r.getRootTask();\n                rootTask.setPictureInPictureAspectRatio(aspectRatio);\n                rootTask.setPictureInPictureActions(actions);\n            }\n        };\n\n        if (isKeyguardLocked()) {\n            // If the keyguard is showing or occluded, then try and dismiss it before\n            // entering picture-in-picture (this will prompt the user to authenticate if the\n            // device is currently locked).\n            mActivityClientController.dismissKeyguard(r.appToken, new KeyguardDismissCallback() {\n                @Override\n                public void onDismissSucceeded() {\n                    mH.post(enterPipRunnable);\n                }\n            }, null /* message */);\n        } else {\n            // Enter picture in picture immediately otherwise\n            enterPipRunnable.run();\n        }\n        return true;\n    }\n\n    @Override\n    public void setSplitScreenResizing(boolean resizing) {\n        enforceTaskPermission(\"setSplitScreenResizing()\");\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                mTaskSupervisor.setSplitScreenResizing(resizing);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public IWindowOrganizerController getWindowOrganizerController() {\n        enforceTaskPermission(\"getWindowOrganizerController()\");\n        return mWindowOrganizerController;\n    }\n\n    /**\n     * Check that we have the features required for VR-related API calls, and throw an exception if\n     * not.\n     */\n    public void enforceSystemHasVrFeature() {\n        if (!mContext.getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE)) {\n            throw new UnsupportedOperationException(\"VR mode not supported on this device!\");\n        }\n    }\n\n    @Override\n    public boolean supportsLocalVoiceInteraction() {\n        return LocalServices.getService(VoiceInteractionManagerInternal.class)\n                .supportsLocalVoiceInteraction();\n    }\n\n    @Override\n    public boolean updateConfiguration(Configuration values) {\n        mAmInternal.enforceCallingPermission(CHANGE_CONFIGURATION, \"updateConfiguration()\");\n\n        synchronized (mGlobalLock) {\n            if (mWindowManager == null) {\n                Slog.w(TAG, \"Skip updateConfiguration because mWindowManager isn't set\");\n                return false;\n            }\n\n            if (values == null) {\n                // sentinel: fetch the current configuration from the window manager\n                values = mWindowManager.computeNewConfiguration(DEFAULT_DISPLAY);\n            }\n\n            mH.sendMessage(PooledLambda.obtainMessage(\n                    ActivityManagerInternal::updateOomLevelsForDisplay, mAmInternal,\n                    DEFAULT_DISPLAY));\n\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                if (values != null) {\n                    Settings.System.clearConfiguration(values);\n                }\n                updateConfigurationLocked(values, null, false, false /* persistent */,\n                        UserHandle.USER_NULL, false /* deferResume */,\n                        mTmpUpdateConfigurationResult);\n                return mTmpUpdateConfigurationResult.changes != 0;\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public void cancelTaskWindowTransition(int taskId) {\n        enforceTaskPermission(\"cancelTaskWindowTransition()\");\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final Task task = mRootWindowContainer.anyTaskForId(taskId,\n                        MATCH_ATTACHED_TASK_ONLY);\n                if (task == null) {\n                    Slog.w(TAG, \"cancelTaskWindowTransition: taskId=\" + taskId + \" not found\");\n                    return;\n                }\n                task.cancelTaskWindowTransition();\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public TaskSnapshot getTaskSnapshot(int taskId, boolean isLowResolution) {\n        mAmInternal.enforceCallingPermission(READ_FRAME_BUFFER, \"getTaskSnapshot()\");\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            return getTaskSnapshot(taskId, isLowResolution, true /* restoreFromDisk */);\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    private TaskSnapshot getTaskSnapshot(int taskId, boolean isLowResolution,\n            boolean restoreFromDisk) {\n        final Task task;\n        synchronized (mGlobalLock) {\n            task = mRootWindowContainer.anyTaskForId(taskId,\n                    MATCH_ATTACHED_TASK_OR_RECENT_TASKS);\n            if (task == null) {\n                Slog.w(TAG, \"getTaskSnapshot: taskId=\" + taskId + \" not found\");\n                return null;\n            }\n        }\n        // Don't call this while holding the lock as this operation might hit the disk.\n        return task.getSnapshot(isLowResolution, restoreFromDisk);\n    }\n\n    /** Return the user id of the last resumed activity. */\n    @Override\n    public @UserIdInt\n    int getLastResumedActivityUserId() {\n        mAmInternal.enforceCallingPermission(\n                Manifest.permission.INTERACT_ACROSS_USERS_FULL, \"getLastResumedActivityUserId()\");\n        synchronized (mGlobalLock) {\n            if (mLastResumedActivity == null) {\n                return getCurrentUserId();\n            }\n            return mLastResumedActivity.mUserId;\n        }\n    }\n\n    @Override\n    public void updateLockTaskFeatures(int userId, int flags) {\n        final int callingUid = Binder.getCallingUid();\n        if (callingUid != 0 && callingUid != SYSTEM_UID) {\n            mAmInternal.enforceCallingPermission(\n                    android.Manifest.permission.UPDATE_LOCK_TASK_PACKAGES,\n                    \"updateLockTaskFeatures()\");\n        }\n        synchronized (mGlobalLock) {\n            ProtoLog.w(WM_DEBUG_LOCKTASK, \"Allowing features %d:0x%s\",\n                    userId, Integer.toHexString(flags));\n            getLockTaskController().updateLockTaskFeatures(userId, flags);\n        }\n    }\n\n    @Override\n    public void registerRemoteAnimationForNextActivityStart(String packageName,\n            RemoteAnimationAdapter adapter) {\n        mAmInternal.enforceCallingPermission(CONTROL_REMOTE_APP_TRANSITION_ANIMATIONS,\n                \"registerRemoteAnimationForNextActivityStart\");\n        adapter.setCallingPidUid(Binder.getCallingPid(), Binder.getCallingUid());\n        synchronized (mGlobalLock) {\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                getActivityStartController().registerRemoteAnimationForNextActivityStart(\n                        packageName, adapter);\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public void registerRemoteAnimationsForDisplay(int displayId,\n            RemoteAnimationDefinition definition) {\n        mAmInternal.enforceCallingPermission(CONTROL_REMOTE_APP_TRANSITION_ANIMATIONS,\n                \"registerRemoteAnimations\");\n        definition.setCallingPidUid(Binder.getCallingPid(), Binder.getCallingUid());\n        synchronized (mGlobalLock) {\n            final DisplayContent display = mRootWindowContainer.getDisplayContent(displayId);\n            if (display == null) {\n                Slog.e(TAG, \"Couldn't find display with id: \" + displayId);\n                return;\n            }\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                display.registerRemoteAnimations(definition);\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    /** @see android.app.ActivityManager#alwaysShowUnsupportedCompileSdkWarning */\n    @Override\n    public void alwaysShowUnsupportedCompileSdkWarning(ComponentName activity) {\n        synchronized (mGlobalLock) {\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                mAppWarnings.alwaysShowUnsupportedCompileSdkWarning(activity);\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n    }\n\n    @Override\n    public void setVrThread(int tid) {\n        enforceSystemHasVrFeature();\n        synchronized (mGlobalLock) {\n            final int pid = Binder.getCallingPid();\n            final WindowProcessController wpc = mProcessMap.getProcess(pid);\n            mVrController.setVrThreadLocked(tid, pid, wpc);\n        }\n    }\n\n    @Override\n    public void setPersistentVrThread(int tid) {\n        if (checkCallingPermission(Manifest.permission.RESTRICTED_VR_ACCESS)\n                != PERMISSION_GRANTED) {\n            final String msg = \"Permission Denial: setPersistentVrThread() from pid=\"\n                    + Binder.getCallingPid()\n                    + \", uid=\" + Binder.getCallingUid()\n                    + \" requires \" + Manifest.permission.RESTRICTED_VR_ACCESS;\n            Slog.w(TAG, msg);\n            throw new SecurityException(msg);\n        }\n        enforceSystemHasVrFeature();\n        synchronized (mGlobalLock) {\n            final int pid = Binder.getCallingPid();\n            final WindowProcessController proc = mProcessMap.getProcess(pid);\n            mVrController.setPersistentVrThreadLocked(tid, pid, proc);\n        }\n    }\n\n    @Override\n    public void stopAppSwitches() {\n        mAmInternal.enforceCallingPermission(STOP_APP_SWITCHES, \"stopAppSwitches\");\n        synchronized (mGlobalLock) {\n            mAppSwitchesAllowed = false;\n            mLastStopAppSwitchesTime = SystemClock.uptimeMillis();\n        }\n    }\n\n    @Override\n    public void resumeAppSwitches() {\n        mAmInternal.enforceCallingPermission(STOP_APP_SWITCHES, \"resumeAppSwitches\");\n        synchronized (mGlobalLock) {\n            mAppSwitchesAllowed = true;\n        }\n    }\n\n    long getLastStopAppSwitchesTime() {\n        return mLastStopAppSwitchesTime;\n    }\n\n    /** @return whether the system should disable UI modes incompatible with VR mode. */\n    boolean shouldDisableNonVrUiLocked() {\n        return mVrController.shouldDisableNonVrUiLocked();\n    }\n\n    void applyUpdateVrModeLocked(ActivityRecord r) {\n        // VR apps are expected to run in a main display. If an app is turning on VR for\n        // itself, but isn't on the main display, then move it there before enabling VR Mode.\n        if (r.requestedVrComponent != null && r.getDisplayId() != DEFAULT_DISPLAY) {\n            Slog.i(TAG, \"Moving \" + r.shortComponentName + \" from display \" + r.getDisplayId()\n                    + \" to main display for VR\");\n            mRootWindowContainer.moveRootTaskToDisplay(\n                    r.getRootTaskId(), DEFAULT_DISPLAY, true /* toTop */);\n        }\n        mH.post(() -> {\n            if (!mVrController.onVrModeChanged(r)) {\n                return;\n            }\n            synchronized (mGlobalLock) {\n                final boolean disableNonVrUi = mVrController.shouldDisableNonVrUiLocked();\n                mWindowManager.disableNonVrUi(disableNonVrUi);\n                if (disableNonVrUi) {\n                    // If we are in a VR mode where Picture-in-Picture mode is unsupported,\n                    // then remove the root pinned task.\n                    mRootWindowContainer.removeRootTasksInWindowingModes(WINDOWING_MODE_PINNED);\n                }\n            }\n        });\n    }\n\n    @Override\n    public int getPackageScreenCompatMode(String packageName) {\n        enforceNotIsolatedCaller(\"getPackageScreenCompatMode\");\n        synchronized (mGlobalLock) {\n            return mCompatModePackages.getPackageScreenCompatModeLocked(packageName);\n        }\n    }\n\n    @Override\n    public void setPackageScreenCompatMode(String packageName, int mode) {\n        mAmInternal.enforceCallingPermission(android.Manifest.permission.SET_SCREEN_COMPATIBILITY,\n                \"setPackageScreenCompatMode\");\n        synchronized (mGlobalLock) {\n            mCompatModePackages.setPackageScreenCompatModeLocked(packageName, mode);\n        }\n    }\n\n    @Override\n    public boolean getPackageAskScreenCompat(String packageName) {\n        enforceNotIsolatedCaller(\"getPackageAskScreenCompat\");\n        synchronized (mGlobalLock) {\n            return mCompatModePackages.getPackageAskCompatModeLocked(packageName);\n        }\n    }\n\n    @Override\n    public void setPackageAskScreenCompat(String packageName, boolean ask) {\n        mAmInternal.enforceCallingPermission(android.Manifest.permission.SET_SCREEN_COMPATIBILITY,\n                \"setPackageAskScreenCompat\");\n        synchronized (mGlobalLock) {\n            mCompatModePackages.setPackageAskCompatModeLocked(packageName, ask);\n        }\n    }\n\n    public static String relaunchReasonToString(int relaunchReason) {\n        switch (relaunchReason) {\n            case RELAUNCH_REASON_WINDOWING_MODE_RESIZE:\n                return \"window_resize\";\n            case RELAUNCH_REASON_FREE_RESIZE:\n                return \"free_resize\";\n            default:\n                return null;\n        }\n    }\n\n    Task getTopDisplayFocusedRootTask() {\n        return mRootWindowContainer.getTopDisplayFocusedRootTask();\n    }\n\n    /** Pokes the task persister. */\n    void notifyTaskPersisterLocked(Task task, boolean flush) {\n        mRecentTasks.notifyTaskPersisterLocked(task, flush);\n    }\n\n    boolean isKeyguardLocked() {\n        return mKeyguardController.isKeyguardLocked();\n    }\n\n    /**\n     * Clears launch params for the given package.\n     *\n     * @param packageNames the names of the packages of which the launch params are to be cleared\n     */\n    @Override\n    public void clearLaunchParamsForPackages(List<String> packageNames) {\n        enforceTaskPermission(\"clearLaunchParamsForPackages\");\n        synchronized (mGlobalLock) {\n            for (int i = 0; i < packageNames.size(); ++i) {\n                mTaskSupervisor.mLaunchParamsPersister.removeRecordForPackage(packageNames.get(i));\n            }\n        }\n    }\n\n    @Override\n    public void onPictureInPictureStateChanged(PictureInPictureUiState pipState) {\n        enforceTaskPermission(\"onPictureInPictureStateChanged\");\n        final Task rootPinnedStask = mRootWindowContainer.getDefaultTaskDisplayArea()\n                .getRootPinnedTask();\n        if (rootPinnedStask != null && rootPinnedStask.getTopMostActivity() != null) {\n            mWindowManager.mAtmService.mActivityClientController.onPictureInPictureStateChanged(\n                    rootPinnedStask.getTopMostActivity(), pipState);\n        }\n    }\n\n    void dumpLastANRLocked(PrintWriter pw) {\n        pw.println(\"ACTIVITY MANAGER LAST ANR (dumpsys activity lastanr)\");\n        if (mLastANRState == null) {\n            pw.println(\"  <no ANR has occurred since boot>\");\n        } else {\n            pw.println(mLastANRState);\n        }\n    }\n\n    void dumpLastANRTracesLocked(PrintWriter pw) {\n        pw.println(\"ACTIVITY MANAGER LAST ANR TRACES (dumpsys activity lastanr-traces)\");\n\n        final File[] files = new File(ANR_TRACE_DIR).listFiles();\n        if (ArrayUtils.isEmpty(files)) {\n            pw.println(\"  <no ANR has occurred since boot>\");\n            return;\n        }\n        // Find the latest file.\n        File latest = null;\n        for (File f : files) {\n            if ((latest == null) || (latest.lastModified() < f.lastModified())) {\n                latest = f;\n            }\n        }\n        pw.print(\"File: \");\n        pw.print(latest.getName());\n        pw.println();\n        try (BufferedReader in = new BufferedReader(new FileReader(latest))) {\n            String line;\n            while ((line = in.readLine()) != null) {\n                pw.println(line);\n            }\n        } catch (IOException e) {\n            pw.print(\"Unable to read: \");\n            pw.print(e);\n            pw.println();\n        }\n    }\n\n    void dumpTopResumedActivityLocked(PrintWriter pw) {\n        pw.println(\"ACTIVITY MANAGER TOP-RESUMED (dumpsys activity top-resumed)\");\n        ActivityRecord topRecord = mRootWindowContainer.getTopResumedActivity();\n        if (topRecord != null) {\n            topRecord.dump(pw, \"\", true);\n        }\n    }\n\n    void dumpActivitiesLocked(FileDescriptor fd, PrintWriter pw, String[] args,\n            int opti, boolean dumpAll, boolean dumpClient, String dumpPackage) {\n        dumpActivitiesLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage,\n                \"ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)\");\n    }\n\n    void dumpActivitiesLocked(FileDescriptor fd, PrintWriter pw, String[] args,\n            int opti, boolean dumpAll, boolean dumpClient, String dumpPackage, String header) {\n        pw.println(header);\n\n        boolean printedAnything = mRootWindowContainer.dumpActivities(fd, pw, dumpAll, dumpClient,\n                dumpPackage);\n        boolean needSep = printedAnything;\n\n        boolean printed = ActivityTaskSupervisor.printThisActivity(pw,\n                mRootWindowContainer.getTopResumedActivity(), dumpPackage, needSep,\n                \"  ResumedActivity: \", null);\n        if (printed) {\n            printedAnything = true;\n            needSep = false;\n        }\n\n        if (dumpPackage == null) {\n            if (needSep) {\n                pw.println();\n            }\n            printedAnything = true;\n            mTaskSupervisor.dump(pw, \"  \");\n            mTaskOrganizerController.dump(pw, \"  \");\n            mVisibleActivityProcessTracker.dump(pw, \"  \");\n            mActiveUids.dump(pw, \"  \");\n        }\n\n        if (!printedAnything) {\n            pw.println(\"  (nothing)\");\n        }\n    }\n\n    void dumpActivityContainersLocked(PrintWriter pw) {\n        pw.println(\"ACTIVITY MANAGER CONTAINERS (dumpsys activity containers)\");\n        mRootWindowContainer.dumpChildrenNames(pw, \" \");\n        pw.println(\" \");\n    }\n\n    void dumpActivityStarterLocked(PrintWriter pw, String dumpPackage) {\n        pw.println(\"ACTIVITY MANAGER STARTER (dumpsys activity starter)\");\n        getActivityStartController().dump(pw, \"\", dumpPackage);\n    }\n\n    /**\n     * There are three things that cmd can be:\n     * - a flattened component name that matches an existing activity\n     * - the cmd arg isn't the flattened component name of an existing activity:\n     * dump all activity whose component contains the cmd as a substring\n     * - A hex number of the ActivityRecord object instance.\n     * <p>\n     * The caller should not hold lock when calling this method because it will wait for the\n     * activities to complete the dump.\n     *\n     * @param dumpVisibleRootTasksOnly dump activity with {@param name} only if in a visible root\n     *                                 task\n     * @param dumpFocusedRootTaskOnly  dump activity with {@param name} only if in the focused\n     *                                 root task\n     */\n    protected boolean dumpActivity(FileDescriptor fd, PrintWriter pw, String name, String[] args,\n            int opti, boolean dumpAll, boolean dumpVisibleRootTasksOnly,\n            boolean dumpFocusedRootTaskOnly) {\n        ArrayList<ActivityRecord> activities;\n\n        synchronized (mGlobalLock) {\n            activities = mRootWindowContainer.getDumpActivities(name, dumpVisibleRootTasksOnly,\n                    dumpFocusedRootTaskOnly);\n        }\n\n        if (activities.size() <= 0) {\n            return false;\n        }\n\n        String[] newArgs = new String[args.length - opti];\n        System.arraycopy(args, opti, newArgs, 0, args.length - opti);\n\n        Task lastTask = null;\n        boolean needSep = false;\n        for (int i = activities.size() - 1; i >= 0; i--) {\n            ActivityRecord r = activities.get(i);\n            if (needSep) {\n                pw.println();\n            }\n            needSep = true;\n            synchronized (mGlobalLock) {\n                final Task task = r.getTask();\n                if (lastTask != task) {\n                    lastTask = task;\n                    pw.print(\"TASK \");\n                    pw.print(lastTask.affinity);\n                    pw.print(\" id=\");\n                    pw.print(lastTask.mTaskId);\n                    pw.print(\" userId=\");\n                    pw.println(lastTask.mUserId);\n                    if (dumpAll) {\n                        lastTask.dump(pw, \"  \");\n                    }\n                }\n            }\n            dumpActivity(\"  \", fd, pw, activities.get(i), newArgs, dumpAll);\n        }\n        return true;\n    }\n\n    /**\n     * Invokes IApplicationThread.dumpActivity() on the thread of the specified activity if\n     * there is a thread associated with the activity.\n     */\n    private void dumpActivity(String prefix, FileDescriptor fd, PrintWriter pw,\n            final ActivityRecord r, String[] args, boolean dumpAll) {\n        String innerPrefix = prefix + \"  \";\n        IApplicationThread appThread = null;\n        synchronized (mGlobalLock) {\n            pw.print(prefix);\n            pw.print(\"ACTIVITY \");\n            pw.print(r.shortComponentName);\n            pw.print(\" \");\n            pw.print(Integer.toHexString(System.identityHashCode(r)));\n            pw.print(\" pid=\");\n            if (r.hasProcess()) {\n                pw.println(r.app.getPid());\n                appThread = r.app.getThread();\n            } else {\n                pw.println(\"(not running)\");\n            }\n            if (dumpAll) {\n                r.dump(pw, innerPrefix, true /* dumpAll */);\n            }\n        }\n        if (appThread != null) {\n            // flush anything that is already in the PrintWriter since the thread is going\n            // to write to the file descriptor directly\n            pw.flush();\n            try (TransferPipe tp = new TransferPipe()) {\n                appThread.dumpActivity(tp.getWriteFd(), r.appToken, innerPrefix, args);\n                tp.go(fd);\n            } catch (IOException e) {\n                pw.println(innerPrefix + \"Failure while dumping the activity: \" + e);\n            } catch (RemoteException e) {\n                pw.println(innerPrefix + \"Got a RemoteException while dumping the activity\");\n            }\n        }\n    }\n\n    private void writeSleepStateToProto(ProtoOutputStream proto, int wakeFullness,\n            boolean testPssMode) {\n        final long sleepToken = proto.start(ActivityManagerServiceDumpProcessesProto.SLEEP_STATUS);\n        proto.write(ActivityManagerServiceDumpProcessesProto.SleepStatus.WAKEFULNESS,\n                PowerManagerInternal.wakefulnessToProtoEnum(wakeFullness));\n        final int tokenSize = mRootWindowContainer.mSleepTokens.size();\n        for (int i = 0; i < tokenSize; i++) {\n            final RootWindowContainer.SleepToken st =\n                    mRootWindowContainer.mSleepTokens.valueAt(i);\n            proto.write(ActivityManagerServiceDumpProcessesProto.SleepStatus.SLEEP_TOKENS,\n                    st.toString());\n        }\n        proto.write(ActivityManagerServiceDumpProcessesProto.SleepStatus.SLEEPING, mSleeping);\n        proto.write(ActivityManagerServiceDumpProcessesProto.SleepStatus.SHUTTING_DOWN,\n                mShuttingDown);\n        proto.write(ActivityManagerServiceDumpProcessesProto.SleepStatus.TEST_PSS_MODE,\n                testPssMode);\n        proto.end(sleepToken);\n    }\n\n    int getCurrentUserId() {\n        return mAmInternal.getCurrentUserId();\n    }\n\n    static void enforceNotIsolatedCaller(String caller) {\n        if (UserHandle.isIsolated(Binder.getCallingUid())) {\n            throw new SecurityException(\"Isolated process not allowed to call \" + caller);\n        }\n    }\n\n    public Configuration getConfiguration() {\n        Configuration ci;\n        synchronized (mGlobalLock) {\n            ci = new Configuration(getGlobalConfigurationForCallingPid());\n            ci.userSetLocale = false;\n        }\n        return ci;\n    }\n\n    /**\n     * Current global configuration information. Contains general settings for the entire system,\n     * also corresponds to the merged configuration of the default display.\n     */\n    Configuration getGlobalConfiguration() {\n        // Return default configuration before mRootWindowContainer initialized, which happens\n        // while initializing process record for system, see {@link\n        // ActivityManagerService#setSystemProcess}.\n        return mRootWindowContainer != null ? mRootWindowContainer.getConfiguration()\n                : new Configuration();\n    }\n\n    boolean updateConfigurationLocked(Configuration values, ActivityRecord starting,\n            boolean initLocale) {\n        return updateConfigurationLocked(values, starting, initLocale, false /* deferResume */);\n    }\n\n    boolean updateConfigurationLocked(Configuration values, ActivityRecord starting,\n            boolean initLocale, boolean deferResume) {\n        // pass UserHandle.USER_NULL as userId because we don't persist configuration for any user\n        return updateConfigurationLocked(values, starting, initLocale, false /* persistent */,\n                UserHandle.USER_NULL, deferResume);\n    }\n\n    public void updatePersistentConfiguration(Configuration values, @UserIdInt int userId) {\n        final long origId = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                updateConfigurationLocked(values, null, false, true, userId,\n                        false /* deferResume */);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n\n    private boolean updateConfigurationLocked(Configuration values, ActivityRecord starting,\n            boolean initLocale, boolean persistent, int userId, boolean deferResume) {\n        return updateConfigurationLocked(values, starting, initLocale, persistent, userId,\n                deferResume, null /* result */);\n    }\n\n    /**\n     * Do either or both things: (1) change the current configuration, and (2)\n     * make sure the given activity is running with the (now) current\n     * configuration.  Returns true if the activity has been left running, or\n     * false if <var>starting</var> is being destroyed to match the new\n     * configuration.\n     *\n     * @param userId is only used when persistent parameter is set to true to persist configuration\n     *               for that particular user\n     */\n    boolean updateConfigurationLocked(Configuration values, ActivityRecord starting,\n            boolean initLocale, boolean persistent, int userId, boolean deferResume,\n            ActivityTaskManagerService.UpdateConfigurationResult result) {\n        int changes = 0;\n        boolean kept = true;\n\n        deferWindowLayout();\n        try {\n            if (values != null) {\n                changes = updateGlobalConfigurationLocked(values, initLocale, persistent, userId);\n            }\n\n            if (!deferResume) {\n                kept = ensureConfigAndVisibilityAfterUpdate(starting, changes);\n            }\n        } finally {\n            continueWindowLayout();\n        }\n\n        if (result != null) {\n            result.changes = changes;\n            result.activityRelaunched = !kept;\n        }\n        return kept;\n    }\n\n    /** Update default (global) configuration and notify listeners about changes. */\n    int updateGlobalConfigurationLocked(@NonNull Configuration values, boolean initLocale,\n            boolean persistent, int userId) {\n\n        mTempConfig.setTo(getGlobalConfiguration());\n        final int changes = mTempConfig.updateFrom(values);\n        if (changes == 0) {\n            return 0;\n        }\n\n        ProtoLog.i(WM_DEBUG_CONFIGURATION, \"Updating global configuration \"\n                + \"to: %s\", values);\n        writeConfigurationChanged(changes);\n        FrameworkStatsLog.write(FrameworkStatsLog.RESOURCE_CONFIGURATION_CHANGED,\n                values.colorMode,\n                values.densityDpi,\n                values.fontScale,\n                values.hardKeyboardHidden,\n                values.keyboard,\n                values.keyboardHidden,\n                values.mcc,\n                values.mnc,\n                values.navigation,\n                values.navigationHidden,\n                values.orientation,\n                values.screenHeightDp,\n                values.screenLayout,\n                values.screenWidthDp,\n                values.smallestScreenWidthDp,\n                values.touchscreen,\n                values.uiMode);\n\n\n        if (!initLocale && !values.getLocales().isEmpty() && values.userSetLocale) {\n            final LocaleList locales = values.getLocales();\n            int bestLocaleIndex = 0;\n            if (locales.size() > 1) {\n                if (mSupportedSystemLocales == null) {\n                    mSupportedSystemLocales = Resources.getSystem().getAssets().getLocales();\n                }\n                bestLocaleIndex = Math.max(0, locales.getFirstMatchIndex(mSupportedSystemLocales));\n            }\n            SystemProperties.set(\"persist.sys.locale\",\n                    locales.get(bestLocaleIndex).toLanguageTag());\n            LocaleList.setDefault(locales, bestLocaleIndex);\n\n            final Message m = PooledLambda.obtainMessage(\n                    ActivityTaskManagerService::sendLocaleToMountDaemonMsg, this,\n                    locales.get(bestLocaleIndex));\n            mH.sendMessage(m);\n        }\n\n        mTempConfig.seq = increaseConfigurationSeqLocked();\n\n        Slog.i(TAG, \"Config changes=\" + Integer.toHexString(changes) + \" \" + mTempConfig);\n        // TODO(multi-display): Update UsageEvents#Event to include displayId.\n        mUsageStatsInternal.reportConfigurationChange(mTempConfig, mAmInternal.getCurrentUserId());\n\n        // TODO: If our config changes, should we auto dismiss any currently showing dialogs?\n        updateShouldShowDialogsLocked(mTempConfig);\n\n        AttributeCache ac = AttributeCache.instance();\n        if (ac != null) {\n            ac.updateConfiguration(mTempConfig);\n        }\n\n        // Make sure all resources in our process are updated right now, so that anyone who is going\n        // to retrieve resource values after we return will be sure to get the new ones. This is\n        // especially important during boot, where the first config change needs to guarantee all\n        // resources have that config before following boot code is executed.\n        mSystemThread.applyConfigurationToResources(mTempConfig);\n\n        if (persistent && Settings.System.hasInterestingConfigurationChanges(changes)) {\n            final Message msg = PooledLambda.obtainMessage(\n                    ActivityTaskManagerService::sendPutConfigurationForUserMsg,\n                    this, userId, new Configuration(mTempConfig));\n            mH.sendMessage(msg);\n        }\n\n        SparseArray<WindowProcessController> pidMap = mProcessMap.getPidMap();\n        for (int i = pidMap.size() - 1; i >= 0; i--) {\n            final int pid = pidMap.keyAt(i);\n            final WindowProcessController app = pidMap.get(pid);\n            ProtoLog.v(WM_DEBUG_CONFIGURATION, \"Update process config of %s to new \"\n                    + \"config %s\", app.mName, mTempConfig);\n            app.onConfigurationChanged(mTempConfig);\n        }\n\n        final Message msg = PooledLambda.obtainMessage(\n                ActivityManagerInternal::broadcastGlobalConfigurationChanged,\n                mAmInternal, changes, initLocale);\n        mH.sendMessage(msg);\n\n        // Update stored global config and notify everyone about the change.\n        mRootWindowContainer.onConfigurationChanged(mTempConfig);\n\n        return changes;\n    }\n\n    private int increaseAssetConfigurationSeq() {\n        mGlobalAssetsSeq = Math.max(++mGlobalAssetsSeq, 1);\n        return mGlobalAssetsSeq;\n    }\n\n    /**\n     * Update the asset configuration and increase the assets sequence number.\n     * @param processes the processes that needs to update the asset configuration\n     */\n    public void updateAssetConfiguration(List<WindowProcessController> processes,\n            boolean updateFrameworkRes) {\n        synchronized (mGlobalLock) {\n            final int assetSeq = increaseAssetConfigurationSeq();\n\n            if (updateFrameworkRes) {\n                Configuration newConfig = new Configuration();\n                newConfig.assetsSeq = assetSeq;\n                updateConfiguration(newConfig);\n            }\n\n            // Always update the override of every process so the asset sequence of the process is\n            // always greater than or equal to the global configuration.\n            for (int i = processes.size() - 1; i >= 0; i--) {\n                final WindowProcessController wpc = processes.get(i);\n                wpc.updateAssetConfiguration(assetSeq);\n            }\n        }\n    }\n\n    void startLaunchPowerMode(@PowerModeReason int reason) {\n        if (mPowerManagerInternal == null) return;\n        mPowerManagerInternal.setPowerMode(Mode.LAUNCH, true);\n        mLaunchPowerModeReasons |= reason;\n    }\n\n    void endLaunchPowerMode(@PowerModeReason int reason) {\n        if (mPowerManagerInternal == null || mLaunchPowerModeReasons == 0) return;\n        mLaunchPowerModeReasons &= ~reason;\n        if (mLaunchPowerModeReasons == 0) {\n            mPowerManagerInternal.setPowerMode(Mode.LAUNCH, false);\n        }\n    }\n\n    /** @see WindowSurfacePlacer#deferLayout */\n    void deferWindowLayout() {\n        if (!mWindowManager.mWindowPlacerLocked.isLayoutDeferred()) {\n            // Reset the reasons at the first entrance because we only care about the changes in the\n            // deferred scope.\n            mLayoutReasons = 0;\n        }\n\n        mWindowManager.mWindowPlacerLocked.deferLayout();\n    }\n\n    /** @see WindowSurfacePlacer#continueLayout */\n    void continueWindowLayout() {\n        mWindowManager.mWindowPlacerLocked.continueLayout(mLayoutReasons != 0);\n        if (DEBUG_ALL && !mWindowManager.mWindowPlacerLocked.isLayoutDeferred()) {\n            Slog.i(TAG, \"continueWindowLayout reason=\" + mLayoutReasons);\n        }\n    }\n\n    /**\n     * If a reason is added between {@link #deferWindowLayout} and {@link #continueWindowLayout},\n     * it will make sure {@link WindowSurfacePlacer#performSurfacePlacement} is called when the last\n     * defer count is gone.\n     */\n    void addWindowLayoutReasons(@LayoutReason int reasons) {\n        mLayoutReasons |= reasons;\n    }\n\n    private void updateEventDispatchingLocked(boolean booted) {\n        mWindowManager.setEventDispatching(booted && !mShuttingDown);\n    }\n\n    private void sendPutConfigurationForUserMsg(int userId, Configuration config) {\n        final ContentResolver resolver = mContext.getContentResolver();\n        Settings.System.putConfigurationForUser(resolver, config, userId);\n    }\n\n    private void sendLocaleToMountDaemonMsg(Locale l) {\n        try {\n            IBinder service = ServiceManager.getService(\"mount\");\n            IStorageManager storageManager = IStorageManager.Stub.asInterface(service);\n            Log.d(TAG, \"Storing locale \" + l.toLanguageTag() + \" for decryption UI\");\n            storageManager.setField(StorageManager.SYSTEM_LOCALE_KEY, l.toLanguageTag());\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Error storing locale for decryption UI\", e);\n        }\n    }\n\n    private void expireStartAsCallerTokenMsg(IBinder permissionToken) {\n        mStartActivitySources.remove(permissionToken);\n        mExpiredStartAsCallerTokens.add(permissionToken);\n    }\n\n    private void forgetStartAsCallerTokenMsg(IBinder permissionToken) {\n        mExpiredStartAsCallerTokens.remove(permissionToken);\n    }\n\n    boolean isActivityStartsLoggingEnabled() {\n        return mAmInternal.isActivityStartsLoggingEnabled();\n    }\n\n    boolean isBackgroundActivityStartsEnabled() {\n        return mAmInternal.isBackgroundActivityStartsEnabled();\n    }\n\n    static long getInputDispatchingTimeoutMillisLocked(ActivityRecord r) {\n        if (r == null || !r.hasProcess()) {\n            return DEFAULT_DISPATCHING_TIMEOUT_MILLIS;\n        }\n        return getInputDispatchingTimeoutMillisLocked(r.app);\n    }\n\n    private static long getInputDispatchingTimeoutMillisLocked(WindowProcessController r) {\n        if (r == null) {\n            return DEFAULT_DISPATCHING_TIMEOUT_MILLIS;\n        }\n        return r.getInputDispatchingTimeoutMillis();\n    }\n\n    /**\n     * Decide based on the configuration whether we should show the ANR,\n     * crash, etc dialogs.  The idea is that if there is no affordance to\n     * press the on-screen buttons, or the user experience would be more\n     * greatly impacted than the crash itself, we shouldn't show the dialog.\n     *\n     * A thought: SystemUI might also want to get told about this, the Power\n     * dialog / global actions also might want different behaviors.\n     */\n    private void updateShouldShowDialogsLocked(Configuration config) {\n        final boolean inputMethodExists = !(config.keyboard == Configuration.KEYBOARD_NOKEYS\n                && config.touchscreen == Configuration.TOUCHSCREEN_NOTOUCH\n                && config.navigation == Configuration.NAVIGATION_NONAV);\n        final boolean hideDialogsSet = Settings.Global.getInt(mContext.getContentResolver(),\n                HIDE_ERROR_DIALOGS, 0) != 0;\n        mShowDialogs = inputMethodExists\n                && ActivityTaskManager.currentUiModeSupportsErrorDialogs(config)\n                && !hideDialogsSet;\n    }\n\n    private void updateFontScaleIfNeeded(@UserIdInt int userId) {\n        final float scaleFactor = Settings.System.getFloatForUser(mContext.getContentResolver(),\n                FONT_SCALE, 1.0f, userId);\n\n        synchronized (mGlobalLock) {\n            if (getGlobalConfiguration().fontScale == scaleFactor) {\n                return;\n            }\n\n            final Configuration configuration\n                    = mWindowManager.computeNewConfiguration(DEFAULT_DISPLAY);\n            configuration.fontScale = scaleFactor;\n            updatePersistentConfiguration(configuration, userId);\n        }\n    }\n\n    private void updateFontWeightAdjustmentIfNeeded(@UserIdInt int userId) {\n        final int fontWeightAdjustment =\n                Settings.Secure.getIntForUser(\n                        mContext.getContentResolver(),\n                        Settings.Secure.FONT_WEIGHT_ADJUSTMENT,\n                        Configuration.FONT_WEIGHT_ADJUSTMENT_UNDEFINED,\n                        userId);\n\n        synchronized (mGlobalLock) {\n            if (getGlobalConfiguration().fontWeightAdjustment == fontWeightAdjustment) {\n                return;\n            }\n\n            final Configuration configuration =\n                    mWindowManager.computeNewConfiguration(DEFAULT_DISPLAY);\n            configuration.fontWeightAdjustment = fontWeightAdjustment;\n            updatePersistentConfiguration(configuration, userId);\n        }\n    }\n\n    // Actually is sleeping or shutting down or whatever else in the future\n    // is an inactive state.\n    boolean isSleepingOrShuttingDownLocked() {\n        return isSleepingLocked() || mShuttingDown;\n    }\n\n    boolean isSleepingLocked() {\n        return mSleeping;\n    }\n\n    /** Update AMS states when an activity is resumed. */\n    void setResumedActivityUncheckLocked(ActivityRecord r, String reason) {\n        final Task task = r.getTask();\n        if (task.isActivityTypeStandard()) {\n            if (mCurAppTimeTracker != r.appTimeTracker) {\n                // We are switching app tracking.  Complete the current one.\n                if (mCurAppTimeTracker != null) {\n                    mCurAppTimeTracker.stop();\n                    mH.obtainMessage(\n                            REPORT_TIME_TRACKER_MSG, mCurAppTimeTracker).sendToTarget();\n                    mRootWindowContainer.clearOtherAppTimeTrackers(r.appTimeTracker);\n                    mCurAppTimeTracker = null;\n                }\n                if (r.appTimeTracker != null) {\n                    mCurAppTimeTracker = r.appTimeTracker;\n                    startTimeTrackingFocusedActivityLocked();\n                }\n            } else {\n                startTimeTrackingFocusedActivityLocked();\n            }\n        } else {\n            r.appTimeTracker = null;\n        }\n        // TODO: VI Maybe r.task.voiceInteractor || r.voiceInteractor != null\n        // TODO: Probably not, because we don't want to resume voice on switching\n        // back to this activity\n        if (task.voiceInteractor != null) {\n            startRunningVoiceLocked(task.voiceSession, r.info.applicationInfo.uid);\n        } else {\n            finishRunningVoiceLocked();\n\n            if (mLastResumedActivity != null) {\n                final IVoiceInteractionSession session;\n\n                final Task lastResumedActivityTask = mLastResumedActivity.getTask();\n                if (lastResumedActivityTask != null\n                        && lastResumedActivityTask.voiceSession != null) {\n                    session = lastResumedActivityTask.voiceSession;\n                } else {\n                    session = mLastResumedActivity.voiceSession;\n                }\n\n                if (session != null) {\n                    // We had been in a voice interaction session, but now focused has\n                    // move to something different.  Just finish the session, we can't\n                    // return to it and retain the proper state and synchronization with\n                    // the voice interaction service.\n                    finishVoiceTask(session);\n                }\n            }\n        }\n\n        if (mLastResumedActivity != null && r.mUserId != mLastResumedActivity.mUserId) {\n            mAmInternal.sendForegroundProfileChanged(r.mUserId);\n        }\n        final Task prevTask = mLastResumedActivity != null ? mLastResumedActivity.getTask() : null;\n\n        updateResumedAppTrace(r);\n        mLastResumedActivity = r;\n\n        final boolean changed = r.mDisplayContent.setFocusedApp(r);\n        if (changed) {\n            mWindowManager.updateFocusedWindowLocked(UPDATE_FOCUS_NORMAL,\n                    true /*updateInputWindows*/);\n        }\n        if (prevTask == null || task != prevTask) {\n            if (prevTask != null) {\n                mTaskChangeNotificationController.notifyTaskFocusChanged(prevTask.mTaskId, false);\n            }\n            mTaskChangeNotificationController.notifyTaskFocusChanged(task.mTaskId, true);\n        }\n\n        applyUpdateLockStateLocked(r);\n        applyUpdateVrModeLocked(r);\n\n        EventLogTags.writeWmSetResumedActivity(\n                r == null ? -1 : r.mUserId,\n                r == null ? \"NULL\" : r.shortComponentName,\n                reason);\n    }\n\n    final class SleepTokenAcquirerImpl implements ActivityTaskManagerInternal.SleepTokenAcquirer {\n        private final String mTag;\n        private final SparseArray<RootWindowContainer.SleepToken> mSleepTokens =\n                new SparseArray<>();\n\n        SleepTokenAcquirerImpl(@NonNull String tag) {\n            mTag = tag;\n        }\n\n        @Override\n        public void acquire(int displayId) {\n            synchronized (mGlobalLock) {\n                if (!mSleepTokens.contains(displayId)) {\n                    mSleepTokens.append(displayId,\n                            mRootWindowContainer.createSleepToken(mTag, displayId));\n                    updateSleepIfNeededLocked();\n                }\n            }\n        }\n\n        @Override\n        public void release(int displayId) {\n            synchronized (mGlobalLock) {\n                final RootWindowContainer.SleepToken token = mSleepTokens.get(displayId);\n                if (token != null) {\n                    mRootWindowContainer.removeSleepToken(token);\n                    mSleepTokens.remove(displayId);\n                }\n            }\n        }\n    }\n\n    void updateSleepIfNeededLocked() {\n        final boolean shouldSleep = !mRootWindowContainer.hasAwakeDisplay();\n        final boolean wasSleeping = mSleeping;\n        boolean updateOomAdj = false;\n\n        if (!shouldSleep) {\n            // If wasSleeping is true, we need to wake up activity manager state from when\n            // we started sleeping. In either case, we need to apply the sleep tokens, which\n            // will wake up root tasks or put them to sleep as appropriate.\n            if (wasSleeping) {\n                mSleeping = false;\n                FrameworkStatsLog.write(FrameworkStatsLog.ACTIVITY_MANAGER_SLEEP_STATE_CHANGED,\n                        FrameworkStatsLog.ACTIVITY_MANAGER_SLEEP_STATE_CHANGED__STATE__AWAKE);\n                startTimeTrackingFocusedActivityLocked();\n                mTopProcessState = ActivityManager.PROCESS_STATE_TOP;\n                Slog.d(TAG, \"Top Process State changed to PROCESS_STATE_TOP\");\n                mTaskSupervisor.comeOutOfSleepIfNeededLocked();\n            }\n            mRootWindowContainer.applySleepTokens(true /* applyToRootTasks */);\n            if (wasSleeping) {\n                updateOomAdj = true;\n            }\n        } else if (!mSleeping && shouldSleep) {\n            mSleeping = true;\n            FrameworkStatsLog.write(FrameworkStatsLog.ACTIVITY_MANAGER_SLEEP_STATE_CHANGED,\n                    FrameworkStatsLog.ACTIVITY_MANAGER_SLEEP_STATE_CHANGED__STATE__ASLEEP);\n            if (mCurAppTimeTracker != null) {\n                mCurAppTimeTracker.stop();\n            }\n            mTopProcessState = ActivityManager.PROCESS_STATE_TOP_SLEEPING;\n            Slog.d(TAG, \"Top Process State changed to PROCESS_STATE_TOP_SLEEPING\");\n            mTaskSupervisor.goingToSleepLocked();\n            updateResumedAppTrace(null /* resumed */);\n            updateOomAdj = true;\n        }\n        if (updateOomAdj) {\n            updateOomAdj();\n        }\n    }\n\n    void updateOomAdj() {\n        mH.removeCallbacks(mUpdateOomAdjRunnable);\n        mH.post(mUpdateOomAdjRunnable);\n    }\n\n    void updateCpuStats() {\n        mH.post(mAmInternal::updateCpuStats);\n    }\n\n    void updateBatteryStats(ActivityRecord component, boolean resumed) {\n        final Message m = PooledLambda.obtainMessage(ActivityManagerInternal::updateBatteryStats,\n                mAmInternal, component.mActivityComponent, component.app.mUid, component.mUserId,\n                resumed);\n        mH.sendMessage(m);\n    }\n\n    void updateTopApp(ActivityRecord topResumedActivity) {\n        final ActivityRecord top = topResumedActivity != null ? topResumedActivity\n                // If there is no resumed activity, it will choose the pausing or focused activity.\n                : mRootWindowContainer.getTopResumedActivity();\n        mTopApp = top != null ? top.app : null;\n    }\n\n    void updateActivityUsageStats(ActivityRecord activity, int event) {\n        ComponentName taskRoot = null;\n        final Task task = activity.getTask();\n        if (task != null) {\n            final ActivityRecord rootActivity = task.getRootActivity();\n            if (rootActivity != null) {\n                taskRoot = rootActivity.mActivityComponent;\n            }\n        }\n\n        final Message m = PooledLambda.obtainMessage(\n                ActivityManagerInternal::updateActivityUsageStats, mAmInternal,\n                activity.mActivityComponent, activity.mUserId, event, activity.appToken, taskRoot);\n        mH.sendMessage(m);\n    }\n\n    void startProcessAsync(ActivityRecord activity, boolean knownToBeDead, boolean isTop,\n            String hostingType) {\n        try {\n            if (Trace.isTagEnabled(TRACE_TAG_WINDOW_MANAGER)) {\n                Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, \"dispatchingStartProcess:\"\n                        + activity.processName);\n            }\n            // Post message to start process to avoid possible deadlock of calling into AMS with the\n            // ATMS lock held.\n            final Message m = PooledLambda.obtainMessage(ActivityManagerInternal::startProcess,\n                    mAmInternal, activity.processName, activity.info.applicationInfo, knownToBeDead,\n                    isTop, hostingType, activity.intent.getComponent());\n            mH.sendMessage(m);\n        } finally {\n            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);\n        }\n    }\n\n    void setBooting(boolean booting) {\n        mAmInternal.setBooting(booting);\n    }\n\n    boolean isBooting() {\n        return mAmInternal.isBooting();\n    }\n\n    void setBooted(boolean booted) {\n        mAmInternal.setBooted(booted);\n    }\n\n    boolean isBooted() {\n        return mAmInternal.isBooted();\n    }\n\n    void postFinishBooting(boolean finishBooting, boolean enableScreen) {\n        mH.post(() -> {\n            if (finishBooting) {\n                mAmInternal.finishBooting();\n            }\n            if (enableScreen) {\n                mInternal.enableScreenAfterBoot(isBooted());\n            }\n        });\n    }\n\n    void setHeavyWeightProcess(ActivityRecord root) {\n        mHeavyWeightProcess = root.app;\n        final Message m = PooledLambda.obtainMessage(\n                ActivityTaskManagerService::postHeavyWeightProcessNotification, this,\n                root.app, root.intent, root.mUserId);\n        mH.sendMessage(m);\n    }\n\n    void clearHeavyWeightProcessIfEquals(WindowProcessController proc) {\n        if (mHeavyWeightProcess == null || mHeavyWeightProcess != proc) {\n            return;\n        }\n\n        mHeavyWeightProcess = null;\n        final Message m = PooledLambda.obtainMessage(\n                ActivityTaskManagerService::cancelHeavyWeightProcessNotification, this,\n                proc.mUserId);\n        mH.sendMessage(m);\n    }\n\n    private void cancelHeavyWeightProcessNotification(int userId) {\n        final INotificationManager inm = NotificationManager.getService();\n        if (inm == null) {\n            return;\n        }\n        try {\n            inm.cancelNotificationWithTag(\"android\", \"android\", null,\n                    SystemMessage.NOTE_HEAVY_WEIGHT_NOTIFICATION, userId);\n        } catch (RuntimeException e) {\n            Slog.w(TAG, \"Error canceling notification for service\", e);\n        } catch (RemoteException e) {\n        }\n\n    }\n\n    private void postHeavyWeightProcessNotification(\n            WindowProcessController proc, Intent intent, int userId) {\n        if (proc == null) {\n            return;\n        }\n\n        final INotificationManager inm = NotificationManager.getService();\n        if (inm == null) {\n            return;\n        }\n\n        try {\n            Context context = mContext.createPackageContext(proc.mInfo.packageName, 0);\n            String text = mContext.getString(R.string.heavy_weight_notification,\n                    context.getApplicationInfo().loadLabel(context.getPackageManager()));\n            Notification notification =\n                    new Notification.Builder(context,\n                            SystemNotificationChannels.HEAVY_WEIGHT_APP)\n                            .setSmallIcon(com.android.internal.R.drawable.stat_sys_adb)\n                            .setWhen(0)\n                            .setOngoing(true)\n                            .setTicker(text)\n                            .setColor(mContext.getColor(\n                                    com.android.internal.R.color.system_notification_accent_color))\n                            .setContentTitle(text)\n                            .setContentText(\n                                    mContext.getText(R.string.heavy_weight_notification_detail))\n                            .setContentIntent(PendingIntent.getActivityAsUser(mContext, 0,\n                                    intent, PendingIntent.FLAG_CANCEL_CURRENT\n                                    | PendingIntent.FLAG_IMMUTABLE, null,\n                                    new UserHandle(userId)))\n                            .build();\n            try {\n                inm.enqueueNotificationWithTag(\"android\", \"android\", null,\n                        SystemMessage.NOTE_HEAVY_WEIGHT_NOTIFICATION, notification, userId);\n            } catch (RuntimeException e) {\n                Slog.w(TAG, \"Error showing notification for heavy-weight app\", e);\n            } catch (RemoteException e) {\n            }\n        } catch (PackageManager.NameNotFoundException e) {\n            Slog.w(TAG, \"Unable to create context for heavy notification\", e);\n        }\n\n    }\n\n    IIntentSender getIntentSenderLocked(int type, String packageName, String featureId,\n            int callingUid, int userId, IBinder token, String resultWho, int requestCode,\n            Intent[] intents, String[] resolvedTypes, int flags, Bundle bOptions) {\n\n        ActivityRecord activity = null;\n        if (type == ActivityManager.INTENT_SENDER_ACTIVITY_RESULT) {\n            activity = ActivityRecord.isInRootTaskLocked(token);\n            if (activity == null) {\n                Slog.w(TAG, \"Failed createPendingResult: activity \" + token\n                        + \" not in any root task\");\n                return null;\n            }\n            if (activity.finishing) {\n                Slog.w(TAG, \"Failed createPendingResult: activity \" + activity + \" is finishing\");\n                return null;\n            }\n        }\n\n        final PendingIntentRecord rec = mPendingIntentController.getIntentSender(type, packageName,\n                featureId, callingUid, userId, token, resultWho, requestCode, intents,\n                resolvedTypes, flags, bOptions);\n        final boolean noCreate = (flags & PendingIntent.FLAG_NO_CREATE) != 0;\n        if (noCreate) {\n            return rec;\n        }\n        if (type == ActivityManager.INTENT_SENDER_ACTIVITY_RESULT) {\n            if (activity.pendingResults == null) {\n                activity.pendingResults = new HashSet<>();\n            }\n            activity.pendingResults.add(rec.ref);\n        }\n        return rec;\n    }\n\n    // TODO(b/111541062): Update app time tracking to make it aware of multiple resumed activities\n    private void startTimeTrackingFocusedActivityLocked() {\n        final ActivityRecord resumedActivity = mRootWindowContainer.getTopResumedActivity();\n        if (!mSleeping && mCurAppTimeTracker != null && resumedActivity != null) {\n            mCurAppTimeTracker.start(resumedActivity.packageName);\n        }\n    }\n\n    private void updateResumedAppTrace(@Nullable ActivityRecord resumed) {\n        if (mTracedResumedActivity != null) {\n            Trace.asyncTraceEnd(TRACE_TAG_WINDOW_MANAGER,\n                    constructResumedTraceName(mTracedResumedActivity.packageName), 0);\n        }\n        if (resumed != null) {\n            Trace.asyncTraceBegin(TRACE_TAG_WINDOW_MANAGER,\n                    constructResumedTraceName(resumed.packageName), 0);\n        }\n        mTracedResumedActivity = resumed;\n    }\n\n    private String constructResumedTraceName(String packageName) {\n        return \"focused app: \" + packageName;\n    }\n\n    /** Applies latest configuration and/or visibility updates if needed. */\n    boolean ensureConfigAndVisibilityAfterUpdate(ActivityRecord starting, int changes) {\n        boolean kept = true;\n        final Task mainRootTask = mRootWindowContainer.getTopDisplayFocusedRootTask();\n        // mainRootTask is null during startup.\n        if (mainRootTask != null) {\n            if (changes != 0 && starting == null) {\n                // If the configuration changed, and the caller is not already\n                // in the process of starting an activity, then find the top\n                // activity to check if its configuration needs to change.\n                starting = mainRootTask.topRunningActivity();\n            }\n\n            if (starting != null) {\n                kept = starting.ensureActivityConfiguration(changes,\n                        false /* preserveWindow */);\n                // And we need to make sure at this point that all other activities\n                // are made visible with the correct configuration.\n                mRootWindowContainer.ensureActivitiesVisible(starting, changes,\n                        !PRESERVE_WINDOWS);\n            }\n        }\n\n        return kept;\n    }\n\n    void scheduleAppGcsLocked() {\n        mH.post(() -> mAmInternal.scheduleAppGcs());\n    }\n\n    CompatibilityInfo compatibilityInfoForPackageLocked(ApplicationInfo ai) {\n        return mCompatModePackages.compatibilityInfoForPackageLocked(ai);\n    }\n\n    /**\n     * Returns the PackageManager. Used by classes hosted by {@link ActivityTaskManagerService}. The\n     * PackageManager could be unavailable at construction time and therefore needs to be accessed\n     * on demand.\n     */\n    IPackageManager getPackageManager() {\n        return AppGlobals.getPackageManager();\n    }\n\n    PackageManagerInternal getPackageManagerInternalLocked() {\n        if (mPmInternal == null) {\n            mPmInternal = LocalServices.getService(PackageManagerInternal.class);\n        }\n        return mPmInternal;\n    }\n\n    ComponentName getSysUiServiceComponentLocked() {\n        if (mSysUiServiceComponent == null) {\n            final PackageManagerInternal pm = getPackageManagerInternalLocked();\n            mSysUiServiceComponent = pm.getSystemUiServiceComponent();\n        }\n        return mSysUiServiceComponent;\n    }\n\n    PermissionPolicyInternal getPermissionPolicyInternal() {\n        if (mPermissionPolicyInternal == null) {\n            mPermissionPolicyInternal = LocalServices.getService(PermissionPolicyInternal.class);\n        }\n        return mPermissionPolicyInternal;\n    }\n\n    StatusBarManagerInternal getStatusBarManagerInternal() {\n        if (mStatusBarManagerInternal == null) {\n            mStatusBarManagerInternal = LocalServices.getService(StatusBarManagerInternal.class);\n        }\n        return mStatusBarManagerInternal;\n    }\n\n    AppWarnings getAppWarningsLocked() {\n        return mAppWarnings;\n    }\n\n    Intent getHomeIntent() {\n        Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null);\n        intent.setComponent(mTopComponent);\n        intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING);\n        if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) {\n            intent.addCategory(Intent.CATEGORY_HOME);\n        }\n        return intent;\n    }\n\n    /**\n     * Return the intent set with {@link Intent#CATEGORY_SECONDARY_HOME} to resolve secondary home\n     * activities.\n     *\n     * @param preferredPackage Specify a preferred package name, otherwise use the package name\n     *                         defined in config_secondaryHomePackage.\n     * @return the intent set with {@link Intent#CATEGORY_SECONDARY_HOME}\n     */\n    Intent getSecondaryHomeIntent(String preferredPackage) {\n        final Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null);\n        final boolean useSystemProvidedLauncher = mContext.getResources().getBoolean(\n                com.android.internal.R.bool.config_useSystemProvidedLauncherForSecondary);\n        if (preferredPackage == null || useSystemProvidedLauncher) {\n            // Using the package name stored in config if no preferred package name or forced.\n            final String secondaryHomePackage = mContext.getResources().getString(\n                    com.android.internal.R.string.config_secondaryHomePackage);\n            intent.setPackage(secondaryHomePackage);\n        } else {\n            intent.setPackage(preferredPackage);\n        }\n        intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING);\n        if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) {\n            intent.addCategory(Intent.CATEGORY_SECONDARY_HOME);\n        }\n        return intent;\n    }\n\n    ApplicationInfo getAppInfoForUser(ApplicationInfo info, int userId) {\n        if (info == null) return null;\n        ApplicationInfo newInfo = new ApplicationInfo(info);\n        newInfo.initForUser(userId);\n        return newInfo;\n    }\n\n    WindowProcessController getProcessController(String processName, int uid) {\n        if (uid == SYSTEM_UID) {\n            // The system gets to run in any process. If there are multiple processes with the same\n            // uid, just pick the first (this should never happen).\n            final SparseArray<WindowProcessController> procs =\n                    mProcessNames.getMap().get(processName);\n            if (procs == null) return null;\n            final int procCount = procs.size();\n            for (int i = 0; i < procCount; i++) {\n                final int procUid = procs.keyAt(i);\n                if (UserHandle.isApp(procUid) || !UserHandle.isSameUser(procUid, uid)) {\n                    // Don't use an app process or different user process for system component.\n                    continue;\n                }\n                return procs.valueAt(i);\n            }\n        }\n\n        return mProcessNames.get(processName, uid);\n    }\n\n    WindowProcessController getProcessController(IApplicationThread thread) {\n        if (thread == null) {\n            return null;\n        }\n\n        final IBinder threadBinder = thread.asBinder();\n        final ArrayMap<String, SparseArray<WindowProcessController>> pmap = mProcessNames.getMap();\n        for (int i = pmap.size() - 1; i >= 0; i--) {\n            final SparseArray<WindowProcessController> procs = pmap.valueAt(i);\n            for (int j = procs.size() - 1; j >= 0; j--) {\n                final WindowProcessController proc = procs.valueAt(j);\n                if (proc.hasThread() && proc.getThread().asBinder() == threadBinder) {\n                    return proc;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    WindowProcessController getProcessController(int pid, int uid) {\n        final WindowProcessController proc = mProcessMap.getProcess(pid);\n        if (proc == null) return null;\n        if (UserHandle.isApp(uid) && proc.mUid == uid) {\n            return proc;\n        }\n        return null;\n    }\n\n    /** A uid is considered to be foreground if it has a visible non-toast window. */\n    @HotPath(caller = HotPath.START_SERVICE)\n    boolean hasActiveVisibleWindow(int uid) {\n        if (mVisibleActivityProcessTracker.hasVisibleActivity(uid)) {\n            return true;\n        }\n        return mActiveUids.hasNonAppVisibleWindow(uid);\n    }\n\n    boolean isDeviceOwner(int uid) {\n        return uid >= 0 && mDeviceOwnerUid == uid;\n    }\n\n    void setDeviceOwnerUid(int uid) {\n        mDeviceOwnerUid = uid;\n    }\n\n    /**\n     * @return allowlist tag for a uid from mPendingTempAllowlist, null if not currently on\n     * the allowlist\n     */\n    String getPendingTempAllowlistTagForUidLocked(int uid) {\n        return mPendingTempAllowlist.get(uid);\n    }\n\n    void logAppTooSlow(WindowProcessController app, long startTime, String msg) {\n        if (true || Build.IS_USER) {\n            return;\n        }\n\n        StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();\n        StrictMode.allowThreadDiskWrites();\n        try {\n            File tracesDir = new File(\"/data/anr\");\n            File tracesFile = null;\n            try {\n                tracesFile = File.createTempFile(\"app_slow\", null, tracesDir);\n\n                StringBuilder sb = new StringBuilder();\n                String timeString =\n                        TimeMigrationUtils.formatMillisWithFixedFormat(System.currentTimeMillis());\n                sb.append(timeString);\n                sb.append(\": \");\n                TimeUtils.formatDuration(SystemClock.uptimeMillis() - startTime, sb);\n                sb.append(\" since \");\n                sb.append(msg);\n                FileOutputStream fos = new FileOutputStream(tracesFile);\n                fos.write(sb.toString().getBytes());\n                if (app == null) {\n                    fos.write(\"\\n*** No application process!\".getBytes());\n                }\n                fos.close();\n                FileUtils.setPermissions(tracesFile.getPath(), 0666, -1, -1); // -rw-rw-rw-\n            } catch (IOException e) {\n                Slog.w(TAG, \"Unable to prepare slow app traces file: \" + tracesFile, e);\n                return;\n            }\n\n            if (app != null && app.getPid() > 0) {\n                ArrayList<Integer> firstPids = new ArrayList<Integer>();\n                firstPids.add(app.getPid());\n                dumpStackTraces(tracesFile.getAbsolutePath(), firstPids, null, null);\n            }\n\n            File lastTracesFile = null;\n            File curTracesFile = null;\n            for (int i = 9; i >= 0; i--) {\n                String name = String.format(Locale.US, \"slow%02d.txt\", i);\n                curTracesFile = new File(tracesDir, name);\n                if (curTracesFile.exists()) {\n                    if (lastTracesFile != null) {\n                        curTracesFile.renameTo(lastTracesFile);\n                    } else {\n                        curTracesFile.delete();\n                    }\n                }\n                lastTracesFile = curTracesFile;\n            }\n            tracesFile.renameTo(curTracesFile);\n        } finally {\n            StrictMode.setThreadPolicy(oldPolicy);\n        }\n    }\n\n    boolean isAssociatedCompanionApp(int userId, int uid) {\n        final Set<Integer> allUids = mCompanionAppUidsMap.get(userId);\n        if (allUids == null) {\n            return false;\n        }\n        return allUids.contains(uid);\n    }\n\n    @Override\n    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)\n            throws RemoteException {\n        try {\n            return super.onTransact(code, data, reply, flags);\n        } catch (RuntimeException e) {\n            throw logAndRethrowRuntimeExceptionOnTransact(TAG, e);\n        }\n    }\n\n    /** Provides the full stack traces of non-security exception that occurs in onTransact. */\n    static RuntimeException logAndRethrowRuntimeExceptionOnTransact(String name,\n            RuntimeException e) {\n        if (!(e instanceof SecurityException)) {\n            Slog.w(TAG, name + \" onTransact aborts\"\n                    + \" UID:\" + Binder.getCallingUid()\n                    + \" PID:\" + Binder.getCallingPid(), e);\n        }\n        throw e;\n    }\n\n    /**\n     * Sets the corresponding {@link DisplayArea} information for the process global\n     * configuration. To be called when we need to show IME on a different {@link DisplayArea}\n     * or display.\n     *\n     * @param pid The process id associated with the IME window.\n     * @param imeContainer The DisplayArea that contains the IME window.\n     */\n    void onImeWindowSetOnDisplayArea(final int pid, @NonNull final DisplayArea imeContainer) {\n        // Don't update process-level configuration for Multi-Client IME process since other\n        // IMEs on other displays will also receive this configuration change due to IME\n        // services use the same application config/context.\n        if (InputMethodSystemProperty.MULTI_CLIENT_IME_ENABLED) return;\n\n        if (pid == MY_PID || pid < 0) {\n            ProtoLog.w(WM_DEBUG_CONFIGURATION,\n                    \"Trying to update display configuration for system/invalid process.\");\n            return;\n        }\n        final WindowProcessController process = mProcessMap.getProcess(pid);\n        if (process == null) {\n            ProtoLog.w(WM_DEBUG_CONFIGURATION, \"Trying to update display \"\n                    + \"configuration for invalid process, pid=%d\", pid);\n            return;\n        }\n        process.registerDisplayAreaConfigurationListener(imeContainer);\n    }\n\n    final class H extends Handler {\n        static final int REPORT_TIME_TRACKER_MSG = 1;\n        static final int UPDATE_PROCESS_ANIMATING_STATE = 2;\n\n        static final int FIRST_ACTIVITY_TASK_MSG = 100;\n        static final int FIRST_SUPERVISOR_TASK_MSG = 200;\n\n        H(Looper looper) {\n            super(looper);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case REPORT_TIME_TRACKER_MSG: {\n                    AppTimeTracker tracker = (AppTimeTracker) msg.obj;\n                    tracker.deliverResult(mContext);\n                }\n                break;\n                case UPDATE_PROCESS_ANIMATING_STATE: {\n                    final WindowProcessController proc = (WindowProcessController) msg.obj;\n                    synchronized (mGlobalLock) {\n                        proc.updateRunningRemoteOrRecentsAnimation();\n                    }\n                }\n                break;\n            }\n        }\n    }\n\n    final class UiHandler extends Handler {\n        static final int DISMISS_DIALOG_UI_MSG = 1;\n\n        public UiHandler() {\n            super(UiThread.get().getLooper(), null, true);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case DISMISS_DIALOG_UI_MSG: {\n                    final Dialog d = (Dialog) msg.obj;\n                    d.dismiss();\n                    break;\n                }\n            }\n        }\n    }\n\n    final class LocalService extends ActivityTaskManagerInternal {\n        @Override\n        public SleepTokenAcquirer createSleepTokenAcquirer(@NonNull String tag) {\n            Objects.requireNonNull(tag);\n            return new SleepTokenAcquirerImpl(tag);\n        }\n\n        @Override\n        public ComponentName getHomeActivityForUser(int userId) {\n            synchronized (mGlobalLock) {\n                final ActivityRecord homeActivity =\n                        mRootWindowContainer.getDefaultDisplayHomeActivityForUser(userId);\n                return homeActivity == null ? null : homeActivity.mActivityComponent;\n            }\n        }\n\n        @Override\n        public void onLocalVoiceInteractionStarted(IBinder activity,\n                IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor) {\n            synchronized (mGlobalLock) {\n                onLocalVoiceInteractionStartedLocked(activity, voiceSession, voiceInteractor);\n            }\n        }\n\n        @Override\n        public List<ActivityAssistInfo> getTopVisibleActivities() {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.getTopVisibleActivities();\n            }\n        }\n\n        @Override\n        public boolean hasResumedActivity(int uid) {\n            return mVisibleActivityProcessTracker.hasResumedActivity(uid);\n        }\n\n        @Override\n        public void setBackgroundActivityStartCallback(\n                @Nullable BackgroundActivityStartCallback backgroundActivityStartCallback) {\n            mBackgroundActivityStartCallback = backgroundActivityStartCallback;\n        }\n\n        @Override\n        public void setAccessibilityServiceUids(IntArray uids) {\n            synchronized (mGlobalLock) {\n                mAccessibilityServiceUids = uids.toArray();\n            }\n        }\n\n        @Override\n        public int startActivitiesAsPackage(String packageName, @Nullable String featureId,\n                int userId, Intent[] intents, Bundle bOptions) {\n            Objects.requireNonNull(intents, \"intents\");\n            final String[] resolvedTypes = new String[intents.length];\n\n            // UID of the package on user userId.\n            // \"= 0\" is needed because otherwise catch(RemoteException) would make it look like\n            // packageUid may not be initialized.\n            int packageUid = 0;\n            final long ident = Binder.clearCallingIdentity();\n\n            try {\n                for (int i = 0; i < intents.length; i++) {\n                    resolvedTypes[i] =\n                            intents[i].resolveTypeIfNeeded(mContext.getContentResolver());\n                }\n\n                packageUid = AppGlobals.getPackageManager().getPackageUid(\n                        packageName, PackageManager.MATCH_DEBUG_TRIAGED_MISSING, userId);\n            } catch (RemoteException e) {\n                // Shouldn't happen.\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n\n            return getActivityStartController().startActivitiesInPackage(\n                    packageUid, packageName, featureId,\n                    intents, resolvedTypes, null /* resultTo */,\n                    SafeActivityOptions.fromBundle(bOptions), userId,\n                    false /* validateIncomingUser */, null /* originatingPendingIntent */,\n                    false /* allowBackgroundActivityStart */);\n        }\n\n        @Override\n        public int startActivitiesInPackage(int uid, int realCallingPid, int realCallingUid,\n                String callingPackage, @Nullable String callingFeatureId, Intent[] intents,\n                String[] resolvedTypes, IBinder resultTo, SafeActivityOptions options, int userId,\n                boolean validateIncomingUser, PendingIntentRecord originatingPendingIntent,\n                boolean allowBackgroundActivityStart) {\n            assertPackageMatchesCallingUid(callingPackage);\n            return getActivityStartController().startActivitiesInPackage(uid, realCallingPid,\n                    realCallingUid, callingPackage, callingFeatureId, intents, resolvedTypes,\n                    resultTo, options, userId, validateIncomingUser, originatingPendingIntent,\n                    allowBackgroundActivityStart);\n        }\n\n        @Override\n        public int startActivityInPackage(int uid, int realCallingPid, int realCallingUid,\n                String callingPackage, @Nullable String callingFeatureId, Intent intent,\n                String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n                int startFlags, SafeActivityOptions options, int userId, Task inTask, String reason,\n                boolean validateIncomingUser, PendingIntentRecord originatingPendingIntent,\n                boolean allowBackgroundActivityStart) {\n            assertPackageMatchesCallingUid(callingPackage);\n            return getActivityStartController().startActivityInPackage(uid, realCallingPid,\n                    realCallingUid, callingPackage, callingFeatureId, intent, resolvedType,\n                    resultTo, resultWho, requestCode, startFlags, options, userId, inTask,\n                    reason, validateIncomingUser, originatingPendingIntent,\n                    allowBackgroundActivityStart);\n        }\n\n        @Override\n        public int startActivityAsUser(IApplicationThread caller, String callerPackage,\n                @Nullable String callerFeatureId, Intent intent, @Nullable IBinder resultTo,\n                int startFlags, Bundle options, int userId) {\n            return ActivityTaskManagerService.this.startActivityAsUser(\n                    caller, callerPackage, callerFeatureId, intent,\n                    intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                    resultTo, null, 0, startFlags, null, options, userId,\n                    false /*validateIncomingUser*/);\n        }\n\n        @Override\n        public void notifyKeyguardFlagsChanged(@Nullable Runnable callback, int displayId) {\n            synchronized (mGlobalLock) {\n\n                // We might change the visibilities here, so prepare an empty app transition which\n                // might be overridden later if we actually change visibilities.\n                final DisplayContent dc = mRootWindowContainer.getDisplayContent(displayId);\n                if (dc == null) {\n                    return;\n                }\n                final boolean wasTransitionSet = dc.mAppTransition.isTransitionSet();\n                if (!wasTransitionSet) {\n                    dc.prepareAppTransition(TRANSIT_NONE);\n                }\n                mRootWindowContainer.ensureActivitiesVisible(null, 0, !PRESERVE_WINDOWS);\n\n                // If there was a transition set already we don't want to interfere with it as we\n                // might be starting it too early.\n                if (!wasTransitionSet) {\n                    dc.executeAppTransition();\n                }\n            }\n            if (callback != null) {\n                callback.run();\n            }\n        }\n\n        @Override\n        public void notifyKeyguardTrustedChanged() {\n            synchronized (mGlobalLock) {\n                if (mKeyguardController.isKeyguardShowing(DEFAULT_DISPLAY)) {\n                    mRootWindowContainer.ensureActivitiesVisible(null, 0, !PRESERVE_WINDOWS);\n                }\n            }\n        }\n\n        /**\n         * Called after virtual display Id is updated by\n         * {@link com.android.server.vr.Vr2dDisplay} with a specific\n         * {@param vrVr2dDisplayId}.\n         */\n        @Override\n        public void setVr2dDisplayId(int vr2dDisplayId) {\n            ProtoLog.d(WM_DEBUG_TASKS, \"setVr2dDisplayId called for: %d\", vr2dDisplayId);\n            synchronized (mGlobalLock) {\n                mVr2dDisplayId = vr2dDisplayId;\n            }\n        }\n\n        @Override\n        public void setFocusedActivity(IBinder token) {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.forTokenLocked(token);\n                if (r == null) {\n                    throw new IllegalArgumentException(\n                            \"setFocusedActivity: No activity record matching token=\" + token);\n                }\n                if (r.moveFocusableActivityToTop(\"setFocusedActivity\")) {\n                    mRootWindowContainer.resumeFocusedTasksTopActivities();\n                }\n            }\n        }\n\n        @Override\n        public void registerScreenObserver(ScreenObserver observer) {\n            mScreenObservers.add(observer);\n        }\n\n        @Override\n        public boolean isCallerRecents(int callingUid) {\n            return getRecentTasks().isCallerRecents(callingUid);\n        }\n\n        @Override\n        public boolean isRecentsComponentHomeActivity(int userId) {\n            return getRecentTasks().isRecentsComponentHomeActivity(userId);\n        }\n\n        @Override\n        public boolean checkCanCloseSystemDialogs(int pid, int uid, @Nullable String packageName) {\n            return ActivityTaskManagerService.this.checkCanCloseSystemDialogs(pid, uid,\n                    packageName);\n        }\n\n        @Override\n        public boolean canCloseSystemDialogs(int pid, int uid) {\n            return ActivityTaskManagerService.this.canCloseSystemDialogs(pid, uid);\n        }\n\n        @Override\n        public void notifyActiveVoiceInteractionServiceChanged(ComponentName component) {\n            synchronized (mGlobalLock) {\n                mActiveVoiceInteractionServiceComponent = component;\n            }\n        }\n\n        @Override\n        public void notifyDreamStateChanged(boolean dreaming) {\n            synchronized (mGlobalLock) {\n                mDreaming = dreaming;\n            }\n        }\n\n        @Override\n        public void setAllowAppSwitches(@NonNull String type, int uid, int userId) {\n            if (!mAmInternal.isUserRunning(userId, ActivityManager.FLAG_OR_STOPPED)) {\n                return;\n            }\n            synchronized (mGlobalLock) {\n                ArrayMap<String, Integer> types = mAllowAppSwitchUids.get(userId);\n                if (types == null) {\n                    if (uid < 0) {\n                        return;\n                    }\n                    types = new ArrayMap<>();\n                    mAllowAppSwitchUids.put(userId, types);\n                }\n                if (uid < 0) {\n                    types.remove(type);\n                } else {\n                    types.put(type, uid);\n                }\n            }\n        }\n\n        @Override\n        public void onUserStopped(int userId) {\n            synchronized (mGlobalLock) {\n                getRecentTasks().unloadUserDataFromMemoryLocked(userId);\n                mAllowAppSwitchUids.remove(userId);\n            }\n        }\n\n        @Override\n        public boolean isGetTasksAllowed(String caller, int callingPid, int callingUid) {\n            synchronized (mGlobalLock) {\n                return ActivityTaskManagerService.this.isGetTasksAllowed(\n                        caller, callingPid, callingUid);\n            }\n        }\n\n        @HotPath(caller = HotPath.PROCESS_CHANGE)\n        @Override\n        public void onProcessAdded(WindowProcessController proc) {\n            synchronized (mGlobalLockWithoutBoost) {\n                mProcessNames.put(proc.mName, proc.mUid, proc);\n            }\n        }\n\n        @HotPath(caller = HotPath.PROCESS_CHANGE)\n        @Override\n        public void onProcessRemoved(String name, int uid) {\n            synchronized (mGlobalLockWithoutBoost) {\n                mProcessNames.remove(name, uid);\n            }\n        }\n\n        @HotPath(caller = HotPath.PROCESS_CHANGE)\n        @Override\n        public void onCleanUpApplicationRecord(WindowProcessController proc) {\n            synchronized (mGlobalLockWithoutBoost) {\n                if (proc == mHomeProcess) {\n                    mHomeProcess = null;\n                }\n                if (proc == mPreviousProcess) {\n                    mPreviousProcess = null;\n                }\n            }\n        }\n\n        @HotPath(caller = HotPath.OOM_ADJUSTMENT)\n        @Override\n        public int getTopProcessState() {\n            return mTopProcessState;\n        }\n\n        @HotPath(caller = HotPath.PROCESS_CHANGE)\n        @Override\n        public void clearHeavyWeightProcessIfEquals(WindowProcessController proc) {\n            synchronized (mGlobalLockWithoutBoost) {\n                ActivityTaskManagerService.this.clearHeavyWeightProcessIfEquals(proc);\n            }\n        }\n\n        @Override\n        public void finishHeavyWeightApp() {\n            synchronized (mGlobalLock) {\n                if (mHeavyWeightProcess != null) {\n                    mHeavyWeightProcess.finishActivities();\n                }\n                ActivityTaskManagerService.this.clearHeavyWeightProcessIfEquals(\n                        mHeavyWeightProcess);\n            }\n        }\n\n        @Override\n        public boolean isDreaming() {\n            synchronized (mGlobalLock) {\n                return mDreaming;\n            }\n        }\n\n        @HotPath(caller = HotPath.OOM_ADJUSTMENT)\n        @Override\n        public boolean isSleeping() {\n            return mSleeping;\n        }\n\n        @Override\n        public boolean isShuttingDown() {\n            synchronized (mGlobalLock) {\n                return mShuttingDown;\n            }\n        }\n\n        @Override\n        public boolean shuttingDown(boolean booted, int timeout) {\n            synchronized (mGlobalLock) {\n                mShuttingDown = true;\n                mRootWindowContainer.prepareForShutdown();\n                updateEventDispatchingLocked(booted);\n                notifyTaskPersisterLocked(null, true);\n                return mTaskSupervisor.shutdownLocked(timeout);\n            }\n        }\n\n        @Override\n        public void enableScreenAfterBoot(boolean booted) {\n            writeBootProgressEnableScreen(SystemClock.uptimeMillis());\n            mWindowManager.enableScreenAfterBoot();\n            synchronized (mGlobalLock) {\n                updateEventDispatchingLocked(booted);\n            }\n        }\n\n        @Override\n        public boolean showStrictModeViolationDialog() {\n            synchronized (mGlobalLock) {\n                return mShowDialogs && !mSleeping && !mShuttingDown;\n            }\n        }\n\n        @Override\n        public void showSystemReadyErrorDialogsIfNeeded() {\n            synchronized (mGlobalLock) {\n                try {\n                    if (AppGlobals.getPackageManager().hasSystemUidErrors()) {\n                        Slog.e(TAG, \"UIDs on the system are inconsistent, you need to wipe your\"\n                                + \" data partition or your device will be unstable.\");\n                        mUiHandler.post(() -> {\n                            if (mShowDialogs) {\n                                AlertDialog d = new BaseErrorDialog(mUiContext);\n                                d.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);\n                                d.setCancelable(false);\n                                d.setTitle(mUiContext.getText(R.string.android_system_label));\n                                d.setMessage(mUiContext.getText(R.string.system_error_wipe_data));\n                                d.setButton(DialogInterface.BUTTON_POSITIVE,\n                                        mUiContext.getText(R.string.ok),\n                                        mUiHandler.obtainMessage(DISMISS_DIALOG_UI_MSG, d));\n                                d.show();\n                            }\n                        });\n                    }\n                } catch (RemoteException e) {\n                }\n\n                if (!Build.isBuildConsistent()) {\n                    Slog.e(TAG, \"Build fingerprint is not consistent, warning user\");\n                    mUiHandler.post(() -> {\n                        if (mShowDialogs) {\n                            AlertDialog d = new BaseErrorDialog(mUiContext);\n                            d.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);\n                            d.setCancelable(false);\n                            d.setTitle(mUiContext.getText(R.string.android_system_label));\n                            d.setMessage(mUiContext.getText(R.string.system_error_manufacturer));\n                            d.setButton(DialogInterface.BUTTON_POSITIVE,\n                                    mUiContext.getText(R.string.ok),\n                                    mUiHandler.obtainMessage(DISMISS_DIALOG_UI_MSG, d));\n                            d.show();\n                        }\n                    });\n                }\n            }\n        }\n\n        @Override\n        public void onProcessMapped(int pid, WindowProcessController proc) {\n            synchronized (mGlobalLock) {\n                mProcessMap.put(pid, proc);\n            }\n        }\n\n        @Override\n        public void onProcessUnMapped(int pid) {\n            synchronized (mGlobalLock) {\n                mProcessMap.remove(pid);\n            }\n        }\n\n        @Override\n        public void onPackageDataCleared(String name) {\n            synchronized (mGlobalLock) {\n                mCompatModePackages.handlePackageDataClearedLocked(name);\n                mAppWarnings.onPackageDataCleared(name);\n            }\n        }\n\n        @Override\n        public void onPackageUninstalled(String name) {\n            synchronized (mGlobalLock) {\n                mAppWarnings.onPackageUninstalled(name);\n                mCompatModePackages.handlePackageUninstalledLocked(name);\n                mPackageConfigPersister.onPackageUninstall(name);\n            }\n        }\n\n        @Override\n        public void onPackageAdded(String name, boolean replacing) {\n            synchronized (mGlobalLock) {\n                mCompatModePackages.handlePackageAddedLocked(name, replacing);\n            }\n        }\n\n        @Override\n        public void onPackageReplaced(ApplicationInfo aInfo) {\n            synchronized (mGlobalLock) {\n                mRootWindowContainer.updateActivityApplicationInfo(aInfo);\n            }\n        }\n\n        @Override\n        public CompatibilityInfo compatibilityInfoForPackage(ApplicationInfo ai) {\n            synchronized (mGlobalLock) {\n                return compatibilityInfoForPackageLocked(ai);\n            }\n        }\n\n        @Override\n        public void sendActivityResult(int callingUid, IBinder activityToken, String resultWho,\n                int requestCode, int resultCode, Intent data) {\n            final ActivityRecord r;\n            synchronized (mGlobalLock) {\n                r = ActivityRecord.isInRootTaskLocked(activityToken);\n                if (r == null || r.getRootTask() == null) {\n                    return;\n                }\n            }\n\n            // Carefully collect grants without holding lock\n            final NeededUriGrants dataGrants = collectGrants(data, r);\n\n            synchronized (mGlobalLock) {\n                r.sendResult(callingUid, resultWho, requestCode, resultCode, data, dataGrants);\n            }\n        }\n\n        @Override\n        public void clearPendingResultForActivity(IBinder activityToken,\n                WeakReference<PendingIntentRecord> pir) {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(activityToken);\n                if (r != null && r.pendingResults != null) {\n                    r.pendingResults.remove(pir);\n                }\n            }\n        }\n\n        @Override\n        public ComponentName getActivityName(IBinder activityToken) {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(activityToken);\n                return r != null ? r.intent.getComponent() : null;\n            }\n        }\n\n        @Override\n        public ActivityTokens getTopActivityForTask(int taskId) {\n            synchronized (mGlobalLock) {\n                final Task task = mRootWindowContainer.anyTaskForId(taskId,\n                        MATCH_ATTACHED_TASK_ONLY);\n                if (task == null) {\n                    Slog.w(TAG, \"getApplicationThreadForTopActivity failed:\"\n                            + \" Requested task not found\");\n                    return null;\n                }\n                final ActivityRecord activity = task.getTopNonFinishingActivity();\n                if (activity == null) {\n                    Slog.w(TAG, \"getApplicationThreadForTopActivity failed:\"\n                            + \" Requested activity not found\");\n                    return null;\n                }\n                if (!activity.attachedToProcess()) {\n                    Slog.w(TAG, \"getApplicationThreadForTopActivity failed: No process for \"\n                            + activity);\n                    return null;\n                }\n                return new ActivityTokens(activity.appToken, activity.assistToken,\n                        activity.app.getThread(), activity.shareableActivityToken);\n            }\n        }\n\n        @Override\n        public IIntentSender getIntentSender(int type, String packageName,\n                @Nullable String featureId, int callingUid, int userId, IBinder token,\n                String resultWho, int requestCode, Intent[] intents, String[] resolvedTypes,\n                int flags, Bundle bOptions) {\n            synchronized (mGlobalLock) {\n                return getIntentSenderLocked(type, packageName, featureId, callingUid, userId,\n                        token, resultWho, requestCode, intents, resolvedTypes, flags, bOptions);\n            }\n        }\n\n        @Override\n        public ActivityServiceConnectionsHolder getServiceConnectionsHolder(IBinder token) {\n            synchronized (mGlobalLock) {\n                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(token);\n                if (r == null) {\n                    return null;\n                }\n                if (r.mServiceConnectionsHolder == null) {\n                    r.mServiceConnectionsHolder = new ActivityServiceConnectionsHolder(\n                            ActivityTaskManagerService.this, r);\n                }\n\n                return r.mServiceConnectionsHolder;\n            }\n        }\n\n        @Override\n        public Intent getHomeIntent() {\n            synchronized (mGlobalLock) {\n                return ActivityTaskManagerService.this.getHomeIntent();\n            }\n        }\n\n        @Override\n        public boolean startHomeActivity(int userId, String reason) {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.startHomeOnDisplay(userId, reason, DEFAULT_DISPLAY);\n            }\n        }\n\n        @Override\n        public boolean startHomeOnDisplay(int userId, String reason, int displayId,\n                boolean allowInstrumenting, boolean fromHomeKey) {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.startHomeOnDisplay(userId, reason, displayId,\n                        allowInstrumenting, fromHomeKey);\n            }\n        }\n\n        @Override\n        public boolean startHomeOnAllDisplays(int userId, String reason) {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.startHomeOnAllDisplays(userId, reason);\n            }\n        }\n\n        @HotPath(caller = HotPath.PROCESS_CHANGE)\n        @Override\n        public boolean isFactoryTestProcess(WindowProcessController wpc) {\n            synchronized (mGlobalLockWithoutBoost) {\n                if (mFactoryTest == FACTORY_TEST_OFF) {\n                    return false;\n                }\n                if (mFactoryTest == FACTORY_TEST_LOW_LEVEL && mTopComponent != null\n                        && wpc.mName.equals(mTopComponent.getPackageName())) {\n                    return true;\n                }\n                return mFactoryTest == FACTORY_TEST_HIGH_LEVEL\n                        && (wpc.mInfo.flags & FLAG_FACTORY_TEST) != 0;\n            }\n        }\n\n        @Override\n        public void updateTopComponentForFactoryTest() {\n            synchronized (mGlobalLock) {\n                if (mFactoryTest != FACTORY_TEST_LOW_LEVEL) {\n                    return;\n                }\n                final ResolveInfo ri = mContext.getPackageManager()\n                        .resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST), STOCK_PM_FLAGS);\n                final CharSequence errorMsg;\n                if (ri != null) {\n                    final ActivityInfo ai = ri.activityInfo;\n                    final ApplicationInfo app = ai.applicationInfo;\n                    if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {\n                        mTopAction = Intent.ACTION_FACTORY_TEST;\n                        mTopData = null;\n                        mTopComponent = new ComponentName(app.packageName, ai.name);\n                        errorMsg = null;\n                    } else {\n                        errorMsg = mContext.getResources().getText(\n                                com.android.internal.R.string.factorytest_not_system);\n                    }\n                } else {\n                    errorMsg = mContext.getResources().getText(\n                            com.android.internal.R.string.factorytest_no_action);\n                }\n                if (errorMsg == null) {\n                    return;\n                }\n\n                mTopAction = null;\n                mTopData = null;\n                mTopComponent = null;\n                mUiHandler.post(() -> {\n                    Dialog d = new FactoryErrorDialog(mUiContext, errorMsg);\n                    d.show();\n                    mAmInternal.ensureBootCompleted();\n                });\n            }\n        }\n\n        @HotPath(caller = HotPath.PROCESS_CHANGE)\n        @Override\n        public void handleAppDied(WindowProcessController wpc, boolean restarting,\n                Runnable finishInstrumentationCallback) {\n            synchronized (mGlobalLockWithoutBoost) {\n                mTaskSupervisor.beginDeferResume();\n                final boolean hasVisibleActivities;\n                try {\n                    // Remove this application's activities from active lists.\n                    hasVisibleActivities = wpc.handleAppDied();\n                } finally {\n                    mTaskSupervisor.endDeferResume();\n                }\n\n                if (!restarting && hasVisibleActivities) {\n                    deferWindowLayout();\n                    try {\n                        if (!mRootWindowContainer.resumeFocusedTasksTopActivities()) {\n                            // If there was nothing to resume, and we are not already restarting\n                            // this process, but there is a visible activity that is hosted by the\n                            // process...then make sure all visible activities are running, taking\n                            // care of restarting this process.\n                            mRootWindowContainer.ensureActivitiesVisible(null, 0,\n                                    !PRESERVE_WINDOWS);\n                        }\n                    } finally {\n                        continueWindowLayout();\n                    }\n                }\n            }\n            if (wpc.isInstrumenting()) {\n                finishInstrumentationCallback.run();\n            }\n        }\n\n        @Override\n        public void closeSystemDialogs(String reason) {\n            enforceNotIsolatedCaller(\"closeSystemDialogs\");\n            final int pid = Binder.getCallingPid();\n            final int uid = Binder.getCallingUid();\n            if (!checkCanCloseSystemDialogs(pid, uid, null)) {\n                return;\n            }\n\n            final long origId = Binder.clearCallingIdentity();\n            try {\n                synchronized (mGlobalLock) {\n                    // Only allow this from foreground processes, so that background\n                    // applications can't abuse it to prevent system UI from being shown.\n                    if (uid >= FIRST_APPLICATION_UID) {\n                        final WindowProcessController proc = mProcessMap.getProcess(pid);\n                        if (!proc.isPerceptible()) {\n                            Slog.w(TAG, \"Ignoring closeSystemDialogs \" + reason\n                                    + \" from background process \" + proc);\n                            return;\n                        }\n                    }\n                    mWindowManager.closeSystemDialogs(reason);\n\n                    mRootWindowContainer.closeSystemDialogActivities(reason);\n                }\n                // Call into AM outside the synchronized block.\n                mAmInternal.broadcastCloseSystemDialogs(reason);\n            } finally {\n                Binder.restoreCallingIdentity(origId);\n            }\n        }\n\n        @Override\n        public void cleanupDisabledPackageComponents(\n                String packageName, Set<String> disabledClasses, int userId, boolean booted) {\n            synchronized (mGlobalLock) {\n                // Clean-up disabled activities.\n                if (mRootWindowContainer.finishDisabledPackageActivities(\n                        packageName, disabledClasses, true /* doit */, false /* evenPersistent */,\n                        userId, false /* onlyRemoveNoProcess */) && booted) {\n                    mRootWindowContainer.resumeFocusedTasksTopActivities();\n                    mTaskSupervisor.scheduleIdle();\n                }\n\n                // Clean-up disabled tasks\n                getRecentTasks().cleanupDisabledPackageTasksLocked(\n                        packageName, disabledClasses, userId);\n            }\n        }\n\n        @Override\n        public boolean onForceStopPackage(String packageName, boolean doit, boolean evenPersistent,\n                int userId) {\n            synchronized (mGlobalLock) {\n\n                return mRootWindowContainer.finishDisabledPackageActivities(packageName,\n                        null /* filterByClasses */, doit, evenPersistent, userId,\n                        // Only remove the activities without process because the activities with\n                        // attached process will be removed when handling process died with\n                        // WindowProcessController#isRemoved == true.\n                        true /* onlyRemoveNoProcess */);\n            }\n        }\n\n        @Override\n        public void resumeTopActivities(boolean scheduleIdle) {\n            synchronized (mGlobalLock) {\n                mRootWindowContainer.resumeFocusedTasksTopActivities();\n                if (scheduleIdle) {\n                    mTaskSupervisor.scheduleIdle();\n                }\n            }\n        }\n\n        @HotPath(caller = HotPath.PROCESS_CHANGE)\n        @Override\n        public void preBindApplication(WindowProcessController wpc) {\n            synchronized (mGlobalLockWithoutBoost) {\n                mTaskSupervisor.getActivityMetricsLogger().notifyBindApplication(wpc.mInfo);\n            }\n        }\n\n        @HotPath(caller = HotPath.PROCESS_CHANGE)\n        @Override\n        public boolean attachApplication(WindowProcessController wpc) throws RemoteException {\n            synchronized (mGlobalLockWithoutBoost) {\n                if (Trace.isTagEnabled(TRACE_TAG_WINDOW_MANAGER)) {\n                    Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, \"attachApplication:\" + wpc.mName);\n                }\n                try {\n                    return mRootWindowContainer.attachApplication(wpc);\n                } finally {\n                    Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);\n                }\n            }\n        }\n\n        @Override\n        public void notifyLockedProfile(@UserIdInt int userId, int currentUserId) {\n            try {\n                if (!AppGlobals.getPackageManager().isUidPrivileged(Binder.getCallingUid())) {\n                    throw new SecurityException(\"Only privileged app can call notifyLockedProfile\");\n                }\n            } catch (RemoteException ex) {\n                throw new SecurityException(\"Fail to check is caller a privileged app\", ex);\n            }\n\n            synchronized (mGlobalLock) {\n                final long ident = Binder.clearCallingIdentity();\n                try {\n                    if (mAmInternal.shouldConfirmCredentials(userId)) {\n                        if (mKeyguardController.isKeyguardLocked()) {\n                            // Showing launcher to avoid user entering credential twice.\n                            startHomeActivity(currentUserId, \"notifyLockedProfile\");\n                        }\n                        mRootWindowContainer.lockAllProfileTasks(userId);\n                    }\n                } finally {\n                    Binder.restoreCallingIdentity(ident);\n                }\n            }\n        }\n\n        @Override\n        public void startConfirmDeviceCredentialIntent(Intent intent, Bundle options) {\n            enforceTaskPermission(\"startConfirmDeviceCredentialIntent\");\n\n            synchronized (mGlobalLock) {\n                final long ident = Binder.clearCallingIdentity();\n                try {\n                    intent.addFlags(FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);\n                    final ActivityOptions activityOptions = options != null\n                            ? new ActivityOptions(options) : ActivityOptions.makeBasic();\n                    mContext.startActivityAsUser(intent, activityOptions.toBundle(),\n                            UserHandle.CURRENT);\n                } finally {\n                    Binder.restoreCallingIdentity(ident);\n                }\n            }\n        }\n\n        @Override\n        public void writeActivitiesToProto(ProtoOutputStream proto) {\n            synchronized (mGlobalLock) {\n                // The output proto of \"activity --proto activities\"\n                mRootWindowContainer.dumpDebug(\n                        proto, ROOT_WINDOW_CONTAINER, WindowTraceLogLevel.ALL);\n            }\n        }\n\n        @Override\n        public void saveANRState(String reason) {\n            synchronized (mGlobalLock) {\n                final StringWriter sw = new StringWriter();\n                final PrintWriter pw = new FastPrintWriter(sw, false, 1024);\n                pw.println(\"  ANR time: \" + DateFormat.getDateTimeInstance().format(new Date()));\n                if (reason != null) {\n                    pw.println(\"  Reason: \" + reason);\n                }\n                pw.println();\n                getActivityStartController().dump(pw, \"  \", null);\n                pw.println();\n                pw.println(\"-------------------------------------------------------------------\"\n                        + \"------------\");\n                dumpActivitiesLocked(null /* fd */, pw, null /* args */, 0 /* opti */,\n                        true /* dumpAll */, false /* dumpClient */, null /* dumpPackage */,\n                        \"\" /* header */);\n                pw.println();\n                pw.close();\n\n                mLastANRState = sw.toString();\n            }\n        }\n\n        @Override\n        public void clearSavedANRState() {\n            synchronized (mGlobalLock) {\n                mLastANRState = null;\n            }\n        }\n\n        @Override\n        public void dump(String cmd, FileDescriptor fd, PrintWriter pw, String[] args, int opti,\n                boolean dumpAll, boolean dumpClient, String dumpPackage) {\n            synchronized (mGlobalLock) {\n                if (DUMP_ACTIVITIES_CMD.equals(cmd) || DUMP_ACTIVITIES_SHORT_CMD.equals(cmd)) {\n                    dumpActivitiesLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage);\n                } else if (DUMP_LASTANR_CMD.equals(cmd)) {\n                    dumpLastANRLocked(pw);\n                } else if (DUMP_LASTANR_TRACES_CMD.equals(cmd)) {\n                    dumpLastANRTracesLocked(pw);\n                } else if (DUMP_STARTER_CMD.equals(cmd)) {\n                    dumpActivityStarterLocked(pw, dumpPackage);\n                } else if (DUMP_CONTAINERS_CMD.equals(cmd)) {\n                    dumpActivityContainersLocked(pw);\n                } else if (DUMP_RECENTS_CMD.equals(cmd) || DUMP_RECENTS_SHORT_CMD.equals(cmd)) {\n                    if (getRecentTasks() != null) {\n                        getRecentTasks().dump(pw, dumpAll, dumpPackage);\n                    }\n                } else if (DUMP_TOP_RESUMED_ACTIVITY.equals(cmd)) {\n                    dumpTopResumedActivityLocked(pw);\n                }\n            }\n        }\n\n        @Override\n        public boolean dumpForProcesses(FileDescriptor fd, PrintWriter pw, boolean dumpAll,\n                String dumpPackage, int dumpAppId, boolean needSep, boolean testPssMode,\n                int wakefulness) {\n            synchronized (mGlobalLock) {\n                if (mHomeProcess != null && (dumpPackage == null\n                        || mHomeProcess.mPkgList.contains(dumpPackage))) {\n                    if (needSep) {\n                        pw.println();\n                        needSep = false;\n                    }\n                    pw.println(\"  mHomeProcess: \" + mHomeProcess);\n                }\n                if (mPreviousProcess != null && (dumpPackage == null\n                        || mPreviousProcess.mPkgList.contains(dumpPackage))) {\n                    if (needSep) {\n                        pw.println();\n                        needSep = false;\n                    }\n                    pw.println(\"  mPreviousProcess: \" + mPreviousProcess);\n                }\n                if (dumpAll && (mPreviousProcess == null || dumpPackage == null\n                        || mPreviousProcess.mPkgList.contains(dumpPackage))) {\n                    StringBuilder sb = new StringBuilder(128);\n                    sb.append(\"  mPreviousProcessVisibleTime: \");\n                    TimeUtils.formatDuration(mPreviousProcessVisibleTime, sb);\n                    pw.println(sb);\n                }\n                if (mHeavyWeightProcess != null && (dumpPackage == null\n                        || mHeavyWeightProcess.mPkgList.contains(dumpPackage))) {\n                    if (needSep) {\n                        pw.println();\n                        needSep = false;\n                    }\n                    pw.println(\"  mHeavyWeightProcess: \" + mHeavyWeightProcess);\n                }\n                if (dumpPackage == null) {\n                    pw.println(\"  mGlobalConfiguration: \" + getGlobalConfiguration());\n                    mRootWindowContainer.dumpDisplayConfigs(pw, \"  \");\n                }\n                if (dumpAll) {\n                    final Task topFocusedRootTask = getTopDisplayFocusedRootTask();\n                    if (dumpPackage == null && topFocusedRootTask != null) {\n                        pw.println(\"  mConfigWillChange: \" + topFocusedRootTask.mConfigWillChange);\n                    }\n                    if (mCompatModePackages.getPackages().size() > 0) {\n                        boolean printed = false;\n                        for (Map.Entry<String, Integer> entry\n                                : mCompatModePackages.getPackages().entrySet()) {\n                            String pkg = entry.getKey();\n                            int mode = entry.getValue();\n                            if (dumpPackage != null && !dumpPackage.equals(pkg)) {\n                                continue;\n                            }\n                            if (!printed) {\n                                pw.println(\"  mScreenCompatPackages:\");\n                                printed = true;\n                            }\n                            pw.println(\"    \" + pkg + \": \" + mode);\n                        }\n                    }\n                }\n\n                if (dumpPackage == null) {\n                    pw.println(\"  mWakefulness=\"\n                            + PowerManagerInternal.wakefulnessToString(wakefulness));\n                    pw.println(\"  mSleepTokens=\" + mRootWindowContainer.mSleepTokens);\n                    if (mRunningVoice != null) {\n                        pw.println(\"  mRunningVoice=\" + mRunningVoice);\n                        pw.println(\"  mVoiceWakeLock\" + mVoiceWakeLock);\n                    }\n                    pw.println(\"  mSleeping=\" + mSleeping);\n                    pw.println(\"  mShuttingDown=\" + mShuttingDown + \" mTestPssMode=\" + testPssMode);\n                    pw.println(\"  mVrController=\" + mVrController);\n                }\n                if (mCurAppTimeTracker != null) {\n                    mCurAppTimeTracker.dumpWithHeader(pw, \"  \", true);\n                }\n                if (mAllowAppSwitchUids.size() > 0) {\n                    boolean printed = false;\n                    for (int i = 0; i < mAllowAppSwitchUids.size(); i++) {\n                        ArrayMap<String, Integer> types = mAllowAppSwitchUids.valueAt(i);\n                        for (int j = 0; j < types.size(); j++) {\n                            if (dumpPackage == null ||\n                                    UserHandle.getAppId(types.valueAt(j).intValue()) == dumpAppId) {\n                                if (needSep) {\n                                    pw.println();\n                                    needSep = false;\n                                }\n                                if (!printed) {\n                                    pw.println(\"  mAllowAppSwitchUids:\");\n                                    printed = true;\n                                }\n                                pw.print(\"    User \");\n                                pw.print(mAllowAppSwitchUids.keyAt(i));\n                                pw.print(\": Type \");\n                                pw.print(types.keyAt(j));\n                                pw.print(\" = \");\n                                UserHandle.formatUid(pw, types.valueAt(j).intValue());\n                                pw.println();\n                            }\n                        }\n                    }\n                }\n                if (dumpPackage == null) {\n                    if (mController != null) {\n                        pw.println(\"  mController=\" + mController\n                                + \" mControllerIsAMonkey=\" + mControllerIsAMonkey);\n                    }\n                    pw.println(\"  mGoingToSleepWakeLock=\" + mTaskSupervisor.mGoingToSleepWakeLock);\n                    pw.println(\"  mLaunchingActivityWakeLock=\"\n                            + mTaskSupervisor.mLaunchingActivityWakeLock);\n                }\n\n                return needSep;\n            }\n        }\n\n        @Override\n        public void writeProcessesToProto(ProtoOutputStream proto, String dumpPackage,\n                int wakeFullness, boolean testPssMode) {\n            synchronized (mGlobalLock) {\n                if (dumpPackage == null) {\n                    getGlobalConfiguration().dumpDebug(proto, GLOBAL_CONFIGURATION);\n                    final Task topFocusedRootTask = getTopDisplayFocusedRootTask();\n                    if (topFocusedRootTask != null) {\n                        proto.write(CONFIG_WILL_CHANGE, topFocusedRootTask.mConfigWillChange);\n                    }\n                    writeSleepStateToProto(proto, wakeFullness, testPssMode);\n                    if (mRunningVoice != null) {\n                        final long vrToken = proto.start(\n                                ActivityManagerServiceDumpProcessesProto.RUNNING_VOICE);\n                        proto.write(ActivityManagerServiceDumpProcessesProto.Voice.SESSION,\n                                mRunningVoice.toString());\n                        mVoiceWakeLock.dumpDebug(\n                                proto, ActivityManagerServiceDumpProcessesProto.Voice.WAKELOCK);\n                        proto.end(vrToken);\n                    }\n                    mVrController.dumpDebug(proto,\n                            ActivityManagerServiceDumpProcessesProto.VR_CONTROLLER);\n                    if (mController != null) {\n                        final long token = proto.start(CONTROLLER);\n                        proto.write(ActivityManagerServiceDumpProcessesProto.Controller.CONTROLLER,\n                                mController.toString());\n                        proto.write(IS_A_MONKEY, mControllerIsAMonkey);\n                        proto.end(token);\n                    }\n                    mTaskSupervisor.mGoingToSleepWakeLock.dumpDebug(proto, GOING_TO_SLEEP);\n                    mTaskSupervisor.mLaunchingActivityWakeLock.dumpDebug(proto,\n                            LAUNCHING_ACTIVITY);\n                }\n\n                if (mHomeProcess != null && (dumpPackage == null\n                        || mHomeProcess.mPkgList.contains(dumpPackage))) {\n                    mHomeProcess.dumpDebug(proto, HOME_PROC);\n                }\n\n                if (mPreviousProcess != null && (dumpPackage == null\n                        || mPreviousProcess.mPkgList.contains(dumpPackage))) {\n                    mPreviousProcess.dumpDebug(proto, PREVIOUS_PROC);\n                    proto.write(PREVIOUS_PROC_VISIBLE_TIME_MS, mPreviousProcessVisibleTime);\n                }\n\n                if (mHeavyWeightProcess != null && (dumpPackage == null\n                        || mHeavyWeightProcess.mPkgList.contains(dumpPackage))) {\n                    mHeavyWeightProcess.dumpDebug(proto, HEAVY_WEIGHT_PROC);\n                }\n\n                for (Map.Entry<String, Integer> entry\n                        : mCompatModePackages.getPackages().entrySet()) {\n                    String pkg = entry.getKey();\n                    int mode = entry.getValue();\n                    if (dumpPackage == null || dumpPackage.equals(pkg)) {\n                        long compatToken = proto.start(SCREEN_COMPAT_PACKAGES);\n                        proto.write(PACKAGE, pkg);\n                        proto.write(MODE, mode);\n                        proto.end(compatToken);\n                    }\n                }\n\n                if (mCurAppTimeTracker != null) {\n                    mCurAppTimeTracker.dumpDebug(proto, CURRENT_TRACKER, true);\n                }\n\n            }\n        }\n\n        @Override\n        public boolean dumpActivity(FileDescriptor fd, PrintWriter pw, String name,\n                String[] args, int opti, boolean dumpAll, boolean dumpVisibleRootTasksOnly,\n                boolean dumpFocusedRootTaskOnly) {\n            return ActivityTaskManagerService.this.dumpActivity(fd, pw, name, args, opti, dumpAll,\n                    dumpVisibleRootTasksOnly, dumpFocusedRootTaskOnly);\n        }\n\n        @Override\n        public void dumpForOom(PrintWriter pw) {\n            synchronized (mGlobalLock) {\n                pw.println(\"  mHomeProcess: \" + mHomeProcess);\n                pw.println(\"  mPreviousProcess: \" + mPreviousProcess);\n                if (mHeavyWeightProcess != null) {\n                    pw.println(\"  mHeavyWeightProcess: \" + mHeavyWeightProcess);\n                }\n            }\n        }\n\n        @Override\n        public boolean canGcNow() {\n            synchronized (mGlobalLock) {\n                return isSleeping() || mRootWindowContainer.allResumedActivitiesIdle();\n            }\n        }\n\n        @HotPath(caller = HotPath.OOM_ADJUSTMENT)\n        @Override\n        public WindowProcessController getTopApp() {\n            return mTopApp;\n        }\n\n        @Override\n        public void scheduleDestroyAllActivities(String reason) {\n            synchronized (mGlobalLock) {\n                mRootWindowContainer.scheduleDestroyAllActivities(reason);\n            }\n        }\n\n        @Override\n        public void removeUser(int userId) {\n            synchronized (mGlobalLock) {\n                mRootWindowContainer.removeUser(userId);\n                mPackageConfigPersister.removeUser(userId);\n            }\n        }\n\n        @Override\n        public boolean switchUser(int userId, UserState userState) {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.switchUser(userId, userState);\n            }\n        }\n\n        @Override\n        public void onHandleAppCrash(WindowProcessController wpc) {\n            synchronized (mGlobalLock) {\n                mRootWindowContainer.handleAppCrash(wpc);\n            }\n        }\n\n        @Override\n        public int finishTopCrashedActivities(WindowProcessController crashedApp, String reason) {\n            synchronized (mGlobalLock) {\n                return mRootWindowContainer.finishTopCrashedActivities(crashedApp, reason);\n            }\n        }\n\n        @HotPath(caller = HotPath.OOM_ADJUSTMENT)\n        @Override\n        public void onUidActive(int uid, int procState) {\n            mActiveUids.onUidActive(uid, procState);\n        }\n\n        @HotPath(caller = HotPath.OOM_ADJUSTMENT)\n        @Override\n        public void onUidInactive(int uid) {\n            mActiveUids.onUidInactive(uid);\n        }\n\n        @HotPath(caller = HotPath.OOM_ADJUSTMENT)\n        @Override\n        public void onUidProcStateChanged(int uid, int procState) {\n            mActiveUids.onUidProcStateChanged(uid, procState);\n        }\n\n        @Override\n        public void onUidAddedToPendingTempAllowlist(int uid, String tag) {\n            synchronized (mGlobalLockWithoutBoost) {\n                mPendingTempAllowlist.put(uid, tag);\n            }\n        }\n\n        @Override\n        public void onUidRemovedFromPendingTempAllowlist(int uid) {\n            synchronized (mGlobalLockWithoutBoost) {\n                mPendingTempAllowlist.remove(uid);\n            }\n        }\n\n        @Override\n        public boolean handleAppCrashInActivityController(String processName, int pid,\n                String shortMsg, String longMsg, long timeMillis, String stackTrace,\n                Runnable killCrashingAppCallback) {\n            Runnable targetRunnable = null;\n            synchronized (mGlobalLock) {\n                if (mController == null) {\n                    return false;\n                }\n\n                try {\n                    if (!mController.appCrashed(processName, pid, shortMsg, longMsg, timeMillis,\n                            stackTrace)) {\n                        targetRunnable = killCrashingAppCallback;\n                    }\n                } catch (RemoteException e) {\n                    mController = null;\n                    Watchdog.getInstance().setActivityController(null);\n                }\n            }\n            if (targetRunnable != null) {\n                targetRunnable.run();\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public void removeRecentTasksByPackageName(String packageName, int userId) {\n            synchronized (mGlobalLock) {\n                mRecentTasks.removeTasksByPackageName(packageName, userId);\n            }\n        }\n\n        @Override\n        public void cleanupRecentTasksForUser(int userId) {\n            synchronized (mGlobalLock) {\n                mRecentTasks.cleanupLocked(userId);\n            }\n        }\n\n        @Override\n        public void loadRecentTasksForUser(int userId) {\n            synchronized (mGlobalLock) {\n                mRecentTasks.loadUserRecentsLocked(userId);\n                // TODO renaming the methods(?)\n                mPackageConfigPersister.loadUserPackages(userId);\n            }\n        }\n\n        @Override\n        public void onPackagesSuspendedChanged(String[] packages, boolean suspended, int userId) {\n            synchronized (mGlobalLock) {\n                mRecentTasks.onPackagesSuspendedChanged(packages, suspended, userId);\n            }\n        }\n\n        @Override\n        public void flushRecentTasks() {\n            mRecentTasks.flush();\n        }\n\n        @Override\n        public void clearLockedTasks(String reason) {\n            synchronized (mGlobalLock) {\n                getLockTaskController().clearLockedTasks(reason);\n            }\n        }\n\n        @Override\n        public void updateUserConfiguration() {\n            synchronized (mGlobalLock) {\n                final Configuration configuration = new Configuration(getGlobalConfiguration());\n                final int currentUserId = mAmInternal.getCurrentUserId();\n                Settings.System.adjustConfigurationForUser(mContext.getContentResolver(),\n                        configuration, currentUserId, Settings.System.canWrite(mContext));\n                updateConfigurationLocked(configuration, null /* starting */,\n                        false /* initLocale */, false /* persistent */, currentUserId,\n                        false /* deferResume */);\n            }\n        }\n\n        @Override\n        public boolean canShowErrorDialogs() {\n            synchronized (mGlobalLock) {\n                return mShowDialogs && !mSleeping && !mShuttingDown\n                        && !mKeyguardController.isKeyguardOrAodShowing(DEFAULT_DISPLAY)\n                        && !hasUserRestriction(UserManager.DISALLOW_SYSTEM_ERROR_DIALOGS,\n                        mAmInternal.getCurrentUserId())\n                        && !(UserManager.isDeviceInDemoMode(mContext)\n                        && mAmInternal.getCurrentUser().isDemo());\n            }\n        }\n\n        @Override\n        public void setProfileApp(String profileApp) {\n            synchronized (mGlobalLock) {\n                mProfileApp = profileApp;\n            }\n        }\n\n        @Override\n        public void setProfileProc(WindowProcessController wpc) {\n            synchronized (mGlobalLock) {\n                mProfileProc = wpc;\n            }\n        }\n\n        @Override\n        public void setProfilerInfo(ProfilerInfo profilerInfo) {\n            synchronized (mGlobalLock) {\n                mProfilerInfo = profilerInfo;\n            }\n        }\n\n        @Override\n        public ActivityMetricsLaunchObserverRegistry getLaunchObserverRegistry() {\n            synchronized (mGlobalLock) {\n                return mTaskSupervisor.getActivityMetricsLogger().getLaunchObserverRegistry();\n            }\n        }\n\n        @Nullable\n        @Override\n        public IBinder getUriPermissionOwnerForActivity(@NonNull IBinder activityToken) {\n            ActivityTaskManagerService.enforceNotIsolatedCaller(\"getUriPermissionOwnerForActivity\");\n            synchronized (mGlobalLock) {\n                ActivityRecord r = ActivityRecord.isInRootTaskLocked(activityToken);\n                return (r == null) ? null : r.getUriPermissionsLocked().getExternalToken();\n            }\n        }\n\n        @Override\n        public TaskSnapshot getTaskSnapshotBlocking(\n                int taskId, boolean isLowResolution) {\n            return ActivityTaskManagerService.this.getTaskSnapshot(taskId, isLowResolution,\n                    true /* restoreFromDisk */);\n        }\n\n        @Override\n        public boolean isUidForeground(int uid) {\n            return ActivityTaskManagerService.this.hasActiveVisibleWindow(uid);\n        }\n\n        @Override\n        public void setDeviceOwnerUid(int uid) {\n            synchronized (mGlobalLock) {\n                ActivityTaskManagerService.this.setDeviceOwnerUid(uid);\n            }\n        }\n\n        @Override\n        public void setCompanionAppUids(int userId, Set<Integer> companionAppUids) {\n            synchronized (mGlobalLock) {\n                mCompanionAppUidsMap.put(userId, companionAppUids);\n            }\n        }\n\n\n        @Override\n        public boolean isBaseOfLockedTask(String packageName) {\n            synchronized (mGlobalLock) {\n                return getLockTaskController().isBaseOfLockedTask(packageName);\n            }\n        }\n\n        @Override\n        public PackageConfigurationUpdater createPackageConfigurationUpdater() {\n            return new PackageConfigurationUpdaterImpl(Binder.getCallingPid());\n        }\n\n        @Override\n        public boolean hasSystemAlertWindowPermission(int callingUid, int callingPid,\n                String callingPackage) {\n            return ActivityTaskManagerService.this.hasSystemAlertWindowPermission(callingUid,\n                    callingPid, callingPackage);\n        }\n    }\n\n    final class PackageConfigurationUpdaterImpl implements\n            ActivityTaskManagerInternal.PackageConfigurationUpdater {\n        private final int mPid;\n        private int mNightMode;\n\n        PackageConfigurationUpdaterImpl(int pid) {\n            mPid = pid;\n        }\n\n        @Override\n        public ActivityTaskManagerInternal.PackageConfigurationUpdater setNightMode(int nightMode) {\n            mNightMode = nightMode;\n            return this;\n        }\n\n        @Override\n        public void commit() {\n            synchronized (mGlobalLock) {\n                final long ident = Binder.clearCallingIdentity();\n                try {\n                    final WindowProcessController wpc = mProcessMap.getProcess(mPid);\n                    if (wpc == null) {\n                        Slog.w(TAG, \"Override application configuration: cannot find pid \" + mPid);\n                        return;\n                    }\n                    wpc.setOverrideNightMode(mNightMode);\n                    wpc.updateNightModeForAllActivities(mNightMode);\n                    mPackageConfigPersister.updateFromImpl(wpc.mName, wpc.mUserId, this);\n                } finally {\n                    Binder.restoreCallingIdentity(ident);\n                }\n            }\n        }\n\n        int getNightMode() {\n            return mNightMode;\n        }\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 53145,
                                        "general": {
                                            "word_based": 20567,
                                            "char_based": 69066
                                        },
                                        "gemini": 62147
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "3e9da3ec4705b072dbe8a10e8ffc841f4928381c",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 3e9da3ec4705b072dbe8a10e8ffc841f4928381c\nAuthor: Christophe Pinelli <cpinelli@google.com>\nDate:   Tue May 16 17:43:49 2023 +0000\n\n    Restrict activity launch when caller is running in the background\n    \n    Test: test on device + atest-src BackgroundActivityLaunchTest#testBackgroundActivityBlockedInStartNextMatchingActivity\n    Bug: 230492947\n    Merged-In: Ic88dd1e79b867b44cdcd6fc86650f5de6ebcc23d\n    Change-Id: Ie774b142a7fab12d596ccd64872b781e3825e9ba\n\ndiff --git a/services/core/java/com/android/server/wm/ActivityTaskManagerService.java b/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\nindex aa154292fe7e..70445c92e143 100644\n--- a/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\n+++ b/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\n@@ -1363,29 +1363,38 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n \n             final long origId = Binder.clearCallingIdentity();\n             // TODO(b/64750076): Check if calling pid should really be -1.\n-            final int res = getActivityStartController()\n-                    .obtainStarter(intent, \"startNextMatchingActivity\")\n-                    .setCaller(r.app.getThread())\n-                    .setResolvedType(r.resolvedType)\n-                    .setActivityInfo(aInfo)\n-                    .setResultTo(resultTo != null ? resultTo.token : null)\n-                    .setResultWho(resultWho)\n-                    .setRequestCode(requestCode)\n-                    .setCallingPid(-1)\n-                    .setCallingUid(r.launchedFromUid)\n-                    .setCallingPackage(r.launchedFromPackage)\n-                    .setCallingFeatureId(r.launchedFromFeatureId)\n-                    .setRealCallingPid(-1)\n-                    .setRealCallingUid(r.launchedFromUid)\n-                    .setActivityOptions(options)\n-                    .execute();\n-            Binder.restoreCallingIdentity(origId);\n-\n-            r.finishing = wasFinishing;\n-            if (res != ActivityManager.START_SUCCESS) {\n-                return false;\n+            try {\n+                if (options == null) {\n+                    options = new SafeActivityOptions(ActivityOptions.makeBasic());\n+                }\n+                // Fixes b/230492947\n+                // Prevents background activity launch through #startNextMatchingActivity\n+                // An activity going into the background could still go back to the foreground\n+                // if the intent used matches both:\n+                // - the activity in the background\n+                // - a second activity.\n+                options.getOptions(r).setAvoidMoveToFront();\n+                final int res = getActivityStartController()\n+                        .obtainStarter(intent, \"startNextMatchingActivity\")\n+                        .setCaller(r.app.getThread())\n+                        .setResolvedType(r.resolvedType)\n+                        .setActivityInfo(aInfo)\n+                        .setResultTo(resultTo != null ? resultTo.token : null)\n+                        .setResultWho(resultWho)\n+                        .setRequestCode(requestCode)\n+                        .setCallingPid(-1)\n+                        .setCallingUid(r.launchedFromUid)\n+                        .setCallingPackage(r.launchedFromPackage)\n+                        .setCallingFeatureId(r.launchedFromFeatureId)\n+                        .setRealCallingPid(-1)\n+                        .setRealCallingUid(r.launchedFromUid)\n+                        .setActivityOptions(options)\n+                        .execute();\n+                r.finishing = wasFinishing;\n+                return res == ActivityManager.START_SUCCESS;\n+            } finally {\n+                Binder.restoreCallingIdentity(origId);\n             }\n-            return true;\n         }\n     }\n \n",
                            "downstream_patch_tokens": {
                                "openai": 854,
                                "general": {
                                    "word_based": 279,
                                    "char_based": 972
                                },
                                "gemini": 1042
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "e1edaa27ea2f6911977556c5bba876a2319d5e2d",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit e1edaa27ea2f6911977556c5bba876a2319d5e2d\nAuthor: Christophe Pinelli <cpinelli@google.com>\nDate:   Thu Oct 19 14:48:57 2023 +0000\n\n    Restrict activity launch when caller is running in the background\n    \n    Test: atest BackgroundActivityLaunchTest#testBackgroundActivityBlockedInStartNextMatchingActivity\n    Bug: 230492947\n    Merged-In: Ie3bc5bd88bfd3bd4777210c0740ad34ea6d3311e\n    Change-Id: Ic88dd1e79b867b44cdcd6fc86650f5de6ebcc23d\n\ndiff --git a/services/core/java/com/android/server/wm/ActivityTaskManagerService.java b/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\nindex 6b65922c198e..dd3a3c5e6bbf 100644\n--- a/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\n+++ b/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\n@@ -1412,7 +1412,12 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n \n             final long origId = Binder.clearCallingIdentity();\n             // TODO(b/64750076): Check if calling pid should really be -1.\n-            final int res = getActivityStartController()\n+            try {\n+                if (options == null) {\n+                    options = new SafeActivityOptions(ActivityOptions.makeBasic());\n+                }\n+                options.getOptions(r).setAvoidMoveToFront();\n+                final int res = getActivityStartController()\n                     .obtainStarter(intent, \"startNextMatchingActivity\")\n                     .setCaller(r.app.getThread())\n                     .setResolvedType(r.resolvedType)\n@@ -1428,13 +1433,11 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n                     .setRealCallingUid(r.launchedFromUid)\n                     .setActivityOptions(options)\n                     .execute();\n-            Binder.restoreCallingIdentity(origId);\n-\n-            r.finishing = wasFinishing;\n-            if (res != ActivityManager.START_SUCCESS) {\n-                return false;\n+                r.finishing = wasFinishing;\n+                return res == ActivityManager.START_SUCCESS;\n+            } finally {\n+                Binder.restoreCallingIdentity(origId);\n             }\n-            return true;\n         }\n     }\n \n",
                            "downstream_patch_tokens": {
                                "openai": 539,
                                "general": {
                                    "word_based": 183,
                                    "char_based": 561
                                },
                                "gemini": 682
                            }
                        }
                    ]
                }
            ]
        }
    ],
    "vulnerabilities_with_all_successful_patches": [
        {
            "id": "ASB-A-300476626",
            "aliases": [
                "A-300476626",
                "CVE-2024-0018"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-300476626",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "de2ad0fad97d6d97d1e01f0e8d8309536eb268b4"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From de2ad0fad97d6d97d1e01f0e8d8309536eb268b4 Mon Sep 17 00:00:00 2001\nFrom: Songyue Han <songyueh@google.com>\nDate: Tue, 3 Oct 2023 22:40:14 +0000\nSubject: [PATCH] Fix convertYUV420Planar16ToY410 overflow issue for\n unsupported cropwidth.\n\nBug: 300476626\nTest: color_conversion_fuzzer\nChange-Id: I8631426188af3c5f9b6c1ff6a0039254c252f733\n---\n media/libstagefright/colorconversion/ColorConverter.cpp | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\ndiff --git a/media/libstagefright/colorconversion/ColorConverter.cpp b/media/libstagefright/colorconversion/ColorConverter.cpp\nindex 6c26c284ad..e079765d6d 100644\n--- a/media/libstagefright/colorconversion/ColorConverter.cpp\n+++ b/media/libstagefright/colorconversion/ColorConverter.cpp\n@@ -1550,7 +1550,8 @@ status_t ColorConverter::convertYUV420Planar16ToY410(\n \n         uint32_t u01, v01, y01, y23, y45, y67, uv0, uv1;\n         size_t x = 0;\n-        for (; x < src.cropWidth() - 3; x += 4) {\n+        // x % 4 is always 0 so x + 3 will never overflow.\n+        for (; x + 3 < src.cropWidth(); x += 4) {\n             u01 = *((uint32_t*)ptr_u); ptr_u += 2;\n             v01 = *((uint32_t*)ptr_v); ptr_v += 2;\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 426,
                        "general": {
                            "word_based": 143,
                            "char_based": 299
                        },
                        "gemini": 551
                    },
                    "total_downstream_versions_tested": 5,
                    "successful_patches": 5,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "11",
                            "branch_used": "android11-release",
                            "downstream_patch": "aa8298ec8eb903e1e3dd915fa24f32e1aea1f76c",
                            "repo_path": "android_repos/av",
                            "result": "success",
                            "downstream_patch_content": "commit aa8298ec8eb903e1e3dd915fa24f32e1aea1f76c\nAuthor: Songyue Han <songyueh@google.com>\nDate:   Tue Oct 3 22:40:14 2023 +0000\n\n    Fix convertYUV420Planar16ToY410 overflow issue for unsupported cropwidth.\n    \n    Bug: 300476626\n    Test: color_conversion_fuzzer\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:de2ad0fad97d6d97d1e01f0e8d8309536eb268b4)\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:745ab99f7343bc236b88b9d63cd7b06ab192f9e9)\n    Merged-In: I8631426188af3c5f9b6c1ff6a0039254c252f733\n    Change-Id: I8631426188af3c5f9b6c1ff6a0039254c252f733\n\ndiff --git a/media/libstagefright/colorconversion/ColorConverter.cpp b/media/libstagefright/colorconversion/ColorConverter.cpp\nindex c7dc415d8b..9804887144 100644\n--- a/media/libstagefright/colorconversion/ColorConverter.cpp\n+++ b/media/libstagefright/colorconversion/ColorConverter.cpp\n@@ -648,7 +648,8 @@ status_t ColorConverter::convertYUV420Planar16ToY410(\n \n         uint32_t u01, v01, y01, y23, y45, y67, uv0, uv1;\n         size_t x = 0;\n-        for (; x < src.cropWidth() - 3; x += 4) {\n+        // x % 4 is always 0 so x + 3 will never overflow.\n+        for (; x + 3 < src.cropWidth(); x += 4) {\n             u01 = *((uint32_t*)ptr_u); ptr_u += 2;\n             v01 = *((uint32_t*)ptr_v); ptr_v += 2;\n \n",
                            "downstream_patch_tokens": {
                                "openai": 485,
                                "general": {
                                    "word_based": 142,
                                    "char_based": 336
                                },
                                "gemini": 641
                            }
                        },
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "aa8298ec8eb903e1e3dd915fa24f32e1aea1f76c",
                            "repo_path": "android_repos/av",
                            "result": "success",
                            "downstream_patch_content": "commit aa8298ec8eb903e1e3dd915fa24f32e1aea1f76c\nAuthor: Songyue Han <songyueh@google.com>\nDate:   Tue Oct 3 22:40:14 2023 +0000\n\n    Fix convertYUV420Planar16ToY410 overflow issue for unsupported cropwidth.\n    \n    Bug: 300476626\n    Test: color_conversion_fuzzer\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:de2ad0fad97d6d97d1e01f0e8d8309536eb268b4)\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:745ab99f7343bc236b88b9d63cd7b06ab192f9e9)\n    Merged-In: I8631426188af3c5f9b6c1ff6a0039254c252f733\n    Change-Id: I8631426188af3c5f9b6c1ff6a0039254c252f733\n\ndiff --git a/media/libstagefright/colorconversion/ColorConverter.cpp b/media/libstagefright/colorconversion/ColorConverter.cpp\nindex c7dc415d8b..9804887144 100644\n--- a/media/libstagefright/colorconversion/ColorConverter.cpp\n+++ b/media/libstagefright/colorconversion/ColorConverter.cpp\n@@ -648,7 +648,8 @@ status_t ColorConverter::convertYUV420Planar16ToY410(\n \n         uint32_t u01, v01, y01, y23, y45, y67, uv0, uv1;\n         size_t x = 0;\n-        for (; x < src.cropWidth() - 3; x += 4) {\n+        // x % 4 is always 0 so x + 3 will never overflow.\n+        for (; x + 3 < src.cropWidth(); x += 4) {\n             u01 = *((uint32_t*)ptr_u); ptr_u += 2;\n             v01 = *((uint32_t*)ptr_v); ptr_v += 2;\n \n",
                            "downstream_patch_tokens": {
                                "openai": 485,
                                "general": {
                                    "word_based": 142,
                                    "char_based": 336
                                },
                                "gemini": 641
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "aa8298ec8eb903e1e3dd915fa24f32e1aea1f76c",
                            "repo_path": "android_repos/av",
                            "result": "success",
                            "downstream_patch_content": "commit aa8298ec8eb903e1e3dd915fa24f32e1aea1f76c\nAuthor: Songyue Han <songyueh@google.com>\nDate:   Tue Oct 3 22:40:14 2023 +0000\n\n    Fix convertYUV420Planar16ToY410 overflow issue for unsupported cropwidth.\n    \n    Bug: 300476626\n    Test: color_conversion_fuzzer\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:de2ad0fad97d6d97d1e01f0e8d8309536eb268b4)\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:745ab99f7343bc236b88b9d63cd7b06ab192f9e9)\n    Merged-In: I8631426188af3c5f9b6c1ff6a0039254c252f733\n    Change-Id: I8631426188af3c5f9b6c1ff6a0039254c252f733\n\ndiff --git a/media/libstagefright/colorconversion/ColorConverter.cpp b/media/libstagefright/colorconversion/ColorConverter.cpp\nindex c7dc415d8b..9804887144 100644\n--- a/media/libstagefright/colorconversion/ColorConverter.cpp\n+++ b/media/libstagefright/colorconversion/ColorConverter.cpp\n@@ -648,7 +648,8 @@ status_t ColorConverter::convertYUV420Planar16ToY410(\n \n         uint32_t u01, v01, y01, y23, y45, y67, uv0, uv1;\n         size_t x = 0;\n-        for (; x < src.cropWidth() - 3; x += 4) {\n+        // x % 4 is always 0 so x + 3 will never overflow.\n+        for (; x + 3 < src.cropWidth(); x += 4) {\n             u01 = *((uint32_t*)ptr_u); ptr_u += 2;\n             v01 = *((uint32_t*)ptr_v); ptr_v += 2;\n \n",
                            "downstream_patch_tokens": {
                                "openai": 485,
                                "general": {
                                    "word_based": 142,
                                    "char_based": 336
                                },
                                "gemini": 641
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "aa8298ec8eb903e1e3dd915fa24f32e1aea1f76c",
                            "repo_path": "android_repos/av",
                            "result": "success",
                            "downstream_patch_content": "commit aa8298ec8eb903e1e3dd915fa24f32e1aea1f76c\nAuthor: Songyue Han <songyueh@google.com>\nDate:   Tue Oct 3 22:40:14 2023 +0000\n\n    Fix convertYUV420Planar16ToY410 overflow issue for unsupported cropwidth.\n    \n    Bug: 300476626\n    Test: color_conversion_fuzzer\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:de2ad0fad97d6d97d1e01f0e8d8309536eb268b4)\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:745ab99f7343bc236b88b9d63cd7b06ab192f9e9)\n    Merged-In: I8631426188af3c5f9b6c1ff6a0039254c252f733\n    Change-Id: I8631426188af3c5f9b6c1ff6a0039254c252f733\n\ndiff --git a/media/libstagefright/colorconversion/ColorConverter.cpp b/media/libstagefright/colorconversion/ColorConverter.cpp\nindex c7dc415d8b..9804887144 100644\n--- a/media/libstagefright/colorconversion/ColorConverter.cpp\n+++ b/media/libstagefright/colorconversion/ColorConverter.cpp\n@@ -648,7 +648,8 @@ status_t ColorConverter::convertYUV420Planar16ToY410(\n \n         uint32_t u01, v01, y01, y23, y45, y67, uv0, uv1;\n         size_t x = 0;\n-        for (; x < src.cropWidth() - 3; x += 4) {\n+        // x % 4 is always 0 so x + 3 will never overflow.\n+        for (; x + 3 < src.cropWidth(); x += 4) {\n             u01 = *((uint32_t*)ptr_u); ptr_u += 2;\n             v01 = *((uint32_t*)ptr_v); ptr_v += 2;\n \n",
                            "downstream_patch_tokens": {
                                "openai": 485,
                                "general": {
                                    "word_based": 142,
                                    "char_based": 336
                                },
                                "gemini": 641
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "aa8298ec8eb903e1e3dd915fa24f32e1aea1f76c",
                            "repo_path": "android_repos/av",
                            "result": "success",
                            "downstream_patch_content": "commit aa8298ec8eb903e1e3dd915fa24f32e1aea1f76c\nAuthor: Songyue Han <songyueh@google.com>\nDate:   Tue Oct 3 22:40:14 2023 +0000\n\n    Fix convertYUV420Planar16ToY410 overflow issue for unsupported cropwidth.\n    \n    Bug: 300476626\n    Test: color_conversion_fuzzer\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:de2ad0fad97d6d97d1e01f0e8d8309536eb268b4)\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:745ab99f7343bc236b88b9d63cd7b06ab192f9e9)\n    Merged-In: I8631426188af3c5f9b6c1ff6a0039254c252f733\n    Change-Id: I8631426188af3c5f9b6c1ff6a0039254c252f733\n\ndiff --git a/media/libstagefright/colorconversion/ColorConverter.cpp b/media/libstagefright/colorconversion/ColorConverter.cpp\nindex c7dc415d8b..9804887144 100644\n--- a/media/libstagefright/colorconversion/ColorConverter.cpp\n+++ b/media/libstagefright/colorconversion/ColorConverter.cpp\n@@ -648,7 +648,8 @@ status_t ColorConverter::convertYUV420Planar16ToY410(\n \n         uint32_t u01, v01, y01, y23, y45, y67, uv0, uv1;\n         size_t x = 0;\n-        for (; x < src.cropWidth() - 3; x += 4) {\n+        // x % 4 is always 0 so x + 3 will never overflow.\n+        for (; x + 3 < src.cropWidth(); x += 4) {\n             u01 = *((uint32_t*)ptr_u); ptr_u += 2;\n             v01 = *((uint32_t*)ptr_v); ptr_v += 2;\n \n",
                            "downstream_patch_tokens": {
                                "openai": 485,
                                "general": {
                                    "word_based": 142,
                                    "char_based": 336
                                },
                                "gemini": 641
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-300903792",
            "aliases": [
                "A-300903792",
                "CVE-2024-0035"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-300903792",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "b9807f01748a669d738c94d6ad5319abea8608f5"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From b9807f01748a669d738c94d6ad5319abea8608f5 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Fabi=C3=A1n=20Kozynski?= <kozynski@google.com>\nDate: Fri, 13 Oct 2023 11:58:10 -0400\nSubject: [PATCH] Unbind TileService onNullBinding\n\nTest: atest TileLifecycleManagerTest\nTest: manual: adb shell dumpsys activity service\nTest: sts test\nBug: 300903792\nChange-Id: Ia8126ac65432b124683960e3ebf47301ba6172a1\n---\n .../qs/external/TileLifecycleManager.java     |  5 ++++\n .../qs/external/TileLifecycleManagerTest.java | 25 +++++++++++++++++++\n 2 files changed, 30 insertions(+)\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java b/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\nindex 78f2da53cd43..789a1e401ae6 100644\n--- a/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\n+++ b/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\n@@ -278,6 +278,11 @@ public class TileLifecycleManager extends BroadcastReceiver implements\n         handlePendingMessages();\n     }\n \n+    @Override\n+    public void onNullBinding(ComponentName name) {\n+        executeSetBindService(false);\n+    }\n+\n     @Override\n     public void onServiceDisconnected(ComponentName name) {\n         if (DEBUG) Log.d(TAG, \"onServiceDisconnected \" + name);\ndiff --git a/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java b/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\nindex 6cc52d70611a..fbd63c6bbdae 100644\n--- a/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\n+++ b/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\n@@ -403,6 +403,31 @@ public class TileLifecycleManagerTest extends SysuiTestCase {\n         verify(falseContext).bindServiceAsUser(any(), any(), eq(flags), any());\n     }\n \n+    @Test\n+    public void testNullBindingCallsUnbind() {\n+        Context mockContext = mock(Context.class);\n+        // Binding has to succeed\n+        when(mockContext.bindServiceAsUser(any(), any(), anyInt(), any())).thenReturn(true);\n+        TileLifecycleManager manager = new TileLifecycleManager(mHandler, mockContext,\n+                mock(IQSService.class),\n+                mMockPackageManagerAdapter,\n+                mMockBroadcastDispatcher,\n+                mTileServiceIntent,\n+                mUser,\n+                mActivityManager,\n+                mExecutor);\n+\n+        manager.executeSetBindService(true);\n+        mExecutor.runAllReady();\n+\n+        ArgumentCaptor<ServiceConnection> captor = ArgumentCaptor.forClass(ServiceConnection.class);\n+        verify(mockContext).bindServiceAsUser(any(), captor.capture(), anyInt(), any());\n+\n+        captor.getValue().onNullBinding(mTileServiceComponentName);\n+        mExecutor.runAllReady();\n+        verify(mockContext).unbindService(captor.getValue());\n+    }\n+\n     private void mockChangeEnabled(long changeId, boolean enabled) {\n         doReturn(enabled).when(() -> CompatChanges.isChangeEnabled(eq(changeId), anyString(),\n                 any(UserHandle.class)));\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 820,
                        "general": {
                            "word_based": 312,
                            "char_based": 804
                        },
                        "gemini": 1044
                    },
                    "total_downstream_versions_tested": 5,
                    "successful_patches": 5,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "11",
                            "branch_used": "android11-release",
                            "downstream_patch": "7bf830ca0df71496cd47563e138b8712918e0476",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 7bf830ca0df71496cd47563e138b8712918e0476\nAuthor: Fabi\u00e1n Kozynski <kozynski@google.com>\nDate:   Fri Oct 13 16:19:27 2023 -0400\n\n    Unbind TileService onNullBinding\n    \n    Test: atest TileLifecycleManagerTest\n    Test: manual: adb shell dumpsys activity service\n    Test: sts test\n    Bug: 300903792\n    Change-Id: Ia8126ac65432b124683960e3ebf47301ba6172a1\n    Merged-In: Ia8126ac65432b124683960e3ebf47301ba6172a1\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java b/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\nindex aa51771864b2..68a83f872983 100644\n--- a/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\n+++ b/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\n@@ -220,6 +220,11 @@ public class TileLifecycleManager extends BroadcastReceiver implements\n         handlePendingMessages();\n     }\n \n+    @Override\n+    public void onNullBinding(ComponentName name) {\n+        setBindService(false);\n+    }\n+\n     @Override\n     public void onServiceDisconnected(ComponentName name) {\n         if (DEBUG) Log.d(TAG, \"onServiceDisconnected \" + name);\ndiff --git a/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java b/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\nindex 42fd288d94ee..c03b2eeee577 100644\n--- a/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\n+++ b/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\n@@ -22,13 +22,16 @@ import static org.junit.Assert.assertEquals;\n import static org.mockito.Mockito.any;\n import static org.mockito.Mockito.anyInt;\n import static org.mockito.Mockito.anyString;\n+import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.never;\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n import android.content.ComponentName;\n+import android.content.Context;\n import android.content.Intent;\n+import android.content.ServiceConnection;\n import android.content.pm.PackageInfo;\n import android.content.pm.ServiceInfo;\n import android.net.Uri;\n@@ -51,7 +54,7 @@ import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n-import org.mockito.Mockito;\n+import org.mockito.ArgumentCaptor;\n \n @SmallTest\n @RunWith(AndroidJUnit4.class)\n@@ -59,10 +62,10 @@ public class TileLifecycleManagerTest extends SysuiTestCase {\n     private static final int TEST_FAIL_TIMEOUT = 5000;\n \n     private final PackageManagerAdapter mMockPackageManagerAdapter =\n-            Mockito.mock(PackageManagerAdapter.class);\n+            mock(PackageManagerAdapter.class);\n     private final BroadcastDispatcher mMockBroadcastDispatcher =\n-            Mockito.mock(BroadcastDispatcher.class);\n-    private final IQSTileService.Stub mMockTileService = Mockito.mock(IQSTileService.Stub.class);\n+            mock(BroadcastDispatcher.class);\n+    private final IQSTileService.Stub mMockTileService = mock(IQSTileService.Stub.class);\n     private ComponentName mTileServiceComponentName;\n     private Intent mTileServiceIntent;\n     private UserHandle mUser;\n@@ -87,7 +90,7 @@ public class TileLifecycleManagerTest extends SysuiTestCase {\n         mThread.start();\n         mHandler = Handler.createAsync(mThread.getLooper());\n         mStateManager = new TileLifecycleManager(mHandler, mContext,\n-                Mockito.mock(IQSService.class), new Tile(),\n+                mock(IQSService.class), new Tile(),\n                 mTileServiceIntent,\n                 mUser,\n                 mMockPackageManagerAdapter,\n@@ -247,4 +250,26 @@ public class TileLifecycleManagerTest extends SysuiTestCase {\n     public void testToggleableTile() throws Exception {\n         assertTrue(mStateManager.isToggleableTile());\n     }\n+\n+    @Test\n+    public void testNullBindingCallsUnbind() {\n+        Context mockContext = mock(Context.class);\n+        // Binding has to succeed\n+        when(mockContext.bindServiceAsUser(any(), any(), anyInt(), any())).thenReturn(true);\n+        TileLifecycleManager manager = new TileLifecycleManager(mHandler, mockContext,\n+                mock(IQSService.class),\n+                new Tile(),\n+                mTileServiceIntent,\n+                mUser,\n+                mMockPackageManagerAdapter,\n+                mMockBroadcastDispatcher);\n+\n+        manager.setBindService(true);\n+\n+        ArgumentCaptor<ServiceConnection> captor = ArgumentCaptor.forClass(ServiceConnection.class);\n+        verify(mockContext).bindServiceAsUser(any(), captor.capture(), anyInt(), any());\n+\n+        captor.getValue().onNullBinding(mTileServiceComponentName);\n+        verify(mockContext).unbindService(captor.getValue());\n+    }\n }\n",
                            "downstream_patch_tokens": {
                                "openai": 1129,
                                "general": {
                                    "word_based": 479,
                                    "char_based": 1226
                                },
                                "gemini": 1474
                            }
                        },
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "7bf830ca0df71496cd47563e138b8712918e0476",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 7bf830ca0df71496cd47563e138b8712918e0476\nAuthor: Fabi\u00e1n Kozynski <kozynski@google.com>\nDate:   Fri Oct 13 16:19:27 2023 -0400\n\n    Unbind TileService onNullBinding\n    \n    Test: atest TileLifecycleManagerTest\n    Test: manual: adb shell dumpsys activity service\n    Test: sts test\n    Bug: 300903792\n    Change-Id: Ia8126ac65432b124683960e3ebf47301ba6172a1\n    Merged-In: Ia8126ac65432b124683960e3ebf47301ba6172a1\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java b/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\nindex aa51771864b2..68a83f872983 100644\n--- a/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\n+++ b/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\n@@ -220,6 +220,11 @@ public class TileLifecycleManager extends BroadcastReceiver implements\n         handlePendingMessages();\n     }\n \n+    @Override\n+    public void onNullBinding(ComponentName name) {\n+        setBindService(false);\n+    }\n+\n     @Override\n     public void onServiceDisconnected(ComponentName name) {\n         if (DEBUG) Log.d(TAG, \"onServiceDisconnected \" + name);\ndiff --git a/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java b/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\nindex 42fd288d94ee..c03b2eeee577 100644\n--- a/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\n+++ b/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\n@@ -22,13 +22,16 @@ import static org.junit.Assert.assertEquals;\n import static org.mockito.Mockito.any;\n import static org.mockito.Mockito.anyInt;\n import static org.mockito.Mockito.anyString;\n+import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.never;\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n import android.content.ComponentName;\n+import android.content.Context;\n import android.content.Intent;\n+import android.content.ServiceConnection;\n import android.content.pm.PackageInfo;\n import android.content.pm.ServiceInfo;\n import android.net.Uri;\n@@ -51,7 +54,7 @@ import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n-import org.mockito.Mockito;\n+import org.mockito.ArgumentCaptor;\n \n @SmallTest\n @RunWith(AndroidJUnit4.class)\n@@ -59,10 +62,10 @@ public class TileLifecycleManagerTest extends SysuiTestCase {\n     private static final int TEST_FAIL_TIMEOUT = 5000;\n \n     private final PackageManagerAdapter mMockPackageManagerAdapter =\n-            Mockito.mock(PackageManagerAdapter.class);\n+            mock(PackageManagerAdapter.class);\n     private final BroadcastDispatcher mMockBroadcastDispatcher =\n-            Mockito.mock(BroadcastDispatcher.class);\n-    private final IQSTileService.Stub mMockTileService = Mockito.mock(IQSTileService.Stub.class);\n+            mock(BroadcastDispatcher.class);\n+    private final IQSTileService.Stub mMockTileService = mock(IQSTileService.Stub.class);\n     private ComponentName mTileServiceComponentName;\n     private Intent mTileServiceIntent;\n     private UserHandle mUser;\n@@ -87,7 +90,7 @@ public class TileLifecycleManagerTest extends SysuiTestCase {\n         mThread.start();\n         mHandler = Handler.createAsync(mThread.getLooper());\n         mStateManager = new TileLifecycleManager(mHandler, mContext,\n-                Mockito.mock(IQSService.class), new Tile(),\n+                mock(IQSService.class), new Tile(),\n                 mTileServiceIntent,\n                 mUser,\n                 mMockPackageManagerAdapter,\n@@ -247,4 +250,26 @@ public class TileLifecycleManagerTest extends SysuiTestCase {\n     public void testToggleableTile() throws Exception {\n         assertTrue(mStateManager.isToggleableTile());\n     }\n+\n+    @Test\n+    public void testNullBindingCallsUnbind() {\n+        Context mockContext = mock(Context.class);\n+        // Binding has to succeed\n+        when(mockContext.bindServiceAsUser(any(), any(), anyInt(), any())).thenReturn(true);\n+        TileLifecycleManager manager = new TileLifecycleManager(mHandler, mockContext,\n+                mock(IQSService.class),\n+                new Tile(),\n+                mTileServiceIntent,\n+                mUser,\n+                mMockPackageManagerAdapter,\n+                mMockBroadcastDispatcher);\n+\n+        manager.setBindService(true);\n+\n+        ArgumentCaptor<ServiceConnection> captor = ArgumentCaptor.forClass(ServiceConnection.class);\n+        verify(mockContext).bindServiceAsUser(any(), captor.capture(), anyInt(), any());\n+\n+        captor.getValue().onNullBinding(mTileServiceComponentName);\n+        verify(mockContext).unbindService(captor.getValue());\n+    }\n }\n",
                            "downstream_patch_tokens": {
                                "openai": 1129,
                                "general": {
                                    "word_based": 479,
                                    "char_based": 1226
                                },
                                "gemini": 1474
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "7bf830ca0df71496cd47563e138b8712918e0476",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 7bf830ca0df71496cd47563e138b8712918e0476\nAuthor: Fabi\u00e1n Kozynski <kozynski@google.com>\nDate:   Fri Oct 13 16:19:27 2023 -0400\n\n    Unbind TileService onNullBinding\n    \n    Test: atest TileLifecycleManagerTest\n    Test: manual: adb shell dumpsys activity service\n    Test: sts test\n    Bug: 300903792\n    Change-Id: Ia8126ac65432b124683960e3ebf47301ba6172a1\n    Merged-In: Ia8126ac65432b124683960e3ebf47301ba6172a1\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java b/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\nindex aa51771864b2..68a83f872983 100644\n--- a/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\n+++ b/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\n@@ -220,6 +220,11 @@ public class TileLifecycleManager extends BroadcastReceiver implements\n         handlePendingMessages();\n     }\n \n+    @Override\n+    public void onNullBinding(ComponentName name) {\n+        setBindService(false);\n+    }\n+\n     @Override\n     public void onServiceDisconnected(ComponentName name) {\n         if (DEBUG) Log.d(TAG, \"onServiceDisconnected \" + name);\ndiff --git a/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java b/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\nindex 42fd288d94ee..c03b2eeee577 100644\n--- a/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\n+++ b/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\n@@ -22,13 +22,16 @@ import static org.junit.Assert.assertEquals;\n import static org.mockito.Mockito.any;\n import static org.mockito.Mockito.anyInt;\n import static org.mockito.Mockito.anyString;\n+import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.never;\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n import android.content.ComponentName;\n+import android.content.Context;\n import android.content.Intent;\n+import android.content.ServiceConnection;\n import android.content.pm.PackageInfo;\n import android.content.pm.ServiceInfo;\n import android.net.Uri;\n@@ -51,7 +54,7 @@ import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n-import org.mockito.Mockito;\n+import org.mockito.ArgumentCaptor;\n \n @SmallTest\n @RunWith(AndroidJUnit4.class)\n@@ -59,10 +62,10 @@ public class TileLifecycleManagerTest extends SysuiTestCase {\n     private static final int TEST_FAIL_TIMEOUT = 5000;\n \n     private final PackageManagerAdapter mMockPackageManagerAdapter =\n-            Mockito.mock(PackageManagerAdapter.class);\n+            mock(PackageManagerAdapter.class);\n     private final BroadcastDispatcher mMockBroadcastDispatcher =\n-            Mockito.mock(BroadcastDispatcher.class);\n-    private final IQSTileService.Stub mMockTileService = Mockito.mock(IQSTileService.Stub.class);\n+            mock(BroadcastDispatcher.class);\n+    private final IQSTileService.Stub mMockTileService = mock(IQSTileService.Stub.class);\n     private ComponentName mTileServiceComponentName;\n     private Intent mTileServiceIntent;\n     private UserHandle mUser;\n@@ -87,7 +90,7 @@ public class TileLifecycleManagerTest extends SysuiTestCase {\n         mThread.start();\n         mHandler = Handler.createAsync(mThread.getLooper());\n         mStateManager = new TileLifecycleManager(mHandler, mContext,\n-                Mockito.mock(IQSService.class), new Tile(),\n+                mock(IQSService.class), new Tile(),\n                 mTileServiceIntent,\n                 mUser,\n                 mMockPackageManagerAdapter,\n@@ -247,4 +250,26 @@ public class TileLifecycleManagerTest extends SysuiTestCase {\n     public void testToggleableTile() throws Exception {\n         assertTrue(mStateManager.isToggleableTile());\n     }\n+\n+    @Test\n+    public void testNullBindingCallsUnbind() {\n+        Context mockContext = mock(Context.class);\n+        // Binding has to succeed\n+        when(mockContext.bindServiceAsUser(any(), any(), anyInt(), any())).thenReturn(true);\n+        TileLifecycleManager manager = new TileLifecycleManager(mHandler, mockContext,\n+                mock(IQSService.class),\n+                new Tile(),\n+                mTileServiceIntent,\n+                mUser,\n+                mMockPackageManagerAdapter,\n+                mMockBroadcastDispatcher);\n+\n+        manager.setBindService(true);\n+\n+        ArgumentCaptor<ServiceConnection> captor = ArgumentCaptor.forClass(ServiceConnection.class);\n+        verify(mockContext).bindServiceAsUser(any(), captor.capture(), anyInt(), any());\n+\n+        captor.getValue().onNullBinding(mTileServiceComponentName);\n+        verify(mockContext).unbindService(captor.getValue());\n+    }\n }\n",
                            "downstream_patch_tokens": {
                                "openai": 1129,
                                "general": {
                                    "word_based": 479,
                                    "char_based": 1226
                                },
                                "gemini": 1474
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "3b93880c0b0052fe03c781a9768b81b098a353c0",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 3b93880c0b0052fe03c781a9768b81b098a353c0\nAuthor: Fabi\u00e1n Kozynski <kozynski@google.com>\nDate:   Fri Oct 13 16:19:27 2023 -0400\n\n    Unbind TileService onNullBinding\n    \n    Test: atest TileLifecycleManagerTest\n    Test: manual: adb shell dumpsys activity service\n    Test: sts test\n    Bug: 300903792\n    Change-Id: Ia8126ac65432b124683960e3ebf47301ba6172a1\n    Merged-In: Ia8126ac65432b124683960e3ebf47301ba6172a1\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java b/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\nindex a49d3fd16591..ea49c7006100 100644\n--- a/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\n+++ b/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\n@@ -242,6 +242,11 @@ public class TileLifecycleManager extends BroadcastReceiver implements\n         handlePendingMessages();\n     }\n \n+    @Override\n+    public void onNullBinding(ComponentName name) {\n+        setBindService(false);\n+    }\n+\n     @Override\n     public void onServiceDisconnected(ComponentName name) {\n         if (DEBUG) Log.d(TAG, \"onServiceDisconnected \" + name);\ndiff --git a/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java b/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\nindex 04b50d8d98c1..09f612fff16b 100644\n--- a/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\n+++ b/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\n@@ -290,6 +290,27 @@ public class TileLifecycleManagerTest extends SysuiTestCase {\n         verify(falseContext).unbindService(captor.getValue());\n     }\n \n+    @Test\n+    public void testNullBindingCallsUnbind() {\n+        Context mockContext = mock(Context.class);\n+        // Binding has to succeed\n+        when(mockContext.bindServiceAsUser(any(), any(), anyInt(), any())).thenReturn(true);\n+        TileLifecycleManager manager = new TileLifecycleManager(mHandler, mockContext,\n+                mock(IQSService.class),\n+                mMockPackageManagerAdapter,\n+                mMockBroadcastDispatcher,\n+                mTileServiceIntent,\n+                mUser);\n+\n+        manager.setBindService(true);\n+\n+        ArgumentCaptor<ServiceConnection> captor = ArgumentCaptor.forClass(ServiceConnection.class);\n+        verify(mockContext).bindServiceAsUser(any(), captor.capture(), anyInt(), any());\n+\n+        captor.getValue().onNullBinding(mTileServiceComponentName);\n+        verify(mockContext).unbindService(captor.getValue());\n+    }\n+\n     private static class TestContextWrapper extends ContextWrapper {\n         private IntentFilter mLastIntentFilter;\n         private int mLastFlag;\n",
                            "downstream_patch_tokens": {
                                "openai": 715,
                                "general": {
                                    "word_based": 265,
                                    "char_based": 708
                                },
                                "gemini": 927
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "7cf363d1fe7c474120ae1c4a96c6adc4c8946d9f",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 7cf363d1fe7c474120ae1c4a96c6adc4c8946d9f\nAuthor: Fabi\u00e1n Kozynski <kozynski@google.com>\nDate:   Fri Oct 13 11:58:10 2023 -0400\n\n    Unbind TileService onNullBinding\n    \n    Test: atest TileLifecycleManagerTest\n    Test: manual: adb shell dumpsys activity service\n    Test: sts test\n    Bug: 300903792\n    Change-Id: Ia8126ac65432b124683960e3ebf47301ba6172a1\n    Merged-In: Ia8126ac65432b124683960e3ebf47301ba6172a1\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java b/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\nindex 2469a98140e3..3750c44a4923 100644\n--- a/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\n+++ b/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\n@@ -280,6 +280,11 @@ public class TileLifecycleManager extends BroadcastReceiver implements\n         handlePendingMessages();\n     }\n \n+    @Override\n+    public void onNullBinding(ComponentName name) {\n+        executeSetBindService(false);\n+    }\n+\n     @Override\n     public void onServiceDisconnected(ComponentName name) {\n         if (DEBUG) Log.d(TAG, \"onServiceDisconnected \" + name);\ndiff --git a/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java b/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\nindex 67587e3a8914..37df93e4c809 100644\n--- a/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\n+++ b/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\n@@ -373,6 +373,30 @@ public class TileLifecycleManagerTest extends SysuiTestCase {\n         verify(falseContext).bindServiceAsUser(any(), any(), eq(flags), any());\n     }\n \n+    @Test\n+    public void testNullBindingCallsUnbind() {\n+        Context mockContext = mock(Context.class);\n+        // Binding has to succeed\n+        when(mockContext.bindServiceAsUser(any(), any(), anyInt(), any())).thenReturn(true);\n+        TileLifecycleManager manager = new TileLifecycleManager(mHandler, mockContext,\n+                mock(IQSService.class),\n+                mMockPackageManagerAdapter,\n+                mMockBroadcastDispatcher,\n+                mTileServiceIntent,\n+                mUser,\n+                mExecutor);\n+\n+        manager.executeSetBindService(true);\n+        mExecutor.runAllReady();\n+\n+        ArgumentCaptor<ServiceConnection> captor = ArgumentCaptor.forClass(ServiceConnection.class);\n+        verify(mockContext).bindServiceAsUser(any(), captor.capture(), anyInt(), any());\n+\n+        captor.getValue().onNullBinding(mTileServiceComponentName);\n+        mExecutor.runAllReady();\n+        verify(mockContext).unbindService(captor.getValue());\n+    }\n+\n     private void mockChangeEnabled(long changeId, boolean enabled) {\n         doReturn(enabled).when(() -> CompatChanges.isChangeEnabled(eq(changeId), anyString(),\n                 any(UserHandle.class)));\n",
                            "downstream_patch_tokens": {
                                "openai": 762,
                                "general": {
                                    "word_based": 279,
                                    "char_based": 754
                                },
                                "gemini": 984
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-281525042",
            "aliases": [
                "A-281525042",
                "CVE-2024-0053"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-281525042",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "df127e12b95a6c499b6fe1c4876eb54b90cd6327"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From df127e12b95a6c499b6fe1c4876eb54b90cd6327 Mon Sep 17 00:00:00 2001\nFrom: kumarashishg <kumarashishg@google.com>\nDate: Mon, 17 Jul 2023 12:01:18 +0000\nSubject: [PATCH] Resolve custom printer icon boundary exploit.\n\nBecause Settings grants the INTERACT_ACROSS_USERS_FULL permission, an exploit is possible where the third party print plugin service can pass other's User Icon URI. This CL provides a lightweight solution for parsing the image URI to detect profile exploitation.\n\nBug: 281525042\nTest: Build and flash the code. Try to reproduce the issue with\nmentioned steps in the bug\n\nChange-Id: Iaaa6fe2a627a265c4d1d7b843a033a132e1fe2ce\nMerged-In: Iaaa6fe2a627a265c4d1d7b843a033a132e1fe2ce\n---\n .../server/print/PrintManagerService.java     | 35 ++++++++++++++++++-\n 1 file changed, 34 insertions(+), 1 deletion(-)\n\ndiff --git a/services/print/java/com/android/server/print/PrintManagerService.java b/services/print/java/com/android/server/print/PrintManagerService.java\nindex 35b9bc3b1e06..4a8d73d23904 100644\n--- a/services/print/java/com/android/server/print/PrintManagerService.java\n+++ b/services/print/java/com/android/server/print/PrintManagerService.java\n@@ -254,12 +254,45 @@ public final class PrintManagerService extends SystemService {\n             }\n             final long identity = Binder.clearCallingIdentity();\n             try {\n-                return userState.getCustomPrinterIcon(printerId);\n+                Icon icon = userState.getCustomPrinterIcon(printerId);\n+                return validateIconUserBoundary(icon);\n             } finally {\n                 Binder.restoreCallingIdentity(identity);\n             }\n         }\n \n+        /**\n+         * Validates the custom printer icon to see if it's not in the calling user space.\n+         * If the condition is not met, return null. Otherwise, return the original icon.\n+         *\n+         * @param icon\n+         * @return icon (validated)\n+         */\n+        private Icon validateIconUserBoundary(Icon icon) {\n+            // Refer to Icon#getUriString for context. The URI string is invalid for icons of\n+            // incompatible types.\n+            if (icon != null && (icon.getType() == Icon.TYPE_URI\n+                    || icon.getType() == Icon.TYPE_URI_ADAPTIVE_BITMAP)) {\n+                String encodedUser = icon.getUri().getEncodedUserInfo();\n+\n+                // If there is no encoded user, the URI is calling into the calling user space\n+                if (encodedUser != null) {\n+                    int userId = Integer.parseInt(encodedUser);\n+                    // resolve encoded user\n+                    final int resolvedUserId = resolveCallingUserEnforcingPermissions(userId);\n+\n+                    synchronized (mLock) {\n+                        // Only the current group members can get the printer icons.\n+                        if (resolveCallingProfileParentLocked(resolvedUserId)\n+                                != getCurrentUserId()) {\n+                            return null;\n+                        }\n+                    }\n+                }\n+            }\n+            return icon;\n+        }\n+\n         @Override\n         public void cancelPrintJob(PrintJobId printJobId, int appId, int userId) {\n             if (printJobId == null) {\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 762,
                        "general": {
                            "word_based": 326,
                            "char_based": 825
                        },
                        "gemini": 940
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "0e0693ca9cb408d0dc82f6c6b3feb453fc8ddd83",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 0e0693ca9cb408d0dc82f6c6b3feb453fc8ddd83\nAuthor: kumarashishg <kumarashishg@google.com>\nDate:   Mon Jul 17 12:01:18 2023 +0000\n\n    Resolve custom printer icon boundary exploit.\n    \n    Because Settings grants the INTERACT_ACROSS_USERS_FULL permission, an exploit is possible where the third party print plugin service can pass other's User Icon URI. This CL provides a lightweight solution for parsing the image URI to detect profile exploitation.\n    \n    Bug: 281525042\n    Test: Build and flash the code. Try to reproduce the issue with\n    mentioned steps in the bug\n    \n    Change-Id: Iaaa6fe2a627a265c4d1d7b843a033a132e1fe2ce\n    Merged-In: Iaaa6fe2a627a265c4d1d7b843a033a132e1fe2ce\n\ndiff --git a/services/print/java/com/android/server/print/PrintManagerService.java b/services/print/java/com/android/server/print/PrintManagerService.java\nindex 1cdcbd87c1f5..1302b905573b 100644\n--- a/services/print/java/com/android/server/print/PrintManagerService.java\n+++ b/services/print/java/com/android/server/print/PrintManagerService.java\n@@ -254,12 +254,45 @@ public final class PrintManagerService extends SystemService {\n             }\n             final long identity = Binder.clearCallingIdentity();\n             try {\n-                return userState.getCustomPrinterIcon(printerId);\n+                Icon icon = userState.getCustomPrinterIcon(printerId);\n+                return validateIconUserBoundary(icon);\n             } finally {\n                 Binder.restoreCallingIdentity(identity);\n             }\n         }\n \n+        /**\n+         * Validates the custom printer icon to see if it's not in the calling user space.\n+         * If the condition is not met, return null. Otherwise, return the original icon.\n+         *\n+         * @param icon\n+         * @return icon (validated)\n+         */\n+        private Icon validateIconUserBoundary(Icon icon) {\n+            // Refer to Icon#getUriString for context. The URI string is invalid for icons of\n+            // incompatible types.\n+            if (icon != null && (icon.getType() == Icon.TYPE_URI\n+                    || icon.getType() == Icon.TYPE_URI_ADAPTIVE_BITMAP)) {\n+                String encodedUser = icon.getUri().getEncodedUserInfo();\n+\n+                // If there is no encoded user, the URI is calling into the calling user space\n+                if (encodedUser != null) {\n+                    int userId = Integer.parseInt(encodedUser);\n+                    // resolve encoded user\n+                    final int resolvedUserId = resolveCallingUserEnforcingPermissions(userId);\n+\n+                    synchronized (mLock) {\n+                        // Only the current group members can get the printer icons.\n+                        if (resolveCallingProfileParentLocked(resolvedUserId)\n+                                != getCurrentUserId()) {\n+                            return null;\n+                        }\n+                    }\n+                }\n+            }\n+            return icon;\n+        }\n+\n         @Override\n         public void cancelPrintJob(PrintJobId printJobId, int appId, int userId) {\n             if (printJobId == null) {\n",
                            "downstream_patch_tokens": {
                                "openai": 704,
                                "general": {
                                    "word_based": 299,
                                    "char_based": 787
                                },
                                "gemini": 868
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "7cfc47271c77b2fa5e9fa05fcf5c315dfb778dec",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 7cfc47271c77b2fa5e9fa05fcf5c315dfb778dec\nAuthor: kumarashishg <kumarashishg@google.com>\nDate:   Mon Jul 17 12:01:18 2023 +0000\n\n    Resolve custom printer icon boundary exploit.\n    \n    Because Settings grants the INTERACT_ACROSS_USERS_FULL permission, an exploit is possible where the third party print plugin service can pass other's User Icon URI. This CL provides a lightweight solution for parsing the image URI to detect profile exploitation.\n    \n    Bug: 281525042\n    Test: Build and flash the code. Try to reproduce the issue with\n    mentioned steps in the bug\n    \n    Change-Id: Iaaa6fe2a627a265c4d1d7b843a033a132e1fe2ce\n    Merged-In: Iaaa6fe2a627a265c4d1d7b843a033a132e1fe2ce\n\ndiff --git a/services/print/java/com/android/server/print/PrintManagerService.java b/services/print/java/com/android/server/print/PrintManagerService.java\nindex 1cdcbd87c1f5..1302b905573b 100644\n--- a/services/print/java/com/android/server/print/PrintManagerService.java\n+++ b/services/print/java/com/android/server/print/PrintManagerService.java\n@@ -254,12 +254,45 @@ public final class PrintManagerService extends SystemService {\n             }\n             final long identity = Binder.clearCallingIdentity();\n             try {\n-                return userState.getCustomPrinterIcon(printerId);\n+                Icon icon = userState.getCustomPrinterIcon(printerId);\n+                return validateIconUserBoundary(icon);\n             } finally {\n                 Binder.restoreCallingIdentity(identity);\n             }\n         }\n \n+        /**\n+         * Validates the custom printer icon to see if it's not in the calling user space.\n+         * If the condition is not met, return null. Otherwise, return the original icon.\n+         *\n+         * @param icon\n+         * @return icon (validated)\n+         */\n+        private Icon validateIconUserBoundary(Icon icon) {\n+            // Refer to Icon#getUriString for context. The URI string is invalid for icons of\n+            // incompatible types.\n+            if (icon != null && (icon.getType() == Icon.TYPE_URI\n+                    || icon.getType() == Icon.TYPE_URI_ADAPTIVE_BITMAP)) {\n+                String encodedUser = icon.getUri().getEncodedUserInfo();\n+\n+                // If there is no encoded user, the URI is calling into the calling user space\n+                if (encodedUser != null) {\n+                    int userId = Integer.parseInt(encodedUser);\n+                    // resolve encoded user\n+                    final int resolvedUserId = resolveCallingUserEnforcingPermissions(userId);\n+\n+                    synchronized (mLock) {\n+                        // Only the current group members can get the printer icons.\n+                        if (resolveCallingProfileParentLocked(resolvedUserId)\n+                                != getCurrentUserId()) {\n+                            return null;\n+                        }\n+                    }\n+                }\n+            }\n+            return icon;\n+        }\n+\n         @Override\n         public void cancelPrintJob(PrintJobId printJobId, int appId, int userId) {\n             if (printJobId == null) {\n",
                            "downstream_patch_tokens": {
                                "openai": 704,
                                "general": {
                                    "word_based": 299,
                                    "char_based": 787
                                },
                                "gemini": 869
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "39f5737626ca644f41fda890c12518ce51875835",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 39f5737626ca644f41fda890c12518ce51875835\nAuthor: kumarashishg <kumarashishg@google.com>\nDate:   Mon Jul 17 12:01:18 2023 +0000\n\n    Resolve custom printer icon boundary exploit.\n    \n    Because Settings grants the INTERACT_ACROSS_USERS_FULL permission, an exploit is possible where the third party print plugin service can pass other's User Icon URI. This CL provides a lightweight solution for parsing the image URI to detect profile exploitation.\n    \n    Bug: 281525042\n    Test: Build and flash the code. Try to reproduce the issue with\n    mentioned steps in the bug\n    \n    Change-Id: Iaaa6fe2a627a265c4d1d7b843a033a132e1fe2ce\n    Merged-In: Iaaa6fe2a627a265c4d1d7b843a033a132e1fe2ce\n\ndiff --git a/services/print/java/com/android/server/print/PrintManagerService.java b/services/print/java/com/android/server/print/PrintManagerService.java\nindex 66524edf61ed..1386bbff6cab 100644\n--- a/services/print/java/com/android/server/print/PrintManagerService.java\n+++ b/services/print/java/com/android/server/print/PrintManagerService.java\n@@ -254,12 +254,45 @@ public final class PrintManagerService extends SystemService {\n             }\n             final long identity = Binder.clearCallingIdentity();\n             try {\n-                return userState.getCustomPrinterIcon(printerId);\n+                Icon icon = userState.getCustomPrinterIcon(printerId);\n+                return validateIconUserBoundary(icon);\n             } finally {\n                 Binder.restoreCallingIdentity(identity);\n             }\n         }\n \n+        /**\n+         * Validates the custom printer icon to see if it's not in the calling user space.\n+         * If the condition is not met, return null. Otherwise, return the original icon.\n+         *\n+         * @param icon\n+         * @return icon (validated)\n+         */\n+        private Icon validateIconUserBoundary(Icon icon) {\n+            // Refer to Icon#getUriString for context. The URI string is invalid for icons of\n+            // incompatible types.\n+            if (icon != null && (icon.getType() == Icon.TYPE_URI\n+                    || icon.getType() == Icon.TYPE_URI_ADAPTIVE_BITMAP)) {\n+                String encodedUser = icon.getUri().getEncodedUserInfo();\n+\n+                // If there is no encoded user, the URI is calling into the calling user space\n+                if (encodedUser != null) {\n+                    int userId = Integer.parseInt(encodedUser);\n+                    // resolve encoded user\n+                    final int resolvedUserId = resolveCallingUserEnforcingPermissions(userId);\n+\n+                    synchronized (mLock) {\n+                        // Only the current group members can get the printer icons.\n+                        if (resolveCallingProfileParentLocked(resolvedUserId)\n+                                != getCurrentUserId()) {\n+                            return null;\n+                        }\n+                    }\n+                }\n+            }\n+            return icon;\n+        }\n+\n         @Override\n         public void cancelPrintJob(PrintJobId printJobId, int appId, int userId) {\n             if (printJobId == null) {\n",
                            "downstream_patch_tokens": {
                                "openai": 697,
                                "general": {
                                    "word_based": 299,
                                    "char_based": 787
                                },
                                "gemini": 868
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "c58f2b7b262eee49130f47d72247615f07af4a81",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit c58f2b7b262eee49130f47d72247615f07af4a81\nAuthor: kumarashishg <kumarashishg@google.com>\nDate:   Mon Jul 17 12:01:18 2023 +0000\n\n    Resolve custom printer icon boundary exploit.\n    \n    Because Settings grants the INTERACT_ACROSS_USERS_FULL permission, an exploit is possible where the third party print plugin service can pass other's User Icon URI. This CL provides a lightweight solution for parsing the image URI to detect profile exploitation.\n    \n    Bug: 281525042\n    Test: Build and flash the code. Try to reproduce the issue with\n    mentioned steps in the bug\n    \n    Change-Id: Iaaa6fe2a627a265c4d1d7b843a033a132e1fe2ce\n    Merged-In: Iaaa6fe2a627a265c4d1d7b843a033a132e1fe2ce\n\ndiff --git a/services/print/java/com/android/server/print/PrintManagerService.java b/services/print/java/com/android/server/print/PrintManagerService.java\nindex 35b9bc3b1e06..4a8d73d23904 100644\n--- a/services/print/java/com/android/server/print/PrintManagerService.java\n+++ b/services/print/java/com/android/server/print/PrintManagerService.java\n@@ -254,12 +254,45 @@ public final class PrintManagerService extends SystemService {\n             }\n             final long identity = Binder.clearCallingIdentity();\n             try {\n-                return userState.getCustomPrinterIcon(printerId);\n+                Icon icon = userState.getCustomPrinterIcon(printerId);\n+                return validateIconUserBoundary(icon);\n             } finally {\n                 Binder.restoreCallingIdentity(identity);\n             }\n         }\n \n+        /**\n+         * Validates the custom printer icon to see if it's not in the calling user space.\n+         * If the condition is not met, return null. Otherwise, return the original icon.\n+         *\n+         * @param icon\n+         * @return icon (validated)\n+         */\n+        private Icon validateIconUserBoundary(Icon icon) {\n+            // Refer to Icon#getUriString for context. The URI string is invalid for icons of\n+            // incompatible types.\n+            if (icon != null && (icon.getType() == Icon.TYPE_URI\n+                    || icon.getType() == Icon.TYPE_URI_ADAPTIVE_BITMAP)) {\n+                String encodedUser = icon.getUri().getEncodedUserInfo();\n+\n+                // If there is no encoded user, the URI is calling into the calling user space\n+                if (encodedUser != null) {\n+                    int userId = Integer.parseInt(encodedUser);\n+                    // resolve encoded user\n+                    final int resolvedUserId = resolveCallingUserEnforcingPermissions(userId);\n+\n+                    synchronized (mLock) {\n+                        // Only the current group members can get the printer icons.\n+                        if (resolveCallingProfileParentLocked(resolvedUserId)\n+                                != getCurrentUserId()) {\n+                            return null;\n+                        }\n+                    }\n+                }\n+            }\n+            return icon;\n+        }\n+\n         @Override\n         public void cancelPrintJob(PrintJobId printJobId, int appId, int userId) {\n             if (printJobId == null) {\n",
                            "downstream_patch_tokens": {
                                "openai": 705,
                                "general": {
                                    "word_based": 299,
                                    "char_based": 787
                                },
                                "gemini": 874
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-321326147",
            "aliases": [
                "A-321326147",
                "CVE-2024-31327"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-321326147",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "db9028d6eead72c9cd45da48087ec6d5f1ac9c5a"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From db9028d6eead72c9cd45da48087ec6d5f1ac9c5a Mon Sep 17 00:00:00 2001\nFrom: Devin Moore <devinmoore@google.com>\nDate: Mon, 22 Jan 2024 17:52:16 +0000\nSubject: [PATCH] Use the values of the ptrs that we check\n\nTest: fmq_fuzzer\nBug: 321326147\nBug: 321341508\nBug: 321383085\n(cherry picked from https://android-review.googlesource.com/q/commit:38963310ad5789b625ca0bca9f9c2c8e24666651)\nMerged-In: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\nChange-Id: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\n---\n include/fmq/MessageQueueBase.h | 24 ++++++++++++++++++++----\n 1 file changed, 20 insertions(+), 4 deletions(-)\n\ndiff --git a/include/fmq/MessageQueueBase.h b/include/fmq/MessageQueueBase.h\nindex f99e335..7a027ec 100644\n--- a/include/fmq/MessageQueueBase.h\n+++ b/include/fmq/MessageQueueBase.h\n@@ -1044,8 +1044,16 @@ bool MessageQueueBase<MQDescriptorType, T, flavor>::readBlocking(T* data, size_t\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n-    return mDesc->getSize() - availableToReadBytes();\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n+    size_t queueSizeBytes = mDesc->getSize();\n+    size_t availableBytes = availableToReadBytes();\n+    if (queueSizeBytes < availableBytes) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return queueSizeBytes - availableBytes;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n@@ -1127,13 +1135,21 @@ MessageQueueBase<MQDescriptorType, T, flavor>::commitWrite(size_t nMessages) {\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n     /*\n      * This method is invoked by implementations of both read() and write() and\n      * hence requires a memory_order_acquired load for both mReadPtr and\n      * mWritePtr.\n      */\n-    return mWritePtr->load(std::memory_order_acquire) - mReadPtr->load(std::memory_order_acquire);\n+    uint64_t writePtr = mWritePtr->load(std::memory_order_acquire);\n+    uint64_t readPtr = mReadPtr->load(std::memory_order_acquire);\n+    if (writePtr < readPtr) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return writePtr - readPtr;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 848,
                        "general": {
                            "word_based": 306,
                            "char_based": 730
                        },
                        "gemini": 1025
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "af19e0ef034174afd794563552f91303fd9f1529",
                            "repo_path": "android_repos/libfmq",
                            "result": "success",
                            "downstream_patch_content": "commit af19e0ef034174afd794563552f91303fd9f1529\nAuthor: Devin Moore <devinmoore@google.com>\nDate:   Mon Jan 22 17:52:16 2024 +0000\n\n    Use the values of the ptrs that we check\n    \n    Test: fmq_fuzzer\n    Bug: 321326147\n    Bug: 321341508\n    Bug: 321383085\n    (cherry picked from https://android-review.googlesource.com/q/commit:38963310ad5789b625ca0bca9f9c2c8e24666651)\n    Merged-In: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\n    Change-Id: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\n\ndiff --git a/include/fmq/MessageQueueBase.h b/include/fmq/MessageQueueBase.h\nindex b932317..d3c80bb 100644\n--- a/include/fmq/MessageQueueBase.h\n+++ b/include/fmq/MessageQueueBase.h\n@@ -1042,8 +1042,16 @@ bool MessageQueueBase<MQDescriptorType, T, flavor>::readBlocking(T* data, size_t\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n-    return mDesc->getSize() - availableToReadBytes();\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n+    size_t queueSizeBytes = mDesc->getSize();\n+    size_t availableBytes = availableToReadBytes();\n+    if (queueSizeBytes < availableBytes) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return queueSizeBytes - availableBytes;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n@@ -1125,13 +1133,21 @@ MessageQueueBase<MQDescriptorType, T, flavor>::commitWrite(size_t nMessages) {\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n     /*\n      * This method is invoked by implementations of both read() and write() and\n      * hence requires a memory_order_acquired load for both mReadPtr and\n      * mWritePtr.\n      */\n-    return mWritePtr->load(std::memory_order_acquire) - mReadPtr->load(std::memory_order_acquire);\n+    uint64_t writePtr = mWritePtr->load(std::memory_order_acquire);\n+    uint64_t readPtr = mReadPtr->load(std::memory_order_acquire);\n+    if (writePtr < readPtr) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return writePtr - readPtr;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n",
                            "downstream_patch_tokens": {
                                "openai": 786,
                                "general": {
                                    "word_based": 279,
                                    "char_based": 694
                                },
                                "gemini": 958
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "b923a7c0d0d25de7b0c9ba7a7c2a3e917819d95a",
                            "repo_path": "android_repos/libfmq",
                            "result": "success",
                            "downstream_patch_content": "commit b923a7c0d0d25de7b0c9ba7a7c2a3e917819d95a\nAuthor: Devin Moore <devinmoore@google.com>\nDate:   Mon Jan 22 17:52:16 2024 +0000\n\n    Use the values of the ptrs that we check\n    \n    Test: fmq_fuzzer\n    Bug: 321326147\n    Bug: 321341508\n    Bug: 321383085\n    (cherry picked from https://android-review.googlesource.com/q/commit:38963310ad5789b625ca0bca9f9c2c8e24666651)\n    Merged-In: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\n    Change-Id: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\n\ndiff --git a/include/fmq/MessageQueueBase.h b/include/fmq/MessageQueueBase.h\nindex b932317..d3c80bb 100644\n--- a/include/fmq/MessageQueueBase.h\n+++ b/include/fmq/MessageQueueBase.h\n@@ -1042,8 +1042,16 @@ bool MessageQueueBase<MQDescriptorType, T, flavor>::readBlocking(T* data, size_t\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n-    return mDesc->getSize() - availableToReadBytes();\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n+    size_t queueSizeBytes = mDesc->getSize();\n+    size_t availableBytes = availableToReadBytes();\n+    if (queueSizeBytes < availableBytes) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return queueSizeBytes - availableBytes;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n@@ -1125,13 +1133,21 @@ MessageQueueBase<MQDescriptorType, T, flavor>::commitWrite(size_t nMessages) {\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n     /*\n      * This method is invoked by implementations of both read() and write() and\n      * hence requires a memory_order_acquired load for both mReadPtr and\n      * mWritePtr.\n      */\n-    return mWritePtr->load(std::memory_order_acquire) - mReadPtr->load(std::memory_order_acquire);\n+    uint64_t writePtr = mWritePtr->load(std::memory_order_acquire);\n+    uint64_t readPtr = mReadPtr->load(std::memory_order_acquire);\n+    if (writePtr < readPtr) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return writePtr - readPtr;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n",
                            "downstream_patch_tokens": {
                                "openai": 797,
                                "general": {
                                    "word_based": 279,
                                    "char_based": 694
                                },
                                "gemini": 961
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "050952bf5f9bd035e469ce005300115d563e524a",
                            "repo_path": "android_repos/libfmq",
                            "result": "success",
                            "downstream_patch_content": "commit 050952bf5f9bd035e469ce005300115d563e524a\nAuthor: Devin Moore <devinmoore@google.com>\nDate:   Mon Jan 22 17:52:16 2024 +0000\n\n    Use the values of the ptrs that we check\n    \n    Test: fmq_fuzzer\n    Bug: 321326147\n    Bug: 321341508\n    Bug: 321383085\n    (cherry picked from https://android-review.googlesource.com/q/commit:38963310ad5789b625ca0bca9f9c2c8e24666651)\n    Merged-In: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\n    Change-Id: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\n\ndiff --git a/include/fmq/MessageQueueBase.h b/include/fmq/MessageQueueBase.h\nindex c34a4ff..652487b 100644\n--- a/include/fmq/MessageQueueBase.h\n+++ b/include/fmq/MessageQueueBase.h\n@@ -1022,8 +1022,16 @@ bool MessageQueueBase<MQDescriptorType, T, flavor>::readBlocking(T* data, size_t\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n-    return mDesc->getSize() - availableToReadBytes();\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n+    size_t queueSizeBytes = mDesc->getSize();\n+    size_t availableBytes = availableToReadBytes();\n+    if (queueSizeBytes < availableBytes) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return queueSizeBytes - availableBytes;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n@@ -1105,13 +1113,21 @@ MessageQueueBase<MQDescriptorType, T, flavor>::commitWrite(size_t nMessages) {\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n     /*\n      * This method is invoked by implementations of both read() and write() and\n      * hence requires a memory_order_acquired load for both mReadPtr and\n      * mWritePtr.\n      */\n-    return mWritePtr->load(std::memory_order_acquire) - mReadPtr->load(std::memory_order_acquire);\n+    uint64_t writePtr = mWritePtr->load(std::memory_order_acquire);\n+    uint64_t readPtr = mReadPtr->load(std::memory_order_acquire);\n+    if (writePtr < readPtr) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return writePtr - readPtr;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n",
                            "downstream_patch_tokens": {
                                "openai": 787,
                                "general": {
                                    "word_based": 279,
                                    "char_based": 694
                                },
                                "gemini": 961
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "da080aa565f0cd1158bde3b8100dc73604959035",
                            "repo_path": "android_repos/libfmq",
                            "result": "success",
                            "downstream_patch_content": "commit da080aa565f0cd1158bde3b8100dc73604959035\nAuthor: Devin Moore <devinmoore@google.com>\nDate:   Mon Jan 22 17:52:16 2024 +0000\n\n    Use the values of the ptrs that we check\n    \n    Test: fmq_fuzzer\n    Bug: 321326147\n    Bug: 321341508\n    Bug: 321383085\n    (cherry picked from https://android-review.googlesource.com/q/commit:38963310ad5789b625ca0bca9f9c2c8e24666651)\n    Merged-In: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\n    Change-Id: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\n\ndiff --git a/include/fmq/MessageQueueBase.h b/include/fmq/MessageQueueBase.h\nindex f99e335..7a027ec 100644\n--- a/include/fmq/MessageQueueBase.h\n+++ b/include/fmq/MessageQueueBase.h\n@@ -1044,8 +1044,16 @@ bool MessageQueueBase<MQDescriptorType, T, flavor>::readBlocking(T* data, size_t\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n-    return mDesc->getSize() - availableToReadBytes();\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n+    size_t queueSizeBytes = mDesc->getSize();\n+    size_t availableBytes = availableToReadBytes();\n+    if (queueSizeBytes < availableBytes) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return queueSizeBytes - availableBytes;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n@@ -1127,13 +1135,21 @@ MessageQueueBase<MQDescriptorType, T, flavor>::commitWrite(size_t nMessages) {\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n     /*\n      * This method is invoked by implementations of both read() and write() and\n      * hence requires a memory_order_acquired load for both mReadPtr and\n      * mWritePtr.\n      */\n-    return mWritePtr->load(std::memory_order_acquire) - mReadPtr->load(std::memory_order_acquire);\n+    uint64_t writePtr = mWritePtr->load(std::memory_order_acquire);\n+    uint64_t readPtr = mReadPtr->load(std::memory_order_acquire);\n+    if (writePtr < readPtr) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return writePtr - readPtr;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n",
                            "downstream_patch_tokens": {
                                "openai": 787,
                                "general": {
                                    "word_based": 279,
                                    "char_based": 694
                                },
                                "gemini": 957
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-335232744",
            "aliases": [
                "A-335232744",
                "CVE-2024-34742"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-335232744",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "aaa86cdfb79003fd66aae1132b9c06cfe80d7d08"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From aaa86cdfb79003fd66aae1132b9c06cfe80d7d08 Mon Sep 17 00:00:00 2001\nFrom: Pavel Grafov <pgrafov@google.com>\nDate: Tue, 16 Apr 2024 18:28:16 +0100\nSubject: [PATCH] Ensure device_owners2.xml is always written.\n\nBug: 335232744\nTest: Manual, upgrading from T-QPR3\nChange-Id: I7a7dba56f2951e7e3699b19d2517d198dc8f9d35\n---\n core/java/android/app/admin/flags/flags.aconfig        | 10 ++++++++++\n .../com/android/server/devicepolicy/OwnersData.java    |  3 ++-\n 2 files changed, 12 insertions(+), 1 deletion(-)\n\ndiff --git a/core/java/android/app/admin/flags/flags.aconfig b/core/java/android/app/admin/flags/flags.aconfig\nindex 6a07484eebc6..0eb67d16436c 100644\n--- a/core/java/android/app/admin/flags/flags.aconfig\n+++ b/core/java/android/app/admin/flags/flags.aconfig\n@@ -227,6 +227,16 @@ flag {\n   bug: \"323894620\"\n }\n \n+flag {\n+  name: \"always_persist_do\"\n+  namespace: \"enterprise\"\n+  description: \"Always write device_owners2.xml so that migration flags aren't lost\"\n+  bug: \"335232744\"\n+  metadata {\n+    purpose: PURPOSE_BUGFIX\n+  }\n+}\n+\n flag {\n   name: \"is_recursive_required_app_merging_enabled\"\n   namespace: \"enterprise\"\ndiff --git a/services/devicepolicy/java/com/android/server/devicepolicy/OwnersData.java b/services/devicepolicy/java/com/android/server/devicepolicy/OwnersData.java\nindex 42ac998bf96c..d02cfee72aa2 100644\n--- a/services/devicepolicy/java/com/android/server/devicepolicy/OwnersData.java\n+++ b/services/devicepolicy/java/com/android/server/devicepolicy/OwnersData.java\n@@ -357,7 +357,8 @@ class OwnersData {\n \n         @Override\n         boolean shouldWrite() {\n-            return (mDeviceOwner != null) || (mSystemUpdatePolicy != null)\n+            return Flags.alwaysPersistDo()\n+                    || (mDeviceOwner != null) || (mSystemUpdatePolicy != null)\n                     || (mSystemUpdateInfo != null);\n         }\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 558,
                        "general": {
                            "word_based": 217,
                            "char_based": 471
                        },
                        "gemini": 752
                    },
                    "total_downstream_versions_tested": 1,
                    "successful_patches": 1,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "3abc07421d5bed187589d6deb48da07e4c407203",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 3abc07421d5bed187589d6deb48da07e4c407203\nAuthor: Pavel Grafov <pgrafov@google.com>\nDate:   Tue Apr 16 18:28:16 2024 +0100\n\n    Ensure device_owners2.xml is always written.\n    \n    Bug: 335232744\n    Test: Manual, upgrading from T-QPR3\n    Change-Id: I7a7dba56f2951e7e3699b19d2517d198dc8f9d35\n    Merged-In: I7a7dba56f2951e7e3699b19d2517d198dc8f9d35\n\ndiff --git a/services/devicepolicy/java/com/android/server/devicepolicy/OwnersData.java b/services/devicepolicy/java/com/android/server/devicepolicy/OwnersData.java\nindex 608ae140450e..2ced224091a0 100644\n--- a/services/devicepolicy/java/com/android/server/devicepolicy/OwnersData.java\n+++ b/services/devicepolicy/java/com/android/server/devicepolicy/OwnersData.java\n@@ -354,8 +354,7 @@ class OwnersData {\n \n         @Override\n         boolean shouldWrite() {\n-            return (mDeviceOwner != null) || (mSystemUpdatePolicy != null)\n-                    || (mSystemUpdateInfo != null);\n+            return true;\n         }\n \n         @Override\n",
                            "downstream_patch_tokens": {
                                "openai": 303,
                                "general": {
                                    "word_based": 102,
                                    "char_based": 251
                                },
                                "gemini": 416
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-324874908",
            "aliases": [
                "A-324874908",
                "CVE-2024-31310"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-324874908",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "141d9d050346bfc4673c429382deb1b3d210f6ad"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 141d9d050346bfc4673c429382deb1b3d210f6ad Mon Sep 17 00:00:00 2001\nFrom: Haoran Zhang <haoranzhang@google.com>\nDate: Wed, 13 Mar 2024 17:08:00 +0000\nSubject: [PATCH] [Autofill Framework] Add in check for intent filter when\n setting/updating service\n\nFor test, I registered two tests around on ABTD. CtsAutoFillServiceTestCases module is passing except three known failures:\n\nTest run link:\n- https://android-build.corp.google.com/builds/abtd/run/L33300030002610600\n- https://android-build.corp.google.com/builds/abtd/run/L58100030002616607\n\n\nBug: b/324874908\nTest: atest CtsAutoFillServiceTestCases\nChange-Id: I51c2e3788ac29ff4d6b86aa2a735ff2ea1463a77\n---\n .../autofill/AutofillManagerServiceImpl.java  | 27 +++++++++++++++++++\n 1 file changed, 27 insertions(+)\n\ndiff --git a/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java b/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\nindex e1291e5f75ec..3ed32fc03e7d 100644\n--- a/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\n+++ b/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\n@@ -33,8 +33,10 @@ import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.ActivityManagerInternal;\n import android.content.ComponentName;\n+import android.content.Intent;\n import android.content.pm.PackageManager;\n import android.content.pm.PackageManager.NameNotFoundException;\n+import android.content.pm.ResolveInfo;\n import android.content.pm.ServiceInfo;\n import android.graphics.Rect;\n import android.metrics.LogMaker;\n@@ -251,6 +253,31 @@ final class AutofillManagerServiceImpl\n     @Override // from PerUserSystemService\n     protected ServiceInfo newServiceInfoLocked(@NonNull ComponentName serviceComponent)\n             throws NameNotFoundException {\n+        final List<ResolveInfo> resolveInfos =\n+                getContext().getPackageManager().queryIntentServicesAsUser(\n+                    new Intent(AutofillService.SERVICE_INTERFACE),\n+                    // The MATCH_INSTANT flag is added because curret autofill CTS module is\n+                    // defined in one apk, which makes the test autofill service installed in a\n+                    // instant app when the CTS tests are running in instant app mode.\n+                    // TODO: Remove MATCH_INSTANT flag after completing refactoring the CTS module\n+                    //       to make the test autofill service a separate apk.\n+                    PackageManager.GET_META_DATA | PackageManager.MATCH_INSTANT,\n+                    mUserId);\n+        boolean serviceHasAutofillIntentFilter = false;\n+        for (ResolveInfo resolveInfo : resolveInfos) {\n+            final ServiceInfo serviceInfo = resolveInfo.serviceInfo;\n+            if (serviceInfo.getComponentName().equals(serviceComponent)) {\n+                serviceHasAutofillIntentFilter = true;\n+                break;\n+            }\n+        }\n+        if (!serviceHasAutofillIntentFilter) {\n+            Slog.w(TAG,\n+                    \"Autofill service from '\" + serviceComponent.getPackageName() + \"' does\"\n+                            + \"not have intent filter \" + AutofillService.SERVICE_INTERFACE);\n+            throw new SecurityException(\"Service does not declare intent filter \"\n+                            + AutofillService.SERVICE_INTERFACE);\n+        }\n         mInfo = new AutofillServiceInfo(getContext(), serviceComponent, mUserId);\n         return mInfo.getServiceInfo();\n     }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 835,
                        "general": {
                            "word_based": 347,
                            "char_based": 893
                        },
                        "gemini": 1021
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "51d64705ab70788a536c26d4df5e63f0952ec98f",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 51d64705ab70788a536c26d4df5e63f0952ec98f\nAuthor: Haoran Zhang <haoranzhang@google.com>\nDate:   Wed Mar 13 17:08:00 2024 +0000\n\n    [DO NOT MERGE][Autofill Framework] Add in check for intent filter when\n    setting/updating service\n    \n    For test, I registered two tests around on ABTD. CtsAutoFillServiceTestCases module is passing except three known failures:\n    \n    Test run link:\n    - https://android-build.corp.google.com/builds/abtd/run/L33300030002610600\n    - https://android-build.corp.google.com/builds/abtd/run/L58100030002616607\n    \n    \n    Bug: b/324874908\n    Test: atest CtsAutoFillServiceTestCases\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:141d9d050346bfc4673c429382deb1b3d210f6ad)\n    Merged-In: I51c2e3788ac29ff4d6b86aa2a735ff2ea1463a77\n    Change-Id: I51c2e3788ac29ff4d6b86aa2a735ff2ea1463a77\n\ndiff --git a/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java b/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\nindex aa42e8deb581..0420d7f7f68e 100644\n--- a/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\n+++ b/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\n@@ -30,8 +30,10 @@ import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.ActivityManagerInternal;\n import android.content.ComponentName;\n+import android.content.Intent;\n import android.content.pm.PackageManager;\n import android.content.pm.PackageManager.NameNotFoundException;\n+import android.content.pm.ResolveInfo;\n import android.content.pm.ServiceInfo;\n import android.graphics.Rect;\n import android.metrics.LogMaker;\n@@ -236,6 +238,31 @@ final class AutofillManagerServiceImpl\n     @Override // from PerUserSystemService\n     protected ServiceInfo newServiceInfoLocked(@NonNull ComponentName serviceComponent)\n             throws NameNotFoundException {\n+        final List<ResolveInfo> resolveInfos =\n+                getContext().getPackageManager().queryIntentServicesAsUser(\n+                    new Intent(AutofillService.SERVICE_INTERFACE),\n+                    // The MATCH_INSTANT flag is added because curret autofill CTS module is\n+                    // defined in one apk, which makes the test autofill service installed in a\n+                    // instant app when the CTS tests are running in instant app mode.\n+                    // TODO: Remove MATCH_INSTANT flag after completing refactoring the CTS module\n+                    //       to make the test autofill service a separate apk.\n+                    PackageManager.GET_META_DATA | PackageManager.MATCH_INSTANT,\n+                    mUserId);\n+        boolean serviceHasAutofillIntentFilter = false;\n+        for (ResolveInfo resolveInfo : resolveInfos) {\n+            final ServiceInfo serviceInfo = resolveInfo.serviceInfo;\n+            if (serviceInfo.getComponentName().equals(serviceComponent)) {\n+                serviceHasAutofillIntentFilter = true;\n+                break;\n+            }\n+        }\n+        if (!serviceHasAutofillIntentFilter) {\n+            Slog.w(TAG,\n+                    \"Autofill service from '\" + serviceComponent.getPackageName() + \"' does\"\n+                            + \"not have intent filter \" + AutofillService.SERVICE_INTERFACE);\n+            throw new SecurityException(\"Service does not declare intent filter \"\n+                            + AutofillService.SERVICE_INTERFACE);\n+        }\n         mInfo = new AutofillServiceInfo(getContext(), serviceComponent, mUserId);\n         return mInfo.getServiceInfo();\n     }\n",
                            "downstream_patch_tokens": {
                                "openai": 864,
                                "general": {
                                    "word_based": 341,
                                    "char_based": 912
                                },
                                "gemini": 1073
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "bedc0ff2bfa8c5faf336ba5e87d80b3a85fde53d",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit bedc0ff2bfa8c5faf336ba5e87d80b3a85fde53d\nAuthor: Haoran Zhang <haoranzhang@google.com>\nDate:   Wed Mar 13 17:08:00 2024 +0000\n\n    [DO NOT MERGE][Autofill Framework] Add in check for intent filter when\n    setting/updating service\n    \n    For test, I registered two tests around on ABTD. CtsAutoFillServiceTestCases module is passing except three known failures:\n    \n    Test run link:\n    - https://android-build.corp.google.com/builds/abtd/run/L33300030002610600\n    - https://android-build.corp.google.com/builds/abtd/run/L58100030002616607\n    \n    \n    Bug: b/324874908\n    Test: atest CtsAutoFillServiceTestCases\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:141d9d050346bfc4673c429382deb1b3d210f6ad)\n    Merged-In: I51c2e3788ac29ff4d6b86aa2a735ff2ea1463a77\n    Change-Id: I51c2e3788ac29ff4d6b86aa2a735ff2ea1463a77\n\ndiff --git a/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java b/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\nindex aa42e8deb581..0420d7f7f68e 100644\n--- a/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\n+++ b/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\n@@ -30,8 +30,10 @@ import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.ActivityManagerInternal;\n import android.content.ComponentName;\n+import android.content.Intent;\n import android.content.pm.PackageManager;\n import android.content.pm.PackageManager.NameNotFoundException;\n+import android.content.pm.ResolveInfo;\n import android.content.pm.ServiceInfo;\n import android.graphics.Rect;\n import android.metrics.LogMaker;\n@@ -236,6 +238,31 @@ final class AutofillManagerServiceImpl\n     @Override // from PerUserSystemService\n     protected ServiceInfo newServiceInfoLocked(@NonNull ComponentName serviceComponent)\n             throws NameNotFoundException {\n+        final List<ResolveInfo> resolveInfos =\n+                getContext().getPackageManager().queryIntentServicesAsUser(\n+                    new Intent(AutofillService.SERVICE_INTERFACE),\n+                    // The MATCH_INSTANT flag is added because curret autofill CTS module is\n+                    // defined in one apk, which makes the test autofill service installed in a\n+                    // instant app when the CTS tests are running in instant app mode.\n+                    // TODO: Remove MATCH_INSTANT flag after completing refactoring the CTS module\n+                    //       to make the test autofill service a separate apk.\n+                    PackageManager.GET_META_DATA | PackageManager.MATCH_INSTANT,\n+                    mUserId);\n+        boolean serviceHasAutofillIntentFilter = false;\n+        for (ResolveInfo resolveInfo : resolveInfos) {\n+            final ServiceInfo serviceInfo = resolveInfo.serviceInfo;\n+            if (serviceInfo.getComponentName().equals(serviceComponent)) {\n+                serviceHasAutofillIntentFilter = true;\n+                break;\n+            }\n+        }\n+        if (!serviceHasAutofillIntentFilter) {\n+            Slog.w(TAG,\n+                    \"Autofill service from '\" + serviceComponent.getPackageName() + \"' does\"\n+                            + \"not have intent filter \" + AutofillService.SERVICE_INTERFACE);\n+            throw new SecurityException(\"Service does not declare intent filter \"\n+                            + AutofillService.SERVICE_INTERFACE);\n+        }\n         mInfo = new AutofillServiceInfo(getContext(), serviceComponent, mUserId);\n         return mInfo.getServiceInfo();\n     }\n",
                            "downstream_patch_tokens": {
                                "openai": 866,
                                "general": {
                                    "word_based": 341,
                                    "char_based": 912
                                },
                                "gemini": 1066
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "ee20adb4b4b2065e040167a4354c4fabaf06e35d",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit ee20adb4b4b2065e040167a4354c4fabaf06e35d\nAuthor: Haoran Zhang <haoranzhang@google.com>\nDate:   Wed Mar 13 17:08:00 2024 +0000\n\n    [DO NOT MERGE][Autofill Framework] Add in check for intent filter when\n    setting/updating service\n    \n    For test, I registered two tests around on ABTD. CtsAutoFillServiceTestCases module is passing except three known failures:\n    \n    Test run link:\n    - https://android-build.corp.google.com/builds/abtd/run/L33300030002610600\n    - https://android-build.corp.google.com/builds/abtd/run/L58100030002616607\n    \n    \n    Bug: b/324874908\n    Test: atest CtsAutoFillServiceTestCases\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:141d9d050346bfc4673c429382deb1b3d210f6ad)\n    Merged-In: I51c2e3788ac29ff4d6b86aa2a735ff2ea1463a77\n    Change-Id: I51c2e3788ac29ff4d6b86aa2a735ff2ea1463a77\n\ndiff --git a/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java b/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\nindex fe85db286fa8..abe68c47b050 100644\n--- a/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\n+++ b/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\n@@ -32,8 +32,10 @@ import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.ActivityManagerInternal;\n import android.content.ComponentName;\n+import android.content.Intent;\n import android.content.pm.PackageManager;\n import android.content.pm.PackageManager.NameNotFoundException;\n+import android.content.pm.ResolveInfo;\n import android.content.pm.ServiceInfo;\n import android.graphics.Rect;\n import android.metrics.LogMaker;\n@@ -239,6 +241,31 @@ final class AutofillManagerServiceImpl\n     @Override // from PerUserSystemService\n     protected ServiceInfo newServiceInfoLocked(@NonNull ComponentName serviceComponent)\n             throws NameNotFoundException {\n+        final List<ResolveInfo> resolveInfos =\n+                getContext().getPackageManager().queryIntentServicesAsUser(\n+                    new Intent(AutofillService.SERVICE_INTERFACE),\n+                    // The MATCH_INSTANT flag is added because curret autofill CTS module is\n+                    // defined in one apk, which makes the test autofill service installed in a\n+                    // instant app when the CTS tests are running in instant app mode.\n+                    // TODO: Remove MATCH_INSTANT flag after completing refactoring the CTS module\n+                    //       to make the test autofill service a separate apk.\n+                    PackageManager.GET_META_DATA | PackageManager.MATCH_INSTANT,\n+                    mUserId);\n+        boolean serviceHasAutofillIntentFilter = false;\n+        for (ResolveInfo resolveInfo : resolveInfos) {\n+            final ServiceInfo serviceInfo = resolveInfo.serviceInfo;\n+            if (serviceInfo.getComponentName().equals(serviceComponent)) {\n+                serviceHasAutofillIntentFilter = true;\n+                break;\n+            }\n+        }\n+        if (!serviceHasAutofillIntentFilter) {\n+            Slog.w(TAG,\n+                    \"Autofill service from '\" + serviceComponent.getPackageName() + \"' does\"\n+                            + \"not have intent filter \" + AutofillService.SERVICE_INTERFACE);\n+            throw new SecurityException(\"Service does not declare intent filter \"\n+                            + AutofillService.SERVICE_INTERFACE);\n+        }\n         mInfo = new AutofillServiceInfo(getContext(), serviceComponent, mUserId);\n         return mInfo.getServiceInfo();\n     }\n",
                            "downstream_patch_tokens": {
                                "openai": 860,
                                "general": {
                                    "word_based": 341,
                                    "char_based": 912
                                },
                                "gemini": 1067
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "e8a448f855ef6ba9ae4b655e6824631f8023c0a0",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit e8a448f855ef6ba9ae4b655e6824631f8023c0a0\nAuthor: Haoran Zhang <haoranzhang@google.com>\nDate:   Wed Mar 13 17:08:00 2024 +0000\n\n    [DO NOT MERGE][Autofill Framework] Add in check for intent filter when\n    setting/updating service\n    \n    For test, I registered two tests around on ABTD. CtsAutoFillServiceTestCases module is passing except three known failures:\n    \n    Test run link:\n    - https://android-build.corp.google.com/builds/abtd/run/L33300030002610600\n    - https://android-build.corp.google.com/builds/abtd/run/L58100030002616607\n    \n    \n    Bug: b/324874908\n    Test: atest CtsAutoFillServiceTestCases\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:141d9d050346bfc4673c429382deb1b3d210f6ad)\n    Merged-In: I51c2e3788ac29ff4d6b86aa2a735ff2ea1463a77\n    Change-Id: I51c2e3788ac29ff4d6b86aa2a735ff2ea1463a77\n\ndiff --git a/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java b/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\nindex 63a607c8d0d4..7be2dea3c2f6 100644\n--- a/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\n+++ b/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\n@@ -32,8 +32,10 @@ import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.ActivityManagerInternal;\n import android.content.ComponentName;\n+import android.content.Intent;\n import android.content.pm.PackageManager;\n import android.content.pm.PackageManager.NameNotFoundException;\n+import android.content.pm.ResolveInfo;\n import android.content.pm.ServiceInfo;\n import android.graphics.Rect;\n import android.metrics.LogMaker;\n@@ -250,6 +252,31 @@ final class AutofillManagerServiceImpl\n     @Override // from PerUserSystemService\n     protected ServiceInfo newServiceInfoLocked(@NonNull ComponentName serviceComponent)\n             throws NameNotFoundException {\n+        final List<ResolveInfo> resolveInfos =\n+                getContext().getPackageManager().queryIntentServicesAsUser(\n+                    new Intent(AutofillService.SERVICE_INTERFACE),\n+                    // The MATCH_INSTANT flag is added because curret autofill CTS module is\n+                    // defined in one apk, which makes the test autofill service installed in a\n+                    // instant app when the CTS tests are running in instant app mode.\n+                    // TODO: Remove MATCH_INSTANT flag after completing refactoring the CTS module\n+                    //       to make the test autofill service a separate apk.\n+                    PackageManager.GET_META_DATA | PackageManager.MATCH_INSTANT,\n+                    mUserId);\n+        boolean serviceHasAutofillIntentFilter = false;\n+        for (ResolveInfo resolveInfo : resolveInfos) {\n+            final ServiceInfo serviceInfo = resolveInfo.serviceInfo;\n+            if (serviceInfo.getComponentName().equals(serviceComponent)) {\n+                serviceHasAutofillIntentFilter = true;\n+                break;\n+            }\n+        }\n+        if (!serviceHasAutofillIntentFilter) {\n+            Slog.w(TAG,\n+                    \"Autofill service from '\" + serviceComponent.getPackageName() + \"' does\"\n+                            + \"not have intent filter \" + AutofillService.SERVICE_INTERFACE);\n+            throw new SecurityException(\"Service does not declare intent filter \"\n+                            + AutofillService.SERVICE_INTERFACE);\n+        }\n         mInfo = new AutofillServiceInfo(getContext(), serviceComponent, mUserId);\n         return mInfo.getServiceInfo();\n     }\n",
                            "downstream_patch_tokens": {
                                "openai": 869,
                                "general": {
                                    "word_based": 341,
                                    "char_based": 912
                                },
                                "gemini": 1073
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-326485767",
            "aliases": [
                "A-326485767",
                "CVE-2024-31322"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-326485767",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "74ab528e54558b5a78a9b0f32a2e3f0a61714ae5"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 74ab528e54558b5a78a9b0f32a2e3f0a61714ae5 Mon Sep 17 00:00:00 2001\nFrom: Ameer Armaly <aarmaly@google.com>\nDate: Tue, 12 Mar 2024 13:45:37 +0000\nSubject: [PATCH] AccessibilityManagerService: remove uninstalled services from\n enabled list after service update.\n\nBug: 326485767\nTest: atest AccessibilityEndToEndTest#testUpdateServiceWithoutIntent_disablesService\nChange-Id: I2d986dc8f09a3cf2f31713237e69e15dcef84514\n---\n .../AccessibilityManagerService.java          | 22 +++++++++++++++++++\n 1 file changed, 22 insertions(+)\n\ndiff --git a/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java b/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\nindex 940379699ee6..a4f998c3ebc1 100644\n--- a/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\n+++ b/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\n@@ -2722,10 +2722,13 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub\n                 userState.mComponentNameToServiceMap;\n         boolean isUnlockingOrUnlocked = mUmi.isUserUnlockingOrUnlocked(userState.mUserId);\n \n+        // Store the list of installed services.\n+        mTempComponentNameSet.clear();\n         for (int i = 0, count = userState.mInstalledServices.size(); i < count; i++) {\n             AccessibilityServiceInfo installedService = userState.mInstalledServices.get(i);\n             ComponentName componentName = ComponentName.unflattenFromString(\n                     installedService.getId());\n+            mTempComponentNameSet.add(componentName);\n \n             AccessibilityServiceConnection service = componentNameToServiceMap.get(componentName);\n \n@@ -2785,6 +2788,25 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub\n             audioManager.setAccessibilityServiceUids(mTempIntArray);\n         }\n         mActivityTaskManagerService.setAccessibilityServiceUids(mTempIntArray);\n+\n+        // If any services have been removed, remove them from the enabled list and the touch\n+        // exploration granted list.\n+        boolean anyServiceRemoved =\n+                userState.mEnabledServices.removeIf((comp) -> !mTempComponentNameSet.contains(comp))\n+                        || userState.mTouchExplorationGrantedServices.removeIf(\n+                                (comp) -> !mTempComponentNameSet.contains(comp));\n+        if (anyServiceRemoved) {\n+            // Update the enabled services setting.\n+            persistComponentNamesToSettingLocked(\n+                    Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,\n+                    userState.mEnabledServices,\n+                    userState.mUserId);\n+            // Update the touch exploration granted services setting.\n+            persistComponentNamesToSettingLocked(\n+                    Settings.Secure.TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,\n+                    userState.mTouchExplorationGrantedServices,\n+                    userState.mUserId);\n+        }\n         updateAccessibilityEnabledSettingLocked(userState);\n     }\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 702,
                        "general": {
                            "word_based": 244,
                            "char_based": 799
                        },
                        "gemini": 868
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "5405514a23edcba0cf30e6ec78189e3f4e7d95cf",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 5405514a23edcba0cf30e6ec78189e3f4e7d95cf\nAuthor: Ameer Armaly <aarmaly@google.com>\nDate:   Fri Mar 8 19:41:06 2024 +0000\n\n    [RESTRICT AUTOMERGE] AccessibilityManagerService: remove uninstalled services from enabled list after service update.\n    \n    Bug: 326485767\n    Test: atest AccessibilityEndToEndTest#testUpdateServiceWithoutIntent_disablesService\n    Change-Id: I5e59296fcad68e62b34c74ee5fd80b6ad6b46fa1\n\ndiff --git a/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java b/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\nindex 0b2a91a4524f..cc9adc772683 100644\n--- a/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\n+++ b/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\n@@ -1906,10 +1906,13 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub\n         boolean isUnlockingOrUnlocked = LocalServices.getService(UserManagerInternal.class)\n                     .isUserUnlockingOrUnlocked(userState.mUserId);\n \n+        // Store the list of installed services.\n+        mTempComponentNameSet.clear();\n         for (int i = 0, count = userState.mInstalledServices.size(); i < count; i++) {\n             AccessibilityServiceInfo installedService = userState.mInstalledServices.get(i);\n             ComponentName componentName = ComponentName.unflattenFromString(\n                     installedService.getId());\n+            mTempComponentNameSet.add(componentName);\n \n             AccessibilityServiceConnection service = componentNameToServiceMap.get(componentName);\n \n@@ -1960,6 +1963,25 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub\n             audioManager.setAccessibilityServiceUids(mTempIntArray);\n         }\n         mActivityTaskManagerService.setAccessibilityServiceUids(mTempIntArray);\n+        // If any services have been removed, remove them from the enabled list and the touch\n+        // exploration granted list.\n+        boolean anyServiceRemoved =\n+                userState.mEnabledServices.removeIf((comp) -> !mTempComponentNameSet.contains(comp))\n+                        || userState.mTouchExplorationGrantedServices.removeIf(\n+                                (comp) -> !mTempComponentNameSet.contains(comp));\n+        if (anyServiceRemoved) {\n+            // Update the enabled services setting.\n+            persistComponentNamesToSettingLocked(\n+                    Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,\n+                    userState.mEnabledServices,\n+                    userState.mUserId);\n+            // Update the touch exploration granted services setting.\n+            persistComponentNamesToSettingLocked(\n+                    Settings.Secure.TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,\n+                    userState.mTouchExplorationGrantedServices,\n+                    userState.mUserId);\n+        }\n+        mTempComponentNameSet.clear();\n         updateAccessibilityEnabledSettingLocked(userState);\n     }\n \n",
                            "downstream_patch_tokens": {
                                "openai": 662,
                                "general": {
                                    "word_based": 226,
                                    "char_based": 778
                                },
                                "gemini": 805
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "412427d7a8c99fd0470483a5a20b50ba8642a1db",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 412427d7a8c99fd0470483a5a20b50ba8642a1db\nAuthor: Ameer Armaly <aarmaly@google.com>\nDate:   Fri Mar 8 19:41:06 2024 +0000\n\n    [RESTRICT AUTOMERGE] AccessibilityManagerService: remove uninstalled services from enabled list after service update.\n    \n    Bug: 326485767\n    Test: atest AccessibilityEndToEndTest#testUpdateServiceWithoutIntent_disablesService\n    Change-Id: I3b778e8f41ace30e09b93a39580993ef5ac52ace\n\ndiff --git a/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java b/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\nindex 05dcea265763..4a28a123c8d1 100644\n--- a/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\n+++ b/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\n@@ -1919,10 +1919,13 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub\n         boolean isUnlockingOrUnlocked = LocalServices.getService(UserManagerInternal.class)\n                     .isUserUnlockingOrUnlocked(userState.mUserId);\n \n+        // Store the list of installed services.\n+        mTempComponentNameSet.clear();\n         for (int i = 0, count = userState.mInstalledServices.size(); i < count; i++) {\n             AccessibilityServiceInfo installedService = userState.mInstalledServices.get(i);\n             ComponentName componentName = ComponentName.unflattenFromString(\n                     installedService.getId());\n+            mTempComponentNameSet.add(componentName);\n \n             AccessibilityServiceConnection service = componentNameToServiceMap.get(componentName);\n \n@@ -1973,6 +1976,25 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub\n             audioManager.setAccessibilityServiceUids(mTempIntArray);\n         }\n         mActivityTaskManagerService.setAccessibilityServiceUids(mTempIntArray);\n+        // If any services have been removed, remove them from the enabled list and the touch\n+        // exploration granted list.\n+        boolean anyServiceRemoved =\n+                userState.mEnabledServices.removeIf((comp) -> !mTempComponentNameSet.contains(comp))\n+                        || userState.mTouchExplorationGrantedServices.removeIf(\n+                                (comp) -> !mTempComponentNameSet.contains(comp));\n+        if (anyServiceRemoved) {\n+            // Update the enabled services setting.\n+            persistComponentNamesToSettingLocked(\n+                    Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,\n+                    userState.mEnabledServices,\n+                    userState.mUserId);\n+            // Update the touch exploration granted services setting.\n+            persistComponentNamesToSettingLocked(\n+                    Settings.Secure.TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,\n+                    userState.mTouchExplorationGrantedServices,\n+                    userState.mUserId);\n+        }\n+        mTempComponentNameSet.clear();\n         updateAccessibilityEnabledSettingLocked(userState);\n     }\n \n",
                            "downstream_patch_tokens": {
                                "openai": 659,
                                "general": {
                                    "word_based": 226,
                                    "char_based": 778
                                },
                                "gemini": 809
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "766911c3312573196b33efd1c3c29ccece806846",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 766911c3312573196b33efd1c3c29ccece806846\nAuthor: Ameer Armaly <aarmaly@google.com>\nDate:   Fri Mar 8 19:41:06 2024 +0000\n\n    [RESTRICT AUTOMERGE] AccessibilityManagerService: remove uninstalled services from enabled list after service update.\n    \n    Bug: 326485767\n    Test: atest AccessibilityEndToEndTest#testUpdateServiceWithoutIntent_disablesService\n    Change-Id: I958d58953b300c8093335a22e207baac471ae9f9\n\ndiff --git a/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java b/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\nindex 3818a884c94a..8271aed181c9 100644\n--- a/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\n+++ b/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\n@@ -2161,10 +2161,13 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub\n         boolean isUnlockingOrUnlocked = LocalServices.getService(UserManagerInternal.class)\n                     .isUserUnlockingOrUnlocked(userState.mUserId);\n \n+        // Store the list of installed services.\n+        mTempComponentNameSet.clear();\n         for (int i = 0, count = userState.mInstalledServices.size(); i < count; i++) {\n             AccessibilityServiceInfo installedService = userState.mInstalledServices.get(i);\n             ComponentName componentName = ComponentName.unflattenFromString(\n                     installedService.getId());\n+            mTempComponentNameSet.add(componentName);\n \n             AccessibilityServiceConnection service = componentNameToServiceMap.get(componentName);\n \n@@ -2215,6 +2218,25 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub\n             audioManager.setAccessibilityServiceUids(mTempIntArray);\n         }\n         mActivityTaskManagerService.setAccessibilityServiceUids(mTempIntArray);\n+        // If any services have been removed, remove them from the enabled list and the touch\n+        // exploration granted list.\n+        boolean anyServiceRemoved =\n+                userState.mEnabledServices.removeIf((comp) -> !mTempComponentNameSet.contains(comp))\n+                        || userState.mTouchExplorationGrantedServices.removeIf(\n+                                (comp) -> !mTempComponentNameSet.contains(comp));\n+        if (anyServiceRemoved) {\n+            // Update the enabled services setting.\n+            persistComponentNamesToSettingLocked(\n+                    Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,\n+                    userState.mEnabledServices,\n+                    userState.mUserId);\n+            // Update the touch exploration granted services setting.\n+            persistComponentNamesToSettingLocked(\n+                    Settings.Secure.TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,\n+                    userState.mTouchExplorationGrantedServices,\n+                    userState.mUserId);\n+        }\n+        mTempComponentNameSet.clear();\n         updateAccessibilityEnabledSettingLocked(userState);\n     }\n \n",
                            "downstream_patch_tokens": {
                                "openai": 652,
                                "general": {
                                    "word_based": 226,
                                    "char_based": 778
                                },
                                "gemini": 810
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "f6192d3a77520d40b6a93de8f45400e19f5ba29f",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit f6192d3a77520d40b6a93de8f45400e19f5ba29f\nAuthor: Ameer Armaly <aarmaly@google.com>\nDate:   Fri Mar 8 19:41:06 2024 +0000\n\n    [RESTRICT AUTOMERGE] AccessibilityManagerService: remove uninstalled services from enabled list after service update.\n    \n    Bug: 326485767\n    Test: atest AccessibilityEndToEndTest#testUpdateServiceWithoutIntent_disablesService\n    Change-Id: Ia86857d58ebab925ec6e55f9e5fa64e265326ec0\n\ndiff --git a/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java b/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\nindex 531227947ba0..7bb7c4a81a7d 100644\n--- a/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\n+++ b/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\n@@ -2398,10 +2398,13 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub\n                 userState.mComponentNameToServiceMap;\n         boolean isUnlockingOrUnlocked = mUmi.isUserUnlockingOrUnlocked(userState.mUserId);\n \n+        // Store the list of installed services.\n+        mTempComponentNameSet.clear();\n         for (int i = 0, count = userState.mInstalledServices.size(); i < count; i++) {\n             AccessibilityServiceInfo installedService = userState.mInstalledServices.get(i);\n             ComponentName componentName = ComponentName.unflattenFromString(\n                     installedService.getId());\n+            mTempComponentNameSet.add(componentName);\n \n             AccessibilityServiceConnection service = componentNameToServiceMap.get(componentName);\n \n@@ -2461,6 +2464,25 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub\n             audioManager.setAccessibilityServiceUids(mTempIntArray);\n         }\n         mActivityTaskManagerService.setAccessibilityServiceUids(mTempIntArray);\n+        // If any services have been removed, remove them from the enabled list and the touch\n+        // exploration granted list.\n+        boolean anyServiceRemoved =\n+                userState.mEnabledServices.removeIf((comp) -> !mTempComponentNameSet.contains(comp))\n+                        || userState.mTouchExplorationGrantedServices.removeIf(\n+                                (comp) -> !mTempComponentNameSet.contains(comp));\n+        if (anyServiceRemoved) {\n+            // Update the enabled services setting.\n+            persistComponentNamesToSettingLocked(\n+                    Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,\n+                    userState.mEnabledServices,\n+                    userState.mUserId);\n+            // Update the touch exploration granted services setting.\n+            persistComponentNamesToSettingLocked(\n+                    Settings.Secure.TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,\n+                    userState.mTouchExplorationGrantedServices,\n+                    userState.mUserId);\n+        }\n+        mTempComponentNameSet.clear();\n         updateAccessibilityEnabledSettingLocked(userState);\n     }\n \n",
                            "downstream_patch_tokens": {
                                "openai": 664,
                                "general": {
                                    "word_based": 225,
                                    "char_based": 775
                                },
                                "gemini": 810
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-294406604",
            "aliases": [
                "A-294406604",
                "CVE-2024-34721"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-294406604",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "a296a6520bef303faedbe8b4489f36e0e2b09d16"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From a296a6520bef303faedbe8b4489f36e0e2b09d16 Mon Sep 17 00:00:00 2001\nFrom: Omar Eissa <oeissa@google.com>\nDate: Mon, 15 Apr 2024 12:04:56 +0000\nSubject: [PATCH] Prevent insertion in other users storage volumes\n\nDon't allow file insertion in other users storage volumes.\nThis was already handled if DATA was explicitly set in content values,\nbut was allowed if DATA was generated based on other values like RELATIVE_PATH and DISPLAY_NAME.\n\nInsertion of files in other users storage volumes can be used by malicious apps\nto get access to other users files, since the same file would exist in both users MP databases\nwhich would lead to MP falsely assuming that the user has access to this file.\n\nBug: 294406604\nTest: atest MediaProviderTests\nChange-Id: Ie219bbdbe28819421040e4c083b65ab47d8ebde6\n---\n .../providers/media/MediaProvider.java        |  1 +\n .../providers/media/MediaProviderTest.java    | 33 +++++++++++++++++--\n 2 files changed, 31 insertions(+), 3 deletions(-)\n\ndiff --git a/src/com/android/providers/media/MediaProvider.java b/src/com/android/providers/media/MediaProvider.java\nindex dd662e58d..f4bb62a53 100644\n--- a/src/com/android/providers/media/MediaProvider.java\n+++ b/src/com/android/providers/media/MediaProvider.java\n@@ -4487,6 +4487,7 @@ public class MediaProvider extends ContentProvider {\n \n             FileUtils.sanitizeValues(values, /*rewriteHiddenFileName*/ !isFuseThread());\n             FileUtils.computeDataFromValues(values, volumePath, isFuseThread());\n+            assertFileColumnsConsistent(match, uri, values);\n \n             // Create result file\n             File res = new File(values.getAsString(MediaColumns.DATA));\ndiff --git a/tests/src/com/android/providers/media/MediaProviderTest.java b/tests/src/com/android/providers/media/MediaProviderTest.java\nindex a8191a17e..819bdfd2f 100644\n--- a/tests/src/com/android/providers/media/MediaProviderTest.java\n+++ b/tests/src/com/android/providers/media/MediaProviderTest.java\n@@ -54,6 +54,7 @@ import android.os.Bundle;\n import android.os.CancellationSignal;\n import android.os.Environment;\n import android.os.UserHandle;\n+import android.os.UserManager;\n import android.provider.MediaStore;\n import android.provider.MediaStore.Audio.AudioColumns;\n import android.provider.MediaStore.Files.FileColumns;\n@@ -77,6 +78,7 @@ import com.android.providers.media.photopicker.data.ItemsProvider;\n import com.android.providers.media.util.FileUtils;\n import com.android.providers.media.util.FileUtilsTest;\n import com.android.providers.media.util.SQLiteQueryBuilder;\n+import com.android.providers.media.util.UserCache;\n \n import org.junit.AfterClass;\n import org.junit.Assert;\n@@ -500,11 +502,36 @@ public class MediaProviderTest {\n     }\n \n     @Test\n-    public void testInsertionWithInvalidFilePath_throwsIllegalArgumentException() {\n+    public void testInsertionWithFilePathOnAnotherUserVolume_throwsIllegalArgumentException() {\n+        final UserCache userCache = new UserCache(sContext);\n+        UserHandle otherUserHandle = sContext.getSystemService(UserManager.class)\n+                .getUserHandles(true).stream()\n+                .filter(uH -> !userCache.getUsersCached().contains(uH))\n+                .findFirst()\n+                .orElse(null);\n+        Assume.assumeNotNull(otherUserHandle);\n+\n         final ContentValues values = new ContentValues();\n-        values.put(MediaStore.MediaColumns.RELATIVE_PATH, \"Android/media/com.example\");\n+        values.put(MediaStore.MediaColumns.RELATIVE_PATH, \"Download\");\n+        final String filePath = \"/storage/emulated/\"\n+                + otherUserHandle.getIdentifier() + \"/Pictures/test.jpg\";\n         values.put(MediaStore.Images.Media.DISPLAY_NAME,\n-                \"./../../../../../../../../../../../data/media/test.txt\");\n+                \"./../../../../../../../../../../../\" + filePath);\n+\n+        IllegalArgumentException illegalArgumentException = Assert.assertThrows(\n+                IllegalArgumentException.class, () -> sIsolatedResolver.insert(\n+                        MediaStore.Files.getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY),\n+                        values));\n+\n+        assertThat(illegalArgumentException).hasMessageThat().contains(\n+                \"Requested path \" + filePath + \" doesn't appear\");\n+    }\n+\n+    @Test\n+    public void testInsertionWithInvalidFilePath_throwsIllegalArgumentException() {\n+        final ContentValues values = new ContentValues();\n+        values.put(MediaStore.MediaColumns.RELATIVE_PATH, \"Android/media/com.example/\");\n+        values.put(MediaStore.Images.Media.DISPLAY_NAME, \"data/media/test.txt\");\n \n         IllegalArgumentException illegalArgumentException = Assert.assertThrows(\n                 IllegalArgumentException.class, () -> sIsolatedResolver.insert(\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 1039,
                        "general": {
                            "word_based": 492,
                            "char_based": 1202
                        },
                        "gemini": 1349
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "df39f8486b25473d0bdbeed896ad917e3c793bf9",
                            "repo_path": "android_repos/MediaProvider",
                            "result": "success",
                            "downstream_patch_content": "commit df39f8486b25473d0bdbeed896ad917e3c793bf9\nAuthor: Omar Eissa <oeissa@google.com>\nDate:   Mon Apr 15 12:04:56 2024 +0000\n\n    Prevent insertion in other users storage volumes\n    \n    Don't allow file insertion in other users storage volumes.\n    This was already handled if DATA was explicitly set in content values,\n    but was allowed if DATA was generated based on other values like RELATIVE_PATH and DISPLAY_NAME.\n    \n    Insertion of files in other users storage volumes can be used by malicious apps\n    to get access to other users files, since the same file would exist in both users MP databases\n    which would lead to MP falsely assuming that the user has access to this file.\n    \n    Bug: 294406604\n    Test: atest MediaProviderTests\n    Merged-In: Ie219bbdbe28819421040e4c083b65ab47d8ebde6\n    Change-Id: Ie219bbdbe28819421040e4c083b65ab47d8ebde6\n\ndiff --git a/src/com/android/providers/media/MediaProvider.java b/src/com/android/providers/media/MediaProvider.java\nindex 31bdf893f..97b6b3015 100644\n--- a/src/com/android/providers/media/MediaProvider.java\n+++ b/src/com/android/providers/media/MediaProvider.java\n@@ -3275,6 +3275,7 @@ public class MediaProvider extends ContentProvider {\n \n             FileUtils.sanitizeValues(values, /*rewriteHiddenFileName*/ !isFuseThread());\n             FileUtils.computeDataFromValues(values, volumePath, isFuseThread());\n+            assertFileColumnsConsistent(match, uri, values);\n \n             // Create result file\n             File res = new File(values.getAsString(MediaColumns.DATA));\ndiff --git a/tests/src/com/android/providers/media/MediaProviderTest.java b/tests/src/com/android/providers/media/MediaProviderTest.java\nindex 11fc327bd..284634772 100644\n--- a/tests/src/com/android/providers/media/MediaProviderTest.java\n+++ b/tests/src/com/android/providers/media/MediaProviderTest.java\n@@ -377,9 +377,8 @@ public class MediaProviderTest {\n     @Test\n     public void testInsertionWithInvalidFilePath_throwsIllegalArgumentException() {\n         final ContentValues values = new ContentValues();\n-        values.put(MediaStore.MediaColumns.RELATIVE_PATH, \"Android/media/com.example\");\n-        values.put(MediaStore.Images.Media.DISPLAY_NAME,\n-                \"./../../../../../../../../../../../data/media/test.txt\");\n+        values.put(MediaStore.MediaColumns.RELATIVE_PATH, \"Android/media/com.example/\");\n+        values.put(MediaStore.Images.Media.DISPLAY_NAME, \"data/media/test.txt\");\n \n         IllegalArgumentException illegalArgumentException = Assert.assertThrows(\n                 IllegalArgumentException.class, () -> sIsolatedResolver.insert(\n",
                            "downstream_patch_tokens": {
                                "openai": 606,
                                "general": {
                                    "word_based": 295,
                                    "char_based": 657
                                },
                                "gemini": 806
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "df39f8486b25473d0bdbeed896ad917e3c793bf9",
                            "repo_path": "android_repos/MediaProvider",
                            "result": "success",
                            "downstream_patch_content": "commit df39f8486b25473d0bdbeed896ad917e3c793bf9\nAuthor: Omar Eissa <oeissa@google.com>\nDate:   Mon Apr 15 12:04:56 2024 +0000\n\n    Prevent insertion in other users storage volumes\n    \n    Don't allow file insertion in other users storage volumes.\n    This was already handled if DATA was explicitly set in content values,\n    but was allowed if DATA was generated based on other values like RELATIVE_PATH and DISPLAY_NAME.\n    \n    Insertion of files in other users storage volumes can be used by malicious apps\n    to get access to other users files, since the same file would exist in both users MP databases\n    which would lead to MP falsely assuming that the user has access to this file.\n    \n    Bug: 294406604\n    Test: atest MediaProviderTests\n    Merged-In: Ie219bbdbe28819421040e4c083b65ab47d8ebde6\n    Change-Id: Ie219bbdbe28819421040e4c083b65ab47d8ebde6\n\ndiff --git a/src/com/android/providers/media/MediaProvider.java b/src/com/android/providers/media/MediaProvider.java\nindex 31bdf893f..97b6b3015 100644\n--- a/src/com/android/providers/media/MediaProvider.java\n+++ b/src/com/android/providers/media/MediaProvider.java\n@@ -3275,6 +3275,7 @@ public class MediaProvider extends ContentProvider {\n \n             FileUtils.sanitizeValues(values, /*rewriteHiddenFileName*/ !isFuseThread());\n             FileUtils.computeDataFromValues(values, volumePath, isFuseThread());\n+            assertFileColumnsConsistent(match, uri, values);\n \n             // Create result file\n             File res = new File(values.getAsString(MediaColumns.DATA));\ndiff --git a/tests/src/com/android/providers/media/MediaProviderTest.java b/tests/src/com/android/providers/media/MediaProviderTest.java\nindex 11fc327bd..284634772 100644\n--- a/tests/src/com/android/providers/media/MediaProviderTest.java\n+++ b/tests/src/com/android/providers/media/MediaProviderTest.java\n@@ -377,9 +377,8 @@ public class MediaProviderTest {\n     @Test\n     public void testInsertionWithInvalidFilePath_throwsIllegalArgumentException() {\n         final ContentValues values = new ContentValues();\n-        values.put(MediaStore.MediaColumns.RELATIVE_PATH, \"Android/media/com.example\");\n-        values.put(MediaStore.Images.Media.DISPLAY_NAME,\n-                \"./../../../../../../../../../../../data/media/test.txt\");\n+        values.put(MediaStore.MediaColumns.RELATIVE_PATH, \"Android/media/com.example/\");\n+        values.put(MediaStore.Images.Media.DISPLAY_NAME, \"data/media/test.txt\");\n \n         IllegalArgumentException illegalArgumentException = Assert.assertThrows(\n                 IllegalArgumentException.class, () -> sIsolatedResolver.insert(\n",
                            "downstream_patch_tokens": {
                                "openai": 606,
                                "general": {
                                    "word_based": 295,
                                    "char_based": 657
                                },
                                "gemini": 806
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "df39f8486b25473d0bdbeed896ad917e3c793bf9",
                            "repo_path": "android_repos/MediaProvider",
                            "result": "success",
                            "downstream_patch_content": "commit df39f8486b25473d0bdbeed896ad917e3c793bf9\nAuthor: Omar Eissa <oeissa@google.com>\nDate:   Mon Apr 15 12:04:56 2024 +0000\n\n    Prevent insertion in other users storage volumes\n    \n    Don't allow file insertion in other users storage volumes.\n    This was already handled if DATA was explicitly set in content values,\n    but was allowed if DATA was generated based on other values like RELATIVE_PATH and DISPLAY_NAME.\n    \n    Insertion of files in other users storage volumes can be used by malicious apps\n    to get access to other users files, since the same file would exist in both users MP databases\n    which would lead to MP falsely assuming that the user has access to this file.\n    \n    Bug: 294406604\n    Test: atest MediaProviderTests\n    Merged-In: Ie219bbdbe28819421040e4c083b65ab47d8ebde6\n    Change-Id: Ie219bbdbe28819421040e4c083b65ab47d8ebde6\n\ndiff --git a/src/com/android/providers/media/MediaProvider.java b/src/com/android/providers/media/MediaProvider.java\nindex 31bdf893f..97b6b3015 100644\n--- a/src/com/android/providers/media/MediaProvider.java\n+++ b/src/com/android/providers/media/MediaProvider.java\n@@ -3275,6 +3275,7 @@ public class MediaProvider extends ContentProvider {\n \n             FileUtils.sanitizeValues(values, /*rewriteHiddenFileName*/ !isFuseThread());\n             FileUtils.computeDataFromValues(values, volumePath, isFuseThread());\n+            assertFileColumnsConsistent(match, uri, values);\n \n             // Create result file\n             File res = new File(values.getAsString(MediaColumns.DATA));\ndiff --git a/tests/src/com/android/providers/media/MediaProviderTest.java b/tests/src/com/android/providers/media/MediaProviderTest.java\nindex 11fc327bd..284634772 100644\n--- a/tests/src/com/android/providers/media/MediaProviderTest.java\n+++ b/tests/src/com/android/providers/media/MediaProviderTest.java\n@@ -377,9 +377,8 @@ public class MediaProviderTest {\n     @Test\n     public void testInsertionWithInvalidFilePath_throwsIllegalArgumentException() {\n         final ContentValues values = new ContentValues();\n-        values.put(MediaStore.MediaColumns.RELATIVE_PATH, \"Android/media/com.example\");\n-        values.put(MediaStore.Images.Media.DISPLAY_NAME,\n-                \"./../../../../../../../../../../../data/media/test.txt\");\n+        values.put(MediaStore.MediaColumns.RELATIVE_PATH, \"Android/media/com.example/\");\n+        values.put(MediaStore.Images.Media.DISPLAY_NAME, \"data/media/test.txt\");\n \n         IllegalArgumentException illegalArgumentException = Assert.assertThrows(\n                 IllegalArgumentException.class, () -> sIsolatedResolver.insert(\n",
                            "downstream_patch_tokens": {
                                "openai": 606,
                                "general": {
                                    "word_based": 295,
                                    "char_based": 657
                                },
                                "gemini": 806
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "df39f8486b25473d0bdbeed896ad917e3c793bf9",
                            "repo_path": "android_repos/MediaProvider",
                            "result": "success",
                            "downstream_patch_content": "commit df39f8486b25473d0bdbeed896ad917e3c793bf9\nAuthor: Omar Eissa <oeissa@google.com>\nDate:   Mon Apr 15 12:04:56 2024 +0000\n\n    Prevent insertion in other users storage volumes\n    \n    Don't allow file insertion in other users storage volumes.\n    This was already handled if DATA was explicitly set in content values,\n    but was allowed if DATA was generated based on other values like RELATIVE_PATH and DISPLAY_NAME.\n    \n    Insertion of files in other users storage volumes can be used by malicious apps\n    to get access to other users files, since the same file would exist in both users MP databases\n    which would lead to MP falsely assuming that the user has access to this file.\n    \n    Bug: 294406604\n    Test: atest MediaProviderTests\n    Merged-In: Ie219bbdbe28819421040e4c083b65ab47d8ebde6\n    Change-Id: Ie219bbdbe28819421040e4c083b65ab47d8ebde6\n\ndiff --git a/src/com/android/providers/media/MediaProvider.java b/src/com/android/providers/media/MediaProvider.java\nindex 31bdf893f..97b6b3015 100644\n--- a/src/com/android/providers/media/MediaProvider.java\n+++ b/src/com/android/providers/media/MediaProvider.java\n@@ -3275,6 +3275,7 @@ public class MediaProvider extends ContentProvider {\n \n             FileUtils.sanitizeValues(values, /*rewriteHiddenFileName*/ !isFuseThread());\n             FileUtils.computeDataFromValues(values, volumePath, isFuseThread());\n+            assertFileColumnsConsistent(match, uri, values);\n \n             // Create result file\n             File res = new File(values.getAsString(MediaColumns.DATA));\ndiff --git a/tests/src/com/android/providers/media/MediaProviderTest.java b/tests/src/com/android/providers/media/MediaProviderTest.java\nindex 11fc327bd..284634772 100644\n--- a/tests/src/com/android/providers/media/MediaProviderTest.java\n+++ b/tests/src/com/android/providers/media/MediaProviderTest.java\n@@ -377,9 +377,8 @@ public class MediaProviderTest {\n     @Test\n     public void testInsertionWithInvalidFilePath_throwsIllegalArgumentException() {\n         final ContentValues values = new ContentValues();\n-        values.put(MediaStore.MediaColumns.RELATIVE_PATH, \"Android/media/com.example\");\n-        values.put(MediaStore.Images.Media.DISPLAY_NAME,\n-                \"./../../../../../../../../../../../data/media/test.txt\");\n+        values.put(MediaStore.MediaColumns.RELATIVE_PATH, \"Android/media/com.example/\");\n+        values.put(MediaStore.Images.Media.DISPLAY_NAME, \"data/media/test.txt\");\n \n         IllegalArgumentException illegalArgumentException = Assert.assertThrows(\n                 IllegalArgumentException.class, () -> sIsolatedResolver.insert(\n",
                            "downstream_patch_tokens": {
                                "openai": 606,
                                "general": {
                                    "word_based": 295,
                                    "char_based": 657
                                },
                                "gemini": 806
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-317048338",
            "aliases": [
                "A-317048338",
                "CVE-2024-34723"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-317048338",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "c5fc8ea92c0aabbb2fdccc23b743c18a8bf62e64"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From c5fc8ea92c0aabbb2fdccc23b743c18a8bf62e64 Mon Sep 17 00:00:00 2001\nFrom: Bishoy Gendy <bishoygendy@google.com>\nDate: Thu, 11 Apr 2024 16:37:10 +0000\nSubject: [PATCH] Fix security vulnerability allowing apps to start from\n background\n\nBug: 317048338\nTest: Using the steps in b/317048338#comment12\nChange-Id: Ia91199fdb23beed27bde687fdca8fe5d3a5a4759\n---\n .../media/session/ParcelableListBinder.java        | 13 +++++++++++--\n .../android/server/media/MediaSessionRecord.java   | 14 ++++++++------\n 2 files changed, 19 insertions(+), 8 deletions(-)\n\ndiff --git a/media/java/android/media/session/ParcelableListBinder.java b/media/java/android/media/session/ParcelableListBinder.java\nindex bbf1e0889b68..d78828462b1e 100644\n--- a/media/java/android/media/session/ParcelableListBinder.java\n+++ b/media/java/android/media/session/ParcelableListBinder.java\n@@ -45,6 +45,7 @@ public class ParcelableListBinder<T extends Parcelable> extends Binder {\n     private static final int END_OF_PARCEL = 0;\n     private static final int ITEM_CONTINUED = 1;\n \n+    private final Class<T> mListElementsClass;\n     private final Consumer<List<T>> mConsumer;\n \n     private final Object mLock = new Object();\n@@ -61,9 +62,11 @@ public class ParcelableListBinder<T extends Parcelable> extends Binder {\n     /**\n      * Creates an instance.\n      *\n+     * @param listElementsClass the class of the list elements.\n      * @param consumer a consumer that consumes the list received\n      */\n-    public ParcelableListBinder(@NonNull Consumer<List<T>> consumer) {\n+    public ParcelableListBinder(Class<T> listElementsClass, @NonNull Consumer<List<T>> consumer) {\n+        mListElementsClass = listElementsClass;\n         mConsumer = consumer;\n     }\n \n@@ -83,7 +86,13 @@ public class ParcelableListBinder<T extends Parcelable> extends Binder {\n                 mCount = data.readInt();\n             }\n             while (i < mCount && data.readInt() != END_OF_PARCEL) {\n-                mList.add(data.readParcelable(null));\n+                Object object = data.readParcelable(null);\n+                if (mListElementsClass.isAssignableFrom(object.getClass())) {\n+                    // Checking list items are of compaitible types to validate against malicious\n+                    // apps calling it directly via reflection with non compilable items.\n+                    // See b/317048338 for more details\n+                    mList.add((T) object);\n+                }\n                 i++;\n             }\n             if (i >= mCount) {\ndiff --git a/services/core/java/com/android/server/media/MediaSessionRecord.java b/services/core/java/com/android/server/media/MediaSessionRecord.java\nindex 8f164d361a56..3d6855547bcd 100644\n--- a/services/core/java/com/android/server/media/MediaSessionRecord.java\n+++ b/services/core/java/com/android/server/media/MediaSessionRecord.java\n@@ -1457,12 +1457,14 @@ public class MediaSessionRecord extends MediaSessionRecordImpl implements IBinde\n \n         @Override\n         public IBinder getBinderForSetQueue() throws RemoteException {\n-            return new ParcelableListBinder<QueueItem>((list) -> {\n-                synchronized (mLock) {\n-                    mQueue = list;\n-                }\n-                mHandler.post(MessageHandler.MSG_UPDATE_QUEUE);\n-            });\n+            return new ParcelableListBinder<QueueItem>(\n+                    QueueItem.class,\n+                    (list) -> {\n+                        synchronized (mLock) {\n+                            mQueue = list;\n+                        }\n+                        mHandler.post(MessageHandler.MSG_UPDATE_QUEUE);\n+                    });\n         }\n \n         @Override\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 865,
                        "general": {
                            "word_based": 367,
                            "char_based": 927
                        },
                        "gemini": 1108
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "df3584bb93ab89d7e174f7d39e42d4b22cb92fe0",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit df3584bb93ab89d7e174f7d39e42d4b22cb92fe0\nAuthor: Bishoy Gendy <bishoygendy@google.com>\nDate:   Thu Apr 11 16:37:10 2024 +0000\n\n    Fix security vulnerability allowing apps to start from background\n    \n    Bug: 317048338\n    Test: Using the steps in b/317048338#comment12\n    Change-Id: Ia91199fdb23beed27bde687fdca8fe5d3a5a4759\n    (cherry picked from commit c5fc8ea92c0aabbb2fdccc23b743c18a8bf62e64)\n    Merged-In: Ia91199fdb23beed27bde687fdca8fe5d3a5a4759\n\ndiff --git a/media/java/android/media/session/ParcelableListBinder.java b/media/java/android/media/session/ParcelableListBinder.java\nindex bbf1e0889b68..d78828462b1e 100644\n--- a/media/java/android/media/session/ParcelableListBinder.java\n+++ b/media/java/android/media/session/ParcelableListBinder.java\n@@ -45,6 +45,7 @@ public class ParcelableListBinder<T extends Parcelable> extends Binder {\n     private static final int END_OF_PARCEL = 0;\n     private static final int ITEM_CONTINUED = 1;\n \n+    private final Class<T> mListElementsClass;\n     private final Consumer<List<T>> mConsumer;\n \n     private final Object mLock = new Object();\n@@ -61,9 +62,11 @@ public class ParcelableListBinder<T extends Parcelable> extends Binder {\n     /**\n      * Creates an instance.\n      *\n+     * @param listElementsClass the class of the list elements.\n      * @param consumer a consumer that consumes the list received\n      */\n-    public ParcelableListBinder(@NonNull Consumer<List<T>> consumer) {\n+    public ParcelableListBinder(Class<T> listElementsClass, @NonNull Consumer<List<T>> consumer) {\n+        mListElementsClass = listElementsClass;\n         mConsumer = consumer;\n     }\n \n@@ -83,7 +86,13 @@ public class ParcelableListBinder<T extends Parcelable> extends Binder {\n                 mCount = data.readInt();\n             }\n             while (i < mCount && data.readInt() != END_OF_PARCEL) {\n-                mList.add(data.readParcelable(null));\n+                Object object = data.readParcelable(null);\n+                if (mListElementsClass.isAssignableFrom(object.getClass())) {\n+                    // Checking list items are of compaitible types to validate against malicious\n+                    // apps calling it directly via reflection with non compilable items.\n+                    // See b/317048338 for more details\n+                    mList.add((T) object);\n+                }\n                 i++;\n             }\n             if (i >= mCount) {\ndiff --git a/services/core/java/com/android/server/media/MediaSessionRecord.java b/services/core/java/com/android/server/media/MediaSessionRecord.java\nindex 82dd478aa028..becb944101f2 100644\n--- a/services/core/java/com/android/server/media/MediaSessionRecord.java\n+++ b/services/core/java/com/android/server/media/MediaSessionRecord.java\n@@ -1095,12 +1095,14 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n \n         @Override\n         public IBinder getBinderForSetQueue() throws RemoteException {\n-            return new ParcelableListBinder<QueueItem>((list) -> {\n-                synchronized (mLock) {\n-                    mQueue = list;\n-                }\n-                mHandler.post(MessageHandler.MSG_UPDATE_QUEUE);\n-            });\n+            return new ParcelableListBinder<QueueItem>(\n+                    QueueItem.class,\n+                    (list) -> {\n+                        synchronized (mLock) {\n+                            mQueue = list;\n+                        }\n+                        mHandler.post(MessageHandler.MSG_UPDATE_QUEUE);\n+                    });\n         }\n \n         @Override\n",
                            "downstream_patch_tokens": {
                                "openai": 847,
                                "general": {
                                    "word_based": 342,
                                    "char_based": 899
                                },
                                "gemini": 1089
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "df3584bb93ab89d7e174f7d39e42d4b22cb92fe0",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit df3584bb93ab89d7e174f7d39e42d4b22cb92fe0\nAuthor: Bishoy Gendy <bishoygendy@google.com>\nDate:   Thu Apr 11 16:37:10 2024 +0000\n\n    Fix security vulnerability allowing apps to start from background\n    \n    Bug: 317048338\n    Test: Using the steps in b/317048338#comment12\n    Change-Id: Ia91199fdb23beed27bde687fdca8fe5d3a5a4759\n    (cherry picked from commit c5fc8ea92c0aabbb2fdccc23b743c18a8bf62e64)\n    Merged-In: Ia91199fdb23beed27bde687fdca8fe5d3a5a4759\n\ndiff --git a/media/java/android/media/session/ParcelableListBinder.java b/media/java/android/media/session/ParcelableListBinder.java\nindex bbf1e0889b68..d78828462b1e 100644\n--- a/media/java/android/media/session/ParcelableListBinder.java\n+++ b/media/java/android/media/session/ParcelableListBinder.java\n@@ -45,6 +45,7 @@ public class ParcelableListBinder<T extends Parcelable> extends Binder {\n     private static final int END_OF_PARCEL = 0;\n     private static final int ITEM_CONTINUED = 1;\n \n+    private final Class<T> mListElementsClass;\n     private final Consumer<List<T>> mConsumer;\n \n     private final Object mLock = new Object();\n@@ -61,9 +62,11 @@ public class ParcelableListBinder<T extends Parcelable> extends Binder {\n     /**\n      * Creates an instance.\n      *\n+     * @param listElementsClass the class of the list elements.\n      * @param consumer a consumer that consumes the list received\n      */\n-    public ParcelableListBinder(@NonNull Consumer<List<T>> consumer) {\n+    public ParcelableListBinder(Class<T> listElementsClass, @NonNull Consumer<List<T>> consumer) {\n+        mListElementsClass = listElementsClass;\n         mConsumer = consumer;\n     }\n \n@@ -83,7 +86,13 @@ public class ParcelableListBinder<T extends Parcelable> extends Binder {\n                 mCount = data.readInt();\n             }\n             while (i < mCount && data.readInt() != END_OF_PARCEL) {\n-                mList.add(data.readParcelable(null));\n+                Object object = data.readParcelable(null);\n+                if (mListElementsClass.isAssignableFrom(object.getClass())) {\n+                    // Checking list items are of compaitible types to validate against malicious\n+                    // apps calling it directly via reflection with non compilable items.\n+                    // See b/317048338 for more details\n+                    mList.add((T) object);\n+                }\n                 i++;\n             }\n             if (i >= mCount) {\ndiff --git a/services/core/java/com/android/server/media/MediaSessionRecord.java b/services/core/java/com/android/server/media/MediaSessionRecord.java\nindex 82dd478aa028..becb944101f2 100644\n--- a/services/core/java/com/android/server/media/MediaSessionRecord.java\n+++ b/services/core/java/com/android/server/media/MediaSessionRecord.java\n@@ -1095,12 +1095,14 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n \n         @Override\n         public IBinder getBinderForSetQueue() throws RemoteException {\n-            return new ParcelableListBinder<QueueItem>((list) -> {\n-                synchronized (mLock) {\n-                    mQueue = list;\n-                }\n-                mHandler.post(MessageHandler.MSG_UPDATE_QUEUE);\n-            });\n+            return new ParcelableListBinder<QueueItem>(\n+                    QueueItem.class,\n+                    (list) -> {\n+                        synchronized (mLock) {\n+                            mQueue = list;\n+                        }\n+                        mHandler.post(MessageHandler.MSG_UPDATE_QUEUE);\n+                    });\n         }\n \n         @Override\n",
                            "downstream_patch_tokens": {
                                "openai": 847,
                                "general": {
                                    "word_based": 342,
                                    "char_based": 899
                                },
                                "gemini": 1089
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "df3584bb93ab89d7e174f7d39e42d4b22cb92fe0",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit df3584bb93ab89d7e174f7d39e42d4b22cb92fe0\nAuthor: Bishoy Gendy <bishoygendy@google.com>\nDate:   Thu Apr 11 16:37:10 2024 +0000\n\n    Fix security vulnerability allowing apps to start from background\n    \n    Bug: 317048338\n    Test: Using the steps in b/317048338#comment12\n    Change-Id: Ia91199fdb23beed27bde687fdca8fe5d3a5a4759\n    (cherry picked from commit c5fc8ea92c0aabbb2fdccc23b743c18a8bf62e64)\n    Merged-In: Ia91199fdb23beed27bde687fdca8fe5d3a5a4759\n\ndiff --git a/media/java/android/media/session/ParcelableListBinder.java b/media/java/android/media/session/ParcelableListBinder.java\nindex bbf1e0889b68..d78828462b1e 100644\n--- a/media/java/android/media/session/ParcelableListBinder.java\n+++ b/media/java/android/media/session/ParcelableListBinder.java\n@@ -45,6 +45,7 @@ public class ParcelableListBinder<T extends Parcelable> extends Binder {\n     private static final int END_OF_PARCEL = 0;\n     private static final int ITEM_CONTINUED = 1;\n \n+    private final Class<T> mListElementsClass;\n     private final Consumer<List<T>> mConsumer;\n \n     private final Object mLock = new Object();\n@@ -61,9 +62,11 @@ public class ParcelableListBinder<T extends Parcelable> extends Binder {\n     /**\n      * Creates an instance.\n      *\n+     * @param listElementsClass the class of the list elements.\n      * @param consumer a consumer that consumes the list received\n      */\n-    public ParcelableListBinder(@NonNull Consumer<List<T>> consumer) {\n+    public ParcelableListBinder(Class<T> listElementsClass, @NonNull Consumer<List<T>> consumer) {\n+        mListElementsClass = listElementsClass;\n         mConsumer = consumer;\n     }\n \n@@ -83,7 +86,13 @@ public class ParcelableListBinder<T extends Parcelable> extends Binder {\n                 mCount = data.readInt();\n             }\n             while (i < mCount && data.readInt() != END_OF_PARCEL) {\n-                mList.add(data.readParcelable(null));\n+                Object object = data.readParcelable(null);\n+                if (mListElementsClass.isAssignableFrom(object.getClass())) {\n+                    // Checking list items are of compaitible types to validate against malicious\n+                    // apps calling it directly via reflection with non compilable items.\n+                    // See b/317048338 for more details\n+                    mList.add((T) object);\n+                }\n                 i++;\n             }\n             if (i >= mCount) {\ndiff --git a/services/core/java/com/android/server/media/MediaSessionRecord.java b/services/core/java/com/android/server/media/MediaSessionRecord.java\nindex 82dd478aa028..becb944101f2 100644\n--- a/services/core/java/com/android/server/media/MediaSessionRecord.java\n+++ b/services/core/java/com/android/server/media/MediaSessionRecord.java\n@@ -1095,12 +1095,14 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n \n         @Override\n         public IBinder getBinderForSetQueue() throws RemoteException {\n-            return new ParcelableListBinder<QueueItem>((list) -> {\n-                synchronized (mLock) {\n-                    mQueue = list;\n-                }\n-                mHandler.post(MessageHandler.MSG_UPDATE_QUEUE);\n-            });\n+            return new ParcelableListBinder<QueueItem>(\n+                    QueueItem.class,\n+                    (list) -> {\n+                        synchronized (mLock) {\n+                            mQueue = list;\n+                        }\n+                        mHandler.post(MessageHandler.MSG_UPDATE_QUEUE);\n+                    });\n         }\n \n         @Override\n",
                            "downstream_patch_tokens": {
                                "openai": 847,
                                "general": {
                                    "word_based": 342,
                                    "char_based": 899
                                },
                                "gemini": 1089
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "df3584bb93ab89d7e174f7d39e42d4b22cb92fe0",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit df3584bb93ab89d7e174f7d39e42d4b22cb92fe0\nAuthor: Bishoy Gendy <bishoygendy@google.com>\nDate:   Thu Apr 11 16:37:10 2024 +0000\n\n    Fix security vulnerability allowing apps to start from background\n    \n    Bug: 317048338\n    Test: Using the steps in b/317048338#comment12\n    Change-Id: Ia91199fdb23beed27bde687fdca8fe5d3a5a4759\n    (cherry picked from commit c5fc8ea92c0aabbb2fdccc23b743c18a8bf62e64)\n    Merged-In: Ia91199fdb23beed27bde687fdca8fe5d3a5a4759\n\ndiff --git a/media/java/android/media/session/ParcelableListBinder.java b/media/java/android/media/session/ParcelableListBinder.java\nindex bbf1e0889b68..d78828462b1e 100644\n--- a/media/java/android/media/session/ParcelableListBinder.java\n+++ b/media/java/android/media/session/ParcelableListBinder.java\n@@ -45,6 +45,7 @@ public class ParcelableListBinder<T extends Parcelable> extends Binder {\n     private static final int END_OF_PARCEL = 0;\n     private static final int ITEM_CONTINUED = 1;\n \n+    private final Class<T> mListElementsClass;\n     private final Consumer<List<T>> mConsumer;\n \n     private final Object mLock = new Object();\n@@ -61,9 +62,11 @@ public class ParcelableListBinder<T extends Parcelable> extends Binder {\n     /**\n      * Creates an instance.\n      *\n+     * @param listElementsClass the class of the list elements.\n      * @param consumer a consumer that consumes the list received\n      */\n-    public ParcelableListBinder(@NonNull Consumer<List<T>> consumer) {\n+    public ParcelableListBinder(Class<T> listElementsClass, @NonNull Consumer<List<T>> consumer) {\n+        mListElementsClass = listElementsClass;\n         mConsumer = consumer;\n     }\n \n@@ -83,7 +86,13 @@ public class ParcelableListBinder<T extends Parcelable> extends Binder {\n                 mCount = data.readInt();\n             }\n             while (i < mCount && data.readInt() != END_OF_PARCEL) {\n-                mList.add(data.readParcelable(null));\n+                Object object = data.readParcelable(null);\n+                if (mListElementsClass.isAssignableFrom(object.getClass())) {\n+                    // Checking list items are of compaitible types to validate against malicious\n+                    // apps calling it directly via reflection with non compilable items.\n+                    // See b/317048338 for more details\n+                    mList.add((T) object);\n+                }\n                 i++;\n             }\n             if (i >= mCount) {\ndiff --git a/services/core/java/com/android/server/media/MediaSessionRecord.java b/services/core/java/com/android/server/media/MediaSessionRecord.java\nindex 82dd478aa028..becb944101f2 100644\n--- a/services/core/java/com/android/server/media/MediaSessionRecord.java\n+++ b/services/core/java/com/android/server/media/MediaSessionRecord.java\n@@ -1095,12 +1095,14 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n \n         @Override\n         public IBinder getBinderForSetQueue() throws RemoteException {\n-            return new ParcelableListBinder<QueueItem>((list) -> {\n-                synchronized (mLock) {\n-                    mQueue = list;\n-                }\n-                mHandler.post(MessageHandler.MSG_UPDATE_QUEUE);\n-            });\n+            return new ParcelableListBinder<QueueItem>(\n+                    QueueItem.class,\n+                    (list) -> {\n+                        synchronized (mLock) {\n+                            mQueue = list;\n+                        }\n+                        mHandler.post(MessageHandler.MSG_UPDATE_QUEUE);\n+                    });\n         }\n \n         @Override\n",
                            "downstream_patch_tokens": {
                                "openai": 847,
                                "general": {
                                    "word_based": 342,
                                    "char_based": 899
                                },
                                "gemini": 1089
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-349780950",
            "aliases": [
                "A-349780950",
                "CVE-2024-40676"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-349780950",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "c1e79495a49bd4d3e380136fe4bca7ac1a9ed763"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From c1e79495a49bd4d3e380136fe4bca7ac1a9ed763 Mon Sep 17 00:00:00 2001\nFrom: Dmitry Dementyev <dementyev@google.com>\nDate: Thu, 11 Jul 2024 12:39:22 -0700\nSubject: [PATCH] Update AccountManagerService checkKeyIntent.\n\nBlock intents with \"content\" data scheme.\n\nBug: 349780950\nTest: manual\nFlag: EXEMPT bugfix\nChange-Id: I8b23191d3d60036ca7ddf0ef7dcba6b38fb27b3c\n---\n .../com/android/server/accounts/AccountManagerService.java     | 3 +++\n 1 file changed, 3 insertions(+)\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex 320122390681..458749d93e0a 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -5052,6 +5052,9 @@ public class AccountManagerService\n                 if (resolveInfo == null) {\n                     return false;\n                 }\n+                if (\"content\".equals(intent.getScheme())) {\n+                    return false;\n+                }\n                 ActivityInfo targetActivityInfo = resolveInfo.activityInfo;\n                 int targetUid = targetActivityInfo.applicationInfo.uid;\n                 PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 360,
                        "general": {
                            "word_based": 143,
                            "char_based": 346
                        },
                        "gemini": 474
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "f483640dfc954f4c6028f8cb35c1582dd1482c4b",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit f483640dfc954f4c6028f8cb35c1582dd1482c4b\nAuthor: Dmitry Dementyev <dementyev@google.com>\nDate:   Thu Jul 11 12:39:22 2024 -0700\n\n    Update AccountManagerService checkKeyIntent.\n    \n    Block intents with \"content\" data scheme.\n    \n    Bug: 349780950\n    Test: manual\n    Flag: EXEMPT bugfix\n    Change-Id: I8b23191d3d60036ca7ddf0ef7dcba6b38fb27b3c\n    (cherry picked from commit c1e79495a49bd4d3e380136fe4bca7ac1a9ed763)\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex 43944b050de4..d55be44f62cd 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -4895,6 +4895,9 @@ public class AccountManagerService\n                 if (resolveInfo == null) {\n                     return false;\n                 }\n+                if (\"content\".equals(intent.getScheme())) {\n+                    return false;\n+                }\n                 ActivityInfo targetActivityInfo = resolveInfo.activityInfo;\n                 int targetUid = targetActivityInfo.applicationInfo.uid;\n                 PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n",
                            "downstream_patch_tokens": {
                                "openai": 342,
                                "general": {
                                    "word_based": 121,
                                    "char_based": 329
                                },
                                "gemini": 451
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "f483640dfc954f4c6028f8cb35c1582dd1482c4b",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit f483640dfc954f4c6028f8cb35c1582dd1482c4b\nAuthor: Dmitry Dementyev <dementyev@google.com>\nDate:   Thu Jul 11 12:39:22 2024 -0700\n\n    Update AccountManagerService checkKeyIntent.\n    \n    Block intents with \"content\" data scheme.\n    \n    Bug: 349780950\n    Test: manual\n    Flag: EXEMPT bugfix\n    Change-Id: I8b23191d3d60036ca7ddf0ef7dcba6b38fb27b3c\n    (cherry picked from commit c1e79495a49bd4d3e380136fe4bca7ac1a9ed763)\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex 43944b050de4..d55be44f62cd 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -4895,6 +4895,9 @@ public class AccountManagerService\n                 if (resolveInfo == null) {\n                     return false;\n                 }\n+                if (\"content\".equals(intent.getScheme())) {\n+                    return false;\n+                }\n                 ActivityInfo targetActivityInfo = resolveInfo.activityInfo;\n                 int targetUid = targetActivityInfo.applicationInfo.uid;\n                 PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n",
                            "downstream_patch_tokens": {
                                "openai": 342,
                                "general": {
                                    "word_based": 121,
                                    "char_based": 329
                                },
                                "gemini": 451
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "f483640dfc954f4c6028f8cb35c1582dd1482c4b",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit f483640dfc954f4c6028f8cb35c1582dd1482c4b\nAuthor: Dmitry Dementyev <dementyev@google.com>\nDate:   Thu Jul 11 12:39:22 2024 -0700\n\n    Update AccountManagerService checkKeyIntent.\n    \n    Block intents with \"content\" data scheme.\n    \n    Bug: 349780950\n    Test: manual\n    Flag: EXEMPT bugfix\n    Change-Id: I8b23191d3d60036ca7ddf0ef7dcba6b38fb27b3c\n    (cherry picked from commit c1e79495a49bd4d3e380136fe4bca7ac1a9ed763)\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex 43944b050de4..d55be44f62cd 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -4895,6 +4895,9 @@ public class AccountManagerService\n                 if (resolveInfo == null) {\n                     return false;\n                 }\n+                if (\"content\".equals(intent.getScheme())) {\n+                    return false;\n+                }\n                 ActivityInfo targetActivityInfo = resolveInfo.activityInfo;\n                 int targetUid = targetActivityInfo.applicationInfo.uid;\n                 PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n",
                            "downstream_patch_tokens": {
                                "openai": 342,
                                "general": {
                                    "word_based": 121,
                                    "char_based": 329
                                },
                                "gemini": 451
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "f483640dfc954f4c6028f8cb35c1582dd1482c4b",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit f483640dfc954f4c6028f8cb35c1582dd1482c4b\nAuthor: Dmitry Dementyev <dementyev@google.com>\nDate:   Thu Jul 11 12:39:22 2024 -0700\n\n    Update AccountManagerService checkKeyIntent.\n    \n    Block intents with \"content\" data scheme.\n    \n    Bug: 349780950\n    Test: manual\n    Flag: EXEMPT bugfix\n    Change-Id: I8b23191d3d60036ca7ddf0ef7dcba6b38fb27b3c\n    (cherry picked from commit c1e79495a49bd4d3e380136fe4bca7ac1a9ed763)\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex 43944b050de4..d55be44f62cd 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -4895,6 +4895,9 @@ public class AccountManagerService\n                 if (resolveInfo == null) {\n                     return false;\n                 }\n+                if (\"content\".equals(intent.getScheme())) {\n+                    return false;\n+                }\n                 ActivityInfo targetActivityInfo = resolveInfo.activityInfo;\n                 int targetUid = targetActivityInfo.applicationInfo.uid;\n                 PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n",
                            "downstream_patch_tokens": {
                                "openai": 342,
                                "general": {
                                    "word_based": 121,
                                    "char_based": 329
                                },
                                "gemini": 451
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-287184435",
            "aliases": [
                "A-287184435",
                "CVE-2024-34727"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-287184435",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "041220978bd8cb0573a7a6679e16cfc843cc9a39"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 041220978bd8cb0573a7a6679e16cfc843cc9a39 Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Wed, 1 Nov 2023 23:54:17 +0000\nSubject: [PATCH] Fix heap-buffer overflow in sdp_utils.cc\n\nFuzzer identifies a case where sdpu_compare_uuid_with_attr crashes with\nan out of bounds comparison.  Although the bug claims this is due to a\ncomparison of a uuid with a smaller data field thana the discovery\nattribute, my research suggests that this instead stems from a\ncomparison of a 128 bit UUID with a discovery attribute of some other,\ninvalid size.\n\nAdd checks for discovery attribute size.\n\nBug: 287184435\nTest: atest bluetooth_test_gd_unit, net_test_stack_sdp\nTag: #security\nIgnore-AOSP-First: Security\nChange-Id: Id06699e51937515b2465f0b3ad72eab9e0a8e532\n---\n system/stack/sdp/sdp_utils.cc | 24 ++++++++++++++++++++++--\n 1 file changed, 22 insertions(+), 2 deletions(-)\n\ndiff --git a/system/stack/sdp/sdp_utils.cc b/system/stack/sdp/sdp_utils.cc\nindex 7ed93a0827..076a944b0c 100644\n--- a/system/stack/sdp/sdp_utils.cc\n+++ b/system/stack/sdp/sdp_utils.cc\n@@ -1137,8 +1137,28 @@ bool sdpu_compare_uuid_arrays(const uint8_t* p_uuid1, uint32_t len1,\n  ******************************************************************************/\n bool sdpu_compare_uuid_with_attr(const Uuid& uuid, tSDP_DISC_ATTR* p_attr) {\n   int len = uuid.GetShortestRepresentationSize();\n-  if (len == 2) return uuid.As16Bit() == p_attr->attr_value.v.u16;\n-  if (len == 4) return uuid.As32Bit() == p_attr->attr_value.v.u32;\n+  if (len == 2) {\n+    if (SDP_DISC_ATTR_LEN(p_attr->attr_len_type) == Uuid::kNumBytes16) {\n+      return uuid.As16Bit() == p_attr->attr_value.v.u16;\n+    } else {\n+      LOG_ERROR(\"invalid length for discovery attribute\");\n+      return (false);\n+    }\n+  }\n+  if (len == 4) {\n+    if (SDP_DISC_ATTR_LEN(p_attr->attr_len_type) == Uuid::kNumBytes32) {\n+      return uuid.As32Bit() == p_attr->attr_value.v.u32;\n+    } else {\n+      LOG_ERROR(\"invalid length for discovery attribute\");\n+      return (false);\n+    }\n+  }\n+\n+  if (SDP_DISC_ATTR_LEN(p_attr->attr_len_type) != Uuid::kNumBytes128) {\n+    LOG_ERROR(\"invalid length for discovery attribute\");\n+    return (false);\n+  }\n+\n   if (memcmp(uuid.To128BitBE().data(), (void*)p_attr->attr_value.v.array,\n              Uuid::kNumBytes128) == 0)\n     return (true);\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 727,
                        "general": {
                            "word_based": 283,
                            "char_based": 589
                        },
                        "gemini": 936
                    },
                    "total_downstream_versions_tested": 2,
                    "successful_patches": 2,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "7bbdb139bf91dca86c72c33a74c0e3407938c487",
                            "repo_path": "android_repos/Bluetooth",
                            "result": "success",
                            "downstream_patch_content": "commit 7bbdb139bf91dca86c72c33a74c0e3407938c487\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Mon Apr 22 17:21:30 2024 +0000\n\n    Fix heap-buffer overflow in sdp_utils.cc\n    \n    Fuzzer identifies a case where sdpu_compare_uuid_with_attr crashes with\n    an out of bounds comparison.  Although the bug claims this is due to a\n    comparison of a uuid with a smaller data field thana the discovery\n    attribute, my research suggests that this instead stems from a\n    comparison of a 128 bit UUID with a discovery attribute of some other,\n    invalid size.\n    \n    Add checks for discovery attribute size.\n    \n    Bug: 287184435\n    Test: atest bluetooth_test_gd_unit, net_test_stack_sdp\n    Tag: #security\n    Ignore-AOSP-First: Security\n    Merged-In: Id06699e51937515b2465f0b3ad72eab9e0a8e532\n    Change-Id: I8e16ae525815bcdd47a2379ee8e5a6de47a3ac43\n\ndiff --git a/system/stack/sdp/sdp_utils.cc b/system/stack/sdp/sdp_utils.cc\nindex 9d6dc6fe0a..f45a7707f0 100644\n--- a/system/stack/sdp/sdp_utils.cc\n+++ b/system/stack/sdp/sdp_utils.cc\n@@ -966,8 +966,28 @@ bool sdpu_compare_uuid_arrays(const uint8_t* p_uuid1, uint32_t len1,\n  ******************************************************************************/\n bool sdpu_compare_uuid_with_attr(const Uuid& uuid, tSDP_DISC_ATTR* p_attr) {\n   int len = uuid.GetShortestRepresentationSize();\n-  if (len == 2) return uuid.As16Bit() == p_attr->attr_value.v.u16;\n-  if (len == 4) return uuid.As32Bit() == p_attr->attr_value.v.u32;\n+  if (len == 2) {\n+    if (SDP_DISC_ATTR_LEN(p_attr->attr_len_type) == Uuid::kNumBytes16) {\n+      return uuid.As16Bit() == p_attr->attr_value.v.u16;\n+    } else {\n+      LOG(ERROR) << \"invalid length for discovery attribute\";\n+      return (false);\n+    }\n+  }\n+  if (len == 4) {\n+    if (SDP_DISC_ATTR_LEN(p_attr->attr_len_type) == Uuid::kNumBytes32) {\n+      return uuid.As32Bit() == p_attr->attr_value.v.u32;\n+    } else {\n+      LOG(ERROR) << \"invalid length for discovery attribute\";\n+      return (false);\n+    }\n+  }\n+\n+  if (SDP_DISC_ATTR_LEN(p_attr->attr_len_type) != Uuid::kNumBytes128) {\n+    LOG(ERROR) << \"invalid length for discovery attribute\";\n+    return (false);\n+  }\n+\n   if (memcmp(uuid.To128BitBE().data(), (void*)p_attr->attr_value.v.array,\n              Uuid::kNumBytes128) == 0)\n     return (true);\n",
                            "downstream_patch_tokens": {
                                "openai": 715,
                                "general": {
                                    "word_based": 261,
                                    "char_based": 577
                                },
                                "gemini": 920
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "7bbdb139bf91dca86c72c33a74c0e3407938c487",
                            "repo_path": "android_repos/Bluetooth",
                            "result": "success",
                            "downstream_patch_content": "commit 7bbdb139bf91dca86c72c33a74c0e3407938c487\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Mon Apr 22 17:21:30 2024 +0000\n\n    Fix heap-buffer overflow in sdp_utils.cc\n    \n    Fuzzer identifies a case where sdpu_compare_uuid_with_attr crashes with\n    an out of bounds comparison.  Although the bug claims this is due to a\n    comparison of a uuid with a smaller data field thana the discovery\n    attribute, my research suggests that this instead stems from a\n    comparison of a 128 bit UUID with a discovery attribute of some other,\n    invalid size.\n    \n    Add checks for discovery attribute size.\n    \n    Bug: 287184435\n    Test: atest bluetooth_test_gd_unit, net_test_stack_sdp\n    Tag: #security\n    Ignore-AOSP-First: Security\n    Merged-In: Id06699e51937515b2465f0b3ad72eab9e0a8e532\n    Change-Id: I8e16ae525815bcdd47a2379ee8e5a6de47a3ac43\n\ndiff --git a/system/stack/sdp/sdp_utils.cc b/system/stack/sdp/sdp_utils.cc\nindex 9d6dc6fe0a..f45a7707f0 100644\n--- a/system/stack/sdp/sdp_utils.cc\n+++ b/system/stack/sdp/sdp_utils.cc\n@@ -966,8 +966,28 @@ bool sdpu_compare_uuid_arrays(const uint8_t* p_uuid1, uint32_t len1,\n  ******************************************************************************/\n bool sdpu_compare_uuid_with_attr(const Uuid& uuid, tSDP_DISC_ATTR* p_attr) {\n   int len = uuid.GetShortestRepresentationSize();\n-  if (len == 2) return uuid.As16Bit() == p_attr->attr_value.v.u16;\n-  if (len == 4) return uuid.As32Bit() == p_attr->attr_value.v.u32;\n+  if (len == 2) {\n+    if (SDP_DISC_ATTR_LEN(p_attr->attr_len_type) == Uuid::kNumBytes16) {\n+      return uuid.As16Bit() == p_attr->attr_value.v.u16;\n+    } else {\n+      LOG(ERROR) << \"invalid length for discovery attribute\";\n+      return (false);\n+    }\n+  }\n+  if (len == 4) {\n+    if (SDP_DISC_ATTR_LEN(p_attr->attr_len_type) == Uuid::kNumBytes32) {\n+      return uuid.As32Bit() == p_attr->attr_value.v.u32;\n+    } else {\n+      LOG(ERROR) << \"invalid length for discovery attribute\";\n+      return (false);\n+    }\n+  }\n+\n+  if (SDP_DISC_ATTR_LEN(p_attr->attr_len_type) != Uuid::kNumBytes128) {\n+    LOG(ERROR) << \"invalid length for discovery attribute\";\n+    return (false);\n+  }\n+\n   if (memcmp(uuid.To128BitBE().data(), (void*)p_attr->attr_value.v.array,\n              Uuid::kNumBytes128) == 0)\n     return (true);\n",
                            "downstream_patch_tokens": {
                                "openai": 715,
                                "general": {
                                    "word_based": 261,
                                    "char_based": 577
                                },
                                "gemini": 920
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-311687929",
            "aliases": [
                "A-311687929",
                "CVE-2024-0047"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-311687929",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "24202a9b15c17739f211ede23d2afbd3be59365b",
                        "739281096aba494151f8c953f2d63ec9fd4c7e87",
                        "5394ddbee5dd88a35e2a9a8508dc260395895ac1"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 24202a9b15c17739f211ede23d2afbd3be59365b Mon Sep 17 00:00:00 2001\nFrom: Jason Parks <jparks@google.com>\nDate: Wed, 6 Sep 2023 17:10:55 +0000\nSubject: [PATCH] Properly store device policy user restrictions.\n\nBug: 299302474\nTest: btest \"android.devicepolicy.cts.UserRestrictionsTest\" && atest UserManagerServiceUserInfoTest#testWriteReadDevicePolicyUserRestrictions\nChange-Id: I66159f362b45d4c9e322754ff272c373b2557812\n---\n .../android/server/pm/UserManagerService.java |  7 ++--\n .../pm/UserManagerServiceUserInfoTest.java    | 36 +++++++++++++++++++\n 2 files changed, 40 insertions(+), 3 deletions(-)\n\ndiff --git a/services/core/java/com/android/server/pm/UserManagerService.java b/services/core/java/com/android/server/pm/UserManagerService.java\nindex cab90d24ca39..f5c5867edb53 100644\n--- a/services/core/java/com/android/server/pm/UserManagerService.java\n+++ b/services/core/java/com/android/server/pm/UserManagerService.java\n@@ -2665,7 +2665,8 @@ public class UserManagerService extends IUserManager.Stub {\n         }\n     }\n \n-    private void setUserRestrictionInner(int userId, @NonNull String key, boolean value) {\n+    @VisibleForTesting\n+    void setUserRestrictionInner(int userId, @NonNull String key, boolean value) {\n         if (!UserRestrictionsUtils.isValidRestriction(key)) {\n             Slog.e(LOG_TAG, \"Setting invalid restriction \" + key);\n             return;\n@@ -4273,11 +4274,11 @@ public class UserManagerService extends IUserManager.Stub {\n \n             UserRestrictionsUtils.writeRestrictions(serializer,\n                     mDevicePolicyUserRestrictions.getRestrictions(UserHandle.USER_ALL),\n-                    TAG_DEVICE_POLICY_RESTRICTIONS);\n+                    TAG_DEVICE_POLICY_GLOBAL_RESTRICTIONS);\n \n             UserRestrictionsUtils.writeRestrictions(serializer,\n                     mDevicePolicyUserRestrictions.getRestrictions(userInfo.id),\n-                    TAG_DEVICE_POLICY_RESTRICTIONS);\n+                    TAG_DEVICE_POLICY_LOCAL_RESTRICTIONS);\n         }\n \n         if (userData.account != null) {\ndiff --git a/services/tests/servicestests/src/com/android/server/pm/UserManagerServiceUserInfoTest.java b/services/tests/servicestests/src/com/android/server/pm/UserManagerServiceUserInfoTest.java\nindex 2273fcd22b38..9f75cf8d552e 100644\n--- a/services/tests/servicestests/src/com/android/server/pm/UserManagerServiceUserInfoTest.java\n+++ b/services/tests/servicestests/src/com/android/server/pm/UserManagerServiceUserInfoTest.java\n@@ -113,6 +113,42 @@ public class UserManagerServiceUserInfoTest {\n         assertUserInfoEquals(data.info, read.info, /* parcelCopy= */ false);\n     }\n \n+    /** Tests that device policy restrictions are written/read properly. */\n+    @Test\n+    public void testWriteReadDevicePolicyUserRestrictions() throws Exception {\n+        final String globalRestriction = UserManager.DISALLOW_FACTORY_RESET;\n+        final String localRestriction = UserManager.DISALLOW_CONFIG_DATE_TIME;\n+\n+        UserData data = new UserData();\n+        data.info = createUser(100, FLAG_FULL, \"A type\");\n+\n+        mUserManagerService.putUserInfo(data.info);\n+\n+        // Set a global and user restriction so they get written out to the user file.\n+        setUserRestrictions(data.info.id, globalRestriction, localRestriction, true);\n+\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        DataOutputStream out = new DataOutputStream(baos);\n+        mUserManagerService.writeUserLP(data, out);\n+        byte[] bytes = baos.toByteArray();\n+\n+        // Clear the restrictions to see if they are properly read in from the user file.\n+        setUserRestrictions(data.info.id, globalRestriction, localRestriction, false);\n+\n+        mUserManagerService.readUserLP(data.info.id, new ByteArrayInputStream(bytes));\n+        assertTrue(mUserManagerService.hasUserRestrictionOnAnyUser(globalRestriction));\n+        assertTrue(mUserManagerService.hasUserRestrictionOnAnyUser(localRestriction));\n+    }\n+\n+    /** Sets a global and local restriction and verifies they were set properly **/\n+    private void setUserRestrictions(int id, String global, String local, boolean enabled) {\n+        mUserManagerService.setUserRestrictionInner(UserHandle.USER_ALL, global, enabled);\n+        assertEquals(mUserManagerService.hasUserRestrictionOnAnyUser(global), enabled);\n+\n+        mUserManagerService.setUserRestrictionInner(id, local, enabled);\n+        assertEquals(mUserManagerService.hasUserRestrictionOnAnyUser(local), enabled);\n+    }\n+\n     @Test\n     public void testParcelUnparcelUserInfo() throws Exception {\n         UserInfo info = createUser();\n-- \n2.39.5 (Apple Git-154)\n\nFrom 739281096aba494151f8c953f2d63ec9fd4c7e87 Mon Sep 17 00:00:00 2001\nFrom: Jason Parks <jparks@google.com>\nDate: Tue, 31 Oct 2023 20:17:21 +0000\nSubject: [PATCH] Fix issue with upgrading from previous user versions.\n\nThe storage format of users changed in userVersion 10. When upgrading\nfrom userVersion 9 (Android 13), local user restrictions would be read\nas base restrictions. This fix properly reads in the old version and\nconverts it to the new storage format.\n\nBug: 305455828\nTest: atest UserManagerServiceUserInfoTest\nChange-Id: I14fdac19b4458c6bd2ccee7d1b119bc710e1b600\nMerged-In: I14fdac19b4458c6bd2ccee7d1b119bc710e1b600\n(cherry picked from commit 347b8a00c8aad4ce36e0c63e0c4c03b7fc86bb92)\n---\n .../android/server/pm/UserManagerService.java | 23 ++++++--\n .../servicestests/res/xml/user_100_v9.xml     | 20 +++++++\n .../pm/UserManagerServiceUserInfoTest.java    | 56 ++++++++++++++++++-\n 3 files changed, 91 insertions(+), 8 deletions(-)\n create mode 100644 services/tests/servicestests/res/xml/user_100_v9.xml\n\ndiff --git a/services/core/java/com/android/server/pm/UserManagerService.java b/services/core/java/com/android/server/pm/UserManagerService.java\nindex d2929aef8a63..a959fc10db49 100644\n--- a/services/core/java/com/android/server/pm/UserManagerService.java\n+++ b/services/core/java/com/android/server/pm/UserManagerService.java\n@@ -3706,7 +3706,8 @@ public class UserManagerService extends IUserManager.Stub {\n                     if (type == XmlPullParser.START_TAG) {\n                         final String name = parser.getName();\n                         if (name.equals(TAG_USER)) {\n-                            UserData userData = readUserLP(parser.getAttributeInt(null, ATTR_ID));\n+                            UserData userData = readUserLP(parser.getAttributeInt(null, ATTR_ID),\n+                                    mUserVersion);\n \n                             if (userData != null) {\n                                 synchronized (mUsersLock) {\n@@ -4387,7 +4388,7 @@ public class UserManagerService extends IUserManager.Stub {\n     }\n \n     @GuardedBy({\"mPackagesLock\"})\n-    private UserData readUserLP(int id) {\n+    private UserData readUserLP(int id, int userVersion) {\n         try (ResilientAtomicFile file = getUserFile(id)) {\n             FileInputStream fis = null;\n             try {\n@@ -4396,19 +4397,19 @@ public class UserManagerService extends IUserManager.Stub {\n                     Slog.e(LOG_TAG, \"User info not found, returning null, user id: \" + id);\n                     return null;\n                 }\n-                return readUserLP(id, fis);\n+                return readUserLP(id, fis, userVersion);\n             } catch (Exception e) {\n                 // Remove corrupted file and retry.\n                 Slog.e(LOG_TAG, \"Error reading user info, user id: \" + id);\n                 file.failRead(fis, e);\n-                return readUserLP(id);\n+                return readUserLP(id, userVersion);\n             }\n         }\n     }\n \n     @GuardedBy({\"mPackagesLock\"})\n     @VisibleForTesting\n-    UserData readUserLP(int id, InputStream is) throws IOException,\n+    UserData readUserLP(int id, InputStream is, int userVersion) throws IOException,\n             XmlPullParserException {\n         int flags = 0;\n         String userType = null;\n@@ -4501,7 +4502,17 @@ public class UserManagerService extends IUserManager.Stub {\n                 } else if (TAG_DEVICE_POLICY_RESTRICTIONS.equals(tag)) {\n                     legacyLocalRestrictions = UserRestrictionsUtils.readRestrictions(parser);\n                 } else if (TAG_DEVICE_POLICY_LOCAL_RESTRICTIONS.equals(tag)) {\n-                    localRestrictions = UserRestrictionsUtils.readRestrictions(parser);\n+                    if (userVersion < 10) {\n+                        // Prior to version 10, the local user restrictions were stored as sub tags\n+                        // grouped by the user id of the source user. The source is no longer stored\n+                        // on versions 10+ as this is now stored in the DevicePolicyEngine.\n+                        RestrictionsSet oldLocalRestrictions =\n+                                RestrictionsSet.readRestrictions(\n+                                    parser, TAG_DEVICE_POLICY_LOCAL_RESTRICTIONS);\n+                        localRestrictions = oldLocalRestrictions.mergeAll();\n+                    } else {\n+                        localRestrictions = UserRestrictionsUtils.readRestrictions(parser);\n+                    }\n                 } else if (TAG_DEVICE_POLICY_GLOBAL_RESTRICTIONS.equals(tag)) {\n                     globalRestrictions = UserRestrictionsUtils.readRestrictions(parser);\n                 } else if (TAG_ACCOUNT.equals(tag)) {\ndiff --git a/services/tests/servicestests/res/xml/user_100_v9.xml b/services/tests/servicestests/res/xml/user_100_v9.xml\nnew file mode 100644\nindex 000000000000..03c08ed40828\n--- /dev/null\n+++ b/services/tests/servicestests/res/xml/user_100_v9.xml\n@@ -0,0 +1,20 @@\n+<user id=\"100\"\n+    serialNumber=\"0\"\n+    flags=\"3091\"\n+    type=\"android.os.usertype.full.SYSTEM\"\n+    created=\"0\"\n+    lastLoggedIn=\"0\"\n+    lastLoggedInFingerprint=\"0\"\n+    profileBadge=\"0\">\n+  <restrictions no_oem_unlock=\"true\" />\n+  <device_policy_local_restrictions>\n+    <restrictions_user user_id=\"0\">\n+      <restrictions no_camera=\"true\" />\n+    </restrictions_user>\n+    <restrictions_user user_id=\"100\">\n+      <restrictions no_camera=\"true\" />\n+      <restrictions no_install_unknown_sources=\"true\" />\n+    </restrictions_user>\n+  </device_policy_local_restrictions>\n+  <ignorePrepareStorageErrors>false</ignorePrepareStorageErrors>\n+</user>\n\\ No newline at end of file\ndiff --git a/services/tests/servicestests/src/com/android/server/pm/UserManagerServiceUserInfoTest.java b/services/tests/servicestests/src/com/android/server/pm/UserManagerServiceUserInfoTest.java\nindex 9f75cf8d552e..429c58e768bf 100644\n--- a/services/tests/servicestests/src/com/android/server/pm/UserManagerServiceUserInfoTest.java\n+++ b/services/tests/servicestests/src/com/android/server/pm/UserManagerServiceUserInfoTest.java\n@@ -43,27 +43,33 @@ import android.annotation.UserIdInt;\n import android.app.PropertyInvalidatedCache;\n import android.content.pm.UserInfo;\n import android.content.pm.UserInfo.UserInfoFlag;\n+import android.content.res.Resources;\n import android.os.Looper;\n import android.os.Parcel;\n import android.os.UserHandle;\n import android.os.UserManager;\n import android.platform.test.annotations.Presubmit;\n import android.text.TextUtils;\n+import android.util.Xml;\n \n import androidx.test.InstrumentationRegistry;\n import androidx.test.filters.MediumTest;\n import androidx.test.runner.AndroidJUnit4;\n \n+import com.android.frameworks.servicestests.R;\n import com.android.server.LocalServices;\n import com.android.server.pm.UserManagerService.UserData;\n \n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n+import org.xmlpull.v1.XmlPullParser;\n+import org.xmlpull.v1.XmlSerializer;\n \n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.DataOutputStream;\n+import java.nio.charset.StandardCharsets;\n import java.util.List;\n \n /**\n@@ -76,6 +82,7 @@ import java.util.List;\n @MediumTest\n public class UserManagerServiceUserInfoTest {\n     private UserManagerService mUserManagerService;\n+    private Resources mResources;\n \n     @Before\n     public void setup() {\n@@ -95,6 +102,8 @@ public class UserManagerServiceUserInfoTest {\n         assertEquals(\"Multiple users so this test can't run.\", 1, users.size());\n         assertEquals(\"Only user present isn't the system user.\",\n                 UserHandle.USER_SYSTEM, users.get(0).id);\n+\n+        mResources = InstrumentationRegistry.getTargetContext().getResources();\n     }\n \n     @Test\n@@ -108,7 +117,7 @@ public class UserManagerServiceUserInfoTest {\n         byte[] bytes = baos.toByteArray();\n \n         UserData read = mUserManagerService.readUserLP(\n-                data.info.id, new ByteArrayInputStream(bytes));\n+                data.info.id, new ByteArrayInputStream(bytes), 0);\n \n         assertUserInfoEquals(data.info, read.info, /* parcelCopy= */ false);\n     }\n@@ -135,7 +144,11 @@ public class UserManagerServiceUserInfoTest {\n         // Clear the restrictions to see if they are properly read in from the user file.\n         setUserRestrictions(data.info.id, globalRestriction, localRestriction, false);\n \n-        mUserManagerService.readUserLP(data.info.id, new ByteArrayInputStream(bytes));\n+        final int userVersion = 10;\n+        //read the secondary and SYSTEM user file to fetch local/global device policy restrictions.\n+        mUserManagerService.readUserLP(data.info.id, new ByteArrayInputStream(bytes),\n+                userVersion);\n+\n         assertTrue(mUserManagerService.hasUserRestrictionOnAnyUser(globalRestriction));\n         assertTrue(mUserManagerService.hasUserRestrictionOnAnyUser(localRestriction));\n     }\n@@ -286,6 +299,45 @@ public class UserManagerServiceUserInfoTest {\n         assertTrue(mUserManagerService.isUserOfType(106, USER_TYPE_FULL_DEMO));\n     }\n \n+    /** Tests readUserLP upgrading from version 9 to 10+. */\n+    @Test\n+    public void testUserRestrictionsUpgradeFromV9() throws Exception {\n+        final String[] localRestrictions = new String[] {\n+            UserManager.DISALLOW_CAMERA,\n+            UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES,\n+        };\n+\n+        final int userId = 100;\n+        UserData data = new UserData();\n+        data.info = createUser(userId, FLAG_FULL, \"A type\");\n+\n+        mUserManagerService.putUserInfo(data.info);\n+\n+        for (String restriction : localRestrictions) {\n+            assertFalse(mUserManagerService.hasBaseUserRestriction(restriction, userId));\n+            assertFalse(mUserManagerService.hasUserRestriction(restriction, userId));\n+        }\n+\n+        // Convert the xml resource to the system storage xml format.\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        DataOutputStream os = new DataOutputStream(baos);\n+        XmlPullParser in = mResources.getXml(R.xml.user_100_v9);\n+        XmlSerializer out = Xml.newBinarySerializer();\n+        out.setOutput(os, StandardCharsets.UTF_8.name());\n+        Xml.copy(in, out);\n+        byte[] userBytes = baos.toByteArray();\n+        baos.reset();\n+\n+        final int userVersion = 9;\n+        mUserManagerService.readUserLP(data.info.id, new ByteArrayInputStream(userBytes),\n+                userVersion);\n+\n+        for (String restriction : localRestrictions) {\n+            assertFalse(mUserManagerService.hasBaseUserRestriction(restriction, userId));\n+            assertTrue(mUserManagerService.hasUserRestriction(restriction, userId));\n+        }\n+    }\n+\n     /** Creates a UserInfo with the given flags and userType. */\n     private UserInfo createUser(@UserIdInt int userId, @UserInfoFlag int flags, String userType) {\n         return new UserInfo(userId, \"A Name\", \"A path\", flags, userType);\n-- \n2.39.5 (Apple Git-154)\n\nFrom 5394ddbee5dd88a35e2a9a8508dc260395895ac1 Mon Sep 17 00:00:00 2001\nFrom: Jonathan Scott <scottjonathan@google.com>\nDate: Tue, 21 Nov 2023 16:36:13 +0000\nSubject: [PATCH] Always sync user restriction state to UserManager\n\nOn certain Android 14 builds, global restrictions set by the\nDPC can errornously go into UserManager's local restriction\nstore, resulting in a bad state where they cannot be unset\nin future. Fix this by always force syncing user restrictions\nfrom the policy engine to the UserManager when a restriction is\nbeing set or cleared by the DPC. The force sync ensures that both\nlocal and global restriction states of UserManager are consistent\nwith policy engine, for the restriction that is being updated.\n\nRan through the following manual tests:\n1. (DO) Start with A14 bad build, set global restrictions\n   -> OTA to this fix\n   -> try clearing policy\n2. (DO) Start with A14 bad build, set global restrictions\n   -> reboot device\n   -> OTA to this fix\n   -> try clearing policy\n3. (DO) A13 with local & global restrictions set\n   -> OTA to A14 bad build\n   -> set same restrictions again\n   -> OTA to this fix\n   -> try clearing policy\n4. (DO) A13 with local & global restrictions set\n   -> OTA to A14 bad build\n   -> reboot device\n   -> set same restrictions again\n   -> OTA to this fix\n   -> try clearing policy\n5. (DO) A13 with local & global restrictions set\n   -> OTA to A14 bad build\n   -> OTA to this fix\n   -> try clearing policy\n6. (DO) A13 with local & global restrictions set\n   -> OTA to A14 bad build\n   -> reboot device\n   -> OTA to this fix\n   -> try clearing policy\n7. (DO) A13 with local & global restrictions set\n   -> OTA to this fix\n   -> try clearing policy\n8. (BYOD PO) A13 with global restrictions set\n   -> OTA to A14 bad build\n   -> reboot device\n   -> OTA to this fix\n   -> try clearing policy\nCase 1 & 2: fresh A14 setup\nCase 3 & 4: OTA'ed devices with workaround applied\nCase 5 & 6: OTA'ed devices without workaround applied\nCase 7: directly OTA'ed to build with fix\nCase 8: same as case 5 & 6 but on a BYOD PO device\n\nBug: 311687929\nBug: 299302474\nTest: btest a.d.c.PolicyEngineTest\nTest: atest android.devicepolicy.cts.UserRestrictionsTest\n\nChange-Id: I4d700bc42ec114d1c0fc86f230f7f7612819195c\n---\n .../devicepolicy/DevicePolicyEngine.java      | 66 +++++++++++++++++++\n 1 file changed, 66 insertions(+)\n\ndiff --git a/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyEngine.java b/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyEngine.java\nindex 9c1d765fe0f9..9f65a33185b5 100644\n--- a/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyEngine.java\n+++ b/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyEngine.java\n@@ -30,6 +30,7 @@ import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.AppGlobals;\n import android.app.BroadcastOptions;\n+import android.app.admin.BooleanPolicyValue;\n import android.app.admin.DevicePolicyIdentifiers;\n import android.app.admin.DevicePolicyManager;\n import android.app.admin.DevicePolicyState;\n@@ -133,6 +134,67 @@ final class DevicePolicyEngine {\n         mEnforcingAdmins = new SparseArray<>();\n     }\n \n+    private void maybeForceEnforcementRefreshLocked(@NonNull PolicyDefinition<?> policyDefinition) {\n+        try {\n+            if (shouldForceEnforcementRefresh(policyDefinition)) {\n+                // This is okay because it's only true for user restrictions which are all <Boolean>\n+                forceEnforcementRefreshLocked((PolicyDefinition<Boolean>) policyDefinition);\n+            }\n+        } catch (Throwable e) {\n+            // Catch any possible exceptions just to be on the safe side\n+            Log.e(TAG, \"Exception throw during maybeForceEnforcementRefreshLocked\", e);\n+        }\n+    }\n+\n+    private boolean shouldForceEnforcementRefresh(@NonNull PolicyDefinition<?> policyDefinition) {\n+        // These are all \"not nullable\" but for the purposes of maximum safety for a lightly tested\n+        // change we check here\n+        if (policyDefinition == null) {\n+            return false;\n+        }\n+        PolicyKey policyKey = policyDefinition.getPolicyKey();\n+        if (policyKey == null) {\n+            return false;\n+        }\n+\n+        if (policyKey instanceof UserRestrictionPolicyKey) {\n+            // b/307481299 We must force all user restrictions to re-sync local\n+            // + global on each set/clear\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    private void forceEnforcementRefreshLocked(PolicyDefinition<Boolean> policyDefinition) {\n+        Binder.withCleanCallingIdentity(() -> {\n+            // Sync global state\n+            PolicyValue<Boolean> globalValue = new BooleanPolicyValue(false);\n+            try {\n+                PolicyState<Boolean> policyState = getGlobalPolicyStateLocked(policyDefinition);\n+                globalValue = policyState.getCurrentResolvedPolicy();\n+            } catch (IllegalArgumentException e) {\n+                // Expected for local-only policies\n+            }\n+\n+            enforcePolicy(policyDefinition, globalValue, UserHandle.USER_ALL);\n+\n+            // Loop through each user and sync that user's state\n+            for (UserInfo user : mUserManager.getUsers()) {\n+                PolicyValue<Boolean> localValue = new BooleanPolicyValue(false);\n+                try {\n+                    PolicyState<Boolean> localPolicyState = getLocalPolicyStateLocked(\n+                            policyDefinition, user.id);\n+                    localValue = localPolicyState.getCurrentResolvedPolicy();\n+                } catch (IllegalArgumentException e) {\n+                    // Expected for global-only policies\n+                }\n+\n+                enforcePolicy(policyDefinition, localValue, user.id);\n+            }\n+        });\n+    }\n+\n     /**\n      * Set the policy for the provided {@code policyDefinition} (see {@link PolicyDefinition}) and\n      * {@code enforcingAdmin} to the provided {@code value}.\n@@ -174,6 +236,7 @@ final class DevicePolicyEngine {\n             // No need to notify admins as no new policy is actually enforced, we're just filling in\n             // the data structures.\n             if (!skipEnforcePolicy) {\n+                maybeForceEnforcementRefreshLocked(policyDefinition);\n                 if (policyChanged) {\n                     onLocalPolicyChangedLocked(policyDefinition, enforcingAdmin, userId);\n                 }\n@@ -262,6 +325,7 @@ final class DevicePolicyEngine {\n         Objects.requireNonNull(enforcingAdmin);\n \n         synchronized (mLock) {\n+            maybeForceEnforcementRefreshLocked(policyDefinition);\n             if (!hasLocalPolicyLocked(policyDefinition, userId)) {\n                 return;\n             }\n@@ -425,6 +489,7 @@ final class DevicePolicyEngine {\n             // No need to notify admins as no new policy is actually enforced, we're just filling in\n             // the data structures.\n             if (!skipEnforcePolicy) {\n+                maybeForceEnforcementRefreshLocked(policyDefinition);\n                 if (policyChanged) {\n                     onGlobalPolicyChangedLocked(policyDefinition, enforcingAdmin);\n                 }\n@@ -474,6 +539,7 @@ final class DevicePolicyEngine {\n             PolicyState<V> policyState = getGlobalPolicyStateLocked(policyDefinition);\n             boolean policyChanged = policyState.removePolicy(enforcingAdmin);\n \n+            maybeForceEnforcementRefreshLocked(policyDefinition);\n             if (policyChanged) {\n                 onGlobalPolicyChangedLocked(policyDefinition, enforcingAdmin);\n             }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 5319,
                        "general": {
                            "word_based": 2276,
                            "char_based": 5854
                        },
                        "gemini": 6541
                    },
                    "total_downstream_versions_tested": 1,
                    "successful_patches": 1,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "c747c3fd1a0111eb699b950e645080470f0cead8",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit c747c3fd1a0111eb699b950e645080470f0cead8\nAuthor: Jason Parks <jparks@google.com>\nDate:   Wed Sep 6 17:10:55 2023 +0000\n\n    Properly store device policy user restrictions.\n    \n    Bug: 299302474\n    Bug: 311687929\n    Test: btest \"android.devicepolicy.cts.UserRestrictionsTest\" && atest UserManagerServiceUserInfoTest#testWriteReadDevicePolicyUserRestrictions\n    \n    Merged-In: I66159f362b45d4c9e322754ff272c373b2557812\n    Change-Id: I66159f362b45d4c9e322754ff272c373b2557812\n    (cherry picked from commit 24202a9b15c17739f211ede23d2afbd3be59365b)\n\ndiff --git a/services/core/java/com/android/server/pm/UserManagerService.java b/services/core/java/com/android/server/pm/UserManagerService.java\nindex b03fb31fbb1e..cc2f679ea46a 100644\n--- a/services/core/java/com/android/server/pm/UserManagerService.java\n+++ b/services/core/java/com/android/server/pm/UserManagerService.java\n@@ -2667,7 +2667,8 @@ public class UserManagerService extends IUserManager.Stub {\n         }\n     }\n \n-    private void setUserRestrictionInner(int userId, @NonNull String key, boolean value) {\n+    @VisibleForTesting\n+    void setUserRestrictionInner(int userId, @NonNull String key, boolean value) {\n         if (!UserRestrictionsUtils.isValidRestriction(key)) {\n             Slog.e(LOG_TAG, \"Setting invalid restriction \" + key);\n             return;\n@@ -4277,11 +4278,11 @@ public class UserManagerService extends IUserManager.Stub {\n \n             UserRestrictionsUtils.writeRestrictions(serializer,\n                     mDevicePolicyUserRestrictions.getRestrictions(UserHandle.USER_ALL),\n-                    TAG_DEVICE_POLICY_RESTRICTIONS);\n+                    TAG_DEVICE_POLICY_GLOBAL_RESTRICTIONS);\n \n             UserRestrictionsUtils.writeRestrictions(serializer,\n                     mDevicePolicyUserRestrictions.getRestrictions(userInfo.id),\n-                    TAG_DEVICE_POLICY_RESTRICTIONS);\n+                    TAG_DEVICE_POLICY_LOCAL_RESTRICTIONS);\n         }\n \n         if (userData.account != null) {\ndiff --git a/services/tests/servicestests/src/com/android/server/pm/UserManagerServiceUserInfoTest.java b/services/tests/servicestests/src/com/android/server/pm/UserManagerServiceUserInfoTest.java\nindex 2273fcd22b38..9f75cf8d552e 100644\n--- a/services/tests/servicestests/src/com/android/server/pm/UserManagerServiceUserInfoTest.java\n+++ b/services/tests/servicestests/src/com/android/server/pm/UserManagerServiceUserInfoTest.java\n@@ -113,6 +113,42 @@ public class UserManagerServiceUserInfoTest {\n         assertUserInfoEquals(data.info, read.info, /* parcelCopy= */ false);\n     }\n \n+    /** Tests that device policy restrictions are written/read properly. */\n+    @Test\n+    public void testWriteReadDevicePolicyUserRestrictions() throws Exception {\n+        final String globalRestriction = UserManager.DISALLOW_FACTORY_RESET;\n+        final String localRestriction = UserManager.DISALLOW_CONFIG_DATE_TIME;\n+\n+        UserData data = new UserData();\n+        data.info = createUser(100, FLAG_FULL, \"A type\");\n+\n+        mUserManagerService.putUserInfo(data.info);\n+\n+        // Set a global and user restriction so they get written out to the user file.\n+        setUserRestrictions(data.info.id, globalRestriction, localRestriction, true);\n+\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        DataOutputStream out = new DataOutputStream(baos);\n+        mUserManagerService.writeUserLP(data, out);\n+        byte[] bytes = baos.toByteArray();\n+\n+        // Clear the restrictions to see if they are properly read in from the user file.\n+        setUserRestrictions(data.info.id, globalRestriction, localRestriction, false);\n+\n+        mUserManagerService.readUserLP(data.info.id, new ByteArrayInputStream(bytes));\n+        assertTrue(mUserManagerService.hasUserRestrictionOnAnyUser(globalRestriction));\n+        assertTrue(mUserManagerService.hasUserRestrictionOnAnyUser(localRestriction));\n+    }\n+\n+    /** Sets a global and local restriction and verifies they were set properly **/\n+    private void setUserRestrictions(int id, String global, String local, boolean enabled) {\n+        mUserManagerService.setUserRestrictionInner(UserHandle.USER_ALL, global, enabled);\n+        assertEquals(mUserManagerService.hasUserRestrictionOnAnyUser(global), enabled);\n+\n+        mUserManagerService.setUserRestrictionInner(id, local, enabled);\n+        assertEquals(mUserManagerService.hasUserRestrictionOnAnyUser(local), enabled);\n+    }\n+\n     @Test\n     public void testParcelUnparcelUserInfo() throws Exception {\n         UserInfo info = createUser();\n",
                            "downstream_patch_tokens": {
                                "openai": 1063,
                                "general": {
                                    "word_based": 401,
                                    "char_based": 1147
                                },
                                "gemini": 1353
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-276898739",
            "aliases": [
                "A-276898739",
                "CVE-2024-0030"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-276898739",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "0dbf1a6ed704dedc92e1ea1196dd6428b4d50240"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 0dbf1a6ed704dedc92e1ea1196dd6428b4d50240 Mon Sep 17 00:00:00 2001\nFrom: Hui Peng <phui@google.com>\nDate: Sat, 29 Apr 2023 18:04:37 +0000\nSubject: [PATCH] Fix an OOB bug in btif_to_bta_response and\n attp_build_value_cmd\n\n1. The size of `p_src->attr_value.value` is dependent on\n   `p_src->attr_value.len`. While copying `p_src->attr_value.value`,\n   to `p_dest->attr_value.value`, it always copies GATT_MAX_ATTR_LEN\n   bytes, it may result in OOB read in `p_src->attr_value.value`;\n\n2. As the `p_dest->attr_value.len` does not map the length of\n   `p_dest->attr_value.value`, it may result in OOB read in\n   attp_build_value_cmd;\n\nBug: 276898739\nTest: m com.android.btservices\nTag: #security\nIgnore-AOSP-First: security\nChange-Id: Iefa66f3a293ac2072ba79853a9ec23cdfe4c1368\n---\n system/btif/src/btif_gatt_util.cc | 6 ++++--\n 1 file changed, 4 insertions(+), 2 deletions(-)\n\ndiff --git a/system/btif/src/btif_gatt_util.cc b/system/btif/src/btif_gatt_util.cc\nindex 5aa19a5ccb..6b03937e58 100644\n--- a/system/btif/src/btif_gatt_util.cc\n+++ b/system/btif/src/btif_gatt_util.cc\n@@ -18,6 +18,8 @@\n \n #define LOG_TAG \"bt_btif_gatt\"\n \n+#include <algorithm>\n+\n #include \"btif_gatt_util.h\"\n \n #include <errno.h>\n@@ -53,9 +55,9 @@ using bluetooth::Uuid;\n void btif_to_bta_response(tGATTS_RSP* p_dest, btgatt_response_t* p_src) {\n   p_dest->attr_value.auth_req = p_src->attr_value.auth_req;\n   p_dest->attr_value.handle = p_src->attr_value.handle;\n-  p_dest->attr_value.len = p_src->attr_value.len;\n+  p_dest->attr_value.len = std::min<uint16_t>(p_src->attr_value.len, GATT_MAX_ATTR_LEN);\n   p_dest->attr_value.offset = p_src->attr_value.offset;\n-  memcpy(p_dest->attr_value.value, p_src->attr_value.value, GATT_MAX_ATTR_LEN);\n+  memcpy(p_dest->attr_value.value, p_src->attr_value.value, p_dest->attr_value.len);\n }\n \n /*******************************************************************************\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 620,
                        "general": {
                            "word_based": 239,
                            "char_based": 479
                        },
                        "gemini": 839
                    },
                    "total_downstream_versions_tested": 2,
                    "successful_patches": 2,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "59c9e84bd31d4935a875d588bf4d2cc5bfb07d59",
                            "repo_path": "android_repos/Bluetooth",
                            "result": "success",
                            "downstream_patch_content": "commit 59c9e84bd31d4935a875d588bf4d2cc5bfb07d59\nAuthor: Hui Peng <phui@google.com>\nDate:   Sat Apr 29 18:04:37 2023 +0000\n\n    Fix an OOB bug in btif_to_bta_response and attp_build_value_cmd\n    \n    1. The size of `p_src->attr_value.value` is dependent on\n       `p_src->attr_value.len`. While copying `p_src->attr_value.value`,\n       to `p_dest->attr_value.value`, it always copies GATT_MAX_ATTR_LEN\n       bytes, it may result in OOB read in `p_src->attr_value.value`;\n    \n    2. As the `p_dest->attr_value.len` does not map the length of\n       `p_dest->attr_value.value`, it may result in OOB read in\n       attp_build_value_cmd;\n    \n    Bug: 276898739\n    Test: manual\n    Tag: #security\n    Ignore-AOSP-First: security\n    Merged-In: Iefa66f3a293ac2072ba79853a9ec23cdfe4c1368\n    Change-Id: Iefa66f3a293ac2072ba79853a9ec23cdfe4c1368\n\ndiff --git a/system/btif/src/btif_gatt_util.cc b/system/btif/src/btif_gatt_util.cc\nindex 290c4315a4..404dc6ae72 100644\n--- a/system/btif/src/btif_gatt_util.cc\n+++ b/system/btif/src/btif_gatt_util.cc\n@@ -18,6 +18,8 @@\n \n #define LOG_TAG \"bt_btif_gatt\"\n \n+#include <algorithm>\n+\n #include \"btif_gatt_util.h\"\n \n #include <errno.h>\n@@ -51,9 +53,9 @@ using bluetooth::Uuid;\n void btif_to_bta_response(tGATTS_RSP* p_dest, btgatt_response_t* p_src) {\n   p_dest->attr_value.auth_req = p_src->attr_value.auth_req;\n   p_dest->attr_value.handle = p_src->attr_value.handle;\n-  p_dest->attr_value.len = p_src->attr_value.len;\n+  p_dest->attr_value.len = std::min<uint16_t>(p_src->attr_value.len, GATT_MAX_ATTR_LEN);\n   p_dest->attr_value.offset = p_src->attr_value.offset;\n-  memcpy(p_dest->attr_value.value, p_src->attr_value.value, GATT_MAX_ATTR_LEN);\n+  memcpy(p_dest->attr_value.value, p_src->attr_value.value, p_dest->attr_value.len);\n }\n \n /*******************************************************************************\n",
                            "downstream_patch_tokens": {
                                "openai": 590,
                                "general": {
                                    "word_based": 211,
                                    "char_based": 464
                                },
                                "gemini": 809
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "59c9e84bd31d4935a875d588bf4d2cc5bfb07d59",
                            "repo_path": "android_repos/Bluetooth",
                            "result": "success",
                            "downstream_patch_content": "commit 59c9e84bd31d4935a875d588bf4d2cc5bfb07d59\nAuthor: Hui Peng <phui@google.com>\nDate:   Sat Apr 29 18:04:37 2023 +0000\n\n    Fix an OOB bug in btif_to_bta_response and attp_build_value_cmd\n    \n    1. The size of `p_src->attr_value.value` is dependent on\n       `p_src->attr_value.len`. While copying `p_src->attr_value.value`,\n       to `p_dest->attr_value.value`, it always copies GATT_MAX_ATTR_LEN\n       bytes, it may result in OOB read in `p_src->attr_value.value`;\n    \n    2. As the `p_dest->attr_value.len` does not map the length of\n       `p_dest->attr_value.value`, it may result in OOB read in\n       attp_build_value_cmd;\n    \n    Bug: 276898739\n    Test: manual\n    Tag: #security\n    Ignore-AOSP-First: security\n    Merged-In: Iefa66f3a293ac2072ba79853a9ec23cdfe4c1368\n    Change-Id: Iefa66f3a293ac2072ba79853a9ec23cdfe4c1368\n\ndiff --git a/system/btif/src/btif_gatt_util.cc b/system/btif/src/btif_gatt_util.cc\nindex 290c4315a4..404dc6ae72 100644\n--- a/system/btif/src/btif_gatt_util.cc\n+++ b/system/btif/src/btif_gatt_util.cc\n@@ -18,6 +18,8 @@\n \n #define LOG_TAG \"bt_btif_gatt\"\n \n+#include <algorithm>\n+\n #include \"btif_gatt_util.h\"\n \n #include <errno.h>\n@@ -51,9 +53,9 @@ using bluetooth::Uuid;\n void btif_to_bta_response(tGATTS_RSP* p_dest, btgatt_response_t* p_src) {\n   p_dest->attr_value.auth_req = p_src->attr_value.auth_req;\n   p_dest->attr_value.handle = p_src->attr_value.handle;\n-  p_dest->attr_value.len = p_src->attr_value.len;\n+  p_dest->attr_value.len = std::min<uint16_t>(p_src->attr_value.len, GATT_MAX_ATTR_LEN);\n   p_dest->attr_value.offset = p_src->attr_value.offset;\n-  memcpy(p_dest->attr_value.value, p_src->attr_value.value, GATT_MAX_ATTR_LEN);\n+  memcpy(p_dest->attr_value.value, p_src->attr_value.value, p_dest->attr_value.len);\n }\n \n /*******************************************************************************\n",
                            "downstream_patch_tokens": {
                                "openai": 590,
                                "general": {
                                    "word_based": 211,
                                    "char_based": 464
                                },
                                "gemini": 809
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-294104969",
            "aliases": [
                "A-294104969",
                "CVE-2024-0019"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-294104969",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "084a7afb4bb41e0cdfdbe67bdd60728d940b4331"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 084a7afb4bb41e0cdfdbe67bdd60728d940b4331 Mon Sep 17 00:00:00 2001\nFrom: Caitlin Shkuratov <caitlinshk@google.com>\nDate: Mon, 28 Aug 2023 21:34:43 +0000\nSubject: [PATCH] [SB][Privacy] Fetch current active appops on startup.\n\nThis also updates SysUI's chip animation scheduler to ignore an\n`isTooEarly` check if the chip animation is forced to be visible (which\nis true for privacy events).\n\nBug: 294104969\nTest: start recording, then kill systemui via adb-> verify privacy chip\nreappears after restart. Pull down shade and verify chip is correctly\nattributed. Stop recording and verify chip/dot disappears.\nTest: open camera, then kill systemui via adb -> verify privacy chip\nreappears after restart. Pull down shade and verify chip is correctly\nattributed. Close camera and verify chip/dot disappears.\nTest: smoke test of privacy chip and dot\nTest: atest AppOpsControllerTest SystemStatusAnimationSchedulerImplTest\n\nChange-Id: I664bb3003a2f6871113406e3257b7118bbdf2ab5\n---\n .../systemui/appops/AppOpsControllerImpl.java |  28 +++\n .../SystemStatusAnimationSchedulerImpl.kt     |   5 +-\n ...ystemStatusAnimationSchedulerLegacyImpl.kt |   5 +-\n .../systemui/appops/AppOpsControllerTest.java | 215 ++++++++++++++++++\n .../SystemStatusAnimationSchedulerImplTest.kt |  28 ++-\n 5 files changed, 273 insertions(+), 8 deletions(-)\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/appops/AppOpsControllerImpl.java b/packages/SystemUI/src/com/android/systemui/appops/AppOpsControllerImpl.java\nindex eec16e6dc301..c9801d77fa43 100644\n--- a/packages/SystemUI/src/com/android/systemui/appops/AppOpsControllerImpl.java\n+++ b/packages/SystemUI/src/com/android/systemui/appops/AppOpsControllerImpl.java\n@@ -52,6 +52,7 @@ import com.android.systemui.util.time.SystemClock;\n import java.io.PrintWriter;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Map;\n import java.util.Set;\n \n import javax.inject.Inject;\n@@ -184,6 +185,10 @@ public class AppOpsControllerImpl extends BroadcastReceiver implements AppOpsCon\n     protected void setListening(boolean listening) {\n         mListening = listening;\n         if (listening) {\n+            // System UI could be restarted while ops are active, so fetch the currently active ops\n+            // once System UI starts listening again.\n+            fetchCurrentActiveOps();\n+\n             mAppOps.startWatchingActive(OPS, this);\n             mAppOps.startWatchingNoted(OPS, this);\n             mAudioManager.registerAudioRecordingCallback(mAudioRecordingCallback, mBGHandler);\n@@ -216,6 +221,29 @@ public class AppOpsControllerImpl extends BroadcastReceiver implements AppOpsCon\n         }\n     }\n \n+    private void fetchCurrentActiveOps() {\n+        List<AppOpsManager.PackageOps> packageOps = mAppOps.getPackagesForOps(OPS);\n+        for (AppOpsManager.PackageOps op : packageOps) {\n+            for (AppOpsManager.OpEntry entry : op.getOps()) {\n+                for (Map.Entry<String, AppOpsManager.AttributedOpEntry> attributedOpEntry :\n+                        entry.getAttributedOpEntries().entrySet()) {\n+                    if (attributedOpEntry.getValue().isRunning()) {\n+                        onOpActiveChanged(\n+                                entry.getOpStr(),\n+                                op.getUid(),\n+                                op.getPackageName(),\n+                                /* attributionTag= */ attributedOpEntry.getKey(),\n+                                /* active= */ true,\n+                                // AppOpsManager doesn't have a way to fetch attribution flags or\n+                                // chain ID given an op entry, so default them to none.\n+                                AppOpsManager.ATTRIBUTION_FLAGS_NONE,\n+                                AppOpsManager.ATTRIBUTION_CHAIN_ID_NONE);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     /**\n      * Adds a callback that will get notifified when an AppOp of the type the controller tracks\n      * changes\ndiff --git a/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImpl.kt b/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImpl.kt\nindex f40f57099110..a3bc00248362 100644\n--- a/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImpl.kt\n+++ b/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImpl.kt\n@@ -132,8 +132,9 @@ constructor(\n     override fun onStatusEvent(event: StatusEvent) {\n         Assert.isMainThread()\n \n-        // Ignore any updates until the system is up and running\n-        if (isTooEarly() || !isImmersiveIndicatorEnabled()) {\n+        // Ignore any updates until the system is up and running. However, for important events that\n+        // request to be force visible (like privacy), ignore whether it's too early.\n+        if ((isTooEarly() && !event.forceVisible) || !isImmersiveIndicatorEnabled()) {\n             return\n         }\n \ndiff --git a/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerLegacyImpl.kt b/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerLegacyImpl.kt\nindex 5fa83ef5d454..6b5a548b0afe 100644\n--- a/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerLegacyImpl.kt\n+++ b/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerLegacyImpl.kt\n@@ -93,8 +93,9 @@ constructor(\n     @SystemAnimationState override fun getAnimationState() = animationState\n \n     override fun onStatusEvent(event: StatusEvent) {\n-        // Ignore any updates until the system is up and running\n-        if (isTooEarly() || !isImmersiveIndicatorEnabled()) {\n+        // Ignore any updates until the system is up and running. However, for important events that\n+        // request to be force visible (like privacy), ignore whether it's too early.\n+        if ((isTooEarly() && !event.forceVisible) || !isImmersiveIndicatorEnabled()) {\n             return\n         }\n \ndiff --git a/packages/SystemUI/tests/src/com/android/systemui/appops/AppOpsControllerTest.java b/packages/SystemUI/tests/src/com/android/systemui/appops/AppOpsControllerTest.java\nindex b100336b602f..f9830b124827 100644\n--- a/packages/SystemUI/tests/src/com/android/systemui/appops/AppOpsControllerTest.java\n+++ b/packages/SystemUI/tests/src/com/android/systemui/appops/AppOpsControllerTest.java\n@@ -71,6 +71,7 @@ import org.mockito.MockitoAnnotations;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n+import java.util.Map;\n \n @SmallTest\n @RunWith(AndroidTestingRunner.class)\n@@ -162,6 +163,204 @@ public class AppOpsControllerTest extends SysuiTestCase {\n         verify(mSensorPrivacyController, times(1)).removeCallback(mController);\n     }\n \n+    @Test\n+    public void startListening_fetchesCurrentActive_none() {\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of());\n+\n+        mController.setListening(true);\n+\n+        assertThat(mController.getActiveAppOps()).isEmpty();\n+    }\n+\n+    /** Regression test for b/294104969. */\n+    @Test\n+    public void startListening_fetchesCurrentActive_oneActive() {\n+        AppOpsManager.PackageOps packageOps = createPackageOp(\n+                \"package.test\",\n+                /* packageUid= */ 2,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ true);\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps));\n+\n+        // WHEN we start listening\n+        mController.setListening(true);\n+\n+        // THEN the active list has the op\n+        List<AppOpItem> list = mController.getActiveAppOps();\n+        assertEquals(1, list.size());\n+        AppOpItem first = list.get(0);\n+        assertThat(first.getPackageName()).isEqualTo(\"package.test\");\n+        assertThat(first.getUid()).isEqualTo(2);\n+        assertThat(first.getCode()).isEqualTo(AppOpsManager.OP_FINE_LOCATION);\n+    }\n+\n+    @Test\n+    public void startListening_fetchesCurrentActive_multiplePackages() {\n+        AppOpsManager.PackageOps packageOps1 = createPackageOp(\n+                \"package.one\",\n+                /* packageUid= */ 1,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ true);\n+        AppOpsManager.PackageOps packageOps2 = createPackageOp(\n+                \"package.two\",\n+                /* packageUid= */ 2,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ false);\n+        AppOpsManager.PackageOps packageOps3 = createPackageOp(\n+                \"package.three\",\n+                /* packageUid= */ 3,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ true);\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps1, packageOps2, packageOps3));\n+\n+        // WHEN we start listening\n+        mController.setListening(true);\n+\n+        // THEN the active list has the ops\n+        List<AppOpItem> list = mController.getActiveAppOps();\n+        assertEquals(2, list.size());\n+\n+        AppOpItem item0 = list.get(0);\n+        assertThat(item0.getPackageName()).isEqualTo(\"package.one\");\n+        assertThat(item0.getUid()).isEqualTo(1);\n+        assertThat(item0.getCode()).isEqualTo(AppOpsManager.OP_FINE_LOCATION);\n+\n+        AppOpItem item1 = list.get(1);\n+        assertThat(item1.getPackageName()).isEqualTo(\"package.three\");\n+        assertThat(item1.getUid()).isEqualTo(3);\n+        assertThat(item1.getCode()).isEqualTo(AppOpsManager.OP_FINE_LOCATION);\n+    }\n+\n+    @Test\n+    public void startListening_fetchesCurrentActive_multipleEntries() {\n+        AppOpsManager.PackageOps packageOps = mock(AppOpsManager.PackageOps.class);\n+        when(packageOps.getUid()).thenReturn(1);\n+        when(packageOps.getPackageName()).thenReturn(\"package.one\");\n+\n+        // Entry 1\n+        AppOpsManager.OpEntry entry1 = mock(AppOpsManager.OpEntry.class);\n+        when(entry1.getOpStr()).thenReturn(AppOpsManager.OPSTR_PHONE_CALL_MICROPHONE);\n+        AppOpsManager.AttributedOpEntry attributed1 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed1.isRunning()).thenReturn(true);\n+        when(entry1.getAttributedOpEntries()).thenReturn(Map.of(\"tag\", attributed1));\n+        // Entry 2\n+        AppOpsManager.OpEntry entry2 = mock(AppOpsManager.OpEntry.class);\n+        when(entry2.getOpStr()).thenReturn(AppOpsManager.OPSTR_CAMERA);\n+        AppOpsManager.AttributedOpEntry attributed2 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed2.isRunning()).thenReturn(true);\n+        when(entry2.getAttributedOpEntries()).thenReturn(Map.of(\"tag\", attributed2));\n+        // Entry 3\n+        AppOpsManager.OpEntry entry3 = mock(AppOpsManager.OpEntry.class);\n+        when(entry3.getOpStr()).thenReturn(AppOpsManager.OPSTR_FINE_LOCATION);\n+        AppOpsManager.AttributedOpEntry attributed3 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed3.isRunning()).thenReturn(false);\n+        when(entry3.getAttributedOpEntries()).thenReturn(Map.of(\"tag\", attributed3));\n+\n+        when(packageOps.getOps()).thenReturn(List.of(entry1, entry2, entry3));\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps));\n+\n+        // WHEN we start listening\n+        mController.setListening(true);\n+\n+        // THEN the active list has the ops\n+        List<AppOpItem> list = mController.getActiveAppOps();\n+        assertEquals(2, list.size());\n+\n+        AppOpItem first = list.get(0);\n+        assertThat(first.getPackageName()).isEqualTo(\"package.one\");\n+        assertThat(first.getUid()).isEqualTo(1);\n+        assertThat(first.getCode()).isEqualTo(AppOpsManager.OP_PHONE_CALL_MICROPHONE);\n+\n+        AppOpItem second = list.get(1);\n+        assertThat(second.getPackageName()).isEqualTo(\"package.one\");\n+        assertThat(second.getUid()).isEqualTo(1);\n+        assertThat(second.getCode()).isEqualTo(AppOpsManager.OP_CAMERA);\n+    }\n+\n+    @Test\n+    public void startListening_fetchesCurrentActive_multipleAttributes() {\n+        AppOpsManager.PackageOps packageOps = mock(AppOpsManager.PackageOps.class);\n+        when(packageOps.getUid()).thenReturn(1);\n+        when(packageOps.getPackageName()).thenReturn(\"package.one\");\n+        AppOpsManager.OpEntry entry = mock(AppOpsManager.OpEntry.class);\n+        when(entry.getOpStr()).thenReturn(AppOpsManager.OPSTR_RECORD_AUDIO);\n+\n+        AppOpsManager.AttributedOpEntry attributed1 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed1.isRunning()).thenReturn(false);\n+        AppOpsManager.AttributedOpEntry attributed2 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed2.isRunning()).thenReturn(true);\n+        AppOpsManager.AttributedOpEntry attributed3 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed3.isRunning()).thenReturn(true);\n+        when(entry.getAttributedOpEntries()).thenReturn(\n+                Map.of(\"attr1\", attributed1, \"attr2\", attributed2, \"attr3\", attributed3));\n+\n+        when(packageOps.getOps()).thenReturn(List.of(entry));\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps));\n+\n+        // WHEN we start listening\n+        mController.setListening(true);\n+\n+        // THEN the active list has the ops\n+        List<AppOpItem> list = mController.getActiveAppOps();\n+        // Multiple attributes get merged into one entry in the active ops\n+        assertEquals(1, list.size());\n+\n+        AppOpItem first = list.get(0);\n+        assertThat(first.getPackageName()).isEqualTo(\"package.one\");\n+        assertThat(first.getUid()).isEqualTo(1);\n+        assertThat(first.getCode()).isEqualTo(AppOpsManager.OP_RECORD_AUDIO);\n+    }\n+\n+    /** Regression test for b/294104969. */\n+    @Test\n+    public void addCallback_existingCallbacksNotifiedOfCurrentActive() {\n+        AppOpsManager.PackageOps packageOps1 = createPackageOp(\n+                \"package.one\",\n+                /* packageUid= */ 1,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ true);\n+        AppOpsManager.PackageOps packageOps2 = createPackageOp(\n+                \"package.two\",\n+                /* packageUid= */ 2,\n+                AppOpsManager.OPSTR_RECORD_AUDIO,\n+                /* isRunning= */ true);\n+        AppOpsManager.PackageOps packageOps3 = createPackageOp(\n+                \"package.three\",\n+                /* packageUid= */ 3,\n+                AppOpsManager.OPSTR_PHONE_CALL_MICROPHONE,\n+                /* isRunning= */ true);\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps1, packageOps2, packageOps3));\n+\n+        // WHEN we start listening\n+        mController.addCallback(\n+                new int[]{AppOpsManager.OP_RECORD_AUDIO, AppOpsManager.OP_FINE_LOCATION},\n+                mCallback);\n+        mTestableLooper.processAllMessages();\n+\n+        // THEN the callback is notified of the current active ops it cares about\n+        verify(mCallback).onActiveStateChanged(\n+                AppOpsManager.OP_FINE_LOCATION,\n+                /* uid= */ 1,\n+                \"package.one\",\n+                true);\n+        verify(mCallback).onActiveStateChanged(\n+                AppOpsManager.OP_RECORD_AUDIO,\n+                /* uid= */ 2,\n+                \"package.two\",\n+                true);\n+        verify(mCallback, never()).onActiveStateChanged(\n+                AppOpsManager.OP_PHONE_CALL_MICROPHONE,\n+                /* uid= */ 3,\n+                \"package.three\",\n+                true);\n+    }\n+\n     @Test\n     public void addCallback_includedCode() {\n         mController.addCallback(\n@@ -772,6 +971,22 @@ public class AppOpsControllerTest extends SysuiTestCase {\n         assertFalse(list.get(1).isDisabled());\n     }\n \n+    private AppOpsManager.PackageOps createPackageOp(\n+            String packageName, int packageUid, String opStr, boolean isRunning) {\n+        AppOpsManager.PackageOps packageOps = mock(AppOpsManager.PackageOps.class);\n+        when(packageOps.getPackageName()).thenReturn(packageName);\n+        when(packageOps.getUid()).thenReturn(packageUid);\n+        AppOpsManager.OpEntry entry = mock(AppOpsManager.OpEntry.class);\n+        when(entry.getOpStr()).thenReturn(opStr);\n+        AppOpsManager.AttributedOpEntry attributed = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed.isRunning()).thenReturn(isRunning);\n+\n+        when(packageOps.getOps()).thenReturn(Collections.singletonList(entry));\n+        when(entry.getAttributedOpEntries()).thenReturn(Map.of(\"tag\", attributed));\n+\n+        return packageOps;\n+    }\n+\n     private class TestHandler extends AppOpsControllerImpl.H {\n         TestHandler(Looper looper) {\n             mController.super(looper);\ndiff --git a/packages/SystemUI/tests/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImplTest.kt b/packages/SystemUI/tests/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImplTest.kt\nindex 6be2fa586f00..4fcccf887e58 100644\n--- a/packages/SystemUI/tests/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImplTest.kt\n+++ b/packages/SystemUI/tests/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImplTest.kt\n@@ -93,9 +93,6 @@ class SystemStatusAnimationSchedulerImplTest : SysuiTestCase() {\n                 fakeFeatureFlags\n             )\n \n-        // ensure that isTooEarly() check in SystemStatusAnimationScheduler does not return true\n-        systemClock.advanceTime(Process.getStartUptimeMillis() + MIN_UPTIME)\n-\n         // StatusBarContentInsetProvider is mocked. Ensure that it returns some mocked values.\n         whenever(statusBarContentInsetProvider.getStatusBarContentInsetsForCurrentRotation())\n             .thenReturn(android.util.Pair(10, 10))\n@@ -156,6 +153,21 @@ class SystemStatusAnimationSchedulerImplTest : SysuiTestCase() {\n         assertEquals(0f, batteryChip.view.alpha)\n     }\n \n+    /** Regression test for b/294104969. */\n+    @Test\n+    fun testPrivacyStatusEvent_beforeSystemUptime_stillDisplayed() = runTest {\n+        initializeSystemStatusAnimationScheduler(testScope = this, advancePastMinUptime = false)\n+\n+        // WHEN the uptime hasn't quite passed the minimum required uptime...\n+        systemClock.setUptimeMillis(Process.getStartUptimeMillis() + MIN_UPTIME / 2)\n+\n+        // BUT the event is a privacy event\n+        createAndScheduleFakePrivacyEvent()\n+\n+        // THEN the privacy event still happens\n+        assertEquals(ANIMATION_QUEUED, systemStatusAnimationScheduler.getAnimationState())\n+    }\n+\n     @Test\n     fun testPrivacyStatusEvent_standardAnimationLifecycle() = runTest {\n         // Instantiate class under test with TestScope from runTest\n@@ -568,7 +580,10 @@ class SystemStatusAnimationSchedulerImplTest : SysuiTestCase() {\n         return batteryChip\n     }\n \n-    private fun initializeSystemStatusAnimationScheduler(testScope: TestScope) {\n+    private fun initializeSystemStatusAnimationScheduler(\n+        testScope: TestScope,\n+        advancePastMinUptime: Boolean = true,\n+    ) {\n         systemStatusAnimationScheduler =\n             SystemStatusAnimationSchedulerImpl(\n                 systemEventCoordinator,\n@@ -581,5 +596,10 @@ class SystemStatusAnimationSchedulerImplTest : SysuiTestCase() {\n             )\n         // add a mock listener\n         systemStatusAnimationScheduler.addCallback(listener)\n+\n+        if (advancePastMinUptime) {\n+            // ensure that isTooEarly() check in SystemStatusAnimationScheduler does not return true\n+            systemClock.advanceTime(Process.getStartUptimeMillis() + MIN_UPTIME)\n+        }\n     }\n }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 4562,
                        "general": {
                            "word_based": 1742,
                            "char_based": 5032
                        },
                        "gemini": 5609
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "dac02d61f8cf755f733ef6c2fbd0f939ea13ee23",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit dac02d61f8cf755f733ef6c2fbd0f939ea13ee23\nAuthor: Caitlin Shkuratov <caitlinshk@google.com>\nDate:   Mon Aug 28 21:34:43 2023 +0000\n\n    [SB][Privacy] Fetch current active appops on startup.\n    \n    This also updates SysUI's chip animation scheduler to ignore an\n    `isTooEarly` check if the chip animation is forced to be visible (which\n    is true for privacy events).\n    \n    Bug: 294104969\n    Test: start recording, then kill systemui via adb-> verify privacy chip\n    reappears after restart. Pull down shade and verify chip is correctly\n    attributed. Stop recording and verify chip/dot disappears.\n    Test: open camera, then kill systemui via adb -> verify privacy chip\n    reappears after restart. Pull down shade and verify chip is correctly\n    attributed. Close camera and verify chip/dot disappears.\n    Test: smoke test of privacy chip and dot\n    Test: atest AppOpsControllerTest SystemStatusAnimationSchedulerImplTest\n    \n    Change-Id: I664bb3003a2f6871113406e3257b7118bbdf2ab5\n    Merged-In: I664bb3003a2f6871113406e3257b7118bbdf2ab5\n    (cherry picked from commit 084a7afb4bb41e0cdfdbe67bdd60728d940b4331)\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/appops/AppOpsControllerImpl.java b/packages/SystemUI/src/com/android/systemui/appops/AppOpsControllerImpl.java\nindex 9676a57b2df9..bcf3de1c0b97 100644\n--- a/packages/SystemUI/src/com/android/systemui/appops/AppOpsControllerImpl.java\n+++ b/packages/SystemUI/src/com/android/systemui/appops/AppOpsControllerImpl.java\n@@ -52,6 +52,7 @@ import java.io.FileDescriptor;\n import java.io.PrintWriter;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Map;\n import java.util.Set;\n \n import javax.inject.Inject;\n@@ -144,6 +145,10 @@ public class AppOpsControllerImpl extends BroadcastReceiver implements AppOpsCon\n     protected void setListening(boolean listening) {\n         mListening = listening;\n         if (listening) {\n+            // System UI could be restarted while ops are active, so fetch the currently active ops\n+            // once System UI starts listening again.\n+            fetchCurrentActiveOps();\n+\n             mAppOps.startWatchingActive(OPS, this);\n             mAppOps.startWatchingNoted(OPS, this);\n             mAudioManager.registerAudioRecordingCallback(mAudioRecordingCallback, mBGHandler);\n@@ -176,6 +181,29 @@ public class AppOpsControllerImpl extends BroadcastReceiver implements AppOpsCon\n         }\n     }\n \n+    private void fetchCurrentActiveOps() {\n+        List<AppOpsManager.PackageOps> packageOps = mAppOps.getPackagesForOps(OPS);\n+        for (AppOpsManager.PackageOps op : packageOps) {\n+            for (AppOpsManager.OpEntry entry : op.getOps()) {\n+                for (Map.Entry<String, AppOpsManager.AttributedOpEntry> attributedOpEntry :\n+                        entry.getAttributedOpEntries().entrySet()) {\n+                    if (attributedOpEntry.getValue().isRunning()) {\n+                        onOpActiveChanged(\n+                                entry.getOpStr(),\n+                                op.getUid(),\n+                                op.getPackageName(),\n+                                /* attributionTag= */ attributedOpEntry.getKey(),\n+                                /* active= */ true,\n+                                // AppOpsManager doesn't have a way to fetch attribution flags or\n+                                // chain ID given an op entry, so default them to none.\n+                                AppOpsManager.ATTRIBUTION_FLAGS_NONE,\n+                                AppOpsManager.ATTRIBUTION_CHAIN_ID_NONE);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     /**\n      * Adds a callback that will get notifified when an AppOp of the type the controller tracks\n      * changes\ndiff --git a/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationScheduler.kt b/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationScheduler.kt\nindex dcf8e739a76e..37a7ba58422d 100644\n--- a/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationScheduler.kt\n+++ b/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationScheduler.kt\n@@ -93,8 +93,9 @@ class SystemStatusAnimationScheduler @Inject constructor(\n     }\n \n     fun onStatusEvent(event: StatusEvent) {\n-        // Ignore any updates until the system is up and running\n-        if (isTooEarly() || !isImmersiveIndicatorEnabled()) {\n+        // Ignore any updates until the system is up and running. However, for important events that\n+        // request to be force visible (like privacy), ignore whether it's too early.\n+        if ((isTooEarly() && !event.forceVisible) || !isImmersiveIndicatorEnabled()) {\n             return\n         }\n \ndiff --git a/packages/SystemUI/tests/src/com/android/systemui/appops/AppOpsControllerTest.java b/packages/SystemUI/tests/src/com/android/systemui/appops/AppOpsControllerTest.java\nindex 61a651234e0c..e6c36c18342c 100644\n--- a/packages/SystemUI/tests/src/com/android/systemui/appops/AppOpsControllerTest.java\n+++ b/packages/SystemUI/tests/src/com/android/systemui/appops/AppOpsControllerTest.java\n@@ -19,6 +19,8 @@ package com.android.systemui.appops;\n import static android.hardware.SensorPrivacyManager.Sensors.CAMERA;\n import static android.hardware.SensorPrivacyManager.Sensors.MICROPHONE;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n import static junit.framework.TestCase.assertFalse;\n \n import static org.junit.Assert.assertEquals;\n@@ -66,6 +68,7 @@ import org.mockito.MockitoAnnotations;\n \n import java.util.Collections;\n import java.util.List;\n+import java.util.Map;\n \n @SmallTest\n @RunWith(AndroidTestingRunner.class)\n@@ -157,6 +160,204 @@ public class AppOpsControllerTest extends SysuiTestCase {\n         verify(mSensorPrivacyController, times(1)).removeCallback(mController);\n     }\n \n+    @Test\n+    public void startListening_fetchesCurrentActive_none() {\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of());\n+\n+        mController.setListening(true);\n+\n+        assertThat(mController.getActiveAppOps()).isEmpty();\n+    }\n+\n+    /** Regression test for b/294104969. */\n+    @Test\n+    public void startListening_fetchesCurrentActive_oneActive() {\n+        AppOpsManager.PackageOps packageOps = createPackageOp(\n+                \"package.test\",\n+                /* packageUid= */ 2,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ true);\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps));\n+\n+        // WHEN we start listening\n+        mController.setListening(true);\n+\n+        // THEN the active list has the op\n+        List<AppOpItem> list = mController.getActiveAppOps();\n+        assertEquals(1, list.size());\n+        AppOpItem first = list.get(0);\n+        assertThat(first.getPackageName()).isEqualTo(\"package.test\");\n+        assertThat(first.getUid()).isEqualTo(2);\n+        assertThat(first.getCode()).isEqualTo(AppOpsManager.OP_FINE_LOCATION);\n+    }\n+\n+    @Test\n+    public void startListening_fetchesCurrentActive_multiplePackages() {\n+        AppOpsManager.PackageOps packageOps1 = createPackageOp(\n+                \"package.one\",\n+                /* packageUid= */ 1,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ true);\n+        AppOpsManager.PackageOps packageOps2 = createPackageOp(\n+                \"package.two\",\n+                /* packageUid= */ 2,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ false);\n+        AppOpsManager.PackageOps packageOps3 = createPackageOp(\n+                \"package.three\",\n+                /* packageUid= */ 3,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ true);\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps1, packageOps2, packageOps3));\n+\n+        // WHEN we start listening\n+        mController.setListening(true);\n+\n+        // THEN the active list has the ops\n+        List<AppOpItem> list = mController.getActiveAppOps();\n+        assertEquals(2, list.size());\n+\n+        AppOpItem item0 = list.get(0);\n+        assertThat(item0.getPackageName()).isEqualTo(\"package.one\");\n+        assertThat(item0.getUid()).isEqualTo(1);\n+        assertThat(item0.getCode()).isEqualTo(AppOpsManager.OP_FINE_LOCATION);\n+\n+        AppOpItem item1 = list.get(1);\n+        assertThat(item1.getPackageName()).isEqualTo(\"package.three\");\n+        assertThat(item1.getUid()).isEqualTo(3);\n+        assertThat(item1.getCode()).isEqualTo(AppOpsManager.OP_FINE_LOCATION);\n+    }\n+\n+    @Test\n+    public void startListening_fetchesCurrentActive_multipleEntries() {\n+        AppOpsManager.PackageOps packageOps = mock(AppOpsManager.PackageOps.class);\n+        when(packageOps.getUid()).thenReturn(1);\n+        when(packageOps.getPackageName()).thenReturn(\"package.one\");\n+\n+        // Entry 1\n+        AppOpsManager.OpEntry entry1 = mock(AppOpsManager.OpEntry.class);\n+        when(entry1.getOpStr()).thenReturn(AppOpsManager.OPSTR_PHONE_CALL_MICROPHONE);\n+        AppOpsManager.AttributedOpEntry attributed1 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed1.isRunning()).thenReturn(true);\n+        when(entry1.getAttributedOpEntries()).thenReturn(Map.of(\"tag\", attributed1));\n+        // Entry 2\n+        AppOpsManager.OpEntry entry2 = mock(AppOpsManager.OpEntry.class);\n+        when(entry2.getOpStr()).thenReturn(AppOpsManager.OPSTR_CAMERA);\n+        AppOpsManager.AttributedOpEntry attributed2 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed2.isRunning()).thenReturn(true);\n+        when(entry2.getAttributedOpEntries()).thenReturn(Map.of(\"tag\", attributed2));\n+        // Entry 3\n+        AppOpsManager.OpEntry entry3 = mock(AppOpsManager.OpEntry.class);\n+        when(entry3.getOpStr()).thenReturn(AppOpsManager.OPSTR_FINE_LOCATION);\n+        AppOpsManager.AttributedOpEntry attributed3 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed3.isRunning()).thenReturn(false);\n+        when(entry3.getAttributedOpEntries()).thenReturn(Map.of(\"tag\", attributed3));\n+\n+        when(packageOps.getOps()).thenReturn(List.of(entry1, entry2, entry3));\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps));\n+\n+        // WHEN we start listening\n+        mController.setListening(true);\n+\n+        // THEN the active list has the ops\n+        List<AppOpItem> list = mController.getActiveAppOps();\n+        assertEquals(2, list.size());\n+\n+        AppOpItem first = list.get(0);\n+        assertThat(first.getPackageName()).isEqualTo(\"package.one\");\n+        assertThat(first.getUid()).isEqualTo(1);\n+        assertThat(first.getCode()).isEqualTo(AppOpsManager.OP_PHONE_CALL_MICROPHONE);\n+\n+        AppOpItem second = list.get(1);\n+        assertThat(second.getPackageName()).isEqualTo(\"package.one\");\n+        assertThat(second.getUid()).isEqualTo(1);\n+        assertThat(second.getCode()).isEqualTo(AppOpsManager.OP_CAMERA);\n+    }\n+\n+    @Test\n+    public void startListening_fetchesCurrentActive_multipleAttributes() {\n+        AppOpsManager.PackageOps packageOps = mock(AppOpsManager.PackageOps.class);\n+        when(packageOps.getUid()).thenReturn(1);\n+        when(packageOps.getPackageName()).thenReturn(\"package.one\");\n+        AppOpsManager.OpEntry entry = mock(AppOpsManager.OpEntry.class);\n+        when(entry.getOpStr()).thenReturn(AppOpsManager.OPSTR_RECORD_AUDIO);\n+\n+        AppOpsManager.AttributedOpEntry attributed1 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed1.isRunning()).thenReturn(false);\n+        AppOpsManager.AttributedOpEntry attributed2 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed2.isRunning()).thenReturn(true);\n+        AppOpsManager.AttributedOpEntry attributed3 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed3.isRunning()).thenReturn(true);\n+        when(entry.getAttributedOpEntries()).thenReturn(\n+                Map.of(\"attr1\", attributed1, \"attr2\", attributed2, \"attr3\", attributed3));\n+\n+        when(packageOps.getOps()).thenReturn(List.of(entry));\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps));\n+\n+        // WHEN we start listening\n+        mController.setListening(true);\n+\n+        // THEN the active list has the ops\n+        List<AppOpItem> list = mController.getActiveAppOps();\n+        // Multiple attributes get merged into one entry in the active ops\n+        assertEquals(1, list.size());\n+\n+        AppOpItem first = list.get(0);\n+        assertThat(first.getPackageName()).isEqualTo(\"package.one\");\n+        assertThat(first.getUid()).isEqualTo(1);\n+        assertThat(first.getCode()).isEqualTo(AppOpsManager.OP_RECORD_AUDIO);\n+    }\n+\n+    /** Regression test for b/294104969. */\n+    @Test\n+    public void addCallback_existingCallbacksNotifiedOfCurrentActive() {\n+        AppOpsManager.PackageOps packageOps1 = createPackageOp(\n+                \"package.one\",\n+                /* packageUid= */ 1,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ true);\n+        AppOpsManager.PackageOps packageOps2 = createPackageOp(\n+                \"package.two\",\n+                /* packageUid= */ 2,\n+                AppOpsManager.OPSTR_RECORD_AUDIO,\n+                /* isRunning= */ true);\n+        AppOpsManager.PackageOps packageOps3 = createPackageOp(\n+                \"package.three\",\n+                /* packageUid= */ 3,\n+                AppOpsManager.OPSTR_PHONE_CALL_MICROPHONE,\n+                /* isRunning= */ true);\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps1, packageOps2, packageOps3));\n+\n+        // WHEN we start listening\n+        mController.addCallback(\n+                new int[]{AppOpsManager.OP_RECORD_AUDIO, AppOpsManager.OP_FINE_LOCATION},\n+                mCallback);\n+        mTestableLooper.processAllMessages();\n+\n+        // THEN the callback is notified of the current active ops it cares about\n+        verify(mCallback).onActiveStateChanged(\n+                AppOpsManager.OP_FINE_LOCATION,\n+                /* uid= */ 1,\n+                \"package.one\",\n+                true);\n+        verify(mCallback).onActiveStateChanged(\n+                AppOpsManager.OP_RECORD_AUDIO,\n+                /* uid= */ 2,\n+                \"package.two\",\n+                true);\n+        verify(mCallback, never()).onActiveStateChanged(\n+                AppOpsManager.OP_PHONE_CALL_MICROPHONE,\n+                /* uid= */ 3,\n+                \"package.three\",\n+                true);\n+    }\n+\n     @Test\n     public void addCallback_includedCode() {\n         mController.addCallback(\n@@ -673,6 +874,22 @@ public class AppOpsControllerTest extends SysuiTestCase {\n         assertEquals(AppOpsManager.OP_PHONE_CALL_CAMERA, list.get(cameraIdx).getCode());\n     }\n \n+    private AppOpsManager.PackageOps createPackageOp(\n+            String packageName, int packageUid, String opStr, boolean isRunning) {\n+        AppOpsManager.PackageOps packageOps = mock(AppOpsManager.PackageOps.class);\n+        when(packageOps.getPackageName()).thenReturn(packageName);\n+        when(packageOps.getUid()).thenReturn(packageUid);\n+        AppOpsManager.OpEntry entry = mock(AppOpsManager.OpEntry.class);\n+        when(entry.getOpStr()).thenReturn(opStr);\n+        AppOpsManager.AttributedOpEntry attributed = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed.isRunning()).thenReturn(isRunning);\n+\n+        when(packageOps.getOps()).thenReturn(Collections.singletonList(entry));\n+        when(entry.getAttributedOpEntries()).thenReturn(Map.of(\"tag\", attributed));\n+\n+        return packageOps;\n+    }\n+\n     private class TestHandler extends AppOpsControllerImpl.H {\n         TestHandler(Looper looper) {\n             mController.super(looper);\n",
                            "downstream_patch_tokens": {
                                "openai": 3697,
                                "general": {
                                    "word_based": 1410,
                                    "char_based": 4063
                                },
                                "gemini": 4568
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "dac02d61f8cf755f733ef6c2fbd0f939ea13ee23",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit dac02d61f8cf755f733ef6c2fbd0f939ea13ee23\nAuthor: Caitlin Shkuratov <caitlinshk@google.com>\nDate:   Mon Aug 28 21:34:43 2023 +0000\n\n    [SB][Privacy] Fetch current active appops on startup.\n    \n    This also updates SysUI's chip animation scheduler to ignore an\n    `isTooEarly` check if the chip animation is forced to be visible (which\n    is true for privacy events).\n    \n    Bug: 294104969\n    Test: start recording, then kill systemui via adb-> verify privacy chip\n    reappears after restart. Pull down shade and verify chip is correctly\n    attributed. Stop recording and verify chip/dot disappears.\n    Test: open camera, then kill systemui via adb -> verify privacy chip\n    reappears after restart. Pull down shade and verify chip is correctly\n    attributed. Close camera and verify chip/dot disappears.\n    Test: smoke test of privacy chip and dot\n    Test: atest AppOpsControllerTest SystemStatusAnimationSchedulerImplTest\n    \n    Change-Id: I664bb3003a2f6871113406e3257b7118bbdf2ab5\n    Merged-In: I664bb3003a2f6871113406e3257b7118bbdf2ab5\n    (cherry picked from commit 084a7afb4bb41e0cdfdbe67bdd60728d940b4331)\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/appops/AppOpsControllerImpl.java b/packages/SystemUI/src/com/android/systemui/appops/AppOpsControllerImpl.java\nindex 9676a57b2df9..bcf3de1c0b97 100644\n--- a/packages/SystemUI/src/com/android/systemui/appops/AppOpsControllerImpl.java\n+++ b/packages/SystemUI/src/com/android/systemui/appops/AppOpsControllerImpl.java\n@@ -52,6 +52,7 @@ import java.io.FileDescriptor;\n import java.io.PrintWriter;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Map;\n import java.util.Set;\n \n import javax.inject.Inject;\n@@ -144,6 +145,10 @@ public class AppOpsControllerImpl extends BroadcastReceiver implements AppOpsCon\n     protected void setListening(boolean listening) {\n         mListening = listening;\n         if (listening) {\n+            // System UI could be restarted while ops are active, so fetch the currently active ops\n+            // once System UI starts listening again.\n+            fetchCurrentActiveOps();\n+\n             mAppOps.startWatchingActive(OPS, this);\n             mAppOps.startWatchingNoted(OPS, this);\n             mAudioManager.registerAudioRecordingCallback(mAudioRecordingCallback, mBGHandler);\n@@ -176,6 +181,29 @@ public class AppOpsControllerImpl extends BroadcastReceiver implements AppOpsCon\n         }\n     }\n \n+    private void fetchCurrentActiveOps() {\n+        List<AppOpsManager.PackageOps> packageOps = mAppOps.getPackagesForOps(OPS);\n+        for (AppOpsManager.PackageOps op : packageOps) {\n+            for (AppOpsManager.OpEntry entry : op.getOps()) {\n+                for (Map.Entry<String, AppOpsManager.AttributedOpEntry> attributedOpEntry :\n+                        entry.getAttributedOpEntries().entrySet()) {\n+                    if (attributedOpEntry.getValue().isRunning()) {\n+                        onOpActiveChanged(\n+                                entry.getOpStr(),\n+                                op.getUid(),\n+                                op.getPackageName(),\n+                                /* attributionTag= */ attributedOpEntry.getKey(),\n+                                /* active= */ true,\n+                                // AppOpsManager doesn't have a way to fetch attribution flags or\n+                                // chain ID given an op entry, so default them to none.\n+                                AppOpsManager.ATTRIBUTION_FLAGS_NONE,\n+                                AppOpsManager.ATTRIBUTION_CHAIN_ID_NONE);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     /**\n      * Adds a callback that will get notifified when an AppOp of the type the controller tracks\n      * changes\ndiff --git a/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationScheduler.kt b/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationScheduler.kt\nindex dcf8e739a76e..37a7ba58422d 100644\n--- a/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationScheduler.kt\n+++ b/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationScheduler.kt\n@@ -93,8 +93,9 @@ class SystemStatusAnimationScheduler @Inject constructor(\n     }\n \n     fun onStatusEvent(event: StatusEvent) {\n-        // Ignore any updates until the system is up and running\n-        if (isTooEarly() || !isImmersiveIndicatorEnabled()) {\n+        // Ignore any updates until the system is up and running. However, for important events that\n+        // request to be force visible (like privacy), ignore whether it's too early.\n+        if ((isTooEarly() && !event.forceVisible) || !isImmersiveIndicatorEnabled()) {\n             return\n         }\n \ndiff --git a/packages/SystemUI/tests/src/com/android/systemui/appops/AppOpsControllerTest.java b/packages/SystemUI/tests/src/com/android/systemui/appops/AppOpsControllerTest.java\nindex 61a651234e0c..e6c36c18342c 100644\n--- a/packages/SystemUI/tests/src/com/android/systemui/appops/AppOpsControllerTest.java\n+++ b/packages/SystemUI/tests/src/com/android/systemui/appops/AppOpsControllerTest.java\n@@ -19,6 +19,8 @@ package com.android.systemui.appops;\n import static android.hardware.SensorPrivacyManager.Sensors.CAMERA;\n import static android.hardware.SensorPrivacyManager.Sensors.MICROPHONE;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n import static junit.framework.TestCase.assertFalse;\n \n import static org.junit.Assert.assertEquals;\n@@ -66,6 +68,7 @@ import org.mockito.MockitoAnnotations;\n \n import java.util.Collections;\n import java.util.List;\n+import java.util.Map;\n \n @SmallTest\n @RunWith(AndroidTestingRunner.class)\n@@ -157,6 +160,204 @@ public class AppOpsControllerTest extends SysuiTestCase {\n         verify(mSensorPrivacyController, times(1)).removeCallback(mController);\n     }\n \n+    @Test\n+    public void startListening_fetchesCurrentActive_none() {\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of());\n+\n+        mController.setListening(true);\n+\n+        assertThat(mController.getActiveAppOps()).isEmpty();\n+    }\n+\n+    /** Regression test for b/294104969. */\n+    @Test\n+    public void startListening_fetchesCurrentActive_oneActive() {\n+        AppOpsManager.PackageOps packageOps = createPackageOp(\n+                \"package.test\",\n+                /* packageUid= */ 2,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ true);\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps));\n+\n+        // WHEN we start listening\n+        mController.setListening(true);\n+\n+        // THEN the active list has the op\n+        List<AppOpItem> list = mController.getActiveAppOps();\n+        assertEquals(1, list.size());\n+        AppOpItem first = list.get(0);\n+        assertThat(first.getPackageName()).isEqualTo(\"package.test\");\n+        assertThat(first.getUid()).isEqualTo(2);\n+        assertThat(first.getCode()).isEqualTo(AppOpsManager.OP_FINE_LOCATION);\n+    }\n+\n+    @Test\n+    public void startListening_fetchesCurrentActive_multiplePackages() {\n+        AppOpsManager.PackageOps packageOps1 = createPackageOp(\n+                \"package.one\",\n+                /* packageUid= */ 1,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ true);\n+        AppOpsManager.PackageOps packageOps2 = createPackageOp(\n+                \"package.two\",\n+                /* packageUid= */ 2,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ false);\n+        AppOpsManager.PackageOps packageOps3 = createPackageOp(\n+                \"package.three\",\n+                /* packageUid= */ 3,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ true);\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps1, packageOps2, packageOps3));\n+\n+        // WHEN we start listening\n+        mController.setListening(true);\n+\n+        // THEN the active list has the ops\n+        List<AppOpItem> list = mController.getActiveAppOps();\n+        assertEquals(2, list.size());\n+\n+        AppOpItem item0 = list.get(0);\n+        assertThat(item0.getPackageName()).isEqualTo(\"package.one\");\n+        assertThat(item0.getUid()).isEqualTo(1);\n+        assertThat(item0.getCode()).isEqualTo(AppOpsManager.OP_FINE_LOCATION);\n+\n+        AppOpItem item1 = list.get(1);\n+        assertThat(item1.getPackageName()).isEqualTo(\"package.three\");\n+        assertThat(item1.getUid()).isEqualTo(3);\n+        assertThat(item1.getCode()).isEqualTo(AppOpsManager.OP_FINE_LOCATION);\n+    }\n+\n+    @Test\n+    public void startListening_fetchesCurrentActive_multipleEntries() {\n+        AppOpsManager.PackageOps packageOps = mock(AppOpsManager.PackageOps.class);\n+        when(packageOps.getUid()).thenReturn(1);\n+        when(packageOps.getPackageName()).thenReturn(\"package.one\");\n+\n+        // Entry 1\n+        AppOpsManager.OpEntry entry1 = mock(AppOpsManager.OpEntry.class);\n+        when(entry1.getOpStr()).thenReturn(AppOpsManager.OPSTR_PHONE_CALL_MICROPHONE);\n+        AppOpsManager.AttributedOpEntry attributed1 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed1.isRunning()).thenReturn(true);\n+        when(entry1.getAttributedOpEntries()).thenReturn(Map.of(\"tag\", attributed1));\n+        // Entry 2\n+        AppOpsManager.OpEntry entry2 = mock(AppOpsManager.OpEntry.class);\n+        when(entry2.getOpStr()).thenReturn(AppOpsManager.OPSTR_CAMERA);\n+        AppOpsManager.AttributedOpEntry attributed2 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed2.isRunning()).thenReturn(true);\n+        when(entry2.getAttributedOpEntries()).thenReturn(Map.of(\"tag\", attributed2));\n+        // Entry 3\n+        AppOpsManager.OpEntry entry3 = mock(AppOpsManager.OpEntry.class);\n+        when(entry3.getOpStr()).thenReturn(AppOpsManager.OPSTR_FINE_LOCATION);\n+        AppOpsManager.AttributedOpEntry attributed3 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed3.isRunning()).thenReturn(false);\n+        when(entry3.getAttributedOpEntries()).thenReturn(Map.of(\"tag\", attributed3));\n+\n+        when(packageOps.getOps()).thenReturn(List.of(entry1, entry2, entry3));\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps));\n+\n+        // WHEN we start listening\n+        mController.setListening(true);\n+\n+        // THEN the active list has the ops\n+        List<AppOpItem> list = mController.getActiveAppOps();\n+        assertEquals(2, list.size());\n+\n+        AppOpItem first = list.get(0);\n+        assertThat(first.getPackageName()).isEqualTo(\"package.one\");\n+        assertThat(first.getUid()).isEqualTo(1);\n+        assertThat(first.getCode()).isEqualTo(AppOpsManager.OP_PHONE_CALL_MICROPHONE);\n+\n+        AppOpItem second = list.get(1);\n+        assertThat(second.getPackageName()).isEqualTo(\"package.one\");\n+        assertThat(second.getUid()).isEqualTo(1);\n+        assertThat(second.getCode()).isEqualTo(AppOpsManager.OP_CAMERA);\n+    }\n+\n+    @Test\n+    public void startListening_fetchesCurrentActive_multipleAttributes() {\n+        AppOpsManager.PackageOps packageOps = mock(AppOpsManager.PackageOps.class);\n+        when(packageOps.getUid()).thenReturn(1);\n+        when(packageOps.getPackageName()).thenReturn(\"package.one\");\n+        AppOpsManager.OpEntry entry = mock(AppOpsManager.OpEntry.class);\n+        when(entry.getOpStr()).thenReturn(AppOpsManager.OPSTR_RECORD_AUDIO);\n+\n+        AppOpsManager.AttributedOpEntry attributed1 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed1.isRunning()).thenReturn(false);\n+        AppOpsManager.AttributedOpEntry attributed2 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed2.isRunning()).thenReturn(true);\n+        AppOpsManager.AttributedOpEntry attributed3 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed3.isRunning()).thenReturn(true);\n+        when(entry.getAttributedOpEntries()).thenReturn(\n+                Map.of(\"attr1\", attributed1, \"attr2\", attributed2, \"attr3\", attributed3));\n+\n+        when(packageOps.getOps()).thenReturn(List.of(entry));\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps));\n+\n+        // WHEN we start listening\n+        mController.setListening(true);\n+\n+        // THEN the active list has the ops\n+        List<AppOpItem> list = mController.getActiveAppOps();\n+        // Multiple attributes get merged into one entry in the active ops\n+        assertEquals(1, list.size());\n+\n+        AppOpItem first = list.get(0);\n+        assertThat(first.getPackageName()).isEqualTo(\"package.one\");\n+        assertThat(first.getUid()).isEqualTo(1);\n+        assertThat(first.getCode()).isEqualTo(AppOpsManager.OP_RECORD_AUDIO);\n+    }\n+\n+    /** Regression test for b/294104969. */\n+    @Test\n+    public void addCallback_existingCallbacksNotifiedOfCurrentActive() {\n+        AppOpsManager.PackageOps packageOps1 = createPackageOp(\n+                \"package.one\",\n+                /* packageUid= */ 1,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ true);\n+        AppOpsManager.PackageOps packageOps2 = createPackageOp(\n+                \"package.two\",\n+                /* packageUid= */ 2,\n+                AppOpsManager.OPSTR_RECORD_AUDIO,\n+                /* isRunning= */ true);\n+        AppOpsManager.PackageOps packageOps3 = createPackageOp(\n+                \"package.three\",\n+                /* packageUid= */ 3,\n+                AppOpsManager.OPSTR_PHONE_CALL_MICROPHONE,\n+                /* isRunning= */ true);\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps1, packageOps2, packageOps3));\n+\n+        // WHEN we start listening\n+        mController.addCallback(\n+                new int[]{AppOpsManager.OP_RECORD_AUDIO, AppOpsManager.OP_FINE_LOCATION},\n+                mCallback);\n+        mTestableLooper.processAllMessages();\n+\n+        // THEN the callback is notified of the current active ops it cares about\n+        verify(mCallback).onActiveStateChanged(\n+                AppOpsManager.OP_FINE_LOCATION,\n+                /* uid= */ 1,\n+                \"package.one\",\n+                true);\n+        verify(mCallback).onActiveStateChanged(\n+                AppOpsManager.OP_RECORD_AUDIO,\n+                /* uid= */ 2,\n+                \"package.two\",\n+                true);\n+        verify(mCallback, never()).onActiveStateChanged(\n+                AppOpsManager.OP_PHONE_CALL_MICROPHONE,\n+                /* uid= */ 3,\n+                \"package.three\",\n+                true);\n+    }\n+\n     @Test\n     public void addCallback_includedCode() {\n         mController.addCallback(\n@@ -673,6 +874,22 @@ public class AppOpsControllerTest extends SysuiTestCase {\n         assertEquals(AppOpsManager.OP_PHONE_CALL_CAMERA, list.get(cameraIdx).getCode());\n     }\n \n+    private AppOpsManager.PackageOps createPackageOp(\n+            String packageName, int packageUid, String opStr, boolean isRunning) {\n+        AppOpsManager.PackageOps packageOps = mock(AppOpsManager.PackageOps.class);\n+        when(packageOps.getPackageName()).thenReturn(packageName);\n+        when(packageOps.getUid()).thenReturn(packageUid);\n+        AppOpsManager.OpEntry entry = mock(AppOpsManager.OpEntry.class);\n+        when(entry.getOpStr()).thenReturn(opStr);\n+        AppOpsManager.AttributedOpEntry attributed = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed.isRunning()).thenReturn(isRunning);\n+\n+        when(packageOps.getOps()).thenReturn(Collections.singletonList(entry));\n+        when(entry.getAttributedOpEntries()).thenReturn(Map.of(\"tag\", attributed));\n+\n+        return packageOps;\n+    }\n+\n     private class TestHandler extends AppOpsControllerImpl.H {\n         TestHandler(Looper looper) {\n             mController.super(looper);\n",
                            "downstream_patch_tokens": {
                                "openai": 3697,
                                "general": {
                                    "word_based": 1410,
                                    "char_based": 4063
                                },
                                "gemini": 4568
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "dac02d61f8cf755f733ef6c2fbd0f939ea13ee23",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit dac02d61f8cf755f733ef6c2fbd0f939ea13ee23\nAuthor: Caitlin Shkuratov <caitlinshk@google.com>\nDate:   Mon Aug 28 21:34:43 2023 +0000\n\n    [SB][Privacy] Fetch current active appops on startup.\n    \n    This also updates SysUI's chip animation scheduler to ignore an\n    `isTooEarly` check if the chip animation is forced to be visible (which\n    is true for privacy events).\n    \n    Bug: 294104969\n    Test: start recording, then kill systemui via adb-> verify privacy chip\n    reappears after restart. Pull down shade and verify chip is correctly\n    attributed. Stop recording and verify chip/dot disappears.\n    Test: open camera, then kill systemui via adb -> verify privacy chip\n    reappears after restart. Pull down shade and verify chip is correctly\n    attributed. Close camera and verify chip/dot disappears.\n    Test: smoke test of privacy chip and dot\n    Test: atest AppOpsControllerTest SystemStatusAnimationSchedulerImplTest\n    \n    Change-Id: I664bb3003a2f6871113406e3257b7118bbdf2ab5\n    Merged-In: I664bb3003a2f6871113406e3257b7118bbdf2ab5\n    (cherry picked from commit 084a7afb4bb41e0cdfdbe67bdd60728d940b4331)\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/appops/AppOpsControllerImpl.java b/packages/SystemUI/src/com/android/systemui/appops/AppOpsControllerImpl.java\nindex 9676a57b2df9..bcf3de1c0b97 100644\n--- a/packages/SystemUI/src/com/android/systemui/appops/AppOpsControllerImpl.java\n+++ b/packages/SystemUI/src/com/android/systemui/appops/AppOpsControllerImpl.java\n@@ -52,6 +52,7 @@ import java.io.FileDescriptor;\n import java.io.PrintWriter;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Map;\n import java.util.Set;\n \n import javax.inject.Inject;\n@@ -144,6 +145,10 @@ public class AppOpsControllerImpl extends BroadcastReceiver implements AppOpsCon\n     protected void setListening(boolean listening) {\n         mListening = listening;\n         if (listening) {\n+            // System UI could be restarted while ops are active, so fetch the currently active ops\n+            // once System UI starts listening again.\n+            fetchCurrentActiveOps();\n+\n             mAppOps.startWatchingActive(OPS, this);\n             mAppOps.startWatchingNoted(OPS, this);\n             mAudioManager.registerAudioRecordingCallback(mAudioRecordingCallback, mBGHandler);\n@@ -176,6 +181,29 @@ public class AppOpsControllerImpl extends BroadcastReceiver implements AppOpsCon\n         }\n     }\n \n+    private void fetchCurrentActiveOps() {\n+        List<AppOpsManager.PackageOps> packageOps = mAppOps.getPackagesForOps(OPS);\n+        for (AppOpsManager.PackageOps op : packageOps) {\n+            for (AppOpsManager.OpEntry entry : op.getOps()) {\n+                for (Map.Entry<String, AppOpsManager.AttributedOpEntry> attributedOpEntry :\n+                        entry.getAttributedOpEntries().entrySet()) {\n+                    if (attributedOpEntry.getValue().isRunning()) {\n+                        onOpActiveChanged(\n+                                entry.getOpStr(),\n+                                op.getUid(),\n+                                op.getPackageName(),\n+                                /* attributionTag= */ attributedOpEntry.getKey(),\n+                                /* active= */ true,\n+                                // AppOpsManager doesn't have a way to fetch attribution flags or\n+                                // chain ID given an op entry, so default them to none.\n+                                AppOpsManager.ATTRIBUTION_FLAGS_NONE,\n+                                AppOpsManager.ATTRIBUTION_CHAIN_ID_NONE);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     /**\n      * Adds a callback that will get notifified when an AppOp of the type the controller tracks\n      * changes\ndiff --git a/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationScheduler.kt b/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationScheduler.kt\nindex dcf8e739a76e..37a7ba58422d 100644\n--- a/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationScheduler.kt\n+++ b/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationScheduler.kt\n@@ -93,8 +93,9 @@ class SystemStatusAnimationScheduler @Inject constructor(\n     }\n \n     fun onStatusEvent(event: StatusEvent) {\n-        // Ignore any updates until the system is up and running\n-        if (isTooEarly() || !isImmersiveIndicatorEnabled()) {\n+        // Ignore any updates until the system is up and running. However, for important events that\n+        // request to be force visible (like privacy), ignore whether it's too early.\n+        if ((isTooEarly() && !event.forceVisible) || !isImmersiveIndicatorEnabled()) {\n             return\n         }\n \ndiff --git a/packages/SystemUI/tests/src/com/android/systemui/appops/AppOpsControllerTest.java b/packages/SystemUI/tests/src/com/android/systemui/appops/AppOpsControllerTest.java\nindex 61a651234e0c..e6c36c18342c 100644\n--- a/packages/SystemUI/tests/src/com/android/systemui/appops/AppOpsControllerTest.java\n+++ b/packages/SystemUI/tests/src/com/android/systemui/appops/AppOpsControllerTest.java\n@@ -19,6 +19,8 @@ package com.android.systemui.appops;\n import static android.hardware.SensorPrivacyManager.Sensors.CAMERA;\n import static android.hardware.SensorPrivacyManager.Sensors.MICROPHONE;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n import static junit.framework.TestCase.assertFalse;\n \n import static org.junit.Assert.assertEquals;\n@@ -66,6 +68,7 @@ import org.mockito.MockitoAnnotations;\n \n import java.util.Collections;\n import java.util.List;\n+import java.util.Map;\n \n @SmallTest\n @RunWith(AndroidTestingRunner.class)\n@@ -157,6 +160,204 @@ public class AppOpsControllerTest extends SysuiTestCase {\n         verify(mSensorPrivacyController, times(1)).removeCallback(mController);\n     }\n \n+    @Test\n+    public void startListening_fetchesCurrentActive_none() {\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of());\n+\n+        mController.setListening(true);\n+\n+        assertThat(mController.getActiveAppOps()).isEmpty();\n+    }\n+\n+    /** Regression test for b/294104969. */\n+    @Test\n+    public void startListening_fetchesCurrentActive_oneActive() {\n+        AppOpsManager.PackageOps packageOps = createPackageOp(\n+                \"package.test\",\n+                /* packageUid= */ 2,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ true);\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps));\n+\n+        // WHEN we start listening\n+        mController.setListening(true);\n+\n+        // THEN the active list has the op\n+        List<AppOpItem> list = mController.getActiveAppOps();\n+        assertEquals(1, list.size());\n+        AppOpItem first = list.get(0);\n+        assertThat(first.getPackageName()).isEqualTo(\"package.test\");\n+        assertThat(first.getUid()).isEqualTo(2);\n+        assertThat(first.getCode()).isEqualTo(AppOpsManager.OP_FINE_LOCATION);\n+    }\n+\n+    @Test\n+    public void startListening_fetchesCurrentActive_multiplePackages() {\n+        AppOpsManager.PackageOps packageOps1 = createPackageOp(\n+                \"package.one\",\n+                /* packageUid= */ 1,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ true);\n+        AppOpsManager.PackageOps packageOps2 = createPackageOp(\n+                \"package.two\",\n+                /* packageUid= */ 2,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ false);\n+        AppOpsManager.PackageOps packageOps3 = createPackageOp(\n+                \"package.three\",\n+                /* packageUid= */ 3,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ true);\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps1, packageOps2, packageOps3));\n+\n+        // WHEN we start listening\n+        mController.setListening(true);\n+\n+        // THEN the active list has the ops\n+        List<AppOpItem> list = mController.getActiveAppOps();\n+        assertEquals(2, list.size());\n+\n+        AppOpItem item0 = list.get(0);\n+        assertThat(item0.getPackageName()).isEqualTo(\"package.one\");\n+        assertThat(item0.getUid()).isEqualTo(1);\n+        assertThat(item0.getCode()).isEqualTo(AppOpsManager.OP_FINE_LOCATION);\n+\n+        AppOpItem item1 = list.get(1);\n+        assertThat(item1.getPackageName()).isEqualTo(\"package.three\");\n+        assertThat(item1.getUid()).isEqualTo(3);\n+        assertThat(item1.getCode()).isEqualTo(AppOpsManager.OP_FINE_LOCATION);\n+    }\n+\n+    @Test\n+    public void startListening_fetchesCurrentActive_multipleEntries() {\n+        AppOpsManager.PackageOps packageOps = mock(AppOpsManager.PackageOps.class);\n+        when(packageOps.getUid()).thenReturn(1);\n+        when(packageOps.getPackageName()).thenReturn(\"package.one\");\n+\n+        // Entry 1\n+        AppOpsManager.OpEntry entry1 = mock(AppOpsManager.OpEntry.class);\n+        when(entry1.getOpStr()).thenReturn(AppOpsManager.OPSTR_PHONE_CALL_MICROPHONE);\n+        AppOpsManager.AttributedOpEntry attributed1 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed1.isRunning()).thenReturn(true);\n+        when(entry1.getAttributedOpEntries()).thenReturn(Map.of(\"tag\", attributed1));\n+        // Entry 2\n+        AppOpsManager.OpEntry entry2 = mock(AppOpsManager.OpEntry.class);\n+        when(entry2.getOpStr()).thenReturn(AppOpsManager.OPSTR_CAMERA);\n+        AppOpsManager.AttributedOpEntry attributed2 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed2.isRunning()).thenReturn(true);\n+        when(entry2.getAttributedOpEntries()).thenReturn(Map.of(\"tag\", attributed2));\n+        // Entry 3\n+        AppOpsManager.OpEntry entry3 = mock(AppOpsManager.OpEntry.class);\n+        when(entry3.getOpStr()).thenReturn(AppOpsManager.OPSTR_FINE_LOCATION);\n+        AppOpsManager.AttributedOpEntry attributed3 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed3.isRunning()).thenReturn(false);\n+        when(entry3.getAttributedOpEntries()).thenReturn(Map.of(\"tag\", attributed3));\n+\n+        when(packageOps.getOps()).thenReturn(List.of(entry1, entry2, entry3));\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps));\n+\n+        // WHEN we start listening\n+        mController.setListening(true);\n+\n+        // THEN the active list has the ops\n+        List<AppOpItem> list = mController.getActiveAppOps();\n+        assertEquals(2, list.size());\n+\n+        AppOpItem first = list.get(0);\n+        assertThat(first.getPackageName()).isEqualTo(\"package.one\");\n+        assertThat(first.getUid()).isEqualTo(1);\n+        assertThat(first.getCode()).isEqualTo(AppOpsManager.OP_PHONE_CALL_MICROPHONE);\n+\n+        AppOpItem second = list.get(1);\n+        assertThat(second.getPackageName()).isEqualTo(\"package.one\");\n+        assertThat(second.getUid()).isEqualTo(1);\n+        assertThat(second.getCode()).isEqualTo(AppOpsManager.OP_CAMERA);\n+    }\n+\n+    @Test\n+    public void startListening_fetchesCurrentActive_multipleAttributes() {\n+        AppOpsManager.PackageOps packageOps = mock(AppOpsManager.PackageOps.class);\n+        when(packageOps.getUid()).thenReturn(1);\n+        when(packageOps.getPackageName()).thenReturn(\"package.one\");\n+        AppOpsManager.OpEntry entry = mock(AppOpsManager.OpEntry.class);\n+        when(entry.getOpStr()).thenReturn(AppOpsManager.OPSTR_RECORD_AUDIO);\n+\n+        AppOpsManager.AttributedOpEntry attributed1 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed1.isRunning()).thenReturn(false);\n+        AppOpsManager.AttributedOpEntry attributed2 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed2.isRunning()).thenReturn(true);\n+        AppOpsManager.AttributedOpEntry attributed3 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed3.isRunning()).thenReturn(true);\n+        when(entry.getAttributedOpEntries()).thenReturn(\n+                Map.of(\"attr1\", attributed1, \"attr2\", attributed2, \"attr3\", attributed3));\n+\n+        when(packageOps.getOps()).thenReturn(List.of(entry));\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps));\n+\n+        // WHEN we start listening\n+        mController.setListening(true);\n+\n+        // THEN the active list has the ops\n+        List<AppOpItem> list = mController.getActiveAppOps();\n+        // Multiple attributes get merged into one entry in the active ops\n+        assertEquals(1, list.size());\n+\n+        AppOpItem first = list.get(0);\n+        assertThat(first.getPackageName()).isEqualTo(\"package.one\");\n+        assertThat(first.getUid()).isEqualTo(1);\n+        assertThat(first.getCode()).isEqualTo(AppOpsManager.OP_RECORD_AUDIO);\n+    }\n+\n+    /** Regression test for b/294104969. */\n+    @Test\n+    public void addCallback_existingCallbacksNotifiedOfCurrentActive() {\n+        AppOpsManager.PackageOps packageOps1 = createPackageOp(\n+                \"package.one\",\n+                /* packageUid= */ 1,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ true);\n+        AppOpsManager.PackageOps packageOps2 = createPackageOp(\n+                \"package.two\",\n+                /* packageUid= */ 2,\n+                AppOpsManager.OPSTR_RECORD_AUDIO,\n+                /* isRunning= */ true);\n+        AppOpsManager.PackageOps packageOps3 = createPackageOp(\n+                \"package.three\",\n+                /* packageUid= */ 3,\n+                AppOpsManager.OPSTR_PHONE_CALL_MICROPHONE,\n+                /* isRunning= */ true);\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps1, packageOps2, packageOps3));\n+\n+        // WHEN we start listening\n+        mController.addCallback(\n+                new int[]{AppOpsManager.OP_RECORD_AUDIO, AppOpsManager.OP_FINE_LOCATION},\n+                mCallback);\n+        mTestableLooper.processAllMessages();\n+\n+        // THEN the callback is notified of the current active ops it cares about\n+        verify(mCallback).onActiveStateChanged(\n+                AppOpsManager.OP_FINE_LOCATION,\n+                /* uid= */ 1,\n+                \"package.one\",\n+                true);\n+        verify(mCallback).onActiveStateChanged(\n+                AppOpsManager.OP_RECORD_AUDIO,\n+                /* uid= */ 2,\n+                \"package.two\",\n+                true);\n+        verify(mCallback, never()).onActiveStateChanged(\n+                AppOpsManager.OP_PHONE_CALL_MICROPHONE,\n+                /* uid= */ 3,\n+                \"package.three\",\n+                true);\n+    }\n+\n     @Test\n     public void addCallback_includedCode() {\n         mController.addCallback(\n@@ -673,6 +874,22 @@ public class AppOpsControllerTest extends SysuiTestCase {\n         assertEquals(AppOpsManager.OP_PHONE_CALL_CAMERA, list.get(cameraIdx).getCode());\n     }\n \n+    private AppOpsManager.PackageOps createPackageOp(\n+            String packageName, int packageUid, String opStr, boolean isRunning) {\n+        AppOpsManager.PackageOps packageOps = mock(AppOpsManager.PackageOps.class);\n+        when(packageOps.getPackageName()).thenReturn(packageName);\n+        when(packageOps.getUid()).thenReturn(packageUid);\n+        AppOpsManager.OpEntry entry = mock(AppOpsManager.OpEntry.class);\n+        when(entry.getOpStr()).thenReturn(opStr);\n+        AppOpsManager.AttributedOpEntry attributed = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed.isRunning()).thenReturn(isRunning);\n+\n+        when(packageOps.getOps()).thenReturn(Collections.singletonList(entry));\n+        when(entry.getAttributedOpEntries()).thenReturn(Map.of(\"tag\", attributed));\n+\n+        return packageOps;\n+    }\n+\n     private class TestHandler extends AppOpsControllerImpl.H {\n         TestHandler(Looper looper) {\n             mController.super(looper);\n",
                            "downstream_patch_tokens": {
                                "openai": 3697,
                                "general": {
                                    "word_based": 1410,
                                    "char_based": 4063
                                },
                                "gemini": 4568
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "12d0064ef788844afbb85ac7e65f8d4b1d37bc5c",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 12d0064ef788844afbb85ac7e65f8d4b1d37bc5c\nAuthor: Caitlin Shkuratov <caitlinshk@google.com>\nDate:   Mon Aug 28 21:34:43 2023 +0000\n\n    [SB][Privacy] Fetch current active appops on startup.\n    \n    This also updates SysUI's chip animation scheduler to ignore an\n    `isTooEarly` check if the chip animation is forced to be visible (which\n    is true for privacy events).\n    \n    Bug: 294104969\n    Test: start recording, then kill systemui via adb-> verify privacy chip\n    reappears after restart. Pull down shade and verify chip is correctly\n    attributed. Stop recording and verify chip/dot disappears.\n    Test: open camera, then kill systemui via adb -> verify privacy chip\n    reappears after restart. Pull down shade and verify chip is correctly\n    attributed. Close camera and verify chip/dot disappears.\n    Test: smoke test of privacy chip and dot\n    Test: atest AppOpsControllerTest SystemStatusAnimationSchedulerImplTest\n    \n    Change-Id: I664bb3003a2f6871113406e3257b7118bbdf2ab5\n    Merged-In: I664bb3003a2f6871113406e3257b7118bbdf2ab5\n    (cherry picked from commit 084a7afb4bb41e0cdfdbe67bdd60728d940b4331)\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/appops/AppOpsControllerImpl.java b/packages/SystemUI/src/com/android/systemui/appops/AppOpsControllerImpl.java\nindex 6b859763eb6f..c6c08585640f 100644\n--- a/packages/SystemUI/src/com/android/systemui/appops/AppOpsControllerImpl.java\n+++ b/packages/SystemUI/src/com/android/systemui/appops/AppOpsControllerImpl.java\n@@ -51,6 +51,7 @@ import com.android.systemui.util.time.SystemClock;\n import java.io.PrintWriter;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Map;\n import java.util.Set;\n \n import javax.inject.Inject;\n@@ -144,6 +145,10 @@ public class AppOpsControllerImpl extends BroadcastReceiver implements AppOpsCon\n     protected void setListening(boolean listening) {\n         mListening = listening;\n         if (listening) {\n+            // System UI could be restarted while ops are active, so fetch the currently active ops\n+            // once System UI starts listening again.\n+            fetchCurrentActiveOps();\n+\n             mAppOps.startWatchingActive(OPS, this);\n             mAppOps.startWatchingNoted(OPS, this);\n             mAudioManager.registerAudioRecordingCallback(mAudioRecordingCallback, mBGHandler);\n@@ -176,6 +181,29 @@ public class AppOpsControllerImpl extends BroadcastReceiver implements AppOpsCon\n         }\n     }\n \n+    private void fetchCurrentActiveOps() {\n+        List<AppOpsManager.PackageOps> packageOps = mAppOps.getPackagesForOps(OPS);\n+        for (AppOpsManager.PackageOps op : packageOps) {\n+            for (AppOpsManager.OpEntry entry : op.getOps()) {\n+                for (Map.Entry<String, AppOpsManager.AttributedOpEntry> attributedOpEntry :\n+                        entry.getAttributedOpEntries().entrySet()) {\n+                    if (attributedOpEntry.getValue().isRunning()) {\n+                        onOpActiveChanged(\n+                                entry.getOpStr(),\n+                                op.getUid(),\n+                                op.getPackageName(),\n+                                /* attributionTag= */ attributedOpEntry.getKey(),\n+                                /* active= */ true,\n+                                // AppOpsManager doesn't have a way to fetch attribution flags or\n+                                // chain ID given an op entry, so default them to none.\n+                                AppOpsManager.ATTRIBUTION_FLAGS_NONE,\n+                                AppOpsManager.ATTRIBUTION_CHAIN_ID_NONE);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     /**\n      * Adds a callback that will get notifified when an AppOp of the type the controller tracks\n      * changes\ndiff --git a/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImpl.kt b/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImpl.kt\nindex f7a4feafee25..997020155cdc 100644\n--- a/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImpl.kt\n+++ b/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImpl.kt\n@@ -128,8 +128,9 @@ constructor(\n     override fun onStatusEvent(event: StatusEvent) {\n         Assert.isMainThread()\n \n-        // Ignore any updates until the system is up and running\n-        if (isTooEarly() || !isImmersiveIndicatorEnabled()) {\n+        // Ignore any updates until the system is up and running. However, for important events that\n+        // request to be force visible (like privacy), ignore whether it's too early.\n+        if ((isTooEarly() && !event.forceVisible) || !isImmersiveIndicatorEnabled()) {\n             return\n         }\n \ndiff --git a/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerLegacyImpl.kt b/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerLegacyImpl.kt\nindex 5fa83ef5d454..6b5a548b0afe 100644\n--- a/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerLegacyImpl.kt\n+++ b/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerLegacyImpl.kt\n@@ -93,8 +93,9 @@ constructor(\n     @SystemAnimationState override fun getAnimationState() = animationState\n \n     override fun onStatusEvent(event: StatusEvent) {\n-        // Ignore any updates until the system is up and running\n-        if (isTooEarly() || !isImmersiveIndicatorEnabled()) {\n+        // Ignore any updates until the system is up and running. However, for important events that\n+        // request to be force visible (like privacy), ignore whether it's too early.\n+        if ((isTooEarly() && !event.forceVisible) || !isImmersiveIndicatorEnabled()) {\n             return\n         }\n \ndiff --git a/packages/SystemUI/tests/src/com/android/systemui/appops/AppOpsControllerTest.java b/packages/SystemUI/tests/src/com/android/systemui/appops/AppOpsControllerTest.java\nindex 61a651234e0c..e6c36c18342c 100644\n--- a/packages/SystemUI/tests/src/com/android/systemui/appops/AppOpsControllerTest.java\n+++ b/packages/SystemUI/tests/src/com/android/systemui/appops/AppOpsControllerTest.java\n@@ -19,6 +19,8 @@ package com.android.systemui.appops;\n import static android.hardware.SensorPrivacyManager.Sensors.CAMERA;\n import static android.hardware.SensorPrivacyManager.Sensors.MICROPHONE;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n import static junit.framework.TestCase.assertFalse;\n \n import static org.junit.Assert.assertEquals;\n@@ -66,6 +68,7 @@ import org.mockito.MockitoAnnotations;\n \n import java.util.Collections;\n import java.util.List;\n+import java.util.Map;\n \n @SmallTest\n @RunWith(AndroidTestingRunner.class)\n@@ -157,6 +160,204 @@ public class AppOpsControllerTest extends SysuiTestCase {\n         verify(mSensorPrivacyController, times(1)).removeCallback(mController);\n     }\n \n+    @Test\n+    public void startListening_fetchesCurrentActive_none() {\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of());\n+\n+        mController.setListening(true);\n+\n+        assertThat(mController.getActiveAppOps()).isEmpty();\n+    }\n+\n+    /** Regression test for b/294104969. */\n+    @Test\n+    public void startListening_fetchesCurrentActive_oneActive() {\n+        AppOpsManager.PackageOps packageOps = createPackageOp(\n+                \"package.test\",\n+                /* packageUid= */ 2,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ true);\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps));\n+\n+        // WHEN we start listening\n+        mController.setListening(true);\n+\n+        // THEN the active list has the op\n+        List<AppOpItem> list = mController.getActiveAppOps();\n+        assertEquals(1, list.size());\n+        AppOpItem first = list.get(0);\n+        assertThat(first.getPackageName()).isEqualTo(\"package.test\");\n+        assertThat(first.getUid()).isEqualTo(2);\n+        assertThat(first.getCode()).isEqualTo(AppOpsManager.OP_FINE_LOCATION);\n+    }\n+\n+    @Test\n+    public void startListening_fetchesCurrentActive_multiplePackages() {\n+        AppOpsManager.PackageOps packageOps1 = createPackageOp(\n+                \"package.one\",\n+                /* packageUid= */ 1,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ true);\n+        AppOpsManager.PackageOps packageOps2 = createPackageOp(\n+                \"package.two\",\n+                /* packageUid= */ 2,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ false);\n+        AppOpsManager.PackageOps packageOps3 = createPackageOp(\n+                \"package.three\",\n+                /* packageUid= */ 3,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ true);\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps1, packageOps2, packageOps3));\n+\n+        // WHEN we start listening\n+        mController.setListening(true);\n+\n+        // THEN the active list has the ops\n+        List<AppOpItem> list = mController.getActiveAppOps();\n+        assertEquals(2, list.size());\n+\n+        AppOpItem item0 = list.get(0);\n+        assertThat(item0.getPackageName()).isEqualTo(\"package.one\");\n+        assertThat(item0.getUid()).isEqualTo(1);\n+        assertThat(item0.getCode()).isEqualTo(AppOpsManager.OP_FINE_LOCATION);\n+\n+        AppOpItem item1 = list.get(1);\n+        assertThat(item1.getPackageName()).isEqualTo(\"package.three\");\n+        assertThat(item1.getUid()).isEqualTo(3);\n+        assertThat(item1.getCode()).isEqualTo(AppOpsManager.OP_FINE_LOCATION);\n+    }\n+\n+    @Test\n+    public void startListening_fetchesCurrentActive_multipleEntries() {\n+        AppOpsManager.PackageOps packageOps = mock(AppOpsManager.PackageOps.class);\n+        when(packageOps.getUid()).thenReturn(1);\n+        when(packageOps.getPackageName()).thenReturn(\"package.one\");\n+\n+        // Entry 1\n+        AppOpsManager.OpEntry entry1 = mock(AppOpsManager.OpEntry.class);\n+        when(entry1.getOpStr()).thenReturn(AppOpsManager.OPSTR_PHONE_CALL_MICROPHONE);\n+        AppOpsManager.AttributedOpEntry attributed1 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed1.isRunning()).thenReturn(true);\n+        when(entry1.getAttributedOpEntries()).thenReturn(Map.of(\"tag\", attributed1));\n+        // Entry 2\n+        AppOpsManager.OpEntry entry2 = mock(AppOpsManager.OpEntry.class);\n+        when(entry2.getOpStr()).thenReturn(AppOpsManager.OPSTR_CAMERA);\n+        AppOpsManager.AttributedOpEntry attributed2 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed2.isRunning()).thenReturn(true);\n+        when(entry2.getAttributedOpEntries()).thenReturn(Map.of(\"tag\", attributed2));\n+        // Entry 3\n+        AppOpsManager.OpEntry entry3 = mock(AppOpsManager.OpEntry.class);\n+        when(entry3.getOpStr()).thenReturn(AppOpsManager.OPSTR_FINE_LOCATION);\n+        AppOpsManager.AttributedOpEntry attributed3 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed3.isRunning()).thenReturn(false);\n+        when(entry3.getAttributedOpEntries()).thenReturn(Map.of(\"tag\", attributed3));\n+\n+        when(packageOps.getOps()).thenReturn(List.of(entry1, entry2, entry3));\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps));\n+\n+        // WHEN we start listening\n+        mController.setListening(true);\n+\n+        // THEN the active list has the ops\n+        List<AppOpItem> list = mController.getActiveAppOps();\n+        assertEquals(2, list.size());\n+\n+        AppOpItem first = list.get(0);\n+        assertThat(first.getPackageName()).isEqualTo(\"package.one\");\n+        assertThat(first.getUid()).isEqualTo(1);\n+        assertThat(first.getCode()).isEqualTo(AppOpsManager.OP_PHONE_CALL_MICROPHONE);\n+\n+        AppOpItem second = list.get(1);\n+        assertThat(second.getPackageName()).isEqualTo(\"package.one\");\n+        assertThat(second.getUid()).isEqualTo(1);\n+        assertThat(second.getCode()).isEqualTo(AppOpsManager.OP_CAMERA);\n+    }\n+\n+    @Test\n+    public void startListening_fetchesCurrentActive_multipleAttributes() {\n+        AppOpsManager.PackageOps packageOps = mock(AppOpsManager.PackageOps.class);\n+        when(packageOps.getUid()).thenReturn(1);\n+        when(packageOps.getPackageName()).thenReturn(\"package.one\");\n+        AppOpsManager.OpEntry entry = mock(AppOpsManager.OpEntry.class);\n+        when(entry.getOpStr()).thenReturn(AppOpsManager.OPSTR_RECORD_AUDIO);\n+\n+        AppOpsManager.AttributedOpEntry attributed1 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed1.isRunning()).thenReturn(false);\n+        AppOpsManager.AttributedOpEntry attributed2 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed2.isRunning()).thenReturn(true);\n+        AppOpsManager.AttributedOpEntry attributed3 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed3.isRunning()).thenReturn(true);\n+        when(entry.getAttributedOpEntries()).thenReturn(\n+                Map.of(\"attr1\", attributed1, \"attr2\", attributed2, \"attr3\", attributed3));\n+\n+        when(packageOps.getOps()).thenReturn(List.of(entry));\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps));\n+\n+        // WHEN we start listening\n+        mController.setListening(true);\n+\n+        // THEN the active list has the ops\n+        List<AppOpItem> list = mController.getActiveAppOps();\n+        // Multiple attributes get merged into one entry in the active ops\n+        assertEquals(1, list.size());\n+\n+        AppOpItem first = list.get(0);\n+        assertThat(first.getPackageName()).isEqualTo(\"package.one\");\n+        assertThat(first.getUid()).isEqualTo(1);\n+        assertThat(first.getCode()).isEqualTo(AppOpsManager.OP_RECORD_AUDIO);\n+    }\n+\n+    /** Regression test for b/294104969. */\n+    @Test\n+    public void addCallback_existingCallbacksNotifiedOfCurrentActive() {\n+        AppOpsManager.PackageOps packageOps1 = createPackageOp(\n+                \"package.one\",\n+                /* packageUid= */ 1,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ true);\n+        AppOpsManager.PackageOps packageOps2 = createPackageOp(\n+                \"package.two\",\n+                /* packageUid= */ 2,\n+                AppOpsManager.OPSTR_RECORD_AUDIO,\n+                /* isRunning= */ true);\n+        AppOpsManager.PackageOps packageOps3 = createPackageOp(\n+                \"package.three\",\n+                /* packageUid= */ 3,\n+                AppOpsManager.OPSTR_PHONE_CALL_MICROPHONE,\n+                /* isRunning= */ true);\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps1, packageOps2, packageOps3));\n+\n+        // WHEN we start listening\n+        mController.addCallback(\n+                new int[]{AppOpsManager.OP_RECORD_AUDIO, AppOpsManager.OP_FINE_LOCATION},\n+                mCallback);\n+        mTestableLooper.processAllMessages();\n+\n+        // THEN the callback is notified of the current active ops it cares about\n+        verify(mCallback).onActiveStateChanged(\n+                AppOpsManager.OP_FINE_LOCATION,\n+                /* uid= */ 1,\n+                \"package.one\",\n+                true);\n+        verify(mCallback).onActiveStateChanged(\n+                AppOpsManager.OP_RECORD_AUDIO,\n+                /* uid= */ 2,\n+                \"package.two\",\n+                true);\n+        verify(mCallback, never()).onActiveStateChanged(\n+                AppOpsManager.OP_PHONE_CALL_MICROPHONE,\n+                /* uid= */ 3,\n+                \"package.three\",\n+                true);\n+    }\n+\n     @Test\n     public void addCallback_includedCode() {\n         mController.addCallback(\n@@ -673,6 +874,22 @@ public class AppOpsControllerTest extends SysuiTestCase {\n         assertEquals(AppOpsManager.OP_PHONE_CALL_CAMERA, list.get(cameraIdx).getCode());\n     }\n \n+    private AppOpsManager.PackageOps createPackageOp(\n+            String packageName, int packageUid, String opStr, boolean isRunning) {\n+        AppOpsManager.PackageOps packageOps = mock(AppOpsManager.PackageOps.class);\n+        when(packageOps.getPackageName()).thenReturn(packageName);\n+        when(packageOps.getUid()).thenReturn(packageUid);\n+        AppOpsManager.OpEntry entry = mock(AppOpsManager.OpEntry.class);\n+        when(entry.getOpStr()).thenReturn(opStr);\n+        AppOpsManager.AttributedOpEntry attributed = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed.isRunning()).thenReturn(isRunning);\n+\n+        when(packageOps.getOps()).thenReturn(Collections.singletonList(entry));\n+        when(entry.getAttributedOpEntries()).thenReturn(Map.of(\"tag\", attributed));\n+\n+        return packageOps;\n+    }\n+\n     private class TestHandler extends AppOpsControllerImpl.H {\n         TestHandler(Looper looper) {\n             mController.super(looper);\ndiff --git a/packages/SystemUI/tests/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImplTest.kt b/packages/SystemUI/tests/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImplTest.kt\nindex 7b59cc284181..f0de14eaf2bc 100644\n--- a/packages/SystemUI/tests/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImplTest.kt\n+++ b/packages/SystemUI/tests/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImplTest.kt\n@@ -87,9 +87,6 @@ class SystemStatusAnimationSchedulerImplTest : SysuiTestCase() {\n                 fakeFeatureFlags\n             )\n \n-        // ensure that isTooEarly() check in SystemStatusAnimationScheduler does not return true\n-        systemClock.advanceTime(Process.getStartUptimeMillis() + MIN_UPTIME)\n-\n         // StatusBarContentInsetProvider is mocked. Ensure that it returns some mocked values.\n         whenever(statusBarContentInsetProvider.getStatusBarContentInsetsForCurrentRotation())\n             .thenReturn(android.util.Pair(10, 10))\n@@ -150,6 +147,21 @@ class SystemStatusAnimationSchedulerImplTest : SysuiTestCase() {\n         assertEquals(0f, batteryChip.view.alpha)\n     }\n \n+    /** Regression test for b/294104969. */\n+    @Test\n+    fun testPrivacyStatusEvent_beforeSystemUptime_stillDisplayed() = runTest {\n+        initializeSystemStatusAnimationScheduler(testScope = this, advancePastMinUptime = false)\n+\n+        // WHEN the uptime hasn't quite passed the minimum required uptime...\n+        systemClock.setUptimeMillis(Process.getStartUptimeMillis() + MIN_UPTIME / 2)\n+\n+        // BUT the event is a privacy event\n+        createAndScheduleFakePrivacyEvent()\n+\n+        // THEN the privacy event still happens\n+        assertEquals(ANIMATION_QUEUED, systemStatusAnimationScheduler.getAnimationState())\n+    }\n+\n     @Test\n     fun testPrivacyStatusEvent_standardAnimationLifecycle() = runTest {\n         // Instantiate class under test with TestScope from runTest\n@@ -454,7 +466,10 @@ class SystemStatusAnimationSchedulerImplTest : SysuiTestCase() {\n         return batteryChip\n     }\n \n-    private fun initializeSystemStatusAnimationScheduler(testScope: TestScope) {\n+    private fun initializeSystemStatusAnimationScheduler(\n+        testScope: TestScope,\n+        advancePastMinUptime: Boolean = true,\n+    ) {\n         systemStatusAnimationScheduler =\n             SystemStatusAnimationSchedulerImpl(\n                 systemEventCoordinator,\n@@ -466,5 +481,10 @@ class SystemStatusAnimationSchedulerImplTest : SysuiTestCase() {\n             )\n         // add a mock listener\n         systemStatusAnimationScheduler.addCallback(listener)\n+\n+        if (advancePastMinUptime) {\n+            // ensure that isTooEarly() check in SystemStatusAnimationScheduler does not return true\n+            systemClock.advanceTime(Process.getStartUptimeMillis() + MIN_UPTIME)\n+        }\n     }\n }\n",
                            "downstream_patch_tokens": {
                                "openai": 4592,
                                "general": {
                                    "word_based": 1750,
                                    "char_based": 5071
                                },
                                "gemini": 5672
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-273936274",
            "aliases": [
                "A-273936274",
                "CVE-2024-0049"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-273936274",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "0e4ca1cb5c16af8f1dfb0ae41941c16c104d38e8"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 0e4ca1cb5c16af8f1dfb0ae41941c16c104d38e8 Mon Sep 17 00:00:00 2001\nFrom: Haripriya Deshmukh <haripriya.deshmukh@ittiam.com>\nDate: Tue, 19 Sep 2023 20:42:45 +0000\nSubject: [PATCH] Validate OMX Params for VPx encoders\n\nBug: 273936274\nBug: 273937171\nBug: 273937136\nBug: 273936553\nBug: 273936601\nTest: POC in bug descriptions\n(cherry picked from https://partner-android-review.googlesource.com/q/commit:022086b76536cd2e19a44053271190bdf6e181f7)\nMerged-In: I9bb17112d9f0217b6af0343afecc9c943453b757\nChange-Id: I9bb17112d9f0217b6af0343afecc9c943453b757\n---\n media/libstagefright/codecs/on2/enc/SoftVP8Encoder.cpp | 10 ++++++++++\n media/libstagefright/codecs/on2/enc/SoftVP9Encoder.cpp | 10 ++++++++++\n media/libstagefright/codecs/on2/enc/SoftVPXEncoder.cpp |  9 +++++++++\n 3 files changed, 29 insertions(+)\n\ndiff --git a/media/libstagefright/codecs/on2/enc/SoftVP8Encoder.cpp b/media/libstagefright/codecs/on2/enc/SoftVP8Encoder.cpp\nindex 04737a9ccf..9198b7c327 100644\n--- a/media/libstagefright/codecs/on2/enc/SoftVP8Encoder.cpp\n+++ b/media/libstagefright/codecs/on2/enc/SoftVP8Encoder.cpp\n@@ -120,6 +120,11 @@ OMX_ERRORTYPE SoftVP8Encoder::internalSetParameter(OMX_INDEXTYPE index,\n \n OMX_ERRORTYPE SoftVP8Encoder::internalGetVp8Params(\n         OMX_VIDEO_PARAM_VP8TYPE* vp8Params) {\n+    if (!isValidOMXParam(vp8Params)) {\n+        android_errorWriteLog(0x534e4554, \"273936274\");\n+        return OMX_ErrorBadParameter;\n+    }\n+\n     if (vp8Params->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\n@@ -133,6 +138,11 @@ OMX_ERRORTYPE SoftVP8Encoder::internalGetVp8Params(\n \n OMX_ERRORTYPE SoftVP8Encoder::internalSetVp8Params(\n         const OMX_VIDEO_PARAM_VP8TYPE* vp8Params) {\n+    if (!isValidOMXParam(vp8Params)) {\n+        android_errorWriteLog(0x534e4554, \"273937171\");\n+        return OMX_ErrorBadParameter;\n+    }\n+\n     if (vp8Params->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\ndiff --git a/media/libstagefright/codecs/on2/enc/SoftVP9Encoder.cpp b/media/libstagefright/codecs/on2/enc/SoftVP9Encoder.cpp\nindex 1ea1c85f76..f8495c2da4 100644\n--- a/media/libstagefright/codecs/on2/enc/SoftVP9Encoder.cpp\n+++ b/media/libstagefright/codecs/on2/enc/SoftVP9Encoder.cpp\n@@ -119,6 +119,11 @@ OMX_ERRORTYPE SoftVP9Encoder::internalSetParameter(\n \n OMX_ERRORTYPE SoftVP9Encoder::internalGetVp9Params(\n         OMX_VIDEO_PARAM_VP9TYPE *vp9Params) {\n+    if (!isValidOMXParam(vp9Params)) {\n+        android_errorWriteLog(0x534e4554, \"273936553\");\n+        return OMX_ErrorBadParameter;\n+    }\n+\n     if (vp9Params->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\n@@ -133,6 +138,11 @@ OMX_ERRORTYPE SoftVP9Encoder::internalGetVp9Params(\n \n OMX_ERRORTYPE SoftVP9Encoder::internalSetVp9Params(\n         const OMX_VIDEO_PARAM_VP9TYPE *vp9Params) {\n+    if (!isValidOMXParam(vp9Params)) {\n+        android_errorWriteLog(0x534e4554, \"273937136\");\n+        return OMX_ErrorBadParameter;\n+    }\n+\n     if (vp9Params->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\ndiff --git a/media/libstagefright/codecs/on2/enc/SoftVPXEncoder.cpp b/media/libstagefright/codecs/on2/enc/SoftVPXEncoder.cpp\nindex e9b4341458..cbedb723ed 100644\n--- a/media/libstagefright/codecs/on2/enc/SoftVPXEncoder.cpp\n+++ b/media/libstagefright/codecs/on2/enc/SoftVPXEncoder.cpp\n@@ -485,6 +485,11 @@ OMX_ERRORTYPE SoftVPXEncoder::internalSetBitrateParams(\n \n OMX_ERRORTYPE SoftVPXEncoder::internalGetAndroidVpxParams(\n         OMX_VIDEO_PARAM_ANDROID_VP8ENCODERTYPE *vpxAndroidParams) {\n+    if (!isValidOMXParam(vpxAndroidParams)) {\n+        android_errorWriteLog(0x534e4554, \"273936601\");\n+        return OMX_ErrorBadParameter;\n+    }\n+\n     if (vpxAndroidParams->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\n@@ -501,6 +506,10 @@ OMX_ERRORTYPE SoftVPXEncoder::internalGetAndroidVpxParams(\n \n OMX_ERRORTYPE SoftVPXEncoder::internalSetAndroidVpxParams(\n         const OMX_VIDEO_PARAM_ANDROID_VP8ENCODERTYPE *vpxAndroidParams) {\n+    if (!isValidOMXParam(vpxAndroidParams)) {\n+        android_errorWriteLog(0x534e4554, \"273937551\");\n+        return OMX_ErrorBadParameter;\n+    }\n     if (vpxAndroidParams->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 1412,
                        "general": {
                            "word_based": 376,
                            "char_based": 1090
                        },
                        "gemini": 1836
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "90641b2799fd3940cdf0bf8a73b2f76839e651a6",
                            "repo_path": "android_repos/av",
                            "result": "success",
                            "downstream_patch_content": "commit 90641b2799fd3940cdf0bf8a73b2f76839e651a6\nAuthor: Haripriya Deshmukh <haripriya.deshmukh@ittiam.com>\nDate:   Tue Sep 19 20:42:45 2023 +0000\n\n    Validate OMX Params for VPx encoders\n    \n    Bug: 273936274\n    Bug: 273937171\n    Bug: 273937136\n    Bug: 273936553\n    Bug: 273936601\n    Test: POC in bug descriptions\n    (cherry picked from https://partner-android-review.googlesource.com/q/commit:022086b76536cd2e19a44053271190bdf6e181f7)\n    Merged-In: I9bb17112d9f0217b6af0343afecc9c943453b757\n    Change-Id: I9bb17112d9f0217b6af0343afecc9c943453b757\n    (cherry picked from commit 0e4ca1cb5c16af8f1dfb0ae41941c16c104d38e8)\n\ndiff --git a/media/libstagefright/codecs/on2/enc/SoftVP8Encoder.cpp b/media/libstagefright/codecs/on2/enc/SoftVP8Encoder.cpp\nindex 04737a9ccf..9198b7c327 100644\n--- a/media/libstagefright/codecs/on2/enc/SoftVP8Encoder.cpp\n+++ b/media/libstagefright/codecs/on2/enc/SoftVP8Encoder.cpp\n@@ -120,6 +120,11 @@ OMX_ERRORTYPE SoftVP8Encoder::internalSetParameter(OMX_INDEXTYPE index,\n \n OMX_ERRORTYPE SoftVP8Encoder::internalGetVp8Params(\n         OMX_VIDEO_PARAM_VP8TYPE* vp8Params) {\n+    if (!isValidOMXParam(vp8Params)) {\n+        android_errorWriteLog(0x534e4554, \"273936274\");\n+        return OMX_ErrorBadParameter;\n+    }\n+\n     if (vp8Params->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\n@@ -133,6 +138,11 @@ OMX_ERRORTYPE SoftVP8Encoder::internalGetVp8Params(\n \n OMX_ERRORTYPE SoftVP8Encoder::internalSetVp8Params(\n         const OMX_VIDEO_PARAM_VP8TYPE* vp8Params) {\n+    if (!isValidOMXParam(vp8Params)) {\n+        android_errorWriteLog(0x534e4554, \"273937171\");\n+        return OMX_ErrorBadParameter;\n+    }\n+\n     if (vp8Params->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\ndiff --git a/media/libstagefright/codecs/on2/enc/SoftVP9Encoder.cpp b/media/libstagefright/codecs/on2/enc/SoftVP9Encoder.cpp\nindex 1ea1c85f76..f8495c2da4 100644\n--- a/media/libstagefright/codecs/on2/enc/SoftVP9Encoder.cpp\n+++ b/media/libstagefright/codecs/on2/enc/SoftVP9Encoder.cpp\n@@ -119,6 +119,11 @@ OMX_ERRORTYPE SoftVP9Encoder::internalSetParameter(\n \n OMX_ERRORTYPE SoftVP9Encoder::internalGetVp9Params(\n         OMX_VIDEO_PARAM_VP9TYPE *vp9Params) {\n+    if (!isValidOMXParam(vp9Params)) {\n+        android_errorWriteLog(0x534e4554, \"273936553\");\n+        return OMX_ErrorBadParameter;\n+    }\n+\n     if (vp9Params->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\n@@ -133,6 +138,11 @@ OMX_ERRORTYPE SoftVP9Encoder::internalGetVp9Params(\n \n OMX_ERRORTYPE SoftVP9Encoder::internalSetVp9Params(\n         const OMX_VIDEO_PARAM_VP9TYPE *vp9Params) {\n+    if (!isValidOMXParam(vp9Params)) {\n+        android_errorWriteLog(0x534e4554, \"273937136\");\n+        return OMX_ErrorBadParameter;\n+    }\n+\n     if (vp9Params->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\ndiff --git a/media/libstagefright/codecs/on2/enc/SoftVPXEncoder.cpp b/media/libstagefright/codecs/on2/enc/SoftVPXEncoder.cpp\nindex d0cb0718c2..054413e7c0 100644\n--- a/media/libstagefright/codecs/on2/enc/SoftVPXEncoder.cpp\n+++ b/media/libstagefright/codecs/on2/enc/SoftVPXEncoder.cpp\n@@ -485,6 +485,11 @@ OMX_ERRORTYPE SoftVPXEncoder::internalSetBitrateParams(\n \n OMX_ERRORTYPE SoftVPXEncoder::internalGetAndroidVpxParams(\n         OMX_VIDEO_PARAM_ANDROID_VP8ENCODERTYPE *vpxAndroidParams) {\n+    if (!isValidOMXParam(vpxAndroidParams)) {\n+        android_errorWriteLog(0x534e4554, \"273936601\");\n+        return OMX_ErrorBadParameter;\n+    }\n+\n     if (vpxAndroidParams->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\n@@ -501,6 +506,10 @@ OMX_ERRORTYPE SoftVPXEncoder::internalGetAndroidVpxParams(\n \n OMX_ERRORTYPE SoftVPXEncoder::internalSetAndroidVpxParams(\n         const OMX_VIDEO_PARAM_ANDROID_VP8ENCODERTYPE *vpxAndroidParams) {\n+    if (!isValidOMXParam(vpxAndroidParams)) {\n+        android_errorWriteLog(0x534e4554, \"273937551\");\n+        return OMX_ErrorBadParameter;\n+    }\n     if (vpxAndroidParams->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\n",
                            "downstream_patch_tokens": {
                                "openai": 1344,
                                "general": {
                                    "word_based": 337,
                                    "char_based": 1039
                                },
                                "gemini": 1758
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "90641b2799fd3940cdf0bf8a73b2f76839e651a6",
                            "repo_path": "android_repos/av",
                            "result": "success",
                            "downstream_patch_content": "commit 90641b2799fd3940cdf0bf8a73b2f76839e651a6\nAuthor: Haripriya Deshmukh <haripriya.deshmukh@ittiam.com>\nDate:   Tue Sep 19 20:42:45 2023 +0000\n\n    Validate OMX Params for VPx encoders\n    \n    Bug: 273936274\n    Bug: 273937171\n    Bug: 273937136\n    Bug: 273936553\n    Bug: 273936601\n    Test: POC in bug descriptions\n    (cherry picked from https://partner-android-review.googlesource.com/q/commit:022086b76536cd2e19a44053271190bdf6e181f7)\n    Merged-In: I9bb17112d9f0217b6af0343afecc9c943453b757\n    Change-Id: I9bb17112d9f0217b6af0343afecc9c943453b757\n    (cherry picked from commit 0e4ca1cb5c16af8f1dfb0ae41941c16c104d38e8)\n\ndiff --git a/media/libstagefright/codecs/on2/enc/SoftVP8Encoder.cpp b/media/libstagefright/codecs/on2/enc/SoftVP8Encoder.cpp\nindex 04737a9ccf..9198b7c327 100644\n--- a/media/libstagefright/codecs/on2/enc/SoftVP8Encoder.cpp\n+++ b/media/libstagefright/codecs/on2/enc/SoftVP8Encoder.cpp\n@@ -120,6 +120,11 @@ OMX_ERRORTYPE SoftVP8Encoder::internalSetParameter(OMX_INDEXTYPE index,\n \n OMX_ERRORTYPE SoftVP8Encoder::internalGetVp8Params(\n         OMX_VIDEO_PARAM_VP8TYPE* vp8Params) {\n+    if (!isValidOMXParam(vp8Params)) {\n+        android_errorWriteLog(0x534e4554, \"273936274\");\n+        return OMX_ErrorBadParameter;\n+    }\n+\n     if (vp8Params->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\n@@ -133,6 +138,11 @@ OMX_ERRORTYPE SoftVP8Encoder::internalGetVp8Params(\n \n OMX_ERRORTYPE SoftVP8Encoder::internalSetVp8Params(\n         const OMX_VIDEO_PARAM_VP8TYPE* vp8Params) {\n+    if (!isValidOMXParam(vp8Params)) {\n+        android_errorWriteLog(0x534e4554, \"273937171\");\n+        return OMX_ErrorBadParameter;\n+    }\n+\n     if (vp8Params->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\ndiff --git a/media/libstagefright/codecs/on2/enc/SoftVP9Encoder.cpp b/media/libstagefright/codecs/on2/enc/SoftVP9Encoder.cpp\nindex 1ea1c85f76..f8495c2da4 100644\n--- a/media/libstagefright/codecs/on2/enc/SoftVP9Encoder.cpp\n+++ b/media/libstagefright/codecs/on2/enc/SoftVP9Encoder.cpp\n@@ -119,6 +119,11 @@ OMX_ERRORTYPE SoftVP9Encoder::internalSetParameter(\n \n OMX_ERRORTYPE SoftVP9Encoder::internalGetVp9Params(\n         OMX_VIDEO_PARAM_VP9TYPE *vp9Params) {\n+    if (!isValidOMXParam(vp9Params)) {\n+        android_errorWriteLog(0x534e4554, \"273936553\");\n+        return OMX_ErrorBadParameter;\n+    }\n+\n     if (vp9Params->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\n@@ -133,6 +138,11 @@ OMX_ERRORTYPE SoftVP9Encoder::internalGetVp9Params(\n \n OMX_ERRORTYPE SoftVP9Encoder::internalSetVp9Params(\n         const OMX_VIDEO_PARAM_VP9TYPE *vp9Params) {\n+    if (!isValidOMXParam(vp9Params)) {\n+        android_errorWriteLog(0x534e4554, \"273937136\");\n+        return OMX_ErrorBadParameter;\n+    }\n+\n     if (vp9Params->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\ndiff --git a/media/libstagefright/codecs/on2/enc/SoftVPXEncoder.cpp b/media/libstagefright/codecs/on2/enc/SoftVPXEncoder.cpp\nindex d0cb0718c2..054413e7c0 100644\n--- a/media/libstagefright/codecs/on2/enc/SoftVPXEncoder.cpp\n+++ b/media/libstagefright/codecs/on2/enc/SoftVPXEncoder.cpp\n@@ -485,6 +485,11 @@ OMX_ERRORTYPE SoftVPXEncoder::internalSetBitrateParams(\n \n OMX_ERRORTYPE SoftVPXEncoder::internalGetAndroidVpxParams(\n         OMX_VIDEO_PARAM_ANDROID_VP8ENCODERTYPE *vpxAndroidParams) {\n+    if (!isValidOMXParam(vpxAndroidParams)) {\n+        android_errorWriteLog(0x534e4554, \"273936601\");\n+        return OMX_ErrorBadParameter;\n+    }\n+\n     if (vpxAndroidParams->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\n@@ -501,6 +506,10 @@ OMX_ERRORTYPE SoftVPXEncoder::internalGetAndroidVpxParams(\n \n OMX_ERRORTYPE SoftVPXEncoder::internalSetAndroidVpxParams(\n         const OMX_VIDEO_PARAM_ANDROID_VP8ENCODERTYPE *vpxAndroidParams) {\n+    if (!isValidOMXParam(vpxAndroidParams)) {\n+        android_errorWriteLog(0x534e4554, \"273937551\");\n+        return OMX_ErrorBadParameter;\n+    }\n     if (vpxAndroidParams->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\n",
                            "downstream_patch_tokens": {
                                "openai": 1344,
                                "general": {
                                    "word_based": 337,
                                    "char_based": 1039
                                },
                                "gemini": 1758
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "90641b2799fd3940cdf0bf8a73b2f76839e651a6",
                            "repo_path": "android_repos/av",
                            "result": "success",
                            "downstream_patch_content": "commit 90641b2799fd3940cdf0bf8a73b2f76839e651a6\nAuthor: Haripriya Deshmukh <haripriya.deshmukh@ittiam.com>\nDate:   Tue Sep 19 20:42:45 2023 +0000\n\n    Validate OMX Params for VPx encoders\n    \n    Bug: 273936274\n    Bug: 273937171\n    Bug: 273937136\n    Bug: 273936553\n    Bug: 273936601\n    Test: POC in bug descriptions\n    (cherry picked from https://partner-android-review.googlesource.com/q/commit:022086b76536cd2e19a44053271190bdf6e181f7)\n    Merged-In: I9bb17112d9f0217b6af0343afecc9c943453b757\n    Change-Id: I9bb17112d9f0217b6af0343afecc9c943453b757\n    (cherry picked from commit 0e4ca1cb5c16af8f1dfb0ae41941c16c104d38e8)\n\ndiff --git a/media/libstagefright/codecs/on2/enc/SoftVP8Encoder.cpp b/media/libstagefright/codecs/on2/enc/SoftVP8Encoder.cpp\nindex 04737a9ccf..9198b7c327 100644\n--- a/media/libstagefright/codecs/on2/enc/SoftVP8Encoder.cpp\n+++ b/media/libstagefright/codecs/on2/enc/SoftVP8Encoder.cpp\n@@ -120,6 +120,11 @@ OMX_ERRORTYPE SoftVP8Encoder::internalSetParameter(OMX_INDEXTYPE index,\n \n OMX_ERRORTYPE SoftVP8Encoder::internalGetVp8Params(\n         OMX_VIDEO_PARAM_VP8TYPE* vp8Params) {\n+    if (!isValidOMXParam(vp8Params)) {\n+        android_errorWriteLog(0x534e4554, \"273936274\");\n+        return OMX_ErrorBadParameter;\n+    }\n+\n     if (vp8Params->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\n@@ -133,6 +138,11 @@ OMX_ERRORTYPE SoftVP8Encoder::internalGetVp8Params(\n \n OMX_ERRORTYPE SoftVP8Encoder::internalSetVp8Params(\n         const OMX_VIDEO_PARAM_VP8TYPE* vp8Params) {\n+    if (!isValidOMXParam(vp8Params)) {\n+        android_errorWriteLog(0x534e4554, \"273937171\");\n+        return OMX_ErrorBadParameter;\n+    }\n+\n     if (vp8Params->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\ndiff --git a/media/libstagefright/codecs/on2/enc/SoftVP9Encoder.cpp b/media/libstagefright/codecs/on2/enc/SoftVP9Encoder.cpp\nindex 1ea1c85f76..f8495c2da4 100644\n--- a/media/libstagefright/codecs/on2/enc/SoftVP9Encoder.cpp\n+++ b/media/libstagefright/codecs/on2/enc/SoftVP9Encoder.cpp\n@@ -119,6 +119,11 @@ OMX_ERRORTYPE SoftVP9Encoder::internalSetParameter(\n \n OMX_ERRORTYPE SoftVP9Encoder::internalGetVp9Params(\n         OMX_VIDEO_PARAM_VP9TYPE *vp9Params) {\n+    if (!isValidOMXParam(vp9Params)) {\n+        android_errorWriteLog(0x534e4554, \"273936553\");\n+        return OMX_ErrorBadParameter;\n+    }\n+\n     if (vp9Params->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\n@@ -133,6 +138,11 @@ OMX_ERRORTYPE SoftVP9Encoder::internalGetVp9Params(\n \n OMX_ERRORTYPE SoftVP9Encoder::internalSetVp9Params(\n         const OMX_VIDEO_PARAM_VP9TYPE *vp9Params) {\n+    if (!isValidOMXParam(vp9Params)) {\n+        android_errorWriteLog(0x534e4554, \"273937136\");\n+        return OMX_ErrorBadParameter;\n+    }\n+\n     if (vp9Params->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\ndiff --git a/media/libstagefright/codecs/on2/enc/SoftVPXEncoder.cpp b/media/libstagefright/codecs/on2/enc/SoftVPXEncoder.cpp\nindex d0cb0718c2..054413e7c0 100644\n--- a/media/libstagefright/codecs/on2/enc/SoftVPXEncoder.cpp\n+++ b/media/libstagefright/codecs/on2/enc/SoftVPXEncoder.cpp\n@@ -485,6 +485,11 @@ OMX_ERRORTYPE SoftVPXEncoder::internalSetBitrateParams(\n \n OMX_ERRORTYPE SoftVPXEncoder::internalGetAndroidVpxParams(\n         OMX_VIDEO_PARAM_ANDROID_VP8ENCODERTYPE *vpxAndroidParams) {\n+    if (!isValidOMXParam(vpxAndroidParams)) {\n+        android_errorWriteLog(0x534e4554, \"273936601\");\n+        return OMX_ErrorBadParameter;\n+    }\n+\n     if (vpxAndroidParams->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\n@@ -501,6 +506,10 @@ OMX_ERRORTYPE SoftVPXEncoder::internalGetAndroidVpxParams(\n \n OMX_ERRORTYPE SoftVPXEncoder::internalSetAndroidVpxParams(\n         const OMX_VIDEO_PARAM_ANDROID_VP8ENCODERTYPE *vpxAndroidParams) {\n+    if (!isValidOMXParam(vpxAndroidParams)) {\n+        android_errorWriteLog(0x534e4554, \"273937551\");\n+        return OMX_ErrorBadParameter;\n+    }\n     if (vpxAndroidParams->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\n",
                            "downstream_patch_tokens": {
                                "openai": 1344,
                                "general": {
                                    "word_based": 337,
                                    "char_based": 1039
                                },
                                "gemini": 1758
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "90641b2799fd3940cdf0bf8a73b2f76839e651a6",
                            "repo_path": "android_repos/av",
                            "result": "success",
                            "downstream_patch_content": "commit 90641b2799fd3940cdf0bf8a73b2f76839e651a6\nAuthor: Haripriya Deshmukh <haripriya.deshmukh@ittiam.com>\nDate:   Tue Sep 19 20:42:45 2023 +0000\n\n    Validate OMX Params for VPx encoders\n    \n    Bug: 273936274\n    Bug: 273937171\n    Bug: 273937136\n    Bug: 273936553\n    Bug: 273936601\n    Test: POC in bug descriptions\n    (cherry picked from https://partner-android-review.googlesource.com/q/commit:022086b76536cd2e19a44053271190bdf6e181f7)\n    Merged-In: I9bb17112d9f0217b6af0343afecc9c943453b757\n    Change-Id: I9bb17112d9f0217b6af0343afecc9c943453b757\n    (cherry picked from commit 0e4ca1cb5c16af8f1dfb0ae41941c16c104d38e8)\n\ndiff --git a/media/libstagefright/codecs/on2/enc/SoftVP8Encoder.cpp b/media/libstagefright/codecs/on2/enc/SoftVP8Encoder.cpp\nindex 04737a9ccf..9198b7c327 100644\n--- a/media/libstagefright/codecs/on2/enc/SoftVP8Encoder.cpp\n+++ b/media/libstagefright/codecs/on2/enc/SoftVP8Encoder.cpp\n@@ -120,6 +120,11 @@ OMX_ERRORTYPE SoftVP8Encoder::internalSetParameter(OMX_INDEXTYPE index,\n \n OMX_ERRORTYPE SoftVP8Encoder::internalGetVp8Params(\n         OMX_VIDEO_PARAM_VP8TYPE* vp8Params) {\n+    if (!isValidOMXParam(vp8Params)) {\n+        android_errorWriteLog(0x534e4554, \"273936274\");\n+        return OMX_ErrorBadParameter;\n+    }\n+\n     if (vp8Params->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\n@@ -133,6 +138,11 @@ OMX_ERRORTYPE SoftVP8Encoder::internalGetVp8Params(\n \n OMX_ERRORTYPE SoftVP8Encoder::internalSetVp8Params(\n         const OMX_VIDEO_PARAM_VP8TYPE* vp8Params) {\n+    if (!isValidOMXParam(vp8Params)) {\n+        android_errorWriteLog(0x534e4554, \"273937171\");\n+        return OMX_ErrorBadParameter;\n+    }\n+\n     if (vp8Params->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\ndiff --git a/media/libstagefright/codecs/on2/enc/SoftVP9Encoder.cpp b/media/libstagefright/codecs/on2/enc/SoftVP9Encoder.cpp\nindex 1ea1c85f76..f8495c2da4 100644\n--- a/media/libstagefright/codecs/on2/enc/SoftVP9Encoder.cpp\n+++ b/media/libstagefright/codecs/on2/enc/SoftVP9Encoder.cpp\n@@ -119,6 +119,11 @@ OMX_ERRORTYPE SoftVP9Encoder::internalSetParameter(\n \n OMX_ERRORTYPE SoftVP9Encoder::internalGetVp9Params(\n         OMX_VIDEO_PARAM_VP9TYPE *vp9Params) {\n+    if (!isValidOMXParam(vp9Params)) {\n+        android_errorWriteLog(0x534e4554, \"273936553\");\n+        return OMX_ErrorBadParameter;\n+    }\n+\n     if (vp9Params->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\n@@ -133,6 +138,11 @@ OMX_ERRORTYPE SoftVP9Encoder::internalGetVp9Params(\n \n OMX_ERRORTYPE SoftVP9Encoder::internalSetVp9Params(\n         const OMX_VIDEO_PARAM_VP9TYPE *vp9Params) {\n+    if (!isValidOMXParam(vp9Params)) {\n+        android_errorWriteLog(0x534e4554, \"273937136\");\n+        return OMX_ErrorBadParameter;\n+    }\n+\n     if (vp9Params->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\ndiff --git a/media/libstagefright/codecs/on2/enc/SoftVPXEncoder.cpp b/media/libstagefright/codecs/on2/enc/SoftVPXEncoder.cpp\nindex d0cb0718c2..054413e7c0 100644\n--- a/media/libstagefright/codecs/on2/enc/SoftVPXEncoder.cpp\n+++ b/media/libstagefright/codecs/on2/enc/SoftVPXEncoder.cpp\n@@ -485,6 +485,11 @@ OMX_ERRORTYPE SoftVPXEncoder::internalSetBitrateParams(\n \n OMX_ERRORTYPE SoftVPXEncoder::internalGetAndroidVpxParams(\n         OMX_VIDEO_PARAM_ANDROID_VP8ENCODERTYPE *vpxAndroidParams) {\n+    if (!isValidOMXParam(vpxAndroidParams)) {\n+        android_errorWriteLog(0x534e4554, \"273936601\");\n+        return OMX_ErrorBadParameter;\n+    }\n+\n     if (vpxAndroidParams->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\n@@ -501,6 +506,10 @@ OMX_ERRORTYPE SoftVPXEncoder::internalGetAndroidVpxParams(\n \n OMX_ERRORTYPE SoftVPXEncoder::internalSetAndroidVpxParams(\n         const OMX_VIDEO_PARAM_ANDROID_VP8ENCODERTYPE *vpxAndroidParams) {\n+    if (!isValidOMXParam(vpxAndroidParams)) {\n+        android_errorWriteLog(0x534e4554, \"273937551\");\n+        return OMX_ErrorBadParameter;\n+    }\n     if (vpxAndroidParams->nPortIndex != kOutputPortIndex) {\n         return OMX_ErrorUnsupportedIndex;\n     }\n",
                            "downstream_patch_tokens": {
                                "openai": 1344,
                                "general": {
                                    "word_based": 337,
                                    "char_based": 1039
                                },
                                "gemini": 1758
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-316153291",
            "aliases": [
                "A-316153291",
                "CVE-2024-31317"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-316153291",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "7ba059e2cf0a2c20f9a849719cdc32b12c933a44"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 7ba059e2cf0a2c20f9a849719cdc32b12c933a44 Mon Sep 17 00:00:00 2001\nFrom: Hans Boehm <hboehm@google.com>\nDate: Tue, 2 Jan 2024 16:53:13 -0800\nSubject: [PATCH] Check hidden API exemptions\n\nRefuse to deal with newlines and null characters in\nHiddenApiSettings.update(). Also disallow nulls in process start\narguments.\n\nBug: 316153291\nTest: Treehugger for now\nChange-Id: I83cd60e46407a4a082f9f3c80e937dbd522dbac4\n---\n core/java/android/os/ZygoteProcess.java | 10 ++++++++++\n 1 file changed, 10 insertions(+)\n\ndiff --git a/core/java/android/os/ZygoteProcess.java b/core/java/android/os/ZygoteProcess.java\nindex c14810bbcd64..f3496e7f2592 100644\n--- a/core/java/android/os/ZygoteProcess.java\n+++ b/core/java/android/os/ZygoteProcess.java\n@@ -425,6 +425,8 @@ public class ZygoteProcess {\n                 throw new ZygoteStartFailedEx(\"Embedded newlines not allowed\");\n             } else if (arg.indexOf('\\r') >= 0) {\n                 throw new ZygoteStartFailedEx(\"Embedded carriage returns not allowed\");\n+            } else if (arg.indexOf('\\u0000') >= 0) {\n+                throw new ZygoteStartFailedEx(\"Embedded nulls not allowed\");\n             }\n         }\n \n@@ -965,6 +967,14 @@ public class ZygoteProcess {\n             return true;\n         }\n \n+        for (/* NonNull */ String s : mApiDenylistExemptions) {\n+            // indexOf() is intrinsified and faster than contains().\n+            if (s.indexOf('\\n') >= 0 || s.indexOf('\\r') >= 0 || s.indexOf('\\u0000') >= 0) {\n+                Slog.e(LOG_TAG, \"Failed to set API denylist exemptions: Bad character\");\n+                mApiDenylistExemptions = Collections.emptyList();\n+                return false;\n+            }\n+        }\n         try {\n             state.mZygoteOutputWriter.write(Integer.toString(mApiDenylistExemptions.size() + 1));\n             state.mZygoteOutputWriter.newLine();\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 546,
                        "general": {
                            "word_based": 212,
                            "char_based": 472
                        },
                        "gemini": 682
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "60669aa49aba34c0950d6246bd95b54f91a3c8e8",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 60669aa49aba34c0950d6246bd95b54f91a3c8e8\nAuthor: Hans Boehm <hboehm@google.com>\nDate:   Tue Jan 2 16:53:13 2024 -0800\n\n    Check hidden API exemptions\n    \n    Refuse to deal with newlines and null characters in\n    HiddenApiSettings.update(). Also disallow nulls in process start\n    arguments.\n    \n    Bug: 316153291\n    Test: Treehugger for now\n    Change-Id: I83cd60e46407a4a082f9f3c80e937dbd522dbac4\n    (cherry picked from commit 7ba059e2cf0a2c20f9a849719cdc32b12c933a44)\n\ndiff --git a/core/java/android/os/ZygoteProcess.java b/core/java/android/os/ZygoteProcess.java\nindex bf2898137967..63bcf5f119e1 100644\n--- a/core/java/android/os/ZygoteProcess.java\n+++ b/core/java/android/os/ZygoteProcess.java\n@@ -431,6 +431,8 @@ public class ZygoteProcess {\n                 throw new ZygoteStartFailedEx(\"Embedded newlines not allowed\");\n             } else if (arg.indexOf('\\r') >= 0) {\n                 throw new ZygoteStartFailedEx(\"Embedded carriage returns not allowed\");\n+            } else if (arg.indexOf('\\u0000') >= 0) {\n+                throw new ZygoteStartFailedEx(\"Embedded nulls not allowed\");\n             }\n         }\n \n@@ -972,6 +974,14 @@ public class ZygoteProcess {\n             return true;\n         }\n \n+        for (/* NonNull */ String s : mApiDenylistExemptions) {\n+            // indexOf() is intrinsified and faster than contains().\n+            if (s.indexOf('\\n') >= 0 || s.indexOf('\\r') >= 0 || s.indexOf('\\u0000') >= 0) {\n+                Slog.e(LOG_TAG, \"Failed to set API denylist exemptions: Bad character\");\n+                mApiDenylistExemptions = Collections.emptyList();\n+                return false;\n+            }\n+        }\n         try {\n             state.mZygoteOutputWriter.write(Integer.toString(mApiDenylistExemptions.size() + 1));\n             state.mZygoteOutputWriter.newLine();\n",
                            "downstream_patch_tokens": {
                                "openai": 528,
                                "general": {
                                    "word_based": 190,
                                    "char_based": 459
                                },
                                "gemini": 661
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "60669aa49aba34c0950d6246bd95b54f91a3c8e8",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 60669aa49aba34c0950d6246bd95b54f91a3c8e8\nAuthor: Hans Boehm <hboehm@google.com>\nDate:   Tue Jan 2 16:53:13 2024 -0800\n\n    Check hidden API exemptions\n    \n    Refuse to deal with newlines and null characters in\n    HiddenApiSettings.update(). Also disallow nulls in process start\n    arguments.\n    \n    Bug: 316153291\n    Test: Treehugger for now\n    Change-Id: I83cd60e46407a4a082f9f3c80e937dbd522dbac4\n    (cherry picked from commit 7ba059e2cf0a2c20f9a849719cdc32b12c933a44)\n\ndiff --git a/core/java/android/os/ZygoteProcess.java b/core/java/android/os/ZygoteProcess.java\nindex bf2898137967..63bcf5f119e1 100644\n--- a/core/java/android/os/ZygoteProcess.java\n+++ b/core/java/android/os/ZygoteProcess.java\n@@ -431,6 +431,8 @@ public class ZygoteProcess {\n                 throw new ZygoteStartFailedEx(\"Embedded newlines not allowed\");\n             } else if (arg.indexOf('\\r') >= 0) {\n                 throw new ZygoteStartFailedEx(\"Embedded carriage returns not allowed\");\n+            } else if (arg.indexOf('\\u0000') >= 0) {\n+                throw new ZygoteStartFailedEx(\"Embedded nulls not allowed\");\n             }\n         }\n \n@@ -972,6 +974,14 @@ public class ZygoteProcess {\n             return true;\n         }\n \n+        for (/* NonNull */ String s : mApiDenylistExemptions) {\n+            // indexOf() is intrinsified and faster than contains().\n+            if (s.indexOf('\\n') >= 0 || s.indexOf('\\r') >= 0 || s.indexOf('\\u0000') >= 0) {\n+                Slog.e(LOG_TAG, \"Failed to set API denylist exemptions: Bad character\");\n+                mApiDenylistExemptions = Collections.emptyList();\n+                return false;\n+            }\n+        }\n         try {\n             state.mZygoteOutputWriter.write(Integer.toString(mApiDenylistExemptions.size() + 1));\n             state.mZygoteOutputWriter.newLine();\n",
                            "downstream_patch_tokens": {
                                "openai": 528,
                                "general": {
                                    "word_based": 190,
                                    "char_based": 459
                                },
                                "gemini": 661
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "60669aa49aba34c0950d6246bd95b54f91a3c8e8",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 60669aa49aba34c0950d6246bd95b54f91a3c8e8\nAuthor: Hans Boehm <hboehm@google.com>\nDate:   Tue Jan 2 16:53:13 2024 -0800\n\n    Check hidden API exemptions\n    \n    Refuse to deal with newlines and null characters in\n    HiddenApiSettings.update(). Also disallow nulls in process start\n    arguments.\n    \n    Bug: 316153291\n    Test: Treehugger for now\n    Change-Id: I83cd60e46407a4a082f9f3c80e937dbd522dbac4\n    (cherry picked from commit 7ba059e2cf0a2c20f9a849719cdc32b12c933a44)\n\ndiff --git a/core/java/android/os/ZygoteProcess.java b/core/java/android/os/ZygoteProcess.java\nindex bf2898137967..63bcf5f119e1 100644\n--- a/core/java/android/os/ZygoteProcess.java\n+++ b/core/java/android/os/ZygoteProcess.java\n@@ -431,6 +431,8 @@ public class ZygoteProcess {\n                 throw new ZygoteStartFailedEx(\"Embedded newlines not allowed\");\n             } else if (arg.indexOf('\\r') >= 0) {\n                 throw new ZygoteStartFailedEx(\"Embedded carriage returns not allowed\");\n+            } else if (arg.indexOf('\\u0000') >= 0) {\n+                throw new ZygoteStartFailedEx(\"Embedded nulls not allowed\");\n             }\n         }\n \n@@ -972,6 +974,14 @@ public class ZygoteProcess {\n             return true;\n         }\n \n+        for (/* NonNull */ String s : mApiDenylistExemptions) {\n+            // indexOf() is intrinsified and faster than contains().\n+            if (s.indexOf('\\n') >= 0 || s.indexOf('\\r') >= 0 || s.indexOf('\\u0000') >= 0) {\n+                Slog.e(LOG_TAG, \"Failed to set API denylist exemptions: Bad character\");\n+                mApiDenylistExemptions = Collections.emptyList();\n+                return false;\n+            }\n+        }\n         try {\n             state.mZygoteOutputWriter.write(Integer.toString(mApiDenylistExemptions.size() + 1));\n             state.mZygoteOutputWriter.newLine();\n",
                            "downstream_patch_tokens": {
                                "openai": 528,
                                "general": {
                                    "word_based": 190,
                                    "char_based": 459
                                },
                                "gemini": 661
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "60669aa49aba34c0950d6246bd95b54f91a3c8e8",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 60669aa49aba34c0950d6246bd95b54f91a3c8e8\nAuthor: Hans Boehm <hboehm@google.com>\nDate:   Tue Jan 2 16:53:13 2024 -0800\n\n    Check hidden API exemptions\n    \n    Refuse to deal with newlines and null characters in\n    HiddenApiSettings.update(). Also disallow nulls in process start\n    arguments.\n    \n    Bug: 316153291\n    Test: Treehugger for now\n    Change-Id: I83cd60e46407a4a082f9f3c80e937dbd522dbac4\n    (cherry picked from commit 7ba059e2cf0a2c20f9a849719cdc32b12c933a44)\n\ndiff --git a/core/java/android/os/ZygoteProcess.java b/core/java/android/os/ZygoteProcess.java\nindex bf2898137967..63bcf5f119e1 100644\n--- a/core/java/android/os/ZygoteProcess.java\n+++ b/core/java/android/os/ZygoteProcess.java\n@@ -431,6 +431,8 @@ public class ZygoteProcess {\n                 throw new ZygoteStartFailedEx(\"Embedded newlines not allowed\");\n             } else if (arg.indexOf('\\r') >= 0) {\n                 throw new ZygoteStartFailedEx(\"Embedded carriage returns not allowed\");\n+            } else if (arg.indexOf('\\u0000') >= 0) {\n+                throw new ZygoteStartFailedEx(\"Embedded nulls not allowed\");\n             }\n         }\n \n@@ -972,6 +974,14 @@ public class ZygoteProcess {\n             return true;\n         }\n \n+        for (/* NonNull */ String s : mApiDenylistExemptions) {\n+            // indexOf() is intrinsified and faster than contains().\n+            if (s.indexOf('\\n') >= 0 || s.indexOf('\\r') >= 0 || s.indexOf('\\u0000') >= 0) {\n+                Slog.e(LOG_TAG, \"Failed to set API denylist exemptions: Bad character\");\n+                mApiDenylistExemptions = Collections.emptyList();\n+                return false;\n+            }\n+        }\n         try {\n             state.mZygoteOutputWriter.write(Integer.toString(mApiDenylistExemptions.size() + 1));\n             state.mZygoteOutputWriter.newLine();\n",
                            "downstream_patch_tokens": {
                                "openai": 528,
                                "general": {
                                    "word_based": 190,
                                    "char_based": 459
                                },
                                "gemini": 661
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-242996380",
            "aliases": [
                "A-242996380",
                "CVE-2024-34719"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-242996380",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "8098771bca75166d06f9591d0d2110ed089ee6a7"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 8098771bca75166d06f9591d0d2110ed089ee6a7 Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Fri, 3 May 2024 21:57:24 +0000\nSubject: [PATCH] Fix permission bypasses to multiple methods\n\nResearcher reports that some BT calls across Binder are validating only\nBT's own permissions and not the calling app's permissions.  On\ninvestigation this seems to be due to a missing null check in several BT\npermissions checks, which allows a malicious app to pass in a null\nAttributionSource and therefore produce a stub AttributionSource chain\nwhich does not properly check for the caller's permissions.\n\nAdd null checks, and correct tests which assumed a null was a valid\ninput.\n\nBug: 242996380\nTest: atest UtilsTest\nTest: researcher POC\nTag: #security\nIgnore-AOSP-First: Security\nChange-Id: I76f49fee440726a7c0714385564ddf0e3e8522b5\n---\n .../app/src/com/android/bluetooth/Utils.java  | 32 +++++++++----------\n .../src/com/android/bluetooth/UtilsTest.java  | 13 +++++---\n .../server/bluetooth/BtPermissionUtils.java   |  4 ++-\n 3 files changed, 28 insertions(+), 21 deletions(-)\n\ndiff --git a/android/app/src/com/android/bluetooth/Utils.java b/android/app/src/com/android/bluetooth/Utils.java\nindex ff57a833cd..70d9004f0b 100644\n--- a/android/app/src/com/android/bluetooth/Utils.java\n+++ b/android/app/src/com/android/bluetooth/Utils.java\n@@ -598,10 +598,10 @@ public final class Utils {\n         }\n         // STOPSHIP(b/188391719): enable this security enforcement\n         // attributionSource.enforceCallingUid();\n-        AttributionSource currentAttribution = new AttributionSource\n-                .Builder(context.getAttributionSource())\n-                .setNext(attributionSource)\n-                .build();\n+        AttributionSource currentAttribution =\n+                new AttributionSource.Builder(context.getAttributionSource())\n+                        .setNext(Objects.requireNonNull(attributionSource))\n+                        .build();\n         PermissionManager pm = context.getSystemService(PermissionManager.class);\n         if (pm == null) {\n             return false;\n@@ -873,10 +873,10 @@ public final class Utils {\n             Log.e(TAG, \"Permission denial: Location is off.\");\n             return false;\n         }\n-        AttributionSource currentAttribution = new AttributionSource\n-                .Builder(context.getAttributionSource())\n-                .setNext(attributionSource)\n-                .build();\n+        AttributionSource currentAttribution =\n+                new AttributionSource.Builder(context.getAttributionSource())\n+                        .setNext(Objects.requireNonNull(attributionSource))\n+                        .build();\n         // STOPSHIP(b/188391719): enable this security enforcement\n         // attributionSource.enforceCallingUid();\n         PermissionManager pm = context.getSystemService(PermissionManager.class);\n@@ -907,10 +907,10 @@ public final class Utils {\n             return false;\n         }\n \n-        final AttributionSource currentAttribution = new AttributionSource\n-                .Builder(context.getAttributionSource())\n-                .setNext(attributionSource)\n-                .build();\n+        final AttributionSource currentAttribution =\n+                new AttributionSource.Builder(context.getAttributionSource())\n+                        .setNext(Objects.requireNonNull(attributionSource))\n+                        .build();\n         // STOPSHIP(b/188391719): enable this security enforcement\n         // attributionSource.enforceCallingUid();\n         PermissionManager pm = context.getSystemService(PermissionManager.class);\n@@ -945,10 +945,10 @@ public final class Utils {\n             return false;\n         }\n \n-        AttributionSource currentAttribution = new AttributionSource\n-                .Builder(context.getAttributionSource())\n-                .setNext(attributionSource)\n-                .build();\n+        AttributionSource currentAttribution =\n+                new AttributionSource.Builder(context.getAttributionSource())\n+                        .setNext(Objects.requireNonNull(attributionSource))\n+                        .build();\n         // STOPSHIP(b/188391719): enable this security enforcement\n         // attributionSource.enforceCallingUid();\n         PermissionManager pm = context.getSystemService(PermissionManager.class);\ndiff --git a/android/app/tests/unit/src/com/android/bluetooth/UtilsTest.java b/android/app/tests/unit/src/com/android/bluetooth/UtilsTest.java\nindex b4d73bc5c1..2b3d17ee13 100644\n--- a/android/app/tests/unit/src/com/android/bluetooth/UtilsTest.java\n+++ b/android/app/tests/unit/src/com/android/bluetooth/UtilsTest.java\n@@ -120,10 +120,12 @@ public class UtilsTest {\n         boolean enabledStatus = locationManager.isLocationEnabledForUser(userHandle);\n \n         locationManager.setLocationEnabledForUser(false, userHandle);\n-        assertThat(Utils.checkCallerHasCoarseLocation(context, null, userHandle)).isFalse();\n+        assertThat(Utils.checkCallerHasCoarseLocation(\n+                       context, context.getAttributionSource(), userHandle))\n+                .isFalse();\n \n         locationManager.setLocationEnabledForUser(true, userHandle);\n-        Utils.checkCallerHasCoarseLocation(context, null, userHandle);\n+        Utils.checkCallerHasCoarseLocation(context, context.getAttributionSource(), userHandle);\n         if (!enabledStatus) {\n             locationManager.setLocationEnabledForUser(false, userHandle);\n         }\n@@ -137,10 +139,13 @@ public class UtilsTest {\n         boolean enabledStatus = locationManager.isLocationEnabledForUser(userHandle);\n \n         locationManager.setLocationEnabledForUser(false, userHandle);\n-        assertThat(Utils.checkCallerHasCoarseOrFineLocation(context, null, userHandle)).isFalse();\n+        assertThat(Utils.checkCallerHasCoarseOrFineLocation(\n+                       context, context.getAttributionSource(), userHandle))\n+                .isFalse();\n \n         locationManager.setLocationEnabledForUser(true, userHandle);\n-        Utils.checkCallerHasCoarseOrFineLocation(context, null, userHandle);\n+        Utils.checkCallerHasCoarseOrFineLocation(\n+                context, context.getAttributionSource(), userHandle);\n         if (!enabledStatus) {\n             locationManager.setLocationEnabledForUser(false, userHandle);\n         }\ndiff --git a/service/src/com/android/server/bluetooth/BtPermissionUtils.java b/service/src/com/android/server/bluetooth/BtPermissionUtils.java\nindex c68f25b65f..b3ba3b013d 100644\n--- a/service/src/com/android/server/bluetooth/BtPermissionUtils.java\n+++ b/service/src/com/android/server/bluetooth/BtPermissionUtils.java\n@@ -86,7 +86,9 @@ class BtPermissionUtils {\n             String message) {\n         final String permission = BLUETOOTH_CONNECT;\n         AttributionSource currentSource =\n-                new AttributionSource.Builder(ctx.getAttributionSource()).setNext(source).build();\n+                new AttributionSource.Builder(ctx.getAttributionSource())\n+                        .setNext(Objects.requireNonNull(source))\n+                        .build();\n         final int result =\n                 permissionManager.checkPermissionForDataDeliveryFromDataSource(\n                         permission, currentSource, message);\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 1545,
                        "general": {
                            "word_based": 642,
                            "char_based": 1837
                        },
                        "gemini": 1917
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 0,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "result": "skipped",
                            "reason": "\u274c Failed to checkout branch android12-release: Command '['git', 'checkout', 'android12-release']' returned non-zero exit status 1.",
                            "downstream_patch": "244e4734d1ed316e8725b0f33e18d8eb709554f1"
                        },
                        {
                            "downstream_version": "12L",
                            "result": "skipped",
                            "reason": "\u274c Failed to checkout branch android12L-release: Command '['git', 'checkout', 'android12L-release']' returned non-zero exit status 1.",
                            "downstream_patch": "244e4734d1ed316e8725b0f33e18d8eb709554f1"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "ed63d97fd6537f539fdde1413bff86a30f80a7b5",
                            "repo_path": "android_repos/Bluetooth",
                            "result": "failure",
                            "downstream_patch_content": "commit ed63d97fd6537f539fdde1413bff86a30f80a7b5\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Mon May 6 17:32:14 2024 +0000\n\n    Fix permission bypasses to multiple methods\n    \n    Researcher reports that some BT calls across Binder are validating only\n    BT's own permissions and not the calling app's permissions.  On\n    investigation this seems to be due to a missing null check in several BT\n    permissions checks, which allows a malicious app to pass in a null\n    AttributionSource and therefore produce a stub AttributionSource chain\n    which does not properly check for the caller's permissions.\n    \n    Add null checks.\n    \n    Bug: 242996380\n    Test: atest UtilsTest\n    Test: researcher POC\n    Tag: #security\n    Ignore-AOSP-First: Security\n    Merged-In: I76f49fee440726a7c0714385564ddf0e3e8522b5\n    Merged-In: I9bf6fac218dccc092debe0904e08eb23cc4583c0\n    Change-Id: I7a11e11257b85dc0752396490abfc79b1c383204\n\ndiff --git a/android/app/src/com/android/bluetooth/Utils.java b/android/app/src/com/android/bluetooth/Utils.java\nindex abe63bafe5..57879c0b9b 100644\n--- a/android/app/src/com/android/bluetooth/Utils.java\n+++ b/android/app/src/com/android/bluetooth/Utils.java\n@@ -462,10 +462,10 @@ public final class Utils {\n             AttributionSource attributionSource, String message) {\n         // STOPSHIP(b/188391719): enable this security enforcement\n         // attributionSource.enforceCallingUid();\n-        AttributionSource currentAttribution = new AttributionSource\n-                .Builder(context.getAttributionSource())\n-                .setNext(attributionSource)\n-                .build();\n+        AttributionSource currentAttribution =\n+                new AttributionSource.Builder(context.getAttributionSource())\n+                        .setNext(Objects.requireNonNull(attributionSource))\n+                        .build();\n         PermissionManager pm = context.getSystemService(PermissionManager.class);\n         if (pm == null) {\n             return false;\n@@ -711,10 +711,10 @@ public final class Utils {\n             Log.e(TAG, \"Permission denial: Location is off.\");\n             return false;\n         }\n-        AttributionSource currentAttribution = new AttributionSource\n-                .Builder(context.getAttributionSource())\n-                .setNext(attributionSource)\n-                .build();\n+        AttributionSource currentAttribution =\n+                new AttributionSource.Builder(context.getAttributionSource())\n+                        .setNext(Objects.requireNonNull(attributionSource))\n+                        .build();\n         // STOPSHIP(b/188391719): enable this security enforcement\n         // attributionSource.enforceCallingUid();\n         PermissionManager pm = context.getSystemService(PermissionManager.class);\n@@ -745,10 +745,10 @@ public final class Utils {\n             return false;\n         }\n \n-        final AttributionSource currentAttribution = new AttributionSource\n-                .Builder(context.getAttributionSource())\n-                .setNext(attributionSource)\n-                .build();\n+        final AttributionSource currentAttribution =\n+                new AttributionSource.Builder(context.getAttributionSource())\n+                        .setNext(Objects.requireNonNull(attributionSource))\n+                        .build();\n         // STOPSHIP(b/188391719): enable this security enforcement\n         // attributionSource.enforceCallingUid();\n         PermissionManager pm = context.getSystemService(PermissionManager.class);\n@@ -783,10 +783,10 @@ public final class Utils {\n             return false;\n         }\n \n-        AttributionSource currentAttribution = new AttributionSource\n-                .Builder(context.getAttributionSource())\n-                .setNext(attributionSource)\n-                .build();\n+        AttributionSource currentAttribution =\n+                new AttributionSource.Builder(context.getAttributionSource())\n+                        .setNext(Objects.requireNonNull(attributionSource))\n+                        .build();\n         // STOPSHIP(b/188391719): enable this security enforcement\n         // attributionSource.enforceCallingUid();\n         PermissionManager pm = context.getSystemService(PermissionManager.class);\n",
                            "downstream_patch_tokens": {
                                "openai": 907,
                                "general": {
                                    "word_based": 363,
                                    "char_based": 1068
                                },
                                "gemini": 1129
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "service/src/com/android/server/bluetooth/BtPermissionUtils.java",
                                    "total_hunks": 0,
                                    "failed_hunks": [],
                                    "inline_merge_conflicts": [],
                                    "rej_file_content": "",
                                    "patch_apply_output": "patching file android/app/src/com/android/bluetooth/Utils.java\nHunk #1 succeeded at 462 with fuzz 1 (offset -136 lines).\nHunk #2 succeeded at 711 (offset -162 lines).\nHunk #3 succeeded at 745 (offset -162 lines).\nHunk #4 succeeded at 783 (offset -162 lines).\ncan't find file to patch at input line 69\nPerhaps you used the wrong -p or --strip option?\nThe text leading up to this was:\n--------------------------\n|diff --git a/service/src/com/android/server/bluetooth/BtPermissionUtils.java b/service/src/com/android/server/bluetooth/BtPermissionUtils.java\n|index c68f25b65f..b3ba3b013d 100644\n|--- a/service/src/com/android/server/bluetooth/BtPermissionUtils.java\n|+++ b/service/src/com/android/server/bluetooth/BtPermissionUtils.java\n--------------------------\nFile to patch: \nSkip this patch? [y] \nSkipping patch.\n1 out of 1 hunk ignored",
                                    "inline_merge_output": "",
                                    "reason": "File 'service/src/com/android/server/bluetooth/BtPermissionUtils.java' is missing in downstream repo",
                                    "upstream_file_content": "",
                                    "downstream_file_content": "",
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "5fe72f931db2898eb51a44e3b1b424c6370e8ad8",
                            "repo_path": "android_repos/Bluetooth",
                            "result": "failure",
                            "downstream_patch_content": "commit 5fe72f931db2898eb51a44e3b1b424c6370e8ad8\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Mon May 6 17:38:49 2024 +0000\n\n    Fix permission bypasses to multiple methods\n    \n    Researcher reports that some BT calls across Binder are validating only\n    BT's own permissions and not the calling app's permissions.  On\n    investigation this seems to be due to a missing null check in several BT\n    permissions checks, which allows a malicious app to pass in a null\n    AttributionSource and therefore produce a stub AttributionSource chain\n    which does not properly check for the caller's permissions.\n    \n    Add null checks, and correct tests which assumed a null was a valid\n    input.\n    \n    Bug: 242996380\n    Test: atest UtilsTest\n    Test: researcher POC\n    Tag: #security\n    Ignore-AOSP-First: Security\n    Merged-In: I76f49fee440726a7c0714385564ddf0e3e8522b5\n    Change-Id: I9bf6fac218dccc092debe0904e08eb23cc4583c0\n\ndiff --git a/android/app/src/com/android/bluetooth/Utils.java b/android/app/src/com/android/bluetooth/Utils.java\nindex 2f0fb5f088..fd7a15ab3b 100644\n--- a/android/app/src/com/android/bluetooth/Utils.java\n+++ b/android/app/src/com/android/bluetooth/Utils.java\n@@ -534,10 +534,10 @@ public final class Utils {\n         }\n         // STOPSHIP(b/188391719): enable this security enforcement\n         // attributionSource.enforceCallingUid();\n-        AttributionSource currentAttribution = new AttributionSource\n-                .Builder(context.getAttributionSource())\n-                .setNext(attributionSource)\n-                .build();\n+        AttributionSource currentAttribution =\n+                new AttributionSource.Builder(context.getAttributionSource())\n+                        .setNext(Objects.requireNonNull(attributionSource))\n+                        .build();\n         PermissionManager pm = context.getSystemService(PermissionManager.class);\n         if (pm == null) {\n             return false;\n@@ -809,10 +809,10 @@ public final class Utils {\n             Log.e(TAG, \"Permission denial: Location is off.\");\n             return false;\n         }\n-        AttributionSource currentAttribution = new AttributionSource\n-                .Builder(context.getAttributionSource())\n-                .setNext(attributionSource)\n-                .build();\n+        AttributionSource currentAttribution =\n+                new AttributionSource.Builder(context.getAttributionSource())\n+                        .setNext(Objects.requireNonNull(attributionSource))\n+                        .build();\n         // STOPSHIP(b/188391719): enable this security enforcement\n         // attributionSource.enforceCallingUid();\n         PermissionManager pm = context.getSystemService(PermissionManager.class);\n@@ -843,10 +843,10 @@ public final class Utils {\n             return false;\n         }\n \n-        final AttributionSource currentAttribution = new AttributionSource\n-                .Builder(context.getAttributionSource())\n-                .setNext(attributionSource)\n-                .build();\n+        final AttributionSource currentAttribution =\n+                new AttributionSource.Builder(context.getAttributionSource())\n+                        .setNext(Objects.requireNonNull(attributionSource))\n+                        .build();\n         // STOPSHIP(b/188391719): enable this security enforcement\n         // attributionSource.enforceCallingUid();\n         PermissionManager pm = context.getSystemService(PermissionManager.class);\n@@ -881,10 +881,10 @@ public final class Utils {\n             return false;\n         }\n \n-        AttributionSource currentAttribution = new AttributionSource\n-                .Builder(context.getAttributionSource())\n-                .setNext(attributionSource)\n-                .build();\n+        AttributionSource currentAttribution =\n+                new AttributionSource.Builder(context.getAttributionSource())\n+                        .setNext(Objects.requireNonNull(attributionSource))\n+                        .build();\n         // STOPSHIP(b/188391719): enable this security enforcement\n         // attributionSource.enforceCallingUid();\n         PermissionManager pm = context.getSystemService(PermissionManager.class);\ndiff --git a/android/app/tests/unit/src/com/android/bluetooth/UtilsTest.java b/android/app/tests/unit/src/com/android/bluetooth/UtilsTest.java\nindex 20e830c7ba..0a2fef3649 100644\n--- a/android/app/tests/unit/src/com/android/bluetooth/UtilsTest.java\n+++ b/android/app/tests/unit/src/com/android/bluetooth/UtilsTest.java\n@@ -119,10 +119,12 @@ public class UtilsTest {\n         boolean enabledStatus = locationManager.isLocationEnabledForUser(userHandle);\n \n         locationManager.setLocationEnabledForUser(false, userHandle);\n-        assertThat(Utils.checkCallerHasCoarseLocation(context, null, userHandle)).isFalse();\n+        assertThat(Utils.checkCallerHasCoarseLocation(\n+                       context, context.getAttributionSource(), userHandle))\n+                .isFalse();\n \n         locationManager.setLocationEnabledForUser(true, userHandle);\n-        Utils.checkCallerHasCoarseLocation(context, null, userHandle);\n+        Utils.checkCallerHasCoarseLocation(context, context.getAttributionSource(), userHandle);\n         if (!enabledStatus) {\n             locationManager.setLocationEnabledForUser(false, userHandle);\n         }\n@@ -136,10 +138,13 @@ public class UtilsTest {\n         boolean enabledStatus = locationManager.isLocationEnabledForUser(userHandle);\n \n         locationManager.setLocationEnabledForUser(false, userHandle);\n-        assertThat(Utils.checkCallerHasCoarseOrFineLocation(context, null, userHandle)).isFalse();\n+        assertThat(Utils.checkCallerHasCoarseOrFineLocation(\n+                       context, context.getAttributionSource(), userHandle))\n+                .isFalse();\n \n         locationManager.setLocationEnabledForUser(true, userHandle);\n-        Utils.checkCallerHasCoarseOrFineLocation(context, null, userHandle);\n+        Utils.checkCallerHasCoarseOrFineLocation(\n+                context, context.getAttributionSource(), userHandle);\n         if (!enabledStatus) {\n             locationManager.setLocationEnabledForUser(false, userHandle);\n         }\n",
                            "downstream_patch_tokens": {
                                "openai": 1302,
                                "general": {
                                    "word_based": 521,
                                    "char_based": 1557
                                },
                                "gemini": 1611
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "service/src/com/android/server/bluetooth/BtPermissionUtils.java",
                                    "total_hunks": 0,
                                    "failed_hunks": [],
                                    "inline_merge_conflicts": [],
                                    "rej_file_content": "",
                                    "patch_apply_output": "patching file android/app/src/com/android/bluetooth/Utils.java\nHunk #1 succeeded at 534 (offset -64 lines).\nHunk #2 succeeded at 809 (offset -64 lines).\nHunk #3 succeeded at 843 (offset -64 lines).\nHunk #4 succeeded at 881 (offset -64 lines).\ncan't find file to patch at input line 69\nPerhaps you used the wrong -p or --strip option?\nThe text leading up to this was:\n--------------------------\n|diff --git a/service/src/com/android/server/bluetooth/BtPermissionUtils.java b/service/src/com/android/server/bluetooth/BtPermissionUtils.java\n|index c68f25b65f..b3ba3b013d 100644\n|--- a/service/src/com/android/server/bluetooth/BtPermissionUtils.java\n|+++ b/service/src/com/android/server/bluetooth/BtPermissionUtils.java\n--------------------------\nFile to patch: \nSkip this patch? [y] \nSkipping patch.\n1 out of 1 hunk ignored",
                                    "inline_merge_output": "",
                                    "reason": "File 'service/src/com/android/server/bluetooth/BtPermissionUtils.java' is missing in downstream repo",
                                    "upstream_file_content": "",
                                    "downstream_file_content": "",
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    }
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-321341508",
            "aliases": [
                "A-321341508",
                "CVE-2024-31313"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-321341508",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "db9028d6eead72c9cd45da48087ec6d5f1ac9c5a"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From db9028d6eead72c9cd45da48087ec6d5f1ac9c5a Mon Sep 17 00:00:00 2001\nFrom: Devin Moore <devinmoore@google.com>\nDate: Mon, 22 Jan 2024 17:52:16 +0000\nSubject: [PATCH] Use the values of the ptrs that we check\n\nTest: fmq_fuzzer\nBug: 321326147\nBug: 321341508\nBug: 321383085\n(cherry picked from https://android-review.googlesource.com/q/commit:38963310ad5789b625ca0bca9f9c2c8e24666651)\nMerged-In: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\nChange-Id: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\n---\n include/fmq/MessageQueueBase.h | 24 ++++++++++++++++++++----\n 1 file changed, 20 insertions(+), 4 deletions(-)\n\ndiff --git a/include/fmq/MessageQueueBase.h b/include/fmq/MessageQueueBase.h\nindex f99e335..7a027ec 100644\n--- a/include/fmq/MessageQueueBase.h\n+++ b/include/fmq/MessageQueueBase.h\n@@ -1044,8 +1044,16 @@ bool MessageQueueBase<MQDescriptorType, T, flavor>::readBlocking(T* data, size_t\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n-    return mDesc->getSize() - availableToReadBytes();\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n+    size_t queueSizeBytes = mDesc->getSize();\n+    size_t availableBytes = availableToReadBytes();\n+    if (queueSizeBytes < availableBytes) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return queueSizeBytes - availableBytes;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n@@ -1127,13 +1135,21 @@ MessageQueueBase<MQDescriptorType, T, flavor>::commitWrite(size_t nMessages) {\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n     /*\n      * This method is invoked by implementations of both read() and write() and\n      * hence requires a memory_order_acquired load for both mReadPtr and\n      * mWritePtr.\n      */\n-    return mWritePtr->load(std::memory_order_acquire) - mReadPtr->load(std::memory_order_acquire);\n+    uint64_t writePtr = mWritePtr->load(std::memory_order_acquire);\n+    uint64_t readPtr = mReadPtr->load(std::memory_order_acquire);\n+    if (writePtr < readPtr) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return writePtr - readPtr;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 848,
                        "general": {
                            "word_based": 306,
                            "char_based": 730
                        },
                        "gemini": 1025
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "af19e0ef034174afd794563552f91303fd9f1529",
                            "repo_path": "android_repos/libfmq",
                            "result": "success",
                            "downstream_patch_content": "commit af19e0ef034174afd794563552f91303fd9f1529\nAuthor: Devin Moore <devinmoore@google.com>\nDate:   Mon Jan 22 17:52:16 2024 +0000\n\n    Use the values of the ptrs that we check\n    \n    Test: fmq_fuzzer\n    Bug: 321326147\n    Bug: 321341508\n    Bug: 321383085\n    (cherry picked from https://android-review.googlesource.com/q/commit:38963310ad5789b625ca0bca9f9c2c8e24666651)\n    Merged-In: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\n    Change-Id: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\n\ndiff --git a/include/fmq/MessageQueueBase.h b/include/fmq/MessageQueueBase.h\nindex b932317..d3c80bb 100644\n--- a/include/fmq/MessageQueueBase.h\n+++ b/include/fmq/MessageQueueBase.h\n@@ -1042,8 +1042,16 @@ bool MessageQueueBase<MQDescriptorType, T, flavor>::readBlocking(T* data, size_t\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n-    return mDesc->getSize() - availableToReadBytes();\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n+    size_t queueSizeBytes = mDesc->getSize();\n+    size_t availableBytes = availableToReadBytes();\n+    if (queueSizeBytes < availableBytes) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return queueSizeBytes - availableBytes;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n@@ -1125,13 +1133,21 @@ MessageQueueBase<MQDescriptorType, T, flavor>::commitWrite(size_t nMessages) {\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n     /*\n      * This method is invoked by implementations of both read() and write() and\n      * hence requires a memory_order_acquired load for both mReadPtr and\n      * mWritePtr.\n      */\n-    return mWritePtr->load(std::memory_order_acquire) - mReadPtr->load(std::memory_order_acquire);\n+    uint64_t writePtr = mWritePtr->load(std::memory_order_acquire);\n+    uint64_t readPtr = mReadPtr->load(std::memory_order_acquire);\n+    if (writePtr < readPtr) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return writePtr - readPtr;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n",
                            "downstream_patch_tokens": {
                                "openai": 786,
                                "general": {
                                    "word_based": 279,
                                    "char_based": 694
                                },
                                "gemini": 958
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "b923a7c0d0d25de7b0c9ba7a7c2a3e917819d95a",
                            "repo_path": "android_repos/libfmq",
                            "result": "success",
                            "downstream_patch_content": "commit b923a7c0d0d25de7b0c9ba7a7c2a3e917819d95a\nAuthor: Devin Moore <devinmoore@google.com>\nDate:   Mon Jan 22 17:52:16 2024 +0000\n\n    Use the values of the ptrs that we check\n    \n    Test: fmq_fuzzer\n    Bug: 321326147\n    Bug: 321341508\n    Bug: 321383085\n    (cherry picked from https://android-review.googlesource.com/q/commit:38963310ad5789b625ca0bca9f9c2c8e24666651)\n    Merged-In: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\n    Change-Id: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\n\ndiff --git a/include/fmq/MessageQueueBase.h b/include/fmq/MessageQueueBase.h\nindex b932317..d3c80bb 100644\n--- a/include/fmq/MessageQueueBase.h\n+++ b/include/fmq/MessageQueueBase.h\n@@ -1042,8 +1042,16 @@ bool MessageQueueBase<MQDescriptorType, T, flavor>::readBlocking(T* data, size_t\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n-    return mDesc->getSize() - availableToReadBytes();\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n+    size_t queueSizeBytes = mDesc->getSize();\n+    size_t availableBytes = availableToReadBytes();\n+    if (queueSizeBytes < availableBytes) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return queueSizeBytes - availableBytes;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n@@ -1125,13 +1133,21 @@ MessageQueueBase<MQDescriptorType, T, flavor>::commitWrite(size_t nMessages) {\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n     /*\n      * This method is invoked by implementations of both read() and write() and\n      * hence requires a memory_order_acquired load for both mReadPtr and\n      * mWritePtr.\n      */\n-    return mWritePtr->load(std::memory_order_acquire) - mReadPtr->load(std::memory_order_acquire);\n+    uint64_t writePtr = mWritePtr->load(std::memory_order_acquire);\n+    uint64_t readPtr = mReadPtr->load(std::memory_order_acquire);\n+    if (writePtr < readPtr) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return writePtr - readPtr;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n",
                            "downstream_patch_tokens": {
                                "openai": 797,
                                "general": {
                                    "word_based": 279,
                                    "char_based": 694
                                },
                                "gemini": 961
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "050952bf5f9bd035e469ce005300115d563e524a",
                            "repo_path": "android_repos/libfmq",
                            "result": "success",
                            "downstream_patch_content": "commit 050952bf5f9bd035e469ce005300115d563e524a\nAuthor: Devin Moore <devinmoore@google.com>\nDate:   Mon Jan 22 17:52:16 2024 +0000\n\n    Use the values of the ptrs that we check\n    \n    Test: fmq_fuzzer\n    Bug: 321326147\n    Bug: 321341508\n    Bug: 321383085\n    (cherry picked from https://android-review.googlesource.com/q/commit:38963310ad5789b625ca0bca9f9c2c8e24666651)\n    Merged-In: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\n    Change-Id: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\n\ndiff --git a/include/fmq/MessageQueueBase.h b/include/fmq/MessageQueueBase.h\nindex c34a4ff..652487b 100644\n--- a/include/fmq/MessageQueueBase.h\n+++ b/include/fmq/MessageQueueBase.h\n@@ -1022,8 +1022,16 @@ bool MessageQueueBase<MQDescriptorType, T, flavor>::readBlocking(T* data, size_t\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n-    return mDesc->getSize() - availableToReadBytes();\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n+    size_t queueSizeBytes = mDesc->getSize();\n+    size_t availableBytes = availableToReadBytes();\n+    if (queueSizeBytes < availableBytes) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return queueSizeBytes - availableBytes;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n@@ -1105,13 +1113,21 @@ MessageQueueBase<MQDescriptorType, T, flavor>::commitWrite(size_t nMessages) {\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n     /*\n      * This method is invoked by implementations of both read() and write() and\n      * hence requires a memory_order_acquired load for both mReadPtr and\n      * mWritePtr.\n      */\n-    return mWritePtr->load(std::memory_order_acquire) - mReadPtr->load(std::memory_order_acquire);\n+    uint64_t writePtr = mWritePtr->load(std::memory_order_acquire);\n+    uint64_t readPtr = mReadPtr->load(std::memory_order_acquire);\n+    if (writePtr < readPtr) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return writePtr - readPtr;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n",
                            "downstream_patch_tokens": {
                                "openai": 787,
                                "general": {
                                    "word_based": 279,
                                    "char_based": 694
                                },
                                "gemini": 961
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "da080aa565f0cd1158bde3b8100dc73604959035",
                            "repo_path": "android_repos/libfmq",
                            "result": "success",
                            "downstream_patch_content": "commit da080aa565f0cd1158bde3b8100dc73604959035\nAuthor: Devin Moore <devinmoore@google.com>\nDate:   Mon Jan 22 17:52:16 2024 +0000\n\n    Use the values of the ptrs that we check\n    \n    Test: fmq_fuzzer\n    Bug: 321326147\n    Bug: 321341508\n    Bug: 321383085\n    (cherry picked from https://android-review.googlesource.com/q/commit:38963310ad5789b625ca0bca9f9c2c8e24666651)\n    Merged-In: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\n    Change-Id: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\n\ndiff --git a/include/fmq/MessageQueueBase.h b/include/fmq/MessageQueueBase.h\nindex f99e335..7a027ec 100644\n--- a/include/fmq/MessageQueueBase.h\n+++ b/include/fmq/MessageQueueBase.h\n@@ -1044,8 +1044,16 @@ bool MessageQueueBase<MQDescriptorType, T, flavor>::readBlocking(T* data, size_t\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n-    return mDesc->getSize() - availableToReadBytes();\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n+    size_t queueSizeBytes = mDesc->getSize();\n+    size_t availableBytes = availableToReadBytes();\n+    if (queueSizeBytes < availableBytes) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return queueSizeBytes - availableBytes;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n@@ -1127,13 +1135,21 @@ MessageQueueBase<MQDescriptorType, T, flavor>::commitWrite(size_t nMessages) {\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n     /*\n      * This method is invoked by implementations of both read() and write() and\n      * hence requires a memory_order_acquired load for both mReadPtr and\n      * mWritePtr.\n      */\n-    return mWritePtr->load(std::memory_order_acquire) - mReadPtr->load(std::memory_order_acquire);\n+    uint64_t writePtr = mWritePtr->load(std::memory_order_acquire);\n+    uint64_t readPtr = mReadPtr->load(std::memory_order_acquire);\n+    if (writePtr < readPtr) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return writePtr - readPtr;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n",
                            "downstream_patch_tokens": {
                                "openai": 787,
                                "general": {
                                    "word_based": 279,
                                    "char_based": 694
                                },
                                "gemini": 957
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-307532206",
            "aliases": [
                "A-307532206",
                "CVE-2024-0044"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-307532206",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "1f445474cd1b902b2e7292a0d24e58f020fd51e7",
                        "c32cfc60ccf531470f6125b6019d8ab2452b3617"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 1f445474cd1b902b2e7292a0d24e58f020fd51e7 Mon Sep 17 00:00:00 2001\nFrom: Alex Buynytskyy <alexbuy@google.com>\nDate: Thu, 2 Nov 2023 15:15:48 -0700\nSubject: [PATCH] Validate package names passed to the installer.\n\nBug: 308989388\nTest: atest android.content.pm.cts.PackageManagerTest\nChange-Id: I840c9c9af5752b3901d4719a13e7908faa43ab04\n---\n .../server/pm/PackageInstallerService.java    | 29 +++++++++++++++----\n 1 file changed, 24 insertions(+), 5 deletions(-)\n\ndiff --git a/services/core/java/com/android/server/pm/PackageInstallerService.java b/services/core/java/com/android/server/pm/PackageInstallerService.java\nindex 305e3536ad25..a4d8632ac077 100644\n--- a/services/core/java/com/android/server/pm/PackageInstallerService.java\n+++ b/services/core/java/com/android/server/pm/PackageInstallerService.java\n@@ -58,6 +58,7 @@ import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n import android.content.pm.ParceledListSlice;\n import android.content.pm.VersionedPackage;\n+import android.content.pm.parsing.FrameworkParsingPackageUtils;\n import android.graphics.Bitmap;\n import android.net.Uri;\n import android.os.Binder;\n@@ -666,17 +667,22 @@ public class PackageInstallerService extends IPackageInstaller.Stub implements\n \n         // App package name and label length is restricted so that really long strings aren't\n         // written to disk.\n-        if (params.appPackageName != null\n-                && params.appPackageName.length() > SessionParams.MAX_PACKAGE_NAME_LENGTH) {\n+        if (params.appPackageName != null && !isValidPackageName(params.appPackageName)) {\n             params.appPackageName = null;\n         }\n \n         params.appLabel = TextUtils.trimToSize(params.appLabel,\n                 PackageItemInfo.MAX_SAFE_LABEL_LENGTH);\n \n-        String requestedInstallerPackageName = (params.installerPackageName != null\n-                && params.installerPackageName.length() < SessionParams.MAX_PACKAGE_NAME_LENGTH)\n-                ? params.installerPackageName : installerPackageName;\n+        // Validate installer package name.\n+        if (params.installerPackageName != null && !isValidPackageName(\n+                params.installerPackageName)) {\n+            params.installerPackageName = null;\n+        }\n+\n+        var requestedInstallerPackageName =\n+                params.installerPackageName != null ? params.installerPackageName\n+                        : installerPackageName;\n \n         if (PackageManagerServiceUtils.isRootOrShell(callingUid)\n                 || PackageInstallerSession.isSystemDataLoaderInstallation(params)\n@@ -1105,6 +1111,19 @@ public class PackageInstallerService extends IPackageInstaller.Stub implements\n         return Integer.parseInt(sessionId);\n     }\n \n+    private static boolean isValidPackageName(@NonNull String packageName) {\n+        if (packageName.length() > SessionParams.MAX_PACKAGE_NAME_LENGTH) {\n+            return false;\n+        }\n+        // \"android\" is a valid package name\n+        var errorMessage = FrameworkParsingPackageUtils.validateName(\n+                packageName, /* requireSeparator= */ false, /* requireFilename */ true);\n+        if (errorMessage != null) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n     private File getTmpSessionDir(String volumeUuid) {\n         return Environment.getDataAppDirectory(volumeUuid);\n     }\n-- \n2.39.5 (Apple Git-154)\n\nFrom c32cfc60ccf531470f6125b6019d8ab2452b3617 Mon Sep 17 00:00:00 2001\nFrom: Sumedh Sen <sumedhsen@google.com>\nDate: Wed, 17 Jul 2024 17:42:43 +0000\nSubject: [PATCH] Check whether installerPackageName contains only valid\n characters\n\nBug: 341256391\nBug: 307532206\nTest: sts-tradefed run sts-dynamic-develop -m CtsSecurityTestCases -t android.security.cts.CVE_2024_0044\n\nChange-Id: I74a172c617d6f5b13f0708092156b657b73b5891\n---\n .../com/android/server/pm/PackageInstallerService.java   | 9 +++++++--\n 1 file changed, 7 insertions(+), 2 deletions(-)\n\ndiff --git a/services/core/java/com/android/server/pm/PackageInstallerService.java b/services/core/java/com/android/server/pm/PackageInstallerService.java\nindex b99e66f68038..d331f31fc545 100644\n--- a/services/core/java/com/android/server/pm/PackageInstallerService.java\n+++ b/services/core/java/com/android/server/pm/PackageInstallerService.java\n@@ -673,13 +673,18 @@ public class PackageInstallerService extends IPackageInstaller.Stub implements\n         params.appLabel = TextUtils.trimToSize(params.appLabel,\n                 PackageItemInfo.MAX_SAFE_LABEL_LENGTH);\n \n-        // Validate installer package name.\n+        // Validate requested installer package name.\n         if (params.installerPackageName != null && !isValidPackageName(\n                 params.installerPackageName)) {\n             params.installerPackageName = null;\n         }\n \n-        var requestedInstallerPackageName =\n+        // Validate installer package name.\n+        if (installerPackageName != null && !isValidPackageName(installerPackageName)) {\n+            installerPackageName = null;\n+        }\n+\n+        String requestedInstallerPackageName =\n                 params.installerPackageName != null ? params.installerPackageName\n                         : installerPackageName;\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 1225,
                        "general": {
                            "word_based": 488,
                            "char_based": 1317
                        },
                        "gemini": 1596
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "a7e48c8d7e00962d335b0076266a5df98d41a21c",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit a7e48c8d7e00962d335b0076266a5df98d41a21c\nAuthor: Alex Buynytskyy <alexbuy@google.com>\nDate:   Thu Nov 2 15:15:48 2023 -0700\n\n    Validate package names passed to the installer.\n    \n    Bug: 308989388\n    Bug: 307532206\n    Test: atest android.content.pm.cts.PackageManagerTest\n    Change-Id: I840c9c9af5752b3901d4719a13e7908faa43ab04\n    Merged-In: I840c9c9af5752b3901d4719a13e7908faa43ab04\n    (cherry picked from commit 1f445474cd1b902b2e7292a0d24e58f020fd51e7)\n\ndiff --git a/services/core/java/com/android/server/pm/PackageInstallerService.java b/services/core/java/com/android/server/pm/PackageInstallerService.java\nindex 2ca3e8f1bc1b..02515cfdc16a 100644\n--- a/services/core/java/com/android/server/pm/PackageInstallerService.java\n+++ b/services/core/java/com/android/server/pm/PackageInstallerService.java\n@@ -47,6 +47,7 @@ import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n import android.content.pm.ParceledListSlice;\n import android.content.pm.VersionedPackage;\n+import android.content.pm.parsing.ParsingPackageUtils;\n import android.graphics.Bitmap;\n import android.net.Uri;\n import android.os.Binder;\n@@ -601,17 +602,22 @@ public class PackageInstallerService extends IPackageInstaller.Stub implements\n \n         // App package name and label length is restricted so that really long strings aren't\n         // written to disk.\n-        if (params.appPackageName != null\n-                && params.appPackageName.length() > SessionParams.MAX_PACKAGE_NAME_LENGTH) {\n+        if (params.appPackageName != null && !isValidPackageName(params.appPackageName)) {\n             params.appPackageName = null;\n         }\n \n         params.appLabel = TextUtils.trimToSize(params.appLabel,\n                 PackageItemInfo.MAX_SAFE_LABEL_LENGTH);\n \n-        String requestedInstallerPackageName = (params.installerPackageName != null\n-                && params.installerPackageName.length() < SessionParams.MAX_PACKAGE_NAME_LENGTH)\n-                ? params.installerPackageName : installerPackageName;\n+        // Validate installer package name.\n+        if (params.installerPackageName != null && !isValidPackageName(\n+                params.installerPackageName)) {\n+            params.installerPackageName = null;\n+        }\n+\n+        String requestedInstallerPackageName =\n+                params.installerPackageName != null ? params.installerPackageName\n+                        : installerPackageName;\n \n         if ((callingUid == Process.SHELL_UID) || (callingUid == Process.ROOT_UID)) {\n             params.installFlags |= PackageManager.INSTALL_FROM_ADB;\n@@ -935,6 +941,19 @@ public class PackageInstallerService extends IPackageInstaller.Stub implements\n         throw new IllegalStateException(\"Failed to allocate session ID\");\n     }\n \n+    private static boolean isValidPackageName(@NonNull String packageName) {\n+        if (packageName.length() > SessionParams.MAX_PACKAGE_NAME_LENGTH) {\n+            return false;\n+        }\n+        // \"android\" is a valid package name\n+        String errorMessage = ParsingPackageUtils.validateName(\n+                packageName, /* requireSeparator= */ false, /* requireFilename */ true);\n+        if (errorMessage != null) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n     private File getTmpSessionDir(String volumeUuid) {\n         return Environment.getDataAppDirectory(volumeUuid);\n     }\n",
                            "downstream_patch_tokens": {
                                "openai": 789,
                                "general": {
                                    "word_based": 300,
                                    "char_based": 855
                                },
                                "gemini": 1022
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "d76643a89ae9a2b58a4151cd92c1f94f69cb60fa",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit d76643a89ae9a2b58a4151cd92c1f94f69cb60fa\nAuthor: Alex Buynytskyy <alexbuy@google.com>\nDate:   Thu Nov 2 15:15:48 2023 -0700\n\n    Validate package names passed to the installer.\n    \n    Bug: 308989388\n    Bug: 307532206\n    Test: atest android.content.pm.cts.PackageManagerTest\n    Change-Id: I840c9c9af5752b3901d4719a13e7908faa43ab04\n    Merged-In: I840c9c9af5752b3901d4719a13e7908faa43ab04\n    (cherry picked from commit 1f445474cd1b902b2e7292a0d24e58f020fd51e7)\n\ndiff --git a/services/core/java/com/android/server/pm/PackageInstallerService.java b/services/core/java/com/android/server/pm/PackageInstallerService.java\nindex 2ca3e8f1bc1b..02515cfdc16a 100644\n--- a/services/core/java/com/android/server/pm/PackageInstallerService.java\n+++ b/services/core/java/com/android/server/pm/PackageInstallerService.java\n@@ -47,6 +47,7 @@ import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n import android.content.pm.ParceledListSlice;\n import android.content.pm.VersionedPackage;\n+import android.content.pm.parsing.ParsingPackageUtils;\n import android.graphics.Bitmap;\n import android.net.Uri;\n import android.os.Binder;\n@@ -601,17 +602,22 @@ public class PackageInstallerService extends IPackageInstaller.Stub implements\n \n         // App package name and label length is restricted so that really long strings aren't\n         // written to disk.\n-        if (params.appPackageName != null\n-                && params.appPackageName.length() > SessionParams.MAX_PACKAGE_NAME_LENGTH) {\n+        if (params.appPackageName != null && !isValidPackageName(params.appPackageName)) {\n             params.appPackageName = null;\n         }\n \n         params.appLabel = TextUtils.trimToSize(params.appLabel,\n                 PackageItemInfo.MAX_SAFE_LABEL_LENGTH);\n \n-        String requestedInstallerPackageName = (params.installerPackageName != null\n-                && params.installerPackageName.length() < SessionParams.MAX_PACKAGE_NAME_LENGTH)\n-                ? params.installerPackageName : installerPackageName;\n+        // Validate installer package name.\n+        if (params.installerPackageName != null && !isValidPackageName(\n+                params.installerPackageName)) {\n+            params.installerPackageName = null;\n+        }\n+\n+        String requestedInstallerPackageName =\n+                params.installerPackageName != null ? params.installerPackageName\n+                        : installerPackageName;\n \n         if ((callingUid == Process.SHELL_UID) || (callingUid == Process.ROOT_UID)) {\n             params.installFlags |= PackageManager.INSTALL_FROM_ADB;\n@@ -935,6 +941,19 @@ public class PackageInstallerService extends IPackageInstaller.Stub implements\n         throw new IllegalStateException(\"Failed to allocate session ID\");\n     }\n \n+    private static boolean isValidPackageName(@NonNull String packageName) {\n+        if (packageName.length() > SessionParams.MAX_PACKAGE_NAME_LENGTH) {\n+            return false;\n+        }\n+        // \"android\" is a valid package name\n+        String errorMessage = ParsingPackageUtils.validateName(\n+                packageName, /* requireSeparator= */ false, /* requireFilename */ true);\n+        if (errorMessage != null) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n     private File getTmpSessionDir(String volumeUuid) {\n         return Environment.getDataAppDirectory(volumeUuid);\n     }\n",
                            "downstream_patch_tokens": {
                                "openai": 788,
                                "general": {
                                    "word_based": 300,
                                    "char_based": 855
                                },
                                "gemini": 1019
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "d42af9a50dcb1b0cf2035c4da7e46c960bcfbc37",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit d42af9a50dcb1b0cf2035c4da7e46c960bcfbc37\nAuthor: Alex Buynytskyy <alexbuy@google.com>\nDate:   Thu Nov 2 15:15:48 2023 -0700\n\n    Validate package names passed to the installer.\n    \n    Bug: 308989388\n    Bug: 307532206\n    Test: atest android.content.pm.cts.PackageManagerTest\n    Change-Id: I840c9c9af5752b3901d4719a13e7908faa43ab04\n    Merged-In: I840c9c9af5752b3901d4719a13e7908faa43ab04\n    (cherry picked from commit 1f445474cd1b902b2e7292a0d24e58f020fd51e7)\n\ndiff --git a/services/core/java/com/android/server/pm/PackageInstallerService.java b/services/core/java/com/android/server/pm/PackageInstallerService.java\nindex 02cf4336b277..c5b82a4605d5 100644\n--- a/services/core/java/com/android/server/pm/PackageInstallerService.java\n+++ b/services/core/java/com/android/server/pm/PackageInstallerService.java\n@@ -50,6 +50,7 @@ import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n import android.content.pm.ParceledListSlice;\n import android.content.pm.VersionedPackage;\n+import android.content.pm.parsing.FrameworkParsingPackageUtils;\n import android.graphics.Bitmap;\n import android.net.Uri;\n import android.os.Binder;\n@@ -632,17 +633,22 @@ public class PackageInstallerService extends IPackageInstaller.Stub implements\n \n         // App package name and label length is restricted so that really long strings aren't\n         // written to disk.\n-        if (params.appPackageName != null\n-                && params.appPackageName.length() > SessionParams.MAX_PACKAGE_NAME_LENGTH) {\n+        if (params.appPackageName != null && !isValidPackageName(params.appPackageName)) {\n             params.appPackageName = null;\n         }\n \n         params.appLabel = TextUtils.trimToSize(params.appLabel,\n                 PackageItemInfo.MAX_SAFE_LABEL_LENGTH);\n \n-        String requestedInstallerPackageName = (params.installerPackageName != null\n-                && params.installerPackageName.length() < SessionParams.MAX_PACKAGE_NAME_LENGTH)\n-                ? params.installerPackageName : installerPackageName;\n+        // Validate installer package name.\n+        if (params.installerPackageName != null && !isValidPackageName(\n+                params.installerPackageName)) {\n+            params.installerPackageName = null;\n+        }\n+\n+        var requestedInstallerPackageName =\n+                params.installerPackageName != null ? params.installerPackageName\n+                        : installerPackageName;\n \n         if ((callingUid == Process.SHELL_UID) || (callingUid == Process.ROOT_UID)\n                 || PackageInstallerSession.isSystemDataLoaderInstallation(params)) {\n@@ -999,6 +1005,19 @@ public class PackageInstallerService extends IPackageInstaller.Stub implements\n         return Integer.parseInt(sessionId);\n     }\n \n+    private static boolean isValidPackageName(@NonNull String packageName) {\n+        if (packageName.length() > SessionParams.MAX_PACKAGE_NAME_LENGTH) {\n+            return false;\n+        }\n+        // \"android\" is a valid package name\n+        var errorMessage = FrameworkParsingPackageUtils.validateName(\n+                packageName, /* requireSeparator= */ false, /* requireFilename */ true);\n+        if (errorMessage != null) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n     private File getTmpSessionDir(String volumeUuid) {\n         return Environment.getDataAppDirectory(volumeUuid);\n     }\n",
                            "downstream_patch_tokens": {
                                "openai": 786,
                                "general": {
                                    "word_based": 295,
                                    "char_based": 854
                                },
                                "gemini": 1018
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "8705e13d7c0f9fd1d73ea66619dc28e966d98666",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 8705e13d7c0f9fd1d73ea66619dc28e966d98666\nAuthor: Alex Buynytskyy <alexbuy@google.com>\nDate:   Thu Nov 2 15:15:48 2023 -0700\n\n    Validate package names passed to the installer.\n    \n    Bug: 308989388\n    Bug: 307532206\n    Test: atest android.content.pm.cts.PackageManagerTest\n    Change-Id: I840c9c9af5752b3901d4719a13e7908faa43ab04\n    Merged-In: I840c9c9af5752b3901d4719a13e7908faa43ab04\n    (cherry picked from commit 1f445474cd1b902b2e7292a0d24e58f020fd51e7)\n\ndiff --git a/services/core/java/com/android/server/pm/PackageInstallerService.java b/services/core/java/com/android/server/pm/PackageInstallerService.java\nindex a9115371413c..b99e66f68038 100644\n--- a/services/core/java/com/android/server/pm/PackageInstallerService.java\n+++ b/services/core/java/com/android/server/pm/PackageInstallerService.java\n@@ -55,6 +55,7 @@ import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n import android.content.pm.ParceledListSlice;\n import android.content.pm.VersionedPackage;\n+import android.content.pm.parsing.FrameworkParsingPackageUtils;\n import android.graphics.Bitmap;\n import android.net.Uri;\n import android.os.Binder;\n@@ -665,17 +666,22 @@ public class PackageInstallerService extends IPackageInstaller.Stub implements\n \n         // App package name and label length is restricted so that really long strings aren't\n         // written to disk.\n-        if (params.appPackageName != null\n-                && params.appPackageName.length() > SessionParams.MAX_PACKAGE_NAME_LENGTH) {\n+        if (params.appPackageName != null && !isValidPackageName(params.appPackageName)) {\n             params.appPackageName = null;\n         }\n \n         params.appLabel = TextUtils.trimToSize(params.appLabel,\n                 PackageItemInfo.MAX_SAFE_LABEL_LENGTH);\n \n-        String requestedInstallerPackageName = (params.installerPackageName != null\n-                && params.installerPackageName.length() < SessionParams.MAX_PACKAGE_NAME_LENGTH)\n-                ? params.installerPackageName : installerPackageName;\n+        // Validate installer package name.\n+        if (params.installerPackageName != null && !isValidPackageName(\n+                params.installerPackageName)) {\n+            params.installerPackageName = null;\n+        }\n+\n+        var requestedInstallerPackageName =\n+                params.installerPackageName != null ? params.installerPackageName\n+                        : installerPackageName;\n \n         if (PackageManagerServiceUtils.isRootOrShell(callingUid)\n                 || PackageInstallerSession.isSystemDataLoaderInstallation(params)\n@@ -1085,6 +1091,19 @@ public class PackageInstallerService extends IPackageInstaller.Stub implements\n         return Integer.parseInt(sessionId);\n     }\n \n+    private static boolean isValidPackageName(@NonNull String packageName) {\n+        if (packageName.length() > SessionParams.MAX_PACKAGE_NAME_LENGTH) {\n+            return false;\n+        }\n+        // \"android\" is a valid package name\n+        var errorMessage = FrameworkParsingPackageUtils.validateName(\n+                packageName, /* requireSeparator= */ false, /* requireFilename */ true);\n+        if (errorMessage != null) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n     private File getTmpSessionDir(String volumeUuid) {\n         return Environment.getDataAppDirectory(volumeUuid);\n     }\n",
                            "downstream_patch_tokens": {
                                "openai": 775,
                                "general": {
                                    "word_based": 292,
                                    "char_based": 849
                                },
                                "gemini": 1014
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-327748846",
            "aliases": [
                "A-327748846",
                "CVE-2024-40677"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-327748846",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "419a6a907902a12a0f565c808fa70092004d6686"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 419a6a907902a12a0f565c808fa70092004d6686 Mon Sep 17 00:00:00 2001\nFrom: Yiling Chuang <emilychuang@google.com>\nDate: Mon, 8 Jul 2024 03:09:50 +0000\nSubject: [PATCH] FRP bypass defense in App battery usage page\n\nBefore the setup flow completion, don't allow the app info page in App battery usage to be launched.\n\nBug: 327748846\nTest: atest SettingsRoboTests + manual test\n- factory reset + launch app battery usage app info via ADB during Setup -> verify app closes\nFlag : EXEMPT bugfix\n\nChange-Id: I486820ca2afecc02729a56a3c531fb931c1907d0\n---\n .../android/settings/fuelgauge/AdvancedPowerUsageDetail.java | 5 +++++\n .../settings/fuelgauge/AdvancedPowerUsageDetailTest.java     | 5 +++++\n 2 files changed, 10 insertions(+)\n\ndiff --git a/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetail.java b/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetail.java\nindex 005c0730343..7bbb06a2d30 100644\n--- a/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetail.java\n+++ b/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetail.java\n@@ -268,6 +268,11 @@ public class AdvancedPowerUsageDetail extends DashboardFragment\n         mLogStringBuilder = new StringBuilder(\"onResume mode = \").append(mOptimizationMode);\n     }\n \n+    @Override\n+    protected boolean shouldSkipForInitialSUW() {\n+        return true;\n+    }\n+\n     @Override\n     public void onPause() {\n         super.onPause();\ndiff --git a/tests/robotests/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetailTest.java b/tests/robotests/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetailTest.java\nindex 80739e9d47a..1bc00a1fdff 100644\n--- a/tests/robotests/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetailTest.java\n+++ b/tests/robotests/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetailTest.java\n@@ -441,4 +441,9 @@ public class AdvancedPowerUsageDetailTest {\n         TimeUnit.SECONDS.sleep(1);\n         verifyNoInteractions(mMetricsFeatureProvider);\n     }\n+\n+    @Test\n+    public void shouldSkipForInitialSUW_returnTrue() {\n+        assertThat(mFragment.shouldSkipForInitialSUW()).isTrue();\n+    }\n }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 602,
                        "general": {
                            "word_based": 236,
                            "char_based": 538
                        },
                        "gemini": 747
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "0c097d5c0d32c59c3ea7c802fe964acac7715485",
                            "repo_path": "android_repos/Settings",
                            "result": "success",
                            "downstream_patch_content": "commit 0c097d5c0d32c59c3ea7c802fe964acac7715485\nAuthor: Yiling Chuang <emilychuang@google.com>\nDate:   Mon Jul 8 03:09:50 2024 +0000\n\n    RESTRICT AUTOMERGE FRP bypass defense in App battery usage page\n    \n    Before the setup flow completion, don't allow the app info page in App battery usage to be launched.\n    \n    Bug: 327748846\n    Test: atest SettingsRoboTests + manual test\n    - factory reset + launch app battery usage app info via ADB during Setup -> verify app closes\n    Flag : EXEMPT bugfix\n    \n    Change-Id: I486820ca2afecc02729a56a3c531fb931c1907d0\n    Merged-In: I486820ca2afecc02729a56a3c531fb931c1907d0\n    (cherry picked from commit 419a6a907902a12a0f565c808fa70092004d6686)\n\ndiff --git a/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetail.java b/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetail.java\nindex 3319e1b1492..cea646365b6 100644\n--- a/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetail.java\n+++ b/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetail.java\n@@ -276,6 +276,11 @@ public class AdvancedPowerUsageDetail extends DashboardFragment implements\n         }\n     }\n \n+    @Override\n+    protected boolean shouldSkipForInitialSUW() {\n+        return true;\n+    }\n+\n     @VisibleForTesting\n     void initHeader() {\n         final View appSnippet = mHeaderPreference.findViewById(R.id.entity_header);\ndiff --git a/tests/robotests/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetailTest.java b/tests/robotests/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetailTest.java\nindex b50e0832ec0..d435117a42d 100644\n--- a/tests/robotests/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetailTest.java\n+++ b/tests/robotests/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetailTest.java\n@@ -780,4 +780,9 @@ public class AdvancedPowerUsageDetailTest {\n                     new Pair(ConvertUtils.METRIC_KEY_BATTERY_USAGE, \"app label\")\n                 });\n     }\n+\n+    @Test\n+    public void shouldSkipForInitialSUW_returnTrue() {\n+        assertThat(mFragment.shouldSkipForInitialSUW()).isTrue();\n+    }\n }\n",
                            "downstream_patch_tokens": {
                                "openai": 589,
                                "general": {
                                    "word_based": 214,
                                    "char_based": 524
                                },
                                "gemini": 758
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "c9d2588c69ce8df208324634d7cea7db08478bf5",
                            "repo_path": "android_repos/Settings",
                            "result": "success",
                            "downstream_patch_content": "commit c9d2588c69ce8df208324634d7cea7db08478bf5\nAuthor: Yiling Chuang <emilychuang@google.com>\nDate:   Mon Jul 8 03:09:50 2024 +0000\n\n    RESTRICT AUTOMERGE FRP bypass defense in App battery usage page\n    \n    Before the setup flow completion, don't allow the app info page in App battery usage to be launched.\n    \n    Bug: 327748846\n    Test: atest SettingsRoboTests + manual test\n    - factory reset + launch app battery usage app info via ADB during Setup -> verify app closes\n    Flag : EXEMPT bugfix\n    \n    Change-Id: I486820ca2afecc02729a56a3c531fb931c1907d0\n    Merged-In: I486820ca2afecc02729a56a3c531fb931c1907d0\n    (cherry picked from commit 419a6a907902a12a0f565c808fa70092004d6686)\n\ndiff --git a/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetail.java b/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetail.java\nindex 3741bfe8045..d89286d4e40 100644\n--- a/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetail.java\n+++ b/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetail.java\n@@ -283,6 +283,11 @@ public class AdvancedPowerUsageDetail extends DashboardFragment implements\n         }\n     }\n \n+    @Override\n+    protected boolean shouldSkipForInitialSUW() {\n+        return true;\n+    }\n+\n     @Override\n     public void onPause() {\n         super.onPause();\ndiff --git a/tests/robotests/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetailTest.java b/tests/robotests/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetailTest.java\nindex 0a48cd1b12f..212ac21cd08 100644\n--- a/tests/robotests/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetailTest.java\n+++ b/tests/robotests/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetailTest.java\n@@ -859,4 +859,9 @@ public class AdvancedPowerUsageDetailTest {\n \n         verifyZeroInteractions(mBackupManager);\n     }\n+\n+    @Test\n+    public void shouldSkipForInitialSUW_returnTrue() {\n+        assertThat(mFragment.shouldSkipForInitialSUW()).isTrue();\n+    }\n }\n",
                            "downstream_patch_tokens": {
                                "openai": 566,
                                "general": {
                                    "word_based": 205,
                                    "char_based": 495
                                },
                                "gemini": 727
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "23b88e07244bd49cb50be989110ccd0594e46fb4",
                            "repo_path": "android_repos/Settings",
                            "result": "success",
                            "downstream_patch_content": "commit 23b88e07244bd49cb50be989110ccd0594e46fb4\nAuthor: Yiling Chuang <emilychuang@google.com>\nDate:   Mon Jul 8 03:09:50 2024 +0000\n\n    RESTRICT AUTOMERGE FRP bypass defense in App battery usage page\n    \n    Before the setup flow completion, don't allow the app info page in App battery usage to be launched.\n    \n    Bug: 327748846\n    Test: atest SettingsRoboTests + manual test\n    - factory reset + launch app battery usage app info via ADB during Setup -> verify app closes\n    Flag : EXEMPT bugfix\n    \n    Change-Id: I486820ca2afecc02729a56a3c531fb931c1907d0\n    Merged-In: I486820ca2afecc02729a56a3c531fb931c1907d0\n    (cherry picked from commit 419a6a907902a12a0f565c808fa70092004d6686)\n\ndiff --git a/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetail.java b/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetail.java\nindex 48825c8204a..21ab2a7bc45 100644\n--- a/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetail.java\n+++ b/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetail.java\n@@ -284,6 +284,11 @@ public class AdvancedPowerUsageDetail extends DashboardFragment implements\n         }\n     }\n \n+    @Override\n+    protected boolean shouldSkipForInitialSUW() {\n+        return true;\n+    }\n+\n     @Override\n     public void onPause() {\n         super.onPause();\ndiff --git a/tests/robotests/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetailTest.java b/tests/robotests/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetailTest.java\nindex 39f2ce5f314..e43a0bbf385 100644\n--- a/tests/robotests/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetailTest.java\n+++ b/tests/robotests/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetailTest.java\n@@ -893,4 +893,9 @@ public class AdvancedPowerUsageDetailTest {\n \n         verifyNoInteractions(mBackupManager);\n     }\n+\n+    @Test\n+    public void shouldSkipForInitialSUW_returnTrue() {\n+        assertThat(mFragment.shouldSkipForInitialSUW()).isTrue();\n+    }\n }\n",
                            "downstream_patch_tokens": {
                                "openai": 566,
                                "general": {
                                    "word_based": 205,
                                    "char_based": 494
                                },
                                "gemini": 728
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "2659f8416cb895c849129699e5f676bc2a431c33",
                            "repo_path": "android_repos/Settings",
                            "result": "success",
                            "downstream_patch_content": "commit 2659f8416cb895c849129699e5f676bc2a431c33\nAuthor: Yiling Chuang <emilychuang@google.com>\nDate:   Mon Jul 8 03:09:50 2024 +0000\n\n    RESTRICT AUTOMERGE FRP bypass defense in App battery usage page\n    \n    Before the setup flow completion, don't allow the app info page in App battery usage to be launched.\n    \n    Bug: 327748846\n    Test: atest SettingsRoboTests + manual test\n    - factory reset + launch app battery usage app info via ADB during Setup -> verify app closes\n    Flag : EXEMPT bugfix\n    \n    Change-Id: I486820ca2afecc02729a56a3c531fb931c1907d0\n    Merged-In: I486820ca2afecc02729a56a3c531fb931c1907d0\n    (cherry picked from commit 419a6a907902a12a0f565c808fa70092004d6686)\n\ndiff --git a/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetail.java b/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetail.java\nindex 79e01940ecd..5daeb9ea86e 100644\n--- a/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetail.java\n+++ b/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetail.java\n@@ -279,6 +279,11 @@ public class AdvancedPowerUsageDetail extends DashboardFragment implements\n         mLogStringBuilder = new StringBuilder(\"onResume mode = \").append(mOptimizationMode);\n     }\n \n+    @Override\n+    protected boolean shouldSkipForInitialSUW() {\n+        return true;\n+    }\n+\n     @Override\n     public void onPause() {\n         super.onPause();\ndiff --git a/tests/robotests/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetailTest.java b/tests/robotests/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetailTest.java\nindex 5e9fb738672..0a833880d8e 100644\n--- a/tests/robotests/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetailTest.java\n+++ b/tests/robotests/src/com/android/settings/fuelgauge/AdvancedPowerUsageDetailTest.java\n@@ -817,4 +817,9 @@ public class AdvancedPowerUsageDetailTest {\n \n         verify(mBackupManager).dataChanged();\n     }\n+\n+    @Test\n+    public void shouldSkipForInitialSUW_returnTrue() {\n+        assertThat(mFragment.shouldSkipForInitialSUW()).isTrue();\n+    }\n }\n",
                            "downstream_patch_tokens": {
                                "openai": 582,
                                "general": {
                                    "word_based": 213,
                                    "char_based": 515
                                },
                                "gemini": 747
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-318683640",
            "aliases": [
                "A-318683640",
                "CVE-2024-34741"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-318683640",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "c37bc9147086f497ac7b1595083836014f524d5f"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From c37bc9147086f497ac7b1595083836014f524d5f Mon Sep 17 00:00:00 2001\nFrom: Linus Tufvesson <lus@google.com>\nDate: Mon, 29 Apr 2024 16:32:15 +0200\nSubject: [PATCH] Hide SAW subwindows\n\n.. when top window is hidden through Window#setHideOverlayWindows\n\nBug: 333491197\nTest: atest CtsWindowManagerDeviceWindow:HideOverlayWindowsTest\nFlag: EXEMPT securityfix\nChange-Id: If19240f5aec2e048de80d75cbbdc00be47622d7f\n---\n services/core/java/com/android/server/wm/WindowState.java | 5 +++--\n 1 file changed, 3 insertions(+), 2 deletions(-)\n\ndiff --git a/services/core/java/com/android/server/wm/WindowState.java b/services/core/java/com/android/server/wm/WindowState.java\nindex 2fcee50e6f85..d3a8c5f35b67 100644\n--- a/services/core/java/com/android/server/wm/WindowState.java\n+++ b/services/core/java/com/android/server/wm/WindowState.java\n@@ -3092,12 +3092,13 @@ class WindowState extends WindowContainer<WindowState> implements WindowManagerP\n     }\n \n     void setForceHideNonSystemOverlayWindowIfNeeded(boolean forceHide) {\n+        final int baseType = getBaseType();\n         if (mSession.mCanAddInternalSystemWindow\n-                || (!isSystemAlertWindowType(mAttrs.type) && mAttrs.type != TYPE_TOAST)) {\n+                || (!isSystemAlertWindowType(baseType) && baseType != TYPE_TOAST)) {\n             return;\n         }\n \n-        if (mAttrs.type == TYPE_APPLICATION_OVERLAY && mAttrs.isSystemApplicationOverlay()\n+        if (baseType == TYPE_APPLICATION_OVERLAY && mAttrs.isSystemApplicationOverlay()\n                 && mSession.mCanCreateSystemApplicationOverlay) {\n             return;\n         }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 454,
                        "general": {
                            "word_based": 165,
                            "char_based": 408
                        },
                        "gemini": 588
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "89bc634cb534b8e0ffd798ac9f9f89ac1be0f785",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 89bc634cb534b8e0ffd798ac9f9f89ac1be0f785\nAuthor: Linus Tufvesson <lus@google.com>\nDate:   Mon Apr 29 16:32:15 2024 +0200\n\n    Hide SAW subwindows\n    \n    .. when top window is hidden through Window#setHideOverlayWindows\n    \n    Bug: 318683640\n    Test: atest CtsWindowManagerDeviceWindow:HideOverlayWindowsTest\n    Flag: EXEMPT securityfix\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:c37bc9147086f497ac7b1595083836014f524d5f)\n    Merged-In: If19240f5aec2e048de80d75cbbdc00be47622d7f\n    Change-Id: If19240f5aec2e048de80d75cbbdc00be47622d7f\n\ndiff --git a/services/core/java/com/android/server/wm/WindowState.java b/services/core/java/com/android/server/wm/WindowState.java\nindex 8c4f1040908b..bfc3239f7bc5 100644\n--- a/services/core/java/com/android/server/wm/WindowState.java\n+++ b/services/core/java/com/android/server/wm/WindowState.java\n@@ -3271,12 +3271,13 @@ class WindowState extends WindowContainer<WindowState> implements WindowManagerP\n     }\n \n     void setForceHideNonSystemOverlayWindowIfNeeded(boolean forceHide) {\n+        final int baseType = getBaseType();\n         if (mSession.mCanAddInternalSystemWindow\n-                || (!isSystemAlertWindowType(mAttrs.type) && mAttrs.type != TYPE_TOAST)) {\n+                || (!isSystemAlertWindowType(baseType) && baseType != TYPE_TOAST)) {\n             return;\n         }\n \n-        if (mAttrs.type == TYPE_APPLICATION_OVERLAY && mAttrs.isSystemApplicationOverlay()\n+        if (baseType == TYPE_APPLICATION_OVERLAY && mAttrs.isSystemApplicationOverlay()\n                 && mSession.mCanCreateSystemApplicationOverlay) {\n             return;\n         }\n",
                            "downstream_patch_tokens": {
                                "openai": 467,
                                "general": {
                                    "word_based": 148,
                                    "char_based": 416
                                },
                                "gemini": 615
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "5a2a9f4991d0c4d28d06e4a9ee73d55f22c14fec",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 5a2a9f4991d0c4d28d06e4a9ee73d55f22c14fec\nAuthor: Linus Tufvesson <lus@google.com>\nDate:   Mon Apr 29 16:32:15 2024 +0200\n\n    Hide SAW subwindows\n    \n    .. when top window is hidden through Window#setHideOverlayWindows\n    \n    Bug: 318683640\n    Test: atest CtsWindowManagerDeviceWindow:HideOverlayWindowsTest\n    Flag: EXEMPT securityfix\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:c37bc9147086f497ac7b1595083836014f524d5f)\n    Merged-In: If19240f5aec2e048de80d75cbbdc00be47622d7f\n    Change-Id: If19240f5aec2e048de80d75cbbdc00be47622d7f\n\ndiff --git a/services/core/java/com/android/server/wm/WindowState.java b/services/core/java/com/android/server/wm/WindowState.java\nindex a7fe57960df5..a4ba428143c9 100644\n--- a/services/core/java/com/android/server/wm/WindowState.java\n+++ b/services/core/java/com/android/server/wm/WindowState.java\n@@ -3348,12 +3348,13 @@ class WindowState extends WindowContainer<WindowState> implements WindowManagerP\n     }\n \n     void setForceHideNonSystemOverlayWindowIfNeeded(boolean forceHide) {\n+        final int baseType = getBaseType();\n         if (mSession.mCanAddInternalSystemWindow\n-                || (!isSystemAlertWindowType(mAttrs.type) && mAttrs.type != TYPE_TOAST)) {\n+                || (!isSystemAlertWindowType(baseType) && baseType != TYPE_TOAST)) {\n             return;\n         }\n \n-        if (mAttrs.type == TYPE_APPLICATION_OVERLAY && mAttrs.isSystemApplicationOverlay()\n+        if (baseType == TYPE_APPLICATION_OVERLAY && mAttrs.isSystemApplicationOverlay()\n                 && mSession.mCanCreateSystemApplicationOverlay) {\n             return;\n         }\n",
                            "downstream_patch_tokens": {
                                "openai": 470,
                                "general": {
                                    "word_based": 148,
                                    "char_based": 416
                                },
                                "gemini": 617
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "a9a7079b095abc07374cf287b5689a99ce250f47",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit a9a7079b095abc07374cf287b5689a99ce250f47\nAuthor: Linus Tufvesson <lus@google.com>\nDate:   Mon Apr 29 16:32:15 2024 +0200\n\n    Hide SAW subwindows\n    \n    .. when top window is hidden through Window#setHideOverlayWindows\n    \n    Bug: 318683640\n    Test: atest CtsWindowManagerDeviceWindow:HideOverlayWindowsTest\n    Flag: EXEMPT securityfix\n    Merged-In: If19240f5aec2e048de80d75cbbdc00be47622d7f\n    Change-Id: If19240f5aec2e048de80d75cbbdc00be47622d7f\n    (cherry picked from commit c37bc9147086f497ac7b1595083836014f524d5f)\n\ndiff --git a/services/core/java/com/android/server/wm/WindowState.java b/services/core/java/com/android/server/wm/WindowState.java\nindex 64bb38760342..56b597e7dccc 100644\n--- a/services/core/java/com/android/server/wm/WindowState.java\n+++ b/services/core/java/com/android/server/wm/WindowState.java\n@@ -3335,12 +3335,13 @@ class WindowState extends WindowContainer<WindowState> implements WindowManagerP\n     }\n \n     void setForceHideNonSystemOverlayWindowIfNeeded(boolean forceHide) {\n+        final int baseType = getBaseType();\n         if (mSession.mCanAddInternalSystemWindow\n-                || (!isSystemAlertWindowType(mAttrs.type) && mAttrs.type != TYPE_TOAST)) {\n+                || (!isSystemAlertWindowType(baseType) && baseType != TYPE_TOAST)) {\n             return;\n         }\n \n-        if (mAttrs.type == TYPE_APPLICATION_OVERLAY && mAttrs.isSystemApplicationOverlay()\n+        if (baseType == TYPE_APPLICATION_OVERLAY && mAttrs.isSystemApplicationOverlay()\n                 && mSession.mCanCreateSystemApplicationOverlay) {\n             return;\n         }\n",
                            "downstream_patch_tokens": {
                                "openai": 447,
                                "general": {
                                    "word_based": 141,
                                    "char_based": 402
                                },
                                "gemini": 598
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "55d02153259003b7552e7eef70b9e4f3f0dcd45c",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 55d02153259003b7552e7eef70b9e4f3f0dcd45c\nAuthor: Linus Tufvesson <lus@google.com>\nDate:   Mon Apr 29 16:32:15 2024 +0200\n\n    Hide SAW subwindows\n    \n    .. when top window is hidden through Window#setHideOverlayWindows\n    \n    Bug: 318683640\n    Test: atest CtsWindowManagerDeviceWindow:HideOverlayWindowsTest\n    Flag: EXEMPT securityfix\n    Merged-In: If19240f5aec2e048de80d75cbbdc00be47622d7f\n    Change-Id: If19240f5aec2e048de80d75cbbdc00be47622d7f\n    (cherry picked from commit c37bc9147086f497ac7b1595083836014f524d5f)\n\ndiff --git a/services/core/java/com/android/server/wm/WindowState.java b/services/core/java/com/android/server/wm/WindowState.java\nindex 8f1e96840fac..f93ddc58b250 100644\n--- a/services/core/java/com/android/server/wm/WindowState.java\n+++ b/services/core/java/com/android/server/wm/WindowState.java\n@@ -3121,12 +3121,13 @@ class WindowState extends WindowContainer<WindowState> implements WindowManagerP\n     }\n \n     void setForceHideNonSystemOverlayWindowIfNeeded(boolean forceHide) {\n+        final int baseType = getBaseType();\n         if (mSession.mCanAddInternalSystemWindow\n-                || (!isSystemAlertWindowType(mAttrs.type) && mAttrs.type != TYPE_TOAST)) {\n+                || (!isSystemAlertWindowType(baseType) && baseType != TYPE_TOAST)) {\n             return;\n         }\n \n-        if (mAttrs.type == TYPE_APPLICATION_OVERLAY && mAttrs.isSystemApplicationOverlay()\n+        if (baseType == TYPE_APPLICATION_OVERLAY && mAttrs.isSystemApplicationOverlay()\n                 && mSession.mCanCreateSystemApplicationOverlay) {\n             return;\n         }\n",
                            "downstream_patch_tokens": {
                                "openai": 455,
                                "general": {
                                    "word_based": 141,
                                    "char_based": 402
                                },
                                "gemini": 600
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-267231571",
            "aliases": [
                "A-267231571",
                "CVE-2023-21113"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-267231571",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "922e52bc3d2a6576cc3e45268dfc3ecd3550f45f"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 922e52bc3d2a6576cc3e45268dfc3ecd3550f45f Mon Sep 17 00:00:00 2001\nFrom: Austin Borger <borgera@google.com>\nDate: Thu, 9 Feb 2023 16:00:02 -0800\nSubject: [PATCH] Fix vulnerability in AttributionSource due to incorrect\n Binder call\n\nAttributionSource uses Binder.getCallingUid to verify the UID of the\ncaller from another process. However, getCallingUid does not always\nbehave as expected. If the AttributionSource is unparceled outside a\ntransaction thread, which is quite possible, getCallingUid will return\nthe UID of the current process instead. If this is a system process,\nthe UID check gets bypassed entirely, meaning any uid can be provided.\n\nThis patch fixes the vulnerability by enforcing that the AttributionSource\nbe unparceled in a transaction only. If it is not, a SecurityException\nwill be thrown.\n\nBug: 267231571\nTest: Smoke test on cuttlefish.\nTest: v2/android-virtual-infra/test_mapping/presubmit-avd\nChange-Id: Ic301a8518b8e57e1c9a2c9f2f845e51dca145257\n---\n core/java/android/content/AttributionSource.java | 5 +++++\n 1 file changed, 5 insertions(+)\n\ndiff --git a/core/java/android/content/AttributionSource.java b/core/java/android/content/AttributionSource.java\nindex e981581c269a..2b400c1fba43 100644\n--- a/core/java/android/content/AttributionSource.java\n+++ b/core/java/android/content/AttributionSource.java\n@@ -155,6 +155,11 @@ public final class AttributionSource implements Parcelable {\n     AttributionSource(@NonNull Parcel in) {\n         this(AttributionSourceState.CREATOR.createFromParcel(in));\n \n+        if (!Binder.isDirectlyHandlingTransaction()) {\n+            throw new SecurityException(\"AttributionSource should be unparceled during a binder \"\n+                    + \"transaction for proper verification.\");\n+        }\n+\n         // Since we just unpacked this object as part of it transiting a Binder\n         // call, this is the perfect time to enforce that its UID and PID can be trusted\n         enforceCallingUidAndPid();\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 520,
                        "general": {
                            "word_based": 259,
                            "char_based": 500
                        },
                        "gemini": 622
                    },
                    "total_downstream_versions_tested": 5,
                    "successful_patches": 3,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "694ba52858703c3959e6811edb9b3df32aeca702",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 694ba52858703c3959e6811edb9b3df32aeca702\nAuthor: Austin Borger <borgera@google.com>\nDate:   Wed May 24 01:23:42 2023 +0000\n\n    Fix vulnerability in AttributionSource due to incorrect Binder call\n    \n    AttributionSource uses Binder.getCallingUid to verify the UID of the\n    caller from another process. However, getCallingUid does not always\n    behave as expected. If the AttributionSource is unparceled outside a\n    transaction thread, which is quite possible, getCallingUid will return\n    the UID of the current process instead. If this is a system process,\n    the UID check gets bypassed entirely, meaning any uid can be provided.\n    \n    This patch fixes the vulnerability by enforcing that the AttributionSource\n    be unparceled in a transaction only. If it is not, a SecurityException\n    will be thrown.\n    \n    Bug: 267231571\n    Test: Smoke test on cuttlefish.\n    Test: v2/android-virtual-infra/test_mapping/presubmit-avd\n    Change-Id: Iee28c3901ee1041e00dca444c37c90d619e19b26\n    Merged-In: I3f228064fbd62e1c907f1ebe870cb61102f788f0\n    Merged-In: Ic301a8518b8e57e1c9a2c9f2f845e51dca145257\n\ndiff --git a/core/java/android/content/AttributionSource.java b/core/java/android/content/AttributionSource.java\nindex 2f61fee88e9f..ec56f9a7cf0c 100644\n--- a/core/java/android/content/AttributionSource.java\n+++ b/core/java/android/content/AttributionSource.java\n@@ -30,6 +30,7 @@ import android.os.Parcelable;\n import android.os.Process;\n import android.permission.PermissionManager;\n import android.util.ArraySet;\n+import android.util.Log;\n \n import com.android.internal.annotations.Immutable;\n \n@@ -86,6 +87,8 @@ import java.util.Set;\n  */\n @Immutable\n public final class AttributionSource implements Parcelable {\n+    private static final String TAG = \"AttributionSource\";\n+\n     private static final String DESCRIPTOR = \"android.content.AttributionSource\";\n \n     private static final Binder sDefaultToken = new Binder(DESCRIPTOR);\n@@ -153,9 +156,20 @@ public final class AttributionSource implements Parcelable {\n     AttributionSource(@NonNull Parcel in) {\n         this(AttributionSourceState.CREATOR.createFromParcel(in));\n \n-        // Since we just unpacked this object as part of it transiting a Binder\n-        // call, this is the perfect time to enforce that its UID and PID can be trusted\n-        enforceCallingUidAndPid();\n+        if (!Binder.isHandlingTransaction()) {\n+            Log.e(TAG, \"Unable to verify calling UID #\" + mAttributionSourceState.uid + \" PID #\"\n+                    + mAttributionSourceState.pid + \" when not handling Binder transaction; \"\n+                    + \"clearing.\");\n+            mAttributionSourceState.pid = -1;\n+            mAttributionSourceState.uid = -1;\n+            mAttributionSourceState.packageName = null;\n+            mAttributionSourceState.attributionTag = null;\n+            mAttributionSourceState.next = null;\n+        } else {\n+            // Since we just unpacked this object as part of it transiting a Binder\n+            // call, this is the perfect time to enforce that its UID and PID can be trusted\n+            enforceCallingUidAndPid();\n+        }\n     }\n \n     /** @hide */\n",
                            "downstream_patch_tokens": {
                                "openai": 798,
                                "general": {
                                    "word_based": 357,
                                    "char_based": 794
                                },
                                "gemini": 959
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "694ba52858703c3959e6811edb9b3df32aeca702",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 694ba52858703c3959e6811edb9b3df32aeca702\nAuthor: Austin Borger <borgera@google.com>\nDate:   Wed May 24 01:23:42 2023 +0000\n\n    Fix vulnerability in AttributionSource due to incorrect Binder call\n    \n    AttributionSource uses Binder.getCallingUid to verify the UID of the\n    caller from another process. However, getCallingUid does not always\n    behave as expected. If the AttributionSource is unparceled outside a\n    transaction thread, which is quite possible, getCallingUid will return\n    the UID of the current process instead. If this is a system process,\n    the UID check gets bypassed entirely, meaning any uid can be provided.\n    \n    This patch fixes the vulnerability by enforcing that the AttributionSource\n    be unparceled in a transaction only. If it is not, a SecurityException\n    will be thrown.\n    \n    Bug: 267231571\n    Test: Smoke test on cuttlefish.\n    Test: v2/android-virtual-infra/test_mapping/presubmit-avd\n    Change-Id: Iee28c3901ee1041e00dca444c37c90d619e19b26\n    Merged-In: I3f228064fbd62e1c907f1ebe870cb61102f788f0\n    Merged-In: Ic301a8518b8e57e1c9a2c9f2f845e51dca145257\n\ndiff --git a/core/java/android/content/AttributionSource.java b/core/java/android/content/AttributionSource.java\nindex 2f61fee88e9f..ec56f9a7cf0c 100644\n--- a/core/java/android/content/AttributionSource.java\n+++ b/core/java/android/content/AttributionSource.java\n@@ -30,6 +30,7 @@ import android.os.Parcelable;\n import android.os.Process;\n import android.permission.PermissionManager;\n import android.util.ArraySet;\n+import android.util.Log;\n \n import com.android.internal.annotations.Immutable;\n \n@@ -86,6 +87,8 @@ import java.util.Set;\n  */\n @Immutable\n public final class AttributionSource implements Parcelable {\n+    private static final String TAG = \"AttributionSource\";\n+\n     private static final String DESCRIPTOR = \"android.content.AttributionSource\";\n \n     private static final Binder sDefaultToken = new Binder(DESCRIPTOR);\n@@ -153,9 +156,20 @@ public final class AttributionSource implements Parcelable {\n     AttributionSource(@NonNull Parcel in) {\n         this(AttributionSourceState.CREATOR.createFromParcel(in));\n \n-        // Since we just unpacked this object as part of it transiting a Binder\n-        // call, this is the perfect time to enforce that its UID and PID can be trusted\n-        enforceCallingUidAndPid();\n+        if (!Binder.isHandlingTransaction()) {\n+            Log.e(TAG, \"Unable to verify calling UID #\" + mAttributionSourceState.uid + \" PID #\"\n+                    + mAttributionSourceState.pid + \" when not handling Binder transaction; \"\n+                    + \"clearing.\");\n+            mAttributionSourceState.pid = -1;\n+            mAttributionSourceState.uid = -1;\n+            mAttributionSourceState.packageName = null;\n+            mAttributionSourceState.attributionTag = null;\n+            mAttributionSourceState.next = null;\n+        } else {\n+            // Since we just unpacked this object as part of it transiting a Binder\n+            // call, this is the perfect time to enforce that its UID and PID can be trusted\n+            enforceCallingUidAndPid();\n+        }\n     }\n \n     /** @hide */\n",
                            "downstream_patch_tokens": {
                                "openai": 798,
                                "general": {
                                    "word_based": 357,
                                    "char_based": 794
                                },
                                "gemini": 959
                            }
                        },
                        {
                            "downstream_version": "13",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "6fa44c197335a8bea4f96cce3296f5c92d8dd7e7"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "5d79e535b9a802680062545e15fc1faaf779c0bf",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 5d79e535b9a802680062545e15fc1faaf779c0bf\nAuthor: Lokesh Kumar Goel <lokeshgoel@google.com>\nDate:   Tue Feb 27 23:05:05 2024 +0000\n\n    Fix vulnerability in AttributionSource due to incorrect Binder call\n    \n    AttributionSource uses Binder.getCallingUid to verify the UID of the\n    caller from another process. However, getCallingUid does not always\n    behave as expected. If the AttributionSource is unparceled outside a\n    transaction thread, which is quite possible, getCallingUid will return\n    the UID of the current process instead. If this is a system process,\n    the UID check gets bypassed entirely, meaning any uid can be provided.\n    \n    This patch fixes the vulnerability by emptying out the state of the\n    AttributionSource, so that the service checking its credentials will\n    fail to give permission to the app.\n    \n    Bug: 267231571\n    Test: v2/android-virtual-infra/test_mapping/presubmit-avd\n    Merged-In: Ic301a8518b8e57e1c9a2c9f2f845e51dca145257\n    Change-Id: I3f228064fbd62e1c907f1ebe870cb61102f788f0\n\ndiff --git a/core/java/android/content/AttributionSource.java b/core/java/android/content/AttributionSource.java\nindex 3f2fa2188d24..16b18c85e790 100644\n--- a/core/java/android/content/AttributionSource.java\n+++ b/core/java/android/content/AttributionSource.java\n@@ -31,6 +31,7 @@ import android.os.Parcelable;\n import android.os.Process;\n import android.permission.PermissionManager;\n import android.util.ArraySet;\n+import android.util.Log;\n \n import com.android.internal.annotations.Immutable;\n \n@@ -87,6 +88,8 @@ import java.util.Set;\n  */\n @Immutable\n public final class AttributionSource implements Parcelable {\n+    private static final String TAG = \"AttributionSource\";\n+\n     private static final String DESCRIPTOR = \"android.content.AttributionSource\";\n \n     private static final Binder sDefaultToken = new Binder(DESCRIPTOR);\n@@ -154,9 +157,20 @@ public final class AttributionSource implements Parcelable {\n     AttributionSource(@NonNull Parcel in) {\n         this(AttributionSourceState.CREATOR.createFromParcel(in));\n \n-        // Since we just unpacked this object as part of it transiting a Binder\n-        // call, this is the perfect time to enforce that its UID and PID can be trusted\n-        enforceCallingUidAndPid();\n+        if (!Binder.isDirectlyHandlingTransaction()) {\n+            Log.e(TAG, \"Unable to verify calling UID #\" + mAttributionSourceState.uid + \" PID #\"\n+                    + mAttributionSourceState.pid + \" when not handling Binder transaction; \"\n+                    + \"clearing.\");\n+            mAttributionSourceState.pid = -1;\n+            mAttributionSourceState.uid = -1;\n+            mAttributionSourceState.packageName = null;\n+            mAttributionSourceState.attributionTag = null;\n+            mAttributionSourceState.next = null;\n+        } else {\n+            // Since we just unpacked this object as part of it transiting a Binder\n+            // call, this is the perfect time to enforce that its UID and PID can be trusted\n+            enforceCallingUidAndPid();\n+        }\n     }\n \n     /** @hide */\n",
                            "downstream_patch_tokens": {
                                "openai": 763,
                                "general": {
                                    "word_based": 353,
                                    "char_based": 777
                                },
                                "gemini": 913
                            }
                        },
                        {
                            "downstream_version": "13",
                            "result": "skipped",
                            "reason": "Commit not found in repo",
                            "downstream_patch": "2ff2726e38819c05769e09dee3e0dfe56ac7e857"
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-341886134",
            "aliases": [
                "A-341886134",
                "CVE-2024-40657"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-341886134",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "2cb9b10ed97b1b9b29661115789605a762f3c2ef"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 2cb9b10ed97b1b9b29661115789605a762f3c2ef Mon Sep 17 00:00:00 2001\nFrom: Chris Antol <cantol@google.com>\nDate: Tue, 4 Jun 2024 17:00:46 +0000\nSubject: [PATCH] Ignore fragment attr from ext authenticator resource\n\nBug: 341886134\nTest: Unit Test\nTest: Manual - see ticket for steps\nFlag: EXEMPT <security>\n\nChange-Id: Id91c2b3b6d16ba3702ee2cd6723365a4db52863b\n---\n .../accounts/AccountTypePreferenceLoader.java |  55 ++++++++\n .../AccountTypePreferenceLoaderTest.java      | 130 +++++++++++++++++-\n 2 files changed, 179 insertions(+), 6 deletions(-)\n\ndiff --git a/src/com/android/settings/accounts/AccountTypePreferenceLoader.java b/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\nindex 72366d48603..3b254e9b844 100644\n--- a/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n+++ b/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n@@ -33,6 +33,10 @@ import android.os.UserHandle;\n import android.text.TextUtils;\n import android.util.Log;\n \n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+import androidx.collection.ArraySet;\n import androidx.preference.Preference;\n import androidx.preference.Preference.OnPreferenceClickListener;\n import androidx.preference.PreferenceFragmentCompat;\n@@ -46,6 +50,8 @@ import com.android.settings.utils.LocalClassLoaderContextThemeWrapper;\n import com.android.settingslib.accounts.AuthenticatorHelper;\n import com.android.settingslib.core.instrumentation.Instrumentable;\n \n+import java.util.Set;\n+\n /**\n  * Class to load the preference screen to be added to the settings page for the specific account\n  * type as specified in the account-authenticator.\n@@ -83,6 +89,7 @@ public class AccountTypePreferenceLoader {\n             try {\n                 desc = mAuthenticatorHelper.getAccountTypeDescription(accountType);\n                 if (desc != null && desc.accountPreferencesId != 0) {\n+                    Set<String> fragmentAllowList = generateFragmentAllowlist(parent);\n                     // Load the context of the target package, then apply the\n                     // base Settings theme (no references to local resources)\n                     // and create a context theme wrapper so that we get the\n@@ -99,6 +106,12 @@ public class AccountTypePreferenceLoader {\n                     themedCtx.getTheme().setTo(baseTheme);\n                     prefs = mFragment.getPreferenceManager().inflateFromResource(themedCtx,\n                             desc.accountPreferencesId, parent);\n+                    // Ignore Fragments provided dynamically, as these are coming from external\n+                    // applications which must not have access to internal Settings' fragments.\n+                    // These preferences are rendered into Settings, so they also won't have access\n+                    // to their own Fragments, meaning there is no acceptable usage of\n+                    // android:fragment here.\n+                    filterBlockedFragments(prefs, fragmentAllowList);\n                 }\n             } catch (PackageManager.NameNotFoundException e) {\n                 Log.w(TAG, \"Couldn't load preferences.xml file from \" + desc.packageName);\n@@ -186,6 +199,48 @@ public class AccountTypePreferenceLoader {\n         }\n     }\n \n+    // Build allowlist from existing Fragments in PreferenceGroup\n+    @VisibleForTesting\n+    Set<String> generateFragmentAllowlist(@Nullable PreferenceGroup prefs) {\n+        Set<String> fragmentAllowList = new ArraySet<>();\n+        if (prefs == null) {\n+            return fragmentAllowList;\n+        }\n+\n+        for (int i = 0; i < prefs.getPreferenceCount(); i++) {\n+            Preference pref = prefs.getPreference(i);\n+            if (pref instanceof PreferenceGroup) {\n+                fragmentAllowList.addAll(generateFragmentAllowlist((PreferenceGroup) pref));\n+            }\n+\n+            String fragmentName = pref.getFragment();\n+            if (!TextUtils.isEmpty(fragmentName)) {\n+                fragmentAllowList.add(fragmentName);\n+            }\n+        }\n+        return fragmentAllowList;\n+    }\n+\n+    // Block clicks on any Preference with android:fragment that is not contained in the allowlist\n+    @VisibleForTesting\n+    void filterBlockedFragments(@Nullable PreferenceGroup prefs,\n+            @NonNull Set<String> allowedFragments) {\n+        if (prefs == null) {\n+            return;\n+        }\n+        for (int i = 0; i < prefs.getPreferenceCount(); i++) {\n+            Preference pref = prefs.getPreference(i);\n+            if (pref instanceof PreferenceGroup) {\n+                filterBlockedFragments((PreferenceGroup) pref, allowedFragments);\n+            }\n+\n+            String fragmentName = pref.getFragment();\n+            if (fragmentName != null && !allowedFragments.contains(fragmentName)) {\n+                pref.setOnPreferenceClickListener(preference -> true);\n+            }\n+        }\n+    }\n+\n     /**\n      * Determines if the supplied Intent is safe. A safe intent is one that is\n      * will launch a exported=true activity or owned by the same uid as the\ndiff --git a/tests/robotests/src/com/android/settings/accounts/AccountTypePreferenceLoaderTest.java b/tests/robotests/src/com/android/settings/accounts/AccountTypePreferenceLoaderTest.java\nindex f5c588f8d83..efa5fea7416 100644\n--- a/tests/robotests/src/com/android/settings/accounts/AccountTypePreferenceLoaderTest.java\n+++ b/tests/robotests/src/com/android/settings/accounts/AccountTypePreferenceLoaderTest.java\n@@ -16,9 +16,13 @@\n \n package com.android.settings.accounts;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n import static org.mockito.Answers.RETURNS_DEEP_STUBS;\n+import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyInt;\n import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n import static org.mockito.Mockito.spy;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n@@ -30,6 +34,7 @@ import android.content.Context;\n import android.content.pm.PackageManager;\n import android.os.UserHandle;\n \n+import androidx.collection.ArraySet;\n import androidx.preference.Preference;\n import androidx.preference.PreferenceFragmentCompat;\n import androidx.preference.PreferenceGroup;\n@@ -51,9 +56,13 @@ import org.robolectric.RuntimeEnvironment;\n import org.robolectric.annotation.Config;\n import org.robolectric.shadows.ShadowApplication;\n \n+import java.util.Set;\n+\n @RunWith(RobolectricTestRunner.class)\n @Config(shadows = {\n         com.android.settings.testutils.shadow.ShadowFragment.class,\n+        ShadowAccountManager.class,\n+        ShadowContentResolver.class,\n })\n public class AccountTypePreferenceLoaderTest {\n \n@@ -63,6 +72,8 @@ public class AccountTypePreferenceLoaderTest {\n     private PreferenceFragmentCompat mPreferenceFragment;\n     @Mock\n     private PackageManager mPackageManager;\n+    @Mock\n+    private PreferenceManager mManager;\n \n     private Context mContext;\n     private Account mAccount;\n@@ -91,18 +102,16 @@ public class AccountTypePreferenceLoaderTest {\n     }\n \n     @Test\n-    @Config(shadows = {ShadowAccountManager.class, ShadowContentResolver.class})\n     public void updatePreferenceIntents_shouldRunRecursively() {\n-        final PreferenceManager preferenceManager = mock(PreferenceManager.class);\n         // Top level\n         PreferenceGroup prefRoot = spy(new PreferenceScreen(mContext, null));\n-        when(prefRoot.getPreferenceManager()).thenReturn(preferenceManager);\n+        when(prefRoot.getPreferenceManager()).thenReturn(mManager);\n         Preference pref1 = mock(Preference.class);\n         PreferenceGroup prefGroup2 = spy(new PreferenceScreen(mContext, null));\n-        when(prefGroup2.getPreferenceManager()).thenReturn(preferenceManager);\n+        when(prefGroup2.getPreferenceManager()).thenReturn(mManager);\n         Preference pref3 = mock(Preference.class);\n         PreferenceGroup prefGroup4 = spy(new PreferenceScreen(mContext, null));\n-        when(prefGroup4.getPreferenceManager()).thenReturn(preferenceManager);\n+        when(prefGroup4.getPreferenceManager()).thenReturn(mManager);\n         prefRoot.addPreference(pref1);\n         prefRoot.addPreference(prefGroup2);\n         prefRoot.addPreference(pref3);\n@@ -114,7 +123,7 @@ public class AccountTypePreferenceLoaderTest {\n         prefGroup2.addPreference(pref21);\n         prefGroup2.addPreference(pref22);\n         PreferenceGroup prefGroup41 = spy(new PreferenceScreen(mContext, null));\n-        when(prefGroup41.getPreferenceManager()).thenReturn(preferenceManager);\n+        when(prefGroup41.getPreferenceManager()).thenReturn(mManager);\n         Preference pref42 = mock(Preference.class);\n         prefGroup4.addPreference(prefGroup41);\n         prefGroup4.addPreference(pref42);\n@@ -132,4 +141,113 @@ public class AccountTypePreferenceLoaderTest {\n         verify(mPrefLoader).updatePreferenceIntents(prefGroup4, acctType, mAccount);\n         verify(mPrefLoader).updatePreferenceIntents(prefGroup41, acctType, mAccount);\n     }\n+\n+    @Test\n+    public void generateFragmentAllowlist_nullPrefGroup_emptyList() {\n+        Set<String> allowed = mPrefLoader.generateFragmentAllowlist(null);\n+\n+        assertThat(allowed).isEmpty();\n+    }\n+\n+    @Test\n+    public void generateFragmentAllowlist_simpleGroupNoFragment_emptyList() {\n+        Preference pref = new Preference(mContext);\n+        PreferenceScreen screen = spy(new PreferenceScreen(mContext, null));\n+        when(screen.getPreferenceManager()).thenReturn(mManager);\n+        screen.addPreference(pref);\n+\n+        Set<String> allowed = mPrefLoader.generateFragmentAllowlist(screen);\n+\n+        assertThat(allowed).isEmpty();\n+    }\n+\n+    @Test\n+    public void generateFragmentAllowlist_simpleGroupOneFragment_populatedList() {\n+        Preference pref = new Preference(mContext);\n+        pref.setFragment(\"test\");\n+        PreferenceScreen screen = spy(new PreferenceScreen(mContext, null));\n+        when(screen.getPreferenceManager()).thenReturn(mManager);\n+        screen.addPreference(pref);\n+\n+        Set<String> allowed = mPrefLoader.generateFragmentAllowlist(screen);\n+\n+        assertThat(allowed).isNotEmpty();\n+    }\n+\n+    @Test\n+    public void generateFragmentAllowlist_nestedGroupWithFragments_populatedList() {\n+        Preference pref = new Preference(mContext);\n+        pref.setFragment(\"test\");\n+        PreferenceScreen nested = spy(new PreferenceScreen(mContext, null));\n+        PreferenceScreen parent = spy(new PreferenceScreen(mContext, null));\n+        when(nested.getPreferenceManager()).thenReturn(mManager);\n+        when(parent.getPreferenceManager()).thenReturn(mManager);\n+        parent.addPreference(nested);\n+        nested.addPreference(pref);\n+\n+        Set<String> allowed = mPrefLoader.generateFragmentAllowlist(parent);\n+\n+        assertThat(allowed).isNotEmpty();\n+    }\n+\n+    @Test\n+    public void filterBlockedFragments_nullPrefGroup_noop() {\n+        // verify no NPE\n+        mPrefLoader.filterBlockedFragments(null, new ArraySet<>());\n+    }\n+\n+    @Test\n+    public void filterBlockedFragments_simplePrefGroupNoFragment_noop() {\n+        Preference pref = spy(new Preference(mContext));\n+        PreferenceScreen screen = spy(new PreferenceScreen(mContext, null));\n+        when(screen.getPreferenceManager()).thenReturn(mManager);\n+        screen.addPreference(pref);\n+\n+        mPrefLoader.filterBlockedFragments(screen, new ArraySet<>());\n+\n+        verify(screen, never()).setOnPreferenceClickListener(any());\n+        verify(pref, never()).setOnPreferenceClickListener(any());\n+    }\n+\n+    @Test\n+    public void filterBlockedFragments_simplePrefGroupWithAllowedFragment_noop() {\n+        Preference pref = spy(new Preference(mContext));\n+        pref.setFragment(\"test\");\n+        PreferenceScreen screen = spy(new PreferenceScreen(mContext, null));\n+        when(screen.getPreferenceManager()).thenReturn(mManager);\n+        screen.addPreference(pref);\n+\n+        mPrefLoader.filterBlockedFragments(screen, Set.of(\"test\"));\n+\n+        verify(screen, never()).setOnPreferenceClickListener(any());\n+        verify(pref, never()).setOnPreferenceClickListener(any());\n+    }\n+\n+    @Test\n+    public void filterBlockedFragments_simplePrefGroupNoMatchFragment_overrideClick() {\n+        Preference pref = spy(new Preference(mContext));\n+        pref.setFragment(\"test\");\n+        PreferenceScreen screen = spy(new PreferenceScreen(mContext, null));\n+        when(screen.getPreferenceManager()).thenReturn(mManager);\n+        screen.addPreference(pref);\n+\n+        mPrefLoader.filterBlockedFragments(screen, new ArraySet<>());\n+\n+        verify(pref).setOnPreferenceClickListener(any());\n+    }\n+\n+    @Test\n+    public void filterBlockedFragments_nestedPrefGroupWithNoMatchFragment_overrideClick() {\n+        Preference pref = spy(new Preference(mContext));\n+        pref.setFragment(\"test\");\n+        PreferenceScreen nested = spy(new PreferenceScreen(mContext, null));\n+        PreferenceScreen parent = spy(new PreferenceScreen(mContext, null));\n+        when(nested.getPreferenceManager()).thenReturn(mManager);\n+        when(parent.getPreferenceManager()).thenReturn(mManager);\n+        parent.addPreference(nested);\n+        nested.addPreference(pref);\n+\n+        mPrefLoader.filterBlockedFragments(parent, Set.of(\"nomatch\", \"other\"));\n+        verify(pref).setOnPreferenceClickListener(any());\n+    }\n }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 2872,
                        "general": {
                            "word_based": 1183,
                            "char_based": 3385
                        },
                        "gemini": 3573
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "7e0b376b11318e1e79b31bac6aafc0c923868bc4",
                            "repo_path": "android_repos/Settings",
                            "result": "success",
                            "downstream_patch_content": "commit 7e0b376b11318e1e79b31bac6aafc0c923868bc4\nAuthor: Chris Antol <cantol@google.com>\nDate:   Tue Jun 4 17:00:46 2024 +0000\n\n    Ignore fragment attr from ext authenticator resource\n    \n    Bug: 341886134\n    Test: Unit Test\n    Test: Manual - see ticket for steps\n    Flag: EXEMPT <security>\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:2cb9b10ed97b1b9b29661115789605a762f3c2ef)\n    Merged-In: Id91c2b3b6d16ba3702ee2cd6723365a4db52863b\n    Change-Id: Id91c2b3b6d16ba3702ee2cd6723365a4db52863b\n\ndiff --git a/src/com/android/settings/accounts/AccountTypePreferenceLoader.java b/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\nindex 42bb34a0ee4..73583ea8592 100644\n--- a/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n+++ b/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n@@ -32,6 +32,10 @@ import android.os.UserHandle;\n import android.text.TextUtils;\n import android.util.Log;\n \n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+import androidx.collection.ArraySet;\n import androidx.preference.Preference;\n import androidx.preference.Preference.OnPreferenceClickListener;\n import androidx.preference.PreferenceFragmentCompat;\n@@ -45,6 +49,8 @@ import com.android.settings.utils.LocalClassLoaderContextThemeWrapper;\n import com.android.settingslib.accounts.AuthenticatorHelper;\n import com.android.settingslib.core.instrumentation.Instrumentable;\n \n+import java.util.Set;\n+\n /**\n  * Class to load the preference screen to be added to the settings page for the specific account\n  * type as specified in the account-authenticator.\n@@ -82,6 +88,7 @@ public class AccountTypePreferenceLoader {\n             try {\n                 desc = mAuthenticatorHelper.getAccountTypeDescription(accountType);\n                 if (desc != null && desc.accountPreferencesId != 0) {\n+                    Set<String> fragmentAllowList = generateFragmentAllowlist(parent);\n                     // Load the context of the target package, then apply the\n                     // base Settings theme (no references to local resources)\n                     // and create a context theme wrapper so that we get the\n@@ -97,6 +104,12 @@ public class AccountTypePreferenceLoader {\n                     themedCtx.getTheme().setTo(baseTheme);\n                     prefs = mFragment.getPreferenceManager().inflateFromResource(themedCtx,\n                             desc.accountPreferencesId, parent);\n+                    // Ignore Fragments provided dynamically, as these are coming from external\n+                    // applications which must not have access to internal Settings' fragments.\n+                    // These preferences are rendered into Settings, so they also won't have access\n+                    // to their own Fragments, meaning there is no acceptable usage of\n+                    // android:fragment here.\n+                    filterBlockedFragments(prefs, fragmentAllowList);\n                 }\n             } catch (PackageManager.NameNotFoundException e) {\n                 Log.w(TAG, \"Couldn't load preferences.xml file from \" + desc.packageName);\n@@ -181,6 +194,48 @@ public class AccountTypePreferenceLoader {\n         }\n     }\n \n+    // Build allowlist from existing Fragments in PreferenceGroup\n+    @VisibleForTesting\n+    Set<String> generateFragmentAllowlist(@Nullable PreferenceGroup prefs) {\n+        Set<String> fragmentAllowList = new ArraySet<>();\n+        if (prefs == null) {\n+            return fragmentAllowList;\n+        }\n+\n+        for (int i = 0; i < prefs.getPreferenceCount(); i++) {\n+            Preference pref = prefs.getPreference(i);\n+            if (pref instanceof PreferenceGroup) {\n+                fragmentAllowList.addAll(generateFragmentAllowlist((PreferenceGroup) pref));\n+            }\n+\n+            String fragmentName = pref.getFragment();\n+            if (!TextUtils.isEmpty(fragmentName)) {\n+                fragmentAllowList.add(fragmentName);\n+            }\n+        }\n+        return fragmentAllowList;\n+    }\n+\n+    // Block clicks on any Preference with android:fragment that is not contained in the allowlist\n+    @VisibleForTesting\n+    void filterBlockedFragments(@Nullable PreferenceGroup prefs,\n+            @NonNull Set<String> allowedFragments) {\n+        if (prefs == null) {\n+            return;\n+        }\n+        for (int i = 0; i < prefs.getPreferenceCount(); i++) {\n+            Preference pref = prefs.getPreference(i);\n+            if (pref instanceof PreferenceGroup) {\n+                filterBlockedFragments((PreferenceGroup) pref, allowedFragments);\n+            }\n+\n+            String fragmentName = pref.getFragment();\n+            if (fragmentName != null && !allowedFragments.contains(fragmentName)) {\n+                pref.setOnPreferenceClickListener(preference -> true);\n+            }\n+        }\n+    }\n+\n     /**\n      * Determines if the supplied Intent is safe. A safe intent is one that is\n      * will launch a exported=true activity or owned by the same uid as the\n",
                            "downstream_patch_tokens": {
                                "openai": 1129,
                                "general": {
                                    "word_based": 485,
                                    "char_based": 1279
                                },
                                "gemini": 1384
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "e2dc98c21db7ac35137417bf72f33177a1b70b48",
                            "repo_path": "android_repos/Settings",
                            "result": "success",
                            "downstream_patch_content": "commit e2dc98c21db7ac35137417bf72f33177a1b70b48\nAuthor: Chris Antol <cantol@google.com>\nDate:   Tue Jun 4 17:00:46 2024 +0000\n\n    Ignore fragment attr from ext authenticator resource\n    \n    Bug: 341886134\n    Test: Unit Test\n    Test: Manual - see ticket for steps\n    Flag: EXEMPT <security>\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:2cb9b10ed97b1b9b29661115789605a762f3c2ef)\n    Merged-In: Id91c2b3b6d16ba3702ee2cd6723365a4db52863b\n    Change-Id: Id91c2b3b6d16ba3702ee2cd6723365a4db52863b\n\ndiff --git a/src/com/android/settings/accounts/AccountTypePreferenceLoader.java b/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\nindex 42bb34a0ee4..73583ea8592 100644\n--- a/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n+++ b/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n@@ -32,6 +32,10 @@ import android.os.UserHandle;\n import android.text.TextUtils;\n import android.util.Log;\n \n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+import androidx.collection.ArraySet;\n import androidx.preference.Preference;\n import androidx.preference.Preference.OnPreferenceClickListener;\n import androidx.preference.PreferenceFragmentCompat;\n@@ -45,6 +49,8 @@ import com.android.settings.utils.LocalClassLoaderContextThemeWrapper;\n import com.android.settingslib.accounts.AuthenticatorHelper;\n import com.android.settingslib.core.instrumentation.Instrumentable;\n \n+import java.util.Set;\n+\n /**\n  * Class to load the preference screen to be added to the settings page for the specific account\n  * type as specified in the account-authenticator.\n@@ -82,6 +88,7 @@ public class AccountTypePreferenceLoader {\n             try {\n                 desc = mAuthenticatorHelper.getAccountTypeDescription(accountType);\n                 if (desc != null && desc.accountPreferencesId != 0) {\n+                    Set<String> fragmentAllowList = generateFragmentAllowlist(parent);\n                     // Load the context of the target package, then apply the\n                     // base Settings theme (no references to local resources)\n                     // and create a context theme wrapper so that we get the\n@@ -97,6 +104,12 @@ public class AccountTypePreferenceLoader {\n                     themedCtx.getTheme().setTo(baseTheme);\n                     prefs = mFragment.getPreferenceManager().inflateFromResource(themedCtx,\n                             desc.accountPreferencesId, parent);\n+                    // Ignore Fragments provided dynamically, as these are coming from external\n+                    // applications which must not have access to internal Settings' fragments.\n+                    // These preferences are rendered into Settings, so they also won't have access\n+                    // to their own Fragments, meaning there is no acceptable usage of\n+                    // android:fragment here.\n+                    filterBlockedFragments(prefs, fragmentAllowList);\n                 }\n             } catch (PackageManager.NameNotFoundException e) {\n                 Log.w(TAG, \"Couldn't load preferences.xml file from \" + desc.packageName);\n@@ -181,6 +194,48 @@ public class AccountTypePreferenceLoader {\n         }\n     }\n \n+    // Build allowlist from existing Fragments in PreferenceGroup\n+    @VisibleForTesting\n+    Set<String> generateFragmentAllowlist(@Nullable PreferenceGroup prefs) {\n+        Set<String> fragmentAllowList = new ArraySet<>();\n+        if (prefs == null) {\n+            return fragmentAllowList;\n+        }\n+\n+        for (int i = 0; i < prefs.getPreferenceCount(); i++) {\n+            Preference pref = prefs.getPreference(i);\n+            if (pref instanceof PreferenceGroup) {\n+                fragmentAllowList.addAll(generateFragmentAllowlist((PreferenceGroup) pref));\n+            }\n+\n+            String fragmentName = pref.getFragment();\n+            if (!TextUtils.isEmpty(fragmentName)) {\n+                fragmentAllowList.add(fragmentName);\n+            }\n+        }\n+        return fragmentAllowList;\n+    }\n+\n+    // Block clicks on any Preference with android:fragment that is not contained in the allowlist\n+    @VisibleForTesting\n+    void filterBlockedFragments(@Nullable PreferenceGroup prefs,\n+            @NonNull Set<String> allowedFragments) {\n+        if (prefs == null) {\n+            return;\n+        }\n+        for (int i = 0; i < prefs.getPreferenceCount(); i++) {\n+            Preference pref = prefs.getPreference(i);\n+            if (pref instanceof PreferenceGroup) {\n+                filterBlockedFragments((PreferenceGroup) pref, allowedFragments);\n+            }\n+\n+            String fragmentName = pref.getFragment();\n+            if (fragmentName != null && !allowedFragments.contains(fragmentName)) {\n+                pref.setOnPreferenceClickListener(preference -> true);\n+            }\n+        }\n+    }\n+\n     /**\n      * Determines if the supplied Intent is safe. A safe intent is one that is\n      * will launch a exported=true activity or owned by the same uid as the\n",
                            "downstream_patch_tokens": {
                                "openai": 1127,
                                "general": {
                                    "word_based": 485,
                                    "char_based": 1279
                                },
                                "gemini": 1384
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "24e2f2d2f65d233527e1f50e3e215c266f040792",
                            "repo_path": "android_repos/Settings",
                            "result": "success",
                            "downstream_patch_content": "commit 24e2f2d2f65d233527e1f50e3e215c266f040792\nAuthor: Chris Antol <cantol@google.com>\nDate:   Tue Jun 4 17:00:46 2024 +0000\n\n    Ignore fragment attr from ext authenticator resource\n    \n    Bug: 341886134\n    Test: Unit Test\n    Test: Manual - see ticket for steps\n    Flag: EXEMPT <security>\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:2cb9b10ed97b1b9b29661115789605a762f3c2ef)\n    Merged-In: Id91c2b3b6d16ba3702ee2cd6723365a4db52863b\n    Change-Id: Id91c2b3b6d16ba3702ee2cd6723365a4db52863b\n\ndiff --git a/src/com/android/settings/accounts/AccountTypePreferenceLoader.java b/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\nindex 42bb34a0ee4..73583ea8592 100644\n--- a/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n+++ b/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n@@ -32,6 +32,10 @@ import android.os.UserHandle;\n import android.text.TextUtils;\n import android.util.Log;\n \n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+import androidx.collection.ArraySet;\n import androidx.preference.Preference;\n import androidx.preference.Preference.OnPreferenceClickListener;\n import androidx.preference.PreferenceFragmentCompat;\n@@ -45,6 +49,8 @@ import com.android.settings.utils.LocalClassLoaderContextThemeWrapper;\n import com.android.settingslib.accounts.AuthenticatorHelper;\n import com.android.settingslib.core.instrumentation.Instrumentable;\n \n+import java.util.Set;\n+\n /**\n  * Class to load the preference screen to be added to the settings page for the specific account\n  * type as specified in the account-authenticator.\n@@ -82,6 +88,7 @@ public class AccountTypePreferenceLoader {\n             try {\n                 desc = mAuthenticatorHelper.getAccountTypeDescription(accountType);\n                 if (desc != null && desc.accountPreferencesId != 0) {\n+                    Set<String> fragmentAllowList = generateFragmentAllowlist(parent);\n                     // Load the context of the target package, then apply the\n                     // base Settings theme (no references to local resources)\n                     // and create a context theme wrapper so that we get the\n@@ -97,6 +104,12 @@ public class AccountTypePreferenceLoader {\n                     themedCtx.getTheme().setTo(baseTheme);\n                     prefs = mFragment.getPreferenceManager().inflateFromResource(themedCtx,\n                             desc.accountPreferencesId, parent);\n+                    // Ignore Fragments provided dynamically, as these are coming from external\n+                    // applications which must not have access to internal Settings' fragments.\n+                    // These preferences are rendered into Settings, so they also won't have access\n+                    // to their own Fragments, meaning there is no acceptable usage of\n+                    // android:fragment here.\n+                    filterBlockedFragments(prefs, fragmentAllowList);\n                 }\n             } catch (PackageManager.NameNotFoundException e) {\n                 Log.w(TAG, \"Couldn't load preferences.xml file from \" + desc.packageName);\n@@ -181,6 +194,48 @@ public class AccountTypePreferenceLoader {\n         }\n     }\n \n+    // Build allowlist from existing Fragments in PreferenceGroup\n+    @VisibleForTesting\n+    Set<String> generateFragmentAllowlist(@Nullable PreferenceGroup prefs) {\n+        Set<String> fragmentAllowList = new ArraySet<>();\n+        if (prefs == null) {\n+            return fragmentAllowList;\n+        }\n+\n+        for (int i = 0; i < prefs.getPreferenceCount(); i++) {\n+            Preference pref = prefs.getPreference(i);\n+            if (pref instanceof PreferenceGroup) {\n+                fragmentAllowList.addAll(generateFragmentAllowlist((PreferenceGroup) pref));\n+            }\n+\n+            String fragmentName = pref.getFragment();\n+            if (!TextUtils.isEmpty(fragmentName)) {\n+                fragmentAllowList.add(fragmentName);\n+            }\n+        }\n+        return fragmentAllowList;\n+    }\n+\n+    // Block clicks on any Preference with android:fragment that is not contained in the allowlist\n+    @VisibleForTesting\n+    void filterBlockedFragments(@Nullable PreferenceGroup prefs,\n+            @NonNull Set<String> allowedFragments) {\n+        if (prefs == null) {\n+            return;\n+        }\n+        for (int i = 0; i < prefs.getPreferenceCount(); i++) {\n+            Preference pref = prefs.getPreference(i);\n+            if (pref instanceof PreferenceGroup) {\n+                filterBlockedFragments((PreferenceGroup) pref, allowedFragments);\n+            }\n+\n+            String fragmentName = pref.getFragment();\n+            if (fragmentName != null && !allowedFragments.contains(fragmentName)) {\n+                pref.setOnPreferenceClickListener(preference -> true);\n+            }\n+        }\n+    }\n+\n     /**\n      * Determines if the supplied Intent is safe. A safe intent is one that is\n      * will launch a exported=true activity or owned by the same uid as the\n",
                            "downstream_patch_tokens": {
                                "openai": 1130,
                                "general": {
                                    "word_based": 485,
                                    "char_based": 1279
                                },
                                "gemini": 1389
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "d43f82be7a1d2fc5659afeb9d7eca45bf4ba3a8e",
                            "repo_path": "android_repos/Settings",
                            "result": "success",
                            "downstream_patch_content": "commit d43f82be7a1d2fc5659afeb9d7eca45bf4ba3a8e\nAuthor: Chris Antol <cantol@google.com>\nDate:   Tue Jun 4 17:00:46 2024 +0000\n\n    Ignore fragment attr from ext authenticator resource\n    \n    Bug: 341886134\n    Test: Unit Test\n    Test: Manual - see ticket for steps\n    Flag: EXEMPT <security>\n    \n    Change-Id: Id91c2b3b6d16ba3702ee2cd6723365a4db52863b\n\ndiff --git a/src/com/android/settings/accounts/AccountTypePreferenceLoader.java b/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\nindex f1b5be109d2..16519af6730 100644\n--- a/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n+++ b/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n@@ -33,6 +33,10 @@ import android.os.UserHandle;\n import android.text.TextUtils;\n import android.util.Log;\n \n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+import androidx.collection.ArraySet;\n import androidx.preference.Preference;\n import androidx.preference.Preference.OnPreferenceClickListener;\n import androidx.preference.PreferenceFragmentCompat;\n@@ -46,6 +50,8 @@ import com.android.settings.utils.LocalClassLoaderContextThemeWrapper;\n import com.android.settingslib.accounts.AuthenticatorHelper;\n import com.android.settingslib.core.instrumentation.Instrumentable;\n \n+import java.util.Set;\n+\n /**\n  * Class to load the preference screen to be added to the settings page for the specific account\n  * type as specified in the account-authenticator.\n@@ -83,6 +89,7 @@ public class AccountTypePreferenceLoader {\n             try {\n                 desc = mAuthenticatorHelper.getAccountTypeDescription(accountType);\n                 if (desc != null && desc.accountPreferencesId != 0) {\n+                    Set<String> fragmentAllowList = generateFragmentAllowlist(parent);\n                     // Load the context of the target package, then apply the\n                     // base Settings theme (no references to local resources)\n                     // and create a context theme wrapper so that we get the\n@@ -98,6 +105,12 @@ public class AccountTypePreferenceLoader {\n                     themedCtx.getTheme().setTo(baseTheme);\n                     prefs = mFragment.getPreferenceManager().inflateFromResource(themedCtx,\n                             desc.accountPreferencesId, parent);\n+                    // Ignore Fragments provided dynamically, as these are coming from external\n+                    // applications which must not have access to internal Settings' fragments.\n+                    // These preferences are rendered into Settings, so they also won't have access\n+                    // to their own Fragments, meaning there is no acceptable usage of\n+                    // android:fragment here.\n+                    filterBlockedFragments(prefs, fragmentAllowList);\n                 }\n             } catch (PackageManager.NameNotFoundException e) {\n                 Log.w(TAG, \"Couldn't load preferences.xml file from \" + desc.packageName);\n@@ -185,6 +198,48 @@ public class AccountTypePreferenceLoader {\n         }\n     }\n \n+    // Build allowlist from existing Fragments in PreferenceGroup\n+    @VisibleForTesting\n+    Set<String> generateFragmentAllowlist(@Nullable PreferenceGroup prefs) {\n+        Set<String> fragmentAllowList = new ArraySet<>();\n+        if (prefs == null) {\n+            return fragmentAllowList;\n+        }\n+\n+        for (int i = 0; i < prefs.getPreferenceCount(); i++) {\n+            Preference pref = prefs.getPreference(i);\n+            if (pref instanceof PreferenceGroup) {\n+                fragmentAllowList.addAll(generateFragmentAllowlist((PreferenceGroup) pref));\n+            }\n+\n+            String fragmentName = pref.getFragment();\n+            if (!TextUtils.isEmpty(fragmentName)) {\n+                fragmentAllowList.add(fragmentName);\n+            }\n+        }\n+        return fragmentAllowList;\n+    }\n+\n+    // Block clicks on any Preference with android:fragment that is not contained in the allowlist\n+    @VisibleForTesting\n+    void filterBlockedFragments(@Nullable PreferenceGroup prefs,\n+            @NonNull Set<String> allowedFragments) {\n+        if (prefs == null) {\n+            return;\n+        }\n+        for (int i = 0; i < prefs.getPreferenceCount(); i++) {\n+            Preference pref = prefs.getPreference(i);\n+            if (pref instanceof PreferenceGroup) {\n+                filterBlockedFragments((PreferenceGroup) pref, allowedFragments);\n+            }\n+\n+            String fragmentName = pref.getFragment();\n+            if (fragmentName != null && !allowedFragments.contains(fragmentName)) {\n+                pref.setOnPreferenceClickListener(preference -> true);\n+            }\n+        }\n+    }\n+\n     /**\n      * Determines if the supplied Intent is safe. A safe intent is one that is\n      * will launch a exported=true activity or owned by the same uid as the\n",
                            "downstream_patch_tokens": {
                                "openai": 1055,
                                "general": {
                                    "word_based": 470,
                                    "char_based": 1234
                                },
                                "gemini": 1277
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-318683126",
            "aliases": [
                "A-318683126",
                "CVE-2024-40675"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-318683126",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "b85bee508793e31d6fe37fc9cd4e8fa3787113cc"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From b85bee508793e31d6fe37fc9cd4e8fa3787113cc Mon Sep 17 00:00:00 2001\nFrom: William Loh <wloh@google.com>\nDate: Mon, 3 Jun 2024 12:56:47 -0700\nSubject: [PATCH] Fail parseUri if end is missing\n\nBug: 318683126\nTest: atest IntentTest\nFlag: EXEMPT bugfix\nChange-Id: I5f619ced684ff505ce2b7408cd35dd3e9be89dea\n---\n core/java/android/content/Intent.java | 3 +++\n 1 file changed, 3 insertions(+)\n\ndiff --git a/core/java/android/content/Intent.java b/core/java/android/content/Intent.java\nindex c8cae822570e..02d62a2a402b 100644\n--- a/core/java/android/content/Intent.java\n+++ b/core/java/android/content/Intent.java\n@@ -8157,6 +8157,9 @@ public class Intent implements Parcelable, Cloneable {\n                 int eq = uri.indexOf('=', i);\n                 if (eq < 0) eq = i-1;\n                 int semi = uri.indexOf(';', i);\n+                if (semi < 0) {\n+                    throw new URISyntaxException(uri, \"uri end not found\");\n+                }\n                 String value = eq < semi ? Uri.decode(uri.substring(eq + 1, semi)) : \"\";\n \n                 // action\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 336,
                        "general": {
                            "word_based": 144,
                            "char_based": 274
                        },
                        "gemini": 438
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "68268563631f18bc984ac2295fb41f5cc9a8369d",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 68268563631f18bc984ac2295fb41f5cc9a8369d\nAuthor: William Loh <wloh@google.com>\nDate:   Mon Jun 3 12:56:47 2024 -0700\n\n    Fail parseUri if end is missing\n    \n    Bug: 318683126\n    Test: atest IntentTest\n    Flag: EXEMPT bugfix\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:b85bee508793e31d6fe37fc9cd4e8fa3787113cc)\n    Merged-In: I5f619ced684ff505ce2b7408cd35dd3e9be89dea\n    Change-Id: I5f619ced684ff505ce2b7408cd35dd3e9be89dea\n\ndiff --git a/core/java/android/content/Intent.java b/core/java/android/content/Intent.java\nindex 76c67fa6645b..6102fd839633 100644\n--- a/core/java/android/content/Intent.java\n+++ b/core/java/android/content/Intent.java\n@@ -7306,6 +7306,9 @@ public class Intent implements Parcelable, Cloneable {\n                 int eq = uri.indexOf('=', i);\n                 if (eq < 0) eq = i-1;\n                 int semi = uri.indexOf(';', i);\n+                if (semi < 0) {\n+                    throw new URISyntaxException(uri, \"uri end not found\");\n+                }\n                 String value = eq < semi ? Uri.decode(uri.substring(eq + 1, semi)) : \"\";\n \n                 // action\n",
                            "downstream_patch_tokens": {
                                "openai": 356,
                                "general": {
                                    "word_based": 132,
                                    "char_based": 289
                                },
                                "gemini": 477
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "6853510bc3070ee43de4b68ba26c3ca2164f8317",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 6853510bc3070ee43de4b68ba26c3ca2164f8317\nAuthor: William Loh <wloh@google.com>\nDate:   Mon Jun 3 12:56:47 2024 -0700\n\n    Fail parseUri if end is missing\n    \n    Bug: 318683126\n    Test: atest IntentTest\n    Flag: EXEMPT bugfix\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:b85bee508793e31d6fe37fc9cd4e8fa3787113cc)\n    Merged-In: I5f619ced684ff505ce2b7408cd35dd3e9be89dea\n    Change-Id: I5f619ced684ff505ce2b7408cd35dd3e9be89dea\n\ndiff --git a/core/java/android/content/Intent.java b/core/java/android/content/Intent.java\nindex 6224758ce71a..ec67c7239df2 100644\n--- a/core/java/android/content/Intent.java\n+++ b/core/java/android/content/Intent.java\n@@ -7322,6 +7322,9 @@ public class Intent implements Parcelable, Cloneable {\n                 int eq = uri.indexOf('=', i);\n                 if (eq < 0) eq = i-1;\n                 int semi = uri.indexOf(';', i);\n+                if (semi < 0) {\n+                    throw new URISyntaxException(uri, \"uri end not found\");\n+                }\n                 String value = eq < semi ? Uri.decode(uri.substring(eq + 1, semi)) : \"\";\n \n                 // action\n",
                            "downstream_patch_tokens": {
                                "openai": 358,
                                "general": {
                                    "word_based": 132,
                                    "char_based": 289
                                },
                                "gemini": 475
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "e716a8dd586a647a809ac2b8331f5c7995c1a147",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit e716a8dd586a647a809ac2b8331f5c7995c1a147\nAuthor: William Loh <wloh@google.com>\nDate:   Mon Jun 3 12:56:47 2024 -0700\n\n    Fail parseUri if end is missing\n    \n    Bug: 318683126\n    Test: atest IntentTest\n    Flag: EXEMPT bugfix\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:b85bee508793e31d6fe37fc9cd4e8fa3787113cc)\n    Merged-In: I5f619ced684ff505ce2b7408cd35dd3e9be89dea\n    Change-Id: I5f619ced684ff505ce2b7408cd35dd3e9be89dea\n\ndiff --git a/core/java/android/content/Intent.java b/core/java/android/content/Intent.java\nindex aa765e3561ff..22839a085cf7 100644\n--- a/core/java/android/content/Intent.java\n+++ b/core/java/android/content/Intent.java\n@@ -7602,6 +7602,9 @@ public class Intent implements Parcelable, Cloneable {\n                 int eq = uri.indexOf('=', i);\n                 if (eq < 0) eq = i-1;\n                 int semi = uri.indexOf(';', i);\n+                if (semi < 0) {\n+                    throw new URISyntaxException(uri, \"uri end not found\");\n+                }\n                 String value = eq < semi ? Uri.decode(uri.substring(eq + 1, semi)) : \"\";\n \n                 // action\n",
                            "downstream_patch_tokens": {
                                "openai": 357,
                                "general": {
                                    "word_based": 132,
                                    "char_based": 289
                                },
                                "gemini": 476
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "fe93f1262d7a73080fbabacd0c800faa7c2d73e3",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit fe93f1262d7a73080fbabacd0c800faa7c2d73e3\nAuthor: William Loh <wloh@google.com>\nDate:   Mon Jun 3 12:56:47 2024 -0700\n\n    Fail parseUri if end is missing\n    \n    Bug: 318683126\n    Test: atest IntentTest\n    Flag: EXEMPT bugfix\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:b85bee508793e31d6fe37fc9cd4e8fa3787113cc)\n    Merged-In: I5f619ced684ff505ce2b7408cd35dd3e9be89dea\n    Change-Id: I5f619ced684ff505ce2b7408cd35dd3e9be89dea\n\ndiff --git a/core/java/android/content/Intent.java b/core/java/android/content/Intent.java\nindex e763e951fbc1..6f44a77a3d4a 100644\n--- a/core/java/android/content/Intent.java\n+++ b/core/java/android/content/Intent.java\n@@ -7855,6 +7855,9 @@ public class Intent implements Parcelable, Cloneable {\n                 int eq = uri.indexOf('=', i);\n                 if (eq < 0) eq = i-1;\n                 int semi = uri.indexOf(';', i);\n+                if (semi < 0) {\n+                    throw new URISyntaxException(uri, \"uri end not found\");\n+                }\n                 String value = eq < semi ? Uri.decode(uri.substring(eq + 1, semi)) : \"\";\n \n                 // action\n",
                            "downstream_patch_tokens": {
                                "openai": 363,
                                "general": {
                                    "word_based": 132,
                                    "char_based": 289
                                },
                                "gemini": 472
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-300903400",
            "aliases": [
                "A-300903400",
                "CVE-2024-0045"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-300903400",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "f20a759c149b739f8dfc3790287ad1b954115c18"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From f20a759c149b739f8dfc3790287ad1b954115c18 Mon Sep 17 00:00:00 2001\nFrom: Hui Peng <phui@google.com>\nDate: Fri, 20 Oct 2023 00:11:24 +0000\nSubject: [PATCH] Fix an OOB bug in smp_proc_sec_req\n\nBug: 300903400\nTest: m com.android.btservices\nIgnore-AOSP-First: security\nChange-Id: I400cfa3523c6d8b25c233205748c2db5dc803d1d\n---\n system/stack/smp/smp_act.cc | 7 +++++++\n 1 file changed, 7 insertions(+)\n\ndiff --git a/system/stack/smp/smp_act.cc b/system/stack/smp/smp_act.cc\nindex eb08abc630..5ba985de86 100644\n--- a/system/stack/smp/smp_act.cc\n+++ b/system/stack/smp/smp_act.cc\n@@ -461,6 +461,13 @@ void smp_send_ltk_reply(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n  * Description  process security request.\n  ******************************************************************************/\n void smp_proc_sec_req(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n+  if (smp_command_has_invalid_length(p_cb)) {\n+    tSMP_INT_DATA smp_int_data;\n+    smp_int_data.status = SMP_INVALID_PARAMETERS;\n+    smp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &smp_int_data);\n+    return;\n+  }\n+\n   tBTM_LE_AUTH_REQ auth_req = *(tBTM_LE_AUTH_REQ*)p_data->p_data;\n   tBTM_BLE_SEC_REQ_ACT sec_req_act;\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 416,
                        "general": {
                            "word_based": 133,
                            "char_based": 298
                        },
                        "gemini": 567
                    },
                    "total_downstream_versions_tested": 2,
                    "successful_patches": 2,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "a4704e7519d0a02c1caf8b4d8ed874bc201a4b91",
                            "repo_path": "android_repos/Bluetooth",
                            "result": "success",
                            "downstream_patch_content": "commit a4704e7519d0a02c1caf8b4d8ed874bc201a4b91\nAuthor: Hui Peng <phui@google.com>\nDate:   Fri Oct 20 00:11:24 2023 +0000\n\n    Fix an OOB bug in smp_proc_sec_req\n    \n    Bug: 300903400\n    Test: m com.android.btservices\n    Ignore-AOSP-First: security\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:f20a759c149b739f8dfc3790287ad1b954115c18)\n    Merged-In: I400cfa3523c6d8b25c233205748c2db5dc803d1d\n    Change-Id: I400cfa3523c6d8b25c233205748c2db5dc803d1d\n\ndiff --git a/system/stack/smp/smp_act.cc b/system/stack/smp/smp_act.cc\nindex 6d8f007c72..a4552d1300 100644\n--- a/system/stack/smp/smp_act.cc\n+++ b/system/stack/smp/smp_act.cc\n@@ -431,6 +431,13 @@ void smp_send_ltk_reply(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n  * Description  process security request.\n  ******************************************************************************/\n void smp_proc_sec_req(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n+  if (smp_command_has_invalid_length(p_cb)) {\n+    tSMP_INT_DATA smp_int_data;\n+    smp_int_data.status = SMP_INVALID_PARAMETERS;\n+    smp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &smp_int_data);\n+    return;\n+  }\n+\n   tBTM_LE_AUTH_REQ auth_req = *(tBTM_LE_AUTH_REQ*)p_data->p_data;\n   tBTM_BLE_SEC_REQ_ACT sec_req_act;\n \n",
                            "downstream_patch_tokens": {
                                "openai": 446,
                                "general": {
                                    "word_based": 122,
                                    "char_based": 314
                                },
                                "gemini": 613
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "a4704e7519d0a02c1caf8b4d8ed874bc201a4b91",
                            "repo_path": "android_repos/Bluetooth",
                            "result": "success",
                            "downstream_patch_content": "commit a4704e7519d0a02c1caf8b4d8ed874bc201a4b91\nAuthor: Hui Peng <phui@google.com>\nDate:   Fri Oct 20 00:11:24 2023 +0000\n\n    Fix an OOB bug in smp_proc_sec_req\n    \n    Bug: 300903400\n    Test: m com.android.btservices\n    Ignore-AOSP-First: security\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:f20a759c149b739f8dfc3790287ad1b954115c18)\n    Merged-In: I400cfa3523c6d8b25c233205748c2db5dc803d1d\n    Change-Id: I400cfa3523c6d8b25c233205748c2db5dc803d1d\n\ndiff --git a/system/stack/smp/smp_act.cc b/system/stack/smp/smp_act.cc\nindex 6d8f007c72..a4552d1300 100644\n--- a/system/stack/smp/smp_act.cc\n+++ b/system/stack/smp/smp_act.cc\n@@ -431,6 +431,13 @@ void smp_send_ltk_reply(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n  * Description  process security request.\n  ******************************************************************************/\n void smp_proc_sec_req(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n+  if (smp_command_has_invalid_length(p_cb)) {\n+    tSMP_INT_DATA smp_int_data;\n+    smp_int_data.status = SMP_INVALID_PARAMETERS;\n+    smp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &smp_int_data);\n+    return;\n+  }\n+\n   tBTM_LE_AUTH_REQ auth_req = *(tBTM_LE_AUTH_REQ*)p_data->p_data;\n   tBTM_BLE_SEC_REQ_ACT sec_req_act;\n \n",
                            "downstream_patch_tokens": {
                                "openai": 446,
                                "general": {
                                    "word_based": 122,
                                    "char_based": 314
                                },
                                "gemini": 613
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-300741186",
            "aliases": [
                "A-300741186",
                "CVE-2024-0041"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-300741186",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "c86dbabdf20965e4804f912440b5964643a04725"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From c86dbabdf20965e4804f912440b5964643a04725 Mon Sep 17 00:00:00 2001\nFrom: Johannes Gallmann <gallmann@google.com>\nDate: Fri, 21 Jul 2023 15:58:11 +0200\nSubject: [PATCH] Fix persistent dot not removed due to race condition in\n scheduler\n\nBug: 290784635\nTest: atest SystemStatusAnimationSchedulerImplTest\nChange-Id: I7380cb956b48c38bdd540b297287786cf35b94f2\n---\n .../SystemStatusAnimationSchedulerImpl.kt     | 32 +++++---------\n .../SystemStatusAnimationSchedulerImplTest.kt | 44 +++++++++++++++++--\n 2 files changed, 52 insertions(+), 24 deletions(-)\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImpl.kt b/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImpl.kt\nindex 6fc715a2b578..e0183971141d 100644\n--- a/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImpl.kt\n+++ b/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImpl.kt\n@@ -170,19 +170,19 @@ constructor(\n         // Set hasPersistentDot to false. If the animationState is anything before ANIMATING_OUT,\n         // the disappear animation will not animate into a dot but remove the chip entirely\n         hasPersistentDot = false\n-        // if we are currently showing a persistent dot, hide it\n-        if (animationState.value == SHOWING_PERSISTENT_DOT) notifyHidePersistentDot()\n-        // if we are currently animating into a dot, wait for the animation to finish and then hide\n-        // the dot\n-        if (animationState.value == ANIMATING_OUT) {\n-            coroutineScope.launch {\n-                withTimeout(DISAPPEAR_ANIMATION_DURATION) {\n-                    animationState.first {\n-                        it == SHOWING_PERSISTENT_DOT || it == IDLE || it == ANIMATION_QUEUED\n-                    }\n-                    notifyHidePersistentDot()\n-                }\n+\n+        if (animationState.value == SHOWING_PERSISTENT_DOT) {\n+            // if we are currently showing a persistent dot, hide it and update the animationState\n+            notifyHidePersistentDot()\n+            if (scheduledEvent.value != null) {\n+                animationState.value = ANIMATION_QUEUED\n+            } else {\n+                animationState.value = IDLE\n             }\n+        } else if (animationState.value == ANIMATING_OUT) {\n+            // if we are currently animating out, hide the dot. The animationState will be updated\n+            // once the animation has ended in the onAnimationEnd callback\n+            notifyHidePersistentDot()\n         }\n     }\n \n@@ -366,14 +366,6 @@ constructor(\n         logger?.logHidePersistentDotCallbackInvoked()\n         val anims: List<Animator> = listeners.mapNotNull { it.onHidePersistentDot() }\n \n-        if (animationState.value == SHOWING_PERSISTENT_DOT) {\n-            if (scheduledEvent.value != null) {\n-                animationState.value = ANIMATION_QUEUED\n-            } else {\n-                animationState.value = IDLE\n-            }\n-        }\n-\n         if (anims.isNotEmpty()) {\n             val aSet = AnimatorSet()\n             aSet.playTogether(anims)\ndiff --git a/packages/SystemUI/tests/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImplTest.kt b/packages/SystemUI/tests/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImplTest.kt\nindex 2af0cebf3519..d1267669a129 100644\n--- a/packages/SystemUI/tests/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImplTest.kt\n+++ b/packages/SystemUI/tests/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImplTest.kt\n@@ -400,15 +400,16 @@ class SystemStatusAnimationSchedulerImplTest : SysuiTestCase() {\n \n         // remove persistent dot\n         systemStatusAnimationScheduler.removePersistentDot()\n-        testScheduler.runCurrent()\n+\n+        // verify that the onHidePersistentDot callback is invoked\n+        verify(listener, times(1)).onHidePersistentDot()\n \n         // skip disappear animation\n         animatorTestRule.advanceTimeBy(DISAPPEAR_ANIMATION_DURATION)\n         testScheduler.runCurrent()\n \n-        // verify that animationState changes to IDLE and onHidePersistentDot callback is invoked\n+        // verify that animationState changes to IDLE\n         assertEquals(IDLE, systemStatusAnimationScheduler.getAnimationState())\n-        verify(listener, times(1)).onHidePersistentDot()\n     }\n \n     @Test\n@@ -473,7 +474,6 @@ class SystemStatusAnimationSchedulerImplTest : SysuiTestCase() {\n \n         // request removal of persistent dot\n         systemStatusAnimationScheduler.removePersistentDot()\n-        testScheduler.runCurrent()\n \n         // schedule another high priority event while the event is animating out\n         createAndScheduleFakePrivacyEvent()\n@@ -489,6 +489,42 @@ class SystemStatusAnimationSchedulerImplTest : SysuiTestCase() {\n         verify(listener, times(1)).onHidePersistentDot()\n     }\n \n+    @Test\n+    fun testDotIsRemoved_evenIfAnimatorCallbackIsDelayed() = runTest {\n+        // Instantiate class under test with TestScope from runTest\n+        initializeSystemStatusAnimationScheduler(testScope = this)\n+\n+        // create and schedule high priority event\n+        createAndScheduleFakePrivacyEvent()\n+\n+        // skip chip animation lifecycle and fast forward to ANIMATING_OUT state\n+        fastForwardAnimationToState(ANIMATING_OUT)\n+        assertEquals(ANIMATING_OUT, systemStatusAnimationScheduler.getAnimationState())\n+        verify(listener, times(1)).onSystemStatusAnimationTransitionToPersistentDot(any())\n+\n+        // request removal of persistent dot\n+        systemStatusAnimationScheduler.removePersistentDot()\n+\n+        // verify that the state is still ANIMATING_OUT\n+        assertEquals(ANIMATING_OUT, systemStatusAnimationScheduler.getAnimationState())\n+\n+        // skip disappear animation duration\n+        testScheduler.advanceTimeBy(DISAPPEAR_ANIMATION_DURATION + 1)\n+        // In an old implementation this would trigger a coroutine timeout causing the\n+        // onHidePersistentDot callback to be missed.\n+        testScheduler.runCurrent()\n+\n+        // advance animator time to invoke onAnimationEnd callback\n+        animatorTestRule.advanceTimeBy(DISAPPEAR_ANIMATION_DURATION)\n+        testScheduler.runCurrent()\n+\n+        // verify that onHidePersistentDot is invoked despite the animator callback being delayed\n+        // (it's invoked more than DISAPPEAR_ANIMATION_DURATION after the dot removal was requested)\n+        verify(listener, times(1)).onHidePersistentDot()\n+        // verify that animationState is IDLE\n+        assertEquals(IDLE, systemStatusAnimationScheduler.getAnimationState())\n+    }\n+\n     private fun TestScope.fastForwardAnimationToState(@SystemAnimationState animationState: Int) {\n         // this function should only be called directly after posting a status event\n         assertEquals(ANIMATION_QUEUED, systemStatusAnimationScheduler.getAnimationState())\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 1576,
                        "general": {
                            "word_based": 611,
                            "char_based": 1765
                        },
                        "gemini": 1907
                    },
                    "total_downstream_versions_tested": 1,
                    "successful_patches": 1,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "d027036adf637b5db0f119afef5218b6a8ce37af",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit d027036adf637b5db0f119afef5218b6a8ce37af\nAuthor: Johannes Gallmann <gallmann@google.com>\nDate:   Fri Jul 21 15:58:11 2023 +0200\n\n    Fix persistent dot not removed due to race condition in scheduler\n    \n    Bug: 300741186\n    Test: atest SystemStatusAnimationSchedulerImplTest\n    Merged-In: I7380cb956b48c38bdd540b297287786cf35b94f2\n    Change-Id: I7380cb956b48c38bdd540b297287786cf35b94f2\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImpl.kt b/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImpl.kt\nindex 68321f433c81..28b00b738a66 100644\n--- a/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImpl.kt\n+++ b/packages/SystemUI/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImpl.kt\n@@ -182,19 +182,19 @@ constructor(\n         // Set hasPersistentDot to false. If the animationState is anything before ANIMATING_OUT,\n         // the disappear animation will not animate into a dot but remove the chip entirely\n         hasPersistentDot = false\n-        // if we are currently showing a persistent dot, hide it\n-        if (animationState.value == SHOWING_PERSISTENT_DOT) notifyHidePersistentDot()\n-        // if we are currently animating into a dot, wait for the animation to finish and then hide\n-        // the dot\n-        if (animationState.value == ANIMATING_OUT) {\n-            coroutineScope.launch {\n-                withTimeout(DISAPPEAR_ANIMATION_DURATION) {\n-                    animationState.first {\n-                        it == SHOWING_PERSISTENT_DOT || it == IDLE || it == ANIMATION_QUEUED\n-                    }\n-                    notifyHidePersistentDot()\n-                }\n+\n+        if (animationState.value == SHOWING_PERSISTENT_DOT) {\n+            // if we are currently showing a persistent dot, hide it and update the animationState\n+            notifyHidePersistentDot()\n+            if (scheduledEvent.value != null) {\n+                animationState.value = ANIMATION_QUEUED\n+            } else {\n+                animationState.value = IDLE\n             }\n+        } else if (animationState.value == ANIMATING_OUT) {\n+            // if we are currently animating out, hide the dot. The animationState will be updated\n+            // once the animation has ended in the onAnimationEnd callback\n+            notifyHidePersistentDot()\n         }\n     }\n \n@@ -376,14 +376,6 @@ constructor(\n         Assert.isMainThread()\n         val anims: List<Animator> = listeners.mapNotNull { it.onHidePersistentDot() }\n \n-        if (animationState.value == SHOWING_PERSISTENT_DOT) {\n-            if (scheduledEvent.value != null) {\n-                animationState.value = ANIMATION_QUEUED\n-            } else {\n-                animationState.value = IDLE\n-            }\n-        }\n-\n         if (anims.isNotEmpty()) {\n             val aSet = AnimatorSet()\n             aSet.playTogether(anims)\ndiff --git a/packages/SystemUI/tests/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImplTest.kt b/packages/SystemUI/tests/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImplTest.kt\nindex 8a6dfe518cbf..1079a7df8842 100644\n--- a/packages/SystemUI/tests/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImplTest.kt\n+++ b/packages/SystemUI/tests/src/com/android/systemui/statusbar/events/SystemStatusAnimationSchedulerImplTest.kt\n@@ -410,15 +410,16 @@ class SystemStatusAnimationSchedulerImplTest : SysuiTestCase() {\n \n         // remove persistent dot\n         systemStatusAnimationScheduler.removePersistentDot()\n-        testScheduler.runCurrent()\n+\n+        // verify that the onHidePersistentDot callback is invoked\n+        verify(listener, times(1)).onHidePersistentDot()\n \n         // skip disappear animation\n         animatorTestRule.advanceTimeBy(DISAPPEAR_ANIMATION_DURATION)\n         testScheduler.runCurrent()\n \n-        // verify that animationState changes to IDLE and onHidePersistentDot callback is invoked\n+        // verify that animationState changes to IDLE\n         assertEquals(IDLE, systemStatusAnimationScheduler.getAnimationState())\n-        verify(listener, times(1)).onHidePersistentDot()\n     }\n \n     @Test\n@@ -483,7 +484,6 @@ class SystemStatusAnimationSchedulerImplTest : SysuiTestCase() {\n \n         // request removal of persistent dot\n         systemStatusAnimationScheduler.removePersistentDot()\n-        testScheduler.runCurrent()\n \n         // schedule another high priority event while the event is animating out\n         createAndScheduleFakePrivacyEvent()\n@@ -499,6 +499,42 @@ class SystemStatusAnimationSchedulerImplTest : SysuiTestCase() {\n         verify(listener, times(1)).onHidePersistentDot()\n     }\n \n+    @Test\n+    fun testDotIsRemoved_evenIfAnimatorCallbackIsDelayed() = runTest {\n+        // Instantiate class under test with TestScope from runTest\n+        initializeSystemStatusAnimationScheduler(testScope = this)\n+\n+        // create and schedule high priority event\n+        createAndScheduleFakePrivacyEvent()\n+\n+        // skip chip animation lifecycle and fast forward to ANIMATING_OUT state\n+        fastForwardAnimationToState(ANIMATING_OUT)\n+        assertEquals(ANIMATING_OUT, systemStatusAnimationScheduler.getAnimationState())\n+        verify(listener, times(1)).onSystemStatusAnimationTransitionToPersistentDot(any())\n+\n+        // request removal of persistent dot\n+        systemStatusAnimationScheduler.removePersistentDot()\n+\n+        // verify that the state is still ANIMATING_OUT\n+        assertEquals(ANIMATING_OUT, systemStatusAnimationScheduler.getAnimationState())\n+\n+        // skip disappear animation duration\n+        testScheduler.advanceTimeBy(DISAPPEAR_ANIMATION_DURATION + 1)\n+        // In an old implementation this would trigger a coroutine timeout causing the\n+        // onHidePersistentDot callback to be missed.\n+        testScheduler.runCurrent()\n+\n+        // advance animator time to invoke onAnimationEnd callback\n+        animatorTestRule.advanceTimeBy(DISAPPEAR_ANIMATION_DURATION)\n+        testScheduler.runCurrent()\n+\n+        // verify that onHidePersistentDot is invoked despite the animator callback being delayed\n+        // (it's invoked more than DISAPPEAR_ANIMATION_DURATION after the dot removal was requested)\n+        verify(listener, times(1)).onHidePersistentDot()\n+        // verify that animationState is IDLE\n+        assertEquals(IDLE, systemStatusAnimationScheduler.getAnimationState())\n+    }\n+\n     private fun TestScope.fastForwardAnimationToState(@SystemAnimationState animationState: Int) {\n         // this function should only be called directly after posting a status event\n         assertEquals(ANIMATION_QUEUED, systemStatusAnimationScheduler.getAnimationState())\n",
                            "downstream_patch_tokens": {
                                "openai": 1523,
                                "general": {
                                    "word_based": 586,
                                    "char_based": 1713
                                },
                                "gemini": 1849
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-321941232",
            "aliases": [
                "A-321941232",
                "CVE-2024-31316"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-321941232",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "36db8a1d61a881f89fdd3911886adcda6e1f0d7f"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 36db8a1d61a881f89fdd3911886adcda6e1f0d7f Mon Sep 17 00:00:00 2001\nFrom: Dmitry Dementyev <dementyev@google.com>\nDate: Tue, 26 Mar 2024 10:31:44 -0700\nSubject: [PATCH] Add more checkKeyIntent checks to AccountManagerService.\n\nAnother verification is needed after Bundle modification.\nBug: 321941232\nTest: manual\n\nChange-Id: I9e45d758a2320328da5664b6341eafe6f285f297\n---\n .../android/server/accounts/AccountManagerService.java | 10 ++++++++++\n 1 file changed, 10 insertions(+)\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex d9153fe44868..43944b050de4 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -3558,6 +3558,11 @@ public class AccountManagerService\n \n             // Strip auth token from result.\n             result.remove(AccountManager.KEY_AUTHTOKEN);\n+            if (!checkKeyIntent(Binder.getCallingUid(), result)) {\n+                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n+                        \"invalid intent in bundle returned\");\n+                return;\n+            }\n \n             if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                 Log.v(TAG,\n@@ -5135,6 +5140,11 @@ public class AccountManagerService\n                     } else {\n                         if (mStripAuthTokenFromResult) {\n                             result.remove(AccountManager.KEY_AUTHTOKEN);\n+                            if (!checkKeyIntent(Binder.getCallingUid(), result)) {\n+                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n+                                        \"invalid intent in bundle returned\");\n+                                return;\n+                            }\n                         }\n                         if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                             Log.v(TAG, getClass().getSimpleName()\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 467,
                        "general": {
                            "word_based": 187,
                            "char_based": 514
                        },
                        "gemini": 629
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "36db8a1d61a881f89fdd3911886adcda6e1f0d7f",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 36db8a1d61a881f89fdd3911886adcda6e1f0d7f\nAuthor: Dmitry Dementyev <dementyev@google.com>\nDate:   Tue Mar 26 10:31:44 2024 -0700\n\n    Add more checkKeyIntent checks to AccountManagerService.\n    \n    Another verification is needed after Bundle modification.\n    Bug: 321941232\n    Test: manual\n    \n    Change-Id: I9e45d758a2320328da5664b6341eafe6f285f297\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex d9153fe44868..43944b050de4 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -3558,6 +3558,11 @@ public class AccountManagerService\n \n             // Strip auth token from result.\n             result.remove(AccountManager.KEY_AUTHTOKEN);\n+            if (!checkKeyIntent(Binder.getCallingUid(), result)) {\n+                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n+                        \"invalid intent in bundle returned\");\n+                return;\n+            }\n \n             if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                 Log.v(TAG,\n@@ -5135,6 +5140,11 @@ public class AccountManagerService\n                     } else {\n                         if (mStripAuthTokenFromResult) {\n                             result.remove(AccountManager.KEY_AUTHTOKEN);\n+                            if (!checkKeyIntent(Binder.getCallingUid(), result)) {\n+                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n+                                        \"invalid intent in bundle returned\");\n+                                return;\n+                            }\n                         }\n                         if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                             Log.v(TAG, getClass().getSimpleName()\n",
                            "downstream_patch_tokens": {
                                "openai": 414,
                                "general": {
                                    "word_based": 161,
                                    "char_based": 478
                                },
                                "gemini": 562
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "36db8a1d61a881f89fdd3911886adcda6e1f0d7f",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 36db8a1d61a881f89fdd3911886adcda6e1f0d7f\nAuthor: Dmitry Dementyev <dementyev@google.com>\nDate:   Tue Mar 26 10:31:44 2024 -0700\n\n    Add more checkKeyIntent checks to AccountManagerService.\n    \n    Another verification is needed after Bundle modification.\n    Bug: 321941232\n    Test: manual\n    \n    Change-Id: I9e45d758a2320328da5664b6341eafe6f285f297\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex d9153fe44868..43944b050de4 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -3558,6 +3558,11 @@ public class AccountManagerService\n \n             // Strip auth token from result.\n             result.remove(AccountManager.KEY_AUTHTOKEN);\n+            if (!checkKeyIntent(Binder.getCallingUid(), result)) {\n+                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n+                        \"invalid intent in bundle returned\");\n+                return;\n+            }\n \n             if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                 Log.v(TAG,\n@@ -5135,6 +5140,11 @@ public class AccountManagerService\n                     } else {\n                         if (mStripAuthTokenFromResult) {\n                             result.remove(AccountManager.KEY_AUTHTOKEN);\n+                            if (!checkKeyIntent(Binder.getCallingUid(), result)) {\n+                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n+                                        \"invalid intent in bundle returned\");\n+                                return;\n+                            }\n                         }\n                         if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                             Log.v(TAG, getClass().getSimpleName()\n",
                            "downstream_patch_tokens": {
                                "openai": 414,
                                "general": {
                                    "word_based": 161,
                                    "char_based": 478
                                },
                                "gemini": 562
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "36db8a1d61a881f89fdd3911886adcda6e1f0d7f",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 36db8a1d61a881f89fdd3911886adcda6e1f0d7f\nAuthor: Dmitry Dementyev <dementyev@google.com>\nDate:   Tue Mar 26 10:31:44 2024 -0700\n\n    Add more checkKeyIntent checks to AccountManagerService.\n    \n    Another verification is needed after Bundle modification.\n    Bug: 321941232\n    Test: manual\n    \n    Change-Id: I9e45d758a2320328da5664b6341eafe6f285f297\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex d9153fe44868..43944b050de4 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -3558,6 +3558,11 @@ public class AccountManagerService\n \n             // Strip auth token from result.\n             result.remove(AccountManager.KEY_AUTHTOKEN);\n+            if (!checkKeyIntent(Binder.getCallingUid(), result)) {\n+                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n+                        \"invalid intent in bundle returned\");\n+                return;\n+            }\n \n             if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                 Log.v(TAG,\n@@ -5135,6 +5140,11 @@ public class AccountManagerService\n                     } else {\n                         if (mStripAuthTokenFromResult) {\n                             result.remove(AccountManager.KEY_AUTHTOKEN);\n+                            if (!checkKeyIntent(Binder.getCallingUid(), result)) {\n+                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n+                                        \"invalid intent in bundle returned\");\n+                                return;\n+                            }\n                         }\n                         if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                             Log.v(TAG, getClass().getSimpleName()\n",
                            "downstream_patch_tokens": {
                                "openai": 414,
                                "general": {
                                    "word_based": 161,
                                    "char_based": 478
                                },
                                "gemini": 562
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "36db8a1d61a881f89fdd3911886adcda6e1f0d7f",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 36db8a1d61a881f89fdd3911886adcda6e1f0d7f\nAuthor: Dmitry Dementyev <dementyev@google.com>\nDate:   Tue Mar 26 10:31:44 2024 -0700\n\n    Add more checkKeyIntent checks to AccountManagerService.\n    \n    Another verification is needed after Bundle modification.\n    Bug: 321941232\n    Test: manual\n    \n    Change-Id: I9e45d758a2320328da5664b6341eafe6f285f297\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex d9153fe44868..43944b050de4 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -3558,6 +3558,11 @@ public class AccountManagerService\n \n             // Strip auth token from result.\n             result.remove(AccountManager.KEY_AUTHTOKEN);\n+            if (!checkKeyIntent(Binder.getCallingUid(), result)) {\n+                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n+                        \"invalid intent in bundle returned\");\n+                return;\n+            }\n \n             if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                 Log.v(TAG,\n@@ -5135,6 +5140,11 @@ public class AccountManagerService\n                     } else {\n                         if (mStripAuthTokenFromResult) {\n                             result.remove(AccountManager.KEY_AUTHTOKEN);\n+                            if (!checkKeyIntent(Binder.getCallingUid(), result)) {\n+                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n+                                        \"invalid intent in bundle returned\");\n+                                return;\n+                            }\n                         }\n                         if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                             Log.v(TAG, getClass().getSimpleName()\n",
                            "downstream_patch_tokens": {
                                "openai": 414,
                                "general": {
                                    "word_based": 161,
                                    "char_based": 478
                                },
                                "gemini": 562
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-293199910",
            "aliases": [
                "A-293199910",
                "CVE-2024-40650"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-293199910",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "092668676af741719d50ac0f121a8f8461aa21ad"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 092668676af741719d50ac0f121a8f8461aa21ad Mon Sep 17 00:00:00 2001\nFrom: Chaohui Wang <chaohuiw@google.com>\nDate: Thu, 2 Nov 2023 11:43:00 +0800\nSubject: [PATCH] Limit wifi item edit content's max length to 500\n\nBug: 293199910\nTest: manual - on \"Add network\"\n\nMerged-In: I303b8c6e0f3c3a1174a047ba98f302042e5db9ae\nChange-Id: I303b8c6e0f3c3a1174a047ba98f302042e5db9ae\n(cherry picked from commit 855053ca4124f2d515b21c469096f8c18bd4829d)\n---\n res/values/styles.xml | 1 +\n 1 file changed, 1 insertion(+)\n\ndiff --git a/res/values/styles.xml b/res/values/styles.xml\nindex 7c368d683cb..54b1080ec36 100644\n--- a/res/values/styles.xml\n+++ b/res/values/styles.xml\n@@ -148,6 +148,7 @@\n         <item name=\"android:textAppearance\">@android:style/TextAppearance.DeviceDefault.Medium</item>\n         <item name=\"android:textColorHint\">?android:attr/textColorSecondary</item>\n         <item name=\"android:minHeight\">@dimen/min_tap_target_size</item>\n+        <item name=\"android:maxLength\">500</item>\n     </style>\n \n     <style name=\"wifi_section\">\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 374,
                        "general": {
                            "word_based": 135,
                            "char_based": 266
                        },
                        "gemini": 509
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "092668676af741719d50ac0f121a8f8461aa21ad",
                            "repo_path": "android_repos/Settings",
                            "result": "success",
                            "downstream_patch_content": "commit 092668676af741719d50ac0f121a8f8461aa21ad\nAuthor: Chaohui Wang <chaohuiw@google.com>\nDate:   Thu Nov 2 11:43:00 2023 +0800\n\n    Limit wifi item edit content's max length to 500\n    \n    Bug: 293199910\n    Test: manual - on \"Add network\"\n    \n    Merged-In: I303b8c6e0f3c3a1174a047ba98f302042e5db9ae\n    Change-Id: I303b8c6e0f3c3a1174a047ba98f302042e5db9ae\n    (cherry picked from commit 855053ca4124f2d515b21c469096f8c18bd4829d)\n\ndiff --git a/res/values/styles.xml b/res/values/styles.xml\nindex 7c368d683cb..54b1080ec36 100644\n--- a/res/values/styles.xml\n+++ b/res/values/styles.xml\n@@ -148,6 +148,7 @@\n         <item name=\"android:textAppearance\">@android:style/TextAppearance.DeviceDefault.Medium</item>\n         <item name=\"android:textColorHint\">?android:attr/textColorSecondary</item>\n         <item name=\"android:minHeight\">@dimen/min_tap_target_size</item>\n+        <item name=\"android:maxLength\">500</item>\n     </style>\n \n     <style name=\"wifi_section\">\n",
                            "downstream_patch_tokens": {
                                "openai": 332,
                                "general": {
                                    "word_based": 110,
                                    "char_based": 242
                                },
                                "gemini": 453
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "092668676af741719d50ac0f121a8f8461aa21ad",
                            "repo_path": "android_repos/Settings",
                            "result": "success",
                            "downstream_patch_content": "commit 092668676af741719d50ac0f121a8f8461aa21ad\nAuthor: Chaohui Wang <chaohuiw@google.com>\nDate:   Thu Nov 2 11:43:00 2023 +0800\n\n    Limit wifi item edit content's max length to 500\n    \n    Bug: 293199910\n    Test: manual - on \"Add network\"\n    \n    Merged-In: I303b8c6e0f3c3a1174a047ba98f302042e5db9ae\n    Change-Id: I303b8c6e0f3c3a1174a047ba98f302042e5db9ae\n    (cherry picked from commit 855053ca4124f2d515b21c469096f8c18bd4829d)\n\ndiff --git a/res/values/styles.xml b/res/values/styles.xml\nindex 7c368d683cb..54b1080ec36 100644\n--- a/res/values/styles.xml\n+++ b/res/values/styles.xml\n@@ -148,6 +148,7 @@\n         <item name=\"android:textAppearance\">@android:style/TextAppearance.DeviceDefault.Medium</item>\n         <item name=\"android:textColorHint\">?android:attr/textColorSecondary</item>\n         <item name=\"android:minHeight\">@dimen/min_tap_target_size</item>\n+        <item name=\"android:maxLength\">500</item>\n     </style>\n \n     <style name=\"wifi_section\">\n",
                            "downstream_patch_tokens": {
                                "openai": 332,
                                "general": {
                                    "word_based": 110,
                                    "char_based": 242
                                },
                                "gemini": 453
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "092668676af741719d50ac0f121a8f8461aa21ad",
                            "repo_path": "android_repos/Settings",
                            "result": "success",
                            "downstream_patch_content": "commit 092668676af741719d50ac0f121a8f8461aa21ad\nAuthor: Chaohui Wang <chaohuiw@google.com>\nDate:   Thu Nov 2 11:43:00 2023 +0800\n\n    Limit wifi item edit content's max length to 500\n    \n    Bug: 293199910\n    Test: manual - on \"Add network\"\n    \n    Merged-In: I303b8c6e0f3c3a1174a047ba98f302042e5db9ae\n    Change-Id: I303b8c6e0f3c3a1174a047ba98f302042e5db9ae\n    (cherry picked from commit 855053ca4124f2d515b21c469096f8c18bd4829d)\n\ndiff --git a/res/values/styles.xml b/res/values/styles.xml\nindex 7c368d683cb..54b1080ec36 100644\n--- a/res/values/styles.xml\n+++ b/res/values/styles.xml\n@@ -148,6 +148,7 @@\n         <item name=\"android:textAppearance\">@android:style/TextAppearance.DeviceDefault.Medium</item>\n         <item name=\"android:textColorHint\">?android:attr/textColorSecondary</item>\n         <item name=\"android:minHeight\">@dimen/min_tap_target_size</item>\n+        <item name=\"android:maxLength\">500</item>\n     </style>\n \n     <style name=\"wifi_section\">\n",
                            "downstream_patch_tokens": {
                                "openai": 332,
                                "general": {
                                    "word_based": 110,
                                    "char_based": 242
                                },
                                "gemini": 453
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "092668676af741719d50ac0f121a8f8461aa21ad",
                            "repo_path": "android_repos/Settings",
                            "result": "success",
                            "downstream_patch_content": "commit 092668676af741719d50ac0f121a8f8461aa21ad\nAuthor: Chaohui Wang <chaohuiw@google.com>\nDate:   Thu Nov 2 11:43:00 2023 +0800\n\n    Limit wifi item edit content's max length to 500\n    \n    Bug: 293199910\n    Test: manual - on \"Add network\"\n    \n    Merged-In: I303b8c6e0f3c3a1174a047ba98f302042e5db9ae\n    Change-Id: I303b8c6e0f3c3a1174a047ba98f302042e5db9ae\n    (cherry picked from commit 855053ca4124f2d515b21c469096f8c18bd4829d)\n\ndiff --git a/res/values/styles.xml b/res/values/styles.xml\nindex 7c368d683cb..54b1080ec36 100644\n--- a/res/values/styles.xml\n+++ b/res/values/styles.xml\n@@ -148,6 +148,7 @@\n         <item name=\"android:textAppearance\">@android:style/TextAppearance.DeviceDefault.Medium</item>\n         <item name=\"android:textColorHint\">?android:attr/textColorSecondary</item>\n         <item name=\"android:minHeight\">@dimen/min_tap_target_size</item>\n+        <item name=\"android:maxLength\">500</item>\n     </style>\n \n     <style name=\"wifi_section\">\n",
                            "downstream_patch_tokens": {
                                "openai": 332,
                                "general": {
                                    "word_based": 110,
                                    "char_based": 242
                                },
                                "gemini": 453
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-298635078",
            "aliases": [
                "A-298635078",
                "CVE-2024-0022"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-298635078",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "38e1e9fb0357a3d0af5551cac83ad9b0b1fd0be2"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 38e1e9fb0357a3d0af5551cac83ad9b0b1fd0be2 Mon Sep 17 00:00:00 2001\nFrom: Evan Chen <evanxinchen@google.com>\nDate: Tue, 17 Oct 2023 21:31:23 +0000\nSubject: [PATCH] Do not allow setting notification access across users.\n\nFor mutil user case, make sure the calling userid\nmatching the passing userid\n\nTest: test it on sample app\nBug: 298635078\nChange-Id: I6c478ebcc1d981faf2d125a4b41909c3b6a30a2a\n---\n .../server/companion/CompanionDeviceManagerService.java   | 8 +++-----\n 1 file changed, 3 insertions(+), 5 deletions(-)\n\ndiff --git a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\nindex c79149816b1a..2c608930b391 100644\n--- a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n+++ b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n@@ -756,8 +756,7 @@ public class CompanionDeviceManagerService extends SystemService {\n         public PendingIntent requestNotificationAccess(ComponentName component, int userId)\n                 throws RemoteException {\n             String callingPackage = component.getPackageName();\n-            checkCanCallNotificationApi(callingPackage);\n-            // TODO: check userId.\n+            checkCanCallNotificationApi(callingPackage, userId);\n             if (component.flattenToString().length() > MAX_CN_LENGTH) {\n                 throw new IllegalArgumentException(\"Component name is too long.\");\n             }\n@@ -783,7 +782,7 @@ public class CompanionDeviceManagerService extends SystemService {\n         @Deprecated\n         @Override\n         public boolean hasNotificationAccess(ComponentName component) throws RemoteException {\n-            checkCanCallNotificationApi(component.getPackageName());\n+            checkCanCallNotificationApi(component.getPackageName(), getCallingUserId());\n             NotificationManager nm = getContext().getSystemService(NotificationManager.class);\n             return nm.isNotificationListenerAccessGranted(component);\n         }\n@@ -1017,8 +1016,7 @@ public class CompanionDeviceManagerService extends SystemService {\n             createNewAssociation(userId, packageName, macAddressObj, null, null, false);\n         }\n \n-        private void checkCanCallNotificationApi(String callingPackage) {\n-            final int userId = getCallingUserId();\n+        private void checkCanCallNotificationApi(String callingPackage, int userId) {\n             enforceCallerIsSystemOr(userId, callingPackage);\n \n             if (getCallingUid() == SYSTEM_UID) return;\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 604,
                        "general": {
                            "word_based": 239,
                            "char_based": 669
                        },
                        "gemini": 735
                    },
                    "total_downstream_versions_tested": 2,
                    "successful_patches": 2,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "15eec4872d7b0fdfead3a8f5b4a1bb4d9ad82a0c",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 15eec4872d7b0fdfead3a8f5b4a1bb4d9ad82a0c\nAuthor: Evan Chen <evanxinchen@google.com>\nDate:   Tue Oct 17 21:31:23 2023 +0000\n\n    Do not allow setting notification access across users.\n    \n    For mutil user case, make sure the calling userid\n    matching the passing userid\n    \n    Test: test it on sample app\n    Bug: 298635078\n    Change-Id: I6c478ebcc1d981faf2d125a4b41909c3b6a30a2a\n    Merged-In: I6c478ebcc1d981faf2d125a4b41909c3b6a30a2a\n\ndiff --git a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\nindex 3ac7b8e6668e..5f6211f158c2 100644\n--- a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n+++ b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n@@ -543,8 +543,7 @@ public class CompanionDeviceManagerService extends SystemService {\n         public PendingIntent requestNotificationAccess(ComponentName component, int userId)\n                 throws RemoteException {\n             String callingPackage = component.getPackageName();\n-            checkCanCallNotificationApi(callingPackage);\n-            // TODO: check userId.\n+            checkCanCallNotificationApi(callingPackage, userId);\n             if (component.flattenToString().length() > MAX_CN_LENGTH) {\n                 throw new IllegalArgumentException(\"Component name is too long.\");\n             }\n@@ -570,7 +569,7 @@ public class CompanionDeviceManagerService extends SystemService {\n         @Deprecated\n         @Override\n         public boolean hasNotificationAccess(ComponentName component) throws RemoteException {\n-            checkCanCallNotificationApi(component.getPackageName());\n+            checkCanCallNotificationApi(component.getPackageName(), getCallingUserId());\n             NotificationManager nm = getContext().getSystemService(NotificationManager.class);\n             return nm.isNotificationListenerAccessGranted(component);\n         }\n@@ -727,8 +726,7 @@ public class CompanionDeviceManagerService extends SystemService {\n             legacyCreateAssociation(userId, macAddress, packageName, null);\n         }\n \n-        private void checkCanCallNotificationApi(String callingPackage) {\n-            final int userId = getCallingUserId();\n+        private void checkCanCallNotificationApi(String callingPackage, int userId) {\n             enforceCallerIsSystemOr(userId, callingPackage);\n \n             if (getCallingUid() == SYSTEM_UID) return;\n",
                            "downstream_patch_tokens": {
                                "openai": 577,
                                "general": {
                                    "word_based": 213,
                                    "char_based": 640
                                },
                                "gemini": 704
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "12bb4ed9ab46d3e42326ef1c5e7b90aae80a9bfc",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 12bb4ed9ab46d3e42326ef1c5e7b90aae80a9bfc\nAuthor: Evan Chen <evanxinchen@google.com>\nDate:   Tue Oct 17 21:31:23 2023 +0000\n\n    Do not allow setting notification access across users.\n    \n    For mutil user case, make sure the calling userid\n    matching the passing userid\n    \n    Test: test it on sample app\n    Bug: 298635078\n    Change-Id: I6c478ebcc1d981faf2d125a4b41909c3b6a30a2a\n    Merged-In: I6c478ebcc1d981faf2d125a4b41909c3b6a30a2a\n\ndiff --git a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\nindex 0a617cdd2168..5c36a6b07392 100644\n--- a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n+++ b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n@@ -685,8 +685,7 @@ public class CompanionDeviceManagerService extends SystemService {\n         public PendingIntent requestNotificationAccess(ComponentName component, int userId)\n                 throws RemoteException {\n             String callingPackage = component.getPackageName();\n-            checkCanCallNotificationApi(callingPackage);\n-            // TODO: check userId.\n+            checkCanCallNotificationApi(callingPackage, userId);\n             if (component.flattenToString().length() > MAX_CN_LENGTH) {\n                 throw new IllegalArgumentException(\"Component name is too long.\");\n             }\n@@ -712,7 +711,7 @@ public class CompanionDeviceManagerService extends SystemService {\n         @Deprecated\n         @Override\n         public boolean hasNotificationAccess(ComponentName component) throws RemoteException {\n-            checkCanCallNotificationApi(component.getPackageName());\n+            checkCanCallNotificationApi(component.getPackageName(), getCallingUserId());\n             NotificationManager nm = getContext().getSystemService(NotificationManager.class);\n             return nm.isNotificationListenerAccessGranted(component);\n         }\n@@ -908,8 +907,7 @@ public class CompanionDeviceManagerService extends SystemService {\n             createNewAssociation(userId, packageName, macAddressObj, null, null, false);\n         }\n \n-        private void checkCanCallNotificationApi(String callingPackage) {\n-            final int userId = getCallingUserId();\n+        private void checkCanCallNotificationApi(String callingPackage, int userId) {\n             enforceCallerIsSystemOr(userId, callingPackage);\n \n             if (getCallingUid() == SYSTEM_UID) return;\n",
                            "downstream_patch_tokens": {
                                "openai": 578,
                                "general": {
                                    "word_based": 215,
                                    "char_based": 643
                                },
                                "gemini": 709
                            }
                        }
                    ]
                }
            ]
        }
    ],
    "vulnerabilities_skipped": [
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-326057017",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-344620577",
            "skipped": true,
            "error": "Filtered patch is empty"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-298094386",
            "skipped": true,
            "error": "[Errno 2] No such file or directory: 'android_repos/base/services/core/java/com/android/server/am/ServiceRecord.java.rej'"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-292160348",
            "skipped": true,
            "error": "[Errno 2] No such file or directory: 'android_repos/StatsD/statsd/src/StatsService.h.rej'"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-350118416",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-269271098",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-304983146",
            "skipped": true,
            "error": "503 Getting metadata from plugin failed with error: HTTPSConnectionPool(host='oauth2.googleapis.com', port=443): Max retries exceeded with url: /token (Caused by NewConnectionError('<urllib3.connection.HTTPSConnection object at 0x109765f70>: Failed to establish a new connection: [Errno 8] nodename nor servname provided, or not known'))"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-303871379",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-353712853",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-314333719",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-293602970",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-285142084",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-297524203",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-302431573",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-319081336",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-309938635",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-283099444",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-341256043",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-317357401",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-329058967",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-300090204",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-300904123",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-293602317",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-330054251",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-309426390",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-318374503",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-343714914",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-293301736",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-282934003",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-329641908",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-340239088",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-304280682",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-299614635",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-318497672",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-273935108",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-316891059",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-295887535",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-321707289",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-304082474",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-300007708",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-307948424",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-272106880",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-308414141",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-288549440",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-317780080",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-295549388",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-327749022",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-305926929",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-276442130",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-329701910",
            "skipped": true,
            "error": "Command '['git', 'fetch', '--all']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-279169188",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-327645387",
            "skipped": true,
            "error": "Filtered patch is empty"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-305664128",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-353700779",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-304290201",
            "skipped": true,
            "error": "[Errno 2] No such file or directory: 'android_repos/base/services/core/java/com/android/server/pm/ShortcutService.java.rej'"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-348352288",
            "skipped": true,
            "error": "[Errno 2] No such file or directory: 'android_repos/Wifi/service/java/com/android/server/wifi/WifiServiceImpl.java.rej'"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-349678452",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-336490997",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-299931076",
            "skipped": true,
            "error": "[Errno 2] No such file or directory: 'android_repos/Settings/src/com/android/settings/wifi/dpp/WifiDppConfiguratorActivity.java.rej'"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-352631932",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-304772709",
            "skipped": true,
            "error": "Filtered patch is empty"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-232798676",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-329230490",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-296915959",
            "skipped": true,
            "error": "No upstream fixes found"
        }
    ],
    "commit_mismatch_vulnerabilities": [
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-313425281",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-313425281",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                }
            ],
            "matched_versions": []
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-279428283",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-279428283",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "12",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12L",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                }
            ],
            "matched_versions": []
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-284297452",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-284297452",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "12",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12L",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                }
            ],
            "matched_versions": []
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-294609150",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-294609150",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "11",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12L",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                }
            ],
            "matched_versions": []
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-297517712",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-297517712",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "12",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12L",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                }
            ],
            "matched_versions": []
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-222446076",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-222446076",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "12L",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 3
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                }
            ],
            "matched_versions": [
                "11",
                "12",
                "13"
            ]
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-347307756",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-347307756",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 4,
                    "downstream_commit_count": 3
                }
            ],
            "matched_versions": []
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-307288067",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-307288067",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "12",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12L",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                }
            ],
            "matched_versions": []
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-317503801",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-317503801",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "12",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12L",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                }
            ],
            "matched_versions": []
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-316893159",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-316893159",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "12",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12L",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                }
            ],
            "matched_versions": []
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-223376078",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-223376078",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "12",
                    "upstream_commit_count": 1,
                    "downstream_commit_count": 2
                },
                {
                    "downstream_version": "12L",
                    "upstream_commit_count": 1,
                    "downstream_commit_count": 2
                }
            ],
            "matched_versions": [
                "13"
            ]
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-281044385",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-281044385",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                }
            ],
            "matched_versions": []
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-336976105",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-336976105",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 3,
                    "downstream_commit_count": 1
                }
            ],
            "matched_versions": []
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-261721900",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-261721900",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "12",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12L",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                }
            ],
            "matched_versions": []
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-324321147",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-324321147",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "12",
                    "upstream_commit_count": 5,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12",
                    "upstream_commit_count": 5,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12L",
                    "upstream_commit_count": 5,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12L",
                    "upstream_commit_count": 5,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 5,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 5,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 5,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 5,
                    "downstream_commit_count": 1
                }
            ],
            "matched_versions": []
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-218495634",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-218495634",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 4,
                    "downstream_commit_count": 3
                }
            ],
            "matched_versions": [
                "12",
                "12L",
                "13"
            ]
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-360807442",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-360807442",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                }
            ],
            "matched_versions": []
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-319210610",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-319210610",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "12",
                    "upstream_commit_count": 7,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12",
                    "upstream_commit_count": 7,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12L",
                    "upstream_commit_count": 7,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12L",
                    "upstream_commit_count": 7,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 7,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 7,
                    "downstream_commit_count": 2
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 7,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 7,
                    "downstream_commit_count": 2
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 7,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 7,
                    "downstream_commit_count": 1
                }
            ],
            "matched_versions": []
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-279055389",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-279055389",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "11",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "11",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12L",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12L",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                }
            ],
            "matched_versions": []
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-225880325",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-225880325",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                }
            ],
            "matched_versions": [
                "12",
                "12L",
                "13"
            ]
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-308138085",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-308138085",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "12",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12L",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                }
            ],
            "matched_versions": []
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-336648613",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-336648613",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                }
            ],
            "matched_versions": []
        }
    ]
}