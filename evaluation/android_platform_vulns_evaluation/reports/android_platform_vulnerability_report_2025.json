{
    "summary": {
        "total_vulnerabilities_tested": 33,
        "total_downstream_versions_tested": 77,
        "total_failed_patches": 30,
        "total_unique_downstream_versions_tested": 0,
        "total_unique_downstream_failed_patches": 0,
        "vulnerabilities_with_all_failures": 16,
        "vulnerabilities_with_partial_failures": 4,
        "vulnerabilities_with_all_successful_patches": 13,
        "vulnerabilities_skipped": 7,
        "vulnerabilities_with_commit_mismatch": 6,
        "per_version_stats": {
            "12": {
                "total_downstreams_tested": 17,
                "total_failed_patches": 6
            },
            "12L": {
                "total_downstreams_tested": 17,
                "total_failed_patches": 6
            },
            "13": {
                "total_downstreams_tested": 23,
                "total_failed_patches": 10
            },
            "14": {
                "total_downstreams_tested": 20,
                "total_failed_patches": 8
            }
        },
        "total_tokens": {
            "upstream_patch": {
                "gemini": 58323,
                "openai": 46376,
                "general_word": 18319,
                "general_char": 45865
            },
            "downstream_patch": {
                "gemini": 114839,
                "openai": 92013,
                "general_word": 36528,
                "general_char": 98001
            },
            "upstream_source": {
                "gemini": 724338,
                "openai": 601109,
                "general_word": 234602,
                "general_char": 771132
            },
            "downstream_source": {
                "gemini": 575982,
                "openai": 475744,
                "general_word": 187625,
                "general_char": 606926
            },
            "rej_file": {
                "gemini": 9204,
                "openai": 7268,
                "general_word": 3087,
                "general_char": 8220
            },
            "inline_merge_conflict": {
                "gemini": 1961,
                "openai": 1478,
                "general_word": 423,
                "general_char": 1416
            }
        },
        "average_tokens_per_downstream_version": {
            "upstream_patch": {
                "gemini": 757.44,
                "openai": 602.29,
                "general_word": 237.91,
                "general_char": 595.65
            },
            "downstream_patch": {
                "gemini": 1491.42,
                "openai": 1194.97,
                "general_word": 474.39,
                "general_char": 1272.74
            },
            "upstream_source": {
                "gemini": 9406.99,
                "openai": 7806.61,
                "general_word": 3046.78,
                "general_char": 10014.7
            },
            "downstream_source": {
                "gemini": 7480.29,
                "openai": 6178.49,
                "general_word": 2436.69,
                "general_char": 7882.16
            },
            "rej_file": {
                "gemini": 119.53,
                "openai": 94.39,
                "general_word": 40.09,
                "general_char": 106.75
            },
            "inline_merge_conflict": {
                "gemini": 25.47,
                "openai": 19.19,
                "general_word": 5.49,
                "general_char": 18.39
            }
        }
    },
    "vulnerabilities_with_all_failures": [
        {
            "id": "ASB-A-370962373",
            "aliases": [
                "A-370962373",
                "CVE-2025-0099"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-370962373",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "692cddfb32abae6c77b00c4850fd36b7eaaf8c70"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 692cddfb32abae6c77b00c4850fd36b7eaaf8c70 Mon Sep 17 00:00:00 2001\nFrom: Raphael Kim <raphk@google.com>\nDate: Wed, 16 Oct 2024 14:42:21 -0700\nSubject: [PATCH] [CDM] Check for system calling UID when backing up and\n restoring data\n\nBug: 370962373\nTest: Manual test on POC\nFlag: EXEMPT bugfix\nChange-Id: I307940b7194dd17eacbbfb8be5c92ac21e688c65\n---\n .../server/companion/CompanionDeviceManagerService.java     | 6 ++++++\n 1 file changed, 6 insertions(+)\n\ndiff --git a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\nindex 95281c81fc33..591107010431 100644\n--- a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n+++ b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n@@ -715,11 +715,17 @@ public class CompanionDeviceManagerService extends SystemService {\n \n         @Override\n         public byte[] getBackupPayload(int userId) {\n+            if (getCallingUid() != SYSTEM_UID) {\n+                throw new SecurityException(\"Caller must be system\");\n+            }\n             return mBackupRestoreProcessor.getBackupPayload(userId);\n         }\n \n         @Override\n         public void applyRestoredPayload(byte[] payload, int userId) {\n+            if (getCallingUid() != SYSTEM_UID) {\n+                throw new SecurityException(\"Caller must be system\");\n+            }\n             mBackupRestoreProcessor.applyRestoredPayload(payload, userId);\n         }\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 422,
                        "general": {
                            "word_based": 164,
                            "char_based": 401
                        },
                        "gemini": 534
                    },
                    "total_downstream_versions_tested": 0,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": []
                }
            ]
        },
        {
            "id": "ASB-A-375404242",
            "aliases": [
                "A-375404242",
                "CVE-2025-22412"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-375404242",
            "severity": "Critical",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "00555617ddbbc1a19089104c084d14f465c971ce"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 00555617ddbbc1a19089104c084d14f465c971ce Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Sat, 2 Nov 2024 02:29:10 +0000\nSubject: [PATCH] Fix more memory-unsafe logging\n\nIn various locations around the stack, log statements use structures that\nmay, in exceptional cases, have been freed by preceding calls.  This can\nlead to use after free and potentially to security vulnerabilities.\n\nUse local variables instead, or store the length before the call if no\nlocal variable is already convenient.\n\nBug: 375404242\nBug: 375398779\nBug: 375397720\nBug: 375397164\nBug: 375397370\nBug: 375396810\nBug: 375159652\nBug: 375160214\nBug: 375159480\nTest: m libbluetooth\nTest: researcher POC\nFlag: EXEMPT trivial logic fix\nIgnore-AOSP-First: security\nTag: #security\nChange-Id: Ia50e074de751661a0e617bfffa17871497b8d1ea\n---\n system/stack/avct/avct_lcb_act.cc    | 5 ++++-\n system/stack/bnep/bnep_main.cc       | 4 +++-\n system/stack/bnep/bnep_utils.cc      | 3 ++-\n system/stack/hid/hidd_conn.cc        | 4 ++--\n system/stack/rfcomm/rfc_ts_frames.cc | 3 ++-\n system/stack/rfcomm/rfc_utils.cc     | 3 ++-\n system/stack/sdp/sdp_discovery.cc    | 2 +-\n system/stack/sdp/sdp_server.cc       | 4 ++--\n 8 files changed, 18 insertions(+), 10 deletions(-)\n\ndiff --git a/system/stack/avct/avct_lcb_act.cc b/system/stack/avct/avct_lcb_act.cc\nindex 986bce7d34..32da9d865b 100644\n--- a/system/stack/avct/avct_lcb_act.cc\n+++ b/system/stack/avct/avct_lcb_act.cc\n@@ -727,10 +727,13 @@ void avct_lcb_msg_ind(tAVCT_LCB* p_lcb, tAVCT_LCB_EVT* p_data) {\n     p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n     AVCT_BUILD_HDR(p, label, AVCT_PKT_TYPE_SINGLE, AVCT_REJ);\n     UINT16_TO_BE_STREAM(p, pid);\n+\n+    uint16_t len = p_buf->len;\n+\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_lcb->ch_lcid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} lcid:0x{:04x} len:{}\", p_lcb->peer_addr,\n-                p_lcb->ch_lcid, p_buf->len);\n+                p_lcb->ch_lcid, len);\n     }\n   }\n }\ndiff --git a/system/stack/bnep/bnep_main.cc b/system/stack/bnep/bnep_main.cc\nindex e0e3c4540c..adf3c8666e 100644\n--- a/system/stack/bnep/bnep_main.cc\n+++ b/system/stack/bnep/bnep_main.cc\n@@ -295,10 +295,12 @@ static void bnep_congestion_ind(uint16_t l2cap_cid, bool is_congested) {\n         break;\n       }\n \n+      uint16_t len = p_buf->len;\n+\n       if (stack::l2cap::get_interface().L2CA_DataWrite(l2cap_cid, p_buf) !=\n           tL2CAP_DW_RESULT::SUCCESS) {\n         log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_bcb->rem_bda, l2cap_cid,\n-                  p_buf->len);\n+                  len);\n       }\n     }\n   }\ndiff --git a/system/stack/bnep/bnep_utils.cc b/system/stack/bnep/bnep_utils.cc\nindex 252facf668..4092d9afee 100644\n--- a/system/stack/bnep/bnep_utils.cc\n+++ b/system/stack/bnep/bnep_utils.cc\n@@ -411,10 +411,11 @@ void bnepu_check_send_packet(tBNEP_CONN* p_bcb, BT_HDR* p_buf) {\n       fixed_queue_enqueue(p_bcb->xmit_q, p_buf);\n     }\n   } else {\n+    uint16_t len = p_buf->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_bcb->l2cap_cid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_bcb->rem_bda,\n-                p_bcb->l2cap_cid, p_buf->len);\n+                p_bcb->l2cap_cid, len);\n     }\n   }\n }\ndiff --git a/system/stack/hid/hidd_conn.cc b/system/stack/hid/hidd_conn.cc\nindex c64a7b9104..695e5d6c84 100644\n--- a/system/stack/hid/hidd_conn.cc\n+++ b/system/stack/hid/hidd_conn.cc\n@@ -88,10 +88,10 @@ static void hidd_check_config_done() {\n \n     // send outstanding data on intr\n     if (hd_cb.pending_data) {\n+      uint16_t len = hd_cb.pending_data->len;\n       if (stack::l2cap::get_interface().L2CA_DataWrite(p_hcon->intr_cid, hd_cb.pending_data) !=\n           tL2CAP_DW_RESULT::SUCCESS) {\n-        log::warn(\"Unable to write L2CAP data cid:{} len:{}\", p_hcon->intr_cid,\n-                  hd_cb.pending_data->len);\n+        log::warn(\"Unable to write L2CAP data cid:{} len:{}\", p_hcon->intr_cid, len);\n       }\n       hd_cb.pending_data = NULL;\n     }\ndiff --git a/system/stack/rfcomm/rfc_ts_frames.cc b/system/stack/rfcomm/rfc_ts_frames.cc\nindex ea57abf6dc..e93cfed9b8 100644\n--- a/system/stack/rfcomm/rfc_ts_frames.cc\n+++ b/system/stack/rfcomm/rfc_ts_frames.cc\n@@ -201,10 +201,11 @@ void rfc_send_buf_uih(tRFC_MCB* p_mcb, uint8_t dlci, BT_HDR* p_buf) {\n   if (dlci == RFCOMM_MX_DLCI) {\n     rfc_check_send_cmd(p_mcb, p_buf);\n   } else {\n+    uint16_t len = p_buf->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_mcb->lcid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_mcb->bd_addr, p_mcb->lcid,\n-                p_buf->len);\n+                len);\n     }\n   }\n }\ndiff --git a/system/stack/rfcomm/rfc_utils.cc b/system/stack/rfcomm/rfc_utils.cc\nindex 23420892cb..0c5074db76 100644\n--- a/system/stack/rfcomm/rfc_utils.cc\n+++ b/system/stack/rfcomm/rfc_utils.cc\n@@ -428,9 +428,10 @@ void rfc_check_send_cmd(tRFC_MCB* p_mcb, BT_HDR* p_buf) {\n     if (p == NULL) {\n       break;\n     }\n+    uint16_t len = p->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_mcb->lcid, p) != tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_mcb->bd_addr, p_mcb->lcid,\n-                p->len);\n+                len);\n     }\n   }\n }\ndiff --git a/system/stack/sdp/sdp_discovery.cc b/system/stack/sdp/sdp_discovery.cc\nindex 4fa484e14a..6aba1993af 100644\n--- a/system/stack/sdp/sdp_discovery.cc\n+++ b/system/stack/sdp/sdp_discovery.cc\n@@ -877,7 +877,7 @@ static void process_service_attr_rsp(tCONN_CB* p_ccb, uint8_t* p_reply, uint8_t*\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_msg) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-                p_ccb->connection_id, p_msg->len);\n+                p_ccb->connection_id, p - p_start);\n     }\n \n     /* Start inactivity timer */\ndiff --git a/system/stack/sdp/sdp_server.cc b/system/stack/sdp/sdp_server.cc\nindex abd70aedb1..0f379708e9 100644\n--- a/system/stack/sdp/sdp_server.cc\n+++ b/system/stack/sdp/sdp_server.cc\n@@ -300,7 +300,7 @@ static void process_service_search(tCONN_CB* p_ccb, uint16_t trans_num, uint16_t\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_buf) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_buf->len);\n+              p_ccb->connection_id, p_rsp - p_rsp_start);\n   }\n }\n \n@@ -564,7 +564,7 @@ static void process_service_attr_req(tCONN_CB* p_ccb, uint16_t trans_num, uint16\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_buf) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_buf->len);\n+              p_ccb->connection_id, p_rsp - p_rsp_start);\n   }\n }\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 2404,
                        "general": {
                            "word_based": 853,
                            "char_based": 1793
                        },
                        "gemini": 3096
                    },
                    "total_downstream_versions_tested": 0,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": []
                }
            ]
        },
        {
            "id": "ASB-A-352542820",
            "aliases": [
                "A-352542820",
                "CVE-2025-0094"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-352542820",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "69c7f5dac580361792bbb189178653b297d06c8a"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 69c7f5dac580361792bbb189178653b297d06c8a Mon Sep 17 00:00:00 2001\nFrom: Adam Bookatz <bookatz@google.com>\nDate: Mon, 18 Nov 2024 15:53:41 -0800\nSubject: [PATCH] Don't let profiles open the UserSettings overflow\n\nReally, profiles aren't expected to open Settings at all. But if they\ndo somehow, the overflow shouldn't appear.\n\nBug: 352542820\nFlag: EXEMPT bugfix\nTest: Try to access the overflow of the work profile by launching its Settings in\nadb shell am start --user 10 'com.android.settings/.Settings\\$UserSettingsActivity'\n\nChange-Id: I5e4c095cda3e19fa5c63c2c550a526f5da8ec5c1\n---\n src/com/android/settings/users/UserSettings.java | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/src/com/android/settings/users/UserSettings.java b/src/com/android/settings/users/UserSettings.java\nindex 0881b29a3b3..589f512ac23 100644\n--- a/src/com/android/settings/users/UserSettings.java\n+++ b/src/com/android/settings/users/UserSettings.java\n@@ -465,7 +465,7 @@ public class UserSettings extends SettingsPreferenceFragment\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n         if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx())\n-                && !isCurrentUserGuest()) {\n+                && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 426,
                        "general": {
                            "word_based": 192,
                            "char_based": 399
                        },
                        "gemini": 552
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 0,
                    "failed_patches": 4,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "44a35ac07bcc076871b8054331096aaff8ee10f0",
                            "repo_path": "android_repos/Settings",
                            "result": "failure",
                            "downstream_patch_content": "commit 44a35ac07bcc076871b8054331096aaff8ee10f0\nAuthor: Adam Bookatz <bookatz@google.com>\nDate:   Mon Nov 18 15:53:41 2024 -0800\n\n    Don't let profiles open the UserSettings overflow [DO NOT MERGE]\n    \n    Really, profiles aren't expected to open Settings at all. But if they\n    do somehow, the overflow shouldn't appear.\n    \n    Bug: 352542820\n    Flag: EXEMPT bugfix\n    Test: Try to access the overflow of the work profile by launching its Settings in\n    adb shell am start --user 10 'com.android.settings/.Settings\\$UserSettingsActivity'\n    \n    Change-Id: I5e4c095cda3e19fa5c63c2c550a526f5da8ec5c1\n    Merged-In: I5e4c095cda3e19fa5c63c2c550a526f5da8ec5c1\n    (cherry picked from commit 69c7f5dac580361792bbb189178653b297d06c8a)\n\ndiff --git a/src/com/android/settings/users/UserSettings.java b/src/com/android/settings/users/UserSettings.java\nindex ee23fc379d8..56bdfba3069 100644\n--- a/src/com/android/settings/users/UserSettings.java\n+++ b/src/com/android/settings/users/UserSettings.java\n@@ -358,8 +358,8 @@ public class UserSettings extends SettingsPreferenceFragment\n         int pos = 0;\n         // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n         //  regardless of mGuestUserAutoCreated\n-        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n-                && mGuestUserAutoCreated)) {\n+        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !mUserManager.isProfile()\n+                && !(isCurrentUserGuest() && mGuestUserAutoCreated)) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n",
                            "downstream_patch_tokens": {
                                "openai": 488,
                                "general": {
                                    "word_based": 189,
                                    "char_based": 438
                                },
                                "gemini": 624
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "src/com/android/settings/users/UserSettings.java",
                                    "total_hunks": 1,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [],
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    },
                                    "rej_file_content": "```diff\n--- src/com/android/settings/users/UserSettings.java\n+++ src/com/android/settings/users/UserSettings.java\n@@ -465,7 +465,7 @@ public class UserSettings extends SettingsPreferenceFragment\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n         if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx())\n-                && !isCurrentUserGuest()) {\n+                && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n```",
                                    "rej_file_tokens": {
                                        "openai": 147,
                                        "general": {
                                            "word_based": 59,
                                            "char_based": 179
                                        },
                                        "gemini": 181
                                    },
                                    "patch_apply_output": "patching file src/com/android/settings/users/UserSettings.java\nHunk #1 FAILED at 465.\n1 out of 1 hunk FAILED -- saving rejects to file src/com/android/settings/users/UserSettings.java.rej",
                                    "inline_merge_output": "patching file src/com/android/settings/users/UserSettings.java\nHunk #1 already applied at 468.",
                                    "upstream_file_tokens": {
                                        "openai": 14655,
                                        "general": {
                                            "word_based": 5594,
                                            "char_based": 20370
                                        },
                                        "gemini": 18165
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.users;\n\nimport android.annotation.NonNull;\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.Dialog;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.settings.SettingsEnums;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.drawable.Drawable;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.ContactsContract;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.SparseArray;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.widget.SimpleAdapter;\nimport android.widget.Toast;\n\nimport androidx.annotation.VisibleForTesting;\nimport androidx.annotation.WorkerThread;\nimport androidx.appcompat.app.AlertDialog;\nimport androidx.preference.Preference;\nimport androidx.preference.PreferenceGroup;\nimport androidx.preference.PreferenceScreen;\n\nimport com.android.internal.util.UserIcons;\nimport com.android.internal.widget.LockPatternUtils;\nimport com.android.settings.R;\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsPreferenceFragment;\nimport com.android.settings.Utils;\nimport com.android.settings.core.SubSettingLauncher;\nimport com.android.settings.password.ChooseLockGeneric;\nimport com.android.settings.search.BaseSearchIndexProvider;\nimport com.android.settings.widget.MainSwitchBarController;\nimport com.android.settings.widget.SettingsMainSwitchBar;\nimport com.android.settingslib.RestrictedLockUtils.EnforcedAdmin;\nimport com.android.settingslib.RestrictedLockUtilsInternal;\nimport com.android.settingslib.RestrictedPreference;\nimport com.android.settingslib.drawable.CircleFramedDrawable;\nimport com.android.settingslib.search.SearchIndexable;\nimport com.android.settingslib.users.EditUserInfoController;\nimport com.android.settingslib.users.UserCreatingDialog;\nimport com.android.settingslib.utils.ThreadUtils;\n\nimport com.google.android.setupcompat.util.WizardManagerHelper;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n/**\n * Screen that manages the list of users on the device.\n * Secondary users and a guest user can be created if there is no restriction.\n *\n * The first user in the list is always the current user.\n * Owner is the primary user.\n */\n@SearchIndexable\npublic class UserSettings extends SettingsPreferenceFragment\n        implements Preference.OnPreferenceClickListener,\n        MultiUserSwitchBarController.OnMultiUserSwitchChangedListener,\n        DialogInterface.OnDismissListener {\n\n    private static final String TAG = \"UserSettings\";\n\n    /** UserId of the user being removed */\n    private static final String SAVE_REMOVING_USER = \"removing_user\";\n\n    private static final String KEY_USER_LIST = \"user_list\";\n    private static final String KEY_USER_ME = \"user_me\";\n    private static final String KEY_USER_GUEST = \"user_guest\";\n    private static final String KEY_ADD_GUEST = \"guest_add\";\n    private static final String KEY_ADD_USER = \"user_add\";\n    private static final String KEY_ADD_USER_WHEN_LOCKED = \"user_settings_add_users_when_locked\";\n    private static final String KEY_MULTIUSER_TOP_INTRO = \"multiuser_top_intro\";\n\n    private static final int MENU_REMOVE_USER = Menu.FIRST;\n\n    private static final IntentFilter USER_REMOVED_INTENT_FILTER;\n\n    private static final int DIALOG_CONFIRM_REMOVE = 1;\n    private static final int DIALOG_ADD_USER = 2;\n    // Dialogs with id 3 and 4 got removed\n    private static final int DIALOG_USER_CANNOT_MANAGE = 5;\n    private static final int DIALOG_CHOOSE_USER_TYPE = 6;\n    private static final int DIALOG_NEED_LOCKSCREEN = 7;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST = 8;\n    private static final int DIALOG_USER_PROFILE_EDITOR = 9;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_USER = 10;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE = 11;\n    private static final int DIALOG_CONFIRM_RESET_GUEST = 12;\n\n    private static final int MESSAGE_UPDATE_LIST = 1;\n    private static final int MESSAGE_USER_CREATED = 2;\n\n    private static final int USER_TYPE_USER = 1;\n    private static final int USER_TYPE_RESTRICTED_PROFILE = 2;\n\n    private static final int REQUEST_CHOOSE_LOCK = 10;\n    private static final int REQUEST_EDIT_GUEST = 11;\n\n    static final int RESULT_GUEST_REMOVED = 100;\n\n    private static final String KEY_ADD_USER_LONG_MESSAGE_DISPLAYED =\n            \"key_add_user_long_message_displayed\";\n\n    private static final String KEY_TITLE = \"title\";\n    private static final String KEY_SUMMARY = \"summary\";\n\n    static {\n        USER_REMOVED_INTENT_FILTER = new IntentFilter(Intent.ACTION_USER_REMOVED);\n        USER_REMOVED_INTENT_FILTER.addAction(Intent.ACTION_USER_INFO_CHANGED);\n    }\n\n    @VisibleForTesting\n    PreferenceGroup mUserListCategory;\n    @VisibleForTesting\n    UserPreference mMePreference;\n    @VisibleForTesting\n    RestrictedPreference mAddGuest;\n    @VisibleForTesting\n    RestrictedPreference mAddUser;\n    @VisibleForTesting\n    SparseArray<Bitmap> mUserIcons = new SparseArray<>();\n    private int mRemovingUserId = -1;\n    private boolean mAddingUser;\n    private boolean mGuestUserAutoCreated;\n    private String mAddingUserName;\n    private UserCapabilities mUserCaps;\n    private boolean mShouldUpdateUserList = true;\n    private final Object mUserLock = new Object();\n    private UserManager mUserManager;\n    private static SparseArray<Bitmap> sDarkDefaultUserBitmapCache = new SparseArray<>();\n\n    private MultiUserSwitchBarController mSwitchBarController;\n    private EditUserInfoController mEditUserInfoController =\n            new EditUserInfoController(Utils.FILE_PROVIDER_AUTHORITY);\n    private AddUserWhenLockedPreferenceController mAddUserWhenLockedPreferenceController;\n    private MultiUserTopIntroPreferenceController mMultiUserTopIntroPreferenceController;\n    private UserCreatingDialog mUserCreatingDialog;\n    private final AtomicBoolean mGuestCreationScheduled = new AtomicBoolean();\n    private final ExecutorService mExecutor = Executors.newSingleThreadExecutor();\n\n    private CharSequence mPendingUserName;\n    private Drawable mPendingUserIcon;\n\n    // A place to cache the generated default avatar\n    private Drawable mDefaultIconDrawable;\n\n    // TODO:   Replace current Handler solution to something that doesn't leak memory and works\n    // TODO:   during a configuration change\n    private Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MESSAGE_UPDATE_LIST:\n                    updateUserList();\n                    break;\n                case MESSAGE_USER_CREATED:\n                    onUserCreated(msg.arg1);\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mUserChangeReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(Intent.ACTION_USER_REMOVED)) {\n                mRemovingUserId = -1;\n            } else if (intent.getAction().equals(Intent.ACTION_USER_INFO_CHANGED)) {\n                int userHandle = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);\n                if (userHandle != -1) {\n                    mUserIcons.remove(userHandle);\n                }\n            }\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n        }\n    };\n\n    @Override\n    public int getMetricsCategory() {\n        return SettingsEnums.USER;\n    }\n\n    @Override\n    public void onActivityCreated(Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n        // Assume we are in a SettingsActivity. This is only safe because we currently use\n        // SettingsActivity as base for all preference fragments.\n        final SettingsActivity activity = (SettingsActivity) getActivity();\n        final SettingsMainSwitchBar switchBar = activity.getSwitchBar();\n        switchBar.setTitle(getContext().getString(R.string.multiple_users_main_switch_title));\n        switchBar.show();\n        mSwitchBarController = new MultiUserSwitchBarController(activity,\n                new MainSwitchBarController(switchBar), this /* listener */);\n        getSettingsLifecycle().addObserver(mSwitchBarController);\n    }\n\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        addPreferencesFromResource(R.xml.user_settings);\n        final Activity activity = getActivity();\n        if (!WizardManagerHelper.isDeviceProvisioned(activity)) {\n            activity.finish();\n            return;\n        }\n\n        mGuestUserAutoCreated = getPrefContext().getResources().getBoolean(\n                        com.android.internal.R.bool.config_guestUserAutoCreated);\n\n        mAddUserWhenLockedPreferenceController = new AddUserWhenLockedPreferenceController(\n                activity, KEY_ADD_USER_WHEN_LOCKED);\n\n        mMultiUserTopIntroPreferenceController = new MultiUserTopIntroPreferenceController(activity,\n                KEY_MULTIUSER_TOP_INTRO);\n\n        final PreferenceScreen screen = getPreferenceScreen();\n        mAddUserWhenLockedPreferenceController.displayPreference(screen);\n        mMultiUserTopIntroPreferenceController.displayPreference(screen);\n\n        screen.findPreference(mAddUserWhenLockedPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mAddUserWhenLockedPreferenceController);\n\n        if (icicle != null) {\n            if (icicle.containsKey(SAVE_REMOVING_USER)) {\n                mRemovingUserId = icicle.getInt(SAVE_REMOVING_USER);\n            }\n            mEditUserInfoController.onRestoreInstanceState(icicle);\n        }\n\n        mUserCaps = UserCapabilities.create(activity);\n        mUserManager = (UserManager) activity.getSystemService(Context.USER_SERVICE);\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n\n        final int myUserId = UserHandle.myUserId();\n\n        mUserListCategory = (PreferenceGroup) findPreference(KEY_USER_LIST);\n        mMePreference = new UserPreference(getPrefContext(), null /* attrs */, myUserId);\n        mMePreference.setKey(KEY_USER_ME);\n        mMePreference.setOnPreferenceClickListener(this);\n        if (mUserCaps.mIsAdmin) {\n            mMePreference.setSummary(R.string.user_admin);\n        }\n\n        mAddGuest = findPreference(KEY_ADD_GUEST);\n        mAddGuest.setOnPreferenceClickListener(this);\n\n        mAddUser = findPreference(KEY_ADD_USER);\n        if (!mUserCaps.mCanAddRestrictedProfile) {\n            // Label should only mention adding a \"user\", not a \"profile\"\n            mAddUser.setTitle(R.string.user_add_user_menu);\n        }\n        mAddUser.setOnPreferenceClickListener(this);\n\n        activity.registerReceiverAsUser(\n                mUserChangeReceiver, UserHandle.ALL, USER_REMOVED_INTENT_FILTER, null, mHandler);\n\n        updateUI();\n        mShouldUpdateUserList = false;\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n        final PreferenceScreen screen = getPreferenceScreen();\n\n        mAddUserWhenLockedPreferenceController.updateState(screen.findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey()));\n\n        if (mShouldUpdateUserList) {\n            updateUI();\n        }\n    }\n\n    @Override\n    public void onPause() {\n        mShouldUpdateUserList = true;\n        super.onPause();\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n\n        if (mUserCaps == null || !mUserCaps.mEnabled) {\n            return;\n        }\n\n        getActivity().unregisterReceiver(mUserChangeReceiver);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        mEditUserInfoController.onSaveInstanceState(outState);\n        outState.putInt(SAVE_REMOVING_USER, mRemovingUserId);\n        super.onSaveInstanceState(outState);\n    }\n\n    @Override\n    public void startActivityForResult(Intent intent, int requestCode) {\n        mEditUserInfoController.startingActivityForResult();\n        super.startActivityForResult(intent, requestCode);\n    }\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        int pos = 0;\n        // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n        //  regardless of mGuestUserAutoCreated\n        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n                && mGuestUserAutoCreated)) {\n            String nickname = mUserManager.getUserName();\n            MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                    getResources().getString(R.string.user_remove_user_menu, nickname));\n            removeThisUser.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n\n            final EnforcedAdmin disallowRemoveUserAdmin =\n                    RestrictedLockUtilsInternal.checkIfRestrictionEnforced(getContext(),\n                            UserManager.DISALLOW_REMOVE_USER, UserHandle.myUserId());\n            RestrictedLockUtilsInternal.setMenuItemAsDisabledByAdmin(getContext(), removeThisUser,\n                    disallowRemoveUserAdmin);\n        }\n        super.onCreateOptionsMenu(menu, inflater);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        final int itemId = item.getItemId();\n        if (itemId == MENU_REMOVE_USER) {\n            onRemoveUserClicked(UserHandle.myUserId());\n            return true;\n        } else {\n            return super.onOptionsItemSelected(item);\n        }\n    }\n\n    @Override\n    public void onMultiUserSwitchChanged(boolean newState) {\n        updateUI();\n    }\n\n    private void updateUI() {\n        mUserCaps.updateAddUserCapabilities(getActivity());\n        loadProfile();\n        updateUserList();\n    }\n\n    /**\n     * Loads profile information for the current user.\n     */\n    private void loadProfile() {\n        if (isCurrentUserGuest()) {\n            // No need to load profile information\n            mMePreference.setIcon(getEncircledDefaultIcon());\n            mMePreference.setTitle(\n                    mGuestUserAutoCreated ? com.android.settingslib.R.string.guest_reset_guest\n                            : R.string.user_exit_guest_title);\n            mMePreference.setSelectable(true);\n            // removing a guest will result in switching back to the admin user\n            mMePreference.setEnabled(canSwitchUserNow());\n            return;\n        }\n\n        new AsyncTask<Void, Void, String>() {\n            @Override\n            protected void onPostExecute(String result) {\n                finishLoadProfile(result);\n            }\n\n            @Override\n            protected String doInBackground(Void... values) {\n                UserInfo user = mUserManager.getUserInfo(UserHandle.myUserId());\n                if (user.iconPath == null || user.iconPath.equals(\"\")) {\n                    // Assign profile photo.\n                    copyMeProfilePhoto(getActivity(), user);\n                }\n                return user.name;\n            }\n        }.execute();\n    }\n\n    private void finishLoadProfile(String profileName) {\n        if (getActivity() == null) {\n            return;\n        }\n        mMePreference.setTitle(getString(R.string.user_you, profileName));\n        int myUserId = UserHandle.myUserId();\n        Bitmap b = mUserManager.getUserIcon(myUserId);\n        if (b != null) {\n            mMePreference.setIcon(encircle(b));\n            mUserIcons.put(myUserId, b);\n        }\n    }\n\n    private boolean hasLockscreenSecurity() {\n        LockPatternUtils lpu = new LockPatternUtils(getActivity());\n        return lpu.isSecure(UserHandle.myUserId());\n    }\n\n    private void launchChooseLockscreen() {\n        Intent chooseLockIntent = new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD);\n        chooseLockIntent.putExtra(ChooseLockGeneric.ChooseLockGenericFragment.HIDE_INSECURE_OPTIONS,\n                true);\n        startActivityForResult(chooseLockIntent, REQUEST_CHOOSE_LOCK);\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n\n        if (requestCode == REQUEST_CHOOSE_LOCK) {\n            if (resultCode != Activity.RESULT_CANCELED && hasLockscreenSecurity()) {\n                addUserNow(USER_TYPE_RESTRICTED_PROFILE);\n            }\n        } else if (mGuestUserAutoCreated && requestCode == REQUEST_EDIT_GUEST\n                && resultCode == RESULT_GUEST_REMOVED) {\n            scheduleGuestCreation();\n        } else {\n            mEditUserInfoController.onActivityResult(requestCode, resultCode, data);\n        }\n    }\n\n    private void onAddUserClicked(int userType) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                switch (userType) {\n                    case USER_TYPE_USER:\n                        showDialog(DIALOG_ADD_USER);\n                        break;\n                    case USER_TYPE_RESTRICTED_PROFILE:\n                        if (hasLockscreenSecurity()) {\n                            showDialog(DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE);\n                        } else {\n                            showDialog(DIALOG_NEED_LOCKSCREEN);\n                        }\n                        break;\n                }\n            }\n        }\n    }\n\n    private void onRemoveUserClicked(int userId) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                mRemovingUserId = userId;\n                showDialog(DIALOG_CONFIRM_REMOVE);\n            }\n        }\n    }\n\n    private void onUserCreated(int userId) {\n        hideUserCreatingDialog();\n        // prevent crash when config changes during user creation\n        if (getContext() == null) {\n            return;\n        }\n        mAddingUser = false;\n        UserInfo userInfo = mUserManager.getUserInfo(userId);\n        openUserDetails(userInfo, true);\n    }\n\n    private void hideUserCreatingDialog() {\n        if (mUserCreatingDialog != null && mUserCreatingDialog.isShowing()) {\n            mUserCreatingDialog.dismiss();\n        }\n    }\n\n    private void onUserCreationFailed() {\n        Toast.makeText(getContext(),\n                com.android.settingslib.R.string.add_user_failed,\n                Toast.LENGTH_SHORT).show();\n        hideUserCreatingDialog();\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser) {\n        Bundle extras = new Bundle();\n        extras.putInt(UserDetailsSettings.EXTRA_USER_ID, userInfo.id);\n        extras.putBoolean(AppRestrictionsFragment.EXTRA_NEW_USER, newUser);\n\n        final Context context = getContext();\n        SubSettingLauncher launcher = new SubSettingLauncher(context)\n                .setDestination(UserDetailsSettings.class.getName())\n                .setArguments(extras)\n                .setTitleText(getUserName(context, userInfo))\n                .setSourceMetricsCategory(getMetricsCategory());\n        if (mGuestUserAutoCreated && userInfo.isGuest()) {\n            launcher.setResultListener(this, REQUEST_EDIT_GUEST);\n        }\n        launcher.launch();\n    }\n\n    @Override\n    public void onDialogShowing() {\n        super.onDialogShowing();\n\n        setOnDismissListener(this);\n    }\n\n    @Override\n    public Dialog onCreateDialog(int dialogId) {\n        Context context = getActivity();\n        if (context == null) {\n            return null;\n        }\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE: {\n                Dialog dlg =\n                        UserDialogs.createRemoveDialog(getActivity(), mRemovingUserId,\n                                new DialogInterface.OnClickListener() {\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        removeUserNow();\n                                    }\n                                }\n                        );\n                return dlg;\n            }\n            case DIALOG_USER_CANNOT_MANAGE:\n                return new AlertDialog.Builder(context)\n                        .setMessage(R.string.user_cannot_manage_message)\n                        .setPositiveButton(android.R.string.ok, null)\n                        .create();\n            case DIALOG_ADD_USER: {\n                final SharedPreferences preferences = getActivity().getPreferences(\n                        Context.MODE_PRIVATE);\n                final boolean longMessageDisplayed = preferences.getBoolean(\n                        KEY_ADD_USER_LONG_MESSAGE_DISPLAYED, false);\n                final int messageResId = longMessageDisplayed\n                        ? com.android.settingslib.R.string.user_add_user_message_short\n                        : com.android.settingslib.R.string.user_add_user_message_long;\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.user_add_user_title)\n                        .setMessage(messageResId)\n                        .setPositiveButton(android.R.string.ok,\n                                new DialogInterface.OnClickListener() {\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        showDialog(DIALOG_USER_PROFILE_EDITOR_ADD_USER);\n                                        if (!longMessageDisplayed) {\n                                            preferences.edit().putBoolean(\n                                                    KEY_ADD_USER_LONG_MESSAGE_DISPLAYED,\n                                                    true).apply();\n                                        }\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CHOOSE_USER_TYPE: {\n                List<HashMap<String, String>> data = new ArrayList<HashMap<String, String>>();\n                HashMap<String, String> addUserItem = new HashMap<String, String>();\n                addUserItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_user_item_title));\n                addUserItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_user_item_summary));\n                HashMap<String, String> addProfileItem = new HashMap<String, String>();\n                addProfileItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_title));\n                addProfileItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_summary));\n                data.add(addUserItem);\n                data.add(addProfileItem);\n                AlertDialog.Builder builder = new AlertDialog.Builder(context);\n                SimpleAdapter adapter = new SimpleAdapter(builder.getContext(),\n                        data, R.layout.two_line_list_item,\n                        new String[]{KEY_TITLE, KEY_SUMMARY},\n                        new int[]{R.id.title, R.id.summary});\n                builder.setTitle(com.android.settingslib.R.string.user_add_user_type_title);\n                builder.setAdapter(adapter,\n                        new DialogInterface.OnClickListener() {\n                            @Override\n                            public void onClick(DialogInterface dialog, int which) {\n                                onAddUserClicked(which == 0\n                                        ? USER_TYPE_USER\n                                        : USER_TYPE_RESTRICTED_PROFILE);\n                            }\n                        });\n                return builder.create();\n            }\n            case DIALOG_NEED_LOCKSCREEN: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setMessage(com.android.settingslib.R.string.user_need_lock_message)\n                        .setPositiveButton(com.android.settingslib.R.string.user_set_lock_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        launchChooseLockscreen();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(R.string.user_exit_guest_confirm_title)\n                        .setMessage(R.string.user_exit_guest_confirm_message)\n                        .setPositiveButton(R.string.user_exit_guest_dialog_remove,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        exitGuest();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_USER_PROFILE_EDITOR: {\n                return buildEditCurrentUserDialog();\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_user_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_USER);\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_profile_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_RESTRICTED_PROFILE);\n            }\n            case DIALOG_CONFIRM_RESET_GUEST: {\n                return UserDialogs.createResetGuestDialog(getActivity(),\n                        (dialog, which) -> resetGuest());\n            }\n            default:\n                return null;\n        }\n    }\n\n    private Dialog buildEditCurrentUserDialog() {\n        final Activity activity = getActivity();\n        if (activity == null) {\n            return null;\n        }\n\n        UserInfo user = mUserManager.getUserInfo(Process.myUserHandle().getIdentifier());\n        Drawable userIcon = Utils.getUserIcon(activity, mUserManager, user);\n\n        return mEditUserInfoController.createDialog(\n                activity,\n                this::startActivityForResult,\n                userIcon,\n                user.name,\n                getString(com.android.settingslib.R.string.profile_info_settings_title),\n                (newUserName, newUserIcon) -> {\n                    if (newUserIcon != userIcon) {\n                        ThreadUtils.postOnBackgroundThread(() ->\n                                mUserManager.setUserIcon(user.id,\n                                        UserIcons.convertToBitmap(newUserIcon)));\n                        mMePreference.setIcon(newUserIcon);\n                    }\n\n                    if (!TextUtils.isEmpty(newUserName) && !newUserName.equals(user.name)) {\n                        mMePreference.setTitle(newUserName);\n                        mUserManager.setUserName(user.id, newUserName);\n                    }\n                }, null);\n    }\n\n    private Dialog buildAddUserDialog(int userType) {\n        Dialog d;\n        synchronized (mUserLock) {\n            d = mEditUserInfoController.createDialog(\n                    getActivity(),\n                    this::startActivityForResult,\n                    null,\n                    mPendingUserName.toString(),\n                    getString(userType == USER_TYPE_USER\n                            ? com.android.settingslib.R.string.user_info_settings_title\n                            : com.android.settingslib.R.string.profile_info_settings_title),\n                    (userName, userIcon) -> {\n                        mPendingUserIcon = userIcon;\n                        mPendingUserName = userName;\n                        addUserNow(userType);\n                    },\n                    () -> {\n                        synchronized (mUserLock) {\n                            mPendingUserIcon = null;\n                            mPendingUserName = null;\n                        }\n                    }\n            );\n        }\n        return d;\n    }\n\n    @Override\n    public int getDialogMetricsCategory(int dialogId) {\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE:\n                return SettingsEnums.DIALOG_USER_REMOVE;\n            case DIALOG_USER_CANNOT_MANAGE:\n                return SettingsEnums.DIALOG_USER_CANNOT_MANAGE;\n            case DIALOG_ADD_USER:\n                return SettingsEnums.DIALOG_USER_ADD;\n            case DIALOG_CHOOSE_USER_TYPE:\n                return SettingsEnums.DIALOG_USER_CHOOSE_TYPE;\n            case DIALOG_NEED_LOCKSCREEN:\n                return SettingsEnums.DIALOG_USER_NEED_LOCKSCREEN;\n            case DIALOG_CONFIRM_EXIT_GUEST:\n            case DIALOG_CONFIRM_RESET_GUEST:\n                return SettingsEnums.DIALOG_USER_CONFIRM_EXIT_GUEST;\n            case DIALOG_USER_PROFILE_EDITOR:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE:\n                return SettingsEnums.DIALOG_USER_EDIT_PROFILE;\n            default:\n                return 0;\n        }\n    }\n\n    private void removeUserNow() {\n        if (mRemovingUserId == UserHandle.myUserId()) {\n            removeThisUser();\n        } else {\n            ThreadUtils.postOnBackgroundThread(new Runnable() {\n                @Override\n                public void run() {\n                    synchronized (mUserLock) {\n                        mUserManager.removeUser(mRemovingUserId);\n                        mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n                    }\n                }\n            });\n        }\n    }\n\n    private void removeThisUser() {\n        if (!canSwitchUserNow()) {\n            Log.w(TAG, \"Cannot remove current user when switching is disabled\");\n            return;\n        }\n        try {\n            getContext().getSystemService(UserManager.class)\n                    .removeUserOrSetEphemeral(UserHandle.myUserId(),\n                            /* evenWhenDisallowed= */ false);\n            ActivityManager.getService().switchUser(UserHandle.USER_SYSTEM);\n        } catch (RemoteException re) {\n            Log.e(TAG, \"Unable to remove self user\");\n        }\n    }\n\n    private void addUserNow(final int userType) {\n        synchronized (mUserLock) {\n            mAddingUser = true;\n            mAddingUserName = userType == USER_TYPE_USER\n                    ? (mPendingUserName != null ? mPendingUserName.toString()\n                    : getString(R.string.user_new_user_name))\n                    : (mPendingUserName != null ? mPendingUserName.toString()\n                            : getString(R.string.user_new_profile_name));\n        }\n\n        mUserCreatingDialog = new UserCreatingDialog(getActivity());\n        mUserCreatingDialog.show();\n        ThreadUtils.postOnBackgroundThread(new Runnable() {\n            @Override\n            public void run() {\n                UserInfo user;\n                String username;\n\n                synchronized (mUserLock) {\n                    username = mAddingUserName;\n                }\n\n                // Could take a few seconds\n                if (userType == USER_TYPE_USER) {\n                    user = mUserManager.createUser(username, 0);\n                } else {\n                    user = mUserManager.createRestrictedProfile(username);\n                }\n\n                synchronized (mUserLock) {\n                    if (user == null) {\n                        mAddingUser = false;\n                        mPendingUserIcon = null;\n                        mPendingUserName = null;\n                        ThreadUtils.postOnMainThread(() -> onUserCreationFailed());\n                        return;\n                    }\n\n                    Drawable newUserIcon = mPendingUserIcon;\n                    if (newUserIcon == null) {\n                        newUserIcon = UserIcons.getDefaultUserIcon(getResources(), user.id, false);\n                    }\n                    mUserManager.setUserIcon(user.id, UserIcons.convertToBitmap(newUserIcon));\n\n                    if (userType == USER_TYPE_USER) {\n                        mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n                    }\n\n                    mHandler.sendMessage(mHandler.obtainMessage(\n                            MESSAGE_USER_CREATED, user.id, user.serialNumber));\n\n                    mPendingUserIcon = null;\n                    mPendingUserName = null;\n                }\n            }\n        });\n    }\n\n    /**\n     * Erase the current user (guest) and switch to another user.\n     */\n    @VisibleForTesting\n    void exitGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mMetricsFeatureProvider.action(getActivity(),\n                SettingsEnums.ACTION_USER_GUEST_EXIT_CONFIRMED);\n        removeThisUser();\n    }\n\n    /**\n     * Erase the current user (assuming it is a guest user), and create a new one in the background\n     */\n    @VisibleForTesting\n    void resetGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        int guestUserId = UserHandle.myUserId();\n        // Using markGuestForDeletion allows us to create a new guest before this one is\n        // fully removed. This could happen if someone calls scheduleGuestCreation()\n        // immediately after calling this method.\n        boolean marked = mUserManager.markGuestForDeletion(guestUserId);\n        if (!marked) {\n            Log.w(TAG, \"Couldn't mark the guest for deletion for user \" + guestUserId);\n            return;\n        }\n        exitGuest();\n        scheduleGuestCreation();\n    }\n\n    /**\n     * Create a guest user in the background\n     */\n    @VisibleForTesting\n    void scheduleGuestCreation() {\n        // TODO(b/191067027): Move guest recreation to system_server\n        if (mGuestCreationScheduled.compareAndSet(/* expect= */ false, /* update= */ true)) {\n            // Once mGuestCreationScheduled=true, mAddGuest needs to be updated so that it shows\n            // \"Resetting guest...\"\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            mExecutor.execute(() -> {\n                UserInfo guest = mUserManager.createGuest(\n                        getContext(), getString(com.android.settingslib.R.string.user_guest));\n                mGuestCreationScheduled.set(false);\n                if (guest == null) {\n                    Log.e(TAG, \"Unable to automatically recreate guest user\");\n                }\n                // The list needs to be updated whether or not guest creation worked. If guest\n                // creation failed, the list needs to update so that \"Add guest\" is displayed.\n                // Otherwise, the UX could be stuck in a state where there is no way to switch to\n                // the guest user (e.g. Guest would not be selectable, and it would be stuck\n                // saying \"Resetting guest...\")\n                mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            });\n        }\n    }\n\n    @VisibleForTesting\n    void updateUserList() {\n        final Context context = getActivity();\n        if (context == null) {\n            return;\n        }\n        final List<UserInfo> users = mUserManager.getAliveUsers();\n\n        final ArrayList<Integer> missingIcons = new ArrayList<>();\n        final ArrayList<UserPreference> userPreferences = new ArrayList<>();\n        userPreferences.add(mMePreference);\n\n        boolean canOpenUserDetails =\n                mUserCaps.mIsAdmin || (canSwitchUserNow() && !mUserCaps.mDisallowSwitchUser);\n        for (UserInfo user : users) {\n            if (!user.supportsSwitchToByUser()) {\n                // Only users that can be switched to should show up here.\n                // e.g. Managed profiles appear under Accounts Settings instead\n                continue;\n            }\n            UserPreference pref;\n            if (user.id == UserHandle.myUserId()) {\n                pref = mMePreference;\n            } else {\n                final Context prefContext = getPrefContext();\n                pref = new UserPreference(prefContext, null, user.id);\n                pref.setTitle(getUserName(prefContext, user));\n                userPreferences.add(pref);\n                pref.setOnPreferenceClickListener(this);\n                pref.setEnabled(canOpenUserDetails);\n                pref.setSelectable(true);\n\n                if (user.isGuest()) {\n                    pref.setIcon(getEncircledDefaultIcon());\n                    pref.setKey(KEY_USER_GUEST);\n                    if (mUserCaps.mDisallowSwitchUser) {\n                        pref.setDisabledByAdmin(\n                                RestrictedLockUtilsInternal.getDeviceOwner(context));\n                    } else {\n                        pref.setDisabledByAdmin(null);\n                    }\n                } else {\n                    pref.setKey(\"id=\" + user.id);\n                    if (user.isAdmin()) {\n                        pref.setSummary(R.string.user_admin);\n                    }\n                }\n            }\n            if (pref == null) {\n                continue;\n            }\n            if (user.id != UserHandle.myUserId() && !user.isGuest() && !user.isInitialized()) {\n                // sometimes after creating a guest the initialized flag isn't immediately set\n                // and we don't want to show \"Not set up\" summary for them\n                if (user.isRestricted()) {\n                    pref.setSummary(R.string.user_summary_restricted_not_set_up);\n                } else {\n                    pref.setSummary(R.string.user_summary_not_set_up);\n                    // Disallow setting up user which results in user switching when the\n                    // restriction is set.\n                    pref.setEnabled(!mUserCaps.mDisallowSwitchUser && canSwitchUserNow());\n                }\n            } else if (user.isRestricted()) {\n                pref.setSummary(R.string.user_summary_restricted_profile);\n            }\n            if (user.iconPath != null) {\n                if (mUserIcons.get(user.id) == null) {\n                    // Icon not loaded yet, print a placeholder\n                    missingIcons.add(user.id);\n                    pref.setIcon(getEncircledDefaultIcon());\n                } else {\n                    setPhotoId(pref, user);\n                }\n            } else {\n                // Icon not available yet, print a placeholder\n                pref.setIcon(getEncircledDefaultIcon());\n            }\n        }\n\n        // Add a temporary entry for the user being created\n        if (mAddingUser) {\n            UserPreference pref = new UserPreference(getPrefContext(), null,\n                    UserPreference.USERID_UNKNOWN);\n            pref.setEnabled(false);\n            pref.setTitle(mAddingUserName);\n            pref.setIcon(getEncircledDefaultIcon());\n            userPreferences.add(pref);\n        }\n\n\n        // Sort list of users by serialNum\n        Collections.sort(userPreferences, UserPreference.SERIAL_NUMBER_COMPARATOR);\n\n        getActivity().invalidateOptionsMenu();\n\n        // Load the icons\n        if (missingIcons.size() > 0) {\n            loadIconsAsync(missingIcons);\n        }\n\n        // If profiles are supported, mUserListCategory will have a special title\n        if (mUserCaps.mCanAddRestrictedProfile) {\n            mUserListCategory.setTitle(R.string.user_list_title);\n        } else {\n            mUserListCategory.setTitle(null);\n        }\n\n        // Remove everything from mUserListCategory and add new users.\n        mUserListCategory.removeAll();\n\n        // If multi-user is disabled, just show top info and return.\n        final Preference addUserOnLockScreen = getPreferenceScreen().findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey());\n        mAddUserWhenLockedPreferenceController.updateState(addUserOnLockScreen);\n\n        final Preference multiUserTopIntroPrefence = getPreferenceScreen().findPreference(\n                mMultiUserTopIntroPreferenceController.getPreferenceKey());\n        mMultiUserTopIntroPreferenceController.updateState(multiUserTopIntroPrefence);\n        mUserListCategory.setVisible(mUserCaps.mUserSwitcherEnabled);\n\n        updateAddGuest(context, users.stream().anyMatch(UserInfo::isGuest));\n        updateAddUser(context);\n\n        if (!mUserCaps.mUserSwitcherEnabled) {\n            return;\n        }\n\n        for (UserPreference userPreference : userPreferences) {\n            userPreference.setOrder(Preference.DEFAULT_ORDER);\n            mUserListCategory.addPreference(userPreference);\n        }\n\n    }\n\n    private boolean isCurrentUserGuest() {\n        return mUserCaps.mIsGuest;\n    }\n\n    private boolean canSwitchUserNow() {\n        return mUserManager.getUserSwitchability() == UserManager.SWITCHABILITY_STATUS_OK;\n    }\n\n    private void updateAddGuest(Context context, boolean isGuestAlreadyCreated) {\n        if (!isGuestAlreadyCreated && mUserCaps.mCanAddGuest\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && mUserCaps.mUserSwitcherEnabled) {\n            mAddGuest.setVisible(true);\n            mAddGuest.setIcon(getEncircledDefaultIcon());\n            mAddGuest.setSelectable(true);\n            if (mGuestUserAutoCreated && mGuestCreationScheduled.get()) {\n                mAddGuest.setTitle(com.android.settingslib.R.string.user_guest);\n                mAddGuest.setSummary(R.string.guest_resetting);\n                mAddGuest.setEnabled(false);\n            } else {\n                mAddGuest.setTitle(com.android.settingslib.R.string.guest_new_guest);\n                mAddGuest.setEnabled(canSwitchUserNow());\n            }\n        } else {\n            mAddGuest.setVisible(false);\n        }\n    }\n\n    private void updateAddUser(Context context) {\n        if ((mUserCaps.mCanAddUser || mUserCaps.mDisallowAddUserSetByAdmin)\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && mUserCaps.mUserSwitcherEnabled) {\n            mAddUser.setVisible(true);\n            mAddUser.setSelectable(true);\n            final boolean canAddMoreUsers = mUserManager.canAddMoreUsers();\n            mAddUser.setEnabled(canAddMoreUsers && !mAddingUser && canSwitchUserNow());\n            if (!canAddMoreUsers) {\n                mAddUser.setSummary(\n                        getString(R.string.user_add_max_count, getRealUsersCount()));\n            } else {\n                mAddUser.setSummary(null);\n            }\n            if (mAddUser.isEnabled()) {\n                mAddUser.setDisabledByAdmin(\n                        mUserCaps.mDisallowAddUser ? mUserCaps.mEnforcedAdmin : null);\n            }\n        } else {\n            mAddUser.setVisible(false);\n        }\n    }\n\n    /**\n     * @return number of non-guest non-managed users\n     */\n    @VisibleForTesting\n    int getRealUsersCount() {\n        return (int) mUserManager.getUsers()\n                .stream()\n                .filter(user -> !user.isGuest() && !user.isProfile())\n                .count();\n    }\n\n    private void loadIconsAsync(List<Integer> missingIcons) {\n        new AsyncTask<List<Integer>, Void, Void>() {\n            @Override\n            protected void onPostExecute(Void result) {\n                updateUserList();\n            }\n\n            @Override\n            protected Void doInBackground(List<Integer>... values) {\n                for (int userId : values[0]) {\n                    Bitmap bitmap = mUserManager.getUserIcon(userId);\n                    if (bitmap == null) {\n                        bitmap = getDefaultUserIconAsBitmap(getContext().getResources(), userId);\n                    }\n                    mUserIcons.append(userId, bitmap);\n                }\n                return null;\n            }\n        }.execute(missingIcons);\n    }\n\n    private Drawable getEncircledDefaultIcon() {\n        if (mDefaultIconDrawable == null) {\n            mDefaultIconDrawable = encircle(\n                    getDefaultUserIconAsBitmap(getContext().getResources(), UserHandle.USER_NULL));\n        }\n        return mDefaultIconDrawable;\n    }\n\n    private void setPhotoId(Preference pref, UserInfo user) {\n        Bitmap bitmap = mUserIcons.get(user.id);\n        if (bitmap != null) {\n            pref.setIcon(encircle(bitmap));\n        }\n    }\n\n    /** Returns the user's name, or the appropriate string in the case of a Guest. */\n    public static String getUserName(Context context, @NonNull UserInfo userInfo) {\n        if (userInfo.isGuest()) {\n            return context.getString(R.string.user_guest);\n        }\n        return userInfo.name;\n    }\n\n    @Override\n    public boolean onPreferenceClick(Preference pref) {\n        if (pref == mMePreference) {\n            if (isCurrentUserGuest()) {\n                if (mGuestUserAutoCreated) {\n                    showDialog(DIALOG_CONFIRM_RESET_GUEST);\n                } else {\n                    showDialog(DIALOG_CONFIRM_EXIT_GUEST);\n                }\n            } else {\n                showDialog(DIALOG_USER_PROFILE_EDITOR);\n            }\n            return true;\n        } else if (pref instanceof UserPreference) {\n            UserInfo userInfo = mUserManager.getUserInfo(((UserPreference) pref).getUserId());\n            openUserDetails(userInfo, false);\n            return true;\n        } else if (pref == mAddUser) {\n            // If we allow both types, show a picker, otherwise directly go to\n            // flow for full user.\n            if (mUserCaps.mCanAddRestrictedProfile) {\n                showDialog(DIALOG_CHOOSE_USER_TYPE);\n            } else {\n                onAddUserClicked(USER_TYPE_USER);\n            }\n            return true;\n        } else if (pref == mAddGuest) {\n            mAddGuest.setEnabled(false); // prevent multiple tap issue\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_GUEST_ADD);\n            UserInfo guest = mUserManager.createGuest(\n                    getContext(), getString(com.android.settingslib.R.string.user_guest));\n            if (guest == null) {\n                Toast.makeText(getContext(),\n                        com.android.settingslib.R.string.add_user_failed,\n                        Toast.LENGTH_SHORT).show();\n                return true;\n            }\n            openUserDetails(guest, true);\n            return true;\n        }\n        return false;\n    }\n\n    private Drawable encircle(Bitmap icon) {\n        Drawable circled = CircleFramedDrawable.getInstance(getActivity(), icon);\n        return circled;\n    }\n\n    @Override\n    public void onDismiss(DialogInterface dialog) {\n        synchronized (mUserLock) {\n            mRemovingUserId = -1;\n            updateUserList();\n        }\n    }\n\n    @Override\n    public int getHelpResource() {\n        return R.string.help_url_users;\n    }\n\n    /**\n     * Returns a default user icon (as a {@link Bitmap}) for the given user.\n     *\n     * Note that for guest users, you should pass in {@code UserHandle.USER_NULL}.\n     *\n     * @param resources resources object to fetch the user icon.\n     * @param userId    the user id or {@code UserHandle.USER_NULL} for a non-user specific icon\n     */\n    private static Bitmap getDefaultUserIconAsBitmap(Resources resources, int userId) {\n        Bitmap bitmap = null;\n        // Try finding the corresponding bitmap in the dark bitmap cache\n        bitmap = sDarkDefaultUserBitmapCache.get(userId);\n        if (bitmap == null) {\n            bitmap = UserIcons.convertToBitmap(\n                    UserIcons.getDefaultUserIcon(resources, userId, false));\n            // Save it to cache\n            sDarkDefaultUserBitmapCache.put(userId, bitmap);\n        }\n        return bitmap;\n    }\n\n    /**\n     * Assign the default photo to user with {@paramref userId}\n     *\n     * @param context used to get the {@link UserManager}\n     * @param userId  used to get the icon bitmap\n     * @return true if assign photo successfully, false if failed\n     */\n    @VisibleForTesting\n    static boolean assignDefaultPhoto(Context context, int userId) {\n        if (context == null) {\n            return false;\n        }\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap bitmap = getDefaultUserIconAsBitmap(context.getResources(), userId);\n        um.setUserIcon(userId, bitmap);\n\n        return true;\n    }\n\n    @WorkerThread\n    static void copyMeProfilePhoto(Context context, UserInfo user) {\n        Uri contactUri = ContactsContract.Profile.CONTENT_URI;\n\n        int userId = user != null ? user.id : UserHandle.myUserId();\n\n        InputStream avatarDataStream = ContactsContract.Contacts.openContactPhotoInputStream(\n                context.getContentResolver(),\n                contactUri, true);\n        // If there's no profile photo, assign a default avatar\n        if (avatarDataStream == null) {\n            assignDefaultPhoto(context, userId);\n            return;\n        }\n\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap icon = BitmapFactory.decodeStream(avatarDataStream);\n        um.setUserIcon(userId, icon);\n        try {\n            avatarDataStream.close();\n        } catch (IOException ioe) {\n        }\n    }\n\n    public static final BaseSearchIndexProvider SEARCH_INDEX_DATA_PROVIDER =\n            new BaseSearchIndexProvider(R.xml.user_settings) {\n\n                @Override\n                protected boolean isPageSearchEnabled(Context context) {\n                    final UserCapabilities userCaps = UserCapabilities.create(context);\n                    return userCaps.mEnabled;\n                }\n\n                @Override\n                public List<String> getNonIndexableKeysFromXml(Context context, int xmlResId,\n                        boolean suppressAllPage) {\n                    final List<String> niks = super.getNonIndexableKeysFromXml(context, xmlResId,\n                            suppressAllPage);\n                    AddUserWhenLockedPreferenceController controller =\n                            new AddUserWhenLockedPreferenceController(\n                                    context, KEY_ADD_USER_WHEN_LOCKED);\n                    controller.updateNonIndexableKeys(niks);\n                    new AutoSyncDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncPersonalDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncWorkDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    return niks;\n                }\n            };\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 9612,
                                        "general": {
                                            "word_based": 3808,
                                            "char_based": 13315
                                        },
                                        "gemini": 11983
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "4901c86b765f5e72075fb5e26374c097920a56f5",
                            "repo_path": "android_repos/Settings",
                            "result": "failure",
                            "downstream_patch_content": "commit 4901c86b765f5e72075fb5e26374c097920a56f5\nAuthor: Adam Bookatz <bookatz@google.com>\nDate:   Mon Nov 18 15:53:41 2024 -0800\n\n    Don't let profiles open the UserSettings overflow [DO NOT MERGE]\n    \n    Really, profiles aren't expected to open Settings at all. But if they\n    do somehow, the overflow shouldn't appear.\n    \n    Bug: 352542820\n    Flag: EXEMPT bugfix\n    Test: Try to access the overflow of the work profile by launching its Settings in\n    adb shell am start --user 10 'com.android.settings/.Settings\\$UserSettingsActivity'\n    \n    Change-Id: I5e4c095cda3e19fa5c63c2c550a526f5da8ec5c1\n    Merged-In: I5e4c095cda3e19fa5c63c2c550a526f5da8ec5c1\n    (cherry picked from commit 69c7f5dac580361792bbb189178653b297d06c8a)\n\ndiff --git a/src/com/android/settings/users/UserSettings.java b/src/com/android/settings/users/UserSettings.java\nindex ee23fc379d8..56bdfba3069 100644\n--- a/src/com/android/settings/users/UserSettings.java\n+++ b/src/com/android/settings/users/UserSettings.java\n@@ -358,8 +358,8 @@ public class UserSettings extends SettingsPreferenceFragment\n         int pos = 0;\n         // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n         //  regardless of mGuestUserAutoCreated\n-        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n-                && mGuestUserAutoCreated)) {\n+        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !mUserManager.isProfile()\n+                && !(isCurrentUserGuest() && mGuestUserAutoCreated)) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n",
                            "downstream_patch_tokens": {
                                "openai": 491,
                                "general": {
                                    "word_based": 189,
                                    "char_based": 438
                                },
                                "gemini": 629
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "src/com/android/settings/users/UserSettings.java",
                                    "total_hunks": 1,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [],
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    },
                                    "rej_file_content": "```diff\n--- src/com/android/settings/users/UserSettings.java\n+++ src/com/android/settings/users/UserSettings.java\n@@ -465,7 +465,7 @@ public class UserSettings extends SettingsPreferenceFragment\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n         if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx())\n-                && !isCurrentUserGuest()) {\n+                && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n```",
                                    "rej_file_tokens": {
                                        "openai": 147,
                                        "general": {
                                            "word_based": 59,
                                            "char_based": 179
                                        },
                                        "gemini": 181
                                    },
                                    "patch_apply_output": "patching file src/com/android/settings/users/UserSettings.java\nHunk #1 FAILED at 465.\n1 out of 1 hunk FAILED -- saving rejects to file src/com/android/settings/users/UserSettings.java.rej",
                                    "inline_merge_output": "patching file src/com/android/settings/users/UserSettings.java\nHunk #1 already applied at 468.",
                                    "upstream_file_tokens": {
                                        "openai": 14655,
                                        "general": {
                                            "word_based": 5594,
                                            "char_based": 20370
                                        },
                                        "gemini": 18165
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.users;\n\nimport android.annotation.NonNull;\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.Dialog;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.settings.SettingsEnums;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.drawable.Drawable;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.ContactsContract;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.SparseArray;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.widget.SimpleAdapter;\nimport android.widget.Toast;\n\nimport androidx.annotation.VisibleForTesting;\nimport androidx.annotation.WorkerThread;\nimport androidx.appcompat.app.AlertDialog;\nimport androidx.preference.Preference;\nimport androidx.preference.PreferenceGroup;\nimport androidx.preference.PreferenceScreen;\n\nimport com.android.internal.util.UserIcons;\nimport com.android.internal.widget.LockPatternUtils;\nimport com.android.settings.R;\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsPreferenceFragment;\nimport com.android.settings.Utils;\nimport com.android.settings.core.SubSettingLauncher;\nimport com.android.settings.password.ChooseLockGeneric;\nimport com.android.settings.search.BaseSearchIndexProvider;\nimport com.android.settings.widget.MainSwitchBarController;\nimport com.android.settings.widget.SettingsMainSwitchBar;\nimport com.android.settingslib.RestrictedLockUtils.EnforcedAdmin;\nimport com.android.settingslib.RestrictedLockUtilsInternal;\nimport com.android.settingslib.RestrictedPreference;\nimport com.android.settingslib.drawable.CircleFramedDrawable;\nimport com.android.settingslib.search.SearchIndexable;\nimport com.android.settingslib.users.EditUserInfoController;\nimport com.android.settingslib.users.UserCreatingDialog;\nimport com.android.settingslib.utils.ThreadUtils;\n\nimport com.google.android.setupcompat.util.WizardManagerHelper;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n/**\n * Screen that manages the list of users on the device.\n * Secondary users and a guest user can be created if there is no restriction.\n *\n * The first user in the list is always the current user.\n * Owner is the primary user.\n */\n@SearchIndexable\npublic class UserSettings extends SettingsPreferenceFragment\n        implements Preference.OnPreferenceClickListener,\n        MultiUserSwitchBarController.OnMultiUserSwitchChangedListener,\n        DialogInterface.OnDismissListener {\n\n    private static final String TAG = \"UserSettings\";\n\n    /** UserId of the user being removed */\n    private static final String SAVE_REMOVING_USER = \"removing_user\";\n\n    private static final String KEY_USER_LIST = \"user_list\";\n    private static final String KEY_USER_ME = \"user_me\";\n    private static final String KEY_USER_GUEST = \"user_guest\";\n    private static final String KEY_ADD_GUEST = \"guest_add\";\n    private static final String KEY_ADD_USER = \"user_add\";\n    private static final String KEY_ADD_USER_WHEN_LOCKED = \"user_settings_add_users_when_locked\";\n    private static final String KEY_MULTIUSER_TOP_INTRO = \"multiuser_top_intro\";\n\n    private static final int MENU_REMOVE_USER = Menu.FIRST;\n\n    private static final IntentFilter USER_REMOVED_INTENT_FILTER;\n\n    private static final int DIALOG_CONFIRM_REMOVE = 1;\n    private static final int DIALOG_ADD_USER = 2;\n    // Dialogs with id 3 and 4 got removed\n    private static final int DIALOG_USER_CANNOT_MANAGE = 5;\n    private static final int DIALOG_CHOOSE_USER_TYPE = 6;\n    private static final int DIALOG_NEED_LOCKSCREEN = 7;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST = 8;\n    private static final int DIALOG_USER_PROFILE_EDITOR = 9;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_USER = 10;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE = 11;\n    private static final int DIALOG_CONFIRM_RESET_GUEST = 12;\n\n    private static final int MESSAGE_UPDATE_LIST = 1;\n    private static final int MESSAGE_USER_CREATED = 2;\n\n    private static final int USER_TYPE_USER = 1;\n    private static final int USER_TYPE_RESTRICTED_PROFILE = 2;\n\n    private static final int REQUEST_CHOOSE_LOCK = 10;\n    private static final int REQUEST_EDIT_GUEST = 11;\n\n    static final int RESULT_GUEST_REMOVED = 100;\n\n    private static final String KEY_ADD_USER_LONG_MESSAGE_DISPLAYED =\n            \"key_add_user_long_message_displayed\";\n\n    private static final String KEY_TITLE = \"title\";\n    private static final String KEY_SUMMARY = \"summary\";\n\n    static {\n        USER_REMOVED_INTENT_FILTER = new IntentFilter(Intent.ACTION_USER_REMOVED);\n        USER_REMOVED_INTENT_FILTER.addAction(Intent.ACTION_USER_INFO_CHANGED);\n    }\n\n    @VisibleForTesting\n    PreferenceGroup mUserListCategory;\n    @VisibleForTesting\n    UserPreference mMePreference;\n    @VisibleForTesting\n    RestrictedPreference mAddGuest;\n    @VisibleForTesting\n    RestrictedPreference mAddUser;\n    @VisibleForTesting\n    SparseArray<Bitmap> mUserIcons = new SparseArray<>();\n    private int mRemovingUserId = -1;\n    private boolean mAddingUser;\n    private boolean mGuestUserAutoCreated;\n    private String mAddingUserName;\n    private UserCapabilities mUserCaps;\n    private boolean mShouldUpdateUserList = true;\n    private final Object mUserLock = new Object();\n    private UserManager mUserManager;\n    private static SparseArray<Bitmap> sDarkDefaultUserBitmapCache = new SparseArray<>();\n\n    private MultiUserSwitchBarController mSwitchBarController;\n    private EditUserInfoController mEditUserInfoController =\n            new EditUserInfoController(Utils.FILE_PROVIDER_AUTHORITY);\n    private AddUserWhenLockedPreferenceController mAddUserWhenLockedPreferenceController;\n    private MultiUserTopIntroPreferenceController mMultiUserTopIntroPreferenceController;\n    private UserCreatingDialog mUserCreatingDialog;\n    private final AtomicBoolean mGuestCreationScheduled = new AtomicBoolean();\n    private final ExecutorService mExecutor = Executors.newSingleThreadExecutor();\n\n    private CharSequence mPendingUserName;\n    private Drawable mPendingUserIcon;\n\n    // A place to cache the generated default avatar\n    private Drawable mDefaultIconDrawable;\n\n    // TODO:   Replace current Handler solution to something that doesn't leak memory and works\n    // TODO:   during a configuration change\n    private Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MESSAGE_UPDATE_LIST:\n                    updateUserList();\n                    break;\n                case MESSAGE_USER_CREATED:\n                    onUserCreated(msg.arg1);\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mUserChangeReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(Intent.ACTION_USER_REMOVED)) {\n                mRemovingUserId = -1;\n            } else if (intent.getAction().equals(Intent.ACTION_USER_INFO_CHANGED)) {\n                int userHandle = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);\n                if (userHandle != -1) {\n                    mUserIcons.remove(userHandle);\n                }\n            }\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n        }\n    };\n\n    @Override\n    public int getMetricsCategory() {\n        return SettingsEnums.USER;\n    }\n\n    @Override\n    public void onActivityCreated(Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n        // Assume we are in a SettingsActivity. This is only safe because we currently use\n        // SettingsActivity as base for all preference fragments.\n        final SettingsActivity activity = (SettingsActivity) getActivity();\n        final SettingsMainSwitchBar switchBar = activity.getSwitchBar();\n        switchBar.setTitle(getContext().getString(R.string.multiple_users_main_switch_title));\n        switchBar.show();\n        mSwitchBarController = new MultiUserSwitchBarController(activity,\n                new MainSwitchBarController(switchBar), this /* listener */);\n        getSettingsLifecycle().addObserver(mSwitchBarController);\n    }\n\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        addPreferencesFromResource(R.xml.user_settings);\n        final Activity activity = getActivity();\n        if (!WizardManagerHelper.isDeviceProvisioned(activity)) {\n            activity.finish();\n            return;\n        }\n\n        mGuestUserAutoCreated = getPrefContext().getResources().getBoolean(\n                        com.android.internal.R.bool.config_guestUserAutoCreated);\n\n        mAddUserWhenLockedPreferenceController = new AddUserWhenLockedPreferenceController(\n                activity, KEY_ADD_USER_WHEN_LOCKED);\n\n        mMultiUserTopIntroPreferenceController = new MultiUserTopIntroPreferenceController(activity,\n                KEY_MULTIUSER_TOP_INTRO);\n\n        final PreferenceScreen screen = getPreferenceScreen();\n        mAddUserWhenLockedPreferenceController.displayPreference(screen);\n        mMultiUserTopIntroPreferenceController.displayPreference(screen);\n\n        screen.findPreference(mAddUserWhenLockedPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mAddUserWhenLockedPreferenceController);\n\n        if (icicle != null) {\n            if (icicle.containsKey(SAVE_REMOVING_USER)) {\n                mRemovingUserId = icicle.getInt(SAVE_REMOVING_USER);\n            }\n            mEditUserInfoController.onRestoreInstanceState(icicle);\n        }\n\n        mUserCaps = UserCapabilities.create(activity);\n        mUserManager = (UserManager) activity.getSystemService(Context.USER_SERVICE);\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n\n        final int myUserId = UserHandle.myUserId();\n\n        mUserListCategory = (PreferenceGroup) findPreference(KEY_USER_LIST);\n        mMePreference = new UserPreference(getPrefContext(), null /* attrs */, myUserId);\n        mMePreference.setKey(KEY_USER_ME);\n        mMePreference.setOnPreferenceClickListener(this);\n        if (mUserCaps.mIsAdmin) {\n            mMePreference.setSummary(R.string.user_admin);\n        }\n\n        mAddGuest = findPreference(KEY_ADD_GUEST);\n        mAddGuest.setOnPreferenceClickListener(this);\n\n        mAddUser = findPreference(KEY_ADD_USER);\n        if (!mUserCaps.mCanAddRestrictedProfile) {\n            // Label should only mention adding a \"user\", not a \"profile\"\n            mAddUser.setTitle(R.string.user_add_user_menu);\n        }\n        mAddUser.setOnPreferenceClickListener(this);\n\n        activity.registerReceiverAsUser(\n                mUserChangeReceiver, UserHandle.ALL, USER_REMOVED_INTENT_FILTER, null, mHandler);\n\n        updateUI();\n        mShouldUpdateUserList = false;\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n        final PreferenceScreen screen = getPreferenceScreen();\n\n        mAddUserWhenLockedPreferenceController.updateState(screen.findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey()));\n\n        if (mShouldUpdateUserList) {\n            updateUI();\n        }\n    }\n\n    @Override\n    public void onPause() {\n        mShouldUpdateUserList = true;\n        super.onPause();\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n\n        if (mUserCaps == null || !mUserCaps.mEnabled) {\n            return;\n        }\n\n        getActivity().unregisterReceiver(mUserChangeReceiver);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        mEditUserInfoController.onSaveInstanceState(outState);\n        outState.putInt(SAVE_REMOVING_USER, mRemovingUserId);\n        super.onSaveInstanceState(outState);\n    }\n\n    @Override\n    public void startActivityForResult(Intent intent, int requestCode) {\n        mEditUserInfoController.startingActivityForResult();\n        super.startActivityForResult(intent, requestCode);\n    }\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        int pos = 0;\n        // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n        //  regardless of mGuestUserAutoCreated\n        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n                && mGuestUserAutoCreated)) {\n            String nickname = mUserManager.getUserName();\n            MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                    getResources().getString(R.string.user_remove_user_menu, nickname));\n            removeThisUser.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n\n            final EnforcedAdmin disallowRemoveUserAdmin =\n                    RestrictedLockUtilsInternal.checkIfRestrictionEnforced(getContext(),\n                            UserManager.DISALLOW_REMOVE_USER, UserHandle.myUserId());\n            RestrictedLockUtilsInternal.setMenuItemAsDisabledByAdmin(getContext(), removeThisUser,\n                    disallowRemoveUserAdmin);\n        }\n        super.onCreateOptionsMenu(menu, inflater);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        final int itemId = item.getItemId();\n        if (itemId == MENU_REMOVE_USER) {\n            onRemoveUserClicked(UserHandle.myUserId());\n            return true;\n        } else {\n            return super.onOptionsItemSelected(item);\n        }\n    }\n\n    @Override\n    public void onMultiUserSwitchChanged(boolean newState) {\n        updateUI();\n    }\n\n    private void updateUI() {\n        mUserCaps.updateAddUserCapabilities(getActivity());\n        loadProfile();\n        updateUserList();\n    }\n\n    /**\n     * Loads profile information for the current user.\n     */\n    private void loadProfile() {\n        if (isCurrentUserGuest()) {\n            // No need to load profile information\n            mMePreference.setIcon(getEncircledDefaultIcon());\n            mMePreference.setTitle(\n                    mGuestUserAutoCreated ? com.android.settingslib.R.string.guest_reset_guest\n                            : R.string.user_exit_guest_title);\n            mMePreference.setSelectable(true);\n            // removing a guest will result in switching back to the admin user\n            mMePreference.setEnabled(canSwitchUserNow());\n            return;\n        }\n\n        new AsyncTask<Void, Void, String>() {\n            @Override\n            protected void onPostExecute(String result) {\n                finishLoadProfile(result);\n            }\n\n            @Override\n            protected String doInBackground(Void... values) {\n                UserInfo user = mUserManager.getUserInfo(UserHandle.myUserId());\n                if (user.iconPath == null || user.iconPath.equals(\"\")) {\n                    // Assign profile photo.\n                    copyMeProfilePhoto(getActivity(), user);\n                }\n                return user.name;\n            }\n        }.execute();\n    }\n\n    private void finishLoadProfile(String profileName) {\n        if (getActivity() == null) {\n            return;\n        }\n        mMePreference.setTitle(getString(R.string.user_you, profileName));\n        int myUserId = UserHandle.myUserId();\n        Bitmap b = mUserManager.getUserIcon(myUserId);\n        if (b != null) {\n            mMePreference.setIcon(encircle(b));\n            mUserIcons.put(myUserId, b);\n        }\n    }\n\n    private boolean hasLockscreenSecurity() {\n        LockPatternUtils lpu = new LockPatternUtils(getActivity());\n        return lpu.isSecure(UserHandle.myUserId());\n    }\n\n    private void launchChooseLockscreen() {\n        Intent chooseLockIntent = new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD);\n        chooseLockIntent.putExtra(ChooseLockGeneric.ChooseLockGenericFragment.HIDE_INSECURE_OPTIONS,\n                true);\n        startActivityForResult(chooseLockIntent, REQUEST_CHOOSE_LOCK);\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n\n        if (requestCode == REQUEST_CHOOSE_LOCK) {\n            if (resultCode != Activity.RESULT_CANCELED && hasLockscreenSecurity()) {\n                addUserNow(USER_TYPE_RESTRICTED_PROFILE);\n            }\n        } else if (mGuestUserAutoCreated && requestCode == REQUEST_EDIT_GUEST\n                && resultCode == RESULT_GUEST_REMOVED) {\n            scheduleGuestCreation();\n        } else {\n            mEditUserInfoController.onActivityResult(requestCode, resultCode, data);\n        }\n    }\n\n    private void onAddUserClicked(int userType) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                switch (userType) {\n                    case USER_TYPE_USER:\n                        showDialog(DIALOG_ADD_USER);\n                        break;\n                    case USER_TYPE_RESTRICTED_PROFILE:\n                        if (hasLockscreenSecurity()) {\n                            showDialog(DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE);\n                        } else {\n                            showDialog(DIALOG_NEED_LOCKSCREEN);\n                        }\n                        break;\n                }\n            }\n        }\n    }\n\n    private void onRemoveUserClicked(int userId) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                mRemovingUserId = userId;\n                showDialog(DIALOG_CONFIRM_REMOVE);\n            }\n        }\n    }\n\n    private void onUserCreated(int userId) {\n        hideUserCreatingDialog();\n        // prevent crash when config changes during user creation\n        if (getContext() == null) {\n            return;\n        }\n        mAddingUser = false;\n        UserInfo userInfo = mUserManager.getUserInfo(userId);\n        openUserDetails(userInfo, true);\n    }\n\n    private void hideUserCreatingDialog() {\n        if (mUserCreatingDialog != null && mUserCreatingDialog.isShowing()) {\n            mUserCreatingDialog.dismiss();\n        }\n    }\n\n    private void onUserCreationFailed() {\n        Toast.makeText(getContext(),\n                com.android.settingslib.R.string.add_user_failed,\n                Toast.LENGTH_SHORT).show();\n        hideUserCreatingDialog();\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser) {\n        Bundle extras = new Bundle();\n        extras.putInt(UserDetailsSettings.EXTRA_USER_ID, userInfo.id);\n        extras.putBoolean(AppRestrictionsFragment.EXTRA_NEW_USER, newUser);\n\n        final Context context = getContext();\n        SubSettingLauncher launcher = new SubSettingLauncher(context)\n                .setDestination(UserDetailsSettings.class.getName())\n                .setArguments(extras)\n                .setTitleText(getUserName(context, userInfo))\n                .setSourceMetricsCategory(getMetricsCategory());\n        if (mGuestUserAutoCreated && userInfo.isGuest()) {\n            launcher.setResultListener(this, REQUEST_EDIT_GUEST);\n        }\n        launcher.launch();\n    }\n\n    @Override\n    public void onDialogShowing() {\n        super.onDialogShowing();\n\n        setOnDismissListener(this);\n    }\n\n    @Override\n    public Dialog onCreateDialog(int dialogId) {\n        Context context = getActivity();\n        if (context == null) {\n            return null;\n        }\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE: {\n                Dialog dlg =\n                        UserDialogs.createRemoveDialog(getActivity(), mRemovingUserId,\n                                new DialogInterface.OnClickListener() {\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        removeUserNow();\n                                    }\n                                }\n                        );\n                return dlg;\n            }\n            case DIALOG_USER_CANNOT_MANAGE:\n                return new AlertDialog.Builder(context)\n                        .setMessage(R.string.user_cannot_manage_message)\n                        .setPositiveButton(android.R.string.ok, null)\n                        .create();\n            case DIALOG_ADD_USER: {\n                final SharedPreferences preferences = getActivity().getPreferences(\n                        Context.MODE_PRIVATE);\n                final boolean longMessageDisplayed = preferences.getBoolean(\n                        KEY_ADD_USER_LONG_MESSAGE_DISPLAYED, false);\n                final int messageResId = longMessageDisplayed\n                        ? com.android.settingslib.R.string.user_add_user_message_short\n                        : com.android.settingslib.R.string.user_add_user_message_long;\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.user_add_user_title)\n                        .setMessage(messageResId)\n                        .setPositiveButton(android.R.string.ok,\n                                new DialogInterface.OnClickListener() {\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        showDialog(DIALOG_USER_PROFILE_EDITOR_ADD_USER);\n                                        if (!longMessageDisplayed) {\n                                            preferences.edit().putBoolean(\n                                                    KEY_ADD_USER_LONG_MESSAGE_DISPLAYED,\n                                                    true).apply();\n                                        }\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CHOOSE_USER_TYPE: {\n                List<HashMap<String, String>> data = new ArrayList<HashMap<String, String>>();\n                HashMap<String, String> addUserItem = new HashMap<String, String>();\n                addUserItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_user_item_title));\n                addUserItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_user_item_summary));\n                HashMap<String, String> addProfileItem = new HashMap<String, String>();\n                addProfileItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_title));\n                addProfileItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_summary));\n                data.add(addUserItem);\n                data.add(addProfileItem);\n                AlertDialog.Builder builder = new AlertDialog.Builder(context);\n                SimpleAdapter adapter = new SimpleAdapter(builder.getContext(),\n                        data, R.layout.two_line_list_item,\n                        new String[]{KEY_TITLE, KEY_SUMMARY},\n                        new int[]{R.id.title, R.id.summary});\n                builder.setTitle(com.android.settingslib.R.string.user_add_user_type_title);\n                builder.setAdapter(adapter,\n                        new DialogInterface.OnClickListener() {\n                            @Override\n                            public void onClick(DialogInterface dialog, int which) {\n                                onAddUserClicked(which == 0\n                                        ? USER_TYPE_USER\n                                        : USER_TYPE_RESTRICTED_PROFILE);\n                            }\n                        });\n                return builder.create();\n            }\n            case DIALOG_NEED_LOCKSCREEN: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setMessage(com.android.settingslib.R.string.user_need_lock_message)\n                        .setPositiveButton(com.android.settingslib.R.string.user_set_lock_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        launchChooseLockscreen();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(R.string.user_exit_guest_confirm_title)\n                        .setMessage(R.string.user_exit_guest_confirm_message)\n                        .setPositiveButton(R.string.user_exit_guest_dialog_remove,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        exitGuest();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_USER_PROFILE_EDITOR: {\n                return buildEditCurrentUserDialog();\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_user_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_USER);\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_profile_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_RESTRICTED_PROFILE);\n            }\n            case DIALOG_CONFIRM_RESET_GUEST: {\n                return UserDialogs.createResetGuestDialog(getActivity(),\n                        (dialog, which) -> resetGuest());\n            }\n            default:\n                return null;\n        }\n    }\n\n    private Dialog buildEditCurrentUserDialog() {\n        final Activity activity = getActivity();\n        if (activity == null) {\n            return null;\n        }\n\n        UserInfo user = mUserManager.getUserInfo(Process.myUserHandle().getIdentifier());\n        Drawable userIcon = Utils.getUserIcon(activity, mUserManager, user);\n\n        return mEditUserInfoController.createDialog(\n                activity,\n                this::startActivityForResult,\n                userIcon,\n                user.name,\n                getString(com.android.settingslib.R.string.profile_info_settings_title),\n                (newUserName, newUserIcon) -> {\n                    if (newUserIcon != userIcon) {\n                        ThreadUtils.postOnBackgroundThread(() ->\n                                mUserManager.setUserIcon(user.id,\n                                        UserIcons.convertToBitmap(newUserIcon)));\n                        mMePreference.setIcon(newUserIcon);\n                    }\n\n                    if (!TextUtils.isEmpty(newUserName) && !newUserName.equals(user.name)) {\n                        mMePreference.setTitle(newUserName);\n                        mUserManager.setUserName(user.id, newUserName);\n                    }\n                }, null);\n    }\n\n    private Dialog buildAddUserDialog(int userType) {\n        Dialog d;\n        synchronized (mUserLock) {\n            d = mEditUserInfoController.createDialog(\n                    getActivity(),\n                    this::startActivityForResult,\n                    null,\n                    mPendingUserName.toString(),\n                    getString(userType == USER_TYPE_USER\n                            ? com.android.settingslib.R.string.user_info_settings_title\n                            : com.android.settingslib.R.string.profile_info_settings_title),\n                    (userName, userIcon) -> {\n                        mPendingUserIcon = userIcon;\n                        mPendingUserName = userName;\n                        addUserNow(userType);\n                    },\n                    () -> {\n                        synchronized (mUserLock) {\n                            mPendingUserIcon = null;\n                            mPendingUserName = null;\n                        }\n                    }\n            );\n        }\n        return d;\n    }\n\n    @Override\n    public int getDialogMetricsCategory(int dialogId) {\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE:\n                return SettingsEnums.DIALOG_USER_REMOVE;\n            case DIALOG_USER_CANNOT_MANAGE:\n                return SettingsEnums.DIALOG_USER_CANNOT_MANAGE;\n            case DIALOG_ADD_USER:\n                return SettingsEnums.DIALOG_USER_ADD;\n            case DIALOG_CHOOSE_USER_TYPE:\n                return SettingsEnums.DIALOG_USER_CHOOSE_TYPE;\n            case DIALOG_NEED_LOCKSCREEN:\n                return SettingsEnums.DIALOG_USER_NEED_LOCKSCREEN;\n            case DIALOG_CONFIRM_EXIT_GUEST:\n            case DIALOG_CONFIRM_RESET_GUEST:\n                return SettingsEnums.DIALOG_USER_CONFIRM_EXIT_GUEST;\n            case DIALOG_USER_PROFILE_EDITOR:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE:\n                return SettingsEnums.DIALOG_USER_EDIT_PROFILE;\n            default:\n                return 0;\n        }\n    }\n\n    private void removeUserNow() {\n        if (mRemovingUserId == UserHandle.myUserId()) {\n            removeThisUser();\n        } else {\n            ThreadUtils.postOnBackgroundThread(new Runnable() {\n                @Override\n                public void run() {\n                    synchronized (mUserLock) {\n                        mUserManager.removeUser(mRemovingUserId);\n                        mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n                    }\n                }\n            });\n        }\n    }\n\n    private void removeThisUser() {\n        if (!canSwitchUserNow()) {\n            Log.w(TAG, \"Cannot remove current user when switching is disabled\");\n            return;\n        }\n        try {\n            getContext().getSystemService(UserManager.class)\n                    .removeUserOrSetEphemeral(UserHandle.myUserId(),\n                            /* evenWhenDisallowed= */ false);\n            ActivityManager.getService().switchUser(UserHandle.USER_SYSTEM);\n        } catch (RemoteException re) {\n            Log.e(TAG, \"Unable to remove self user\");\n        }\n    }\n\n    private void addUserNow(final int userType) {\n        synchronized (mUserLock) {\n            mAddingUser = true;\n            mAddingUserName = userType == USER_TYPE_USER\n                    ? (mPendingUserName != null ? mPendingUserName.toString()\n                    : getString(R.string.user_new_user_name))\n                    : (mPendingUserName != null ? mPendingUserName.toString()\n                            : getString(R.string.user_new_profile_name));\n        }\n\n        mUserCreatingDialog = new UserCreatingDialog(getActivity());\n        mUserCreatingDialog.show();\n        ThreadUtils.postOnBackgroundThread(new Runnable() {\n            @Override\n            public void run() {\n                UserInfo user;\n                String username;\n\n                synchronized (mUserLock) {\n                    username = mAddingUserName;\n                }\n\n                // Could take a few seconds\n                if (userType == USER_TYPE_USER) {\n                    user = mUserManager.createUser(username, 0);\n                } else {\n                    user = mUserManager.createRestrictedProfile(username);\n                }\n\n                synchronized (mUserLock) {\n                    if (user == null) {\n                        mAddingUser = false;\n                        mPendingUserIcon = null;\n                        mPendingUserName = null;\n                        ThreadUtils.postOnMainThread(() -> onUserCreationFailed());\n                        return;\n                    }\n\n                    Drawable newUserIcon = mPendingUserIcon;\n                    if (newUserIcon == null) {\n                        newUserIcon = UserIcons.getDefaultUserIcon(getResources(), user.id, false);\n                    }\n                    mUserManager.setUserIcon(user.id, UserIcons.convertToBitmap(newUserIcon));\n\n                    if (userType == USER_TYPE_USER) {\n                        mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n                    }\n\n                    mHandler.sendMessage(mHandler.obtainMessage(\n                            MESSAGE_USER_CREATED, user.id, user.serialNumber));\n\n                    mPendingUserIcon = null;\n                    mPendingUserName = null;\n                }\n            }\n        });\n    }\n\n    /**\n     * Erase the current user (guest) and switch to another user.\n     */\n    @VisibleForTesting\n    void exitGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mMetricsFeatureProvider.action(getActivity(),\n                SettingsEnums.ACTION_USER_GUEST_EXIT_CONFIRMED);\n        removeThisUser();\n    }\n\n    /**\n     * Erase the current user (assuming it is a guest user), and create a new one in the background\n     */\n    @VisibleForTesting\n    void resetGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        int guestUserId = UserHandle.myUserId();\n        // Using markGuestForDeletion allows us to create a new guest before this one is\n        // fully removed. This could happen if someone calls scheduleGuestCreation()\n        // immediately after calling this method.\n        boolean marked = mUserManager.markGuestForDeletion(guestUserId);\n        if (!marked) {\n            Log.w(TAG, \"Couldn't mark the guest for deletion for user \" + guestUserId);\n            return;\n        }\n        exitGuest();\n        scheduleGuestCreation();\n    }\n\n    /**\n     * Create a guest user in the background\n     */\n    @VisibleForTesting\n    void scheduleGuestCreation() {\n        // TODO(b/191067027): Move guest recreation to system_server\n        if (mGuestCreationScheduled.compareAndSet(/* expect= */ false, /* update= */ true)) {\n            // Once mGuestCreationScheduled=true, mAddGuest needs to be updated so that it shows\n            // \"Resetting guest...\"\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            mExecutor.execute(() -> {\n                UserInfo guest = mUserManager.createGuest(\n                        getContext(), getString(com.android.settingslib.R.string.user_guest));\n                mGuestCreationScheduled.set(false);\n                if (guest == null) {\n                    Log.e(TAG, \"Unable to automatically recreate guest user\");\n                }\n                // The list needs to be updated whether or not guest creation worked. If guest\n                // creation failed, the list needs to update so that \"Add guest\" is displayed.\n                // Otherwise, the UX could be stuck in a state where there is no way to switch to\n                // the guest user (e.g. Guest would not be selectable, and it would be stuck\n                // saying \"Resetting guest...\")\n                mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            });\n        }\n    }\n\n    @VisibleForTesting\n    void updateUserList() {\n        final Context context = getActivity();\n        if (context == null) {\n            return;\n        }\n        final List<UserInfo> users = mUserManager.getAliveUsers();\n\n        final ArrayList<Integer> missingIcons = new ArrayList<>();\n        final ArrayList<UserPreference> userPreferences = new ArrayList<>();\n        userPreferences.add(mMePreference);\n\n        boolean canOpenUserDetails =\n                mUserCaps.mIsAdmin || (canSwitchUserNow() && !mUserCaps.mDisallowSwitchUser);\n        for (UserInfo user : users) {\n            if (!user.supportsSwitchToByUser()) {\n                // Only users that can be switched to should show up here.\n                // e.g. Managed profiles appear under Accounts Settings instead\n                continue;\n            }\n            UserPreference pref;\n            if (user.id == UserHandle.myUserId()) {\n                pref = mMePreference;\n            } else {\n                final Context prefContext = getPrefContext();\n                pref = new UserPreference(prefContext, null, user.id);\n                pref.setTitle(getUserName(prefContext, user));\n                userPreferences.add(pref);\n                pref.setOnPreferenceClickListener(this);\n                pref.setEnabled(canOpenUserDetails);\n                pref.setSelectable(true);\n\n                if (user.isGuest()) {\n                    pref.setIcon(getEncircledDefaultIcon());\n                    pref.setKey(KEY_USER_GUEST);\n                    if (mUserCaps.mDisallowSwitchUser) {\n                        pref.setDisabledByAdmin(\n                                RestrictedLockUtilsInternal.getDeviceOwner(context));\n                    } else {\n                        pref.setDisabledByAdmin(null);\n                    }\n                } else {\n                    pref.setKey(\"id=\" + user.id);\n                    if (user.isAdmin()) {\n                        pref.setSummary(R.string.user_admin);\n                    }\n                }\n            }\n            if (pref == null) {\n                continue;\n            }\n            if (user.id != UserHandle.myUserId() && !user.isGuest() && !user.isInitialized()) {\n                // sometimes after creating a guest the initialized flag isn't immediately set\n                // and we don't want to show \"Not set up\" summary for them\n                if (user.isRestricted()) {\n                    pref.setSummary(R.string.user_summary_restricted_not_set_up);\n                } else {\n                    pref.setSummary(R.string.user_summary_not_set_up);\n                    // Disallow setting up user which results in user switching when the\n                    // restriction is set.\n                    pref.setEnabled(!mUserCaps.mDisallowSwitchUser && canSwitchUserNow());\n                }\n            } else if (user.isRestricted()) {\n                pref.setSummary(R.string.user_summary_restricted_profile);\n            }\n            if (user.iconPath != null) {\n                if (mUserIcons.get(user.id) == null) {\n                    // Icon not loaded yet, print a placeholder\n                    missingIcons.add(user.id);\n                    pref.setIcon(getEncircledDefaultIcon());\n                } else {\n                    setPhotoId(pref, user);\n                }\n            } else {\n                // Icon not available yet, print a placeholder\n                pref.setIcon(getEncircledDefaultIcon());\n            }\n        }\n\n        // Add a temporary entry for the user being created\n        if (mAddingUser) {\n            UserPreference pref = new UserPreference(getPrefContext(), null,\n                    UserPreference.USERID_UNKNOWN);\n            pref.setEnabled(false);\n            pref.setTitle(mAddingUserName);\n            pref.setIcon(getEncircledDefaultIcon());\n            userPreferences.add(pref);\n        }\n\n\n        // Sort list of users by serialNum\n        Collections.sort(userPreferences, UserPreference.SERIAL_NUMBER_COMPARATOR);\n\n        getActivity().invalidateOptionsMenu();\n\n        // Load the icons\n        if (missingIcons.size() > 0) {\n            loadIconsAsync(missingIcons);\n        }\n\n        // If profiles are supported, mUserListCategory will have a special title\n        if (mUserCaps.mCanAddRestrictedProfile) {\n            mUserListCategory.setTitle(R.string.user_list_title);\n        } else {\n            mUserListCategory.setTitle(null);\n        }\n\n        // Remove everything from mUserListCategory and add new users.\n        mUserListCategory.removeAll();\n\n        // If multi-user is disabled, just show top info and return.\n        final Preference addUserOnLockScreen = getPreferenceScreen().findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey());\n        mAddUserWhenLockedPreferenceController.updateState(addUserOnLockScreen);\n\n        final Preference multiUserTopIntroPrefence = getPreferenceScreen().findPreference(\n                mMultiUserTopIntroPreferenceController.getPreferenceKey());\n        mMultiUserTopIntroPreferenceController.updateState(multiUserTopIntroPrefence);\n        mUserListCategory.setVisible(mUserCaps.mUserSwitcherEnabled);\n\n        updateAddGuest(context, users.stream().anyMatch(UserInfo::isGuest));\n        updateAddUser(context);\n\n        if (!mUserCaps.mUserSwitcherEnabled) {\n            return;\n        }\n\n        for (UserPreference userPreference : userPreferences) {\n            userPreference.setOrder(Preference.DEFAULT_ORDER);\n            mUserListCategory.addPreference(userPreference);\n        }\n\n    }\n\n    private boolean isCurrentUserGuest() {\n        return mUserCaps.mIsGuest;\n    }\n\n    private boolean canSwitchUserNow() {\n        return mUserManager.getUserSwitchability() == UserManager.SWITCHABILITY_STATUS_OK;\n    }\n\n    private void updateAddGuest(Context context, boolean isGuestAlreadyCreated) {\n        if (!isGuestAlreadyCreated && mUserCaps.mCanAddGuest\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && mUserCaps.mUserSwitcherEnabled) {\n            mAddGuest.setVisible(true);\n            mAddGuest.setIcon(getEncircledDefaultIcon());\n            mAddGuest.setSelectable(true);\n            if (mGuestUserAutoCreated && mGuestCreationScheduled.get()) {\n                mAddGuest.setTitle(com.android.settingslib.R.string.user_guest);\n                mAddGuest.setSummary(R.string.guest_resetting);\n                mAddGuest.setEnabled(false);\n            } else {\n                mAddGuest.setTitle(com.android.settingslib.R.string.guest_new_guest);\n                mAddGuest.setEnabled(canSwitchUserNow());\n            }\n        } else {\n            mAddGuest.setVisible(false);\n        }\n    }\n\n    private void updateAddUser(Context context) {\n        if ((mUserCaps.mCanAddUser || mUserCaps.mDisallowAddUserSetByAdmin)\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && mUserCaps.mUserSwitcherEnabled) {\n            mAddUser.setVisible(true);\n            mAddUser.setSelectable(true);\n            final boolean canAddMoreUsers = mUserManager.canAddMoreUsers();\n            mAddUser.setEnabled(canAddMoreUsers && !mAddingUser && canSwitchUserNow());\n            if (!canAddMoreUsers) {\n                mAddUser.setSummary(\n                        getString(R.string.user_add_max_count, getRealUsersCount()));\n            } else {\n                mAddUser.setSummary(null);\n            }\n            if (mAddUser.isEnabled()) {\n                mAddUser.setDisabledByAdmin(\n                        mUserCaps.mDisallowAddUser ? mUserCaps.mEnforcedAdmin : null);\n            }\n        } else {\n            mAddUser.setVisible(false);\n        }\n    }\n\n    /**\n     * @return number of non-guest non-managed users\n     */\n    @VisibleForTesting\n    int getRealUsersCount() {\n        return (int) mUserManager.getUsers()\n                .stream()\n                .filter(user -> !user.isGuest() && !user.isProfile())\n                .count();\n    }\n\n    private void loadIconsAsync(List<Integer> missingIcons) {\n        new AsyncTask<List<Integer>, Void, Void>() {\n            @Override\n            protected void onPostExecute(Void result) {\n                updateUserList();\n            }\n\n            @Override\n            protected Void doInBackground(List<Integer>... values) {\n                for (int userId : values[0]) {\n                    Bitmap bitmap = mUserManager.getUserIcon(userId);\n                    if (bitmap == null) {\n                        bitmap = getDefaultUserIconAsBitmap(getContext().getResources(), userId);\n                    }\n                    mUserIcons.append(userId, bitmap);\n                }\n                return null;\n            }\n        }.execute(missingIcons);\n    }\n\n    private Drawable getEncircledDefaultIcon() {\n        if (mDefaultIconDrawable == null) {\n            mDefaultIconDrawable = encircle(\n                    getDefaultUserIconAsBitmap(getContext().getResources(), UserHandle.USER_NULL));\n        }\n        return mDefaultIconDrawable;\n    }\n\n    private void setPhotoId(Preference pref, UserInfo user) {\n        Bitmap bitmap = mUserIcons.get(user.id);\n        if (bitmap != null) {\n            pref.setIcon(encircle(bitmap));\n        }\n    }\n\n    /** Returns the user's name, or the appropriate string in the case of a Guest. */\n    public static String getUserName(Context context, @NonNull UserInfo userInfo) {\n        if (userInfo.isGuest()) {\n            return context.getString(R.string.user_guest);\n        }\n        return userInfo.name;\n    }\n\n    @Override\n    public boolean onPreferenceClick(Preference pref) {\n        if (pref == mMePreference) {\n            if (isCurrentUserGuest()) {\n                if (mGuestUserAutoCreated) {\n                    showDialog(DIALOG_CONFIRM_RESET_GUEST);\n                } else {\n                    showDialog(DIALOG_CONFIRM_EXIT_GUEST);\n                }\n            } else {\n                showDialog(DIALOG_USER_PROFILE_EDITOR);\n            }\n            return true;\n        } else if (pref instanceof UserPreference) {\n            UserInfo userInfo = mUserManager.getUserInfo(((UserPreference) pref).getUserId());\n            openUserDetails(userInfo, false);\n            return true;\n        } else if (pref == mAddUser) {\n            // If we allow both types, show a picker, otherwise directly go to\n            // flow for full user.\n            if (mUserCaps.mCanAddRestrictedProfile) {\n                showDialog(DIALOG_CHOOSE_USER_TYPE);\n            } else {\n                onAddUserClicked(USER_TYPE_USER);\n            }\n            return true;\n        } else if (pref == mAddGuest) {\n            mAddGuest.setEnabled(false); // prevent multiple tap issue\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_GUEST_ADD);\n            UserInfo guest = mUserManager.createGuest(\n                    getContext(), getString(com.android.settingslib.R.string.user_guest));\n            if (guest == null) {\n                Toast.makeText(getContext(),\n                        com.android.settingslib.R.string.add_user_failed,\n                        Toast.LENGTH_SHORT).show();\n                return true;\n            }\n            openUserDetails(guest, true);\n            return true;\n        }\n        return false;\n    }\n\n    private Drawable encircle(Bitmap icon) {\n        Drawable circled = CircleFramedDrawable.getInstance(getActivity(), icon);\n        return circled;\n    }\n\n    @Override\n    public void onDismiss(DialogInterface dialog) {\n        synchronized (mUserLock) {\n            mRemovingUserId = -1;\n            updateUserList();\n        }\n    }\n\n    @Override\n    public int getHelpResource() {\n        return R.string.help_url_users;\n    }\n\n    /**\n     * Returns a default user icon (as a {@link Bitmap}) for the given user.\n     *\n     * Note that for guest users, you should pass in {@code UserHandle.USER_NULL}.\n     *\n     * @param resources resources object to fetch the user icon.\n     * @param userId    the user id or {@code UserHandle.USER_NULL} for a non-user specific icon\n     */\n    private static Bitmap getDefaultUserIconAsBitmap(Resources resources, int userId) {\n        Bitmap bitmap = null;\n        // Try finding the corresponding bitmap in the dark bitmap cache\n        bitmap = sDarkDefaultUserBitmapCache.get(userId);\n        if (bitmap == null) {\n            bitmap = UserIcons.convertToBitmap(\n                    UserIcons.getDefaultUserIcon(resources, userId, false));\n            // Save it to cache\n            sDarkDefaultUserBitmapCache.put(userId, bitmap);\n        }\n        return bitmap;\n    }\n\n    /**\n     * Assign the default photo to user with {@paramref userId}\n     *\n     * @param context used to get the {@link UserManager}\n     * @param userId  used to get the icon bitmap\n     * @return true if assign photo successfully, false if failed\n     */\n    @VisibleForTesting\n    static boolean assignDefaultPhoto(Context context, int userId) {\n        if (context == null) {\n            return false;\n        }\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap bitmap = getDefaultUserIconAsBitmap(context.getResources(), userId);\n        um.setUserIcon(userId, bitmap);\n\n        return true;\n    }\n\n    @WorkerThread\n    static void copyMeProfilePhoto(Context context, UserInfo user) {\n        Uri contactUri = ContactsContract.Profile.CONTENT_URI;\n\n        int userId = user != null ? user.id : UserHandle.myUserId();\n\n        InputStream avatarDataStream = ContactsContract.Contacts.openContactPhotoInputStream(\n                context.getContentResolver(),\n                contactUri, true);\n        // If there's no profile photo, assign a default avatar\n        if (avatarDataStream == null) {\n            assignDefaultPhoto(context, userId);\n            return;\n        }\n\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap icon = BitmapFactory.decodeStream(avatarDataStream);\n        um.setUserIcon(userId, icon);\n        try {\n            avatarDataStream.close();\n        } catch (IOException ioe) {\n        }\n    }\n\n    public static final BaseSearchIndexProvider SEARCH_INDEX_DATA_PROVIDER =\n            new BaseSearchIndexProvider(R.xml.user_settings) {\n\n                @Override\n                protected boolean isPageSearchEnabled(Context context) {\n                    final UserCapabilities userCaps = UserCapabilities.create(context);\n                    return userCaps.mEnabled;\n                }\n\n                @Override\n                public List<String> getNonIndexableKeysFromXml(Context context, int xmlResId,\n                        boolean suppressAllPage) {\n                    final List<String> niks = super.getNonIndexableKeysFromXml(context, xmlResId,\n                            suppressAllPage);\n                    AddUserWhenLockedPreferenceController controller =\n                            new AddUserWhenLockedPreferenceController(\n                                    context, KEY_ADD_USER_WHEN_LOCKED);\n                    controller.updateNonIndexableKeys(niks);\n                    new AutoSyncDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncPersonalDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncWorkDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    return niks;\n                }\n            };\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 9612,
                                        "general": {
                                            "word_based": 3808,
                                            "char_based": 13315
                                        },
                                        "gemini": 11983
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "31e69deb2809887b5ea7b8b7a7893d7db90acdd2",
                            "repo_path": "android_repos/Settings",
                            "result": "failure",
                            "downstream_patch_content": "commit 31e69deb2809887b5ea7b8b7a7893d7db90acdd2\nAuthor: Adam Bookatz <bookatz@google.com>\nDate:   Mon Nov 18 15:53:41 2024 -0800\n\n    Don't let profiles open the UserSettings overflow [DO NOT MERGE]\n    \n    Really, profiles aren't expected to open Settings at all. But if they\n    do somehow, the overflow shouldn't appear.\n    \n    Bug: 352542820\n    Flag: EXEMPT bugfix\n    Test: Try to access the overflow of the work profile by launching its Settings in\n    adb shell am start --user 10 'com.android.settings/.Settings\\$UserSettingsActivity'\n    \n    Change-Id: I5e4c095cda3e19fa5c63c2c550a526f5da8ec5c1\n    Merged-In: I5e4c095cda3e19fa5c63c2c550a526f5da8ec5c1\n    (cherry picked from commit 69c7f5dac580361792bbb189178653b297d06c8a)\n\ndiff --git a/src/com/android/settings/users/UserSettings.java b/src/com/android/settings/users/UserSettings.java\nindex 5ee95ddc45a..a1806fe4770 100644\n--- a/src/com/android/settings/users/UserSettings.java\n+++ b/src/com/android/settings/users/UserSettings.java\n@@ -380,8 +380,8 @@ public class UserSettings extends SettingsPreferenceFragment\n         int pos = 0;\n         // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n         //  regardless of mGuestUserAutoCreated\n-        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n-                && mGuestUserAutoCreated)) {\n+        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !mUserManager.isProfile()\n+                && !(isCurrentUserGuest() && mGuestUserAutoCreated)) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n",
                            "downstream_patch_tokens": {
                                "openai": 495,
                                "general": {
                                    "word_based": 189,
                                    "char_based": 438
                                },
                                "gemini": 627
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "src/com/android/settings/users/UserSettings.java",
                                    "total_hunks": 1,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [],
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    },
                                    "rej_file_content": "```diff\n--- src/com/android/settings/users/UserSettings.java\n+++ src/com/android/settings/users/UserSettings.java\n@@ -465,7 +465,7 @@ public class UserSettings extends SettingsPreferenceFragment\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n         if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx())\n-                && !isCurrentUserGuest()) {\n+                && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n```",
                                    "rej_file_tokens": {
                                        "openai": 147,
                                        "general": {
                                            "word_based": 59,
                                            "char_based": 179
                                        },
                                        "gemini": 181
                                    },
                                    "patch_apply_output": "patching file src/com/android/settings/users/UserSettings.java\nHunk #1 FAILED at 465.\n1 out of 1 hunk FAILED -- saving rejects to file src/com/android/settings/users/UserSettings.java.rej",
                                    "inline_merge_output": "patching file src/com/android/settings/users/UserSettings.java\nHunk #1 already applied at 468.",
                                    "upstream_file_tokens": {
                                        "openai": 14655,
                                        "general": {
                                            "word_based": 5594,
                                            "char_based": 20370
                                        },
                                        "gemini": 18165
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.users;\n\nimport static com.android.settingslib.Utils.getColorAttrDefaultColor;\n\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.Dialog;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.settings.SettingsEnums;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.BlendMode;\nimport android.graphics.drawable.Drawable;\nimport android.graphics.drawable.LayerDrawable;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.ContactsContract;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.SparseArray;\nimport android.view.Gravity;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.widget.SimpleAdapter;\nimport android.widget.Toast;\n\nimport androidx.annotation.VisibleForTesting;\nimport androidx.annotation.WorkerThread;\nimport androidx.appcompat.app.AlertDialog;\nimport androidx.preference.Preference;\nimport androidx.preference.PreferenceGroup;\nimport androidx.preference.PreferenceScreen;\n\nimport com.android.internal.util.UserIcons;\nimport com.android.internal.widget.LockPatternUtils;\nimport com.android.settings.R;\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsPreferenceFragment;\nimport com.android.settings.Utils;\nimport com.android.settings.core.SubSettingLauncher;\nimport com.android.settings.password.ChooseLockGeneric;\nimport com.android.settings.search.BaseSearchIndexProvider;\nimport com.android.settings.widget.MainSwitchBarController;\nimport com.android.settings.widget.SettingsMainSwitchBar;\nimport com.android.settingslib.RestrictedLockUtils.EnforcedAdmin;\nimport com.android.settingslib.RestrictedLockUtilsInternal;\nimport com.android.settingslib.RestrictedPreference;\nimport com.android.settingslib.drawable.CircleFramedDrawable;\nimport com.android.settingslib.search.SearchIndexable;\nimport com.android.settingslib.users.EditUserInfoController;\nimport com.android.settingslib.users.UserCreatingDialog;\nimport com.android.settingslib.utils.ThreadUtils;\n\nimport com.google.android.setupcompat.util.WizardManagerHelper;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n/**\n * Screen that manages the list of users on the device.\n * Secondary users and a guest user can be created if there is no restriction.\n *\n * The first user in the list is always the current user.\n * Owner is the primary user.\n */\n@SearchIndexable\npublic class UserSettings extends SettingsPreferenceFragment\n        implements Preference.OnPreferenceClickListener,\n        MultiUserSwitchBarController.OnMultiUserSwitchChangedListener,\n        DialogInterface.OnDismissListener {\n\n    private static final String TAG = \"UserSettings\";\n\n    /** UserId of the user being removed */\n    private static final String SAVE_REMOVING_USER = \"removing_user\";\n\n    private static final String KEY_USER_LIST = \"user_list\";\n    private static final String KEY_USER_ME = \"user_me\";\n    private static final String KEY_USER_GUEST = \"user_guest\";\n    private static final String KEY_ADD_GUEST = \"guest_add\";\n    private static final String KEY_ADD_USER = \"user_add\";\n    private static final String KEY_ADD_SUPERVISED_USER = \"supervised_user_add\";\n    private static final String KEY_ADD_USER_WHEN_LOCKED = \"user_settings_add_users_when_locked\";\n    private static final String KEY_MULTIUSER_TOP_INTRO = \"multiuser_top_intro\";\n    private static final String KEY_TIMEOUT_TO_USER_ZERO = \"timeout_to_user_zero_preference\";\n\n    private static final int MENU_REMOVE_USER = Menu.FIRST;\n\n    private static final IntentFilter USER_REMOVED_INTENT_FILTER;\n\n    private static final int DIALOG_CONFIRM_REMOVE = 1;\n    private static final int DIALOG_ADD_USER = 2;\n    // Dialogs with id 3 and 4 got removed\n    private static final int DIALOG_USER_CANNOT_MANAGE = 5;\n    private static final int DIALOG_CHOOSE_USER_TYPE = 6;\n    private static final int DIALOG_NEED_LOCKSCREEN = 7;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST = 8;\n    private static final int DIALOG_USER_PROFILE_EDITOR = 9;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_USER = 10;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE = 11;\n    private static final int DIALOG_CONFIRM_RESET_GUEST = 12;\n\n    private static final int MESSAGE_UPDATE_LIST = 1;\n    private static final int MESSAGE_USER_CREATED = 2;\n\n    private static final int USER_TYPE_USER = 1;\n    private static final int USER_TYPE_RESTRICTED_PROFILE = 2;\n\n    private static final int REQUEST_CHOOSE_LOCK = 10;\n    private static final int REQUEST_EDIT_GUEST = 11;\n\n    static final int RESULT_GUEST_REMOVED = 100;\n\n    private static final String KEY_ADD_USER_LONG_MESSAGE_DISPLAYED =\n            \"key_add_user_long_message_displayed\";\n\n    private static final String KEY_TITLE = \"title\";\n    private static final String KEY_SUMMARY = \"summary\";\n\n    static {\n        USER_REMOVED_INTENT_FILTER = new IntentFilter(Intent.ACTION_USER_REMOVED);\n        USER_REMOVED_INTENT_FILTER.addAction(Intent.ACTION_USER_INFO_CHANGED);\n    }\n\n    @VisibleForTesting\n    PreferenceGroup mUserListCategory;\n    @VisibleForTesting\n    UserPreference mMePreference;\n    @VisibleForTesting\n    RestrictedPreference mAddGuest;\n    @VisibleForTesting\n    RestrictedPreference mAddUser;\n    @VisibleForTesting\n    RestrictedPreference mAddSupervisedUser;\n    @VisibleForTesting\n    SparseArray<Bitmap> mUserIcons = new SparseArray<>();\n    private int mRemovingUserId = -1;\n    private boolean mAddingUser;\n    private boolean mGuestUserAutoCreated;\n    private String mConfigSupervisedUserCreationPackage;\n    private String mAddingUserName;\n    private UserCapabilities mUserCaps;\n    private boolean mShouldUpdateUserList = true;\n    private final Object mUserLock = new Object();\n    private UserManager mUserManager;\n    private static SparseArray<Bitmap> sDarkDefaultUserBitmapCache = new SparseArray<>();\n\n    private MultiUserSwitchBarController mSwitchBarController;\n    private EditUserInfoController mEditUserInfoController =\n            new EditUserInfoController(Utils.FILE_PROVIDER_AUTHORITY);\n    private AddUserWhenLockedPreferenceController mAddUserWhenLockedPreferenceController;\n    private MultiUserTopIntroPreferenceController mMultiUserTopIntroPreferenceController;\n    private TimeoutToUserZeroPreferenceController mTimeoutToUserZeroPreferenceController;\n    private UserCreatingDialog mUserCreatingDialog;\n    private final AtomicBoolean mGuestCreationScheduled = new AtomicBoolean();\n    private final ExecutorService mExecutor = Executors.newSingleThreadExecutor();\n\n    private CharSequence mPendingUserName;\n    private Drawable mPendingUserIcon;\n\n    // A place to cache the generated default avatar\n    private Drawable mDefaultIconDrawable;\n\n    // TODO:   Replace current Handler solution to something that doesn't leak memory and works\n    // TODO:   during a configuration change\n    private Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MESSAGE_UPDATE_LIST:\n                    updateUserList();\n                    break;\n                case MESSAGE_USER_CREATED:\n                    onUserCreated(msg.arg1);\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mUserChangeReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(Intent.ACTION_USER_REMOVED)) {\n                mRemovingUserId = -1;\n            } else if (intent.getAction().equals(Intent.ACTION_USER_INFO_CHANGED)) {\n                int userHandle = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);\n                if (userHandle != -1) {\n                    mUserIcons.remove(userHandle);\n                }\n            }\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n        }\n    };\n\n    @Override\n    public int getMetricsCategory() {\n        return SettingsEnums.USER;\n    }\n\n    @Override\n    public void onActivityCreated(Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n        // Assume we are in a SettingsActivity. This is only safe because we currently use\n        // SettingsActivity as base for all preference fragments.\n        final SettingsActivity activity = (SettingsActivity) getActivity();\n        final SettingsMainSwitchBar switchBar = activity.getSwitchBar();\n        switchBar.setTitle(getContext().getString(R.string.multiple_users_main_switch_title));\n        switchBar.show();\n        mSwitchBarController = new MultiUserSwitchBarController(activity,\n                new MainSwitchBarController(switchBar), this /* listener */);\n        getSettingsLifecycle().addObserver(mSwitchBarController);\n    }\n\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        addPreferencesFromResource(R.xml.user_settings);\n        final Activity activity = getActivity();\n        if (!WizardManagerHelper.isDeviceProvisioned(activity)) {\n            activity.finish();\n            return;\n        }\n\n        mGuestUserAutoCreated = getPrefContext().getResources().getBoolean(\n                        com.android.internal.R.bool.config_guestUserAutoCreated);\n\n        mAddUserWhenLockedPreferenceController = new AddUserWhenLockedPreferenceController(\n                activity, KEY_ADD_USER_WHEN_LOCKED);\n\n        mMultiUserTopIntroPreferenceController = new MultiUserTopIntroPreferenceController(activity,\n                KEY_MULTIUSER_TOP_INTRO);\n\n        mTimeoutToUserZeroPreferenceController = new TimeoutToUserZeroPreferenceController(activity,\n                KEY_TIMEOUT_TO_USER_ZERO);\n\n        final PreferenceScreen screen = getPreferenceScreen();\n        mAddUserWhenLockedPreferenceController.displayPreference(screen);\n        mMultiUserTopIntroPreferenceController.displayPreference(screen);\n        mTimeoutToUserZeroPreferenceController.displayPreference(screen);\n\n        screen.findPreference(mAddUserWhenLockedPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mAddUserWhenLockedPreferenceController);\n\n        if (icicle != null) {\n            if (icicle.containsKey(SAVE_REMOVING_USER)) {\n                mRemovingUserId = icicle.getInt(SAVE_REMOVING_USER);\n            }\n            mEditUserInfoController.onRestoreInstanceState(icicle);\n        }\n\n        mUserCaps = UserCapabilities.create(activity);\n        mUserManager = (UserManager) activity.getSystemService(Context.USER_SERVICE);\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n\n        final int myUserId = UserHandle.myUserId();\n\n        mUserListCategory = (PreferenceGroup) findPreference(KEY_USER_LIST);\n        mMePreference = new UserPreference(getPrefContext(), null /* attrs */, myUserId);\n        mMePreference.setKey(KEY_USER_ME);\n        mMePreference.setOnPreferenceClickListener(this);\n        if (mUserCaps.mIsAdmin) {\n            mMePreference.setSummary(R.string.user_admin);\n        }\n\n        mAddGuest = findPreference(KEY_ADD_GUEST);\n        mAddGuest.setOnPreferenceClickListener(this);\n\n        mAddUser = findPreference(KEY_ADD_USER);\n        if (!mUserCaps.mCanAddRestrictedProfile) {\n            // Label should only mention adding a \"user\", not a \"profile\"\n            mAddUser.setTitle(com.android.settingslib.R.string.user_add_user);\n        }\n        mAddUser.setOnPreferenceClickListener(this);\n\n        setConfigSupervisedUserCreationPackage();\n        mAddSupervisedUser = findPreference(KEY_ADD_SUPERVISED_USER);\n        mAddSupervisedUser.setOnPreferenceClickListener(this);\n\n        activity.registerReceiverAsUser(\n                mUserChangeReceiver, UserHandle.ALL, USER_REMOVED_INTENT_FILTER, null, mHandler,\n                Context.RECEIVER_EXPORTED_UNAUDITED);\n\n        updateUI();\n        mShouldUpdateUserList = false;\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n        final PreferenceScreen screen = getPreferenceScreen();\n\n        mAddUserWhenLockedPreferenceController.updateState(screen.findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey()));\n        mTimeoutToUserZeroPreferenceController.updateState(screen.findPreference(\n                mTimeoutToUserZeroPreferenceController.getPreferenceKey()));\n\n        if (mShouldUpdateUserList) {\n            updateUI();\n        }\n    }\n\n    @Override\n    public void onPause() {\n        mShouldUpdateUserList = true;\n        super.onPause();\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n\n        if (mUserCaps == null || !mUserCaps.mEnabled) {\n            return;\n        }\n\n        getActivity().unregisterReceiver(mUserChangeReceiver);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        mEditUserInfoController.onSaveInstanceState(outState);\n        outState.putInt(SAVE_REMOVING_USER, mRemovingUserId);\n        super.onSaveInstanceState(outState);\n    }\n\n    @Override\n    public void startActivityForResult(Intent intent, int requestCode) {\n        mEditUserInfoController.startingActivityForResult();\n        super.startActivityForResult(intent, requestCode);\n    }\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        int pos = 0;\n        // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n        //  regardless of mGuestUserAutoCreated\n        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n                && mGuestUserAutoCreated)) {\n            String nickname = mUserManager.getUserName();\n            MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                    getResources().getString(R.string.user_remove_user_menu, nickname));\n            removeThisUser.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n\n            final EnforcedAdmin disallowRemoveUserAdmin =\n                    RestrictedLockUtilsInternal.checkIfRestrictionEnforced(getContext(),\n                            UserManager.DISALLOW_REMOVE_USER, UserHandle.myUserId());\n            RestrictedLockUtilsInternal.setMenuItemAsDisabledByAdmin(getContext(), removeThisUser,\n                    disallowRemoveUserAdmin);\n        }\n        super.onCreateOptionsMenu(menu, inflater);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        final int itemId = item.getItemId();\n        if (itemId == MENU_REMOVE_USER) {\n            onRemoveUserClicked(UserHandle.myUserId());\n            return true;\n        } else {\n            return super.onOptionsItemSelected(item);\n        }\n    }\n\n    @Override\n    public void onMultiUserSwitchChanged(boolean newState) {\n        updateUI();\n    }\n\n    private void updateUI() {\n        mUserCaps.updateAddUserCapabilities(getActivity());\n        loadProfile();\n        updateUserList();\n    }\n\n    /**\n     * Loads profile information for the current user.\n     */\n    private void loadProfile() {\n        if (isCurrentUserGuest()) {\n            // No need to load profile information\n            mMePreference.setIcon(getEncircledDefaultIcon());\n            mMePreference.setTitle(mGuestUserAutoCreated\n                    ? com.android.settingslib.R.string.guest_reset_guest\n                    : com.android.settingslib.R.string.guest_exit_guest);\n            mMePreference.setSelectable(true);\n            // removing a guest will result in switching back to the admin user\n            mMePreference.setEnabled(canSwitchUserNow());\n            return;\n        }\n\n        new AsyncTask<Void, Void, String>() {\n            @Override\n            protected void onPostExecute(String result) {\n                finishLoadProfile(result);\n            }\n\n            @Override\n            protected String doInBackground(Void... values) {\n                UserInfo user = mUserManager.getUserInfo(UserHandle.myUserId());\n                if (user.iconPath == null || user.iconPath.equals(\"\")) {\n                    // Assign profile photo.\n                    copyMeProfilePhoto(getActivity(), user);\n                }\n                return user.name;\n            }\n        }.execute();\n    }\n\n    private void finishLoadProfile(String profileName) {\n        if (getActivity() == null) {\n            return;\n        }\n        mMePreference.setTitle(getString(R.string.user_you, profileName));\n        int myUserId = UserHandle.myUserId();\n        Bitmap b = mUserManager.getUserIcon(myUserId);\n        if (b != null) {\n            mMePreference.setIcon(encircle(b));\n            mUserIcons.put(myUserId, b);\n        }\n    }\n\n    private boolean hasLockscreenSecurity() {\n        LockPatternUtils lpu = new LockPatternUtils(getActivity());\n        return lpu.isSecure(UserHandle.myUserId());\n    }\n\n    private void launchChooseLockscreen() {\n        Intent chooseLockIntent = new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD);\n        chooseLockIntent.putExtra(ChooseLockGeneric.ChooseLockGenericFragment.HIDE_INSECURE_OPTIONS,\n                true);\n        startActivityForResult(chooseLockIntent, REQUEST_CHOOSE_LOCK);\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n\n        if (requestCode == REQUEST_CHOOSE_LOCK) {\n            if (resultCode != Activity.RESULT_CANCELED && hasLockscreenSecurity()) {\n                addUserNow(USER_TYPE_RESTRICTED_PROFILE);\n            }\n        } else if (mGuestUserAutoCreated && requestCode == REQUEST_EDIT_GUEST\n                && resultCode == RESULT_GUEST_REMOVED) {\n            scheduleGuestCreation();\n        } else {\n            mEditUserInfoController.onActivityResult(requestCode, resultCode, data);\n        }\n    }\n\n    private void onAddUserClicked(int userType) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                switch (userType) {\n                    case USER_TYPE_USER:\n                        showDialog(DIALOG_ADD_USER);\n                        break;\n                    case USER_TYPE_RESTRICTED_PROFILE:\n                        if (hasLockscreenSecurity()) {\n                            showDialog(DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE);\n                        } else {\n                            showDialog(DIALOG_NEED_LOCKSCREEN);\n                        }\n                        break;\n                }\n            }\n        }\n    }\n\n    private void onAddSupervisedUserClicked() {\n        final Intent intent = new Intent()\n                .setAction(UserManager.ACTION_CREATE_SUPERVISED_USER)\n                .setPackage(mConfigSupervisedUserCreationPackage)\n                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\n        startActivity(intent);\n    }\n\n    private void onAddGuestClicked() {\n        final UserCreatingDialog guestCreatingDialog =\n                new UserCreatingDialog(getActivity(), /* isGuest= */ true);\n        guestCreatingDialog.show();\n\n        ThreadUtils.postOnBackgroundThread(() -> {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_GUEST_ADD);\n            Trace.beginSection(\"UserSettings.addGuest\");\n            final UserInfo guest = mUserManager.createGuest(getContext());\n            Trace.endSection();\n\n            ThreadUtils.postOnMainThread(() -> {\n                guestCreatingDialog.dismiss();\n                if (guest == null) {\n                    Toast.makeText(getContext(),\n                            com.android.settingslib.R.string.add_guest_failed,\n                            Toast.LENGTH_SHORT).show();\n                    return;\n                }\n                openUserDetails(guest, true);\n            });\n        });\n    }\n\n    private void onRemoveUserClicked(int userId) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                mRemovingUserId = userId;\n                showDialog(DIALOG_CONFIRM_REMOVE);\n            }\n        }\n    }\n\n    private void onUserCreated(int userId) {\n        hideUserCreatingDialog();\n        // prevent crash when config changes during user creation\n        if (getContext() == null) {\n            return;\n        }\n        mAddingUser = false;\n        UserInfo userInfo = mUserManager.getUserInfo(userId);\n        openUserDetails(userInfo, true);\n    }\n\n    private void hideUserCreatingDialog() {\n        if (mUserCreatingDialog != null && mUserCreatingDialog.isShowing()) {\n            mUserCreatingDialog.dismiss();\n        }\n    }\n\n    private void onUserCreationFailed() {\n        Toast.makeText(getContext(),\n                com.android.settingslib.R.string.add_user_failed,\n                Toast.LENGTH_SHORT).show();\n        hideUserCreatingDialog();\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser) {\n        Bundle extras = new Bundle();\n        extras.putInt(UserDetailsSettings.EXTRA_USER_ID, userInfo.id);\n        extras.putBoolean(AppRestrictionsFragment.EXTRA_NEW_USER, newUser);\n\n        SubSettingLauncher launcher = new SubSettingLauncher(getContext())\n                .setDestination(UserDetailsSettings.class.getName())\n                .setArguments(extras)\n                .setTitleText(userInfo.name)\n                .setSourceMetricsCategory(getMetricsCategory());\n        if (mGuestUserAutoCreated && userInfo.isGuest()) {\n            launcher.setResultListener(this, REQUEST_EDIT_GUEST);\n        }\n        launcher.launch();\n    }\n\n    @Override\n    public void onDialogShowing() {\n        super.onDialogShowing();\n\n        setOnDismissListener(this);\n    }\n\n    @Override\n    public Dialog onCreateDialog(int dialogId) {\n        Context context = getActivity();\n        if (context == null) {\n            return null;\n        }\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE: {\n                Dialog dlg =\n                        UserDialogs.createRemoveDialog(getActivity(), mRemovingUserId,\n                                new DialogInterface.OnClickListener() {\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        removeUserNow();\n                                    }\n                                }\n                        );\n                return dlg;\n            }\n            case DIALOG_USER_CANNOT_MANAGE:\n                return new AlertDialog.Builder(context)\n                        .setMessage(R.string.user_cannot_manage_message)\n                        .setPositiveButton(android.R.string.ok, null)\n                        .create();\n            case DIALOG_ADD_USER: {\n                final SharedPreferences preferences = getActivity().getPreferences(\n                        Context.MODE_PRIVATE);\n                final boolean longMessageDisplayed = preferences.getBoolean(\n                        KEY_ADD_USER_LONG_MESSAGE_DISPLAYED, false);\n                final int messageResId = longMessageDisplayed\n                        ? com.android.settingslib.R.string.user_add_user_message_short\n                        : com.android.settingslib.R.string.user_add_user_message_long;\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.user_add_user_title)\n                        .setMessage(messageResId)\n                        .setPositiveButton(android.R.string.ok,\n                                new DialogInterface.OnClickListener() {\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        showDialog(DIALOG_USER_PROFILE_EDITOR_ADD_USER);\n                                        if (!longMessageDisplayed) {\n                                            preferences.edit().putBoolean(\n                                                    KEY_ADD_USER_LONG_MESSAGE_DISPLAYED,\n                                                    true).apply();\n                                        }\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CHOOSE_USER_TYPE: {\n                List<HashMap<String, String>> data = new ArrayList<HashMap<String, String>>();\n                HashMap<String, String> addUserItem = new HashMap<String, String>();\n                addUserItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_user_item_title));\n                addUserItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_user_item_summary));\n                HashMap<String, String> addProfileItem = new HashMap<String, String>();\n                addProfileItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_title));\n                addProfileItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_summary));\n                data.add(addUserItem);\n                data.add(addProfileItem);\n                AlertDialog.Builder builder = new AlertDialog.Builder(context);\n                SimpleAdapter adapter = new SimpleAdapter(builder.getContext(),\n                        data, R.layout.two_line_list_item,\n                        new String[]{KEY_TITLE, KEY_SUMMARY},\n                        new int[]{R.id.title, R.id.summary});\n                builder.setTitle(com.android.settingslib.R.string.user_add_user_type_title);\n                builder.setAdapter(adapter,\n                        new DialogInterface.OnClickListener() {\n                            @Override\n                            public void onClick(DialogInterface dialog, int which) {\n                                onAddUserClicked(which == 0\n                                        ? USER_TYPE_USER\n                                        : USER_TYPE_RESTRICTED_PROFILE);\n                            }\n                        });\n                return builder.create();\n            }\n            case DIALOG_NEED_LOCKSCREEN: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setMessage(com.android.settingslib.R.string.user_need_lock_message)\n                        .setPositiveButton(com.android.settingslib.R.string.user_set_lock_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        launchChooseLockscreen();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.guest_remove_guest_dialog_title)\n                        .setMessage(R.string.user_exit_guest_confirm_message)\n                        .setPositiveButton(R.string.user_exit_guest_dialog_remove,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        exitGuest();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_USER_PROFILE_EDITOR: {\n                return buildEditCurrentUserDialog();\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_user_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_USER);\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_profile_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_RESTRICTED_PROFILE);\n            }\n            case DIALOG_CONFIRM_RESET_GUEST: {\n                if (mGuestUserAutoCreated) {\n                    return UserDialogs.createResetGuestDialog(getActivity(),\n                        (dialog, which) -> resetGuest());\n                } else {\n                    return UserDialogs.createRemoveGuestDialog(getActivity(),\n                        (dialog, which) -> resetGuest());\n                }\n            }\n            default:\n                return null;\n        }\n    }\n\n    private Dialog buildEditCurrentUserDialog() {\n        final Activity activity = getActivity();\n        if (activity == null) {\n            return null;\n        }\n\n        UserInfo user = mUserManager.getUserInfo(Process.myUserHandle().getIdentifier());\n        Drawable userIcon = Utils.getUserIcon(activity, mUserManager, user);\n\n        return mEditUserInfoController.createDialog(\n                activity,\n                this::startActivityForResult,\n                userIcon,\n                user.name,\n                getString(com.android.settingslib.R.string.profile_info_settings_title),\n                (newUserName, newUserIcon) -> {\n                    if (newUserIcon != userIcon) {\n                        ThreadUtils.postOnBackgroundThread(() ->\n                                mUserManager.setUserIcon(user.id,\n                                        UserIcons.convertToBitmapAtUserIconSize(\n                                                activity.getResources(), newUserIcon)));\n                        mMePreference.setIcon(newUserIcon);\n                    }\n\n                    if (!TextUtils.isEmpty(newUserName) && !newUserName.equals(user.name)) {\n                        mMePreference.setTitle(newUserName);\n                        mUserManager.setUserName(user.id, newUserName);\n                    }\n                }, null);\n    }\n\n    private Dialog buildAddUserDialog(int userType) {\n        Dialog d;\n        synchronized (mUserLock) {\n            d = mEditUserInfoController.createDialog(\n                    getActivity(),\n                    this::startActivityForResult,\n                    null,\n                    mPendingUserName.toString(),\n                    getString(userType == USER_TYPE_USER\n                            ? com.android.settingslib.R.string.user_info_settings_title\n                            : com.android.settingslib.R.string.profile_info_settings_title),\n                    (userName, userIcon) -> {\n                        mPendingUserIcon = userIcon;\n                        mPendingUserName = userName;\n                        addUserNow(userType);\n                    },\n                    () -> {\n                        synchronized (mUserLock) {\n                            mPendingUserIcon = null;\n                            mPendingUserName = null;\n                        }\n                    }\n            );\n        }\n        return d;\n    }\n\n    @Override\n    public int getDialogMetricsCategory(int dialogId) {\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE:\n                return SettingsEnums.DIALOG_USER_REMOVE;\n            case DIALOG_USER_CANNOT_MANAGE:\n                return SettingsEnums.DIALOG_USER_CANNOT_MANAGE;\n            case DIALOG_ADD_USER:\n                return SettingsEnums.DIALOG_USER_ADD;\n            case DIALOG_CHOOSE_USER_TYPE:\n                return SettingsEnums.DIALOG_USER_CHOOSE_TYPE;\n            case DIALOG_NEED_LOCKSCREEN:\n                return SettingsEnums.DIALOG_USER_NEED_LOCKSCREEN;\n            case DIALOG_CONFIRM_EXIT_GUEST:\n            case DIALOG_CONFIRM_RESET_GUEST:\n                return SettingsEnums.DIALOG_USER_CONFIRM_EXIT_GUEST;\n            case DIALOG_USER_PROFILE_EDITOR:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE:\n                return SettingsEnums.DIALOG_USER_EDIT_PROFILE;\n            default:\n                return 0;\n        }\n    }\n\n    private void removeUserNow() {\n        if (mRemovingUserId == UserHandle.myUserId()) {\n            removeThisUser();\n        } else {\n            ThreadUtils.postOnBackgroundThread(new Runnable() {\n                @Override\n                public void run() {\n                    synchronized (mUserLock) {\n                        mUserManager.removeUser(mRemovingUserId);\n                        mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n                    }\n                }\n            });\n        }\n    }\n\n    private void removeThisUser() {\n        if (!canSwitchUserNow()) {\n            Log.w(TAG, \"Cannot remove current user when switching is disabled\");\n            return;\n        }\n        try {\n            getContext().getSystemService(UserManager.class)\n                    .removeUserWhenPossible(UserHandle.of(UserHandle.myUserId()),\n                            /* overrideDevicePolicy= */ false);\n            ActivityManager.getService().switchUser(UserHandle.USER_SYSTEM);\n        } catch (RemoteException re) {\n            Log.e(TAG, \"Unable to remove self user\");\n        }\n    }\n\n    private void addUserNow(final int userType) {\n        Trace.beginAsyncSection(\"UserSettings.addUserNow\", 0);\n        synchronized (mUserLock) {\n            mAddingUser = true;\n            mAddingUserName = userType == USER_TYPE_USER\n                    ? (mPendingUserName != null ? mPendingUserName.toString()\n                    : getString(R.string.user_new_user_name))\n                    : (mPendingUserName != null ? mPendingUserName.toString()\n                            : getString(R.string.user_new_profile_name));\n        }\n\n        mUserCreatingDialog = new UserCreatingDialog(getActivity());\n        mUserCreatingDialog.show();\n        ThreadUtils.postOnBackgroundThread(new AddUserNowImpl(userType, mAddingUserName));\n    }\n\n    @VisibleForTesting\n    class AddUserNowImpl implements Runnable{\n        int mUserType;\n        String mImplAddUserName;\n\n        AddUserNowImpl(final int userType, final String addUserName) {\n            mUserType = userType;\n            mImplAddUserName = addUserName;\n        }\n\n        @Override\n        public void run() {\n            runAddUser();\n            Trace.endAsyncSection(\"UserSettings.addUserNow\", 0);\n        }\n\n        private void runAddUser() {\n            UserInfo user;\n            String username;\n\n            synchronized (mUserLock) {\n                username = mImplAddUserName;\n            }\n\n            // Could take a few seconds\n            if (mUserType == USER_TYPE_USER) {\n                user = mUserManager.createUser(username, 0);\n            } else {\n                user = mUserManager.createRestrictedProfile(username);\n            }\n\n            synchronized (mUserLock) {\n                if (user == null) {\n                    mAddingUser = false;\n                    mPendingUserIcon = null;\n                    mPendingUserName = null;\n                    ThreadUtils.postOnMainThread(() -> onUserCreationFailed());\n                    return;\n                }\n\n                Drawable newUserIcon = mPendingUserIcon;\n                if (newUserIcon == null) {\n                    newUserIcon = UserIcons.getDefaultUserIcon(getResources(), user.id, false);\n                }\n                mUserManager.setUserIcon(\n                        user.id, UserIcons.convertToBitmapAtUserIconSize(\n                                getResources(), newUserIcon));\n\n                if (mUserType == USER_TYPE_USER) {\n                    mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n                }\n\n                mHandler.sendMessage(mHandler.obtainMessage(\n                        MESSAGE_USER_CREATED, user.id, user.serialNumber));\n\n                mPendingUserIcon = null;\n                mPendingUserName = null;\n            }\n        }\n    };\n\n    /**\n     * Erase the current user (guest) and switch to another user.\n     */\n    @VisibleForTesting\n    void exitGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mMetricsFeatureProvider.action(getActivity(),\n                SettingsEnums.ACTION_USER_GUEST_EXIT_CONFIRMED);\n        removeThisUser();\n    }\n\n    /**\n     * Erase the current user (assuming it is a guest user), and create a new one in the background\n     */\n    @VisibleForTesting\n    void resetGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        int guestUserId = UserHandle.myUserId();\n        // Using markGuestForDeletion allows us to create a new guest before this one is\n        // fully removed. This could happen if someone calls scheduleGuestCreation()\n        // immediately after calling this method.\n        boolean marked = mUserManager.markGuestForDeletion(guestUserId);\n        if (!marked) {\n            Log.w(TAG, \"Couldn't mark the guest for deletion for user \" + guestUserId);\n            return;\n        }\n        exitGuest();\n        scheduleGuestCreation();\n    }\n\n    /**\n     * Create a guest user in the background\n     */\n    @VisibleForTesting\n    void scheduleGuestCreation() {\n        // TODO(b/191067027): Move guest recreation to system_server\n        if (mGuestCreationScheduled.compareAndSet(/* expect= */ false, /* update= */ true)) {\n            // Once mGuestCreationScheduled=true, mAddGuest needs to be updated so that it shows\n            // \"Resetting guest...\"\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            mExecutor.execute(() -> {\n                UserInfo guest = mUserManager.createGuest(getContext());\n                mGuestCreationScheduled.set(false);\n                if (guest == null) {\n                    Log.e(TAG, \"Unable to automatically recreate guest user\");\n                }\n                // The list needs to be updated whether or not guest creation worked. If guest\n                // creation failed, the list needs to update so that \"Add guest\" is displayed.\n                // Otherwise, the UX could be stuck in a state where there is no way to switch to\n                // the guest user (e.g. Guest would not be selectable, and it would be stuck\n                // saying \"Resetting guest...\")\n                mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            });\n        }\n    }\n\n    @VisibleForTesting\n    void updateUserList() {\n        final Context context = getActivity();\n        if (context == null) {\n            return;\n        }\n        final List<UserInfo> users = mUserManager.getAliveUsers();\n\n        final ArrayList<Integer> missingIcons = new ArrayList<>();\n        final ArrayList<UserPreference> userPreferences = new ArrayList<>();\n        userPreferences.add(mMePreference);\n\n        boolean canOpenUserDetails =\n                mUserCaps.mIsAdmin || (canSwitchUserNow() && !mUserCaps.mDisallowSwitchUser);\n        for (UserInfo user : users) {\n            if (!user.supportsSwitchToByUser()) {\n                // Only users that can be switched to should show up here.\n                // e.g. Managed profiles appear under Accounts Settings instead\n                continue;\n            }\n            UserPreference pref;\n            if (user.id == UserHandle.myUserId()) {\n                pref = mMePreference;\n            } else {\n                pref = new UserPreference(getPrefContext(), null, user.id);\n                pref.setTitle(user.name);\n                userPreferences.add(pref);\n                pref.setOnPreferenceClickListener(this);\n                pref.setEnabled(canOpenUserDetails);\n                pref.setSelectable(true);\n\n                if (user.isGuest()) {\n                    pref.setIcon(getEncircledDefaultIcon());\n                    pref.setKey(KEY_USER_GUEST);\n                    if (mUserCaps.mDisallowSwitchUser) {\n                        pref.setDisabledByAdmin(\n                                RestrictedLockUtilsInternal.getDeviceOwner(context));\n                    } else {\n                        pref.setDisabledByAdmin(null);\n                    }\n                } else {\n                    pref.setKey(\"id=\" + user.id);\n                    if (user.isAdmin()) {\n                        pref.setSummary(R.string.user_admin);\n                    }\n                }\n            }\n            if (pref == null) {\n                continue;\n            }\n            if (user.id != UserHandle.myUserId() && !user.isGuest() && !user.isInitialized()) {\n                // sometimes after creating a guest the initialized flag isn't immediately set\n                // and we don't want to show \"Not set up\" summary for them\n                if (user.isRestricted()) {\n                    pref.setSummary(R.string.user_summary_restricted_not_set_up);\n                } else {\n                    pref.setSummary(R.string.user_summary_not_set_up);\n                    // Disallow setting up user which results in user switching when the\n                    // restriction is set.\n                    pref.setEnabled(!mUserCaps.mDisallowSwitchUser && canSwitchUserNow());\n                }\n            } else if (user.isRestricted()) {\n                pref.setSummary(R.string.user_summary_restricted_profile);\n            }\n            if (user.iconPath != null) {\n                if (mUserIcons.get(user.id) == null) {\n                    // Icon not loaded yet, print a placeholder\n                    missingIcons.add(user.id);\n                    pref.setIcon(getEncircledDefaultIcon());\n                } else {\n                    setPhotoId(pref, user);\n                }\n            } else {\n                // Icon not available yet, print a placeholder\n                pref.setIcon(getEncircledDefaultIcon());\n            }\n        }\n\n        // Add a temporary entry for the user being created\n        if (mAddingUser) {\n            UserPreference pref = new UserPreference(getPrefContext(), null,\n                    UserPreference.USERID_UNKNOWN);\n            pref.setEnabled(false);\n            pref.setTitle(mAddingUserName);\n            pref.setIcon(getEncircledDefaultIcon());\n            userPreferences.add(pref);\n        }\n\n\n        // Sort list of users by serialNum\n        Collections.sort(userPreferences, UserPreference.SERIAL_NUMBER_COMPARATOR);\n\n        getActivity().invalidateOptionsMenu();\n\n        // Load the icons\n        if (missingIcons.size() > 0) {\n            loadIconsAsync(missingIcons);\n        }\n\n        // If profiles are supported, mUserListCategory will have a special title\n        if (mUserCaps.mCanAddRestrictedProfile) {\n            mUserListCategory.setTitle(R.string.user_list_title);\n        } else {\n            mUserListCategory.setTitle(null);\n            mUserListCategory.setLayoutResource(R.layout.empty_view);\n        }\n\n        // Remove everything from mUserListCategory and add new users.\n        mUserListCategory.removeAll();\n\n        // If multi-user is disabled, just show top info and return.\n        final Preference addUserOnLockScreen = getPreferenceScreen().findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey());\n        mAddUserWhenLockedPreferenceController.updateState(addUserOnLockScreen);\n\n        final Preference multiUserTopIntroPrefence = getPreferenceScreen().findPreference(\n                mMultiUserTopIntroPreferenceController.getPreferenceKey());\n        mMultiUserTopIntroPreferenceController.updateState(multiUserTopIntroPrefence);\n        mUserListCategory.setVisible(mUserCaps.mUserSwitcherEnabled);\n\n        updateAddGuest(context, users.stream().anyMatch(UserInfo::isGuest));\n        updateAddUser(context);\n        updateAddSupervisedUser(context);\n\n        if (!mUserCaps.mUserSwitcherEnabled) {\n            return;\n        }\n\n        for (UserPreference userPreference : userPreferences) {\n            userPreference.setOrder(Preference.DEFAULT_ORDER);\n            mUserListCategory.addPreference(userPreference);\n        }\n\n    }\n\n    @VisibleForTesting\n    void setConfigSupervisedUserCreationPackage() {\n        mConfigSupervisedUserCreationPackage = getPrefContext().getString(\n                com.android.internal.R.string.config_supervisedUserCreationPackage);\n    }\n\n    private boolean isCurrentUserGuest() {\n        return mUserCaps.mIsGuest;\n    }\n\n    private boolean canSwitchUserNow() {\n        return mUserManager.getUserSwitchability() == UserManager.SWITCHABILITY_STATUS_OK;\n    }\n\n    private void updateAddGuest(Context context, boolean isGuestAlreadyCreated) {\n        if (!isGuestAlreadyCreated && mUserCaps.mCanAddGuest\n                && mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_GUEST)\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && mUserCaps.mUserSwitcherEnabled) {\n            mAddGuest.setVisible(true);\n            Drawable icon = context.getDrawable(R.drawable.ic_account_circle);\n            mAddGuest.setIcon(centerAndTint(icon));\n            mAddGuest.setSelectable(true);\n            if (mGuestUserAutoCreated && mGuestCreationScheduled.get()) {\n                mAddGuest.setTitle(com.android.internal.R.string.guest_name);\n                mAddGuest.setSummary(R.string.guest_resetting);\n                mAddGuest.setEnabled(false);\n            } else {\n                mAddGuest.setTitle(com.android.settingslib.R.string.guest_new_guest);\n                mAddGuest.setEnabled(canSwitchUserNow());\n            }\n        } else {\n            mAddGuest.setVisible(false);\n        }\n    }\n\n    private void updateAddUser(Context context) {\n        updateAddUserCommon(context, mAddUser, mUserCaps.mCanAddRestrictedProfile);\n        Drawable icon = context.getDrawable(R.drawable.ic_account_circle_filled);\n        mAddUser.setIcon(centerAndTint(icon));\n    }\n\n    private void updateAddSupervisedUser(Context context) {\n        if (!TextUtils.isEmpty(mConfigSupervisedUserCreationPackage)) {\n            updateAddUserCommon(context, mAddSupervisedUser, false);\n            Drawable icon = context.getDrawable(R.drawable.ic_add_supervised_user);\n            mAddSupervisedUser.setIcon(centerAndTint(icon));\n        } else {\n            mAddSupervisedUser.setVisible(false);\n        }\n    }\n\n    private void updateAddUserCommon(Context context, RestrictedPreference addUser,\n            boolean canAddRestrictedProfile) {\n        if ((mUserCaps.mCanAddUser || mUserCaps.mDisallowAddUserSetByAdmin)\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && mUserCaps.mUserSwitcherEnabled) {\n            addUser.setVisible(true);\n            addUser.setSelectable(true);\n            final boolean canAddMoreUsers =\n                    mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_SECONDARY)\n                            || (canAddRestrictedProfile\n                            && mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_RESTRICTED));\n            addUser.setEnabled(canAddMoreUsers && !mAddingUser && canSwitchUserNow());\n\n            if (!canAddMoreUsers) {\n                addUser.setSummary(getString(R.string.user_add_max_count));\n            } else {\n                addUser.setSummary(null);\n            }\n            if (addUser.isEnabled()) {\n                addUser.setDisabledByAdmin(\n                        mUserCaps.mDisallowAddUser ? mUserCaps.mEnforcedAdmin : null);\n            }\n        } else {\n            addUser.setVisible(false);\n        }\n    }\n\n    private Drawable centerAndTint(Drawable icon) {\n        icon.setTintBlendMode(BlendMode.SRC_IN);\n        icon.setTint(getColorAttrDefaultColor(getContext(), android.R.attr.textColorPrimary));\n\n        Drawable bg = getContext().getDrawable(R.drawable.user_avatar_bg).mutate();\n        LayerDrawable ld = new LayerDrawable(new Drawable[] {bg, icon});\n        int size = getContext().getResources().getDimensionPixelSize(\n                R.dimen.multiple_users_avatar_size);\n        ld.setLayerSize(1, size, size);\n        ld.setLayerGravity(1, Gravity.CENTER);\n\n        return ld;\n    }\n\n    /**\n     * @return number of non-guest non-managed users\n     */\n    @VisibleForTesting\n    int getRealUsersCount() {\n        return (int) mUserManager.getUsers()\n                .stream()\n                .filter(user -> !user.isGuest() && !user.isProfile())\n                .count();\n    }\n\n    private void loadIconsAsync(List<Integer> missingIcons) {\n        new AsyncTask<List<Integer>, Void, Void>() {\n            @Override\n            protected void onPostExecute(Void result) {\n                updateUserList();\n            }\n\n            @Override\n            protected Void doInBackground(List<Integer>... values) {\n                for (int userId : values[0]) {\n                    Bitmap bitmap = mUserManager.getUserIcon(userId);\n                    if (bitmap == null) {\n                        bitmap = getDefaultUserIconAsBitmap(getContext().getResources(), userId);\n                    }\n                    mUserIcons.append(userId, bitmap);\n                }\n                return null;\n            }\n        }.execute(missingIcons);\n    }\n\n    private Drawable getEncircledDefaultIcon() {\n        if (mDefaultIconDrawable == null) {\n            mDefaultIconDrawable = encircle(\n                    getDefaultUserIconAsBitmap(getContext().getResources(), UserHandle.USER_NULL));\n        }\n        return mDefaultIconDrawable;\n    }\n\n    private void setPhotoId(Preference pref, UserInfo user) {\n        Bitmap bitmap = mUserIcons.get(user.id);\n        if (bitmap != null) {\n            pref.setIcon(encircle(bitmap));\n        }\n    }\n\n    @Override\n    public boolean onPreferenceClick(Preference pref) {\n        if (pref == mMePreference) {\n            if (isCurrentUserGuest()) {\n                if (mGuestUserAutoCreated) {\n                    showDialog(DIALOG_CONFIRM_RESET_GUEST);\n                } else {\n                    showDialog(DIALOG_CONFIRM_EXIT_GUEST);\n                }\n            } else {\n                showDialog(DIALOG_USER_PROFILE_EDITOR);\n            }\n            return true;\n        } else if (pref instanceof UserPreference) {\n            UserInfo userInfo = mUserManager.getUserInfo(((UserPreference) pref).getUserId());\n            openUserDetails(userInfo, false);\n            return true;\n        } else if (pref == mAddUser) {\n            // If we allow both types, show a picker, otherwise directly go to\n            // flow for full user.\n            if (mUserCaps.mCanAddRestrictedProfile) {\n                showDialog(DIALOG_CHOOSE_USER_TYPE);\n            } else {\n                onAddUserClicked(USER_TYPE_USER);\n            }\n            return true;\n        } else if (pref == mAddSupervisedUser) {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_SUPERVISED_ADD);\n            Trace.beginSection(\"UserSettings.addSupervisedUser\");\n            onAddSupervisedUserClicked();\n            Trace.endSection();\n            return true;\n        } else if (pref == mAddGuest) {\n            mAddGuest.setEnabled(false); // prevent multiple tap issue\n            onAddGuestClicked();\n            return true;\n        }\n        return false;\n    }\n\n    private Drawable encircle(Bitmap icon) {\n        Drawable circled = CircleFramedDrawable.getInstance(getActivity(), icon);\n        return circled;\n    }\n\n    @Override\n    public void onDismiss(DialogInterface dialog) {\n        synchronized (mUserLock) {\n            mRemovingUserId = -1;\n            updateUserList();\n        }\n    }\n\n    @Override\n    public int getHelpResource() {\n        return R.string.help_url_users;\n    }\n\n    /**\n     * Returns a default user icon (as a {@link Bitmap}) for the given user.\n     *\n     * Note that for guest users, you should pass in {@code UserHandle.USER_NULL}.\n     *\n     * @param resources resources object to fetch the user icon.\n     * @param userId    the user id or {@code UserHandle.USER_NULL} for a non-user specific icon\n     */\n    private static Bitmap getDefaultUserIconAsBitmap(Resources resources, int userId) {\n        Bitmap bitmap = null;\n        // Try finding the corresponding bitmap in the dark bitmap cache\n        bitmap = sDarkDefaultUserBitmapCache.get(userId);\n        if (bitmap == null) {\n            bitmap = UserIcons.convertToBitmapAtUserIconSize(resources,\n                    UserIcons.getDefaultUserIcon(resources, userId, false));\n            // Save it to cache\n            sDarkDefaultUserBitmapCache.put(userId, bitmap);\n        }\n        return bitmap;\n    }\n\n    /**\n     * Assign the default photo to user with {@paramref userId}\n     *\n     * @param context used to get the {@link UserManager}\n     * @param userId  used to get the icon bitmap\n     * @return true if assign photo successfully, false if failed\n     */\n    @VisibleForTesting\n    static boolean assignDefaultPhoto(Context context, int userId) {\n        if (context == null) {\n            return false;\n        }\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap bitmap = getDefaultUserIconAsBitmap(context.getResources(), userId);\n        um.setUserIcon(userId, bitmap);\n\n        return true;\n    }\n\n    @WorkerThread\n    static void copyMeProfilePhoto(Context context, UserInfo user) {\n        Uri contactUri = ContactsContract.Profile.CONTENT_URI;\n\n        int userId = user != null ? user.id : UserHandle.myUserId();\n\n        InputStream avatarDataStream = ContactsContract.Contacts.openContactPhotoInputStream(\n                context.getContentResolver(),\n                contactUri, true);\n        // If there's no profile photo, assign a default avatar\n        if (avatarDataStream == null) {\n            assignDefaultPhoto(context, userId);\n            return;\n        }\n\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap icon = BitmapFactory.decodeStream(avatarDataStream);\n        um.setUserIcon(userId, icon);\n        try {\n            avatarDataStream.close();\n        } catch (IOException ioe) {\n        }\n    }\n\n    public static final BaseSearchIndexProvider SEARCH_INDEX_DATA_PROVIDER =\n            new BaseSearchIndexProvider(R.xml.user_settings) {\n\n                @Override\n                protected boolean isPageSearchEnabled(Context context) {\n                    final UserCapabilities userCaps = UserCapabilities.create(context);\n                    return userCaps.mEnabled;\n                }\n\n                @Override\n                public List<String> getNonIndexableKeysFromXml(Context context, int xmlResId,\n                        boolean suppressAllPage) {\n                    final List<String> niks = super.getNonIndexableKeysFromXml(context, xmlResId,\n                            suppressAllPage);\n                    AddUserWhenLockedPreferenceController controller =\n                            new AddUserWhenLockedPreferenceController(\n                                    context, KEY_ADD_USER_WHEN_LOCKED);\n                    controller.updateNonIndexableKeys(niks);\n                    new AutoSyncDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncPersonalDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncWorkDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    return niks;\n                }\n            };\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 10512,
                                        "general": {
                                            "word_based": 4078,
                                            "char_based": 14482
                                        },
                                        "gemini": 13080
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "6e413c4cff2f306d18e9682b1e0be5ddc8427c5f",
                            "repo_path": "android_repos/Settings",
                            "result": "failure",
                            "downstream_patch_content": "commit 6e413c4cff2f306d18e9682b1e0be5ddc8427c5f\nAuthor: Adam Bookatz <bookatz@google.com>\nDate:   Mon Nov 18 15:53:41 2024 -0800\n\n    Don't let profiles open the UserSettings overflow [DO NOT MERGE]\n    \n    Really, profiles aren't expected to open Settings at all. But if they\n    do somehow, the overflow shouldn't appear.\n    \n    Bug: 352542820\n    Flag: EXEMPT bugfix\n    Test: Try to access the overflow of the work profile by launching its Settings in\n    adb shell am start --user 10 'com.android.settings/.Settings\\$UserSettingsActivity'\n    \n    Change-Id: I5e4c095cda3e19fa5c63c2c550a526f5da8ec5c1\n    Merged-In: I5e4c095cda3e19fa5c63c2c550a526f5da8ec5c1\n    (cherry picked from commit 69c7f5dac580361792bbb189178653b297d06c8a)\n\ndiff --git a/src/com/android/settings/users/UserSettings.java b/src/com/android/settings/users/UserSettings.java\nindex 28e02ec16e2..b430068a7ef 100644\n--- a/src/com/android/settings/users/UserSettings.java\n+++ b/src/com/android/settings/users/UserSettings.java\n@@ -464,7 +464,8 @@ public class UserSettings extends SettingsPreferenceFragment\n     @Override\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n-        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest()) {\n+        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest()\n+                && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n",
                            "downstream_patch_tokens": {
                                "openai": 460,
                                "general": {
                                    "word_based": 175,
                                    "char_based": 408
                                },
                                "gemini": 587
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "src/com/android/settings/users/UserSettings.java",
                                    "total_hunks": 1,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [],
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    },
                                    "rej_file_content": "```diff\n--- src/com/android/settings/users/UserSettings.java\n+++ src/com/android/settings/users/UserSettings.java\n@@ -465,7 +465,7 @@ public class UserSettings extends SettingsPreferenceFragment\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n         if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx())\n-                && !isCurrentUserGuest()) {\n+                && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n```",
                                    "rej_file_tokens": {
                                        "openai": 147,
                                        "general": {
                                            "word_based": 59,
                                            "char_based": 179
                                        },
                                        "gemini": 181
                                    },
                                    "patch_apply_output": "patching file src/com/android/settings/users/UserSettings.java\nHunk #1 FAILED at 465.\n1 out of 1 hunk FAILED -- saving rejects to file src/com/android/settings/users/UserSettings.java.rej",
                                    "inline_merge_output": "patching file src/com/android/settings/users/UserSettings.java\nHunk #1 already applied at 468.",
                                    "upstream_file_tokens": {
                                        "openai": 14655,
                                        "general": {
                                            "word_based": 5594,
                                            "char_based": 20370
                                        },
                                        "gemini": 18165
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.users;\n\nimport static com.android.settingslib.Utils.getColorAttrDefaultColor;\n\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.Dialog;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.settings.SettingsEnums;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.BlendMode;\nimport android.graphics.drawable.Drawable;\nimport android.graphics.drawable.LayerDrawable;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.ContactsContract;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.SparseArray;\nimport android.view.Gravity;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.WindowManagerGlobal;\nimport android.widget.SimpleAdapter;\nimport android.widget.Toast;\n\nimport androidx.annotation.VisibleForTesting;\nimport androidx.annotation.WorkerThread;\nimport androidx.appcompat.app.AlertDialog;\nimport androidx.preference.Preference;\nimport androidx.preference.PreferenceGroup;\nimport androidx.preference.PreferenceScreen;\n\nimport com.android.internal.util.UserIcons;\nimport com.android.internal.widget.LockPatternUtils;\nimport com.android.settings.R;\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsPreferenceFragment;\nimport com.android.settings.Utils;\nimport com.android.settings.core.SubSettingLauncher;\nimport com.android.settings.password.ChooseLockGeneric;\nimport com.android.settings.search.BaseSearchIndexProvider;\nimport com.android.settings.widget.MainSwitchBarController;\nimport com.android.settings.widget.SettingsMainSwitchBar;\nimport com.android.settingslib.RestrictedLockUtils.EnforcedAdmin;\nimport com.android.settingslib.RestrictedLockUtilsInternal;\nimport com.android.settingslib.RestrictedPreference;\nimport com.android.settingslib.drawable.CircleFramedDrawable;\nimport com.android.settingslib.search.SearchIndexable;\nimport com.android.settingslib.search.SearchIndexableRaw;\nimport com.android.settingslib.users.CreateUserDialogController;\nimport com.android.settingslib.users.EditUserInfoController;\nimport com.android.settingslib.users.GrantAdminDialogController;\nimport com.android.settingslib.users.UserCreatingDialog;\nimport com.android.settingslib.utils.ThreadUtils;\n\nimport com.google.android.setupcompat.util.WizardManagerHelper;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.stream.Collectors;\n\n/**\n * Screen that manages the list of users on the device.\n * Secondary users and a guest user can be created if there is no restriction.\n *\n * The first user in the list is always the current user.\n * Owner is the primary user.\n */\n@SearchIndexable\npublic class UserSettings extends SettingsPreferenceFragment\n        implements Preference.OnPreferenceClickListener,\n        MultiUserSwitchBarController.OnMultiUserSwitchChangedListener,\n        DialogInterface.OnDismissListener {\n\n    private static final String TAG = \"UserSettings\";\n\n    /** UserId of the user being removed */\n    private static final String SAVE_REMOVING_USER = \"removing_user\";\n    private static final String SAVE_CREATE_USER = \"create_user\";\n\n    private static final String KEY_USER_LIST = \"user_list\";\n    private static final String KEY_USER_ME = \"user_me\";\n    private static final String KEY_USER_GUEST = \"user_guest\";\n    private static final String KEY_ADD_GUEST = \"guest_add\";\n    private static final String KEY_ADD_USER = \"user_add\";\n    private static final String KEY_ADD_SUPERVISED_USER = \"supervised_user_add\";\n    private static final String KEY_ADD_USER_WHEN_LOCKED = \"user_settings_add_users_when_locked\";\n    private static final String KEY_ENABLE_GUEST_TELEPHONY = \"enable_guest_calling\";\n    private static final String KEY_MULTIUSER_TOP_INTRO = \"multiuser_top_intro\";\n    private static final String KEY_TIMEOUT_TO_DOCK_USER = \"timeout_to_dock_user_preference\";\n    private static final String KEY_GUEST_CATEGORY = \"guest_category\";\n    private static final String KEY_GUEST_RESET = \"guest_reset\";\n    private static final String KEY_GUEST_EXIT = \"guest_exit\";\n    private static final String KEY_REMOVE_GUEST_ON_EXIT = \"remove_guest_on_exit\";\n    private static final String KEY_GUEST_USER_CATEGORY = \"guest_user_category\";\n    private static final String KEY_ALLOW_MULTIPLE_USERS = \"allow_multiple_users\";\n\n    private static final String SETTING_GUEST_HAS_LOGGED_IN = \"systemui.guest_has_logged_in\";\n\n    private static final int MENU_REMOVE_USER = Menu.FIRST;\n\n    private static final IntentFilter USER_REMOVED_INTENT_FILTER;\n\n    private static final int DIALOG_CONFIRM_REMOVE = 1;\n    private static final int DIALOG_ADD_USER = 2;\n    // Dialogs with id 3 and 4 got removed\n    private static final int DIALOG_USER_CANNOT_MANAGE = 5;\n    private static final int DIALOG_CHOOSE_USER_TYPE = 6;\n    private static final int DIALOG_NEED_LOCKSCREEN = 7;\n    private static final int DIALOG_CONFIRM_REMOVE_GUEST = 8;\n    private static final int DIALOG_USER_PROFILE_EDITOR = 9;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_USER = 10;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE = 11;\n    private static final int DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE = 12;\n    private static final int DIALOG_CONFIRM_RESET_AND_RESTART_GUEST = 13;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL = 14;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL = 15;\n    private static final int DIALOG_GRANT_ADMIN = 16;\n\n    private static final int MESSAGE_UPDATE_LIST = 1;\n    private static final int MESSAGE_USER_CREATED = 2;\n    static final int MESSAGE_REMOVE_GUEST_ON_EXIT_CONTROLLER_GUEST_REMOVED = 3;\n\n    private static final int USER_TYPE_USER = 1;\n    private static final int USER_TYPE_RESTRICTED_PROFILE = 2;\n\n    private static final int REQUEST_CHOOSE_LOCK = 10;\n    private static final int REQUEST_EDIT_GUEST = 11;\n\n    static final int RESULT_GUEST_REMOVED = 100;\n\n    private static final String KEY_TITLE = \"title\";\n    private static final String KEY_SUMMARY = \"summary\";\n\n    private static final String EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR =\n            \"EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR\";\n\n    static {\n        USER_REMOVED_INTENT_FILTER = new IntentFilter(Intent.ACTION_USER_REMOVED);\n        USER_REMOVED_INTENT_FILTER.addAction(Intent.ACTION_USER_INFO_CHANGED);\n    }\n\n    @VisibleForTesting\n    PreferenceGroup mUserListCategory;\n    @VisibleForTesting\n    PreferenceGroup mGuestUserCategory;\n    @VisibleForTesting\n    PreferenceGroup mGuestCategory;\n    @VisibleForTesting\n    Preference mGuestResetPreference;\n    @VisibleForTesting\n    Preference mGuestExitPreference;\n    @VisibleForTesting\n    UserPreference mMePreference;\n    @VisibleForTesting\n    RestrictedPreference mAddGuest;\n    @VisibleForTesting\n    RestrictedPreference mAddUser;\n    @VisibleForTesting\n    RestrictedPreference mAddSupervisedUser;\n    @VisibleForTesting\n    SparseArray<Bitmap> mUserIcons = new SparseArray<>();\n    private int mRemovingUserId = -1;\n    private boolean mAddingUser;\n    private boolean mGuestUserAutoCreated;\n    private String mConfigSupervisedUserCreationPackage;\n    private String mAddingUserName;\n    private UserCapabilities mUserCaps;\n    private boolean mShouldUpdateUserList = true;\n    private final Object mUserLock = new Object();\n    private UserManager mUserManager;\n    private static SparseArray<Bitmap> sDarkDefaultUserBitmapCache = new SparseArray<>();\n\n    private MultiUserSwitchBarController mSwitchBarController;\n\n    private GrantAdminDialogController mGrantAdminDialogController =\n            new GrantAdminDialogController();\n    private EditUserInfoController mEditUserInfoController =\n            new EditUserInfoController(Utils.FILE_PROVIDER_AUTHORITY);\n    private CreateUserDialogController mCreateUserDialogController =\n            new CreateUserDialogController(Utils.FILE_PROVIDER_AUTHORITY);\n    private AddUserWhenLockedPreferenceController mAddUserWhenLockedPreferenceController;\n    private GuestTelephonyPreferenceController mGuestTelephonyPreferenceController;\n    private RemoveGuestOnExitPreferenceController mRemoveGuestOnExitPreferenceController;\n    private MultiUserTopIntroPreferenceController mMultiUserTopIntroPreferenceController;\n    private TimeoutToDockUserPreferenceController mTimeoutToDockUserPreferenceController;\n    private UserCreatingDialog mUserCreatingDialog;\n    private final AtomicBoolean mGuestCreationScheduled = new AtomicBoolean();\n    private final ExecutorService mExecutor = Executors.newSingleThreadExecutor();\n\n    private CharSequence mPendingUserName;\n    private Drawable mPendingUserIcon;\n    private boolean mPendingUserIsAdmin;\n\n    // A place to cache the generated default avatar\n    private Drawable mDefaultIconDrawable;\n\n    // TODO:   Replace current Handler solution to something that doesn't leak memory and works\n    // TODO:   during a configuration change\n    private Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MESSAGE_UPDATE_LIST:\n                    updateUserList();\n                    break;\n                case MESSAGE_REMOVE_GUEST_ON_EXIT_CONTROLLER_GUEST_REMOVED:\n                    updateUserList();\n                    if (mGuestUserAutoCreated) {\n                        scheduleGuestCreation();\n                    }\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mUserChangeReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(Intent.ACTION_USER_REMOVED)) {\n                mRemovingUserId = -1;\n            } else if (intent.getAction().equals(Intent.ACTION_USER_INFO_CHANGED)) {\n                int userHandle = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);\n                if (userHandle != -1) {\n                    mUserIcons.remove(userHandle);\n                }\n            }\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n        }\n    };\n\n    @Override\n    public int getMetricsCategory() {\n        return SettingsEnums.USER;\n    }\n\n    @Override\n    public void onActivityCreated(Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n        // Assume we are in a SettingsActivity. This is only safe because we currently use\n        // SettingsActivity as base for all preference fragments.\n        final SettingsActivity activity = (SettingsActivity) getActivity();\n        final SettingsMainSwitchBar switchBar = activity.getSwitchBar();\n        switchBar.setTitle(getContext().getString(R.string.multiple_users_main_switch_title));\n        if (isCurrentUserAdmin()) {\n            switchBar.show();\n        } else {\n            switchBar.hide();\n        }\n        mSwitchBarController = new MultiUserSwitchBarController(activity,\n                new MainSwitchBarController(switchBar), this /* listener */);\n        getSettingsLifecycle().addObserver(mSwitchBarController);\n        boolean openUserEditDialog = getIntent().getBooleanExtra(\n                EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR, false);\n        if (switchBar.isChecked() && openUserEditDialog) {\n            showDialog(DIALOG_USER_PROFILE_EDITOR);\n        }\n    }\n\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        addPreferencesFromResource(R.xml.user_settings);\n        final Activity activity = getActivity();\n        if (!WizardManagerHelper.isDeviceProvisioned(activity)) {\n            activity.finish();\n            return;\n        }\n\n        mGuestUserAutoCreated = getPrefContext().getResources().getBoolean(\n                com.android.internal.R.bool.config_guestUserAutoCreated);\n\n        mAddUserWhenLockedPreferenceController = new AddUserWhenLockedPreferenceController(\n                activity, KEY_ADD_USER_WHEN_LOCKED);\n\n        mGuestTelephonyPreferenceController = new GuestTelephonyPreferenceController(\n                activity, KEY_ENABLE_GUEST_TELEPHONY);\n\n        mRemoveGuestOnExitPreferenceController = new RemoveGuestOnExitPreferenceController(\n                activity, KEY_REMOVE_GUEST_ON_EXIT, this, mHandler);\n\n        mMultiUserTopIntroPreferenceController = new MultiUserTopIntroPreferenceController(activity,\n                KEY_MULTIUSER_TOP_INTRO);\n\n        mTimeoutToDockUserPreferenceController = new TimeoutToDockUserPreferenceController(\n                activity, KEY_TIMEOUT_TO_DOCK_USER);\n\n        final PreferenceScreen screen = getPreferenceScreen();\n        mAddUserWhenLockedPreferenceController.displayPreference(screen);\n        mGuestTelephonyPreferenceController.displayPreference(screen);\n        mRemoveGuestOnExitPreferenceController.displayPreference(screen);\n        mMultiUserTopIntroPreferenceController.displayPreference(screen);\n        mTimeoutToDockUserPreferenceController.displayPreference(screen);\n\n        screen.findPreference(mAddUserWhenLockedPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mAddUserWhenLockedPreferenceController);\n\n        screen.findPreference(mGuestTelephonyPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mGuestTelephonyPreferenceController);\n\n        screen.findPreference(mRemoveGuestOnExitPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mRemoveGuestOnExitPreferenceController);\n\n        if (icicle != null) {\n            if (icicle.containsKey(SAVE_REMOVING_USER)) {\n                mRemovingUserId = icicle.getInt(SAVE_REMOVING_USER);\n            }\n            if (icicle.containsKey(SAVE_CREATE_USER)) {\n                mCreateUserDialogController.onRestoreInstanceState(icicle);\n            } else {\n                mEditUserInfoController.onRestoreInstanceState(icicle);\n            }\n        }\n\n        mUserCaps = UserCapabilities.create(activity);\n        mUserManager = (UserManager) activity.getSystemService(Context.USER_SERVICE);\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n\n        final int myUserId = UserHandle.myUserId();\n\n        mUserListCategory = (PreferenceGroup) findPreference(KEY_USER_LIST);\n        mMePreference = new UserPreference(getPrefContext(), null /* attrs */, myUserId);\n        mMePreference.setKey(KEY_USER_ME);\n        mMePreference.setOnPreferenceClickListener(this);\n        if (isCurrentUserAdmin()) {\n            mMePreference.setSummary(R.string.user_admin);\n        }\n\n        mGuestCategory = findPreference(KEY_GUEST_CATEGORY);\n\n        mGuestResetPreference = findPreference(KEY_GUEST_RESET);\n        mGuestResetPreference.setOnPreferenceClickListener(this);\n\n        mGuestExitPreference = findPreference(KEY_GUEST_EXIT);\n        mGuestExitPreference.setOnPreferenceClickListener(this);\n\n        mGuestUserCategory = findPreference(KEY_GUEST_USER_CATEGORY);\n\n        mAddGuest = findPreference(KEY_ADD_GUEST);\n        mAddGuest.setOnPreferenceClickListener(this);\n\n        mAddUser = findPreference(KEY_ADD_USER);\n        if (!mUserCaps.mCanAddRestrictedProfile) {\n            // Label should only mention adding a \"user\", not a \"profile\"\n            mAddUser.setTitle(com.android.settingslib.R.string.user_add_user);\n        }\n        mAddUser.setOnPreferenceClickListener(this);\n\n        setConfigSupervisedUserCreationPackage();\n        mAddSupervisedUser = findPreference(KEY_ADD_SUPERVISED_USER);\n        mAddSupervisedUser.setOnPreferenceClickListener(this);\n\n        activity.registerReceiverAsUser(\n                mUserChangeReceiver, UserHandle.ALL, USER_REMOVED_INTENT_FILTER, null, mHandler,\n                Context.RECEIVER_EXPORTED_UNAUDITED);\n\n        updateUI();\n        mShouldUpdateUserList = false;\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n        final PreferenceScreen screen = getPreferenceScreen();\n\n        mAddUserWhenLockedPreferenceController.updateState(screen.findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey()));\n        mGuestTelephonyPreferenceController.updateState(screen.findPreference(\n                mGuestTelephonyPreferenceController.getPreferenceKey()));\n        mTimeoutToDockUserPreferenceController.updateState(screen.findPreference(\n                mTimeoutToDockUserPreferenceController.getPreferenceKey()));\n        mRemoveGuestOnExitPreferenceController.updateState(screen.findPreference(\n                mRemoveGuestOnExitPreferenceController.getPreferenceKey()));\n        if (mShouldUpdateUserList) {\n            updateUI();\n        }\n    }\n\n    @Override\n    public void onPause() {\n        mShouldUpdateUserList = true;\n        super.onPause();\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n\n        if (mUserCaps == null || !mUserCaps.mEnabled) {\n            return;\n        }\n\n        getActivity().unregisterReceiver(mUserChangeReceiver);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        if (mCreateUserDialogController.isActive()) {\n            outState.putBoolean(SAVE_CREATE_USER, mCreateUserDialogController.isActive());\n            mCreateUserDialogController.onSaveInstanceState(outState);\n        } else {\n            mEditUserInfoController.onSaveInstanceState(outState);\n        }\n        outState.putInt(SAVE_REMOVING_USER, mRemovingUserId);\n        super.onSaveInstanceState(outState);\n    }\n\n    @Override\n    public void startActivityForResult(Intent intent, int requestCode) {\n        mEditUserInfoController.startingActivityForResult();\n        mCreateUserDialogController.startingActivityForResult();\n        super.startActivityForResult(intent, requestCode);\n    }\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        int pos = 0;\n        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest()) {\n            String nickname = mUserManager.getUserName();\n            MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                    getResources().getString(R.string.user_remove_user_menu, nickname));\n            removeThisUser.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n\n            final EnforcedAdmin disallowRemoveUserAdmin =\n                    RestrictedLockUtilsInternal.checkIfRestrictionEnforced(getContext(),\n                            UserManager.DISALLOW_REMOVE_USER, UserHandle.myUserId());\n            RestrictedLockUtilsInternal.setMenuItemAsDisabledByAdmin(getContext(), removeThisUser,\n                    disallowRemoveUserAdmin);\n        }\n        super.onCreateOptionsMenu(menu, inflater);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        final int itemId = item.getItemId();\n        if (itemId == MENU_REMOVE_USER) {\n            onRemoveUserClicked(UserHandle.myUserId());\n            return true;\n        } else {\n            return super.onOptionsItemSelected(item);\n        }\n    }\n\n    @Override\n    public void onMultiUserSwitchChanged(boolean newState) {\n        updateUI();\n    }\n\n    private void updateUI() {\n        mUserCaps.updateAddUserCapabilities(getActivity());\n        loadProfile();\n        updateUserList();\n    }\n\n    /**\n     * Loads profile information for the current user.\n     */\n    private void loadProfile() {\n        if (isCurrentUserGuest()) {\n            // No need to load profile information\n            mMePreference.setIcon(getEncircledDefaultIcon());\n            mMePreference.setTitle(mGuestUserAutoCreated\n                    ? com.android.settingslib.R.string.guest_reset_guest\n                    : com.android.settingslib.R.string.guest_exit_guest);\n            mMePreference.setSelectable(true);\n            // removing a guest will result in switching back to the admin user\n            mMePreference.setEnabled(canSwitchUserNow());\n            return;\n        }\n\n        new AsyncTask<Void, Void, String>() {\n            @Override\n            protected void onPostExecute(String result) {\n                finishLoadProfile(result);\n            }\n\n            @Override\n            protected String doInBackground(Void... values) {\n                UserInfo user = mUserManager.getUserInfo(UserHandle.myUserId());\n                if (user.iconPath == null || user.iconPath.equals(\"\")) {\n                    // Assign profile photo.\n                    copyMeProfilePhoto(getActivity(), user);\n                }\n                return user.name;\n            }\n        }.execute();\n    }\n\n    private void finishLoadProfile(String profileName) {\n        if (getActivity() == null) {\n            return;\n        }\n        mMePreference.setTitle(getString(R.string.user_you, profileName));\n        int myUserId = UserHandle.myUserId();\n        Bitmap b = mUserManager.getUserIcon(myUserId);\n        if (b != null) {\n            mMePreference.setIcon(encircleUserIcon(b));\n            mUserIcons.put(myUserId, b);\n        }\n    }\n\n    private boolean hasLockscreenSecurity() {\n        LockPatternUtils lpu = new LockPatternUtils(getActivity());\n        return lpu.isSecure(UserHandle.myUserId());\n    }\n\n    private void launchChooseLockscreen() {\n        Intent chooseLockIntent = new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD);\n        chooseLockIntent.putExtra(ChooseLockGeneric.ChooseLockGenericFragment.HIDE_INSECURE_OPTIONS,\n                true);\n        startActivityForResult(chooseLockIntent, REQUEST_CHOOSE_LOCK);\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n\n        if (requestCode == REQUEST_CHOOSE_LOCK) {\n            if (resultCode != Activity.RESULT_CANCELED && hasLockscreenSecurity()) {\n                addUserNow(USER_TYPE_RESTRICTED_PROFILE);\n            }\n        } else if (mGuestUserAutoCreated && requestCode == REQUEST_EDIT_GUEST\n                && resultCode == RESULT_GUEST_REMOVED) {\n            scheduleGuestCreation();\n        } else {\n            mCreateUserDialogController.onActivityResult(requestCode, resultCode, data);\n            mEditUserInfoController.onActivityResult(requestCode, resultCode, data);\n        }\n    }\n\n    private void onAddUserClicked(int userType) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                switch (userType) {\n                    case USER_TYPE_USER:\n                        showDialog(DIALOG_ADD_USER);\n                        break;\n                    case USER_TYPE_RESTRICTED_PROFILE:\n                        if (hasLockscreenSecurity()) {\n                            showDialog(DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE);\n                        } else {\n                            showDialog(DIALOG_NEED_LOCKSCREEN);\n                        }\n                        break;\n                }\n            }\n        }\n    }\n\n    private void onAddSupervisedUserClicked() {\n        final Intent intent = new Intent()\n                .setAction(UserManager.ACTION_CREATE_SUPERVISED_USER)\n                .setPackage(mConfigSupervisedUserCreationPackage)\n                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\n        startActivity(intent);\n    }\n\n    private void onAddGuestClicked() {\n        Context context = getContext();\n        final UserCreatingDialog guestCreatingDialog =\n                new UserCreatingDialog(getActivity(), /* isGuest= */ true);\n        guestCreatingDialog.show();\n\n        ThreadUtils.postOnBackgroundThread(() -> {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_GUEST_ADD);\n            Trace.beginSection(\"UserSettings.addGuest\");\n            final UserInfo guest = mUserManager.createGuest(context);\n            Trace.endSection();\n\n            ThreadUtils.postOnMainThread(() -> {\n                guestCreatingDialog.dismiss();\n                if (guest == null) {\n                    Toast.makeText(context,\n                            com.android.settingslib.R.string.add_guest_failed,\n                            Toast.LENGTH_SHORT).show();\n                    return;\n                }\n                openUserDetails(guest, true, context);\n            });\n        });\n    }\n\n    private void onRemoveUserClicked(int userId) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                mRemovingUserId = userId;\n                showDialog(DIALOG_CONFIRM_REMOVE);\n            }\n        }\n    }\n\n    private void onUserCreated(UserInfo userInfo, Context context) {\n        hideUserCreatingDialog();\n        mAddingUser = false;\n        openUserDetails(userInfo, true, context);\n    }\n\n    private void hideUserCreatingDialog() {\n        if (mUserCreatingDialog != null && mUserCreatingDialog.isShowing()) {\n            mUserCreatingDialog.dismiss();\n        }\n    }\n\n    private void onUserCreationFailed() {\n        Toast.makeText(getContext(),\n                com.android.settingslib.R.string.add_user_failed,\n                Toast.LENGTH_SHORT).show();\n        hideUserCreatingDialog();\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser) {\n        openUserDetails(userInfo, newUser, getContext());\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser, Context context) {\n        // to prevent a crash when config changes during user creation,\n        // we simply ignore this redirection step\n        if (context == null) {\n            return;\n        }\n\n        Bundle extras = new Bundle();\n        extras.putInt(UserDetailsSettings.EXTRA_USER_ID, userInfo.id);\n        extras.putBoolean(AppRestrictionsFragment.EXTRA_NEW_USER, newUser);\n\n        SubSettingLauncher launcher = new SubSettingLauncher(context)\n                .setDestination(UserDetailsSettings.class.getName())\n                .setArguments(extras)\n                .setTitleText(userInfo.name)\n                .setSourceMetricsCategory(getMetricsCategory());\n        if (mGuestUserAutoCreated && userInfo.isGuest()) {\n            launcher.setResultListener(this, REQUEST_EDIT_GUEST);\n        }\n        launcher.launch();\n    }\n\n    @Override\n    public void onDialogShowing() {\n        super.onDialogShowing();\n\n        setOnDismissListener(this);\n    }\n\n    @Override\n    public Dialog onCreateDialog(int dialogId) {\n        Context context = getActivity();\n        if (context == null) {\n            return null;\n        }\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE: {\n                Dialog dlg =\n                        UserDialogs.createRemoveDialog(getActivity(), mRemovingUserId,\n                                new DialogInterface.OnClickListener() {\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        removeUserNow();\n                                    }\n                                }\n                        );\n                return dlg;\n            }\n            case DIALOG_USER_CANNOT_MANAGE:\n                return new AlertDialog.Builder(context)\n                        .setMessage(R.string.user_cannot_manage_message)\n                        .setPositiveButton(android.R.string.ok, null)\n                        .create();\n            case DIALOG_ADD_USER: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_user_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_USER);\n            }\n            case DIALOG_CHOOSE_USER_TYPE: {\n                List<HashMap<String, String>> data = new ArrayList<HashMap<String, String>>();\n                HashMap<String, String> addUserItem = new HashMap<String, String>();\n                addUserItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_user_item_title));\n                addUserItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_user_item_summary));\n                HashMap<String, String> addProfileItem = new HashMap<String, String>();\n                addProfileItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_title));\n                addProfileItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_summary));\n                data.add(addUserItem);\n                data.add(addProfileItem);\n                AlertDialog.Builder builder = new AlertDialog.Builder(context);\n                SimpleAdapter adapter = new SimpleAdapter(builder.getContext(),\n                        data, R.layout.two_line_list_item,\n                        new String[]{KEY_TITLE, KEY_SUMMARY},\n                        new int[]{R.id.title, R.id.summary});\n                builder.setTitle(com.android.settingslib.R.string.user_add_user_type_title);\n                builder.setAdapter(adapter,\n                        new DialogInterface.OnClickListener() {\n                            @Override\n                            public void onClick(DialogInterface dialog, int which) {\n                                onAddUserClicked(which == 0\n                                        ? USER_TYPE_USER\n                                        : USER_TYPE_RESTRICTED_PROFILE);\n                            }\n                        });\n                return builder.create();\n            }\n            case DIALOG_NEED_LOCKSCREEN: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setMessage(com.android.settingslib.R.string.user_need_lock_message)\n                        .setPositiveButton(com.android.settingslib.R.string.user_set_lock_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        launchChooseLockscreen();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_REMOVE_GUEST: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.guest_remove_guest_dialog_title)\n                        .setMessage(R.string.user_exit_guest_confirm_message)\n                        .setPositiveButton(R.string.user_exit_guest_dialog_remove,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.guest_exit_dialog_title)\n                        .setMessage(com.android.settingslib.R.string.guest_exit_dialog_message)\n                        .setPositiveButton(\n                                com.android.settingslib.R.string.guest_exit_dialog_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(\n                            com.android.settingslib.R.string.guest_exit_dialog_title_non_ephemeral)\n                        .setMessage(\n                            com.android.settingslib\n                                .R.string.guest_exit_dialog_message_non_ephemeral)\n                        .setPositiveButton(\n                            com.android.settingslib.R.string.guest_exit_save_data_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        exitGuest();\n                                    }\n                                })\n                        .setNegativeButton(\n                            com.android.settingslib.R.string.guest_exit_clear_data_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_USER_PROFILE_EDITOR: {\n                return buildEditCurrentUserDialog();\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_user_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_USER);\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_profile_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_RESTRICTED_PROFILE);\n            }\n            case DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE: {\n                return UserDialogs.createResetGuestDialog(getActivity(),\n                        (dialog, which) -> clearAndExitGuest());\n            }\n            case DIALOG_CONFIRM_RESET_AND_RESTART_GUEST: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(\n                            com.android.settingslib.R.string.guest_reset_and_restart_dialog_title)\n                        .setMessage(\n                            com.android.settingslib.R.string.guest_reset_and_restart_dialog_message)\n                        .setPositiveButton(\n                            com.android.settingslib.R.string.guest_reset_guest_confirm_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        resetAndRestartGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            default:\n                return null;\n        }\n    }\n\n    private Dialog buildEditCurrentUserDialog() {\n        final Activity activity = getActivity();\n        if (activity == null) {\n            return null;\n        }\n\n        UserInfo user = mUserManager.getUserInfo(Process.myUserHandle().getIdentifier());\n        Drawable userIcon = Utils.getUserIcon(activity, mUserManager, user);\n\n        return mEditUserInfoController.createDialog(\n                activity,\n                this::startActivityForResult,\n                userIcon,\n                user.name,\n                getString(com.android.settingslib.R.string.profile_info_settings_title),\n                (newUserName, newUserIcon) -> {\n                    if (newUserIcon != userIcon) {\n                        ThreadUtils.postOnBackgroundThread(() ->\n                                mUserManager.setUserIcon(user.id,\n                                        UserIcons.convertToBitmapAtUserIconSize(\n                                                activity.getResources(), newUserIcon)));\n                        mMePreference.setIcon(newUserIcon);\n                    }\n\n                    if (!TextUtils.isEmpty(newUserName) && !newUserName.equals(user.name)) {\n                        mMePreference.setTitle(newUserName);\n                        mUserManager.setUserName(user.id, newUserName);\n                    }\n                }, null);\n    }\n\n    private Dialog buildAddUserDialog(int userType) {\n        Dialog d;\n        synchronized (mUserLock) {\n            d = mCreateUserDialogController.createDialog(\n                    getActivity(),\n                    this::startActivityForResult,\n                    UserManager.isMultipleAdminEnabled(),\n                    (userName, userIcon, isAdmin) -> {\n                        mPendingUserIcon = userIcon;\n                        mPendingUserName = userName;\n                        mPendingUserIsAdmin = isAdmin;\n                        addUserNow(userType);\n                    },\n                    () -> {\n                        synchronized (mUserLock) {\n                            mPendingUserIcon = null;\n                            mPendingUserName = null;\n                        }\n                    }\n            );\n        }\n        return d;\n    }\n\n    @Override\n    public int getDialogMetricsCategory(int dialogId) {\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE:\n                return SettingsEnums.DIALOG_USER_REMOVE;\n            case DIALOG_USER_CANNOT_MANAGE:\n                return SettingsEnums.DIALOG_USER_CANNOT_MANAGE;\n            case DIALOG_GRANT_ADMIN:\n                return SettingsEnums.DIALOG_GRANT_USER_ADMIN;\n            case DIALOG_ADD_USER:\n                return SettingsEnums.DIALOG_USER_ADD;\n            case DIALOG_CHOOSE_USER_TYPE:\n                return SettingsEnums.DIALOG_USER_CHOOSE_TYPE;\n            case DIALOG_NEED_LOCKSCREEN:\n                return SettingsEnums.DIALOG_USER_NEED_LOCKSCREEN;\n            case DIALOG_CONFIRM_REMOVE_GUEST:\n            case DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE:\n            case DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL:\n            case DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL:\n            case DIALOG_CONFIRM_RESET_AND_RESTART_GUEST:\n                return SettingsEnums.DIALOG_USER_CONFIRM_EXIT_GUEST;\n            case DIALOG_USER_PROFILE_EDITOR:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE:\n                return SettingsEnums.DIALOG_USER_EDIT_PROFILE;\n            default:\n                return 0;\n        }\n    }\n\n    private void removeUserNow() {\n        if (mRemovingUserId == UserHandle.myUserId()) {\n            removeThisUser();\n        } else {\n            ThreadUtils.postOnBackgroundThread(new Runnable() {\n                @Override\n                public void run() {\n                    synchronized (mUserLock) {\n                        mUserManager.removeUser(mRemovingUserId);\n                        mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n                    }\n                }\n            });\n        }\n    }\n\n    private void removeThisUser() {\n        if (!canSwitchUserNow()) {\n            Log.w(TAG, \"Cannot remove current user when switching is disabled\");\n            return;\n        }\n        try {\n            getContext().getSystemService(UserManager.class)\n                    .removeUserWhenPossible(UserHandle.of(UserHandle.myUserId()),\n                            /* overrideDevicePolicy= */ false);\n            ActivityManager.getService().switchUser(UserHandle.USER_SYSTEM);\n        } catch (RemoteException re) {\n            Log.e(TAG, \"Unable to remove self user\");\n        }\n    }\n\n    private void switchToUserId(int userId) {\n        if (!canSwitchUserNow()) {\n            Log.w(TAG, \"Cannot switch current user when switching is disabled\");\n            return;\n        }\n        try {\n            ActivityManager.getService().switchUser(userId);\n        } catch (RemoteException re) {\n            Log.e(TAG, \"Unable to switch user\");\n        }\n    }\n\n    private void addUserNow(final int userType) {\n        Trace.beginAsyncSection(\"UserSettings.addUserNow\", 0);\n        synchronized (mUserLock) {\n            mAddingUser = true;\n            mAddingUserName = userType == USER_TYPE_USER\n                    ? (mPendingUserName != null ? mPendingUserName.toString()\n                    : getString(R.string.user_new_user_name))\n                    : (mPendingUserName != null ? mPendingUserName.toString()\n                            : getString(R.string.user_new_profile_name));\n        }\n\n        mUserCreatingDialog = new UserCreatingDialog(getActivity());\n        mUserCreatingDialog.show();\n        createUser(userType, mAddingUserName);\n    }\n\n    @VisibleForTesting\n    void createUser(final int userType, String userName) {\n        Context context = getContext();\n        Resources resources = getResources();\n        final Drawable selectedUserIcon = mPendingUserIcon;\n        Future<?> unusedCreateUserFuture = ThreadUtils.postOnBackgroundThread(() -> {\n            UserInfo user;\n\n            if (userType == USER_TYPE_USER) {\n                user = mUserManager.createUser(\n                        userName,\n                        mUserManager.USER_TYPE_FULL_SECONDARY,\n                        0);\n                if (mPendingUserIsAdmin) {\n                    mUserManager.setUserAdmin(user.id);\n                }\n            } else {\n                user = mUserManager.createRestrictedProfile(userName);\n            }\n\n            ThreadUtils.postOnMainThread(() -> {\n                if (user == null) {\n                    mAddingUser = false;\n                    mPendingUserIcon = null;\n                    mPendingUserName = null;\n                    onUserCreationFailed();\n                    return;\n                }\n\n                Future<?> unusedSettingIconFuture = ThreadUtils.postOnBackgroundThread(() -> {\n                    Drawable newUserIcon = selectedUserIcon;\n                    if (newUserIcon == null) {\n                        newUserIcon = UserIcons.getDefaultUserIcon(resources, user.id, false);\n                    }\n                    mUserManager.setUserIcon(\n                            user.id, UserIcons.convertToBitmapAtUserIconSize(\n                                    resources, newUserIcon));\n                });\n\n                mPendingUserIcon = null;\n                mPendingUserName = null;\n\n                onUserCreated(user, context);\n            });\n        });\n    }\n\n\n    /**\n     * Erase the current user (guest) and switch to another user.\n     */\n    @VisibleForTesting\n    void clearAndExitGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mMetricsFeatureProvider.action(getActivity(),\n                SettingsEnums.ACTION_USER_GUEST_EXIT_CONFIRMED);\n\n        int guestUserId = UserHandle.myUserId();\n        // Using markGuestForDeletion allows us to create a new guest before this one is\n        // fully removed.\n        boolean marked = mUserManager.markGuestForDeletion(guestUserId);\n        if (!marked) {\n            Log.w(TAG, \"Couldn't mark the guest for deletion for user \" + guestUserId);\n            return;\n        }\n\n        removeThisUser();\n        if (mGuestUserAutoCreated) {\n            scheduleGuestCreation();\n        }\n    }\n\n    /**\n     * Switch to another user.\n     */\n    private void exitGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mMetricsFeatureProvider.action(getActivity(),\n                SettingsEnums.ACTION_USER_GUEST_EXIT_CONFIRMED);\n        switchToUserId(UserHandle.USER_SYSTEM);\n    }\n\n    private int createGuest() {\n        UserInfo guest;\n        Context context = getPrefContext();\n        try {\n            guest = mUserManager.createGuest(context);\n        } catch (UserManager.UserOperationException e) {\n            Log.e(TAG, \"Couldn't create guest user\", e);\n            return UserHandle.USER_NULL;\n        }\n        if (guest == null) {\n            Log.e(TAG, \"Couldn't create guest, most likely because there already exists one\");\n            return UserHandle.USER_NULL;\n        }\n        return guest.id;\n    }\n\n    /**\n     * Remove current guest and start a new guest session\n     */\n    private void resetAndRestartGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        int oldGuestUserId = UserHandle.myUserId();\n        // Using markGuestForDeletion allows us to create a new guest before this one is\n        // fully removed.\n        boolean marked = mUserManager.markGuestForDeletion(oldGuestUserId);\n        if (!marked) {\n            Log.w(TAG, \"Couldn't mark the guest for deletion for user \" + oldGuestUserId);\n            return;\n        }\n\n        try {\n            // Create a new guest in the foreground, and then immediately switch to it\n            int newGuestUserId = createGuest();\n            if (newGuestUserId == UserHandle.USER_NULL) {\n                Log.e(TAG, \"Could not create new guest, switching back to system user\");\n                switchToUserId(UserHandle.USER_SYSTEM);\n                mUserManager.removeUser(oldGuestUserId);\n                WindowManagerGlobal.getWindowManagerService().lockNow(/* options= */ null);\n                return;\n            }\n            switchToUserId(newGuestUserId);\n            mUserManager.removeUser(oldGuestUserId);\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Couldn't remove guest because ActivityManager or WindowManager is dead\");\n            return;\n        }\n    }\n\n    /**\n     * Create a guest user in the background\n     */\n    @VisibleForTesting\n    void scheduleGuestCreation() {\n        // TODO(b/191067027): Move guest recreation to system_server\n        if (mGuestCreationScheduled.compareAndSet(/* expect= */ false, /* update= */ true)) {\n            // Once mGuestCreationScheduled=true, mAddGuest needs to be updated so that it shows\n            // \"Resetting guest...\"\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            mExecutor.execute(() -> {\n                UserInfo guest = mUserManager.createGuest(getContext());\n                mGuestCreationScheduled.set(false);\n                if (guest == null) {\n                    Log.e(TAG, \"Unable to automatically recreate guest user\");\n                }\n                // The list needs to be updated whether or not guest creation worked. If guest\n                // creation failed, the list needs to update so that \"Add guest\" is displayed.\n                // Otherwise, the UX could be stuck in a state where there is no way to switch to\n                // the guest user (e.g. Guest would not be selectable, and it would be stuck\n                // saying \"Resetting guest...\")\n                mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            });\n        }\n    }\n\n    @VisibleForTesting\n    void updateUserList() {\n        final Context context = getActivity();\n        if (context == null) {\n            return;\n        }\n\n        List<UserInfo> users;\n        if (mUserCaps.mUserSwitcherEnabled) {\n            // Only users that can be switched to should show up here.\n            // e.g. Managed profiles appear under Accounts Settings instead\n            users = mUserManager.getAliveUsers().stream()\n                    .filter(UserInfo::supportsSwitchToByUser)\n                    .collect(Collectors.toList());\n        } else {\n            // Only current user will be displayed in case of multi-user switch is disabled\n            users = List.of(mUserManager.getUserInfo(context.getUserId()));\n        }\n\n        final ArrayList<Integer> missingIcons = new ArrayList<>();\n        final ArrayList<UserPreference> userPreferences = new ArrayList<>();\n\n        // mMePreference shows a icon for current user. However when current user is a guest, we\n        // don't show the guest user icon, instead we show two preferences for guest user to\n        // exit and reset itself. Hence we don't add mMePreference, i.e. guest user to the\n        // list of users visible in the UI.\n        if (!isCurrentUserGuest()) {\n            userPreferences.add(mMePreference);\n        }\n\n        boolean canOpenUserDetails =\n                isCurrentUserAdmin() || (canSwitchUserNow() && !mUserCaps.mDisallowSwitchUser);\n        for (UserInfo user : users) {\n            if (user.isGuest()) {\n                // Guest user is added to guest category via updateGuestCategory\n                // and not to user list so skip guest here\n                continue;\n            }\n            UserPreference pref;\n            if (user.id == UserHandle.myUserId()) {\n                pref = mMePreference;\n            } else {\n                pref = new UserPreference(getPrefContext(), null, user.id);\n                pref.setTitle(user.name);\n                userPreferences.add(pref);\n                pref.setOnPreferenceClickListener(this);\n                pref.setEnabled(canOpenUserDetails);\n                pref.setSelectable(true);\n                pref.setKey(\"id=\" + user.id);\n                if (user.isAdmin()) {\n                    pref.setSummary(R.string.user_admin);\n                }\n            }\n            if (pref == null) {\n                continue;\n            }\n            if (user.id != UserHandle.myUserId() && !user.isGuest() && !user.isInitialized()) {\n                // sometimes after creating a guest the initialized flag isn't immediately set\n                // and we don't want to show \"Not set up\" summary for them\n                if (user.isRestricted()) {\n                    pref.setSummary(R.string.user_summary_restricted_not_set_up);\n                } else {\n                    pref.setSummary(R.string.user_summary_not_set_up);\n                    // Disallow setting up user which results in user switching when the\n                    // restriction is set.\n                    pref.setEnabled(!mUserCaps.mDisallowSwitchUser && canSwitchUserNow());\n                }\n            } else if (user.isRestricted()) {\n                pref.setSummary(R.string.user_summary_restricted_profile);\n            }\n            if (user.iconPath != null) {\n                if (mUserIcons.get(user.id) == null) {\n                    // Icon not loaded yet, print a placeholder\n                    missingIcons.add(user.id);\n                    pref.setIcon(getEncircledDefaultIcon());\n                } else {\n                    setPhotoId(pref, user);\n                }\n            } else {\n                // Icon not available yet, print a placeholder\n                pref.setIcon(getEncircledDefaultIcon());\n            }\n        }\n\n        // Add a temporary entry for the user being created\n        if (mAddingUser) {\n            UserPreference pref = new UserPreference(getPrefContext(), null,\n                    UserPreference.USERID_UNKNOWN);\n            pref.setEnabled(false);\n            pref.setTitle(mAddingUserName);\n            pref.setIcon(getEncircledDefaultIcon());\n            userPreferences.add(pref);\n        }\n\n        // Sort list of users by serialNum\n        Collections.sort(userPreferences, UserPreference.SERIAL_NUMBER_COMPARATOR);\n\n        getActivity().invalidateOptionsMenu();\n\n        // Load the icons\n        if (missingIcons.size() > 0) {\n            loadIconsAsync(missingIcons);\n        }\n\n        // If restricted profiles are supported, mUserListCategory will have a special title\n        if (mUserCaps.mCanAddRestrictedProfile) {\n            mUserListCategory.setTitle(R.string.user_list_title);\n        } else if (isCurrentUserGuest()) {\n            mUserListCategory.setTitle(R.string.other_user_category_title);\n        } else {\n            mUserListCategory.setTitle(R.string.user_category_title);\n        }\n\n        // Remove everything from mUserListCategory and add new users.\n        mUserListCategory.removeAll();\n\n        final Preference addUserOnLockScreen = getPreferenceScreen().findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey());\n        mAddUserWhenLockedPreferenceController.updateState(addUserOnLockScreen);\n\n        final Preference guestCallPreference = getPreferenceScreen().findPreference(\n                mGuestTelephonyPreferenceController.getPreferenceKey());\n        mGuestTelephonyPreferenceController.updateState(guestCallPreference);\n\n        final Preference multiUserTopIntroPreference = getPreferenceScreen().findPreference(\n                mMultiUserTopIntroPreferenceController.getPreferenceKey());\n        mMultiUserTopIntroPreferenceController.updateState(multiUserTopIntroPreference);\n        updateGuestPreferences();\n        updateGuestCategory(context, users);\n        updateAddUser(context);\n        updateAddSupervisedUser(context);\n\n        for (UserPreference userPreference : userPreferences) {\n            userPreference.setOrder(Preference.DEFAULT_ORDER);\n            mUserListCategory.addPreference(userPreference);\n        }\n\n    }\n\n    @VisibleForTesting\n    void setConfigSupervisedUserCreationPackage() {\n        mConfigSupervisedUserCreationPackage = getPrefContext().getString(\n                com.android.internal.R.string.config_supervisedUserCreationPackage);\n    }\n\n    private boolean isCurrentUserGuest() {\n        return mUserCaps.mIsGuest;\n    }\n\n    private boolean isCurrentUserAdmin() {\n        return mUserCaps.mIsAdmin;\n    }\n\n    private boolean canSwitchUserNow() {\n        return mUserManager.getUserSwitchability() == UserManager.SWITCHABILITY_STATUS_OK;\n    }\n\n    private void updateGuestPreferences() {\n        // reset guest and exit guest preferences are shown only in guest mode.\n        // For all other users these are not visible.\n        mGuestCategory.setVisible(false);\n        mGuestResetPreference.setVisible(false);\n        mGuestExitPreference.setVisible(false);\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mGuestCategory.setVisible(true);\n        mGuestExitPreference.setVisible(true);\n        mGuestResetPreference.setVisible(true);\n\n        boolean isGuestFirstLogin = Settings.Secure.getIntForUser(\n                getContext().getContentResolver(),\n                SETTING_GUEST_HAS_LOGGED_IN,\n                0,\n                UserHandle.myUserId()) <= 1;\n        String guestExitSummary;\n        if (mUserCaps.mIsEphemeral) {\n            guestExitSummary = getContext().getString(\n                    R.string.guest_notification_ephemeral);\n        } else if (isGuestFirstLogin) {\n            guestExitSummary = getContext().getString(\n                    R.string.guest_notification_non_ephemeral);\n        } else {\n            guestExitSummary = getContext().getString(\n                    R.string.guest_notification_non_ephemeral_non_first_login);\n        }\n        mGuestExitPreference.setSummary(guestExitSummary);\n    }\n\n    private void updateGuestCategory(Context context, List<UserInfo> users) {\n        // show guest category title and related guest preferences\n        // - if guest is created, then show guest user preference\n        // - if guest is not created and its allowed to create guest,\n        //   then show \"add guest\" preference\n        // - if allowed, show \"reset guest on exit\" preference\n        // - if there is nothing to show, then make the guest category as not visible\n        // - guest category is not visible for guest user.\n        UserPreference pref = null;\n        boolean isGuestAlreadyCreated = false;\n        boolean canOpenUserDetails =\n                isCurrentUserAdmin() || (canSwitchUserNow() && !mUserCaps.mDisallowSwitchUser);\n\n        mGuestUserCategory.removeAll();\n        mGuestUserCategory.setVisible(false);\n        for (UserInfo user : users) {\n            if (!user.isGuest() || !user.isEnabled()) {\n                // Only look at enabled, guest users\n                continue;\n            }\n            final Context prefContext = getPrefContext();\n            pref = new UserPreference(prefContext, null, user.id);\n            pref.setTitle(user.name);\n            pref.setOnPreferenceClickListener(this);\n            pref.setEnabled(canOpenUserDetails);\n            pref.setSelectable(true);\n            Drawable icon = getContext().getDrawable(R.drawable.ic_account_circle_outline);\n            icon.setTint(\n                    getColorAttrDefaultColor(getContext(), android.R.attr.colorControlNormal));\n            pref.setIcon(encircleUserIcon(\n                    UserIcons.convertToBitmapAtUserIconSize(\n                            getContext().getResources(), icon)));\n            pref.setKey(KEY_USER_GUEST);\n            pref.setOrder(Preference.DEFAULT_ORDER);\n            if (mUserCaps.mDisallowSwitchUser) {\n                pref.setDisabledByAdmin(\n                        RestrictedLockUtilsInternal.getDeviceOwner(context));\n            } else {\n                pref.setDisabledByAdmin(null);\n            }\n            if (mUserCaps.mUserSwitcherEnabled) {\n                mGuestUserCategory.addPreference(pref);\n                // guest user preference is shown hence also make guest category visible\n                mGuestUserCategory.setVisible(true);\n            }\n            isGuestAlreadyCreated = true;\n        }\n        boolean isVisible = updateAddGuestPreference(context, isGuestAlreadyCreated);\n        if (isVisible) {\n            // \"add guest\" preference is shown hence also make guest category visible\n            mGuestUserCategory.setVisible(true);\n        }\n        final Preference removeGuestOnExit = getPreferenceScreen().findPreference(\n                mRemoveGuestOnExitPreferenceController.getPreferenceKey());\n        mRemoveGuestOnExitPreferenceController.updateState(removeGuestOnExit);\n        if (mRemoveGuestOnExitPreferenceController.isAvailable()) {\n            // \"reset guest on exit\" preference is shown hence also make guest category visible\n            mGuestUserCategory.setVisible(true);\n        }\n        if (isCurrentUserGuest()) {\n            // guest category is not visible for guest user.\n            mGuestUserCategory.setVisible(false);\n        }\n    }\n\n    private boolean updateAddGuestPreference(Context context, boolean isGuestAlreadyCreated) {\n        boolean isVisible = false;\n        if (!isGuestAlreadyCreated && mUserCaps.mCanAddGuest\n                && mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_GUEST)\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && mUserCaps.mUserSwitcherEnabled) {\n            Drawable icon = context.getDrawable(R.drawable.ic_account_circle);\n            mAddGuest.setIcon(centerAndTint(icon));\n            isVisible = true;\n            mAddGuest.setVisible(true);\n            mAddGuest.setSelectable(true);\n            if (mGuestUserAutoCreated && mGuestCreationScheduled.get()) {\n                mAddGuest.setTitle(com.android.internal.R.string.guest_name);\n                mAddGuest.setSummary(R.string.guest_resetting);\n                mAddGuest.setEnabled(false);\n            } else {\n                mAddGuest.setTitle(com.android.settingslib.R.string.guest_new_guest);\n                mAddGuest.setEnabled(canSwitchUserNow());\n            }\n        } else {\n            mAddGuest.setVisible(false);\n        }\n        return isVisible;\n    }\n\n    private void updateAddUser(Context context) {\n        updateAddUserCommon(context, mAddUser, mUserCaps.mCanAddRestrictedProfile);\n        Drawable icon = context.getDrawable(R.drawable.ic_account_circle_filled);\n        mAddUser.setIcon(centerAndTint(icon));\n    }\n\n    private void updateAddSupervisedUser(Context context) {\n        if (!TextUtils.isEmpty(mConfigSupervisedUserCreationPackage)) {\n            updateAddUserCommon(context, mAddSupervisedUser, false);\n            Drawable icon = context.getDrawable(R.drawable.ic_add_supervised_user);\n            mAddSupervisedUser.setIcon(centerAndTint(icon));\n        } else {\n            mAddSupervisedUser.setVisible(false);\n        }\n    }\n\n    private void updateAddUserCommon(Context context, RestrictedPreference addUser,\n            boolean canAddRestrictedProfile) {\n        if ((mUserCaps.mCanAddUser && !mUserCaps.mDisallowAddUserSetByAdmin)\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && mUserCaps.mUserSwitcherEnabled) {\n            addUser.setVisible(true);\n            addUser.setSelectable(true);\n            final boolean canAddMoreUsers =\n                    mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_SECONDARY)\n                            || (canAddRestrictedProfile\n                            && mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_RESTRICTED));\n            addUser.setEnabled(canAddMoreUsers && !mAddingUser && canSwitchUserNow());\n\n            if (!canAddMoreUsers) {\n                addUser.setSummary(getString(R.string.user_add_max_count));\n            } else {\n                addUser.setSummary(null);\n            }\n            if (addUser.isEnabled()) {\n                addUser.setDisabledByAdmin(\n                        mUserCaps.mDisallowAddUser ? mUserCaps.mEnforcedAdmin : null);\n            }\n        } else {\n            addUser.setVisible(false);\n        }\n    }\n\n    private Drawable centerAndTint(Drawable icon) {\n        icon.setTintBlendMode(BlendMode.SRC_IN);\n        icon.setTint(getColorAttrDefaultColor(getContext(), android.R.attr.textColorPrimary));\n\n        Drawable bg = getContext().getDrawable(R.drawable.user_avatar_bg).mutate();\n        LayerDrawable ld = new LayerDrawable(new Drawable[] {bg, icon});\n        int size = getContext().getResources().getDimensionPixelSize(\n                R.dimen.multiple_users_avatar_size);\n        int bgSize = getContext().getResources().getDimensionPixelSize(\n                R.dimen.multiple_users_user_icon_size);\n        ld.setLayerSize(1, size, size);\n        ld.setLayerSize(0, bgSize, bgSize);\n        ld.setLayerGravity(1, Gravity.CENTER);\n\n        return ld;\n    }\n\n    /**\n     * @return number of non-guest non-managed users\n     */\n    @VisibleForTesting\n    int getRealUsersCount() {\n        return (int) mUserManager.getUsers()\n                .stream()\n                .filter(user -> !user.isGuest() && !user.isProfile())\n                .count();\n    }\n\n    private void loadIconsAsync(List<Integer> missingIcons) {\n        new AsyncTask<List<Integer>, Void, Void>() {\n            @Override\n            protected void onPostExecute(Void result) {\n                updateUserList();\n            }\n\n            @Override\n            protected Void doInBackground(List<Integer>... values) {\n                for (int userId : values[0]) {\n                    Bitmap bitmap = mUserManager.getUserIcon(userId);\n                    if (bitmap == null) {\n                        bitmap = getDefaultUserIconAsBitmap(getContext().getResources(), userId);\n                    }\n                    mUserIcons.append(userId, bitmap);\n                }\n                return null;\n            }\n        }.execute(missingIcons);\n    }\n\n    private Drawable getEncircledDefaultIcon() {\n        if (mDefaultIconDrawable == null) {\n            mDefaultIconDrawable = encircleUserIcon(\n                    getDefaultUserIconAsBitmap(getContext().getResources(), UserHandle.USER_NULL));\n        }\n        return mDefaultIconDrawable;\n    }\n\n    private void setPhotoId(Preference pref, UserInfo user) {\n        Bitmap bitmap = mUserIcons.get(user.id);\n        if (bitmap != null) {\n            pref.setIcon(encircleUserIcon(bitmap));\n        }\n    }\n\n    @Override\n    public boolean onPreferenceClick(Preference pref) {\n        mMetricsFeatureProvider.logSettingsTileClick(pref.getKey(), getMetricsCategory());\n        if (isCurrentUserGuest()) {\n            if (mGuestResetPreference != null && pref == mGuestResetPreference) {\n                showDialog(DIALOG_CONFIRM_RESET_AND_RESTART_GUEST);\n                return true;\n            }\n            if (mGuestExitPreference != null && pref == mGuestExitPreference) {\n                if (mUserCaps.mIsEphemeral) {\n                    showDialog(DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL);\n                } else {\n                    showDialog(DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL);\n                }\n                return true;\n            }\n        }\n        if (pref == mMePreference) {\n            if (!isCurrentUserGuest()) {\n                showDialog(DIALOG_USER_PROFILE_EDITOR);\n                return true;\n            }\n        } else if (pref instanceof UserPreference) {\n            UserInfo userInfo = mUserManager.getUserInfo(((UserPreference) pref).getUserId());\n            openUserDetails(userInfo, false);\n            return true;\n        } else if (pref == mAddUser) {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_ADD);\n            // If we allow both types, show a picker, otherwise directly go to\n            // flow for full user.\n            if (mUserCaps.mCanAddRestrictedProfile) {\n                showDialog(DIALOG_CHOOSE_USER_TYPE);\n            } else {\n                onAddUserClicked(USER_TYPE_USER);\n            }\n            return true;\n        } else if (pref == mAddSupervisedUser) {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_SUPERVISED_ADD);\n            Trace.beginSection(\"UserSettings.addSupervisedUser\");\n            onAddSupervisedUserClicked();\n            Trace.endSection();\n            return true;\n        } else if (pref == mAddGuest) {\n            mAddGuest.setEnabled(false); // prevent multiple tap issue\n            onAddGuestClicked();\n            return true;\n        }\n        return false;\n    }\n\n    private Drawable encircleUserIcon(Bitmap icon) {\n        return new CircleFramedDrawable(\n                icon,\n                getActivity().getResources().getDimensionPixelSize(\n                        R.dimen.multiple_users_user_icon_size));\n    }\n\n    @Override\n    public void onDismiss(DialogInterface dialog) {\n        synchronized (mUserLock) {\n            mRemovingUserId = -1;\n            updateUserList();\n            if (mCreateUserDialogController.isActive()) {\n                mCreateUserDialogController.clear();\n            }\n        }\n    }\n\n    @Override\n    public int getHelpResource() {\n        return R.string.help_url_users;\n    }\n\n    /**\n     * Returns a default user icon (as a {@link Bitmap}) for the given user.\n     *\n     * Note that for guest users, you should pass in {@code UserHandle.USER_NULL}.\n     *\n     * @param resources resources object to fetch the user icon.\n     * @param userId    the user id or {@code UserHandle.USER_NULL} for a non-user specific icon\n     */\n    private static Bitmap getDefaultUserIconAsBitmap(Resources resources, int userId) {\n        Bitmap bitmap = null;\n        // Try finding the corresponding bitmap in the dark bitmap cache\n        bitmap = sDarkDefaultUserBitmapCache.get(userId);\n        if (bitmap == null) {\n            bitmap = UserIcons.convertToBitmapAtUserIconSize(resources,\n                    UserIcons.getDefaultUserIcon(resources, userId, false));\n            // Save it to cache\n            sDarkDefaultUserBitmapCache.put(userId, bitmap);\n        }\n        return bitmap;\n    }\n\n    /**\n     * Assign the default photo to user with {@paramref userId}\n     *\n     * @param context used to get the {@link UserManager}\n     * @param userId  used to get the icon bitmap\n     * @return true if assign photo successfully, false if failed\n     */\n    @VisibleForTesting\n    static boolean assignDefaultPhoto(Context context, int userId) {\n        if (context == null) {\n            return false;\n        }\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap bitmap = getDefaultUserIconAsBitmap(context.getResources(), userId);\n        um.setUserIcon(userId, bitmap);\n\n        return true;\n    }\n\n    @WorkerThread\n    static void copyMeProfilePhoto(Context context, UserInfo user) {\n        Uri contactUri = ContactsContract.Profile.CONTENT_URI;\n\n        int userId = user != null ? user.id : UserHandle.myUserId();\n\n        InputStream avatarDataStream = ContactsContract.Contacts.openContactPhotoInputStream(\n                context.getContentResolver(),\n                contactUri, true);\n        // If there's no profile photo, assign a default avatar\n        if (avatarDataStream == null) {\n            assignDefaultPhoto(context, userId);\n            return;\n        }\n\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap decodedIcon = BitmapFactory.decodeStream(avatarDataStream);\n        CircleFramedDrawable drawable = CircleFramedDrawable.getInstance(context, decodedIcon);\n        Bitmap icon = UserIcons.convertToBitmapAtUserIconSize(context.getResources(), drawable);\n\n        um.setUserIcon(userId, icon);\n        try {\n            avatarDataStream.close();\n        } catch (IOException ioe) {\n        }\n    }\n\n    public static final BaseSearchIndexProvider SEARCH_INDEX_DATA_PROVIDER =\n            new BaseSearchIndexProvider(R.xml.user_settings) {\n\n                @Override\n                protected boolean isPageSearchEnabled(Context context) {\n                    final UserCapabilities userCaps = UserCapabilities.create(context);\n                    return userCaps.mEnabled;\n                }\n\n                @Override\n                public List<SearchIndexableRaw> getRawDataToIndex(Context context,\n                        boolean enabled) {\n                    final List<SearchIndexableRaw> rawData = new ArrayList<>();\n\n                    SearchIndexableRaw allowMultipleUsersResult = new SearchIndexableRaw(context);\n\n                    allowMultipleUsersResult.key = KEY_ALLOW_MULTIPLE_USERS;\n                    allowMultipleUsersResult.title =\n                            context.getString(R.string.multiple_users_main_switch_title);\n                    allowMultipleUsersResult.keywords =\n                            context.getString(R.string.multiple_users_main_switch_keywords);\n                    allowMultipleUsersResult.screenTitle =\n                            context.getString(R.string.user_settings_title);\n                    allowMultipleUsersResult.className =\n                            MultiUserSwitchBarController.class.getName();\n\n                    rawData.add(allowMultipleUsersResult);\n                    return rawData;\n                }\n\n                @Override\n                public List<String> getNonIndexableKeysFromXml(Context context, int xmlResId,\n                        boolean suppressAllPage) {\n                    final List<String> niks = super.getNonIndexableKeysFromXml(context, xmlResId,\n                            suppressAllPage);\n                    AddUserWhenLockedPreferenceController controller =\n                            new AddUserWhenLockedPreferenceController(\n                                    context, KEY_ADD_USER_WHEN_LOCKED);\n                    controller.updateNonIndexableKeys(niks);\n                    new AutoSyncDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncPersonalDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncWorkDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    return niks;\n                }\n            };\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 13446,
                                        "general": {
                                            "word_based": 5142,
                                            "char_based": 18571
                                        },
                                        "gemini": 16666
                                    }
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-296915500",
            "aliases": [
                "A-296915500",
                "CVE-2024-49728"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-296915500",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "b5d66a17fa296117b44f23ae45ff7338cee6ae85"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From b5d66a17fa296117b44f23ae45ff7338cee6ae85 Mon Sep 17 00:00:00 2001\nFrom: Billy Huang <billyhuang@google.com>\nDate: Thu, 8 Aug 2024 14:57:07 -0700\nSubject: [PATCH] Reapply \"opp: validate that content uri belongs to current\n user\"\n\nCheck that the userInfo part of the content URI is\neither implicit or the same as the current userId.\n\nThis reverts commit db25b12501095bc3f371a7271e372834cde5cee5.\n\nBug: 296915500\nFlag: EXEMPT fix for vulnerability\nTest: atest GoogleBluetoothInstrumentationTests:BluetoothOppSendFileInfoTest\nIgnore-AOSP-First: fix for undisclosed vulnerability\nChange-Id: I76b25fcd446d5e0530308e21deafa68d0b768edc\n---\n .../opp/BluetoothOppSendFileInfo.java         |  22 +++-\n .../opp/BluetoothOppSendFileInfoTest.java     | 106 ++++++++++++++++++\n 2 files changed, 127 insertions(+), 1 deletion(-)\n\ndiff --git a/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java b/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\nindex 16056cde79..2d727f9fdf 100644\n--- a/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n+++ b/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n@@ -32,6 +32,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import android.bluetooth.BluetoothProfile;\n import android.bluetooth.BluetoothProtoEnums;\n import android.content.ContentResolver;\n@@ -41,6 +43,7 @@ import android.database.Cursor;\n import android.database.sqlite.SQLiteException;\n import android.net.Uri;\n import android.provider.OpenableColumns;\n+import android.text.TextUtils;\n import android.util.EventLog;\n import android.util.Log;\n \n@@ -53,12 +56,13 @@ import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n /**\n  * This class stores information about a single sending file It will only be used for outbound\n  * share.\n  */\n-// Next tag value for ContentProfileErrorReportUtils.report(): 15\n+// Next tag value for ContentProfileErrorReportUtils.report(): 16\n public class BluetoothOppSendFileInfo {\n     private static final String TAG = \"BluetoothOppSendFileInfo\";\n \n@@ -124,6 +128,16 @@ public class BluetoothOppSendFileInfo {\n                 return SEND_FILE_INFO_ERROR;\n             }\n \n+            if (isContentUriForOtherUser(uri)) {\n+                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n+                ContentProfileErrorReportUtils.report(\n+                        BluetoothProfile.OPP,\n+                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n+                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__LOG_ERROR,\n+                        15);\n+                return SEND_FILE_INFO_ERROR;\n+            }\n+\n             contentType = contentResolver.getType(uri);\n             Cursor metadataCursor;\n             try {\n@@ -353,6 +367,12 @@ public class BluetoothOppSendFileInfo {\n         return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n     }\n \n+    private static boolean isContentUriForOtherUser(Uri uri) {\n+        String uriUserId = uri.getUserInfo();\n+        return !TextUtils.isEmpty(uriUserId)\n+                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n+    }\n+\n     private static long getStreamSize(FileInputStream is) throws IOException {\n         long length = 0;\n         byte[] unused = new byte[4096];\ndiff --git a/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java b/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java\nindex 273f6fd8d5..aad8a31170 100644\n--- a/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java\n+++ b/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java\n@@ -16,6 +16,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import static com.google.common.truth.Truth.assertThat;\n \n import static org.mockito.ArgumentMatchers.any;\n@@ -119,6 +121,110 @@ public class BluetoothOppSendFileInfoTest {\n         assertThat(info).isEqualTo(BluetoothOppSendFileInfo.SEND_FILE_INFO_ERROR);\n     }\n \n+    @Test\n+    public void generateFileInfo_withContentUriForOtherUser_returnsSendFileInfoError()\n+            throws Exception {\n+        String type = \"image/jpeg\";\n+        Uri uri = buildContentUriWithEncodedAuthority((myUserId() + 1) + \"@media\");\n+\n+        long fileLength = 1000;\n+        String fileName = \"pic.jpg\";\n+\n+        FileInputStream fs = mock(FileInputStream.class);\n+        AssetFileDescriptor fd = mock(AssetFileDescriptor.class);\n+        doReturn(fileLength).when(fd).getLength();\n+        doReturn(fs).when(fd).createInputStream();\n+\n+        doReturn(fd).when(mCallProxy).contentResolverOpenAssetFileDescriptor(any(), eq(uri), any());\n+\n+        mCursor =\n+                new MatrixCursor(new String[] {OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE});\n+        mCursor.addRow(new Object[] {fileName, fileLength});\n+\n+        doReturn(mCursor)\n+                .when(mCallProxy)\n+                .contentResolverQuery(any(), eq(uri), any(), any(), any(), any());\n+\n+        BluetoothOppSendFileInfo info =\n+                BluetoothOppSendFileInfo.generateFileInfo(mContext, uri, type, true);\n+\n+        assertThat(info).isEqualTo(BluetoothOppSendFileInfo.SEND_FILE_INFO_ERROR);\n+    }\n+\n+    @Test\n+    public void generateFileInfo_withContentUriForImplicitUser_returnsInfoWithCorrectLength()\n+            throws Exception {\n+        String type = \"image/jpeg\";\n+        Uri uri = buildContentUriWithEncodedAuthority(\"media\");\n+\n+        long fileLength = 1000;\n+        String fileName = \"pic.jpg\";\n+\n+        FileInputStream fs = mock(FileInputStream.class);\n+        AssetFileDescriptor fd = mock(AssetFileDescriptor.class);\n+        doReturn(fileLength).when(fd).getLength();\n+        doReturn(fs).when(fd).createInputStream();\n+\n+        doReturn(fd).when(mCallProxy).contentResolverOpenAssetFileDescriptor(any(), eq(uri), any());\n+\n+        mCursor =\n+                new MatrixCursor(new String[] {OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE});\n+        mCursor.addRow(new Object[] {fileName, fileLength});\n+\n+        doReturn(mCursor)\n+                .when(mCallProxy)\n+                .contentResolverQuery(any(), eq(uri), any(), any(), any(), any());\n+\n+        BluetoothOppSendFileInfo info =\n+                BluetoothOppSendFileInfo.generateFileInfo(mContext, uri, type, true);\n+\n+        assertThat(info.mInputStream).isEqualTo(fs);\n+        assertThat(info.mFileName).isEqualTo(fileName);\n+        assertThat(info.mLength).isEqualTo(fileLength);\n+        assertThat(info.mStatus).isEqualTo(0);\n+    }\n+\n+    @Test\n+    public void generateFileInfo_withContentUriForSameUser_returnsInfoWithCorrectLength()\n+            throws Exception {\n+        String type = \"image/jpeg\";\n+        Uri uri = buildContentUriWithEncodedAuthority(myUserId() + \"@media\");\n+\n+        long fileLength = 1000;\n+        String fileName = \"pic.jpg\";\n+\n+        FileInputStream fs = mock(FileInputStream.class);\n+        AssetFileDescriptor fd = mock(AssetFileDescriptor.class);\n+        doReturn(fileLength).when(fd).getLength();\n+        doReturn(fs).when(fd).createInputStream();\n+\n+        doReturn(fd).when(mCallProxy).contentResolverOpenAssetFileDescriptor(any(), eq(uri), any());\n+\n+        mCursor =\n+                new MatrixCursor(new String[] {OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE});\n+        mCursor.addRow(new Object[] {fileName, fileLength});\n+\n+        doReturn(mCursor)\n+                .when(mCallProxy)\n+                .contentResolverQuery(any(), eq(uri), any(), any(), any(), any());\n+\n+        BluetoothOppSendFileInfo info =\n+                BluetoothOppSendFileInfo.generateFileInfo(mContext, uri, type, true);\n+\n+        assertThat(info.mInputStream).isEqualTo(fs);\n+        assertThat(info.mFileName).isEqualTo(fileName);\n+        assertThat(info.mLength).isEqualTo(fileLength);\n+        assertThat(info.mStatus).isEqualTo(0);\n+    }\n+\n+    private static Uri buildContentUriWithEncodedAuthority(String authority) {\n+        return new Uri.Builder()\n+                .scheme(\"content\")\n+                .encodedAuthority(authority)\n+                .path(\"external/images/media/1\")\n+                .build();\n+    }\n+\n     @Test\n     public void generateFileInfo_withoutPermissionForAccessingUri_returnsSendFileInfoError() {\n         String type = \"text/plain\";\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 1994,
                        "general": {
                            "word_based": 788,
                            "char_based": 2157
                        },
                        "gemini": 2525
                    },
                    "total_downstream_versions_tested": 2,
                    "successful_patches": 0,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "5bcfd347823f1d3893d843db2286f2013923fad8",
                            "repo_path": "android_repos/Bluetooth",
                            "result": "failure",
                            "downstream_patch_content": "commit 5bcfd347823f1d3893d843db2286f2013923fad8\nAuthor: Billy Huang <billyhuang@google.com>\nDate:   Wed Oct 2 14:45:37 2024 -0700\n\n    RESTRICT AUTOMERGE backport \"opp: validate that content uri belongs to current user\"\n    \n    Bug: 296915500\n    Flag: EXEMPT trivial fix with complete testing coverage\n    Test: atest GoogleBluetoothInstrumentationTests:BluetoothOppSendFileInfoTest\n    Ignore-AOSP-First: fix for undisclosed vulnerability\n    Merged-In: I76b25fcd446d5e0530308e21deafa68d0b768edc\n    Change-Id: Ibff36089bfde4b5bb28d797aeae1423b668943a2\n\ndiff --git a/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java b/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\nindex 46e3ba144e..10087c9f16 100644\n--- a/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n+++ b/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n@@ -32,6 +32,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import android.content.ContentResolver;\n import android.content.Context;\n import android.content.res.AssetFileDescriptor;\n@@ -39,6 +41,7 @@ import android.database.Cursor;\n import android.database.sqlite.SQLiteException;\n import android.net.Uri;\n import android.provider.OpenableColumns;\n+import android.text.TextUtils;\n import android.util.EventLog;\n import android.util.Log;\n \n@@ -48,6 +51,7 @@ import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n /**\n  * This class stores information about a single sending file It will only be\n@@ -116,6 +120,11 @@ public class BluetoothOppSendFileInfo {\n                 return SEND_FILE_INFO_ERROR;\n             }\n \n+            if (isContentUriForOtherUser(uri)) {\n+                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n+                return SEND_FILE_INFO_ERROR;\n+            }\n+\n             contentType = contentResolver.getType(uri);\n             Cursor metadataCursor;\n             try {\n@@ -247,6 +256,12 @@ public class BluetoothOppSendFileInfo {\n         return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n     }\n \n+    private static boolean isContentUriForOtherUser(Uri uri) {\n+        String uriUserId = uri.getUserInfo();\n+        return !TextUtils.isEmpty(uriUserId)\n+                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n+    }\n+\n     private static long getStreamSize(FileInputStream is) throws IOException {\n         long length = 0;\n         byte[] unused = new byte[4096];\ndiff --git a/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java b/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java\nnew file mode 100644\nindex 0000000000..9fb93ac968\n--- /dev/null\n+++ b/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java\n@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2024 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.android.bluetooth.opp;\n+\n+import static android.os.UserHandle.myUserId;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+\n+import android.content.ContentResolver;\n+import android.content.Context;\n+import android.content.IContentProvider;\n+import android.content.pm.ApplicationInfo;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.MatrixCursor;\n+import android.net.Uri;\n+import android.os.Build;\n+import android.provider.OpenableColumns;\n+import android.test.mock.MockContentProvider;\n+import android.test.mock.MockContext;\n+\n+import androidx.test.runner.AndroidJUnit4;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.io.FileInputStream;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class BluetoothOppSendFileInfoTest {\n+    public static final String PROVIDER_NAME_MEDIA = \"media\";\n+    TestContext mContext;\n+    TestContentResolver mContentResolver;\n+    MockContentProvider mContentProvider;\n+    MatrixCursor mCursor;\n+\n+    private static Uri buildContentUriWithEncodedAuthority(String authority) {\n+        return new Uri.Builder().scheme(\"content\")\n+                .encodedAuthority(authority)\n+                .path(\"external/images/media/1\")\n+                .build();\n+    }\n+\n+    @Before\n+    public void setUp() {\n+        mContext = new TestContext();\n+        mContentResolver = mContext.getContentResolver();\n+        mContentProvider = mContext.getContentProvider();\n+    }\n+\n+    @Test\n+    public void generateFileInfo_withContentUriForOtherUser_returnsSendFileInfoError()\n+            throws Exception {\n+        String type = \"image/jpeg\";\n+        Uri uri = buildContentUriWithEncodedAuthority((myUserId() + 1) + \"@\" + PROVIDER_NAME_MEDIA);\n+        doReturn(type).when(mContentProvider).getType(any());\n+        long fileLength = 1000;\n+        String fileName = \"pic.jpg\";\n+        FileInputStream fs = mock(FileInputStream.class);\n+        AssetFileDescriptor fd = mock(AssetFileDescriptor.class);\n+        doReturn(fileLength).when(fd).getLength();\n+        doReturn(fs).when(fd).createInputStream();\n+        doReturn(fd).when(mContentProvider).openAssetFile(eq(uri), any(), any());\n+        mCursor =\n+                new MatrixCursor(new String[]{OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE});\n+        mCursor.addRow(new Object[]{fileName, fileLength});\n+        doReturn(mCursor).when(mContentProvider).query(eq(uri), any(), any(), any(), any());\n+        BluetoothOppSendFileInfo info =\n+                BluetoothOppSendFileInfo.generateFileInfo(mContext, uri, type, true);\n+        assertThat(info).isEqualTo(BluetoothOppSendFileInfo.SEND_FILE_INFO_ERROR);\n+    }\n+\n+    @Test\n+    public void generateFileInfo_withContentUriForImplicitUser_returnsInfoWithCorrectLength()\n+            throws Exception {\n+        String type = \"image/jpeg\";\n+        Uri uri = buildContentUriWithEncodedAuthority(PROVIDER_NAME_MEDIA);\n+        doReturn(type).when(mContentProvider).getType(any());\n+        long fileLength = 1000;\n+        String fileName = \"pic.jpg\";\n+        FileInputStream fs = mock(FileInputStream.class);\n+        AssetFileDescriptor fd = mock(AssetFileDescriptor.class);\n+        doReturn(fileLength).when(fd).getLength();\n+        doReturn(fs).when(fd).createInputStream();\n+        doReturn(fd).when(mContentProvider).openAssetFile(eq(uri), any(), any());\n+        mCursor =\n+                new MatrixCursor(new String[]{OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE});\n+        mCursor.addRow(new Object[]{fileName, fileLength});\n+        doReturn(mCursor).when(mContentProvider).query(eq(uri), any(), any(), any(), any());\n+        BluetoothOppSendFileInfo info =\n+                BluetoothOppSendFileInfo.generateFileInfo(mContext, uri, type, true);\n+        assertThat(info.mInputStream).isEqualTo(fs);\n+        assertThat(info.mFileName).isEqualTo(fileName);\n+        assertThat(info.mLength).isEqualTo(fileLength);\n+        assertThat(info.mStatus).isEqualTo(0);\n+    }\n+\n+    @Test\n+    public void generateFileInfo_withContentUriForSameUser_returnsInfoWithCorrectLength()\n+            throws Exception {\n+        String type = \"image/jpeg\";\n+        Uri uri = buildContentUriWithEncodedAuthority(myUserId() + \"@\" + PROVIDER_NAME_MEDIA);\n+        doReturn(type).when(mContentProvider).getType(any());\n+        long fileLength = 1000;\n+        String fileName = \"pic.jpg\";\n+        FileInputStream fs = mock(FileInputStream.class);\n+        AssetFileDescriptor fd = mock(AssetFileDescriptor.class);\n+        doReturn(fileLength).when(fd).getLength();\n+        doReturn(fs).when(fd).createInputStream();\n+        doReturn(fd).when(mContentProvider).openAssetFile(eq(uri), any(), any());\n+        mCursor =\n+                new MatrixCursor(new String[]{OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE});\n+        mCursor.addRow(new Object[]{fileName, fileLength});\n+        doReturn(mCursor).when(mContentProvider).query(eq(uri), any(), any(), any(), any());\n+        BluetoothOppSendFileInfo info =\n+                BluetoothOppSendFileInfo.generateFileInfo(mContext, uri, type, true);\n+        assertThat(info.mInputStream).isEqualTo(fs);\n+        assertThat(info.mFileName).isEqualTo(fileName);\n+        assertThat(info.mLength).isEqualTo(fileLength);\n+        assertThat(info.mStatus).isEqualTo(0);\n+    }\n+\n+    public static final class TestContext extends MockContext {\n+        private final TestContentResolver mContentResolver;\n+        private final MockContentProvider mContentProvider;\n+\n+        public TestContext() {\n+            mContentProvider = spy(new MockContentProvider(this));\n+            mContentResolver = new TestContentResolver(this, mContentProvider);\n+        }\n+\n+        @Override\n+        public TestContentResolver getContentResolver() {\n+            return mContentResolver;\n+        }\n+\n+        public MockContentProvider getContentProvider() {\n+            return mContentProvider;\n+        }\n+\n+        @Override\n+        public String getOpPackageName() {\n+            return \"test.package\";\n+        }\n+\n+        @Override\n+        public ApplicationInfo getApplicationInfo() {\n+            ApplicationInfo applicationInfo = new ApplicationInfo();\n+            applicationInfo.targetSdkVersion = Build.VERSION.SDK_INT;\n+            return applicationInfo;\n+        }\n+    }\n+\n+    public static final class TestContentResolver extends ContentResolver {\n+        private final MockContentProvider mContentProvider;\n+\n+        public TestContentResolver(Context context, MockContentProvider contentProvider) {\n+            super(context, contentProvider);\n+            mContentProvider = contentProvider;\n+        }\n+\n+        @Override\n+        protected IContentProvider acquireProvider(Context c, String name) {\n+            return mContentProvider.getIContentProvider();\n+        }\n+\n+        @Override\n+        public boolean releaseProvider(IContentProvider icp) {\n+            return true;\n+        }\n+\n+        @Override\n+        protected IContentProvider acquireUnstableProvider(Context c, String name) {\n+            return mContentProvider.getIContentProvider();\n+        }\n+\n+        @Override\n+        public boolean releaseUnstableProvider(IContentProvider icp) {\n+            return true;\n+        }\n+\n+        @Override\n+        public void unstableProviderDied(IContentProvider icp) {\n+        }\n+    }\n+}\n",
                            "downstream_patch_tokens": {
                                "openai": 2521,
                                "general": {
                                    "word_based": 1042,
                                    "char_based": 2817
                                },
                                "gemini": 3159
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java",
                                    "total_hunks": 5,
                                    "failed_hunks": [
                                        1,
                                        3
                                    ],
                                    "inline_merge_conflicts": [],
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    },
                                    "rej_file_content": "```diff\n--- android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n+++ android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n@@ -32,6 +32,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import android.bluetooth.BluetoothProfile;\n import android.bluetooth.BluetoothProtoEnums;\n import android.content.ContentResolver;\n@@ -54,12 +57,13 @@ import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n /**\n  * This class stores information about a single sending file It will only be used for outbound\n  * share.\n  */\n-// Next tag value for ContentProfileErrorReportUtils.report(): 15\n+// Next tag value for ContentProfileErrorReportUtils.report(): 16\n public class BluetoothOppSendFileInfo {\n     private static final String TAG = \"BluetoothOppSendFileInfo\";\n```",
                                    "rej_file_tokens": {
                                        "openai": 201,
                                        "general": {
                                            "word_based": 109,
                                            "char_based": 230
                                        },
                                        "gemini": 260
                                    },
                                    "patch_apply_output": "patching file android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\nHunk #1 FAILED at 32.\nHunk #2 succeeded at 39 (offset -2 lines).\nHunk #3 FAILED at 54.\nHunk #4 succeeded at 117 (offset -8 lines).\nHunk #5 succeeded at 258 (offset -106 lines).\n2 out of 5 hunks FAILED -- saving rejects to file android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java.rej",
                                    "inline_merge_output": "patching file android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\nHunk #1 already applied at 35-36.\nHunk #2 already applied at 46.\nHunk #3 already applied at 59,65.\nHunk #5 merged at 386-391.",
                                    "upstream_file_tokens": {
                                        "openai": 3040,
                                        "general": {
                                            "word_based": 1215,
                                            "char_based": 4393
                                        },
                                        "gemini": 3744
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (c) 2008-2009, Motorola, Inc.\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * - Neither the name of the Motorola, Inc. nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.android.bluetooth.opp;\n\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.res.AssetFileDescriptor;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteException;\nimport android.net.Uri;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.util.EventLog;\nimport android.util.Log;\n\nimport com.android.bluetooth.R;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n\n/**\n * This class stores information about a single sending file It will only be\n * used for outbound share.\n */\npublic class BluetoothOppSendFileInfo {\n    private static final String TAG = \"BluetoothOppSendFileInfo\";\n\n    private static final boolean D = Constants.DEBUG;\n\n\n    /** Reusable SendFileInfo for error status. */\n    static final BluetoothOppSendFileInfo SEND_FILE_INFO_ERROR =\n            new BluetoothOppSendFileInfo(null, null, 0, null, BluetoothShare.STATUS_FILE_ERROR);\n\n    /** readable media file name */\n    public final String mFileName;\n\n    /** media file input stream */\n    public final FileInputStream mInputStream;\n\n    /** vCard string data */\n    public final String mData;\n\n    public final int mStatus;\n\n    public final String mMimetype;\n\n    public final long mLength;\n\n    /** for media file */\n    public BluetoothOppSendFileInfo(String fileName, String type, long length,\n            FileInputStream inputStream, int status) {\n        mFileName = fileName;\n        mMimetype = type;\n        mLength = length;\n        mInputStream = inputStream;\n        mStatus = status;\n        mData = null;\n    }\n\n    /** for vCard, or later for vCal, vNote. Not used currently */\n    public BluetoothOppSendFileInfo(String data, String type, long length, int status) {\n        mFileName = null;\n        mInputStream = null;\n        mData = data;\n        mMimetype = type;\n        mLength = length;\n        mStatus = status;\n    }\n\n    public static BluetoothOppSendFileInfo generateFileInfo(Context context, Uri uri, String type,\n            boolean fromExternal) {\n        ContentResolver contentResolver = context.getContentResolver();\n        String scheme = uri.getScheme();\n        String fileName = null;\n        String contentType;\n        long length = 0;\n        // Support all Uri with \"content\" scheme\n        // This will allow more 3rd party applications to share files via\n        // bluetooth\n        if (\"content\".equals(scheme)) {\n            if (fromExternal && BluetoothOppUtility.isForbiddenContent(uri)) {\n                EventLog.writeEvent(0x534e4554, \"179910660\", -1, uri.toString());\n                Log.e(TAG, \"Content from forbidden URI is not allowed.\");\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            if (isContentUriForOtherUser(uri)) {\n                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n                ContentProfileErrorReportUtils.report(\n                        BluetoothProfile.OPP,\n                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__LOG_ERROR,\n                        15);\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            contentType = contentResolver.getType(uri);\n            Cursor metadataCursor;\n            try {\n                metadataCursor = contentResolver.query(uri, new String[]{\n                        OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE\n                }, null, null, null);\n            } catch (SQLiteException e) {\n                // some content providers don't support the DISPLAY_NAME or SIZE columns\n                metadataCursor = null;\n            } catch (SecurityException e) {\n                Log.e(TAG, \"generateFileInfo: Permission error, could not access URI: \" + uri);\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            if (metadataCursor != null) {\n                try {\n                    if (metadataCursor.moveToFirst()) {\n                        int indexName = metadataCursor.getColumnIndex(OpenableColumns.DISPLAY_NAME);\n                        int indexSize = metadataCursor.getColumnIndex(OpenableColumns.SIZE);\n                        if (indexName != -1) {\n                            fileName = metadataCursor.getString(indexName);\n                        }\n                        if (indexSize != -1) {\n                            length = metadataCursor.getLong(indexSize);\n                        }\n                        if (D) {\n                            Log.d(TAG, \"fileName = \" + fileName + \" length = \" + length);\n                        }\n                    }\n                } finally {\n                    metadataCursor.close();\n                }\n            }\n            if (fileName == null) {\n                // use last segment of URI if DISPLAY_NAME query fails\n                fileName = uri.getLastPathSegment();\n                if (D) Log.d(TAG, \"fileName from URI :\" + fileName);\n            }\n        } else if (\"file\".equals(scheme)) {\n            if (uri.getPath() == null) {\n                Log.e(TAG, \"Invalid URI path: \" + uri);\n                return SEND_FILE_INFO_ERROR;\n            }\n            if (fromExternal && !BluetoothOppUtility.isInExternalStorageDir(uri)) {\n                EventLog.writeEvent(0x534e4554, \"35310991\", -1, uri.getPath());\n                Log.e(TAG, \"File based URI not in Environment.getExternalStorageDirectory() is not \"\n                        + \"allowed.\");\n                return SEND_FILE_INFO_ERROR;\n            }\n            fileName = uri.getLastPathSegment();\n            contentType = type;\n            File f = new File(uri.getPath());\n            length = f.length();\n        } else {\n            // currently don't accept other scheme\n            return SEND_FILE_INFO_ERROR;\n        }\n        FileInputStream is = null;\n        if (scheme.equals(\"content\")) {\n            try {\n                // We've found that content providers don't always have the\n                // right size in _OpenableColumns.SIZE\n                // As a second source of getting the correct file length,\n                // get a file descriptor and get the stat length\n                AssetFileDescriptor fd = contentResolver.openAssetFileDescriptor(uri, \"r\");\n                long statLength = fd.getLength();\n                if (length != statLength && statLength > 0) {\n                    Log.e(TAG, \"Content provider length is wrong (\" + Long.toString(length)\n                            + \"), using stat length (\" + Long.toString(statLength) + \")\");\n                    length = statLength;\n                }\n\n                try {\n                    // This creates an auto-closing input-stream, so\n                    // the file descriptor will be closed whenever the InputStream\n                    // is closed.\n                    is = fd.createInputStream();\n\n                    // If the database doesn't contain the file size, get the size\n                    // by reading through the entire stream\n                    if (length == 0) {\n                        length = getStreamSize(is);\n                        Log.w(TAG, \"File length not provided. Length from stream = \" + length);\n                        // Reset the stream\n                        fd = contentResolver.openAssetFileDescriptor(uri, \"r\");\n                        is = fd.createInputStream();\n                    }\n                } catch (IOException e) {\n                    try {\n                        fd.close();\n                    } catch (IOException e2) {\n                        // Ignore\n                    }\n                }\n            } catch (FileNotFoundException e) {\n                // Ignore\n            } catch (SecurityException e) {\n                return SEND_FILE_INFO_ERROR;\n            }\n        }\n\n        if (is == null) {\n            try {\n                is = (FileInputStream) contentResolver.openInputStream(uri);\n\n                // If the database doesn't contain the file size, get the size\n                // by reading through the entire stream\n                if (length == 0) {\n                    length = getStreamSize(is);\n                    // Reset the stream\n                    is = (FileInputStream) contentResolver.openInputStream(uri);\n                }\n            } catch (FileNotFoundException e) {\n                return SEND_FILE_INFO_ERROR;\n            } catch (IOException e) {\n                return SEND_FILE_INFO_ERROR;\n            }\n        }\n\n        if (length == 0) {\n            Log.e(TAG, \"Could not determine size of file\");\n            return SEND_FILE_INFO_ERROR;\n        } else if (length > 0xffffffffL) {\n            Log.e(TAG, \"File of size: \" + length + \" bytes can't be transferred\");\n            throw new IllegalArgumentException(context\n                .getString(R.string.bluetooth_opp_file_limit_exceeded));\n        }\n\n        return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n    }\n\n    private static boolean isContentUriForOtherUser(Uri uri) {\n        String uriUserId = uri.getUserInfo();\n        return !TextUtils.isEmpty(uriUserId)\n                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n    }\n\n    private static long getStreamSize(FileInputStream is) throws IOException {\n        long length = 0;\n        byte[] unused = new byte[4096];\n        int bytesRead = is.read(unused, 0, 4096);\n        while (bytesRead != -1) {\n            length += bytesRead;\n            bytesRead = is.read(unused, 0, 4096);\n        }\n        return length;\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 2132,
                                        "general": {
                                            "word_based": 1040,
                                            "char_based": 2818
                                        },
                                        "gemini": 2593
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "2c5add83a18d87ea4a46bc8ab7f675e32c8d6a56",
                            "repo_path": "android_repos/Bluetooth",
                            "result": "failure",
                            "downstream_patch_content": "commit 2c5add83a18d87ea4a46bc8ab7f675e32c8d6a56\nAuthor: Billy Huang <billyhuang@google.com>\nDate:   Wed Oct 2 14:27:47 2024 -0700\n\n    RESTRICT AUTOMERGE backport \"opp: validate that content uri belongs to current user\"\n    \n    Bug: 296915500\n    Flag: EXEMPT trivial fix with complete testing coverage\n    Test: atest GoogleBluetoothInstrumentationTests:BluetoothOppSendFileInfoTest\n    Ignore-AOSP-First: fix for undisclosed vulnerability\n    Merged-In: I76b25fcd446d5e0530308e21deafa68d0b768edc\n    Change-Id: I0b6423025c95c13eeea3cbf584212913b5fbf307\n\ndiff --git a/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java b/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\nindex 2adb8e5f44..7ce134341a 100644\n--- a/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n+++ b/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n@@ -32,6 +32,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import android.content.ContentResolver;\n import android.content.Context;\n import android.content.res.AssetFileDescriptor;\n@@ -39,6 +41,7 @@ import android.database.Cursor;\n import android.database.sqlite.SQLiteException;\n import android.net.Uri;\n import android.provider.OpenableColumns;\n+import android.text.TextUtils;\n import android.util.EventLog;\n import android.util.Log;\n \n@@ -49,6 +52,7 @@ import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n /**\n  * This class stores information about a single sending file It will only be\n@@ -117,6 +121,11 @@ public class BluetoothOppSendFileInfo {\n                 return SEND_FILE_INFO_ERROR;\n             }\n \n+            if (isContentUriForOtherUser(uri)) {\n+                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n+                return SEND_FILE_INFO_ERROR;\n+            }\n+\n             contentType = contentResolver.getType(uri);\n             Cursor metadataCursor;\n             try {\n@@ -253,6 +262,12 @@ public class BluetoothOppSendFileInfo {\n         return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n     }\n \n+    private static boolean isContentUriForOtherUser(Uri uri) {\n+        String uriUserId = uri.getUserInfo();\n+        return !TextUtils.isEmpty(uriUserId)\n+                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n+    }\n+\n     private static long getStreamSize(FileInputStream is) throws IOException {\n         long length = 0;\n         byte[] unused = new byte[4096];\ndiff --git a/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java b/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java\nindex 756836afaa..acb58272fb 100644\n--- a/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java\n+++ b/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java\n@@ -17,6 +17,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import static com.google.common.truth.Truth.assertThat;\n \n import static org.mockito.ArgumentMatchers.any;\n@@ -31,7 +33,6 @@ import android.content.res.AssetFileDescriptor;\n import android.database.MatrixCursor;\n import android.net.Uri;\n import android.provider.OpenableColumns;\n-import android.util.Log;\n \n import androidx.test.platform.app.InstrumentationRegistry;\n import androidx.test.runner.AndroidJUnit4;\n@@ -120,6 +121,110 @@ public class BluetoothOppSendFileInfoTest {\n         assertThat(info).isEqualTo(BluetoothOppSendFileInfo.SEND_FILE_INFO_ERROR);\n     }\n \n+    @Test\n+    public void generateFileInfo_withContentUriForOtherUser_returnsSendFileInfoError()\n+            throws Exception {\n+        String type = \"image/jpeg\";\n+        Uri uri = buildContentUriWithEncodedAuthority((myUserId() + 1) + \"@media\");\n+\n+        long fileLength = 1000;\n+        String fileName = \"pic.jpg\";\n+\n+        FileInputStream fs = mock(FileInputStream.class);\n+        AssetFileDescriptor fd = mock(AssetFileDescriptor.class);\n+        doReturn(fileLength).when(fd).getLength();\n+        doReturn(fs).when(fd).createInputStream();\n+\n+        doReturn(fd).when(mCallProxy).contentResolverOpenAssetFileDescriptor(any(), eq(uri), any());\n+\n+        mCursor =\n+                new MatrixCursor(new String[] {OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE});\n+        mCursor.addRow(new Object[] {fileName, fileLength});\n+\n+        doReturn(mCursor)\n+                .when(mCallProxy)\n+                .contentResolverQuery(any(), eq(uri), any(), any(), any(), any());\n+\n+        BluetoothOppSendFileInfo info =\n+                BluetoothOppSendFileInfo.generateFileInfo(mContext, uri, type, true);\n+\n+        assertThat(info).isEqualTo(BluetoothOppSendFileInfo.SEND_FILE_INFO_ERROR);\n+    }\n+\n+    @Test\n+    public void generateFileInfo_withContentUriForImplicitUser_returnsInfoWithCorrectLength()\n+            throws Exception {\n+        String type = \"image/jpeg\";\n+        Uri uri = buildContentUriWithEncodedAuthority(\"media\");\n+\n+        long fileLength = 1000;\n+        String fileName = \"pic.jpg\";\n+\n+        FileInputStream fs = mock(FileInputStream.class);\n+        AssetFileDescriptor fd = mock(AssetFileDescriptor.class);\n+        doReturn(fileLength).when(fd).getLength();\n+        doReturn(fs).when(fd).createInputStream();\n+\n+        doReturn(fd).when(mCallProxy).contentResolverOpenAssetFileDescriptor(any(), eq(uri), any());\n+\n+        mCursor =\n+                new MatrixCursor(new String[] {OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE});\n+        mCursor.addRow(new Object[] {fileName, fileLength});\n+\n+        doReturn(mCursor)\n+                .when(mCallProxy)\n+                .contentResolverQuery(any(), eq(uri), any(), any(), any(), any());\n+\n+        BluetoothOppSendFileInfo info =\n+                BluetoothOppSendFileInfo.generateFileInfo(mContext, uri, type, true);\n+\n+        assertThat(info.mInputStream).isEqualTo(fs);\n+        assertThat(info.mFileName).isEqualTo(fileName);\n+        assertThat(info.mLength).isEqualTo(fileLength);\n+        assertThat(info.mStatus).isEqualTo(0);\n+    }\n+\n+    @Test\n+    public void generateFileInfo_withContentUriForSameUser_returnsInfoWithCorrectLength()\n+            throws Exception {\n+        String type = \"image/jpeg\";\n+        Uri uri = buildContentUriWithEncodedAuthority(myUserId() + \"@media\");\n+\n+        long fileLength = 1000;\n+        String fileName = \"pic.jpg\";\n+\n+        FileInputStream fs = mock(FileInputStream.class);\n+        AssetFileDescriptor fd = mock(AssetFileDescriptor.class);\n+        doReturn(fileLength).when(fd).getLength();\n+        doReturn(fs).when(fd).createInputStream();\n+\n+        doReturn(fd).when(mCallProxy).contentResolverOpenAssetFileDescriptor(any(), eq(uri), any());\n+\n+        mCursor =\n+                new MatrixCursor(new String[] {OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE});\n+        mCursor.addRow(new Object[] {fileName, fileLength});\n+\n+        doReturn(mCursor)\n+                .when(mCallProxy)\n+                .contentResolverQuery(any(), eq(uri), any(), any(), any(), any());\n+\n+        BluetoothOppSendFileInfo info =\n+                BluetoothOppSendFileInfo.generateFileInfo(mContext, uri, type, true);\n+\n+        assertThat(info.mInputStream).isEqualTo(fs);\n+        assertThat(info.mFileName).isEqualTo(fileName);\n+        assertThat(info.mLength).isEqualTo(fileLength);\n+        assertThat(info.mStatus).isEqualTo(0);\n+    }\n+\n+    private static Uri buildContentUriWithEncodedAuthority(String authority) {\n+        return new Uri.Builder()\n+                .scheme(\"content\")\n+                .encodedAuthority(authority)\n+                .path(\"external/images/media/1\")\n+                .build();\n+    }\n+\n     @Test\n     public void generateFileInfo_withoutPermissionForAccessingUri_returnsSendFileInfoError() {\n         String type = \"text/plain\";\n",
                            "downstream_patch_tokens": {
                                "openai": 1852,
                                "general": {
                                    "word_based": 744,
                                    "char_based": 2011
                                },
                                "gemini": 2362
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java",
                                    "total_hunks": 5,
                                    "failed_hunks": [
                                        1,
                                        3
                                    ],
                                    "inline_merge_conflicts": [],
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    },
                                    "rej_file_content": "```diff\n--- android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n+++ android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n@@ -32,6 +32,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import android.bluetooth.BluetoothProfile;\n import android.bluetooth.BluetoothProtoEnums;\n import android.content.ContentResolver;\n@@ -54,12 +57,13 @@ import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n /**\n  * This class stores information about a single sending file It will only be used for outbound\n  * share.\n  */\n-// Next tag value for ContentProfileErrorReportUtils.report(): 15\n+// Next tag value for ContentProfileErrorReportUtils.report(): 16\n public class BluetoothOppSendFileInfo {\n     private static final String TAG = \"BluetoothOppSendFileInfo\";\n```",
                                    "rej_file_tokens": {
                                        "openai": 201,
                                        "general": {
                                            "word_based": 109,
                                            "char_based": 230
                                        },
                                        "gemini": 260
                                    },
                                    "patch_apply_output": "patching file android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\nHunk #1 FAILED at 32.\nHunk #2 succeeded at 39 (offset -2 lines).\nHunk #3 FAILED at 54.\nHunk #4 succeeded at 118 (offset -7 lines).\nHunk #5 succeeded at 264 (offset -100 lines).\n2 out of 5 hunks FAILED -- saving rejects to file android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java.rej",
                                    "inline_merge_output": "patching file android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\nHunk #1 already applied at 35-36.\nHunk #2 already applied at 46.\nHunk #3 already applied at 59,65.\nHunk #5 merged at 386-391.",
                                    "upstream_file_tokens": {
                                        "openai": 3040,
                                        "general": {
                                            "word_based": 1215,
                                            "char_based": 4393
                                        },
                                        "gemini": 3744
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (c) 2008-2009, Motorola, Inc.\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * - Neither the name of the Motorola, Inc. nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.android.bluetooth.opp;\n\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.res.AssetFileDescriptor;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteException;\nimport android.net.Uri;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.util.EventLog;\nimport android.util.Log;\n\nimport com.android.bluetooth.BluetoothMethodProxy;\nimport com.android.bluetooth.R;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n\n/**\n * This class stores information about a single sending file It will only be\n * used for outbound share.\n */\npublic class BluetoothOppSendFileInfo {\n    private static final String TAG = \"BluetoothOppSendFileInfo\";\n\n    private static final boolean D = Constants.DEBUG;\n\n\n    /** Reusable SendFileInfo for error status. */\n    static final BluetoothOppSendFileInfo SEND_FILE_INFO_ERROR =\n            new BluetoothOppSendFileInfo(null, null, 0, null, BluetoothShare.STATUS_FILE_ERROR);\n\n    /** readable media file name */\n    public final String mFileName;\n\n    /** media file input stream */\n    public final FileInputStream mInputStream;\n\n    /** vCard string data */\n    public final String mData;\n\n    public final int mStatus;\n\n    public final String mMimetype;\n\n    public final long mLength;\n\n    /** for media file */\n    public BluetoothOppSendFileInfo(String fileName, String type, long length,\n            FileInputStream inputStream, int status) {\n        mFileName = fileName;\n        mMimetype = type;\n        mLength = length;\n        mInputStream = inputStream;\n        mStatus = status;\n        mData = null;\n    }\n\n    /** for vCard, or later for vCal, vNote. Not used currently */\n    public BluetoothOppSendFileInfo(String data, String type, long length, int status) {\n        mFileName = null;\n        mInputStream = null;\n        mData = data;\n        mMimetype = type;\n        mLength = length;\n        mStatus = status;\n    }\n\n    public static BluetoothOppSendFileInfo generateFileInfo(Context context, Uri uri, String type,\n            boolean fromExternal) {\n        ContentResolver contentResolver = context.getContentResolver();\n        String scheme = uri.getScheme();\n        String fileName = null;\n        String contentType;\n        long length = 0;\n        // Support all Uri with \"content\" scheme\n        // This will allow more 3rd party applications to share files via\n        // bluetooth\n        if (\"content\".equals(scheme)) {\n            if (fromExternal && BluetoothOppUtility.isForbiddenContent(uri)) {\n                EventLog.writeEvent(0x534e4554, \"179910660\", -1, uri.toString());\n                Log.e(TAG, \"Content from forbidden URI is not allowed.\");\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            if (isContentUriForOtherUser(uri)) {\n                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n                ContentProfileErrorReportUtils.report(\n                        BluetoothProfile.OPP,\n                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__LOG_ERROR,\n                        15);\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            contentType = contentResolver.getType(uri);\n            Cursor metadataCursor;\n            try {\n                metadataCursor = BluetoothMethodProxy.getInstance().contentResolverQuery(\n                        contentResolver, uri, new String[]{\n                                OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE\n                        }, null, null, null);\n            } catch (SQLiteException e) {\n                // some content providers don't support the DISPLAY_NAME or SIZE columns\n                metadataCursor = null;\n            } catch (SecurityException e) {\n                Log.e(TAG, \"generateFileInfo: Permission error, could not access URI: \" + uri);\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            if (metadataCursor != null) {\n                try {\n                    if (metadataCursor.moveToFirst()) {\n                        int indexName = metadataCursor.getColumnIndex(OpenableColumns.DISPLAY_NAME);\n                        int indexSize = metadataCursor.getColumnIndex(OpenableColumns.SIZE);\n                        if (indexName != -1) {\n                            fileName = metadataCursor.getString(indexName);\n                        }\n                        if (indexSize != -1) {\n                            length = metadataCursor.getLong(indexSize);\n                        }\n                        if (D) {\n                            Log.d(TAG, \"fileName = \" + fileName + \" length = \" + length);\n                        }\n                    }\n                } finally {\n                    metadataCursor.close();\n                }\n            }\n            if (fileName == null) {\n                // use last segment of URI if DISPLAY_NAME query fails\n                fileName = uri.getLastPathSegment();\n                if (D) Log.d(TAG, \"fileName from URI :\" + fileName);\n            }\n        } else if (\"file\".equals(scheme)) {\n            if (uri.getPath() == null) {\n                Log.e(TAG, \"Invalid URI path: \" + uri);\n                return SEND_FILE_INFO_ERROR;\n            }\n            if (fromExternal && !BluetoothOppUtility.isInExternalStorageDir(uri)) {\n                EventLog.writeEvent(0x534e4554, \"35310991\", -1, uri.getPath());\n                Log.e(TAG, \"File based URI not in Environment.getExternalStorageDirectory() is not \"\n                        + \"allowed.\");\n                return SEND_FILE_INFO_ERROR;\n            }\n            fileName = uri.getLastPathSegment();\n            contentType = type;\n            File f = new File(uri.getPath());\n            length = f.length();\n        } else {\n            // currently don't accept other scheme\n            return SEND_FILE_INFO_ERROR;\n        }\n        FileInputStream is = null;\n        if (scheme.equals(\"content\")) {\n            try {\n                // We've found that content providers don't always have the\n                // right size in _OpenableColumns.SIZE\n                // As a second source of getting the correct file length,\n                // get a file descriptor and get the stat length\n                AssetFileDescriptor fd = BluetoothMethodProxy.getInstance()\n                        .contentResolverOpenAssetFileDescriptor(contentResolver, uri, \"r\");\n                long statLength = fd.getLength();\n                if (length != statLength && statLength > 0) {\n                    Log.e(TAG, \"Content provider length is wrong (\" + Long.toString(length)\n                            + \"), using stat length (\" + Long.toString(statLength) + \")\");\n                    length = statLength;\n                }\n\n                try {\n                    // This creates an auto-closing input-stream, so\n                    // the file descriptor will be closed whenever the InputStream\n                    // is closed.\n                    is = fd.createInputStream();\n\n                    // If the database doesn't contain the file size, get the size\n                    // by reading through the entire stream\n                    if (length == 0) {\n                        length = getStreamSize(is);\n                        Log.w(TAG, \"File length not provided. Length from stream = \" + length);\n                        // Reset the stream\n                        fd = BluetoothMethodProxy.getInstance()\n                                .contentResolverOpenAssetFileDescriptor(contentResolver, uri, \"r\");\n                        is = fd.createInputStream();\n                    }\n                } catch (IOException e) {\n                    try {\n                        fd.close();\n                    } catch (IOException e2) {\n                        // Ignore\n                    }\n                }\n            } catch (FileNotFoundException e) {\n                // Ignore\n            } catch (SecurityException e) {\n                return SEND_FILE_INFO_ERROR;\n            }\n        }\n\n        if (is == null) {\n            try {\n                is = (FileInputStream) BluetoothMethodProxy.getInstance()\n                        .contentResolverOpenInputStream(contentResolver, uri);\n\n                // If the database doesn't contain the file size, get the size\n                // by reading through the entire stream\n                if (length == 0) {\n                    length = getStreamSize(is);\n                    // Reset the stream\n                    is = (FileInputStream) BluetoothMethodProxy.getInstance()\n                            .contentResolverOpenInputStream(contentResolver, uri);\n                }\n            } catch (FileNotFoundException e) {\n                return SEND_FILE_INFO_ERROR;\n            } catch (IOException e) {\n                return SEND_FILE_INFO_ERROR;\n            }\n        }\n\n        if (length == 0) {\n            Log.e(TAG, \"Could not determine size of file\");\n            return SEND_FILE_INFO_ERROR;\n        } else if (length > 0xffffffffL) {\n            Log.e(TAG, \"File of size: \" + length + \" bytes can't be transferred\");\n            throw new IllegalArgumentException(context\n                .getString(R.string.bluetooth_opp_file_limit_exceeded));\n        }\n\n        return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n    }\n\n    private static boolean isContentUriForOtherUser(Uri uri) {\n        String uriUserId = uri.getUserInfo();\n        return !TextUtils.isEmpty(uriUserId)\n                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n    }\n\n    private static long getStreamSize(FileInputStream is) throws IOException {\n        long length = 0;\n        byte[] unused = new byte[4096];\n        int bytesRead = is.read(unused, 0, 4096);\n        while (bytesRead != -1) {\n            length += bytesRead;\n            bytesRead = is.read(unused, 0, 4096);\n        }\n        return length;\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 2191,
                                        "general": {
                                            "word_based": 1055,
                                            "char_based": 2933
                                        },
                                        "gemini": 2659
                                    }
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-370958259",
            "aliases": [
                "A-370958259",
                "CVE-2025-0080"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-370958259",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "b1612955cb7fb2f69f1e04d437bb7fabd411ff7c"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From b1612955cb7fb2f69f1e04d437bb7fabd411ff7c Mon Sep 17 00:00:00 2001\nFrom: Sumedh Sen <sumedhsen@google.com>\nDate: Thu, 12 Dec 2024 14:29:31 -0800\nSubject: [PATCH] Prevent showing overlays when unarchiving\n\nWhen unarchiving an app:\n- Hide non-system overlays\n- Disable the restore button when another window is being shown on top\n  of Pia\n\nBug: 370958259\nTest: atest CtsPackageUninstallTestCases:ArchiveTest\nFlag: EXEMPT.Bug fix only\nChange-Id: If750c0a613136f3ad3040c544bd70ab428fe5ef2\n---\n .../packageinstaller/UnarchiveActivity.java   |  3 ++\n .../packageinstaller/UnarchiveFragment.java   | 31 ++++++++++++++++++-\n 2 files changed, 33 insertions(+), 1 deletion(-)\n\ndiff --git a/packages/PackageInstaller/src/com/android/packageinstaller/UnarchiveActivity.java b/packages/PackageInstaller/src/com/android/packageinstaller/UnarchiveActivity.java\nindex b20117d78230..c99d37bb6ce6 100644\n--- a/packages/PackageInstaller/src/com/android/packageinstaller/UnarchiveActivity.java\n+++ b/packages/PackageInstaller/src/com/android/packageinstaller/UnarchiveActivity.java\n@@ -19,6 +19,7 @@ package com.android.packageinstaller;\n import static android.Manifest.permission;\n import static android.content.pm.PackageManager.GET_PERMISSIONS;\n import static android.content.pm.PackageManager.MATCH_ARCHIVED_PACKAGES;\n+import static android.view.WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS;\n \n import android.app.Activity;\n import android.app.DialogFragment;\n@@ -53,6 +54,8 @@ public class UnarchiveActivity extends Activity {\n \n     @Override\n     public void onCreate(Bundle icicle) {\n+        getWindow().addSystemFlags(SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n+\n         super.onCreate(null);\n \n         int callingUid = getLaunchedFromUid();\ndiff --git a/packages/PackageInstaller/src/com/android/packageinstaller/UnarchiveFragment.java b/packages/PackageInstaller/src/com/android/packageinstaller/UnarchiveFragment.java\nindex 42dd382b98bc..fbb0fa4d6a57 100644\n--- a/packages/PackageInstaller/src/com/android/packageinstaller/UnarchiveFragment.java\n+++ b/packages/PackageInstaller/src/com/android/packageinstaller/UnarchiveFragment.java\n@@ -21,10 +21,14 @@ import android.app.Dialog;\n import android.app.DialogFragment;\n import android.content.DialogInterface;\n import android.os.Bundle;\n+import android.widget.Button;\n \n public class UnarchiveFragment extends DialogFragment implements\n         DialogInterface.OnClickListener {\n \n+    private Dialog mDialog;\n+    private Button mRestoreButton;\n+\n     @Override\n     public Dialog onCreateDialog(Bundle savedInstanceState) {\n         String appTitle = getArguments().getString(UnarchiveActivity.APP_TITLE);\n@@ -40,7 +44,32 @@ public class UnarchiveFragment extends DialogFragment implements\n         dialogBuilder.setPositiveButton(R.string.restore, this);\n         dialogBuilder.setNegativeButton(android.R.string.cancel, this);\n \n-        return dialogBuilder.create();\n+        mDialog = dialogBuilder.create();\n+        return mDialog;\n+    }\n+\n+    @Override\n+    public void onStart() {\n+        super.onStart();\n+        if (mDialog != null) {\n+            mRestoreButton = ((AlertDialog) mDialog).getButton(DialogInterface.BUTTON_POSITIVE);\n+        }\n+    }\n+\n+    @Override\n+    public void onPause() {\n+        super.onPause();\n+        if (mRestoreButton != null) {\n+            mRestoreButton.setEnabled(false);\n+        }\n+    }\n+\n+    @Override\n+    public void onResume() {\n+        super.onResume();\n+        if (mRestoreButton != null) {\n+            mRestoreButton.setEnabled(true);\n+        }\n     }\n \n     @Override\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 864,
                        "general": {
                            "word_based": 359,
                            "char_based": 910
                        },
                        "gemini": 1127
                    },
                    "total_downstream_versions_tested": 0,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": []
                }
            ]
        },
        {
            "id": "ASB-A-341688848",
            "aliases": [
                "A-341688848",
                "CVE-2024-49722"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-341688848",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "e480e1892cafaff977e2ede68e5988eb732d098e"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From e480e1892cafaff977e2ede68e5988eb732d098e Mon Sep 17 00:00:00 2001\nFrom: Anna Bauza <annabauza@google.com>\nDate: Tue, 3 Sep 2024 12:08:43 +0000\nSubject: [PATCH] Fix vulnerability by explicitly set the class name of avatar\n picker.\n\nChange-Id: I0203403d7724076c7d6266a7b5930fa26a3e54b7\nFlag: android.multiuser.fix_avatar_cross_user_leak\nTest: manual\nBug: 341688848\n---\n packages/SettingsLib/res/values/config.xml             | 10 ++++++++++\n .../settingslib/users/EditUserPhotoController.java     |  8 ++++++++\n 2 files changed, 18 insertions(+)\n\ndiff --git a/packages/SettingsLib/res/values/config.xml b/packages/SettingsLib/res/values/config.xml\nindex 68b81db1d9c0..3c3de044cc4e 100644\n--- a/packages/SettingsLib/res/values/config.xml\n+++ b/packages/SettingsLib/res/values/config.xml\n@@ -31,4 +31,14 @@\n     <!-- Control whether status bar should distinguish HSPA data icon form UMTS\n     data icon on devices -->\n     <bool name=\"config_hspa_data_distinguishable\">false</bool>\n+\n+    <!-- Edit User avatar explicit package name -->\n+    <string name=\"config_avatar_picker_package\" translatable=\"false\">\n+        com.android.avatarpicker\n+    </string>\n+\n+    <!-- Edit User avatar explicit activity class -->\n+    <string name=\"config_avatar_picker_class\" translatable=\"false\">\n+        com.android.avatarpicker.ui.AvatarPickerActivity\n+    </string>\n </resources>\n\\ No newline at end of file\ndiff --git a/packages/SettingsLib/src/com/android/settingslib/users/EditUserPhotoController.java b/packages/SettingsLib/src/com/android/settingslib/users/EditUserPhotoController.java\nindex cdc3f123eff7..f38e91ac0d8a 100644\n--- a/packages/SettingsLib/src/com/android/settingslib/users/EditUserPhotoController.java\n+++ b/packages/SettingsLib/src/com/android/settingslib/users/EditUserPhotoController.java\n@@ -32,6 +32,7 @@ import androidx.annotation.Nullable;\n \n import com.android.internal.util.UserIcons;\n import com.android.settingslib.drawable.CircleFramedDrawable;\n+import com.android.settingslib.R;\n import com.android.settingslib.utils.ThreadUtils;\n \n import com.google.common.util.concurrent.FutureCallback;\n@@ -132,6 +133,13 @@ public class EditUserPhotoController {\n         intent.addCategory(Intent.CATEGORY_DEFAULT);\n         if (Flags.avatarSync()) {\n             intent.putExtra(EXTRA_IS_USER_NEW, isUserNew);\n+            // Fix vulnerability b/341688848 by explicitly set the class name of avatar picker.\n+            if (Flags.fixAvatarCrossUserLeak()) {\n+                final String packageName =\n+                        mActivity.getString(R.string.config_avatar_picker_package);\n+                final String className = mActivity.getString(R.string.config_avatar_picker_class);\n+                intent.setClassName(packageName, className);\n+            }\n         } else {\n             // SettingsLib is used by multiple apps therefore we need to know out of all apps\n             // using settingsLib which one is the one we return value to.\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 732,
                        "general": {
                            "word_based": 333,
                            "char_based": 748
                        },
                        "gemini": 975
                    },
                    "total_downstream_versions_tested": 0,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": []
                }
            ]
        },
        {
            "id": "ASB-A-369103643",
            "aliases": [
                "A-369103643",
                "CVE-2024-49737"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-369103643",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "20c568e77eae5d469cd5e594b644d8645d830dbd"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 20c568e77eae5d469cd5e594b644d8645d830dbd Mon Sep 17 00:00:00 2001\nFrom: Chris Li <lihongyu@google.com>\nDate: Wed, 9 Oct 2024 01:50:57 +0000\nSubject: [PATCH] Pass SafeActivityOptions with actual caller for\n startActivityInTF\n\nWe clearCallingUid before apply the WCT, but SafeActivityOptions will\nquery the Binder Uid when construct. Update to pass in the actual\ncaller.\n\nFlag: EXEMPT bug fix\nBug: 369103643\nTest: atest WmTests:WindowOrganizerTests#\n      testStartActivityInTaskFragment_checkCallerPermission\nChange-Id: I873ae576de0bc4a7402c2f522b45853bce48a0c5\n---\n .../java/com/android/server/wm/ActivityStartController.java  | 5 ++---\n .../com/android/server/wm/WindowOrganizerController.java     | 4 +++-\n 2 files changed, 5 insertions(+), 4 deletions(-)\n\ndiff --git a/services/core/java/com/android/server/wm/ActivityStartController.java b/services/core/java/com/android/server/wm/ActivityStartController.java\nindex 35ec5adf54b0..0580d4a5a4a3 100644\n--- a/services/core/java/com/android/server/wm/ActivityStartController.java\n+++ b/services/core/java/com/android/server/wm/ActivityStartController.java\n@@ -43,7 +43,6 @@ import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageManager;\n import android.content.pm.ResolveInfo;\n import android.os.Binder;\n-import android.os.Bundle;\n import android.os.IBinder;\n import android.os.Trace;\n import android.os.UserHandle;\n@@ -550,14 +549,14 @@ public class ActivityStartController {\n      * Starts an activity in the TaskFragment.\n      * @param taskFragment TaskFragment {@link TaskFragment} to start the activity in.\n      * @param activityIntent intent to start the activity.\n-     * @param activityOptions ActivityOptions to start the activity with.\n+     * @param activityOptions SafeActivityOptions to start the activity with.\n      * @param resultTo the caller activity\n      * @param callingUid the caller uid\n      * @param callingPid the caller pid\n      * @return the start result.\n      */\n     int startActivityInTaskFragment(@NonNull TaskFragment taskFragment,\n-            @NonNull Intent activityIntent, @Nullable Bundle activityOptions,\n+            @NonNull Intent activityIntent, @Nullable SafeActivityOptions activityOptions,\n             @Nullable IBinder resultTo, int callingUid, int callingPid,\n             @Nullable IBinder errorCallbackToken) {\n         final ActivityRecord caller =\ndiff --git a/services/core/java/com/android/server/wm/WindowOrganizerController.java b/services/core/java/com/android/server/wm/WindowOrganizerController.java\nindex f8d0bc252b0f..fe2a8850905c 100644\n--- a/services/core/java/com/android/server/wm/WindowOrganizerController.java\n+++ b/services/core/java/com/android/server/wm/WindowOrganizerController.java\n@@ -1517,8 +1517,10 @@ class WindowOrganizerController extends IWindowOrganizerController.Stub\n                 final IBinder callerActivityToken = operation.getActivityToken();\n                 final Intent activityIntent = operation.getActivityIntent();\n                 final Bundle activityOptions = operation.getBundle();\n+                final SafeActivityOptions safeOptions =\n+                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n                 final int result = waitAsyncStart(() -> mService.getActivityStartController()\n-                        .startActivityInTaskFragment(taskFragment, activityIntent, activityOptions,\n+                        .startActivityInTaskFragment(taskFragment, activityIntent, safeOptions,\n                                 callerActivityToken, caller.mUid, caller.mPid,\n                                 errorCallbackToken));\n                 if (!isStartResultSuccessful(result)) {\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 861,
                        "general": {
                            "word_based": 380,
                            "char_based": 933
                        },
                        "gemini": 1066
                    },
                    "total_downstream_versions_tested": 2,
                    "successful_patches": 0,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "ef9ea0faa26e0ce0ee5e8dc70a663f98e04b0ca0",
                            "repo_path": "android_repos/base",
                            "result": "failure",
                            "downstream_patch_content": "commit ef9ea0faa26e0ce0ee5e8dc70a663f98e04b0ca0\nAuthor: Chris Li <lihongyu@google.com>\nDate:   Wed Oct 9 01:50:57 2024 +0000\n\n    Pass SafeActivityOptions with actual caller for startActivityInTF\n    \n    We clearCallingUid before apply the WCT, but SafeActivityOptions will\n    query the Binder Uid when construct. Update to pass in the actual\n    caller.\n    \n    Flag: EXEMPT bug fix\n    Bug: 369103643\n    Test: atest WmTests:WindowOrganizerTests#\n          testStartActivityInTaskFragment_checkCallerPermission\n    Merged-In: I873ae576de0bc4a7402c2f522b45853bce48a0c5\n    Change-Id: I873ae576de0bc4a7402c2f522b45853bce48a0c5\n    (cherry picked from commit 20c568e77eae5d469cd5e594b644d8645d830dbd)\n\ndiff --git a/services/core/java/com/android/server/wm/ActivityStartController.java b/services/core/java/com/android/server/wm/ActivityStartController.java\nindex 32ed4725b3b4..d51b90ef1ec0 100644\n--- a/services/core/java/com/android/server/wm/ActivityStartController.java\n+++ b/services/core/java/com/android/server/wm/ActivityStartController.java\n@@ -39,7 +39,6 @@ import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageManager;\n import android.content.pm.ResolveInfo;\n import android.os.Binder;\n-import android.os.Bundle;\n import android.os.IBinder;\n import android.os.UserHandle;\n import android.provider.Settings;\n@@ -500,14 +499,14 @@ public class ActivityStartController {\n      * Starts an activity in the TaskFragment.\n      * @param taskFragment TaskFragment {@link TaskFragment} to start the activity in.\n      * @param activityIntent intent to start the activity.\n-     * @param activityOptions ActivityOptions to start the activity with.\n+     * @param activityOptions SafeActivityOptions to start the activity with.\n      * @param resultTo the caller activity\n      * @param callingUid the caller uid\n      * @param callingPid the caller pid\n      * @return the start result.\n      */\n     int startActivityInTaskFragment(@NonNull TaskFragment taskFragment,\n-            @NonNull Intent activityIntent, @Nullable Bundle activityOptions,\n+            @NonNull Intent activityIntent, @Nullable SafeActivityOptions activityOptions,\n             @Nullable IBinder resultTo, int callingUid, int callingPid,\n             @Nullable IBinder errorCallbackToken) {\n         final ActivityRecord caller =\ndiff --git a/services/core/java/com/android/server/wm/WindowOrganizerController.java b/services/core/java/com/android/server/wm/WindowOrganizerController.java\nindex 4f4d5967365c..65dce1352ba4 100644\n--- a/services/core/java/com/android/server/wm/WindowOrganizerController.java\n+++ b/services/core/java/com/android/server/wm/WindowOrganizerController.java\n@@ -722,8 +722,10 @@ class WindowOrganizerController extends IWindowOrganizerController.Stub\n                 }\n                 final Intent activityIntent = hop.getActivityIntent();\n                 final Bundle activityOptions = hop.getLaunchOptions();\n+                final SafeActivityOptions safeOptions =\n+                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n                 final int result = mService.getActivityStartController()\n-                        .startActivityInTaskFragment(tf, activityIntent, activityOptions,\n+                        .startActivityInTaskFragment(tf, activityIntent, safeOptions,\n                                 hop.getCallingActivity(), caller.mUid, caller.mPid,\n                                 errorCallbackToken);\n                 if (!isStartResultSuccessful(result)) {\n",
                            "downstream_patch_tokens": {
                                "openai": 830,
                                "general": {
                                    "word_based": 346,
                                    "char_based": 887
                                },
                                "gemini": 1038
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "services/core/java/com/android/server/wm/WindowOrganizerController.java",
                                    "total_hunks": 1,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [],
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    },
                                    "rej_file_content": "```diff\n--- services/core/java/com/android/server/wm/WindowOrganizerController.java\n+++ services/core/java/com/android/server/wm/WindowOrganizerController.java\n@@ -1517,8 +1517,10 @@ class WindowOrganizerController extends IWindowOrganizerController.Stub\n                 final IBinder callerActivityToken = operation.getActivityToken();\n                 final Intent activityIntent = operation.getActivityIntent();\n                 final Bundle activityOptions = operation.getBundle();\n+                final SafeActivityOptions safeOptions =\n+                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n                 final int result = waitAsyncStart(() -> mService.getActivityStartController()\n-                        .startActivityInTaskFragment(taskFragment, activityIntent, activityOptions,\n+                        .startActivityInTaskFragment(taskFragment, activityIntent, safeOptions,\n                                 callerActivityToken, caller.mUid, caller.mPid,\n                                 errorCallbackToken));\n                 if (!isStartResultSuccessful(result)) {\n```",
                                    "rej_file_tokens": {
                                        "openai": 194,
                                        "general": {
                                            "word_based": 75,
                                            "char_based": 280
                                        },
                                        "gemini": 232
                                    },
                                    "patch_apply_output": "patching file services/core/java/com/android/server/wm/ActivityStartController.java\nHunk #1 succeeded at 39 with fuzz 2 (offset -4 lines).\nHunk #2 succeeded at 499 (offset -50 lines).\npatching file services/core/java/com/android/server/wm/WindowOrganizerController.java\nHunk #1 FAILED at 1517.\n1 out of 1 hunk FAILED -- saving rejects to file services/core/java/com/android/server/wm/WindowOrganizerController.java.rej",
                                    "inline_merge_output": "patching file services/core/java/com/android/server/wm/WindowOrganizerController.java\nHunk #1 already applied at 1520-1521,1523.",
                                    "upstream_file_tokens": {
                                        "openai": 24982,
                                        "general": {
                                            "word_based": 9778,
                                            "char_based": 33936
                                        },
                                        "gemini": 29346
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2020 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.wm;\n\nimport static android.Manifest.permission.START_TASKS_FROM_RECENTS;\nimport static android.app.ActivityManager.isStartResultSuccessful;\nimport static android.app.WindowConfiguration.WINDOW_CONFIG_BOUNDS;\nimport static android.view.Display.DEFAULT_DISPLAY;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_ADD_RECT_INSETS_PROVIDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_CHILDREN_TASKS_REPARENT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_CREATE_TASK_FRAGMENT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_DELETE_TASK_FRAGMENT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_LAUNCH_TASK;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_PENDING_INTENT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REMOVE_INSETS_PROVIDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REORDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REPARENT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REPARENT_ACTIVITY_TO_TASK_FRAGMENT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REPARENT_CHILDREN;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REQUEST_FOCUS_ON_TASK_FRAGMENT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_RESTORE_TRANSIENT_ORDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_ADJACENT_ROOTS;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_ADJACENT_TASK_FRAGMENTS;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_LAUNCH_ADJACENT_FLAG_ROOT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_LAUNCH_ROOT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_START_ACTIVITY_IN_TASK_FRAGMENT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_START_SHORTCUT;\n\nimport static com.android.internal.protolog.ProtoLogGroup.WM_DEBUG_WINDOW_ORGANIZER;\nimport static com.android.server.wm.ActivityTaskManagerService.LAYOUT_REASON_CONFIG_CHANGED;\nimport static com.android.server.wm.ActivityTaskSupervisor.PRESERVE_WINDOWS;\nimport static com.android.server.wm.Task.FLAG_FORCE_HIDDEN_FOR_TASK_ORG;\nimport static com.android.server.wm.TaskFragment.EMBEDDING_ALLOWED;\nimport static com.android.server.wm.WindowContainer.POSITION_BOTTOM;\nimport static com.android.server.wm.WindowContainer.POSITION_TOP;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.ActivityManager;\nimport android.app.ActivityOptions;\nimport android.app.IApplicationThread;\nimport android.app.WindowConfiguration;\nimport android.content.ActivityNotFoundException;\nimport android.content.Intent;\nimport android.content.pm.ActivityInfo;\nimport android.content.res.Configuration;\nimport android.graphics.Point;\nimport android.graphics.Rect;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.IBinder;\nimport android.os.Parcel;\nimport android.os.RemoteException;\nimport android.util.AndroidRuntimeException;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.Slog;\nimport android.view.RemoteAnimationAdapter;\nimport android.view.SurfaceControl;\nimport android.window.IDisplayAreaOrganizerController;\nimport android.window.ITaskFragmentOrganizer;\nimport android.window.ITaskFragmentOrganizerController;\nimport android.window.ITaskOrganizerController;\nimport android.window.ITransitionMetricsReporter;\nimport android.window.ITransitionPlayer;\nimport android.window.IWindowContainerTransactionCallback;\nimport android.window.IWindowOrganizerController;\nimport android.window.TaskFragmentCreationParams;\nimport android.window.WindowContainerTransaction;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.protolog.ProtoLogGroup;\nimport com.android.internal.protolog.common.ProtoLog;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.function.pooled.PooledConsumer;\nimport com.android.internal.util.function.pooled.PooledLambda;\nimport com.android.server.LocalServices;\nimport com.android.server.pm.LauncherAppsService.LauncherAppsServiceInternal;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.IntSupplier;\n\n/**\n * Server side implementation for the interface for organizing windows\n * @see android.window.WindowOrganizer\n */\nclass WindowOrganizerController extends IWindowOrganizerController.Stub\n        implements BLASTSyncEngine.TransactionReadyListener {\n\n    private static final String TAG = \"WindowOrganizerController\";\n\n    /** Flag indicating that an applied transaction may have effected lifecycle */\n    private static final int TRANSACT_EFFECTS_CLIENT_CONFIG = 1;\n    private static final int TRANSACT_EFFECTS_LIFECYCLE = 1 << 1;\n\n    /**\n     * Masks specifying which configurations task-organizers can control. Incoming transactions\n     * will be filtered to only include these.\n     */\n    static final int CONTROLLABLE_CONFIGS = ActivityInfo.CONFIG_WINDOW_CONFIGURATION\n            | ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE | ActivityInfo.CONFIG_SCREEN_SIZE\n            | ActivityInfo.CONFIG_LAYOUT_DIRECTION;\n    static final int CONTROLLABLE_WINDOW_CONFIGS = WINDOW_CONFIG_BOUNDS\n            | WindowConfiguration.WINDOW_CONFIG_APP_BOUNDS;\n\n    private final ActivityTaskManagerService mService;\n    private final WindowManagerGlobalLock mGlobalLock;\n\n    private final HashMap<Integer, IWindowContainerTransactionCallback>\n            mTransactionCallbacksByPendingSyncId = new HashMap();\n\n    final TaskOrganizerController mTaskOrganizerController;\n    final DisplayAreaOrganizerController mDisplayAreaOrganizerController;\n    final TaskFragmentOrganizerController mTaskFragmentOrganizerController;\n\n    TransitionController mTransitionController;\n    /**\n     * A Map which manages the relationship between\n     * {@link TaskFragmentCreationParams#getFragmentToken()} and {@link TaskFragment}\n     */\n    @VisibleForTesting\n    final ArrayMap<IBinder, TaskFragment> mLaunchTaskFragments = new ArrayMap<>();\n\n    WindowOrganizerController(ActivityTaskManagerService atm) {\n        mService = atm;\n        mGlobalLock = atm.mGlobalLock;\n        mTaskOrganizerController = new TaskOrganizerController(mService);\n        mDisplayAreaOrganizerController = new DisplayAreaOrganizerController(mService);\n        mTaskFragmentOrganizerController = new TaskFragmentOrganizerController(atm);\n    }\n\n    void setWindowManager(WindowManagerService wms) {\n        mTransitionController = new TransitionController(mService, wms.mTaskSnapshotController);\n        mTransitionController.registerLegacyListener(wms.mActivityManagerAppTransitionNotifier);\n    }\n\n    TransitionController getTransitionController() {\n        return mTransitionController;\n    }\n\n    @Override\n    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)\n            throws RemoteException {\n        try {\n            return super.onTransact(code, data, reply, flags);\n        } catch (RuntimeException e) {\n            throw ActivityTaskManagerService.logAndRethrowRuntimeExceptionOnTransact(TAG, e);\n        }\n    }\n\n    @Override\n    public void applyTransaction(WindowContainerTransaction t) {\n        if (t == null) {\n            throw new IllegalArgumentException(\"Null transaction passed to applyTransaction\");\n        }\n        enforceTaskPermission(\"applyTransaction()\", t);\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                applyTransaction(t, -1 /*syncId*/, null /*transition*/, caller);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public int applySyncTransaction(WindowContainerTransaction t,\n            IWindowContainerTransactionCallback callback) {\n        if (t == null) {\n            throw new IllegalArgumentException(\"Null transaction passed to applySyncTransaction\");\n        }\n        enforceTaskPermission(\"applySyncTransaction()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                if (callback == null) {\n                    applyTransaction(t, -1 /* syncId*/, null /*transition*/, caller);\n                    return -1;\n                }\n\n                /**\n                 * If callback is non-null we are looking to synchronize this transaction by\n                 * collecting all the results in to a SurfaceFlinger transaction and then delivering\n                 * that to the given transaction ready callback. See {@link BLASTSyncEngine} for the\n                 * details of the operation. But at a high level we create a sync operation with a\n                 * given ID and an associated callback. Then we notify each WindowContainer in this\n                 * WindowContainer transaction that it is participating in a sync operation with\n                 * that ID. Once everything is notified we tell the BLASTSyncEngine \"setSyncReady\"\n                 * which means that we have added everything to the set. At any point after this,\n                 * all the WindowContainers will eventually finish applying their changes and notify\n                 * the BLASTSyncEngine which will deliver the Transaction to the callback.\n                 */\n                final BLASTSyncEngine.SyncGroup syncGroup = prepareSyncWithOrganizer(callback);\n                final int syncId = syncGroup.mSyncId;\n                if (!mService.mWindowManager.mSyncEngine.hasActiveSync()) {\n                    mService.mWindowManager.mSyncEngine.startSyncSet(syncGroup);\n                    applyTransaction(t, syncId, null /*transition*/, caller);\n                    setSyncReady(syncId);\n                } else {\n                    // Because the BLAST engine only supports one sync at a time, queue the\n                    // transaction.\n                    mService.mWindowManager.mSyncEngine.queueSyncSet(\n                            () -> mService.mWindowManager.mSyncEngine.startSyncSet(syncGroup),\n                            () -> {\n                                applyTransaction(t, syncId, null /*transition*/, caller);\n                                setSyncReady(syncId);\n                            });\n                }\n                return syncId;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public IBinder startTransition(int type, @Nullable IBinder transitionToken,\n            @Nullable WindowContainerTransaction t) {\n        enforceTaskPermission(\"startTransition()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                Transition transition = Transition.fromBinder(transitionToken);\n                if (mTransitionController.getTransitionPlayer() == null && transition == null) {\n                    Slog.w(TAG, \"Using shell transitions API for legacy transitions.\");\n                    if (t == null) {\n                        throw new IllegalArgumentException(\"Can't use legacy transitions in\"\n                                + \" compatibility mode with no WCT.\");\n                    }\n                    applyTransaction(t, -1 /* syncId */, null, caller);\n                    return null;\n                }\n                // In cases where transition is already provided, the \"readiness lifecycle\" of the\n                // transition is determined outside of this transaction. However, if this is a\n                // direct call from shell, the entire transition lifecycle is contained in the\n                // provided transaction and thus we can setReady immediately after apply.\n                final boolean needsSetReady = transition == null && t != null;\n                final WindowContainerTransaction wct =\n                        t != null ? t : new WindowContainerTransaction();\n                if (transition == null) {\n                    if (type < 0) {\n                        throw new IllegalArgumentException(\"Can't create transition with no type\");\n                    }\n                    // If there is already a collecting transition, queue up a new transition and\n                    // return that. The actual start and apply will then be deferred until that\n                    // transition starts collecting. This should almost never happen except during\n                    // tests.\n                    if (mService.mWindowManager.mSyncEngine.hasActiveSync()) {\n                        Slog.w(TAG, \"startTransition() while one is already collecting.\");\n                        final Transition nextTransition = new Transition(type, 0 /* flags */,\n                                mTransitionController, mService.mWindowManager.mSyncEngine);\n                        ProtoLog.v(ProtoLogGroup.WM_DEBUG_WINDOW_TRANSITIONS,\n                                \"Creating Pending Transition: %s\", nextTransition);\n                        mService.mWindowManager.mSyncEngine.queueSyncSet(\n                                // Make sure to collect immediately to prevent another transition\n                                // from sneaking in before it. Note: moveToCollecting internally\n                                // calls startSyncSet.\n                                () -> mTransitionController.moveToCollecting(nextTransition),\n                                () -> {\n                                    nextTransition.start();\n                                    applyTransaction(wct, -1 /*syncId*/, nextTransition, caller);\n                                    if (needsSetReady) {\n                                        nextTransition.setAllReady();\n                                    }\n                                });\n                        return nextTransition;\n                    }\n                    transition = mTransitionController.createTransition(type);\n                }\n                transition.start();\n                applyTransaction(wct, -1 /*syncId*/, transition, caller);\n                if (needsSetReady) {\n                    transition.setAllReady();\n                }\n                return transition;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public int startLegacyTransition(int type, @NonNull RemoteAnimationAdapter adapter,\n            @NonNull IWindowContainerTransactionCallback callback,\n            @NonNull WindowContainerTransaction t) {\n        enforceTaskPermission(\"startLegacyTransition()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        int syncId;\n        try {\n            synchronized (mGlobalLock) {\n                if (type < 0) {\n                    throw new IllegalArgumentException(\"Can't create transition with no type\");\n                }\n                if (mTransitionController.getTransitionPlayer() != null) {\n                    throw new IllegalArgumentException(\"Can't use legacy transitions in\"\n                            + \" when shell transitions are enabled.\");\n                }\n                final DisplayContent dc =\n                        mService.mRootWindowContainer.getDisplayContent(DEFAULT_DISPLAY);\n                if (dc.mAppTransition.isTransitionSet()) {\n                    // a transition already exists, so the callback probably won't be called.\n                    return -1;\n                }\n                adapter.setCallingPidUid(caller.mPid, caller.mUid);\n                dc.prepareAppTransition(type);\n                dc.mAppTransition.overridePendingAppTransitionRemote(adapter, true /* sync */);\n                syncId = startSyncWithOrganizer(callback);\n                applyTransaction(t, syncId, null /* transition */, caller);\n                setSyncReady(syncId);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n        return syncId;\n    }\n\n    @Override\n    public int finishTransition(@NonNull IBinder transitionToken,\n            @Nullable WindowContainerTransaction t,\n            @Nullable IWindowContainerTransactionCallback callback) {\n        enforceTaskPermission(\"finishTransition()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                int syncId = -1;\n                if (t != null && callback != null) {\n                    syncId = startSyncWithOrganizer(callback);\n                }\n                final Transition transition = Transition.fromBinder(transitionToken);\n                // apply the incoming transaction before finish in case it alters the visibility\n                // of the participants.\n                if (t != null) {\n                    applyTransaction(t, syncId, null /*transition*/, caller, transition);\n                }\n                getTransitionController().finishTransition(transitionToken);\n                if (syncId >= 0) {\n                    setSyncReady(syncId);\n                }\n                return syncId;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    private void applyTransaction(@NonNull WindowContainerTransaction t, int syncId,\n            @Nullable Transition transition, @NonNull CallerInfo caller) {\n        applyTransaction(t, syncId, transition, caller, null /* finishTransition */);\n    }\n\n    /**\n     * @param syncId If non-null, this will be a sync-transaction.\n     * @param transition A transition to collect changes into.\n     * @param caller Info about the calling process.\n     * @param finishTransition The transition that is currently being finished.\n     */\n    private void applyTransaction(@NonNull WindowContainerTransaction t, int syncId,\n            @Nullable Transition transition, @NonNull CallerInfo caller,\n            @Nullable Transition finishTransition) {\n        int effects = 0;\n        ProtoLog.v(WM_DEBUG_WINDOW_ORGANIZER, \"Apply window transaction, syncId=%d\", syncId);\n        mService.deferWindowLayout();\n        mService.mTaskSupervisor.setDeferRootVisibilityUpdate(true /* deferUpdate */);\n        try {\n            if (transition != null) {\n                // First check if we have a display rotation transition and if so, update it.\n                final DisplayContent dc = DisplayRotation.getDisplayFromTransition(transition);\n                if (dc != null && transition.mChanges.get(dc).hasChanged(dc)) {\n                    // Go through all tasks and collect them before the rotation\n                    // TODO(shell-transitions): move collect() to onConfigurationChange once\n                    //       wallpaper handling is synchronized.\n                    dc.mTransitionController.collectForDisplayChange(dc, transition);\n                    dc.sendNewConfiguration();\n                    effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                }\n            }\n            ArraySet<WindowContainer> haveConfigChanges = new ArraySet<>();\n            Iterator<Map.Entry<IBinder, WindowContainerTransaction.Change>> entries =\n                    t.getChanges().entrySet().iterator();\n            while (entries.hasNext()) {\n                final Map.Entry<IBinder, WindowContainerTransaction.Change> entry = entries.next();\n                final WindowContainer wc = WindowContainer.fromBinder(entry.getKey());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on detached container: \" + wc);\n                    continue;\n                }\n                // Make sure we add to the syncSet before performing\n                // operations so we don't end up splitting effects between the WM\n                // pending transaction and the BLASTSync transaction.\n                if (syncId >= 0) {\n                    addToSyncSet(syncId, wc);\n                }\n                if (transition != null) transition.collect(wc);\n\n                if (finishTransition != null) {\n                    // Deal with edge-cases in recents where it pretends to finish itself.\n                    if ((entry.getValue().getChangeMask()\n                            & WindowContainerTransaction.Change.CHANGE_FORCE_NO_PIP) != 0) {\n                        finishTransition.setCanPipOnFinish(false /* canPipOnFinish */);\n                    }\n                }\n\n                int containerEffect = applyWindowContainerChange(wc, entry.getValue(),\n                        t.getErrorCallbackToken());\n                effects |= containerEffect;\n\n                // Lifecycle changes will trigger ensureConfig for everything.\n                if ((effects & TRANSACT_EFFECTS_LIFECYCLE) == 0\n                        && (containerEffect & TRANSACT_EFFECTS_CLIENT_CONFIG) != 0) {\n                    haveConfigChanges.add(wc);\n                }\n            }\n            // Hierarchy changes\n            final List<WindowContainerTransaction.HierarchyOp> hops = t.getHierarchyOps();\n            final int hopSize = hops.size();\n            if (hopSize > 0) {\n                final boolean isInLockTaskMode = mService.isInLockTaskMode();\n                for (int i = 0; i < hopSize; ++i) {\n                    effects |= applyHierarchyOp(hops.get(i), effects, syncId, transition,\n                            isInLockTaskMode, caller, t.getErrorCallbackToken(),\n                            t.getTaskFragmentOrganizer(), finishTransition);\n                }\n            }\n            // Queue-up bounds-change transactions for tasks which are now organized. Do\n            // this after hierarchy ops so we have the final organized state.\n            entries = t.getChanges().entrySet().iterator();\n            while (entries.hasNext()) {\n                final Map.Entry<IBinder, WindowContainerTransaction.Change> entry = entries.next();\n                final WindowContainer wc = WindowContainer.fromBinder(entry.getKey());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on detached container: \" + wc);\n                    continue;\n                }\n                final Task task = wc.asTask();\n                final Rect surfaceBounds = entry.getValue().getBoundsChangeSurfaceBounds();\n                if (task == null || !task.isAttached() || surfaceBounds == null) {\n                    continue;\n                }\n                if (!task.isOrganized()) {\n                    final Task parent = task.getParent() != null ? task.getParent().asTask() : null;\n                    // Also allow direct children of created-by-organizer tasks to be\n                    // controlled. In the future, these will become organized anyways.\n                    if (parent == null || !parent.mCreatedByOrganizer) {\n                        throw new IllegalArgumentException(\n                                \"Can't manipulate non-organized task surface \" + task);\n                    }\n                }\n                final SurfaceControl.Transaction sft = new SurfaceControl.Transaction();\n                final SurfaceControl sc = task.getSurfaceControl();\n                sft.setPosition(sc, surfaceBounds.left, surfaceBounds.top);\n                if (surfaceBounds.isEmpty()) {\n                    sft.setWindowCrop(sc, null);\n                } else {\n                    sft.setWindowCrop(sc, surfaceBounds.width(), surfaceBounds.height());\n                }\n                task.setMainWindowSizeChangeTransaction(sft);\n            }\n            if ((effects & TRANSACT_EFFECTS_LIFECYCLE) != 0) {\n                mService.mTaskSupervisor.setDeferRootVisibilityUpdate(false /* deferUpdate */);\n                // Already calls ensureActivityConfig\n                mService.mRootWindowContainer.ensureActivitiesVisible(null, 0, PRESERVE_WINDOWS);\n                mService.mRootWindowContainer.resumeFocusedTasksTopActivities();\n            } else if ((effects & TRANSACT_EFFECTS_CLIENT_CONFIG) != 0) {\n                final PooledConsumer f = PooledLambda.obtainConsumer(\n                        ActivityRecord::ensureActivityConfiguration,\n                        PooledLambda.__(ActivityRecord.class), 0,\n                        true /* preserveWindow */);\n                try {\n                    for (int i = haveConfigChanges.size() - 1; i >= 0; --i) {\n                        haveConfigChanges.valueAt(i).forAllActivities(f);\n                    }\n                } finally {\n                    f.recycle();\n                }\n            }\n\n            if ((effects & TRANSACT_EFFECTS_CLIENT_CONFIG) == 0) {\n                mService.addWindowLayoutReasons(LAYOUT_REASON_CONFIG_CHANGED);\n            }\n        } finally {\n            mService.mTaskSupervisor.setDeferRootVisibilityUpdate(false /* deferUpdate */);\n            mService.continueWindowLayout();\n        }\n    }\n\n    private int applyChanges(WindowContainer<?> container,\n            WindowContainerTransaction.Change change, @Nullable IBinder errorCallbackToken) {\n        // The \"client\"-facing API should prevent bad changes; however, just in case, sanitize\n        // masks here.\n        final int configMask = change.getConfigSetMask() & CONTROLLABLE_CONFIGS;\n        final int windowMask = change.getWindowSetMask() & CONTROLLABLE_WINDOW_CONFIGS;\n        int effects = 0;\n        final int windowingMode = change.getWindowingMode();\n        if (configMask != 0) {\n\n            adjustBoundsForMinDimensionsIfNeeded(container, change, errorCallbackToken);\n\n            if (windowingMode > -1 && windowingMode != container.getWindowingMode()) {\n                // Special handling for when we are setting a windowingMode in the same transaction.\n                // Setting the windowingMode is going to call onConfigurationChanged so we don't\n                // need it called right now. Additionally, some logic requires everything in the\n                // configuration to change at the same time (ie. surface-freezer requires bounds\n                // and mode to change at the same time).\n                final Configuration c = container.getRequestedOverrideConfiguration();\n                c.setTo(change.getConfiguration(), configMask, windowMask);\n            } else {\n                final Configuration c =\n                        new Configuration(container.getRequestedOverrideConfiguration());\n                c.setTo(change.getConfiguration(), configMask, windowMask);\n                container.onRequestedOverrideConfigurationChanged(c);\n            }\n            effects |= TRANSACT_EFFECTS_CLIENT_CONFIG;\n            if (windowMask != 0 && container.isEmbedded()) {\n                // Changing bounds of the embedded TaskFragments may result in lifecycle changes.\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n        if ((change.getChangeMask() & WindowContainerTransaction.Change.CHANGE_FOCUSABLE) != 0) {\n            if (container.setFocusable(change.getFocusable())) {\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n\n        if (windowingMode > -1) {\n            if (mService.isInLockTaskMode()\n                    && WindowConfiguration.inMultiWindowMode(windowingMode)) {\n                throw new UnsupportedOperationException(\"Not supported to set multi-window\"\n                        + \" windowing mode during locked task mode.\");\n            }\n\n            final int prevMode = container.getWindowingMode();\n            container.setWindowingMode(windowingMode);\n            if (prevMode != container.getWindowingMode()) {\n                // The activity in the container may become focusable or non-focusable due to\n                // windowing modes changes (such as entering or leaving pinned windowing mode),\n                // so also apply the lifecycle effects to this transaction.\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n        return effects;\n    }\n\n    private void adjustBoundsForMinDimensionsIfNeeded(WindowContainer<?> container,\n            WindowContainerTransaction.Change change, @Nullable IBinder errorCallbackToken) {\n        final TaskFragment taskFragment = container.asTaskFragment();\n        if (taskFragment == null || !taskFragment.isEmbedded()) {\n            return;\n        }\n        if ((change.getWindowSetMask() & WINDOW_CONFIG_BOUNDS) == 0) {\n            return;\n        }\n        final WindowConfiguration winConfig = change.getConfiguration().windowConfiguration;\n        final Rect bounds = winConfig.getBounds();\n        final Point minDimensions = taskFragment.calculateMinDimension();\n        if (bounds.width() < minDimensions.x || bounds.height() < minDimensions.y) {\n            sendMinimumDimensionViolation(taskFragment, minDimensions, errorCallbackToken,\n                    \"setBounds:\" + bounds);\n            // Sets the bounds to match parent bounds.\n            winConfig.setBounds(new Rect());\n        }\n    }\n\n    private int applyTaskChanges(Task tr, WindowContainerTransaction.Change c) {\n        int effects = 0;\n        final SurfaceControl.Transaction t = c.getBoundsChangeTransaction();\n\n        if ((c.getChangeMask() & WindowContainerTransaction.Change.CHANGE_HIDDEN) != 0) {\n            if (tr.setForceHidden(FLAG_FORCE_HIDDEN_FOR_TASK_ORG, c.getHidden())) {\n                effects = TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n\n        final int childWindowingMode = c.getActivityWindowingMode();\n        if (childWindowingMode > -1) {\n            tr.setActivityWindowingMode(childWindowingMode);\n        }\n\n        if (t != null) {\n            tr.setMainWindowSizeChangeTransaction(t);\n        }\n\n        Rect enterPipBounds = c.getEnterPipBounds();\n        if (enterPipBounds != null) {\n            tr.mDisplayContent.mPinnedTaskController.setEnterPipBounds(enterPipBounds);\n        }\n\n        return effects;\n    }\n\n    private int applyDisplayAreaChanges(DisplayArea displayArea,\n            WindowContainerTransaction.Change c) {\n        final int[] effects = new int[1];\n\n        if ((c.getChangeMask()\n                & WindowContainerTransaction.Change.CHANGE_IGNORE_ORIENTATION_REQUEST) != 0) {\n            if (displayArea.setIgnoreOrientationRequest(c.getIgnoreOrientationRequest())) {\n                effects[0] |= TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n\n        displayArea.forAllTasks(task -> {\n            Task tr = (Task) task;\n            if ((c.getChangeMask() & WindowContainerTransaction.Change.CHANGE_HIDDEN) != 0) {\n                if (tr.setForceHidden(FLAG_FORCE_HIDDEN_FOR_TASK_ORG, c.getHidden())) {\n                    effects[0] |= TRANSACT_EFFECTS_LIFECYCLE;\n                }\n            }\n        });\n\n        return effects[0];\n    }\n\n    private int applyHierarchyOp(WindowContainerTransaction.HierarchyOp hop, int effects,\n            int syncId, @Nullable Transition transition, boolean isInLockTaskMode,\n            @NonNull CallerInfo caller, @Nullable IBinder errorCallbackToken,\n            @Nullable ITaskFragmentOrganizer organizer, @Nullable Transition finishTransition) {\n        final int type = hop.getType();\n        switch (type) {\n            case HIERARCHY_OP_TYPE_SET_LAUNCH_ROOT: {\n                final WindowContainer wc = WindowContainer.fromBinder(hop.getContainer());\n                final Task task = wc != null ? wc.asTask() : null;\n                if (task != null) {\n                    task.getDisplayArea().setLaunchRootTask(task,\n                            hop.getWindowingModes(), hop.getActivityTypes());\n                } else {\n                    throw new IllegalArgumentException(\"Cannot set non-task as launch root: \" + wc);\n                }\n                break;\n            }\n            case HIERARCHY_OP_TYPE_SET_LAUNCH_ADJACENT_FLAG_ROOT: {\n                final WindowContainer wc = WindowContainer.fromBinder(hop.getContainer());\n                final Task task = wc != null ? wc.asTask() : null;\n                final boolean clearRoot = hop.getToTop();\n                if (task == null) {\n                    throw new IllegalArgumentException(\"Cannot set non-task as launch root: \" + wc);\n                } else if (!task.mCreatedByOrganizer) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot set non-organized task as adjacent flag root: \" + wc);\n                } else if (task.getAdjacentTaskFragment() == null && !clearRoot) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot set non-adjacent task as adjacent flag root: \" + wc);\n                }\n\n                task.getDisplayArea().setLaunchAdjacentFlagRootTask(clearRoot ? null : task);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_SET_ADJACENT_ROOTS: {\n                effects |= setAdjacentRootsHierarchyOp(hop);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_CREATE_TASK_FRAGMENT: {\n                final TaskFragmentCreationParams taskFragmentCreationOptions =\n                        hop.getTaskFragmentCreationOptions();\n                createTaskFragment(taskFragmentCreationOptions, errorCallbackToken, caller);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_DELETE_TASK_FRAGMENT: {\n                final WindowContainer wc = WindowContainer.fromBinder(hop.getContainer());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on unknown or detached container: \" + wc);\n                    break;\n                }\n                final TaskFragment taskFragment = wc.asTaskFragment();\n                if (taskFragment == null || taskFragment.asTask() != null) {\n                    throw new IllegalArgumentException(\n                            \"Can only delete organized TaskFragment, but not Task.\");\n                }\n                if (isInLockTaskMode) {\n                    final ActivityRecord bottomActivity = taskFragment.getActivity(\n                            a -> !a.finishing, false /* traverseTopToBottom */);\n                    if (bottomActivity != null\n                            && mService.getLockTaskController().activityBlockedFromFinish(\n                                    bottomActivity)) {\n                        Slog.w(TAG, \"Skip removing TaskFragment due in lock task mode.\");\n                        sendTaskFragmentOperationFailure(organizer, errorCallbackToken,\n                                new IllegalStateException(\n                                        \"Not allow to delete task fragment in lock task mode.\"));\n                        break;\n                    }\n                }\n                effects |= deleteTaskFragment(taskFragment, organizer, errorCallbackToken);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_START_ACTIVITY_IN_TASK_FRAGMENT: {\n                final IBinder fragmentToken = hop.getContainer();\n                final TaskFragment tf = mLaunchTaskFragments.get(fragmentToken);\n                if (tf == null) {\n                    final Throwable exception = new IllegalArgumentException(\n                            \"Not allowed to operate with invalid fragment token\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, exception);\n                    break;\n                }\n                if (tf.isEmbeddedTaskFragmentInPip()) {\n                    final Throwable exception = new IllegalArgumentException(\n                            \"Not allowed to start activity in PIP TaskFragment\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, exception);\n                    break;\n                }\n                final Intent activityIntent = hop.getActivityIntent();\n                final Bundle activityOptions = hop.getLaunchOptions();\n                final int result = mService.getActivityStartController()\n                        .startActivityInTaskFragment(tf, activityIntent, activityOptions,\n                                hop.getCallingActivity(), caller.mUid, caller.mPid,\n                                errorCallbackToken);\n                if (!isStartResultSuccessful(result)) {\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken,\n                            convertStartFailureToThrowable(result, activityIntent));\n                } else {\n                    effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                }\n                break;\n            }\n            case HIERARCHY_OP_TYPE_REPARENT_ACTIVITY_TO_TASK_FRAGMENT: {\n                final IBinder fragmentToken = hop.getNewParent();\n                final IBinder activityToken = hop.getContainer();\n                ActivityRecord activity = ActivityRecord.forTokenLocked(activityToken);\n                if (activity == null) {\n                    // The token may be a temporary token if the activity doesn't belong to\n                    // the organizer process.\n                    activity = mTaskFragmentOrganizerController\n                            .getReparentActivityFromTemporaryToken(organizer, activityToken);\n                }\n                final TaskFragment parent = mLaunchTaskFragments.get(fragmentToken);\n                if (parent == null || activity == null) {\n                    final Throwable exception = new IllegalArgumentException(\n                            \"Not allowed to operate with invalid fragment token or activity.\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, exception);\n                    break;\n                }\n                if (parent.isEmbeddedTaskFragmentInPip()) {\n                    final Throwable exception = new IllegalArgumentException(\n                            \"Not allowed to reparent activity to PIP TaskFragment\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, exception);\n                    break;\n                }\n                if (parent.isAllowedToEmbedActivity(activity) != EMBEDDING_ALLOWED) {\n                    final Throwable exception = new SecurityException(\n                            \"The task fragment is not allowed to embed the given activity.\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, exception);\n                    break;\n                }\n                if (parent.getTask() != activity.getTask()) {\n                    final Throwable exception = new SecurityException(\"The reparented activity is\"\n                            + \" not in the same Task as the target TaskFragment.\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, exception);\n                    break;\n                }\n\n                activity.reparent(parent, POSITION_TOP);\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                break;\n            }\n            case HIERARCHY_OP_TYPE_SET_ADJACENT_TASK_FRAGMENTS: {\n                final IBinder fragmentToken = hop.getContainer();\n                final IBinder adjacentFragmentToken = hop.getAdjacentRoot();\n                final TaskFragment tf1 = mLaunchTaskFragments.get(fragmentToken);\n                final TaskFragment tf2 = adjacentFragmentToken != null\n                        ? mLaunchTaskFragments.get(adjacentFragmentToken)\n                        : null;\n                if (tf1 == null || (adjacentFragmentToken != null && tf2 == null)) {\n                    final Throwable exception = new IllegalArgumentException(\n                            \"Not allowed to set adjacent on invalid fragment tokens\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, exception);\n                    break;\n                }\n                if (tf1.isEmbeddedTaskFragmentInPip()\n                        || (tf2 != null && tf2.isEmbeddedTaskFragmentInPip())) {\n                    final Throwable exception = new IllegalArgumentException(\n                            \"Not allowed to set adjacent on TaskFragment in PIP Task\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, exception);\n                    break;\n                }\n                tf1.setAdjacentTaskFragment(tf2, false /* moveAdjacentTogether */);\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n\n                final Bundle bundle = hop.getLaunchOptions();\n                final WindowContainerTransaction.TaskFragmentAdjacentParams adjacentParams =\n                        bundle != null ? new WindowContainerTransaction.TaskFragmentAdjacentParams(\n                                bundle) : null;\n                if (adjacentParams == null) {\n                    break;\n                }\n\n                tf1.setDelayLastActivityRemoval(\n                        adjacentParams.shouldDelayPrimaryLastActivityRemoval());\n                if (tf2 != null) {\n                    tf2.setDelayLastActivityRemoval(\n                            adjacentParams.shouldDelaySecondaryLastActivityRemoval());\n                }\n                break;\n            }\n            case HIERARCHY_OP_TYPE_REQUEST_FOCUS_ON_TASK_FRAGMENT: {\n                final TaskFragment tf = mLaunchTaskFragments.get(hop.getContainer());\n                if (tf == null || !tf.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on detached container: \" + tf);\n                    break;\n                }\n                final ActivityRecord curFocus = tf.getDisplayContent().mFocusedApp;\n                if (curFocus != null && curFocus.getTaskFragment() == tf) {\n                    Slog.d(TAG, \"The requested TaskFragment already has the focus.\");\n                    break;\n                }\n                if (curFocus != null && curFocus.getTask() != tf.getTask()) {\n                    Slog.d(TAG, \"The Task of the requested TaskFragment doesn't have focus.\");\n                    break;\n                }\n                final ActivityRecord targetFocus = tf.getTopResumedActivity();\n                if (targetFocus == null) {\n                    Slog.d(TAG, \"There is no resumed activity in the requested TaskFragment.\");\n                    break;\n                }\n                tf.getDisplayContent().setFocusedApp(targetFocus);\n                break;\n            }\n            default: {\n                // The other operations may change task order so they are skipped while in lock\n                // task mode. The above operations are still allowed because they don't move\n                // tasks. And it may be necessary such as clearing launch root after entering\n                // lock task mode.\n                if (isInLockTaskMode) {\n                    Slog.w(TAG, \"Skip applying hierarchy operation \" + hop\n                            + \" while in lock task mode\");\n                    return effects;\n                }\n            }\n        }\n\n        switch (type) {\n            case HIERARCHY_OP_TYPE_CHILDREN_TASKS_REPARENT: {\n                effects |= reparentChildrenTasksHierarchyOp(hop, transition, syncId);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_REORDER:\n            case HIERARCHY_OP_TYPE_REPARENT: {\n                final WindowContainer wc = WindowContainer.fromBinder(hop.getContainer());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on detached container: \" + wc);\n                    break;\n                }\n                if (syncId >= 0) {\n                    addToSyncSet(syncId, wc);\n                }\n                if (transition != null) {\n                    transition.collect(wc);\n                    if (hop.isReparent()) {\n                        if (wc.getParent() != null) {\n                            // Collect the current parent. It's visibility may change as\n                            // a result of this reparenting.\n                            transition.collect(wc.getParent());\n                        }\n                        if (hop.getNewParent() != null) {\n                            final WindowContainer parentWc =\n                                    WindowContainer.fromBinder(hop.getNewParent());\n                            if (parentWc == null) {\n                                Slog.e(TAG, \"Can't resolve parent window from token\");\n                                break;\n                            }\n                            transition.collect(parentWc);\n                        }\n                    }\n                }\n                effects |= sanitizeAndApplyHierarchyOp(wc, hop);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_LAUNCH_TASK: {\n                mService.mAmInternal.enforceCallingPermission(START_TASKS_FROM_RECENTS,\n                        \"launchTask HierarchyOp\");\n                final Bundle launchOpts = hop.getLaunchOptions();\n                final int taskId = launchOpts.getInt(\n                        WindowContainerTransaction.HierarchyOp.LAUNCH_KEY_TASK_ID);\n                launchOpts.remove(WindowContainerTransaction.HierarchyOp.LAUNCH_KEY_TASK_ID);\n                final SafeActivityOptions safeOptions =\n                        SafeActivityOptions.fromBundle(launchOpts, caller.mPid, caller.mUid);\n                waitAsyncStart(() -> mService.mTaskSupervisor.startActivityFromRecents(\n                        caller.mPid, caller.mUid, taskId, safeOptions));\n                break;\n            }\n            case HIERARCHY_OP_TYPE_PENDING_INTENT: {\n                String resolvedType = hop.getActivityIntent() != null\n                        ? hop.getActivityIntent().resolveTypeIfNeeded(\n                        mService.mContext.getContentResolver())\n                        : null;\n\n                ActivityOptions activityOptions = null;\n                if (hop.getPendingIntent().isActivity()) {\n                    // Set the context display id as preferred for this activity launches, so that\n                    // it can land on caller's display. Or just brought the task to front at the\n                    // display where it was on since it has higher preference.\n                    activityOptions = hop.getLaunchOptions() != null\n                            ? new ActivityOptions(hop.getLaunchOptions())\n                            : ActivityOptions.makeBasic();\n                    activityOptions.setCallerDisplayId(DEFAULT_DISPLAY);\n                }\n                final Bundle options = activityOptions != null ? activityOptions.toBundle() : null;\n                waitAsyncStart(() -> mService.mAmInternal.sendIntentSender(\n                        hop.getPendingIntent().getTarget(),\n                        hop.getPendingIntent().getWhitelistToken(), 0 /* code */,\n                        hop.getActivityIntent(), resolvedType, null /* finishReceiver */,\n                        null /* requiredPermission */, options));\n                break;\n            }\n            case HIERARCHY_OP_TYPE_START_SHORTCUT: {\n                final Bundle launchOpts = hop.getLaunchOptions();\n                final String callingPackage = launchOpts.getString(\n                        WindowContainerTransaction.HierarchyOp.LAUNCH_KEY_SHORTCUT_CALLING_PACKAGE);\n                launchOpts.remove(\n                        WindowContainerTransaction.HierarchyOp.LAUNCH_KEY_SHORTCUT_CALLING_PACKAGE);\n\n                final LauncherAppsServiceInternal launcherApps = LocalServices.getService(\n                        LauncherAppsServiceInternal.class);\n\n                launcherApps.startShortcut(caller.mUid, caller.mPid, callingPackage,\n                        hop.getShortcutInfo().getPackage(), null /* default featureId */,\n                        hop.getShortcutInfo().getId(), null /* sourceBounds */, launchOpts,\n                        hop.getShortcutInfo().getUserId());\n                break;\n            }\n            case HIERARCHY_OP_TYPE_REPARENT_CHILDREN: {\n                final WindowContainer oldParent = WindowContainer.fromBinder(hop.getContainer());\n                final WindowContainer newParent = hop.getNewParent() != null\n                        ? WindowContainer.fromBinder(hop.getNewParent())\n                        : null;\n                if (oldParent == null || oldParent.asTaskFragment() == null\n                        || !oldParent.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on unknown or detached container: \"\n                            + oldParent);\n                    break;\n                }\n                reparentTaskFragment(oldParent.asTaskFragment(), newParent, organizer,\n                        errorCallbackToken);\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                break;\n            }\n            case HIERARCHY_OP_TYPE_RESTORE_TRANSIENT_ORDER: {\n                if (finishTransition == null) break;\n                final WindowContainer container = WindowContainer.fromBinder(hop.getContainer());\n                if (container == null) break;\n                final Task thisTask = container.asActivityRecord() != null\n                        ? container.asActivityRecord().getTask() : container.asTask();\n                if (thisTask == null) break;\n                final Task restoreAt = finishTransition.getTransientLaunchRestoreTarget(container);\n                if (restoreAt == null) break;\n                final TaskDisplayArea taskDisplayArea = thisTask.getTaskDisplayArea();\n                taskDisplayArea.moveRootTaskBehindRootTask(thisTask.getRootTask(), restoreAt);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_ADD_RECT_INSETS_PROVIDER:\n                final Rect insetsProviderWindowContainer = hop.getInsetsProviderFrame();\n                final WindowContainer receiverWindowContainer =\n                        WindowContainer.fromBinder(hop.getContainer());\n                receiverWindowContainer.addLocalRectInsetsSourceProvider(\n                        insetsProviderWindowContainer, hop.getInsetsTypes());\n                break;\n            case HIERARCHY_OP_TYPE_REMOVE_INSETS_PROVIDER:\n                WindowContainer.fromBinder(hop.getContainer())\n                        .removeLocalInsetsSourceProvider(hop.getInsetsTypes());\n                break;\n        }\n        return effects;\n    }\n\n    /** A helper method to send minimum dimension violation error to the client. */\n    private void sendMinimumDimensionViolation(TaskFragment taskFragment, Point minDimensions,\n            IBinder errorCallbackToken, String reason) {\n        if (taskFragment == null || taskFragment.getTaskFragmentOrganizer() == null) {\n            return;\n        }\n        final Throwable exception = new SecurityException(\"The task fragment's bounds:\"\n                + taskFragment.getBounds() + \" does not satisfy minimum dimensions:\"\n                + minDimensions + \" \" + reason);\n        sendTaskFragmentOperationFailure(taskFragment.getTaskFragmentOrganizer(),\n                errorCallbackToken, exception);\n    }\n\n    /**\n     * Post and wait for the result of the activity start to prevent potential deadlock against\n     * {@link WindowManagerGlobalLock}.\n     */\n    private void waitAsyncStart(IntSupplier startActivity) {\n        final Integer[] starterResult = {null};\n        mService.mH.post(() -> {\n            try {\n                starterResult[0] = startActivity.getAsInt();\n            } catch (Throwable t) {\n                starterResult[0] = ActivityManager.START_CANCELED;\n                Slog.w(TAG, t);\n            }\n            synchronized (mGlobalLock) {\n                mGlobalLock.notifyAll();\n            }\n        });\n        while (starterResult[0] == null) {\n            try {\n                mGlobalLock.wait();\n            } catch (InterruptedException ignored) {\n            }\n        }\n    }\n\n    private int sanitizeAndApplyHierarchyOp(WindowContainer container,\n            WindowContainerTransaction.HierarchyOp hop) {\n        final Task task = container.asTask();\n        if (task == null) {\n            throw new IllegalArgumentException(\"Invalid container in hierarchy op\");\n        }\n        final DisplayContent dc = task.getDisplayContent();\n        if (dc == null) {\n            Slog.w(TAG, \"Container is no longer attached: \" + task);\n            return 0;\n        }\n        final Task as = task;\n\n        if (hop.isReparent()) {\n            final boolean isNonOrganizedRootableTask =\n                    task.isRootTask() || task.getParent().asTask().mCreatedByOrganizer;\n            if (isNonOrganizedRootableTask) {\n                WindowContainer newParent = hop.getNewParent() == null\n                        ? dc.getDefaultTaskDisplayArea()\n                        : WindowContainer.fromBinder(hop.getNewParent());\n                if (newParent == null) {\n                    Slog.e(TAG, \"Can't resolve parent window from token\");\n                    return 0;\n                }\n                if (task.getParent() != newParent) {\n                    if (newParent.asTaskDisplayArea() != null) {\n                        // For now, reparenting to displayarea is different from other reparents...\n                        as.reparent(newParent.asTaskDisplayArea(), hop.getToTop());\n                    } else if (newParent.asTask() != null) {\n                        if (newParent.inMultiWindowMode() && task.isLeafTask()) {\n                            if (newParent.inPinnedWindowingMode()) {\n                                Slog.w(TAG, \"Can't support moving a task to another PIP window...\"\n                                        + \" newParent=\" + newParent + \" task=\" + task);\n                                return 0;\n                            }\n                            if (!task.supportsMultiWindowInDisplayArea(\n                                    newParent.asTask().getDisplayArea())) {\n                                Slog.w(TAG, \"Can't support task that doesn't support multi-window\"\n                                        + \" mode in multi-window mode... newParent=\" + newParent\n                                        + \" task=\" + task);\n                                return 0;\n                            }\n                        }\n                        task.reparent((Task) newParent,\n                                hop.getToTop() ? POSITION_TOP : POSITION_BOTTOM,\n                                false /*moveParents*/, \"sanitizeAndApplyHierarchyOp\");\n                    } else {\n                        throw new RuntimeException(\"Can only reparent task to another task or\"\n                                + \" taskDisplayArea, but not \" + newParent);\n                    }\n                } else {\n                    final Task rootTask = (Task) (\n                            (newParent != null && !(newParent instanceof TaskDisplayArea))\n                                    ? newParent : task.getRootTask());\n                    as.getDisplayArea().positionChildAt(\n                            hop.getToTop() ? POSITION_TOP : POSITION_BOTTOM, rootTask,\n                            false /* includingParents */);\n                }\n            } else {\n                throw new RuntimeException(\"Reparenting leaf Tasks is not supported now. \" + task);\n            }\n        } else {\n            task.getParent().positionChildAt(\n                    hop.getToTop() ? POSITION_TOP : POSITION_BOTTOM,\n                    task, false /* includingParents */);\n        }\n        return TRANSACT_EFFECTS_LIFECYCLE;\n    }\n\n    private int reparentChildrenTasksHierarchyOp(WindowContainerTransaction.HierarchyOp hop,\n            @Nullable Transition transition, int syncId) {\n        WindowContainer<?> currentParent = hop.getContainer() != null\n                ? WindowContainer.fromBinder(hop.getContainer()) : null;\n        WindowContainer newParent = hop.getNewParent() != null\n                ? WindowContainer.fromBinder(hop.getNewParent()) : null;\n        if (currentParent == null && newParent == null) {\n            throw new IllegalArgumentException(\"reparentChildrenTasksHierarchyOp: \" + hop);\n        } else if (currentParent == null) {\n            currentParent = newParent.asTask().getDisplayContent().getDefaultTaskDisplayArea();\n        } else if (newParent == null) {\n            newParent = currentParent.asTask().getDisplayContent().getDefaultTaskDisplayArea();\n        }\n\n        if (currentParent == newParent) {\n            Slog.e(TAG, \"reparentChildrenTasksHierarchyOp parent not changing: \" + hop);\n            return 0;\n        }\n        if (!currentParent.isAttached()) {\n            Slog.e(TAG, \"reparentChildrenTasksHierarchyOp currentParent detached=\"\n                    + currentParent + \" hop=\" + hop);\n            return 0;\n        }\n        if (!newParent.isAttached()) {\n            Slog.e(TAG, \"reparentChildrenTasksHierarchyOp newParent detached=\"\n                    + newParent + \" hop=\" + hop);\n            return 0;\n        }\n        if (newParent.inPinnedWindowingMode()) {\n            Slog.e(TAG, \"reparentChildrenTasksHierarchyOp newParent in PIP=\"\n                    + newParent + \" hop=\" + hop);\n            return 0;\n        }\n\n        final boolean newParentInMultiWindow = newParent.inMultiWindowMode();\n        final TaskDisplayArea newParentTda = newParent.asTask() != null\n                ? newParent.asTask().getDisplayArea()\n                : newParent.asTaskDisplayArea();\n        final WindowContainer finalCurrentParent = currentParent;\n        Slog.i(TAG, \"reparentChildrenTasksHierarchyOp\"\n                + \" currentParent=\" + currentParent + \" newParent=\" + newParent + \" hop=\" + hop);\n\n        // We want to collect the tasks first before re-parenting to avoid array shifting on us.\n        final ArrayList<Task> tasksToReparent = new ArrayList<>();\n\n        currentParent.forAllTasks(task -> {\n            Slog.i(TAG, \" Processing task=\" + task);\n            final boolean reparent;\n            if (task.mCreatedByOrganizer || task.getParent() != finalCurrentParent) {\n                // We only care about non-organized task that are direct children of the thing we\n                // are reparenting from.\n                return false;\n            }\n            if (newParentInMultiWindow && !task.supportsMultiWindowInDisplayArea(newParentTda)) {\n                Slog.e(TAG, \"reparentChildrenTasksHierarchyOp non-resizeable task to multi window,\"\n                        + \" task=\" + task);\n                return false;\n            }\n            if (!ArrayUtils.contains(hop.getActivityTypes(), task.getActivityType())\n                    || !ArrayUtils.contains(hop.getWindowingModes(), task.getWindowingMode())) {\n                return false;\n            }\n\n            if (hop.getToTop()) {\n                tasksToReparent.add(0, task);\n            } else {\n                tasksToReparent.add(task);\n            }\n            return hop.getReparentTopOnly() && tasksToReparent.size() == 1;\n        });\n\n        final int count = tasksToReparent.size();\n        for (int i = 0; i < count; ++i) {\n            final Task task = tasksToReparent.get(i);\n            if (syncId >= 0) {\n                addToSyncSet(syncId, task);\n            }\n            if (transition != null) transition.collect(task);\n\n            if (newParent instanceof TaskDisplayArea) {\n                // For now, reparenting to display area is different from other reparents...\n                task.reparent((TaskDisplayArea) newParent, hop.getToTop());\n            } else {\n                task.reparent((Task) newParent,\n                        hop.getToTop() ? POSITION_TOP : POSITION_BOTTOM,\n                        false /*moveParents*/, \"processChildrenTaskReparentHierarchyOp\");\n            }\n        }\n\n        if (transition != null) transition.collect(newParent);\n\n        return TRANSACT_EFFECTS_LIFECYCLE;\n    }\n\n    private int setAdjacentRootsHierarchyOp(WindowContainerTransaction.HierarchyOp hop) {\n        final TaskFragment root1 = WindowContainer.fromBinder(hop.getContainer()).asTaskFragment();\n        final TaskFragment root2 =\n                WindowContainer.fromBinder(hop.getAdjacentRoot()).asTaskFragment();\n        if (!root1.mCreatedByOrganizer || !root2.mCreatedByOrganizer) {\n            throw new IllegalArgumentException(\"setAdjacentRootsHierarchyOp: Not created by\"\n                    + \" organizer root1=\" + root1 + \" root2=\" + root2);\n        }\n        if (root1.isEmbeddedTaskFragmentInPip() || root2.isEmbeddedTaskFragmentInPip()) {\n            Slog.e(TAG, \"Attempt to set adjacent TaskFragment in PIP Task\");\n            return 0;\n        }\n        root1.setAdjacentTaskFragment(root2, hop.getMoveAdjacentTogether());\n        return TRANSACT_EFFECTS_LIFECYCLE;\n    }\n\n    private void sanitizeWindowContainer(WindowContainer wc) {\n        if (!(wc instanceof TaskFragment) && !(wc instanceof DisplayArea)) {\n            throw new RuntimeException(\"Invalid token in task fragment or displayArea transaction\");\n        }\n    }\n\n    private int applyWindowContainerChange(WindowContainer wc,\n            WindowContainerTransaction.Change c, @Nullable IBinder errorCallbackToken) {\n        sanitizeWindowContainer(wc);\n        if (wc.asTaskFragment() != null && wc.asTaskFragment().isEmbeddedTaskFragmentInPip()) {\n            // No override from organizer for embedded TaskFragment in a PIP Task.\n            return 0;\n        }\n\n        int effects = applyChanges(wc, c, errorCallbackToken);\n\n        if (wc instanceof DisplayArea) {\n            effects |= applyDisplayAreaChanges(wc.asDisplayArea(), c);\n        } else if (wc instanceof Task) {\n            effects |= applyTaskChanges(wc.asTask(), c);\n        }\n\n        return effects;\n    }\n\n    @Override\n    public ITaskOrganizerController getTaskOrganizerController() {\n        enforceTaskPermission(\"getTaskOrganizerController()\");\n        return mTaskOrganizerController;\n    }\n\n    @Override\n    public IDisplayAreaOrganizerController getDisplayAreaOrganizerController() {\n        enforceTaskPermission(\"getDisplayAreaOrganizerController()\");\n        return mDisplayAreaOrganizerController;\n    }\n\n    @Override\n    public ITaskFragmentOrganizerController getTaskFragmentOrganizerController() {\n        return mTaskFragmentOrganizerController;\n    }\n\n    /**\n     * This will prepare a {@link BLASTSyncEngine.SyncGroup} for the organizer to track, but the\n     * {@link BLASTSyncEngine.SyncGroup} may not be active until the {@link BLASTSyncEngine} is\n     * free.\n     */\n    private BLASTSyncEngine.SyncGroup prepareSyncWithOrganizer(\n            IWindowContainerTransactionCallback callback) {\n        final BLASTSyncEngine.SyncGroup s = mService.mWindowManager.mSyncEngine\n                .prepareSyncSet(this, \"\");\n        mTransactionCallbacksByPendingSyncId.put(s.mSyncId, callback);\n        return s;\n    }\n\n    @VisibleForTesting\n    int startSyncWithOrganizer(IWindowContainerTransactionCallback callback) {\n        final BLASTSyncEngine.SyncGroup s = prepareSyncWithOrganizer(callback);\n        mService.mWindowManager.mSyncEngine.startSyncSet(s);\n        return s.mSyncId;\n    }\n\n    @VisibleForTesting\n    void setSyncReady(int id) {\n        ProtoLog.v(WM_DEBUG_WINDOW_ORGANIZER, \"Set sync ready, syncId=%d\", id);\n        mService.mWindowManager.mSyncEngine.setReady(id);\n    }\n\n    @VisibleForTesting\n    void addToSyncSet(int syncId, WindowContainer wc) {\n        mService.mWindowManager.mSyncEngine.addToSyncSet(syncId, wc);\n    }\n\n    @Override\n    public void onTransactionReady(int syncId, SurfaceControl.Transaction t) {\n        ProtoLog.v(WM_DEBUG_WINDOW_ORGANIZER, \"Transaction ready, syncId=%d\", syncId);\n        final IWindowContainerTransactionCallback callback =\n                mTransactionCallbacksByPendingSyncId.get(syncId);\n\n        try {\n            callback.onTransactionReady(syncId, t);\n        } catch (RemoteException e) {\n            // If there's an exception when trying to send the mergedTransaction to the client, we\n            // should immediately apply it here so the transactions aren't lost.\n            t.apply();\n        }\n\n        mTransactionCallbacksByPendingSyncId.remove(syncId);\n    }\n\n    @Override\n    public void registerTransitionPlayer(ITransitionPlayer player) {\n        enforceTaskPermission(\"registerTransitionPlayer()\");\n        final int callerPid = Binder.getCallingPid();\n        final int callerUid = Binder.getCallingUid();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final WindowProcessController wpc =\n                        mService.getProcessController(callerPid, callerUid);\n                IApplicationThread appThread = null;\n                if (wpc != null) {\n                    appThread = wpc.getThread();\n                }\n                mTransitionController.registerTransitionPlayer(player, appThread);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public ITransitionMetricsReporter getTransitionMetricsReporter() {\n        return mTransitionController.mTransitionMetricsReporter;\n    }\n\n    /** Whether the configuration changes are important to report back to an organizer. */\n    static boolean configurationsAreEqualForOrganizer(\n            Configuration newConfig, @Nullable Configuration oldConfig) {\n        if (oldConfig == null) {\n            return false;\n        }\n        int cfgChanges = newConfig.diff(oldConfig);\n        final int winCfgChanges = (cfgChanges & ActivityInfo.CONFIG_WINDOW_CONFIGURATION) != 0\n                ? (int) newConfig.windowConfiguration.diff(oldConfig.windowConfiguration,\n                true /* compareUndefined */) : 0;\n        if ((winCfgChanges & CONTROLLABLE_WINDOW_CONFIGS) == 0) {\n            cfgChanges &= ~ActivityInfo.CONFIG_WINDOW_CONFIGURATION;\n        }\n        return (cfgChanges & CONTROLLABLE_CONFIGS) == 0;\n    }\n\n    private void enforceTaskPermission(String func) {\n        mService.enforceTaskPermission(func);\n    }\n\n    private void enforceTaskPermission(String func, @Nullable WindowContainerTransaction t) {\n        if (t == null || t.getTaskFragmentOrganizer() == null) {\n            enforceTaskPermission(func);\n            return;\n        }\n\n        // Apps may not have the permission to manage Tasks, but we are allowing apps to manage\n        // TaskFragments belonging to their own Task.\n        enforceOperationsAllowedForTaskFragmentOrganizer(func, t);\n    }\n\n    /**\n     * Makes sure that the transaction only contains operations that are allowed for the\n     * {@link WindowContainerTransaction#getTaskFragmentOrganizer()}.\n     */\n    private void enforceOperationsAllowedForTaskFragmentOrganizer(\n            String func, WindowContainerTransaction t) {\n        final ITaskFragmentOrganizer organizer = t.getTaskFragmentOrganizer();\n\n        // Configuration changes\n        final Iterator<Map.Entry<IBinder, WindowContainerTransaction.Change>> entries =\n                t.getChanges().entrySet().iterator();\n        while (entries.hasNext()) {\n            final Map.Entry<IBinder, WindowContainerTransaction.Change> entry = entries.next();\n            // Only allow to apply changes to TaskFragment that is created by this organizer.\n            final WindowContainer wc = WindowContainer.fromBinder(entry.getKey());\n            enforceTaskFragmentOrganized(func, wc, organizer);\n            enforceTaskFragmentConfigChangeAllowed(func, wc, entry.getValue(), organizer);\n        }\n\n        // Hierarchy changes\n        final List<WindowContainerTransaction.HierarchyOp> hops = t.getHierarchyOps();\n        for (int i = hops.size() - 1; i >= 0; i--) {\n            final WindowContainerTransaction.HierarchyOp hop = hops.get(i);\n            final int type = hop.getType();\n            // Check for each type of the operations that are allowed for TaskFragmentOrganizer.\n            switch (type) {\n                case HIERARCHY_OP_TYPE_REORDER:\n                case HIERARCHY_OP_TYPE_DELETE_TASK_FRAGMENT:\n                    enforceTaskFragmentOrganized(func,\n                            WindowContainer.fromBinder(hop.getContainer()), organizer);\n                    break;\n                case HIERARCHY_OP_TYPE_SET_ADJACENT_ROOTS:\n                    enforceTaskFragmentOrganized(func,\n                            WindowContainer.fromBinder(hop.getContainer()), organizer);\n                    enforceTaskFragmentOrganized(func,\n                            WindowContainer.fromBinder(hop.getAdjacentRoot()),\n                            organizer);\n                    break;\n                case HIERARCHY_OP_TYPE_CREATE_TASK_FRAGMENT:\n                    // We are allowing organizer to create TaskFragment. We will check the\n                    // ownerToken in #createTaskFragment, and trigger error callback if that is not\n                    // valid.\n                case HIERARCHY_OP_TYPE_START_ACTIVITY_IN_TASK_FRAGMENT:\n                case HIERARCHY_OP_TYPE_REPARENT_ACTIVITY_TO_TASK_FRAGMENT:\n                case HIERARCHY_OP_TYPE_SET_ADJACENT_TASK_FRAGMENTS:\n                case HIERARCHY_OP_TYPE_REQUEST_FOCUS_ON_TASK_FRAGMENT:\n                    // We are allowing organizer to start/reparent activity to a TaskFragment it\n                    // created, or set two TaskFragments adjacent to each other. Nothing to check\n                    // here because the TaskFragment may not be created yet, but will be created in\n                    // the same transaction.\n                    break;\n                case HIERARCHY_OP_TYPE_REPARENT_CHILDREN:\n                    enforceTaskFragmentOrganized(func,\n                            WindowContainer.fromBinder(hop.getContainer()), organizer);\n                    if (hop.getNewParent() != null) {\n                        enforceTaskFragmentOrganized(func,\n                                WindowContainer.fromBinder(hop.getNewParent()),\n                                organizer);\n                    }\n                    break;\n                default:\n                    // Other types of hierarchy changes are not allowed.\n                    String msg = \"Permission Denial: \" + func + \" from pid=\"\n                            + Binder.getCallingPid() + \", uid=\" + Binder.getCallingUid()\n                            + \" trying to apply a hierarchy change that is not allowed for\"\n                            + \" TaskFragmentOrganizer=\" + organizer;\n                    Slog.w(TAG, msg);\n                    throw new SecurityException(msg);\n            }\n        }\n    }\n\n    private void enforceTaskFragmentOrganized(String func, @Nullable WindowContainer wc,\n            ITaskFragmentOrganizer organizer) {\n        if (wc == null) {\n            Slog.e(TAG, \"Attempt to operate on window that no longer exists\");\n            return;\n        }\n\n        final TaskFragment tf = wc.asTaskFragment();\n        if (tf == null || !tf.hasTaskFragmentOrganizer(organizer)) {\n            String msg = \"Permission Denial: \" + func + \" from pid=\" + Binder.getCallingPid()\n                    + \", uid=\" + Binder.getCallingUid() + \" trying to modify window container not\"\n                    + \" belonging to the TaskFragmentOrganizer=\" + organizer;\n            Slog.w(TAG, msg);\n            throw new SecurityException(msg);\n        }\n    }\n\n    /**\n     * Makes sure that SurfaceControl transactions and the ability to set bounds outside of the\n     * parent bounds are not allowed for embedding without full trust between the host and the\n     * target.\n     */\n    private void enforceTaskFragmentConfigChangeAllowed(String func, @Nullable WindowContainer wc,\n            WindowContainerTransaction.Change change, ITaskFragmentOrganizer organizer) {\n        if (wc == null) {\n            Slog.e(TAG, \"Attempt to operate on task fragment that no longer exists\");\n            return;\n        }\n        if (change == null) {\n            return;\n        }\n        final int changeMask = change.getChangeMask();\n        if (changeMask != 0) {\n            // None of the change should be requested from a TaskFragment organizer.\n            String msg = \"Permission Denial: \" + func + \" from pid=\"\n                    + Binder.getCallingPid() + \", uid=\" + Binder.getCallingUid()\n                    + \" trying to apply changes of \" + changeMask + \" to TaskFragment\"\n                    + \" TaskFragmentOrganizer=\" + organizer;\n            Slog.w(TAG, msg);\n            throw new SecurityException(msg);\n        }\n        // Check if TaskFragment is embedded in fully trusted mode.\n        if (wc.asTaskFragment().isAllowedToBeEmbeddedInTrustedMode()) {\n            // Fully trusted, no need to check further\n            return;\n        }\n        final WindowContainer wcParent = wc.getParent();\n        if (wcParent == null) {\n            Slog.e(TAG, \"Attempt to apply config change on task fragment that has no parent\");\n            return;\n        }\n        final Configuration requestedConfig = change.getConfiguration();\n        final Configuration parentConfig = wcParent.getConfiguration();\n        if (parentConfig.screenWidthDp < requestedConfig.screenWidthDp\n                || parentConfig.screenHeightDp < requestedConfig.screenHeightDp\n                || parentConfig.smallestScreenWidthDp < requestedConfig.smallestScreenWidthDp) {\n            String msg = \"Permission Denial: \" + func + \" from pid=\"\n                    + Binder.getCallingPid() + \", uid=\" + Binder.getCallingUid()\n                    + \" trying to apply screen width/height greater than parent's for non-trusted\"\n                    + \" host, TaskFragmentOrganizer=\" + organizer;\n            Slog.w(TAG, msg);\n            throw new SecurityException(msg);\n        }\n        if (change.getWindowSetMask() == 0) {\n            // No bounds change.\n            return;\n        }\n        final WindowConfiguration requestedWindowConfig = requestedConfig.windowConfiguration;\n        final WindowConfiguration parentWindowConfig = parentConfig.windowConfiguration;\n        if (!requestedWindowConfig.getBounds().isEmpty()\n                && !parentWindowConfig.getBounds().contains(requestedWindowConfig.getBounds())) {\n            String msg = \"Permission Denial: \" + func + \" from pid=\"\n                    + Binder.getCallingPid() + \", uid=\" + Binder.getCallingUid()\n                    + \" trying to apply bounds outside of parent for non-trusted host,\"\n                    + \" TaskFragmentOrganizer=\" + organizer;\n            Slog.w(TAG, msg);\n            throw new SecurityException(msg);\n        }\n        if (requestedWindowConfig.getAppBounds() != null\n                && !requestedWindowConfig.getAppBounds().isEmpty()\n                && parentWindowConfig.getAppBounds() != null\n                && !parentWindowConfig.getAppBounds().contains(\n                        requestedWindowConfig.getAppBounds())) {\n            String msg = \"Permission Denial: \" + func + \" from pid=\"\n                    + Binder.getCallingPid() + \", uid=\" + Binder.getCallingUid()\n                    + \" trying to apply app bounds outside of parent for non-trusted host,\"\n                    + \" TaskFragmentOrganizer=\" + organizer;\n            Slog.w(TAG, msg);\n            throw new SecurityException(msg);\n        }\n    }\n\n    void createTaskFragment(@NonNull TaskFragmentCreationParams creationParams,\n            @Nullable IBinder errorCallbackToken, @NonNull CallerInfo caller) {\n        final ActivityRecord ownerActivity =\n                ActivityRecord.forTokenLocked(creationParams.getOwnerToken());\n        final ITaskFragmentOrganizer organizer = ITaskFragmentOrganizer.Stub.asInterface(\n                creationParams.getOrganizer().asBinder());\n\n        if (ownerActivity == null || ownerActivity.getTask() == null) {\n            final Throwable exception =\n                    new IllegalArgumentException(\"Not allowed to operate with invalid ownerToken\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, exception);\n            return;\n        }\n        if (!ownerActivity.isResizeable()) {\n            final IllegalArgumentException exception = new IllegalArgumentException(\"Not allowed\"\n                    + \" to operate with non-resizable owner Activity\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, exception);\n            return;\n        }\n        // The ownerActivity has to belong to the same app as the target Task.\n        final Task ownerTask = ownerActivity.getTask();\n        if (ownerTask.effectiveUid != ownerActivity.getUid()\n                || ownerTask.effectiveUid != caller.mUid) {\n            final Throwable exception =\n                    new SecurityException(\"Not allowed to operate with the ownerToken while \"\n                            + \"the root activity of the target task belong to the different app\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, exception);\n            return;\n        }\n        if (ownerTask.inPinnedWindowingMode()) {\n            final Throwable exception = new IllegalArgumentException(\n                    \"Not allowed to create TaskFragment in PIP Task\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, exception);\n            return;\n        }\n        final TaskFragment taskFragment = new TaskFragment(mService,\n                creationParams.getFragmentToken(), true /* createdByOrganizer */);\n        // Set task fragment organizer immediately, since it might have to be notified about further\n        // actions.\n        taskFragment.setTaskFragmentOrganizer(creationParams.getOrganizer(),\n                ownerActivity.getUid(), ownerActivity.info.processName);\n        ownerTask.addChild(taskFragment, POSITION_TOP);\n        taskFragment.setWindowingMode(creationParams.getWindowingMode());\n        taskFragment.setBounds(creationParams.getInitialBounds());\n        mLaunchTaskFragments.put(creationParams.getFragmentToken(), taskFragment);\n    }\n\n    void reparentTaskFragment(@NonNull TaskFragment oldParent,\n            @Nullable WindowContainer<?> newParent, @Nullable ITaskFragmentOrganizer organizer,\n            @Nullable IBinder errorCallbackToken) {\n        final TaskFragment newParentTF;\n        if (newParent == null) {\n            // Use the old parent's parent if the caller doesn't specify the new parent.\n            newParentTF = oldParent.getTask();\n        } else {\n            newParentTF = newParent.asTaskFragment();\n        }\n        if (newParentTF == null) {\n            final Throwable exception =\n                    new IllegalArgumentException(\"Not allowed to operate with invalid container\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, exception);\n            return;\n        }\n        if (newParentTF.getTaskFragmentOrganizer() != null) {\n            // We are reparenting activities to a new embedded TaskFragment, this operation is only\n            // allowed if the new parent is trusted by all reparent activities.\n            final boolean isEmbeddingDisallowed = oldParent.forAllActivities(activity ->\n                    newParentTF.isAllowedToEmbedActivity(activity) != EMBEDDING_ALLOWED);\n            if (isEmbeddingDisallowed) {\n                final Throwable exception = new SecurityException(\n                        \"The new parent is not allowed to embed the activities.\");\n                sendTaskFragmentOperationFailure(organizer, errorCallbackToken, exception);\n                return;\n            }\n        }\n        if (newParentTF.isEmbeddedTaskFragmentInPip() || oldParent.isEmbeddedTaskFragmentInPip()) {\n            final Throwable exception = new SecurityException(\n                    \"Not allow to reparent in TaskFragment in PIP Task.\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, exception);\n            return;\n        }\n        if (newParentTF.getTask() != oldParent.getTask()) {\n            final Throwable exception = new SecurityException(\n                    \"The new parent is not in the same Task as the old parent.\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, exception);\n            return;\n        }\n        while (oldParent.hasChild()) {\n            oldParent.getChildAt(0).reparent(newParentTF, POSITION_TOP);\n        }\n    }\n\n    private int deleteTaskFragment(@NonNull TaskFragment taskFragment,\n            @Nullable ITaskFragmentOrganizer organizer, @Nullable IBinder errorCallbackToken) {\n        final int index = mLaunchTaskFragments.indexOfValue(taskFragment);\n        if (index < 0) {\n            final Throwable exception =\n                    new IllegalArgumentException(\"Not allowed to operate with invalid \"\n                            + \"taskFragment\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, exception);\n            return 0;\n        }\n        if (taskFragment.isEmbeddedTaskFragmentInPip()\n                // When the Task enters PiP before the organizer removes the empty TaskFragment, we\n                // should allow it to do the cleanup.\n                && taskFragment.getTopNonFinishingActivity() != null) {\n            final Throwable exception = new IllegalArgumentException(\n                    \"Not allowed to delete TaskFragment in PIP Task\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, exception);\n            return 0;\n        }\n        mLaunchTaskFragments.removeAt(index);\n        taskFragment.remove(true /* withTransition */, \"deleteTaskFragment\");\n        return TRANSACT_EFFECTS_LIFECYCLE;\n    }\n\n    @Nullable\n    TaskFragment getTaskFragment(IBinder tfToken) {\n        return mLaunchTaskFragments.get(tfToken);\n    }\n\n    void cleanUpEmbeddedTaskFragment(TaskFragment taskFragment) {\n        mLaunchTaskFragments.remove(taskFragment.getFragmentToken());\n    }\n\n    static class CallerInfo {\n        final int mPid;\n        final int mUid;\n\n        CallerInfo() {\n            mPid = Binder.getCallingPid();\n            mUid = Binder.getCallingUid();\n        }\n    }\n\n    void sendTaskFragmentOperationFailure(@NonNull ITaskFragmentOrganizer organizer,\n            @Nullable IBinder errorCallbackToken, @NonNull Throwable exception) {\n        if (organizer == null) {\n            throw new IllegalArgumentException(\"Not allowed to operate with invalid organizer\");\n        }\n        mService.mTaskFragmentOrganizerController\n                .onTaskFragmentError(organizer, errorCallbackToken, exception);\n    }\n\n    private Throwable convertStartFailureToThrowable(int result, Intent intent) {\n        switch (result) {\n            case ActivityManager.START_INTENT_NOT_RESOLVED:\n            case ActivityManager.START_CLASS_NOT_FOUND:\n                return new ActivityNotFoundException(\"No Activity found to handle \" + intent);\n            case ActivityManager.START_PERMISSION_DENIED:\n                return new SecurityException(\"Permission denied and not allowed to start activity \"\n                        + intent);\n            case ActivityManager.START_CANCELED:\n                return new AndroidRuntimeException(\"Activity could not be started for \" + intent\n                        + \" with error code : \" + result);\n            default:\n                return new AndroidRuntimeException(\"Start activity failed with error code : \"\n                        + result + \" when starting \" + intent);\n        }\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 15651,
                                        "general": {
                                            "word_based": 6241,
                                            "char_based": 21243
                                        },
                                        "gemini": 18246
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "198f7b559f9a13d5b9d26b41c6b95bc1e45fcb1e",
                            "repo_path": "android_repos/base",
                            "result": "failure",
                            "downstream_patch_content": "commit 198f7b559f9a13d5b9d26b41c6b95bc1e45fcb1e\nAuthor: Chris Li <lihongyu@google.com>\nDate:   Wed Oct 9 01:50:57 2024 +0000\n\n    Pass SafeActivityOptions with actual caller for startActivityInTF\n    \n    We clearCallingUid before apply the WCT, but SafeActivityOptions will\n    query the Binder Uid when construct. Update to pass in the actual\n    caller.\n    \n    Flag: EXEMPT bug fix\n    Bug: 369103643\n    Test: atest WmTests:WindowOrganizerTests#\n          testStartActivityInTaskFragment_checkCallerPermission\n    Merged-In: I873ae576de0bc4a7402c2f522b45853bce48a0c5\n    Change-Id: I873ae576de0bc4a7402c2f522b45853bce48a0c5\n    (cherry picked from commit 20c568e77eae5d469cd5e594b644d8645d830dbd)\n\ndiff --git a/services/core/java/com/android/server/wm/ActivityStartController.java b/services/core/java/com/android/server/wm/ActivityStartController.java\nindex a6e50405e7d9..4de02f7f812f 100644\n--- a/services/core/java/com/android/server/wm/ActivityStartController.java\n+++ b/services/core/java/com/android/server/wm/ActivityStartController.java\n@@ -43,7 +43,6 @@ import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageManager;\n import android.content.pm.ResolveInfo;\n import android.os.Binder;\n-import android.os.Bundle;\n import android.os.IBinder;\n import android.os.Trace;\n import android.os.UserHandle;\n@@ -529,14 +528,14 @@ public class ActivityStartController {\n      * Starts an activity in the TaskFragment.\n      * @param taskFragment TaskFragment {@link TaskFragment} to start the activity in.\n      * @param activityIntent intent to start the activity.\n-     * @param activityOptions ActivityOptions to start the activity with.\n+     * @param activityOptions SafeActivityOptions to start the activity with.\n      * @param resultTo the caller activity\n      * @param callingUid the caller uid\n      * @param callingPid the caller pid\n      * @return the start result.\n      */\n     int startActivityInTaskFragment(@NonNull TaskFragment taskFragment,\n-            @NonNull Intent activityIntent, @Nullable Bundle activityOptions,\n+            @NonNull Intent activityIntent, @Nullable SafeActivityOptions activityOptions,\n             @Nullable IBinder resultTo, int callingUid, int callingPid,\n             @Nullable IBinder errorCallbackToken) {\n         final ActivityRecord caller =\ndiff --git a/services/core/java/com/android/server/wm/WindowOrganizerController.java b/services/core/java/com/android/server/wm/WindowOrganizerController.java\nindex 027ab97693fd..7b59d6fbd820 100644\n--- a/services/core/java/com/android/server/wm/WindowOrganizerController.java\n+++ b/services/core/java/com/android/server/wm/WindowOrganizerController.java\n@@ -1189,8 +1189,10 @@ class WindowOrganizerController extends IWindowOrganizerController.Stub\n                 final IBinder callerActivityToken = operation.getActivityToken();\n                 final Intent activityIntent = operation.getActivityIntent();\n                 final Bundle activityOptions = operation.getBundle();\n+                final SafeActivityOptions safeOptions =\n+                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n                 final int result = mService.getActivityStartController()\n-                        .startActivityInTaskFragment(taskFragment, activityIntent, activityOptions,\n+                        .startActivityInTaskFragment(taskFragment, activityIntent, safeOptions,\n                                 callerActivityToken, caller.mUid, caller.mPid,\n                                 errorCallbackToken);\n                 if (!isStartResultSuccessful(result)) {\n",
                            "downstream_patch_tokens": {
                                "openai": 843,
                                "general": {
                                    "word_based": 350,
                                    "char_based": 906
                                },
                                "gemini": 1058
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "services/core/java/com/android/server/wm/WindowOrganizerController.java",
                                    "total_hunks": 1,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [],
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    },
                                    "rej_file_content": "```diff\n--- services/core/java/com/android/server/wm/WindowOrganizerController.java\n+++ services/core/java/com/android/server/wm/WindowOrganizerController.java\n@@ -1517,8 +1517,10 @@ class WindowOrganizerController extends IWindowOrganizerController.Stub\n                 final IBinder callerActivityToken = operation.getActivityToken();\n                 final Intent activityIntent = operation.getActivityIntent();\n                 final Bundle activityOptions = operation.getBundle();\n+                final SafeActivityOptions safeOptions =\n+                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n                 final int result = waitAsyncStart(() -> mService.getActivityStartController()\n-                        .startActivityInTaskFragment(taskFragment, activityIntent, activityOptions,\n+                        .startActivityInTaskFragment(taskFragment, activityIntent, safeOptions,\n                                 callerActivityToken, caller.mUid, caller.mPid,\n                                 errorCallbackToken));\n                 if (!isStartResultSuccessful(result)) {\n```",
                                    "rej_file_tokens": {
                                        "openai": 194,
                                        "general": {
                                            "word_based": 75,
                                            "char_based": 280
                                        },
                                        "gemini": 232
                                    },
                                    "patch_apply_output": "patching file services/core/java/com/android/server/wm/ActivityStartController.java\nHunk #2 succeeded at 528 (offset -21 lines).\npatching file services/core/java/com/android/server/wm/WindowOrganizerController.java\nHunk #1 FAILED at 1517.\n1 out of 1 hunk FAILED -- saving rejects to file services/core/java/com/android/server/wm/WindowOrganizerController.java.rej",
                                    "inline_merge_output": "patching file services/core/java/com/android/server/wm/WindowOrganizerController.java\nHunk #1 already applied at 1520-1521,1523.",
                                    "upstream_file_tokens": {
                                        "openai": 24982,
                                        "general": {
                                            "word_based": 9778,
                                            "char_based": 33936
                                        },
                                        "gemini": 29346
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2020 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.wm;\n\nimport static android.Manifest.permission.START_TASKS_FROM_RECENTS;\nimport static android.app.ActivityManager.isStartResultSuccessful;\nimport static android.app.WindowConfiguration.WINDOWING_MODE_UNDEFINED;\nimport static android.app.WindowConfiguration.WINDOW_CONFIG_BOUNDS;\nimport static android.view.Display.DEFAULT_DISPLAY;\nimport static android.window.TaskFragmentOperation.OP_TYPE_CLEAR_ADJACENT_TASK_FRAGMENTS;\nimport static android.window.TaskFragmentOperation.OP_TYPE_CREATE_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_DELETE_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_REPARENT_ACTIVITY_TO_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_REQUEST_FOCUS_ON_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_SET_ADJACENT_TASK_FRAGMENTS;\nimport static android.window.TaskFragmentOperation.OP_TYPE_SET_ANIMATION_PARAMS;\nimport static android.window.TaskFragmentOperation.OP_TYPE_SET_COMPANION_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_SET_RELATIVE_BOUNDS;\nimport static android.window.TaskFragmentOperation.OP_TYPE_START_ACTIVITY_IN_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_UNKNOWN;\nimport static android.window.WindowContainerTransaction.Change.CHANGE_RELATIVE_BOUNDS;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_ADD_INSETS_FRAME_PROVIDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_ADD_TASK_FRAGMENT_OPERATION;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_CHILDREN_TASKS_REPARENT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_CLEAR_ADJACENT_ROOTS;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_FINISH_ACTIVITY;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_LAUNCH_TASK;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_PENDING_INTENT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REMOVE_INSETS_FRAME_PROVIDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REMOVE_TASK;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REORDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REPARENT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_RESTORE_TRANSIENT_ORDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_ADJACENT_ROOTS;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_ALWAYS_ON_TOP;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_LAUNCH_ADJACENT_FLAG_ROOT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_LAUNCH_ROOT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_REPARENT_LEAF_TASK_IF_RELAUNCH;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_START_SHORTCUT;\n\nimport static com.android.internal.protolog.ProtoLogGroup.WM_DEBUG_WINDOW_ORGANIZER;\nimport static com.android.server.wm.ActivityTaskManagerService.enforceTaskPermission;\nimport static com.android.server.wm.ActivityTaskSupervisor.PRESERVE_WINDOWS;\nimport static com.android.server.wm.Task.FLAG_FORCE_HIDDEN_FOR_PINNED_TASK;\nimport static com.android.server.wm.Task.FLAG_FORCE_HIDDEN_FOR_TASK_ORG;\nimport static com.android.server.wm.TaskFragment.EMBEDDING_ALLOWED;\nimport static com.android.server.wm.WindowContainer.POSITION_BOTTOM;\nimport static com.android.server.wm.WindowContainer.POSITION_TOP;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.ActivityManager;\nimport android.app.ActivityOptions;\nimport android.app.WindowConfiguration;\nimport android.content.ActivityNotFoundException;\nimport android.content.Intent;\nimport android.content.pm.ActivityInfo;\nimport android.content.res.Configuration;\nimport android.graphics.Point;\nimport android.graphics.Rect;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Parcel;\nimport android.os.RemoteException;\nimport android.util.AndroidRuntimeException;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.Slog;\nimport android.view.RemoteAnimationAdapter;\nimport android.view.SurfaceControl;\nimport android.view.WindowManager;\nimport android.window.IDisplayAreaOrganizerController;\nimport android.window.ITaskFragmentOrganizer;\nimport android.window.ITaskFragmentOrganizerController;\nimport android.window.ITaskOrganizerController;\nimport android.window.ITransitionMetricsReporter;\nimport android.window.ITransitionPlayer;\nimport android.window.IWindowContainerTransactionCallback;\nimport android.window.IWindowOrganizerController;\nimport android.window.TaskFragmentAnimationParams;\nimport android.window.TaskFragmentCreationParams;\nimport android.window.TaskFragmentOperation;\nimport android.window.WindowContainerToken;\nimport android.window.WindowContainerTransaction;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.protolog.ProtoLogGroup;\nimport com.android.internal.protolog.common.ProtoLog;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.server.LocalServices;\nimport com.android.server.pm.LauncherAppsService.LauncherAppsServiceInternal;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.IntSupplier;\n\n/**\n * Server side implementation for the interface for organizing windows\n * @see android.window.WindowOrganizer\n */\nclass WindowOrganizerController extends IWindowOrganizerController.Stub\n        implements BLASTSyncEngine.TransactionReadyListener {\n\n    private static final String TAG = \"WindowOrganizerController\";\n\n    private static final int TRANSACT_EFFECTS_NONE = 0;\n    /** Flag indicating that an applied transaction may have effected lifecycle */\n    private static final int TRANSACT_EFFECTS_CLIENT_CONFIG = 1;\n    private static final int TRANSACT_EFFECTS_LIFECYCLE = 1 << 1;\n\n    /**\n     * Masks specifying which configurations task-organizers can control. Incoming transactions\n     * will be filtered to only include these.\n     */\n    static final int CONTROLLABLE_CONFIGS = ActivityInfo.CONFIG_WINDOW_CONFIGURATION\n            | ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE | ActivityInfo.CONFIG_SCREEN_SIZE\n            | ActivityInfo.CONFIG_LAYOUT_DIRECTION | ActivityInfo.CONFIG_DENSITY;\n    static final int CONTROLLABLE_WINDOW_CONFIGS = WINDOW_CONFIG_BOUNDS\n            | WindowConfiguration.WINDOW_CONFIG_APP_BOUNDS;\n\n    private final ActivityTaskManagerService mService;\n    private final WindowManagerGlobalLock mGlobalLock;\n\n    private final HashMap<Integer, IWindowContainerTransactionCallback>\n            mTransactionCallbacksByPendingSyncId = new HashMap();\n\n    final TaskOrganizerController mTaskOrganizerController;\n    final DisplayAreaOrganizerController mDisplayAreaOrganizerController;\n    final TaskFragmentOrganizerController mTaskFragmentOrganizerController;\n\n    final TransitionController mTransitionController;\n\n    /**\n     * A Map which manages the relationship between\n     * {@link TaskFragmentCreationParams#getFragmentToken()} and {@link TaskFragment}\n     */\n    @VisibleForTesting\n    final ArrayMap<IBinder, TaskFragment> mLaunchTaskFragments = new ArrayMap<>();\n\n    private final Rect mTmpBounds0 = new Rect();\n    private final Rect mTmpBounds1 = new Rect();\n\n    WindowOrganizerController(ActivityTaskManagerService atm) {\n        mService = atm;\n        mGlobalLock = atm.mGlobalLock;\n        mTaskOrganizerController = new TaskOrganizerController(mService);\n        mDisplayAreaOrganizerController = new DisplayAreaOrganizerController(mService);\n        mTaskFragmentOrganizerController = new TaskFragmentOrganizerController(atm, this);\n        mTransitionController = new TransitionController(atm);\n    }\n\n    TransitionController getTransitionController() {\n        return mTransitionController;\n    }\n\n    @Override\n    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)\n            throws RemoteException {\n        try {\n            return super.onTransact(code, data, reply, flags);\n        } catch (RuntimeException e) {\n            throw ActivityTaskManagerService.logAndRethrowRuntimeExceptionOnTransact(TAG, e);\n        }\n    }\n\n    @Override\n    public void applyTransaction(WindowContainerTransaction t) {\n        if (t == null) {\n            throw new IllegalArgumentException(\"Null transaction passed to applyTransaction\");\n        }\n        enforceTaskPermission(\"applyTransaction()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                applyTransaction(t, -1 /*syncId*/, null /*transition*/, caller);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public int applySyncTransaction(WindowContainerTransaction t,\n            IWindowContainerTransactionCallback callback) {\n        if (t == null) {\n            throw new IllegalArgumentException(\"Null transaction passed to applySyncTransaction\");\n        }\n        enforceTaskPermission(\"applySyncTransaction()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                if (callback == null) {\n                    applyTransaction(t, -1 /* syncId*/, null /*transition*/, caller);\n                    return -1;\n                }\n\n                /**\n                 * If callback is non-null we are looking to synchronize this transaction by\n                 * collecting all the results in to a SurfaceFlinger transaction and then delivering\n                 * that to the given transaction ready callback. See {@link BLASTSyncEngine} for the\n                 * details of the operation. But at a high level we create a sync operation with a\n                 * given ID and an associated callback. Then we notify each WindowContainer in this\n                 * WindowContainer transaction that it is participating in a sync operation with\n                 * that ID. Once everything is notified we tell the BLASTSyncEngine \"setSyncReady\"\n                 * which means that we have added everything to the set. At any point after this,\n                 * all the WindowContainers will eventually finish applying their changes and notify\n                 * the BLASTSyncEngine which will deliver the Transaction to the callback.\n                 */\n                final BLASTSyncEngine.SyncGroup syncGroup = prepareSyncWithOrganizer(callback);\n                final int syncId = syncGroup.mSyncId;\n                if (mTransitionController.isShellTransitionsEnabled()) {\n                    mTransitionController.startLegacySyncOrQueue(syncGroup, (deferred) -> {\n                        applyTransaction(t, syncId, null /* transition */, caller, deferred);\n                        setSyncReady(syncId);\n                    });\n                } else {\n                    if (!mService.mWindowManager.mSyncEngine.hasActiveSync()) {\n                        mService.mWindowManager.mSyncEngine.startSyncSet(syncGroup);\n                        applyTransaction(t, syncId, null /*transition*/, caller);\n                        setSyncReady(syncId);\n                    } else {\n                        // Because the BLAST engine only supports one sync at a time, queue the\n                        // transaction.\n                        mService.mWindowManager.mSyncEngine.queueSyncSet(\n                                () -> mService.mWindowManager.mSyncEngine.startSyncSet(syncGroup),\n                                () -> {\n                                    applyTransaction(t, syncId, null /*transition*/, caller);\n                                    setSyncReady(syncId);\n                                });\n                    }\n                }\n                return syncId;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public IBinder startNewTransition(int type, @Nullable WindowContainerTransaction t) {\n        return startTransition(type, null /* transitionToken */, t);\n    }\n\n    @Override\n    public void startTransition(@NonNull IBinder transitionToken,\n            @Nullable WindowContainerTransaction t) {\n        startTransition(-1 /* unused type */, transitionToken, t);\n    }\n\n    private IBinder startTransition(@WindowManager.TransitionType int type,\n            @Nullable IBinder transitionToken, @Nullable WindowContainerTransaction t) {\n        enforceTaskPermission(\"startTransition()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                Transition transition = Transition.fromBinder(transitionToken);\n                if (mTransitionController.getTransitionPlayer() == null && transition == null) {\n                    Slog.w(TAG, \"Using shell transitions API for legacy transitions.\");\n                    if (t == null) {\n                        throw new IllegalArgumentException(\"Can't use legacy transitions in\"\n                                + \" compatibility mode with no WCT.\");\n                    }\n                    applyTransaction(t, -1 /* syncId */, null, caller);\n                    return null;\n                }\n                final WindowContainerTransaction wct =\n                        t != null ? t : new WindowContainerTransaction();\n                if (transition == null) {\n                    if (type < 0) {\n                        throw new IllegalArgumentException(\"Can't create transition with no type\");\n                    }\n                    // This is a direct call from shell, so the entire transition lifecycle is\n                    // contained in the provided transaction if provided. Thus, we can setReady\n                    // immediately after apply.\n                    final boolean needsSetReady = t != null;\n                    final Transition nextTransition = new Transition(type, 0 /* flags */,\n                            mTransitionController, mService.mWindowManager.mSyncEngine);\n                    nextTransition.calcParallelCollectType(wct);\n                    mTransitionController.startCollectOrQueue(nextTransition,\n                            (deferred) -> {\n                                nextTransition.start();\n                                nextTransition.mLogger.mStartWCT = wct;\n                                applyTransaction(wct, -1 /* syncId */, nextTransition, caller,\n                                        deferred);\n                                if (needsSetReady) {\n                                    nextTransition.setAllReady();\n                                }\n                            });\n                    return nextTransition.getToken();\n                }\n                // The transition already started collecting before sending a request to shell,\n                // so just start here.\n                if (!transition.isCollecting() && !transition.isForcePlaying()) {\n                    Slog.e(TAG, \"Trying to start a transition that isn't collecting. This probably\"\n                            + \" means Shell took too long to respond to a request. WM State may be\"\n                            + \" incorrect now, please file a bug\");\n                    applyTransaction(wct, -1 /*syncId*/, null /*transition*/, caller);\n                    return transition.getToken();\n                }\n                transition.start();\n                transition.mLogger.mStartWCT = wct;\n                applyTransaction(wct, -1 /*syncId*/, transition, caller);\n                // Since the transition is already provided, it means WMCore is determining the\n                // \"readiness lifecycle\" outside the provided transaction, so don't set ready here.\n                return transition.getToken();\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public int startLegacyTransition(int type, @NonNull RemoteAnimationAdapter adapter,\n            @NonNull IWindowContainerTransactionCallback callback,\n            @NonNull WindowContainerTransaction t) {\n        enforceTaskPermission(\"startLegacyTransition()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        int syncId;\n        try {\n            synchronized (mGlobalLock) {\n                if (type < 0) {\n                    throw new IllegalArgumentException(\"Can't create transition with no type\");\n                }\n                if (mTransitionController.getTransitionPlayer() != null) {\n                    throw new IllegalArgumentException(\"Can't use legacy transitions in\"\n                            + \" when shell transitions are enabled.\");\n                }\n                final DisplayContent dc =\n                        mService.mRootWindowContainer.getDisplayContent(DEFAULT_DISPLAY);\n                if (dc.mAppTransition.isTransitionSet()) {\n                    // a transition already exists, so the callback probably won't be called.\n                    return -1;\n                }\n                adapter.setCallingPidUid(caller.mPid, caller.mUid);\n                dc.prepareAppTransition(type);\n                dc.mAppTransition.overridePendingAppTransitionRemote(adapter, true /* sync */,\n                        false /* isActivityEmbedding */);\n                syncId = startSyncWithOrganizer(callback);\n                applyTransaction(t, syncId, null /* transition */, caller);\n                setSyncReady(syncId);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n        return syncId;\n    }\n\n    @Override\n    public int finishTransition(@NonNull IBinder transitionToken,\n            @Nullable WindowContainerTransaction t,\n            @Nullable IWindowContainerTransactionCallback callback) {\n        enforceTaskPermission(\"finishTransition()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                int syncId = -1;\n                if (t != null && callback != null) {\n                    syncId = startSyncWithOrganizer(callback);\n                }\n                final Transition transition = Transition.fromBinder(transitionToken);\n                // apply the incoming transaction before finish in case it alters the visibility\n                // of the participants.\n                if (t != null) {\n                    // Set the finishing transition before applyTransaction so the visibility\n                    // changes of the transition participants will only set visible-requested\n                    // and still let finishTransition handle the participants.\n                    mTransitionController.mFinishingTransition = transition;\n                    applyTransaction(t, syncId, null /*transition*/, caller, transition);\n                }\n                mTransitionController.finishTransition(transition);\n                mTransitionController.mFinishingTransition = null;\n                if (syncId >= 0) {\n                    setSyncReady(syncId);\n                }\n                return syncId;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    /**\n     * Applies the {@link WindowContainerTransaction} as a request from\n     * {@link android.window.TaskFragmentOrganizer}.\n     *\n     * @param wct   {@link WindowContainerTransaction} to apply.\n     * @param type  {@link WindowManager.TransitionType} if it needs to start a new transition.\n     * @param shouldApplyIndependently  If {@code true}, the {@code wct} will request a new\n     *                                  transition, which will be queued until the sync engine is\n     *                                  free if there is any other active sync. If {@code false},\n     *                                  the {@code wct} will be directly applied to the active sync.\n     */\n    void applyTaskFragmentTransactionLocked(@NonNull WindowContainerTransaction wct,\n            @WindowManager.TransitionType int type, boolean shouldApplyIndependently) {\n        enforceTaskFragmentOrganizerPermission(\"applyTaskFragmentTransaction()\",\n                Objects.requireNonNull(wct.getTaskFragmentOrganizer()),\n                Objects.requireNonNull(wct));\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            if (mTransitionController.getTransitionPlayer() == null) {\n                // No need to worry about transition when Shell transition is not enabled.\n                applyTransaction(wct, -1 /* syncId */, null /* transition */, caller);\n                return;\n            }\n\n            if (mService.mWindowManager.mSyncEngine.hasActiveSync()\n                    && !shouldApplyIndependently) {\n                // Although there is an active sync, we want to apply the transaction now.\n                // TODO(b/232042367) Redesign the organizer update on activity callback so that we\n                // we will know about the transition explicitly.\n                final Transition transition = mTransitionController.getCollectingTransition();\n                if (transition == null) {\n                    // This should rarely happen, and we should try to avoid using\n                    // {@link #applySyncTransaction} with Shell transition.\n                    // We still want to apply and merge the transaction to the active sync\n                    // because {@code shouldApplyIndependently} is {@code false}.\n                    ProtoLog.w(ProtoLogGroup.WM_DEBUG_WINDOW_TRANSITIONS,\n                            \"TaskFragmentTransaction changes are not collected in transition\"\n                                    + \" because there is an ongoing sync for\"\n                                    + \" applySyncTransaction().\");\n                }\n                applyTransaction(wct, -1 /* syncId */, transition, caller);\n                return;\n            }\n\n            final Transition transition = new Transition(type, 0 /* flags */,\n                    mTransitionController, mService.mWindowManager.mSyncEngine);\n            TransitionController.OnStartCollect doApply = (deferred) -> {\n                if (deferred && !mTaskFragmentOrganizerController.isValidTransaction(wct)) {\n                    transition.abort();\n                    return;\n                }\n                if (applyTransaction(wct, -1 /* syncId */, transition, caller, deferred)\n                        == TRANSACT_EFFECTS_NONE && transition.mParticipants.isEmpty()) {\n                    transition.abort();\n                    return;\n                }\n                mTransitionController.requestStartTransition(transition, null /* startTask */,\n                        null /* remoteTransition */, null /* displayChange */);\n                transition.setAllReady();\n            };\n            mTransitionController.startCollectOrQueue(transition, doApply);\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    private int applyTransaction(@NonNull WindowContainerTransaction t, int syncId,\n            @Nullable Transition transition, @NonNull CallerInfo caller) {\n        return applyTransaction(t, syncId, transition, caller, null /* finishTransition */);\n    }\n\n    private int applyTransaction(@NonNull WindowContainerTransaction t, int syncId,\n            @Nullable Transition transition, @NonNull CallerInfo caller, boolean deferred) {\n        if (deferred) {\n            try {\n                return applyTransaction(t, syncId, transition, caller);\n            } catch (RuntimeException e) {\n                // If the transaction is deferred, the caller could be from TransitionController\n                // #tryStartCollectFromQueue that executes on system's worker thread rather than\n                // binder thread. And the operation in the WCT may be outdated that violates the\n                // current state. So catch the exception to avoid crashing the system.\n                Slog.e(TAG, \"Failed to execute deferred applyTransaction\", e);\n            }\n            return TRANSACT_EFFECTS_NONE;\n        }\n        return applyTransaction(t, syncId, transition, caller);\n    }\n\n    /**\n     * @param syncId If non-null, this will be a sync-transaction.\n     * @param transition A transition to collect changes into.\n     * @param caller Info about the calling process.\n     * @param finishTransition The transition that is currently being finished.\n     * @return The effects of the window container transaction.\n     */\n    private int applyTransaction(@NonNull WindowContainerTransaction t, int syncId,\n            @Nullable Transition transition, @NonNull CallerInfo caller,\n            @Nullable Transition finishTransition) {\n        int effects = TRANSACT_EFFECTS_NONE;\n        ProtoLog.v(WM_DEBUG_WINDOW_ORGANIZER, \"Apply window transaction, syncId=%d\", syncId);\n        mService.deferWindowLayout();\n        mService.mTaskSupervisor.setDeferRootVisibilityUpdate(true /* deferUpdate */);\n        try {\n            if (transition != null) {\n                transition.applyDisplayChangeIfNeeded();\n            }\n            final List<WindowContainerTransaction.HierarchyOp> hops = t.getHierarchyOps();\n            final int hopSize = hops.size();\n            final ArraySet<WindowContainer<?>> haveConfigChanges = new ArraySet<>();\n            Iterator<Map.Entry<IBinder, WindowContainerTransaction.Change>> entries =\n                    t.getChanges().entrySet().iterator();\n            while (entries.hasNext()) {\n                final Map.Entry<IBinder, WindowContainerTransaction.Change> entry = entries.next();\n                final WindowContainer wc = WindowContainer.fromBinder(entry.getKey());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on detached container: \" + wc);\n                    continue;\n                }\n                // Make sure we add to the syncSet before performing\n                // operations so we don't end up splitting effects between the WM\n                // pending transaction and the BLASTSync transaction.\n                if (syncId >= 0) {\n                    addToSyncSet(syncId, wc);\n                }\n                if (transition != null) transition.collect(wc);\n\n                if ((entry.getValue().getChangeMask()\n                        & WindowContainerTransaction.Change.CHANGE_FORCE_NO_PIP) != 0) {\n                    // Disable entering pip (eg. when recents pretends to finish itself)\n                    if (finishTransition != null) {\n                        finishTransition.setCanPipOnFinish(false /* canPipOnFinish */);\n                    } else if (transition != null) {\n                        transition.setCanPipOnFinish(false /* canPipOnFinish */);\n                    }\n                }\n                // A bit hacky, but we need to detect \"remove PiP\" so that we can \"wrap\" the\n                // setWindowingMode call in force-hidden.\n                boolean forceHiddenForPip = false;\n                if (wc.asTask() != null && wc.inPinnedWindowingMode()\n                        && entry.getValue().getWindowingMode() == WINDOWING_MODE_UNDEFINED) {\n                    // We are in pip and going to undefined. Now search hierarchy ops to determine\n                    // whether we are removing pip or expanding pip.\n                    for (int i = 0; i < hopSize; ++i) {\n                        final WindowContainerTransaction.HierarchyOp hop = hops.get(i);\n                        if (hop.getType() != HIERARCHY_OP_TYPE_REORDER) continue;\n                        final WindowContainer hopWc = WindowContainer.fromBinder(\n                                hop.getContainer());\n                        if (!wc.equals(hopWc)) continue;\n                        forceHiddenForPip = !hop.getToTop();\n                    }\n                }\n                if (forceHiddenForPip) {\n                    wc.asTask().setForceHidden(FLAG_FORCE_HIDDEN_FOR_PINNED_TASK, true /* set */);\n                    // When removing pip, make sure that onStop is sent to the app ahead of\n                    // onPictureInPictureModeChanged.\n                    // See also PinnedStackTests#testStopBeforeMultiWindowCallbacksOnDismiss\n                    wc.asTask().ensureActivitiesVisible(null, 0, PRESERVE_WINDOWS);\n                    wc.asTask().mTaskSupervisor.processStoppingAndFinishingActivities(\n                            null /* launchedActivity */, false /* processPausingActivities */,\n                            \"force-stop-on-removing-pip\");\n                }\n\n                int containerEffect = applyWindowContainerChange(wc, entry.getValue(),\n                        t.getErrorCallbackToken());\n                effects |= containerEffect;\n\n                if (forceHiddenForPip) {\n                    wc.asTask().setForceHidden(FLAG_FORCE_HIDDEN_FOR_PINNED_TASK, false /* set */);\n                }\n\n                // Lifecycle changes will trigger ensureConfig for everything.\n                if ((effects & TRANSACT_EFFECTS_LIFECYCLE) == 0\n                        && (containerEffect & TRANSACT_EFFECTS_CLIENT_CONFIG) != 0) {\n                    haveConfigChanges.add(wc);\n                }\n            }\n            // Hierarchy changes\n            if (hopSize > 0) {\n                final boolean isInLockTaskMode = mService.isInLockTaskMode();\n                for (int i = 0; i < hopSize; ++i) {\n                    effects |= applyHierarchyOp(hops.get(i), effects, syncId, transition,\n                            isInLockTaskMode, caller, t.getErrorCallbackToken(),\n                            t.getTaskFragmentOrganizer(), finishTransition);\n                }\n            }\n            // Queue-up bounds-change transactions for tasks which are now organized. Do\n            // this after hierarchy ops so we have the final organized state.\n            entries = t.getChanges().entrySet().iterator();\n            while (entries.hasNext()) {\n                final Map.Entry<IBinder, WindowContainerTransaction.Change> entry = entries.next();\n                final WindowContainer wc = WindowContainer.fromBinder(entry.getKey());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on detached container: \" + wc);\n                    continue;\n                }\n                final Task task = wc.asTask();\n                final Rect surfaceBounds = entry.getValue().getBoundsChangeSurfaceBounds();\n                if (task == null || !task.isAttached() || surfaceBounds == null) {\n                    continue;\n                }\n                if (!task.isOrganized()) {\n                    final Task parent = task.getParent() != null ? task.getParent().asTask() : null;\n                    // Also allow direct children of created-by-organizer tasks to be\n                    // controlled. In the future, these will become organized anyways.\n                    if (parent == null || !parent.mCreatedByOrganizer) {\n                        throw new IllegalArgumentException(\n                                \"Can't manipulate non-organized task surface \" + task);\n                    }\n                }\n                final SurfaceControl.Transaction sft = new SurfaceControl.Transaction();\n                final SurfaceControl sc = task.getSurfaceControl();\n                sft.setPosition(sc, surfaceBounds.left, surfaceBounds.top);\n                if (surfaceBounds.isEmpty()) {\n                    sft.setWindowCrop(sc, null);\n                } else {\n                    sft.setWindowCrop(sc, surfaceBounds.width(), surfaceBounds.height());\n                }\n                task.setMainWindowSizeChangeTransaction(sft);\n            }\n            if ((effects & TRANSACT_EFFECTS_LIFECYCLE) != 0) {\n                mService.mTaskSupervisor.setDeferRootVisibilityUpdate(false /* deferUpdate */);\n                // Already calls ensureActivityConfig\n                mService.mRootWindowContainer.ensureActivitiesVisible(null, 0, PRESERVE_WINDOWS);\n                mService.mRootWindowContainer.resumeFocusedTasksTopActivities();\n            } else if ((effects & TRANSACT_EFFECTS_CLIENT_CONFIG) != 0) {\n                for (int i = haveConfigChanges.size() - 1; i >= 0; --i) {\n                    haveConfigChanges.valueAt(i).forAllActivities(r -> {\n                        r.ensureActivityConfiguration(0, PRESERVE_WINDOWS);\n                    });\n                }\n            }\n\n            if (effects != 0) {\n                mService.mWindowManager.mWindowPlacerLocked.requestTraversal();\n            }\n        } finally {\n            mService.mTaskSupervisor.setDeferRootVisibilityUpdate(false /* deferUpdate */);\n            mService.continueWindowLayout();\n        }\n        return effects;\n    }\n\n    private int applyChanges(@NonNull WindowContainer<?> container,\n            @NonNull WindowContainerTransaction.Change change) {\n        // The \"client\"-facing API should prevent bad changes; however, just in case, sanitize\n        // masks here.\n        final int configMask = change.getConfigSetMask() & CONTROLLABLE_CONFIGS;\n        final int windowMask = change.getWindowSetMask() & CONTROLLABLE_WINDOW_CONFIGS;\n        int effects = TRANSACT_EFFECTS_NONE;\n        final int windowingMode = change.getWindowingMode();\n        if (configMask != 0) {\n            if (windowingMode > -1 && windowingMode != container.getWindowingMode()) {\n                // Special handling for when we are setting a windowingMode in the same transaction.\n                // Setting the windowingMode is going to call onConfigurationChanged so we don't\n                // need it called right now. Additionally, some logic requires everything in the\n                // configuration to change at the same time (ie. surface-freezer requires bounds\n                // and mode to change at the same time).\n                final Configuration c = container.getRequestedOverrideConfiguration();\n                c.setTo(change.getConfiguration(), configMask, windowMask);\n            } else {\n                final Configuration c =\n                        new Configuration(container.getRequestedOverrideConfiguration());\n                c.setTo(change.getConfiguration(), configMask, windowMask);\n                container.onRequestedOverrideConfigurationChanged(c);\n            }\n            effects |= TRANSACT_EFFECTS_CLIENT_CONFIG;\n            if (windowMask != 0 && container.isEmbedded()) {\n                // Changing bounds of the embedded TaskFragments may result in lifecycle changes.\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n        if ((change.getChangeMask() & WindowContainerTransaction.Change.CHANGE_FOCUSABLE) != 0) {\n            if (container.setFocusable(change.getFocusable())) {\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n\n        if (windowingMode > -1) {\n            if (mService.isInLockTaskMode()\n                    && WindowConfiguration.inMultiWindowMode(windowingMode)) {\n                Slog.w(TAG, \"Dropping unsupported request to set multi-window windowing mode\"\n                        + \" during locked task mode.\");\n                return effects;\n            }\n\n            if (windowingMode == WindowConfiguration.WINDOWING_MODE_PINNED) {\n                // Do not directly put the container into PINNED mode as it may not support it or\n                // the app may not want to enter it. Instead, send a signal to request PIP\n                // mode to the app if they wish to support it below in #applyTaskChanges.\n                return effects;\n            }\n\n            final int prevMode = container.getRequestedOverrideWindowingMode();\n            container.setWindowingMode(windowingMode);\n            if (prevMode != container.getWindowingMode()) {\n                // The activity in the container may become focusable or non-focusable due to\n                // windowing modes changes (such as entering or leaving pinned windowing mode),\n                // so also apply the lifecycle effects to this transaction.\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n        return effects;\n    }\n\n    private int applyTaskChanges(Task tr, WindowContainerTransaction.Change c) {\n        int effects = applyChanges(tr, c);\n        final SurfaceControl.Transaction t = c.getBoundsChangeTransaction();\n\n        if ((c.getChangeMask() & WindowContainerTransaction.Change.CHANGE_HIDDEN) != 0) {\n            if (tr.setForceHidden(FLAG_FORCE_HIDDEN_FOR_TASK_ORG, c.getHidden())) {\n                effects = TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n\n        if ((c.getChangeMask()\n                & WindowContainerTransaction.Change.CHANGE_FORCE_TRANSLUCENT) != 0) {\n            tr.setForceTranslucent(c.getForceTranslucent());\n            effects = TRANSACT_EFFECTS_LIFECYCLE;\n        }\n\n        if ((c.getChangeMask() & WindowContainerTransaction.Change.CHANGE_DRAG_RESIZING) != 0) {\n            tr.setDragResizing(c.getDragResizing());\n        }\n\n        final int childWindowingMode = c.getActivityWindowingMode();\n        if (childWindowingMode > -1) {\n            tr.forAllActivities(a -> { a.setWindowingMode(childWindowingMode); });\n        }\n\n        if (t != null) {\n            tr.setMainWindowSizeChangeTransaction(t);\n        }\n\n        Rect enterPipBounds = c.getEnterPipBounds();\n        if (enterPipBounds != null) {\n            tr.mDisplayContent.mPinnedTaskController.setEnterPipBounds(enterPipBounds);\n        }\n\n        if (c.getWindowingMode() == WindowConfiguration.WINDOWING_MODE_PINNED\n                && !tr.inPinnedWindowingMode()) {\n            final ActivityRecord activity = tr.getTopNonFinishingActivity();\n            if (activity != null) {\n                final boolean lastSupportsEnterPipOnTaskSwitch =\n                        activity.supportsEnterPipOnTaskSwitch;\n                // Temporarily force enable enter PIP on task switch so that PIP is requested\n                // regardless of whether the activity is resumed or paused.\n                activity.supportsEnterPipOnTaskSwitch = true;\n                boolean canEnterPip = activity.checkEnterPictureInPictureState(\n                        \"applyTaskChanges\", true /* beforeStopping */);\n                if (canEnterPip) {\n                    canEnterPip = mService.mActivityClientController\n                            .requestPictureInPictureMode(activity);\n                }\n                if (!canEnterPip) {\n                    // Restore the flag to its previous state when the activity cannot enter PIP.\n                    activity.supportsEnterPipOnTaskSwitch = lastSupportsEnterPipOnTaskSwitch;\n                }\n            }\n        }\n\n        return effects;\n    }\n\n    private int applyDisplayAreaChanges(DisplayArea displayArea,\n            WindowContainerTransaction.Change c) {\n        final int[] effects = new int[1];\n        effects[0] = applyChanges(displayArea, c);\n\n        if ((c.getChangeMask()\n                & WindowContainerTransaction.Change.CHANGE_IGNORE_ORIENTATION_REQUEST) != 0) {\n            if (displayArea.setIgnoreOrientationRequest(c.getIgnoreOrientationRequest())) {\n                effects[0] |= TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n\n        displayArea.forAllTasks(task -> {\n            Task tr = (Task) task;\n            if ((c.getChangeMask() & WindowContainerTransaction.Change.CHANGE_HIDDEN) != 0) {\n                if (tr.setForceHidden(FLAG_FORCE_HIDDEN_FOR_TASK_ORG, c.getHidden())) {\n                    effects[0] |= TRANSACT_EFFECTS_LIFECYCLE;\n                }\n            }\n        });\n\n        return effects[0];\n    }\n\n    private int applyTaskFragmentChanges(@NonNull TaskFragment taskFragment,\n            @NonNull WindowContainerTransaction.Change c, @Nullable IBinder errorCallbackToken) {\n        if (taskFragment.isEmbeddedTaskFragmentInPip()) {\n            // No override from organizer for embedded TaskFragment in a PIP Task.\n            return TRANSACT_EFFECTS_NONE;\n        }\n\n        // When the TaskFragment is resized, we may want to create a change transition for it, for\n        // which we want to defer the surface update until we determine whether or not to start\n        // change transition.\n        mTmpBounds0.set(taskFragment.getBounds());\n        mTmpBounds1.set(taskFragment.getRelativeEmbeddedBounds());\n        taskFragment.deferOrganizedTaskFragmentSurfaceUpdate();\n        final Rect relBounds = c.getRelativeBounds();\n        if (relBounds != null) {\n            // Make sure the requested bounds satisfied the min dimensions requirement.\n            adjustTaskFragmentRelativeBoundsForMinDimensionsIfNeeded(taskFragment, relBounds,\n                    errorCallbackToken);\n\n            // For embedded TaskFragment, the organizer set the bounds in parent coordinate to\n            // prevent flicker in case there is a racing condition between the parent bounds changed\n            // and the organizer request.\n            final Rect parentBounds = taskFragment.getParent().getBounds();\n            // Convert relative bounds to screen space.\n            final Rect absBounds = taskFragment.translateRelativeBoundsToAbsoluteBounds(relBounds,\n                    parentBounds);\n            c.getConfiguration().windowConfiguration.setBounds(absBounds);\n            taskFragment.setRelativeEmbeddedBounds(relBounds);\n        }\n        final int effects = applyChanges(taskFragment, c);\n        if (taskFragment.shouldStartChangeTransition(mTmpBounds0, mTmpBounds1)) {\n            taskFragment.initializeChangeTransition(mTmpBounds0);\n        }\n        taskFragment.continueOrganizedTaskFragmentSurfaceUpdate();\n        return effects;\n    }\n\n    /**\n     * Adjusts the requested relative bounds on {@link TaskFragment} to make sure it satisfies the\n     * activity min dimensions.\n     */\n    private void adjustTaskFragmentRelativeBoundsForMinDimensionsIfNeeded(\n            @NonNull TaskFragment taskFragment, @NonNull Rect inOutRelativeBounds,\n            @Nullable IBinder errorCallbackToken) {\n        if (inOutRelativeBounds.isEmpty()) {\n            return;\n        }\n        final Point minDimensions = taskFragment.calculateMinDimension();\n        if (inOutRelativeBounds.width() < minDimensions.x\n                || inOutRelativeBounds.height() < minDimensions.y) {\n            // Notify organizer about the request failure.\n            final Throwable exception = new SecurityException(\"The requested relative bounds:\"\n                    + inOutRelativeBounds + \" does not satisfy minimum dimensions:\"\n                    + minDimensions);\n            sendTaskFragmentOperationFailure(taskFragment.getTaskFragmentOrganizer(),\n                    errorCallbackToken, taskFragment, OP_TYPE_SET_RELATIVE_BOUNDS, exception);\n\n            // Reset to match parent bounds.\n            inOutRelativeBounds.setEmpty();\n        }\n    }\n\n    private int applyHierarchyOp(WindowContainerTransaction.HierarchyOp hop, int effects,\n            int syncId, @Nullable Transition transition, boolean isInLockTaskMode,\n            @NonNull CallerInfo caller, @Nullable IBinder errorCallbackToken,\n            @Nullable ITaskFragmentOrganizer organizer, @Nullable Transition finishTransition) {\n        final int type = hop.getType();\n        switch (type) {\n            case HIERARCHY_OP_TYPE_REMOVE_TASK: {\n                final WindowContainer wc = WindowContainer.fromBinder(hop.getContainer());\n                if (wc == null || wc.asTask() == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to remove invalid task: \" + wc);\n                    break;\n                }\n                final Task task = wc.asTask();\n                task.remove(true, \"Applying remove task Hierarchy Op\");\n                break;\n            }\n            case HIERARCHY_OP_TYPE_SET_LAUNCH_ROOT: {\n                final WindowContainer wc = WindowContainer.fromBinder(hop.getContainer());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to set launch root to a detached container: \" + wc);\n                    break;\n                }\n                final Task task = wc.asTask();\n                if (task == null) {\n                    throw new IllegalArgumentException(\"Cannot set non-task as launch root: \" + wc);\n                } else if (task.getTaskDisplayArea() == null) {\n                    throw new IllegalArgumentException(\"Cannot set a task without display area as \"\n                            + \"launch root: \" + wc);\n                } else {\n                    task.getDisplayArea().setLaunchRootTask(task,\n                            hop.getWindowingModes(), hop.getActivityTypes());\n                }\n                break;\n            }\n            case HIERARCHY_OP_TYPE_SET_LAUNCH_ADJACENT_FLAG_ROOT: {\n                final WindowContainer wc = WindowContainer.fromBinder(hop.getContainer());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to set launch adjacent to a detached container: \" + wc);\n                    break;\n                }\n                final Task task = wc.asTask();\n                final boolean clearRoot = hop.getToTop();\n                if (task == null) {\n                    throw new IllegalArgumentException(\"Cannot set non-task as launch root: \" + wc);\n                } else if (!task.mCreatedByOrganizer) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot set non-organized task as adjacent flag root: \" + wc);\n                } else if (task.getAdjacentTaskFragment() == null && !clearRoot) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot set non-adjacent task as adjacent flag root: \" + wc);\n                }\n\n                task.getDisplayArea().setLaunchAdjacentFlagRootTask(clearRoot ? null : task);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_SET_ADJACENT_ROOTS: {\n                effects |= setAdjacentRootsHierarchyOp(hop);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_CLEAR_ADJACENT_ROOTS: {\n                effects |= clearAdjacentRootsHierarchyOp(hop);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_CHILDREN_TASKS_REPARENT: {\n                effects |= reparentChildrenTasksHierarchyOp(hop, transition, syncId,\n                        isInLockTaskMode);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_FINISH_ACTIVITY: {\n                final ActivityRecord activity = ActivityRecord.forTokenLocked(hop.getContainer());\n                if (activity == null || activity.finishing) {\n                    break;\n                }\n                if (activity.isVisible() || activity.isVisibleRequested()) {\n                    // Prevent the transition from being executed too early if the activity is\n                    // visible.\n                    activity.finishIfPossible(\"finish-activity-op\", false /* oomAdj */);\n                } else {\n                    activity.destroyIfPossible(\"finish-activity-op\");\n                }\n                break;\n            }\n            case HIERARCHY_OP_TYPE_LAUNCH_TASK: {\n                mService.mAmInternal.enforceCallingPermission(START_TASKS_FROM_RECENTS,\n                        \"launchTask HierarchyOp\");\n                final Bundle launchOpts = hop.getLaunchOptions();\n                final int taskId = launchOpts.getInt(\n                        WindowContainerTransaction.HierarchyOp.LAUNCH_KEY_TASK_ID);\n                launchOpts.remove(WindowContainerTransaction.HierarchyOp.LAUNCH_KEY_TASK_ID);\n                final SafeActivityOptions safeOptions =\n                        SafeActivityOptions.fromBundle(launchOpts, caller.mPid, caller.mUid);\n                waitAsyncStart(() -> mService.mTaskSupervisor.startActivityFromRecents(\n                        caller.mPid, caller.mUid, taskId, safeOptions));\n                break;\n            }\n            case HIERARCHY_OP_TYPE_REORDER:\n            case HIERARCHY_OP_TYPE_REPARENT: {\n                final WindowContainer wc = WindowContainer.fromBinder(hop.getContainer());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on detached container: \" + wc);\n                    break;\n                }\n                // There is no use case to ask the reparent operation in lock-task mode now, so keep\n                // skipping this operation as usual.\n                if (isInLockTaskMode && type == HIERARCHY_OP_TYPE_REPARENT) {\n                    Slog.w(TAG, \"Skip applying hierarchy operation \" + hop\n                            + \" while in lock task mode\");\n                    break;\n                }\n                if (isLockTaskModeViolation(wc.getParent(), wc.asTask(), isInLockTaskMode)) {\n                    break;\n                }\n                if (syncId >= 0) {\n                    addToSyncSet(syncId, wc);\n                }\n                if (transition != null) {\n                    transition.collect(wc);\n                    if (hop.isReparent()) {\n                        if (wc.getParent() != null) {\n                            // Collect the current parent. It's visibility may change as\n                            // a result of this reparenting.\n                            transition.collect(wc.getParent());\n                        }\n                        if (hop.getNewParent() != null) {\n                            final WindowContainer parentWc =\n                                    WindowContainer.fromBinder(hop.getNewParent());\n                            if (parentWc == null) {\n                                Slog.e(TAG, \"Can't resolve parent window from token\");\n                                break;\n                            }\n                            transition.collect(parentWc);\n                        }\n                    }\n                }\n                effects |= sanitizeAndApplyHierarchyOp(wc, hop);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_ADD_TASK_FRAGMENT_OPERATION: {\n                effects |= applyTaskFragmentOperation(hop, transition, isInLockTaskMode, caller,\n                        errorCallbackToken, organizer);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_PENDING_INTENT: {\n                final Bundle launchOpts = hop.getLaunchOptions();\n                ActivityOptions activityOptions = launchOpts != null\n                        ? new ActivityOptions(launchOpts) : null;\n                if (activityOptions != null && activityOptions.getTransientLaunch()\n                        && mService.isCallerRecents(hop.getPendingIntent().getCreatorUid())) {\n                    if (mService.getActivityStartController().startExistingRecentsIfPossible(\n                            hop.getActivityIntent(), activityOptions)) {\n                        // Start recents successfully.\n                        break;\n                    }\n                }\n\n                String resolvedType = hop.getActivityIntent() != null\n                        ? hop.getActivityIntent().resolveTypeIfNeeded(\n                        mService.mContext.getContentResolver())\n                        : null;\n\n                if (hop.getPendingIntent().isActivity()) {\n                    // Set the context display id as preferred for this activity launches, so that\n                    // it can land on caller's display. Or just brought the task to front at the\n                    // display where it was on since it has higher preference.\n                    if (activityOptions == null) {\n                        activityOptions = ActivityOptions.makeBasic();\n                    }\n                    activityOptions.setCallerDisplayId(DEFAULT_DISPLAY);\n                }\n                final Bundle options = activityOptions != null ? activityOptions.toBundle() : null;\n                int res = waitAsyncStart(() -> mService.mAmInternal.sendIntentSender(\n                        hop.getPendingIntent().getTarget(),\n                        hop.getPendingIntent().getWhitelistToken(), 0 /* code */,\n                        hop.getActivityIntent(), resolvedType, null /* finishReceiver */,\n                        null /* requiredPermission */, options));\n                if (ActivityManager.isStartResultSuccessful(res)) {\n                    effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                }\n                break;\n            }\n            default: {\n                // The other operations may change task order so they are skipped while in lock\n                // task mode. The above operations are still allowed because they don't move\n                // tasks. And it may be necessary such as clearing launch root after entering\n                // lock task mode.\n                if (isInLockTaskMode) {\n                    Slog.w(TAG, \"Skip applying hierarchy operation \" + hop\n                            + \" while in lock task mode\");\n                    return effects;\n                }\n            }\n        }\n\n        switch (type) {\n            case HIERARCHY_OP_TYPE_START_SHORTCUT: {\n                final Bundle launchOpts = hop.getLaunchOptions();\n                final String callingPackage = launchOpts.getString(\n                        WindowContainerTransaction.HierarchyOp.LAUNCH_KEY_SHORTCUT_CALLING_PACKAGE);\n                launchOpts.remove(\n                        WindowContainerTransaction.HierarchyOp.LAUNCH_KEY_SHORTCUT_CALLING_PACKAGE);\n\n                final LauncherAppsServiceInternal launcherApps = LocalServices.getService(\n                        LauncherAppsServiceInternal.class);\n\n                final boolean success = launcherApps.startShortcut(caller.mUid, caller.mPid,\n                        callingPackage, hop.getShortcutInfo().getPackage(), null /* featureId */,\n                        hop.getShortcutInfo().getId(), null /* sourceBounds */, launchOpts,\n                        hop.getShortcutInfo().getUserId());\n                if (success) {\n                    effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                }\n                break;\n            }\n            case HIERARCHY_OP_TYPE_RESTORE_TRANSIENT_ORDER: {\n                if (finishTransition == null) break;\n                final WindowContainer container = WindowContainer.fromBinder(hop.getContainer());\n                if (container == null) break;\n                final Task thisTask = container.asActivityRecord() != null\n                        ? container.asActivityRecord().getTask() : container.asTask();\n                if (thisTask == null) break;\n                final Task restoreAt = finishTransition.getTransientLaunchRestoreTarget(container);\n                if (restoreAt == null) break;\n                final TaskDisplayArea taskDisplayArea = thisTask.getTaskDisplayArea();\n                taskDisplayArea.moveRootTaskBehindRootTask(thisTask.getRootTask(), restoreAt);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_ADD_INSETS_FRAME_PROVIDER: {\n                final WindowContainer container = WindowContainer.fromBinder(hop.getContainer());\n                if (container == null) {\n                    Slog.e(TAG, \"Attempt to add local insets source provider on unknown: \"\n                            + container);\n                    break;\n                }\n                container.addLocalInsetsFrameProvider(hop.getInsetsFrameProvider());\n                break;\n            }\n            case HIERARCHY_OP_TYPE_REMOVE_INSETS_FRAME_PROVIDER: {\n                final WindowContainer container = WindowContainer.fromBinder(hop.getContainer());\n                if (container == null) {\n                    Slog.e(TAG, \"Attempt to remove local insets source provider from unknown: \"\n                                    + container);\n                    break;\n                }\n                container.removeLocalInsetsFrameProvider(hop.getInsetsFrameProvider());\n                break;\n            }\n            case HIERARCHY_OP_TYPE_SET_ALWAYS_ON_TOP: {\n                final WindowContainer container = WindowContainer.fromBinder(hop.getContainer());\n                if (container == null || container.asDisplayArea() == null\n                        || !container.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on unknown or detached display area: \"\n                            + container);\n                    break;\n                }\n                container.setAlwaysOnTop(hop.isAlwaysOnTop());\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                break;\n            }\n            case HIERARCHY_OP_TYPE_SET_REPARENT_LEAF_TASK_IF_RELAUNCH: {\n                final WindowContainer container = WindowContainer.fromBinder(hop.getContainer());\n                final Task task = container != null ? container.asTask() : null;\n                if (task == null || !task.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on unknown or detached container: \"\n                            + container);\n                    break;\n                }\n                if (!task.mCreatedByOrganizer) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot set reparent leaf task flag on non-organized task : \" + task);\n                }\n                if (!task.isRootTask()) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot set reparent leaf task flag on non-root task : \" + task);\n                }\n                task.setReparentLeafTaskIfRelaunch(hop.isReparentLeafTaskIfRelaunch());\n                break;\n            }\n        }\n        return effects;\n    }\n\n    /**\n     * Applies change set through {@link WindowContainerTransaction#addTaskFragmentOperation}.\n     * @return an int to represent the transaction effects, such as {@link #TRANSACT_EFFECTS_NONE},\n     *         {@link #TRANSACT_EFFECTS_LIFECYCLE} or {@link #TRANSACT_EFFECTS_CLIENT_CONFIG}.\n     */\n    private int applyTaskFragmentOperation(@NonNull WindowContainerTransaction.HierarchyOp hop,\n            @Nullable Transition transition, boolean isInLockTaskMode, @NonNull CallerInfo caller,\n            @Nullable IBinder errorCallbackToken, @Nullable ITaskFragmentOrganizer organizer) {\n        if (!validateTaskFragmentOperation(hop, errorCallbackToken, organizer)) {\n            return TRANSACT_EFFECTS_NONE;\n        }\n        final IBinder fragmentToken = hop.getContainer();\n        final TaskFragment taskFragment = mLaunchTaskFragments.get(fragmentToken);\n        final TaskFragmentOperation operation = hop.getTaskFragmentOperation();\n        final int opType = operation.getOpType();\n\n        int effects = TRANSACT_EFFECTS_NONE;\n        switch (opType) {\n            case OP_TYPE_CREATE_TASK_FRAGMENT: {\n                final TaskFragmentCreationParams taskFragmentCreationParams =\n                        operation.getTaskFragmentCreationParams();\n                if (taskFragmentCreationParams == null) {\n                    final Throwable exception = new IllegalArgumentException(\n                            \"TaskFragmentCreationParams must be non-null\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                createTaskFragment(taskFragmentCreationParams, errorCallbackToken, caller,\n                        transition);\n                break;\n            }\n            case OP_TYPE_DELETE_TASK_FRAGMENT: {\n                if (isInLockTaskMode) {\n                    final ActivityRecord bottomActivity = taskFragment.getActivity(\n                            a -> !a.finishing, false /* traverseTopToBottom */);\n                    if (bottomActivity != null\n                            && mService.getLockTaskController().activityBlockedFromFinish(\n                            bottomActivity)) {\n                        Slog.w(TAG, \"Skip removing TaskFragment due in lock task mode.\");\n                        sendTaskFragmentOperationFailure(organizer, errorCallbackToken,\n                                taskFragment, opType, new IllegalStateException(\n                                        \"Not allow to delete task fragment in lock task mode.\"));\n                        break;\n                    }\n                }\n                effects |= deleteTaskFragment(taskFragment, transition);\n                break;\n            }\n            case OP_TYPE_START_ACTIVITY_IN_TASK_FRAGMENT: {\n                final IBinder callerActivityToken = operation.getActivityToken();\n                final Intent activityIntent = operation.getActivityIntent();\n                final Bundle activityOptions = operation.getBundle();\n                final int result = mService.getActivityStartController()\n                        .startActivityInTaskFragment(taskFragment, activityIntent, activityOptions,\n                                callerActivityToken, caller.mUid, caller.mPid,\n                                errorCallbackToken);\n                if (!isStartResultSuccessful(result)) {\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, convertStartFailureToThrowable(result, activityIntent));\n                } else {\n                    effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                }\n                break;\n            }\n            case OP_TYPE_REPARENT_ACTIVITY_TO_TASK_FRAGMENT: {\n                final IBinder activityToken = operation.getActivityToken();\n                ActivityRecord activity = ActivityRecord.forTokenLocked(activityToken);\n                if (activity == null) {\n                    // The token may be a temporary token if the activity doesn't belong to\n                    // the organizer process.\n                    activity = mTaskFragmentOrganizerController\n                            .getReparentActivityFromTemporaryToken(organizer, activityToken);\n                }\n                if (activity == null) {\n                    final Throwable exception = new IllegalArgumentException(\n                            \"Not allowed to operate with invalid activity.\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                if (taskFragment.isAllowedToEmbedActivity(activity) != EMBEDDING_ALLOWED) {\n                    final Throwable exception = new SecurityException(\n                            \"The task fragment is not allowed to embed the given activity.\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                if (taskFragment.getTask() != activity.getTask()) {\n                    final Throwable exception = new SecurityException(\"The reparented activity is\"\n                            + \" not in the same Task as the target TaskFragment.\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                if (transition != null) {\n                    transition.collect(activity);\n                    if (activity.getParent() != null) {\n                        // Collect the current parent. Its visibility may change as a result of\n                        // this reparenting.\n                        transition.collect(activity.getParent());\n                    }\n                    transition.collect(taskFragment);\n                }\n                activity.reparent(taskFragment, POSITION_TOP);\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                break;\n            }\n            case OP_TYPE_SET_ADJACENT_TASK_FRAGMENTS: {\n                final IBinder secondaryFragmentToken = operation.getSecondaryFragmentToken();\n                final TaskFragment secondaryTaskFragment =\n                        mLaunchTaskFragments.get(secondaryFragmentToken);\n                if (secondaryTaskFragment == null) {\n                    final Throwable exception = new IllegalArgumentException(\n                            \"SecondaryFragmentToken must be set for setAdjacentTaskFragments.\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                if (taskFragment.getAdjacentTaskFragment() != secondaryTaskFragment) {\n                    // Only have lifecycle effect if the adjacent changed.\n                    taskFragment.setAdjacentTaskFragment(secondaryTaskFragment);\n                    effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                }\n\n                final Bundle bundle = hop.getLaunchOptions();\n                final WindowContainerTransaction.TaskFragmentAdjacentParams adjacentParams =\n                        bundle != null\n                                ? new WindowContainerTransaction.TaskFragmentAdjacentParams(bundle)\n                                : null;\n                taskFragment.setDelayLastActivityRemoval(adjacentParams != null\n                        && adjacentParams.shouldDelayPrimaryLastActivityRemoval());\n                secondaryTaskFragment.setDelayLastActivityRemoval(adjacentParams != null\n                        && adjacentParams.shouldDelaySecondaryLastActivityRemoval());\n                break;\n            }\n            case OP_TYPE_CLEAR_ADJACENT_TASK_FRAGMENTS: {\n                final TaskFragment adjacentTaskFragment = taskFragment.getAdjacentTaskFragment();\n                if (adjacentTaskFragment == null) {\n                    break;\n                }\n                taskFragment.resetAdjacentTaskFragment();\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n\n                // Clear the focused app if the focused app is no longer visible after reset the\n                // adjacent TaskFragments.\n                final ActivityRecord focusedApp = taskFragment.getDisplayContent().mFocusedApp;\n                final TaskFragment focusedTaskFragment = focusedApp != null\n                        ? focusedApp.getTaskFragment()\n                        : null;\n                if ((focusedTaskFragment == taskFragment\n                        || focusedTaskFragment == adjacentTaskFragment)\n                        && !focusedTaskFragment.shouldBeVisible(null /* starting */)) {\n                    focusedTaskFragment.getDisplayContent().setFocusedApp(null /* newFocus */);\n                }\n                break;\n            }\n            case OP_TYPE_REQUEST_FOCUS_ON_TASK_FRAGMENT: {\n                final ActivityRecord curFocus = taskFragment.getDisplayContent().mFocusedApp;\n                if (curFocus != null && curFocus.getTaskFragment() == taskFragment) {\n                    Slog.d(TAG, \"The requested TaskFragment already has the focus.\");\n                    break;\n                }\n                if (curFocus != null && curFocus.getTask() != taskFragment.getTask()) {\n                    Slog.d(TAG, \"The Task of the requested TaskFragment doesn't have focus.\");\n                    break;\n                }\n                final ActivityRecord targetFocus = taskFragment.getTopResumedActivity();\n                if (targetFocus == null) {\n                    Slog.d(TAG, \"There is no resumed activity in the requested TaskFragment.\");\n                    break;\n                }\n                taskFragment.getDisplayContent().setFocusedApp(targetFocus);\n                break;\n            }\n            case OP_TYPE_SET_COMPANION_TASK_FRAGMENT: {\n                final IBinder companionFragmentToken = operation.getSecondaryFragmentToken();\n                final TaskFragment companionTaskFragment = companionFragmentToken != null\n                        ? mLaunchTaskFragments.get(companionFragmentToken)\n                        : null;\n                taskFragment.setCompanionTaskFragment(companionTaskFragment);\n                break;\n            }\n            case OP_TYPE_SET_ANIMATION_PARAMS: {\n                final TaskFragmentAnimationParams animationParams = operation.getAnimationParams();\n                if (animationParams == null) {\n                    final Throwable exception = new IllegalArgumentException(\n                            \"TaskFragmentAnimationParams must be non-null\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                taskFragment.setAnimationParams(animationParams);\n                break;\n            }\n        }\n        return effects;\n    }\n\n    private boolean validateTaskFragmentOperation(\n            @NonNull WindowContainerTransaction.HierarchyOp hop,\n            @Nullable IBinder errorCallbackToken, @Nullable ITaskFragmentOrganizer organizer) {\n        final TaskFragmentOperation operation = hop.getTaskFragmentOperation();\n        final IBinder fragmentToken = hop.getContainer();\n        final TaskFragment taskFragment = mLaunchTaskFragments.get(fragmentToken);\n        if (operation == null) {\n            final Throwable exception = new IllegalArgumentException(\n                    \"TaskFragmentOperation must be non-null\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                    OP_TYPE_UNKNOWN, exception);\n            return false;\n        }\n        final int opType = operation.getOpType();\n        if (opType == OP_TYPE_CREATE_TASK_FRAGMENT) {\n            // No need to check TaskFragment.\n            return true;\n        }\n\n        if (!validateTaskFragment(taskFragment, opType, errorCallbackToken, organizer)) {\n            return false;\n        }\n\n        final IBinder secondaryFragmentToken = operation.getSecondaryFragmentToken();\n        return secondaryFragmentToken == null\n                || validateTaskFragment(mLaunchTaskFragments.get(secondaryFragmentToken), opType,\n                errorCallbackToken, organizer);\n    }\n\n    private boolean validateTaskFragment(@Nullable TaskFragment taskFragment,\n            @TaskFragmentOperation.OperationType int opType, @Nullable IBinder errorCallbackToken,\n            @Nullable ITaskFragmentOrganizer organizer) {\n        if (taskFragment == null || !taskFragment.isAttached()) {\n            // TaskFragment doesn't exist.\n            final Throwable exception = new IllegalArgumentException(\n                    \"Not allowed to apply operation on invalid fragment tokens opType=\" + opType);\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                    opType, exception);\n            return false;\n        }\n        if (taskFragment.isEmbeddedTaskFragmentInPip()\n                && (opType != OP_TYPE_DELETE_TASK_FRAGMENT\n                // When the Task enters PiP before the organizer removes the empty TaskFragment, we\n                // should allow it to delete the TaskFragment for cleanup.\n                || taskFragment.getTopNonFinishingActivity() != null)) {\n            final Throwable exception = new IllegalArgumentException(\n                    \"Not allowed to apply operation on PIP TaskFragment\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                    opType, exception);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Post and wait for the result of the activity start to prevent potential deadlock against\n     * {@link WindowManagerGlobalLock}.\n     */\n    private int waitAsyncStart(IntSupplier startActivity) {\n        final Integer[] starterResult = {null};\n        final Handler handler = (Looper.myLooper() == mService.mH.getLooper())\n                // uncommon case where a queued transaction is trying to start an activity. We can't\n                // post to our own thread and wait (otherwise we deadlock), so use anim thread\n                // instead (which is 1 higher priority).\n                ? mService.mWindowManager.mAnimationHandler\n                // Otherwise just put it on main handler\n                : mService.mH;\n        handler.post(() -> {\n            try {\n                starterResult[0] = startActivity.getAsInt();\n            } catch (Throwable t) {\n                starterResult[0] = ActivityManager.START_CANCELED;\n                Slog.w(TAG, t);\n            }\n            synchronized (mGlobalLock) {\n                mGlobalLock.notifyAll();\n            }\n        });\n        while (starterResult[0] == null) {\n            try {\n                mGlobalLock.wait();\n            } catch (InterruptedException ignored) {\n            }\n        }\n        return starterResult[0];\n    }\n\n    private int sanitizeAndApplyHierarchyOp(WindowContainer container,\n            WindowContainerTransaction.HierarchyOp hop) {\n        final Task task = container.asTask();\n        if (task == null) {\n            throw new IllegalArgumentException(\"Invalid container in hierarchy op\");\n        }\n        final DisplayContent dc = task.getDisplayContent();\n        if (dc == null) {\n            Slog.w(TAG, \"Container is no longer attached: \" + task);\n            return TRANSACT_EFFECTS_NONE;\n        }\n        final Task as = task;\n\n        if (hop.isReparent()) {\n            final boolean isNonOrganizedRootableTask =\n                    task.isRootTask() || task.getParent().asTask().mCreatedByOrganizer;\n            if (isNonOrganizedRootableTask) {\n                WindowContainer newParent = hop.getNewParent() == null\n                        ? dc.getDefaultTaskDisplayArea()\n                        : WindowContainer.fromBinder(hop.getNewParent());\n                if (newParent == null) {\n                    Slog.e(TAG, \"Can't resolve parent window from token\");\n                    return TRANSACT_EFFECTS_NONE;\n                }\n                if (task.getParent() != newParent) {\n                    if (newParent.asTaskDisplayArea() != null) {\n                        // For now, reparenting to displayarea is different from other reparents...\n                        as.reparent(newParent.asTaskDisplayArea(), hop.getToTop());\n                    } else if (newParent.asTask() != null) {\n                        if (newParent.inMultiWindowMode() && task.isLeafTask()) {\n                            if (newParent.inPinnedWindowingMode()) {\n                                Slog.w(TAG, \"Can't support moving a task to another PIP window...\"\n                                        + \" newParent=\" + newParent + \" task=\" + task);\n                                return TRANSACT_EFFECTS_NONE;\n                            }\n                            if (!task.supportsMultiWindowInDisplayArea(\n                                    newParent.asTask().getDisplayArea())) {\n                                Slog.w(TAG, \"Can't support task that doesn't support multi-window\"\n                                        + \" mode in multi-window mode... newParent=\" + newParent\n                                        + \" task=\" + task);\n                                return TRANSACT_EFFECTS_NONE;\n                            }\n                        }\n                        task.reparent((Task) newParent,\n                                hop.getToTop() ? POSITION_TOP : POSITION_BOTTOM,\n                                false /*moveParents*/, \"sanitizeAndApplyHierarchyOp\");\n                    } else {\n                        throw new RuntimeException(\"Can only reparent task to another task or\"\n                                + \" taskDisplayArea, but not \" + newParent);\n                    }\n                } else {\n                    final Task rootTask = (Task) (\n                            (newParent != null && !(newParent instanceof TaskDisplayArea))\n                                    ? newParent : task.getRootTask());\n                    as.getDisplayArea().positionChildAt(\n                            hop.getToTop() ? POSITION_TOP : POSITION_BOTTOM, rootTask,\n                            false /* includingParents */);\n                }\n            } else {\n                throw new RuntimeException(\"Reparenting leaf Tasks is not supported now. \" + task);\n            }\n        } else {\n            task.getParent().positionChildAt(\n                    hop.getToTop() ? POSITION_TOP : POSITION_BOTTOM,\n                    task, false /* includingParents */);\n        }\n        return TRANSACT_EFFECTS_LIFECYCLE;\n    }\n\n    private boolean isLockTaskModeViolation(WindowContainer parent, Task task,\n            boolean isInLockTaskMode) {\n        if (!isInLockTaskMode || parent == null || task == null) {\n            return false;\n        }\n        final LockTaskController lockTaskController = mService.getLockTaskController();\n        boolean taskViolation = lockTaskController.isLockTaskModeViolation(task);\n        if (!taskViolation && parent.asTask() != null) {\n            taskViolation = lockTaskController.isLockTaskModeViolation(parent.asTask());\n        }\n        if (taskViolation) {\n            Slog.w(TAG, \"Can't support the operation since in lock task mode violation. \"\n                    + \" Task: \" + task + \" Parent : \" + parent);\n        }\n        return taskViolation;\n    }\n\n    private int reparentChildrenTasksHierarchyOp(WindowContainerTransaction.HierarchyOp hop,\n            @Nullable Transition transition, int syncId, boolean isInLockTaskMode) {\n        WindowContainer<?> currentParent = hop.getContainer() != null\n                ? WindowContainer.fromBinder(hop.getContainer()) : null;\n        WindowContainer newParent = hop.getNewParent() != null\n                ? WindowContainer.fromBinder(hop.getNewParent()) : null;\n        if (currentParent == null && newParent == null) {\n            throw new IllegalArgumentException(\"reparentChildrenTasksHierarchyOp: \" + hop);\n        } else if (currentParent == null) {\n            currentParent = newParent.asTask().getDisplayContent().getDefaultTaskDisplayArea();\n        } else if (newParent == null) {\n            newParent = currentParent.asTask().getDisplayContent().getDefaultTaskDisplayArea();\n        }\n\n        if (currentParent == newParent) {\n            Slog.e(TAG, \"reparentChildrenTasksHierarchyOp parent not changing: \" + hop);\n            return TRANSACT_EFFECTS_NONE;\n        }\n        if (!currentParent.isAttached()) {\n            Slog.e(TAG, \"reparentChildrenTasksHierarchyOp currentParent detached=\"\n                    + currentParent + \" hop=\" + hop);\n            return TRANSACT_EFFECTS_NONE;\n        }\n        if (!newParent.isAttached()) {\n            Slog.e(TAG, \"reparentChildrenTasksHierarchyOp newParent detached=\"\n                    + newParent + \" hop=\" + hop);\n            return TRANSACT_EFFECTS_NONE;\n        }\n        if (newParent.inPinnedWindowingMode()) {\n            Slog.e(TAG, \"reparentChildrenTasksHierarchyOp newParent in PIP=\"\n                    + newParent + \" hop=\" + hop);\n            return TRANSACT_EFFECTS_NONE;\n        }\n\n        final boolean newParentInMultiWindow = newParent.inMultiWindowMode();\n        final TaskDisplayArea newParentTda = newParent.asTask() != null\n                ? newParent.asTask().getDisplayArea()\n                : newParent.asTaskDisplayArea();\n        final WindowContainer finalCurrentParent = currentParent;\n        final WindowContainer finalNewParent = newParent;\n        Slog.i(TAG, \"reparentChildrenTasksHierarchyOp\"\n                + \" currentParent=\" + currentParent + \" newParent=\" + newParent + \" hop=\" + hop);\n\n        // We want to collect the tasks first before re-parenting to avoid array shifting on us.\n        final ArrayList<Task> tasksToReparent = new ArrayList<>();\n\n        currentParent.forAllTasks(task -> {\n            Slog.i(TAG, \" Processing task=\" + task);\n            final boolean reparent;\n            if (task.mCreatedByOrganizer || task.getParent() != finalCurrentParent) {\n                // We only care about non-organized task that are direct children of the thing we\n                // are reparenting from.\n                return false;\n            }\n            if (newParentInMultiWindow && !task.supportsMultiWindowInDisplayArea(newParentTda)) {\n                Slog.e(TAG, \"reparentChildrenTasksHierarchyOp non-resizeable task to multi window,\"\n                        + \" task=\" + task);\n                return false;\n            }\n            if (!ArrayUtils.isEmpty(hop.getActivityTypes())\n                    && !ArrayUtils.contains(hop.getActivityTypes(), task.getActivityType())) {\n                return false;\n            }\n            if (!ArrayUtils.isEmpty(hop.getWindowingModes())\n                    && !ArrayUtils.contains(hop.getWindowingModes(), task.getWindowingMode())) {\n                return false;\n            }\n            if (isLockTaskModeViolation(finalNewParent, task, isInLockTaskMode)) {\n                return false;\n            }\n\n            if (hop.getToTop()) {\n                tasksToReparent.add(0, task);\n            } else {\n                tasksToReparent.add(task);\n            }\n            return hop.getReparentTopOnly() && tasksToReparent.size() == 1;\n        });\n\n        final int count = tasksToReparent.size();\n        for (int i = 0; i < count; ++i) {\n            final Task task = tasksToReparent.get(i);\n            if (syncId >= 0) {\n                addToSyncSet(syncId, task);\n            }\n            if (transition != null) transition.collect(task);\n\n            if (newParent instanceof TaskDisplayArea) {\n                // For now, reparenting to display area is different from other reparents...\n                task.reparent((TaskDisplayArea) newParent, hop.getToTop());\n            } else {\n                task.reparent((Task) newParent,\n                        hop.getToTop() ? POSITION_TOP : POSITION_BOTTOM,\n                        false /*moveParents*/, \"processChildrenTaskReparentHierarchyOp\");\n            }\n        }\n\n        if (transition != null) transition.collect(newParent);\n\n        return TRANSACT_EFFECTS_LIFECYCLE;\n    }\n\n    private int setAdjacentRootsHierarchyOp(WindowContainerTransaction.HierarchyOp hop) {\n        final TaskFragment root1 = WindowContainer.fromBinder(hop.getContainer()).asTaskFragment();\n        final TaskFragment root2 =\n                WindowContainer.fromBinder(hop.getAdjacentRoot()).asTaskFragment();\n        if (!root1.mCreatedByOrganizer || !root2.mCreatedByOrganizer) {\n            throw new IllegalArgumentException(\"setAdjacentRootsHierarchyOp: Not created by\"\n                    + \" organizer root1=\" + root1 + \" root2=\" + root2);\n        }\n        if (root1.getAdjacentTaskFragment() == root2) {\n            return TRANSACT_EFFECTS_NONE;\n        }\n        root1.setAdjacentTaskFragment(root2);\n        return TRANSACT_EFFECTS_LIFECYCLE;\n    }\n\n    private int clearAdjacentRootsHierarchyOp(WindowContainerTransaction.HierarchyOp hop) {\n        final TaskFragment root = WindowContainer.fromBinder(hop.getContainer()).asTaskFragment();\n        if (!root.mCreatedByOrganizer) {\n            throw new IllegalArgumentException(\"clearAdjacentRootsHierarchyOp: Not created by\"\n                    + \" organizer root=\" + root);\n        }\n        if (root.getAdjacentTaskFragment() == null) {\n            return TRANSACT_EFFECTS_NONE;\n        }\n        root.resetAdjacentTaskFragment();\n        return TRANSACT_EFFECTS_LIFECYCLE;\n    }\n\n    private void sanitizeWindowContainer(WindowContainer wc) {\n        if (!(wc instanceof TaskFragment) && !(wc instanceof DisplayArea)) {\n            throw new RuntimeException(\"Invalid token in task fragment or displayArea transaction\");\n        }\n    }\n\n    private int applyWindowContainerChange(WindowContainer wc,\n            WindowContainerTransaction.Change c, @Nullable IBinder errorCallbackToken) {\n        sanitizeWindowContainer(wc);\n        if (wc.asDisplayArea() != null) {\n            return applyDisplayAreaChanges(wc.asDisplayArea(), c);\n        } else if (wc.asTask() != null) {\n            return applyTaskChanges(wc.asTask(), c);\n        } else if (wc.asTaskFragment() != null && wc.asTaskFragment().isEmbedded()) {\n            return applyTaskFragmentChanges(wc.asTaskFragment(), c, errorCallbackToken);\n        } else {\n            return applyChanges(wc, c);\n        }\n    }\n\n    @Override\n    public ITaskOrganizerController getTaskOrganizerController() {\n        enforceTaskPermission(\"getTaskOrganizerController()\");\n        return mTaskOrganizerController;\n    }\n\n    @Override\n    public IDisplayAreaOrganizerController getDisplayAreaOrganizerController() {\n        enforceTaskPermission(\"getDisplayAreaOrganizerController()\");\n        return mDisplayAreaOrganizerController;\n    }\n\n    @Override\n    public ITaskFragmentOrganizerController getTaskFragmentOrganizerController() {\n        return mTaskFragmentOrganizerController;\n    }\n\n    /**\n     * This will prepare a {@link BLASTSyncEngine.SyncGroup} for the organizer to track, but the\n     * {@link BLASTSyncEngine.SyncGroup} may not be active until the {@link BLASTSyncEngine} is\n     * free.\n     */\n    private BLASTSyncEngine.SyncGroup prepareSyncWithOrganizer(\n            IWindowContainerTransactionCallback callback) {\n        final BLASTSyncEngine.SyncGroup s = mService.mWindowManager.mSyncEngine\n                .prepareSyncSet(this, \"Organizer\");\n        mTransactionCallbacksByPendingSyncId.put(s.mSyncId, callback);\n        return s;\n    }\n\n    @VisibleForTesting\n    int startSyncWithOrganizer(IWindowContainerTransactionCallback callback) {\n        final BLASTSyncEngine.SyncGroup s = prepareSyncWithOrganizer(callback);\n        mService.mWindowManager.mSyncEngine.startSyncSet(s);\n        return s.mSyncId;\n    }\n\n    @VisibleForTesting\n    void setSyncReady(int id) {\n        ProtoLog.v(WM_DEBUG_WINDOW_ORGANIZER, \"Set sync ready, syncId=%d\", id);\n        mService.mWindowManager.mSyncEngine.setReady(id);\n    }\n\n    @VisibleForTesting\n    void addToSyncSet(int syncId, WindowContainer wc) {\n        mService.mWindowManager.mSyncEngine.addToSyncSet(syncId, wc);\n    }\n\n    @Override\n    public void onTransactionReady(int syncId, SurfaceControl.Transaction t) {\n        ProtoLog.v(WM_DEBUG_WINDOW_ORGANIZER, \"Transaction ready, syncId=%d\", syncId);\n        final IWindowContainerTransactionCallback callback =\n                mTransactionCallbacksByPendingSyncId.get(syncId);\n\n        try {\n            callback.onTransactionReady(syncId, t);\n        } catch (RemoteException e) {\n            // If there's an exception when trying to send the mergedTransaction to the client, we\n            // should immediately apply it here so the transactions aren't lost.\n            t.apply();\n        }\n\n        mTransactionCallbacksByPendingSyncId.remove(syncId);\n    }\n\n    @Override\n    public void registerTransitionPlayer(ITransitionPlayer player) {\n        enforceTaskPermission(\"registerTransitionPlayer()\");\n        final int callerPid = Binder.getCallingPid();\n        final int callerUid = Binder.getCallingUid();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final WindowProcessController wpc =\n                        mService.getProcessController(callerPid, callerUid);\n                mTransitionController.registerTransitionPlayer(player, wpc);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public ITransitionMetricsReporter getTransitionMetricsReporter() {\n        return mTransitionController.mTransitionMetricsReporter;\n    }\n\n    @Override\n    public IBinder getApplyToken() {\n        enforceTaskPermission(\"getApplyToken()\");\n        return SurfaceControl.Transaction.getDefaultApplyToken();\n    }\n\n    /** Whether the configuration changes are important to report back to an organizer. */\n    static boolean configurationsAreEqualForOrganizer(\n            Configuration newConfig, @Nullable Configuration oldConfig) {\n        if (oldConfig == null) {\n            return false;\n        }\n        int cfgChanges = newConfig.diff(oldConfig);\n        final int winCfgChanges = (cfgChanges & ActivityInfo.CONFIG_WINDOW_CONFIGURATION) != 0\n                ? (int) newConfig.windowConfiguration.diff(oldConfig.windowConfiguration,\n                true /* compareUndefined */) : 0;\n        if ((winCfgChanges & CONTROLLABLE_WINDOW_CONFIGS) == 0) {\n            cfgChanges &= ~ActivityInfo.CONFIG_WINDOW_CONFIGURATION;\n        }\n        return (cfgChanges & CONTROLLABLE_CONFIGS) == 0;\n    }\n\n    /**\n     * Makes sure that the transaction only contains operations that are allowed for the\n     * {@link WindowContainerTransaction#getTaskFragmentOrganizer()}.\n     */\n    private void enforceTaskFragmentOrganizerPermission(@NonNull String func,\n            @NonNull ITaskFragmentOrganizer organizer, @NonNull WindowContainerTransaction t) {\n        // Configuration changes\n        final Iterator<Map.Entry<IBinder, WindowContainerTransaction.Change>> entries =\n                t.getChanges().entrySet().iterator();\n        while (entries.hasNext()) {\n            final Map.Entry<IBinder, WindowContainerTransaction.Change> entry = entries.next();\n            final WindowContainer wc = WindowContainer.fromBinder(entry.getKey());\n            enforceTaskFragmentConfigChangeAllowed(func, wc, entry.getValue(), organizer);\n        }\n\n        // Hierarchy changes\n        final List<WindowContainerTransaction.HierarchyOp> hops = t.getHierarchyOps();\n        for (int i = hops.size() - 1; i >= 0; i--) {\n            final WindowContainerTransaction.HierarchyOp hop = hops.get(i);\n            final int type = hop.getType();\n            // Check for each type of the operations that are allowed for TaskFragmentOrganizer.\n            switch (type) {\n                case HIERARCHY_OP_TYPE_ADD_TASK_FRAGMENT_OPERATION:\n                    enforceTaskFragmentOrganized(func, hop.getContainer(), organizer);\n                    if (hop.getTaskFragmentOperation() != null\n                            && hop.getTaskFragmentOperation().getSecondaryFragmentToken() != null) {\n                        enforceTaskFragmentOrganized(func,\n                                hop.getTaskFragmentOperation().getSecondaryFragmentToken(),\n                                organizer);\n                    }\n                    break;\n                case HIERARCHY_OP_TYPE_FINISH_ACTIVITY:\n                    // Allow finish activity if it has the activity token.\n                    break;\n                default:\n                    // Other types of hierarchy changes are not allowed.\n                    String msg = \"Permission Denial: \" + func + \" from pid=\"\n                            + Binder.getCallingPid() + \", uid=\" + Binder.getCallingUid()\n                            + \" trying to apply a hierarchy change that is not allowed for\"\n                            + \" TaskFragmentOrganizer=\" + organizer;\n                    Slog.w(TAG, msg);\n                    throw new SecurityException(msg);\n            }\n        }\n    }\n\n    /**\n     * Makes sure that the {@link TaskFragment} of the given fragment token is created and organized\n     * by the given {@link ITaskFragmentOrganizer}.\n     */\n    private void enforceTaskFragmentOrganized(@NonNull String func,\n            @NonNull IBinder fragmentToken, @NonNull ITaskFragmentOrganizer organizer) {\n        Objects.requireNonNull(fragmentToken);\n        final TaskFragment tf = mLaunchTaskFragments.get(fragmentToken);\n        // When the TaskFragment is {@code null}, it means that the TaskFragment will be created\n        // later in the same transaction, in which case it will always be organized by the given\n        // organizer.\n        if (tf != null && !tf.hasTaskFragmentOrganizer(organizer)) {\n            String msg = \"Permission Denial: \" + func + \" from pid=\" + Binder.getCallingPid()\n                    + \", uid=\" + Binder.getCallingUid() + \" trying to modify TaskFragment not\"\n                    + \" belonging to the TaskFragmentOrganizer=\" + organizer;\n            Slog.w(TAG, msg);\n            throw new SecurityException(msg);\n        }\n    }\n\n    /**\n     * For config change on {@link TaskFragment}, we only support the following operations:\n     * {@link WindowContainerTransaction#setRelativeBounds(WindowContainerToken, Rect)},\n     * {@link WindowContainerTransaction#setWindowingMode(WindowContainerToken, int)}.\n     */\n    private void enforceTaskFragmentConfigChangeAllowed(@NonNull String func,\n            @Nullable WindowContainer wc, @NonNull WindowContainerTransaction.Change change,\n            @NonNull ITaskFragmentOrganizer organizer) {\n        if (wc == null) {\n            Slog.e(TAG, \"Attempt to operate on task fragment that no longer exists\");\n            return;\n        }\n        final TaskFragment tf = wc.asTaskFragment();\n        if (tf == null || !tf.hasTaskFragmentOrganizer(organizer)) {\n            // Only allow to apply changes to TaskFragment that is organized by this organizer.\n            String msg = \"Permission Denial: \" + func + \" from pid=\" + Binder.getCallingPid()\n                    + \", uid=\" + Binder.getCallingUid() + \" trying to modify window container\"\n                    + \" not belonging to the TaskFragmentOrganizer=\" + organizer;\n            Slog.w(TAG, msg);\n            throw new SecurityException(msg);\n        }\n\n        final int changeMask = change.getChangeMask();\n        final int configSetMask = change.getConfigSetMask();\n        final int windowSetMask = change.getWindowSetMask();\n        if (changeMask == 0 && configSetMask == 0 && windowSetMask == 0\n                && change.getWindowingMode() >= 0) {\n            // The change contains only setWindowingMode, which is allowed.\n            return;\n        }\n        if (changeMask != CHANGE_RELATIVE_BOUNDS\n                || configSetMask != ActivityInfo.CONFIG_WINDOW_CONFIGURATION\n                || windowSetMask != WindowConfiguration.WINDOW_CONFIG_BOUNDS) {\n            // None of the change should be requested from a TaskFragment organizer except\n            // setRelativeBounds and setWindowingMode.\n            // For setRelativeBounds, we don't need to check whether it is outside of the Task\n            // bounds, because it is possible that the Task is also resizing, for which we don't\n            // want to throw an exception. The bounds will be adjusted in\n            // TaskFragment#translateRelativeBoundsToAbsoluteBounds.\n            String msg = \"Permission Denial: \" + func + \" from pid=\"\n                    + Binder.getCallingPid() + \", uid=\" + Binder.getCallingUid()\n                    + \" trying to apply changes of changeMask=\" + changeMask\n                    + \" configSetMask=\" + configSetMask + \" windowSetMask=\" + windowSetMask\n                    + \" to TaskFragment=\" + tf + \" TaskFragmentOrganizer=\" + organizer;\n            Slog.w(TAG, msg);\n            throw new SecurityException(msg);\n        }\n    }\n\n    private void createTaskFragment(@NonNull TaskFragmentCreationParams creationParams,\n            @Nullable IBinder errorCallbackToken, @NonNull CallerInfo caller,\n            @Nullable Transition transition) {\n        final ActivityRecord ownerActivity =\n                ActivityRecord.forTokenLocked(creationParams.getOwnerToken());\n        final ITaskFragmentOrganizer organizer = ITaskFragmentOrganizer.Stub.asInterface(\n                creationParams.getOrganizer().asBinder());\n\n        if (mLaunchTaskFragments.containsKey(creationParams.getFragmentToken())) {\n            final Throwable exception =\n                    new IllegalArgumentException(\"TaskFragment token must be unique\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, null /* taskFragment */,\n                    OP_TYPE_CREATE_TASK_FRAGMENT, exception);\n            return;\n        }\n        if (ownerActivity == null || ownerActivity.getTask() == null) {\n            final Throwable exception =\n                    new IllegalArgumentException(\"Not allowed to operate with invalid ownerToken\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, null /* taskFragment */,\n                    OP_TYPE_CREATE_TASK_FRAGMENT, exception);\n            return;\n        }\n        if (!ownerActivity.isResizeable()) {\n            final IllegalArgumentException exception = new IllegalArgumentException(\"Not allowed\"\n                    + \" to operate with non-resizable owner Activity\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, null /* taskFragment */,\n                    OP_TYPE_CREATE_TASK_FRAGMENT, exception);\n            return;\n        }\n        // The ownerActivity has to belong to the same app as the target Task.\n        final Task ownerTask = ownerActivity.getTask();\n        if (ownerTask.effectiveUid != ownerActivity.getUid()\n                || ownerTask.effectiveUid != caller.mUid) {\n            final Throwable exception =\n                    new SecurityException(\"Not allowed to operate with the ownerToken while \"\n                            + \"the root activity of the target task belong to the different app\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, null /* taskFragment */,\n                    OP_TYPE_CREATE_TASK_FRAGMENT, exception);\n            return;\n        }\n        if (ownerTask.inPinnedWindowingMode()) {\n            final Throwable exception = new IllegalArgumentException(\n                    \"Not allowed to create TaskFragment in PIP Task\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, null /* taskFragment */,\n                    OP_TYPE_CREATE_TASK_FRAGMENT, exception);\n            return;\n        }\n        final TaskFragment taskFragment = new TaskFragment(mService,\n                creationParams.getFragmentToken(), true /* createdByOrganizer */);\n        // Set task fragment organizer immediately, since it might have to be notified about further\n        // actions.\n        taskFragment.setTaskFragmentOrganizer(creationParams.getOrganizer(),\n                ownerActivity.getUid(), ownerActivity.info.processName);\n        final int position;\n        if (creationParams.getPairedPrimaryFragmentToken() != null) {\n            // When there is a paired primary TaskFragment, we want to place the new TaskFragment\n            // right above the paired one to make sure there is no other window in between.\n            final TaskFragment pairedPrimaryTaskFragment = getTaskFragment(\n                    creationParams.getPairedPrimaryFragmentToken());\n            final int pairedPosition = ownerTask.mChildren.indexOf(pairedPrimaryTaskFragment);\n            position = pairedPosition != -1 ? pairedPosition + 1 : POSITION_TOP;\n        } else if (creationParams.getPairedActivityToken() != null) {\n            // When there is a paired Activity, we want to place the new TaskFragment right above\n            // the paired Activity to make sure the Activity position is not changed after reparent.\n            final ActivityRecord pairedActivity = ActivityRecord.forTokenLocked(\n                    creationParams.getPairedActivityToken());\n            final int pairedPosition = ownerTask.mChildren.indexOf(pairedActivity);\n            position = pairedPosition != -1 ? pairedPosition + 1 : POSITION_TOP;\n        } else {\n            position = POSITION_TOP;\n        }\n        ownerTask.addChild(taskFragment, position);\n        taskFragment.setWindowingMode(creationParams.getWindowingMode());\n        if (!creationParams.getInitialRelativeBounds().isEmpty()) {\n            // Set relative bounds instead of using setBounds. This will avoid unnecessary update in\n            // case the parent has resized since the last time parent info is sent to the organizer.\n            taskFragment.setRelativeEmbeddedBounds(creationParams.getInitialRelativeBounds());\n            // Recompute configuration as the bounds will be calculated based on relative bounds in\n            // TaskFragment#resolveOverrideConfiguration.\n            taskFragment.recomputeConfiguration();\n        }\n        mLaunchTaskFragments.put(creationParams.getFragmentToken(), taskFragment);\n\n        if (transition != null) transition.collectExistenceChange(taskFragment);\n    }\n\n    private int deleteTaskFragment(@NonNull TaskFragment taskFragment,\n            @Nullable Transition transition) {\n        if (transition != null) transition.collectExistenceChange(taskFragment);\n\n        mLaunchTaskFragments.remove(taskFragment.getFragmentToken());\n        taskFragment.remove(true /* withTransition */, \"deleteTaskFragment\");\n        return TRANSACT_EFFECTS_LIFECYCLE;\n    }\n\n    @Nullable\n    TaskFragment getTaskFragment(IBinder tfToken) {\n        return mLaunchTaskFragments.get(tfToken);\n    }\n\n    void cleanUpEmbeddedTaskFragment(TaskFragment taskFragment) {\n        mLaunchTaskFragments.remove(taskFragment.getFragmentToken());\n    }\n\n    static class CallerInfo {\n        final int mPid;\n        final int mUid;\n\n        CallerInfo() {\n            mPid = Binder.getCallingPid();\n            mUid = Binder.getCallingUid();\n        }\n    }\n\n    void sendTaskFragmentOperationFailure(@NonNull ITaskFragmentOrganizer organizer,\n            @Nullable IBinder errorCallbackToken, @Nullable TaskFragment taskFragment,\n            @TaskFragmentOperation.OperationType int opType, @NonNull Throwable exception) {\n        if (organizer == null) {\n            throw new IllegalArgumentException(\"Not allowed to operate with invalid organizer\");\n        }\n        mService.mTaskFragmentOrganizerController\n                .onTaskFragmentError(organizer, errorCallbackToken, taskFragment, opType,\n                        exception);\n    }\n\n    private Throwable convertStartFailureToThrowable(int result, Intent intent) {\n        switch (result) {\n            case ActivityManager.START_INTENT_NOT_RESOLVED:\n            case ActivityManager.START_CLASS_NOT_FOUND:\n                return new ActivityNotFoundException(\"No Activity found to handle \" + intent);\n            case ActivityManager.START_PERMISSION_DENIED:\n                return new SecurityException(\"Permission denied and not allowed to start activity \"\n                        + intent);\n            case ActivityManager.START_CANCELED:\n                return new AndroidRuntimeException(\"Activity could not be started for \" + intent\n                        + \" with error code : \" + result);\n            default:\n                return new AndroidRuntimeException(\"Start activity failed with error code : \"\n                        + result + \" when starting \" + intent);\n        }\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 19277,
                                        "general": {
                                            "word_based": 7692,
                                            "char_based": 26209
                                        },
                                        "gemini": 22487
                                    }
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-375396810",
            "aliases": [
                "A-375396810",
                "CVE-2025-22407"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-375396810",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "00555617ddbbc1a19089104c084d14f465c971ce"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 00555617ddbbc1a19089104c084d14f465c971ce Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Sat, 2 Nov 2024 02:29:10 +0000\nSubject: [PATCH] Fix more memory-unsafe logging\n\nIn various locations around the stack, log statements use structures that\nmay, in exceptional cases, have been freed by preceding calls.  This can\nlead to use after free and potentially to security vulnerabilities.\n\nUse local variables instead, or store the length before the call if no\nlocal variable is already convenient.\n\nBug: 375404242\nBug: 375398779\nBug: 375397720\nBug: 375397164\nBug: 375397370\nBug: 375396810\nBug: 375159652\nBug: 375160214\nBug: 375159480\nTest: m libbluetooth\nTest: researcher POC\nFlag: EXEMPT trivial logic fix\nIgnore-AOSP-First: security\nTag: #security\nChange-Id: Ia50e074de751661a0e617bfffa17871497b8d1ea\n---\n system/stack/avct/avct_lcb_act.cc    | 5 ++++-\n system/stack/bnep/bnep_main.cc       | 4 +++-\n system/stack/bnep/bnep_utils.cc      | 3 ++-\n system/stack/hid/hidd_conn.cc        | 4 ++--\n system/stack/rfcomm/rfc_ts_frames.cc | 3 ++-\n system/stack/rfcomm/rfc_utils.cc     | 3 ++-\n system/stack/sdp/sdp_discovery.cc    | 2 +-\n system/stack/sdp/sdp_server.cc       | 4 ++--\n 8 files changed, 18 insertions(+), 10 deletions(-)\n\ndiff --git a/system/stack/avct/avct_lcb_act.cc b/system/stack/avct/avct_lcb_act.cc\nindex 986bce7d34..32da9d865b 100644\n--- a/system/stack/avct/avct_lcb_act.cc\n+++ b/system/stack/avct/avct_lcb_act.cc\n@@ -727,10 +727,13 @@ void avct_lcb_msg_ind(tAVCT_LCB* p_lcb, tAVCT_LCB_EVT* p_data) {\n     p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n     AVCT_BUILD_HDR(p, label, AVCT_PKT_TYPE_SINGLE, AVCT_REJ);\n     UINT16_TO_BE_STREAM(p, pid);\n+\n+    uint16_t len = p_buf->len;\n+\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_lcb->ch_lcid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} lcid:0x{:04x} len:{}\", p_lcb->peer_addr,\n-                p_lcb->ch_lcid, p_buf->len);\n+                p_lcb->ch_lcid, len);\n     }\n   }\n }\ndiff --git a/system/stack/bnep/bnep_main.cc b/system/stack/bnep/bnep_main.cc\nindex e0e3c4540c..adf3c8666e 100644\n--- a/system/stack/bnep/bnep_main.cc\n+++ b/system/stack/bnep/bnep_main.cc\n@@ -295,10 +295,12 @@ static void bnep_congestion_ind(uint16_t l2cap_cid, bool is_congested) {\n         break;\n       }\n \n+      uint16_t len = p_buf->len;\n+\n       if (stack::l2cap::get_interface().L2CA_DataWrite(l2cap_cid, p_buf) !=\n           tL2CAP_DW_RESULT::SUCCESS) {\n         log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_bcb->rem_bda, l2cap_cid,\n-                  p_buf->len);\n+                  len);\n       }\n     }\n   }\ndiff --git a/system/stack/bnep/bnep_utils.cc b/system/stack/bnep/bnep_utils.cc\nindex 252facf668..4092d9afee 100644\n--- a/system/stack/bnep/bnep_utils.cc\n+++ b/system/stack/bnep/bnep_utils.cc\n@@ -411,10 +411,11 @@ void bnepu_check_send_packet(tBNEP_CONN* p_bcb, BT_HDR* p_buf) {\n       fixed_queue_enqueue(p_bcb->xmit_q, p_buf);\n     }\n   } else {\n+    uint16_t len = p_buf->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_bcb->l2cap_cid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_bcb->rem_bda,\n-                p_bcb->l2cap_cid, p_buf->len);\n+                p_bcb->l2cap_cid, len);\n     }\n   }\n }\ndiff --git a/system/stack/hid/hidd_conn.cc b/system/stack/hid/hidd_conn.cc\nindex c64a7b9104..695e5d6c84 100644\n--- a/system/stack/hid/hidd_conn.cc\n+++ b/system/stack/hid/hidd_conn.cc\n@@ -88,10 +88,10 @@ static void hidd_check_config_done() {\n \n     // send outstanding data on intr\n     if (hd_cb.pending_data) {\n+      uint16_t len = hd_cb.pending_data->len;\n       if (stack::l2cap::get_interface().L2CA_DataWrite(p_hcon->intr_cid, hd_cb.pending_data) !=\n           tL2CAP_DW_RESULT::SUCCESS) {\n-        log::warn(\"Unable to write L2CAP data cid:{} len:{}\", p_hcon->intr_cid,\n-                  hd_cb.pending_data->len);\n+        log::warn(\"Unable to write L2CAP data cid:{} len:{}\", p_hcon->intr_cid, len);\n       }\n       hd_cb.pending_data = NULL;\n     }\ndiff --git a/system/stack/rfcomm/rfc_ts_frames.cc b/system/stack/rfcomm/rfc_ts_frames.cc\nindex ea57abf6dc..e93cfed9b8 100644\n--- a/system/stack/rfcomm/rfc_ts_frames.cc\n+++ b/system/stack/rfcomm/rfc_ts_frames.cc\n@@ -201,10 +201,11 @@ void rfc_send_buf_uih(tRFC_MCB* p_mcb, uint8_t dlci, BT_HDR* p_buf) {\n   if (dlci == RFCOMM_MX_DLCI) {\n     rfc_check_send_cmd(p_mcb, p_buf);\n   } else {\n+    uint16_t len = p_buf->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_mcb->lcid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_mcb->bd_addr, p_mcb->lcid,\n-                p_buf->len);\n+                len);\n     }\n   }\n }\ndiff --git a/system/stack/rfcomm/rfc_utils.cc b/system/stack/rfcomm/rfc_utils.cc\nindex 23420892cb..0c5074db76 100644\n--- a/system/stack/rfcomm/rfc_utils.cc\n+++ b/system/stack/rfcomm/rfc_utils.cc\n@@ -428,9 +428,10 @@ void rfc_check_send_cmd(tRFC_MCB* p_mcb, BT_HDR* p_buf) {\n     if (p == NULL) {\n       break;\n     }\n+    uint16_t len = p->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_mcb->lcid, p) != tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_mcb->bd_addr, p_mcb->lcid,\n-                p->len);\n+                len);\n     }\n   }\n }\ndiff --git a/system/stack/sdp/sdp_discovery.cc b/system/stack/sdp/sdp_discovery.cc\nindex 4fa484e14a..6aba1993af 100644\n--- a/system/stack/sdp/sdp_discovery.cc\n+++ b/system/stack/sdp/sdp_discovery.cc\n@@ -877,7 +877,7 @@ static void process_service_attr_rsp(tCONN_CB* p_ccb, uint8_t* p_reply, uint8_t*\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_msg) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-                p_ccb->connection_id, p_msg->len);\n+                p_ccb->connection_id, p - p_start);\n     }\n \n     /* Start inactivity timer */\ndiff --git a/system/stack/sdp/sdp_server.cc b/system/stack/sdp/sdp_server.cc\nindex abd70aedb1..0f379708e9 100644\n--- a/system/stack/sdp/sdp_server.cc\n+++ b/system/stack/sdp/sdp_server.cc\n@@ -300,7 +300,7 @@ static void process_service_search(tCONN_CB* p_ccb, uint16_t trans_num, uint16_t\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_buf) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_buf->len);\n+              p_ccb->connection_id, p_rsp - p_rsp_start);\n   }\n }\n \n@@ -564,7 +564,7 @@ static void process_service_attr_req(tCONN_CB* p_ccb, uint16_t trans_num, uint16\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_buf) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_buf->len);\n+              p_ccb->connection_id, p_rsp - p_rsp_start);\n   }\n }\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 2404,
                        "general": {
                            "word_based": 853,
                            "char_based": 1793
                        },
                        "gemini": 3096
                    },
                    "total_downstream_versions_tested": 0,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": []
                }
            ]
        },
        {
            "id": "ASB-A-364037868",
            "aliases": [
                "A-364037868",
                "CVE-2025-0097"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-364037868",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "ea329372d8426c6cdbc2d5570c10bef1003d9912"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From ea329372d8426c6cdbc2d5570c10bef1003d9912 Mon Sep 17 00:00:00 2001\nFrom: Vishnu Nair <vishnun@google.com>\nDate: Tue, 17 Sep 2024 10:00:39 -0700\nSubject: [PATCH] Validate originating process for transferTouchGesture API\n\nAddresses a security vulnerability where a malicious process could\npotentially steal an active touch gesture from its host or embedded\nprocess. The fix ensures that the requested is the owner of the\nInputTransferToken. This adds an additional verification on top of\nthe existing  association checks between the transferFrom and\ntransferTo processes.\n\nFlag: EXEMPT security fix\nBug: 364037868\nTest: presubmit\nChange-Id: I2654ccab807a62a341c8af69bf64bb33e56c4252\n---\n .../android/server/wm/EmbeddedWindowController.java  | 12 ++++++++++--\n .../com/android/server/wm/WindowManagerService.java  |  9 +++++++--\n 2 files changed, 17 insertions(+), 4 deletions(-)\n\ndiff --git a/services/core/java/com/android/server/wm/EmbeddedWindowController.java b/services/core/java/com/android/server/wm/EmbeddedWindowController.java\nindex 5514294ed477..e007b1d07b34 100644\n--- a/services/core/java/com/android/server/wm/EmbeddedWindowController.java\n+++ b/services/core/java/com/android/server/wm/EmbeddedWindowController.java\n@@ -181,22 +181,30 @@ class EmbeddedWindowController {\n         return true;\n     }\n \n-    boolean transferToHost(@NonNull InputTransferToken embeddedWindowToken,\n+    boolean transferToHost(int callingUid, @NonNull InputTransferToken embeddedWindowToken,\n             @NonNull WindowState transferToHostWindowState) {\n         EmbeddedWindow ew = getByInputTransferToken(embeddedWindowToken);\n         if (!isValidTouchGestureParams(transferToHostWindowState, ew)) {\n             return false;\n         }\n+        if (callingUid != ew.mOwnerUid) {\n+            throw new SecurityException(\n+                    \"Transfer request must originate from owner of transferFromToken\");\n+        }\n         return mInputManagerService.transferTouchGesture(ew.getInputChannelToken(),\n                 transferToHostWindowState.mInputChannelToken);\n     }\n \n-    boolean transferToEmbedded(WindowState hostWindowState,\n+    boolean transferToEmbedded(int callingUid, WindowState hostWindowState,\n             @NonNull InputTransferToken transferToToken) {\n         final EmbeddedWindowController.EmbeddedWindow ew = getByInputTransferToken(transferToToken);\n         if (!isValidTouchGestureParams(hostWindowState, ew)) {\n             return false;\n         }\n+        if (callingUid != hostWindowState.mOwnerUid) {\n+            throw new SecurityException(\n+                    \"Transfer request must originate from owner of transferFromToken\");\n+        }\n         return mInputManagerService.transferTouchGesture(hostWindowState.mInputChannelToken,\n                 ew.getInputChannelToken());\n     }\ndiff --git a/services/core/java/com/android/server/wm/WindowManagerService.java b/services/core/java/com/android/server/wm/WindowManagerService.java\nindex 33f2dd103c2e..b8f47cce6005 100644\n--- a/services/core/java/com/android/server/wm/WindowManagerService.java\n+++ b/services/core/java/com/android/server/wm/WindowManagerService.java\n@@ -9212,6 +9212,8 @@ public class WindowManagerService extends IWindowManager.Stub\n         final InputApplicationHandle applicationHandle;\n         final String name;\n         Objects.requireNonNull(outInputChannel);\n+        Objects.requireNonNull(inputTransferToken);\n+\n         synchronized (mGlobalLock) {\n             WindowState hostWindowState = hostInputTransferToken != null\n                     ? mInputToWindowMap.get(hostInputTransferToken.getToken()) : null;\n@@ -9236,6 +9238,7 @@ public class WindowManagerService extends IWindowManager.Stub\n         Objects.requireNonNull(transferFromToken);\n         Objects.requireNonNull(transferToToken);\n \n+        final int callingUid = Binder.getCallingUid();\n         final long identity = Binder.clearCallingIdentity();\n         boolean didTransfer;\n         try {\n@@ -9245,12 +9248,14 @@ public class WindowManagerService extends IWindowManager.Stub\n                 // represents an embedded window so transfer from host to embedded.\n                 WindowState windowStateTo = mInputToWindowMap.get(transferToToken.getToken());\n                 if (windowStateTo != null) {\n-                    didTransfer = mEmbeddedWindowController.transferToHost(transferFromToken,\n+                    didTransfer = mEmbeddedWindowController.transferToHost(callingUid,\n+                            transferFromToken,\n                             windowStateTo);\n                 } else {\n                     WindowState windowStateFrom = mInputToWindowMap.get(\n                             transferFromToken.getToken());\n-                    didTransfer = mEmbeddedWindowController.transferToEmbedded(windowStateFrom,\n+                    didTransfer = mEmbeddedWindowController.transferToEmbedded(callingUid,\n+                            windowStateFrom,\n                             transferToToken);\n                 }\n             }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 1086,
                        "general": {
                            "word_based": 432,
                            "char_based": 1270
                        },
                        "gemini": 1339
                    },
                    "total_downstream_versions_tested": 0,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": []
                }
            ]
        },
        {
            "id": "ASB-A-375407167",
            "aliases": [
                "A-375407167",
                "CVE-2025-0075"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-375407167",
            "severity": "Critical",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "d62bf15de2fb8161bab7067f6e8704452bd52460"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From d62bf15de2fb8161bab7067f6e8704452bd52460 Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Thu, 31 Oct 2024 00:05:16 +0000\nSubject: [PATCH] Fix incorrect logging in sdp_server\n\nIn the function process_service_search_attr_req of sdp_server.cc, a log\nstatement uses a structure that may, in exceptional cases, have been\nfreed by preceding calls.  This can lead to use after free and\npotentially to security vulnerabilities.\n\nUse local variables instead.\n\nBug: 375407167\nTest: m libbluetooth\nTest: researcher POC\nFlag: EXEMPT trivial logic fix\nIgnore-AOSP-First: security\nTag: #security\nChange-Id: I04a295f3c451267aaad0f0d22401b9f5b5510d83\n---\n system/stack/sdp/sdp_server.cc | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/system/stack/sdp/sdp_server.cc b/system/stack/sdp/sdp_server.cc\nindex 58a17727cf..0ebe890dd6 100644\n--- a/system/stack/sdp/sdp_server.cc\n+++ b/system/stack/sdp/sdp_server.cc\n@@ -924,7 +924,7 @@ static void process_service_search_attr_req(tCONN_CB* p_ccb, uint16_t trans_num,\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_buf) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_buf->len);\n+              p_ccb->connection_id, p_rsp - p_rsp_start);\n   }\n }\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 454,
                        "general": {
                            "word_based": 183,
                            "char_based": 350
                        },
                        "gemini": 573
                    },
                    "total_downstream_versions_tested": 0,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": []
                }
            ]
        },
        {
            "id": "ASB-A-317203980",
            "aliases": [
                "A-317203980",
                "CVE-2025-22437"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-317203980",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "fda5a94aaf91933f8602e00d78ad9ba4872c72f4"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From fda5a94aaf91933f8602e00d78ad9ba4872c72f4 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Iv=C3=A1n=20Budnik?= <ivanbuper@google.com>\nDate: Wed, 21 Jun 2023 16:34:37 +0000\nSubject: [PATCH] Prevent media button receivers targeting activities\n\nThis enforcement prevents a bypass of background activity launches.\n\nBug: 272737196\nTest: atest MediaSessionHostTest MediaSessionTest\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:edf219ab08fdf5390aac6dd18fcdab76daa3488a)\nChange-Id: I07c2521f3d97f94e245a25bbb6f49f75cf54a808\n---\n .../android/media/session/MediaSession.java   | 28 ++++++++++++-------\n .../server/media/MediaSessionRecord.java      | 25 ++++++++++++++++-\n 2 files changed, 42 insertions(+), 11 deletions(-)\n\ndiff --git a/media/java/android/media/session/MediaSession.java b/media/java/android/media/session/MediaSession.java\nindex af33149867bd..f664fdc949de 100644\n--- a/media/java/android/media/session/MediaSession.java\n+++ b/media/java/android/media/session/MediaSession.java\n@@ -267,25 +267,33 @@ public final class MediaSession {\n     }\n \n     /**\n-     * Set a pending intent for your media button receiver to allow restarting\n-     * playback after the session has been stopped. If your app is started in\n-     * this way an {@link Intent#ACTION_MEDIA_BUTTON} intent will be sent via\n-     * the pending intent.\n-     * <p>\n-     * The pending intent is recommended to be explicit to follow the security recommendation of\n-     * {@link PendingIntent#getActivity}.\n+     * Set a pending intent for your media button receiver to allow restarting playback after the\n+     * session has been stopped.\n      *\n-     * @param mbr The {@link PendingIntent} to send the media button event to.\n-     * @see PendingIntent#getActivity\n+     * <p>If your app is started in this way an {@link Intent#ACTION_MEDIA_BUTTON} intent will be\n+     * sent via the pending intent.\n+     *\n+     * <p>The provided {@link PendingIntent} must not target an activity. On apps targeting Android\n+     * V and above, passing an activity pending intent to this method causes an {@link\n+     * IllegalArgumentException}. On apps targeting Android U and below, passing an activity pending\n+     * intent causes the call to be ignored. Refer to this <a\n+     * href=\"https://developer.android.com/guide/components/activities/background-starts\">guide</a>\n+     * for more information.\n      *\n+     * <p>The pending intent is recommended to be explicit to follow the security recommendation of\n+     * {@link PendingIntent#getService}.\n+     *\n+     * @param mbr The {@link PendingIntent} to send the media button event to.\n      * @deprecated Use {@link #setMediaButtonBroadcastReceiver(ComponentName)} instead.\n+     * @throws IllegalArgumentException if the pending intent targets an activity on apps targeting\n+     * Android V and above.\n      */\n     @Deprecated\n     public void setMediaButtonReceiver(@Nullable PendingIntent mbr) {\n         try {\n             mBinder.setMediaButtonReceiver(mbr);\n         } catch (RemoteException e) {\n-            Log.wtf(TAG, \"Failure in setMediaButtonReceiver.\", e);\n+            e.rethrowFromSystemServer();\n         }\n     }\n \ndiff --git a/services/core/java/com/android/server/media/MediaSessionRecord.java b/services/core/java/com/android/server/media/MediaSessionRecord.java\nindex 9185a00da570..95ca08cc7fe9 100644\n--- a/services/core/java/com/android/server/media/MediaSessionRecord.java\n+++ b/services/core/java/com/android/server/media/MediaSessionRecord.java\n@@ -106,6 +106,16 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n     @EnabledSince(targetSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)\n     static final long THROW_FOR_INVALID_BROADCAST_RECEIVER = 270049379L;\n \n+    /**\n+     * {@link MediaSession#setMediaButtonReceiver(PendingIntent)} throws an {@link\n+     * IllegalArgumentException} if the provided {@link PendingIntent} targets an {@link\n+     * android.app.Activity activity} for apps targeting Android V and above. For apps targeting\n+     * Android U and below, the request will be ignored.\n+     */\n+    @ChangeId\n+    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.VANILLA_ICE_CREAM)\n+    static final long THROW_FOR_ACTIVITY_MEDIA_BUTTON_RECEIVER = 272737196L;\n+\n     private static final String TAG = \"MediaSessionRecord\";\n     private static final String[] ART_URIS = new String[] {\n             MediaMetadata.METADATA_KEY_ALBUM_ART_URI,\n@@ -1055,13 +1065,26 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n         }\n \n         @Override\n-        public void setMediaButtonReceiver(PendingIntent pi) throws RemoteException {\n+        public void setMediaButtonReceiver(@Nullable PendingIntent pi) throws RemoteException {\n+            final int uid = Binder.getCallingUid();\n             final long token = Binder.clearCallingIdentity();\n             try {\n                 if ((mPolicies & MediaSessionPolicyProvider.SESSION_POLICY_IGNORE_BUTTON_RECEIVER)\n                         != 0) {\n                     return;\n                 }\n+\n+                if (pi != null && pi.isActivity()) {\n+                    if (CompatChanges.isChangeEnabled(\n+                            THROW_FOR_ACTIVITY_MEDIA_BUTTON_RECEIVER, uid)) {\n+                        throw new IllegalArgumentException(\n+                                \"The media button receiver cannot be set to an activity.\");\n+                    } else {\n+                        Log.w(TAG, \"Ignoring invalid media button receiver targeting an activity.\");\n+                        return;\n+                    }\n+                }\n+\n                 mMediaButtonReceiverHolder =\n                         MediaButtonReceiverHolder.create(mUserId, pi, mPackageName);\n                 mService.onMediaButtonReceiverChanged(MediaSessionRecord.this);\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 1369,
                        "general": {
                            "word_based": 612,
                            "char_based": 1477
                        },
                        "gemini": 1687
                    },
                    "total_downstream_versions_tested": 1,
                    "successful_patches": 0,
                    "failed_patches": 1,
                    "patch_results": [
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "4a1e3f85e00b0b7eba35f70096efe3dbd5287e7f",
                            "repo_path": "android_repos/base",
                            "result": "failure",
                            "downstream_patch_content": "commit 4a1e3f85e00b0b7eba35f70096efe3dbd5287e7f\nAuthor: Iv\u00e1n Budnik <ivanbuper@google.com>\nDate:   Wed Aug 16 16:32:55 2023 +0000\n\n    Prevent media button receivers targeting activities\n    \n    This enforcement prevents a bypass of background activity launches. For\n    versions before Android V, the enforcement just ignores the request and\n    logs a warning.\n    \n    This change is a backport of ag/23810567.\n    \n    Test: Manually.\n    Bug: 272737196\n    Bug: 272024837\n    Bug: 317203980\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:d455e21711c167223f7d0696809a4e411683182c)\n    Merged-In: I2412633c0b3afda6776244c72043d0dd78a4c8a1\n    Change-Id: I2412633c0b3afda6776244c72043d0dd78a4c8a1\n\ndiff --git a/media/java/android/media/session/MediaSession.java b/media/java/android/media/session/MediaSession.java\nindex a14999df666c..7c1b26d904e4 100644\n--- a/media/java/android/media/session/MediaSession.java\n+++ b/media/java/android/media/session/MediaSession.java\n@@ -270,17 +270,22 @@ public final class MediaSession {\n     }\n \n     /**\n-     * Set a pending intent for your media button receiver to allow restarting\n-     * playback after the session has been stopped. If your app is started in\n-     * this way an {@link Intent#ACTION_MEDIA_BUTTON} intent will be sent via\n-     * the pending intent.\n-     * <p>\n-     * The pending intent is recommended to be explicit to follow the security recommendation of\n-     * {@link PendingIntent#getActivity}.\n+     * Set a pending intent for your media button receiver to allow restarting playback after the\n+     * session has been stopped.\n+     *\n+     * <p>If your app is started in this way an {@link Intent#ACTION_MEDIA_BUTTON} intent will be\n+     * sent via the pending intent.\n+     *\n+     * <p>The provided {@link PendingIntent} must not target an activity. Passing an activity\n+     * pending intent will cause the call to be ignored. Refer to this <a\n+     * href=\"https://developer.android.com/guide/components/activities/background-starts\">guide</a>\n+     * for more information.\n+     *\n+     * <p>The pending intent is recommended to be explicit to follow the security recommendation of\n+     * {@link PendingIntent#getService}.\n      *\n      * @param mbr The {@link PendingIntent} to send the media button event to.\n      * @see PendingIntent#getActivity\n-     *\n      * @deprecated Use {@link #setMediaButtonBroadcastReceiver(ComponentName)} instead.\n      */\n     @Deprecated\n@@ -288,7 +293,7 @@ public final class MediaSession {\n         try {\n             mBinder.setMediaButtonReceiver(mbr);\n         } catch (RemoteException e) {\n-            Log.wtf(TAG, \"Failure in setMediaButtonReceiver.\", e);\n+            e.rethrowFromSystemServer();\n         }\n     }\n \ndiff --git a/services/core/java/com/android/server/media/MediaSessionRecord.java b/services/core/java/com/android/server/media/MediaSessionRecord.java\nindex becb944101f2..7db5bf261fe2 100644\n--- a/services/core/java/com/android/server/media/MediaSessionRecord.java\n+++ b/services/core/java/com/android/server/media/MediaSessionRecord.java\n@@ -973,6 +973,14 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n                         != 0) {\n                     return;\n                 }\n+\n+                if (pi != null && pi.isActivity()) {\n+                    Log.w(\n+                            TAG,\n+                            \"Ignoring invalid media button receiver targeting an activity: \" + pi);\n+                    return;\n+                }\n+\n                 mMediaButtonReceiverHolder =\n                         MediaButtonReceiverHolder.create(mUserId, pi, mPackageName);\n                 mService.onMediaButtonReceiverChanged(MediaSessionRecord.this);\n",
                            "downstream_patch_tokens": {
                                "openai": 932,
                                "general": {
                                    "word_based": 416,
                                    "char_based": 945
                                },
                                "gemini": 1186
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "services/core/java/com/android/server/media/MediaSessionRecord.java",
                                    "total_hunks": 2,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n\n                if (pi != null && pi.isActivity()) {\n                    if (CompatChanges.isChangeEnabled(\n                            THROW_FOR_ACTIVITY_MEDIA_BUTTON_RECEIVER, uid)) {\n                        throw new IllegalArgumentException(\n                                \"The media button receiver cannot be set to an activity.\");\n                    } else {\n                        Log.w(TAG, \"Ignoring invalid media button receiver targeting an activity.\");\n                        return;\n                    }\n                }\n\n                mMediaButtonReceiverHolder =\n                        MediaButtonReceiverHolder.create(mUserId, pi, mPackageName);\n                mService.onMediaButtonReceiverChanged(MediaSessionRecord.this);\n>>>>>>> UPSTREAM PATCH (commit fda5a94aaf91933f8602e00d78ad9ba4872c72f4)",
                                            "merge_conflict_tokens": {
                                                "openai": 153,
                                                "general": {
                                                    "word_based": 53,
                                                    "char_based": 216
                                                },
                                                "gemini": 194
                                            }
                                        }
                                    ],
                                    "inline_merge_token_summary": {
                                        "gemini": 2910,
                                        "openai": 2448,
                                        "general_word": 848,
                                        "general_char": 3456
                                    },
                                    "rej_file_content": "```diff\n--- services/core/java/com/android/server/media/MediaSessionRecord.java\n+++ services/core/java/com/android/server/media/MediaSessionRecord.java\n@@ -106,6 +106,16 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n     @EnabledSince(targetSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)\n     static final long THROW_FOR_INVALID_BROADCAST_RECEIVER = 270049379L;\n \n+    /**\n+     * {@link MediaSession#setMediaButtonReceiver(PendingIntent)} throws an {@link\n+     * IllegalArgumentException} if the provided {@link PendingIntent} targets an {@link\n+     * android.app.Activity activity} for apps targeting Android V and above. For apps targeting\n+     * Android U and below, the request will be ignored.\n+     */\n+    @ChangeId\n+    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.VANILLA_ICE_CREAM)\n+    static final long THROW_FOR_ACTIVITY_MEDIA_BUTTON_RECEIVER = 272737196L;\n+\n     private static final String TAG = \"MediaSessionRecord\";\n     private static final String[] ART_URIS = new String[] {\n             MediaMetadata.METADATA_KEY_ALBUM_ART_URI,\n```",
                                    "rej_file_tokens": {
                                        "openai": 253,
                                        "general": {
                                            "word_based": 104,
                                            "char_based": 273
                                        },
                                        "gemini": 319
                                    },
                                    "patch_apply_output": "patching file media/java/android/media/session/MediaSession.java\nHunk #1 succeeded at 270 (offset 3 lines).\npatching file services/core/java/com/android/server/media/MediaSessionRecord.java\nHunk #1 FAILED at 106.\nHunk #2 succeeded at 966 (offset -89 lines).\n1 out of 2 hunks FAILED -- saving rejects to file services/core/java/com/android/server/media/MediaSessionRecord.java.rej",
                                    "inline_merge_output": "patching file services/core/java/com/android/server/media/MediaSessionRecord.java\nHunk #1 merged at 119-128.\nHunk #2 already applied at 1078-1079, NOT MERGED at 1086-1103.",
                                    "upstream_file_tokens": {
                                        "openai": 15015,
                                        "general": {
                                            "word_based": 6015,
                                            "char_based": 19875
                                        },
                                        "gemini": 17723
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2014 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.media;\n\nimport android.Manifest;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.RequiresPermission;\nimport android.app.PendingIntent;\nimport android.content.ComponentName;\nimport android.content.ContentProvider;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.ResolveInfo;\nimport android.media.AudioAttributes;\nimport android.media.AudioManager;\nimport android.media.AudioSystem;\nimport android.media.MediaMetadata;\nimport android.media.MediaRouter2Manager;\nimport android.media.Rating;\nimport android.media.RoutingSessionInfo;\nimport android.media.VolumeProvider;\nimport android.media.session.ISession;\nimport android.media.session.ISessionCallback;\nimport android.media.session.ISessionController;\nimport android.media.session.ISessionControllerCallback;\nimport android.media.session.MediaController;\nimport android.media.session.MediaController.PlaybackInfo;\nimport android.media.session.MediaSession;\nimport android.media.session.MediaSession.QueueItem;\nimport android.media.session.ParcelableListBinder;\nimport android.media.session.PlaybackState;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.DeadObjectException;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.text.TextUtils;\nimport android.util.EventLog;\nimport android.util.Log;\nimport android.view.KeyEvent;\n\nimport com.android.server.LocalServices;\nimport com.android.server.uri.UriGrantsManagerInternal;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n * This is the system implementation of a Session. Apps will interact with the\n * MediaSession wrapper class instead.\n */\n// TODO(jaewan): Do not call service method directly -- introduce listener instead.\npublic class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionRecordImpl {\n    private static final String TAG = \"MediaSessionRecord\";\n    private static final String[] ART_URIS = new String[] {\n            MediaMetadata.METADATA_KEY_ALBUM_ART_URI,\n            MediaMetadata.METADATA_KEY_ART_URI,\n            MediaMetadata.METADATA_KEY_DISPLAY_ICON_URI};\n    private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);\n\n    /**\n     * The amount of time we'll send an assumed volume after the last volume\n     * command before reverting to the last reported volume.\n     */\n    private static final int OPTIMISTIC_VOLUME_TIMEOUT = 1000;\n\n    /**\n     * These are states that usually indicate the user took an action and should\n     * bump priority regardless of the old state.\n     */\n    private static final List<Integer> ALWAYS_PRIORITY_STATES = Arrays.asList(\n            PlaybackState.STATE_FAST_FORWARDING,\n            PlaybackState.STATE_REWINDING,\n            PlaybackState.STATE_SKIPPING_TO_PREVIOUS,\n            PlaybackState.STATE_SKIPPING_TO_NEXT);\n    /**\n     * These are states that usually indicate the user took an action if they\n     * were entered from a non-priority state.\n     */\n    private static final List<Integer> TRANSITION_PRIORITY_STATES = Arrays.asList(\n            PlaybackState.STATE_BUFFERING,\n            PlaybackState.STATE_CONNECTING,\n            PlaybackState.STATE_PLAYING);\n\n    private static final AudioAttributes DEFAULT_ATTRIBUTES =\n            new AudioAttributes.Builder().setUsage(AudioAttributes.USAGE_MEDIA).build();\n\n    private static int getVolumeStream(@Nullable AudioAttributes attr) {\n        if (attr == null) {\n            return DEFAULT_ATTRIBUTES.getVolumeControlStream();\n        }\n        final int stream = attr.getVolumeControlStream();\n        if (stream == AudioManager.USE_DEFAULT_STREAM_TYPE) {\n            return DEFAULT_ATTRIBUTES.getVolumeControlStream();\n        }\n        return stream;\n    }\n\n    private final MessageHandler mHandler;\n\n    private final int mOwnerPid;\n    private final int mOwnerUid;\n    private final int mUserId;\n    private final String mPackageName;\n    private final String mTag;\n    private final Bundle mSessionInfo;\n    private final ControllerStub mController;\n    private final MediaSession.Token mSessionToken;\n    private final SessionStub mSession;\n    private final SessionCb mSessionCb;\n    private final MediaSessionService mService;\n    private final UriGrantsManagerInternal mUgmInternal;\n    private final Context mContext;\n    private final boolean mVolumeAdjustmentForRemoteGroupSessions;\n\n    private final Object mLock = new Object();\n    private final CopyOnWriteArrayList<ISessionControllerCallbackHolder>\n            mControllerCallbackHolders = new CopyOnWriteArrayList<>();\n\n    private long mFlags;\n    private MediaButtonReceiverHolder mMediaButtonReceiverHolder;\n    private PendingIntent mLaunchIntent;\n\n    // TransportPerformer fields\n    private Bundle mExtras;\n    // Note: Avoid unparceling the bundle inside MediaMetadata since unparceling in system process\n    // may result in throwing an exception.\n    private MediaMetadata mMetadata;\n    private PlaybackState mPlaybackState;\n    private List<QueueItem> mQueue;\n    private CharSequence mQueueTitle;\n    private int mRatingType;\n    // End TransportPerformer fields\n\n    // Volume handling fields\n    private AudioAttributes mAudioAttrs;\n    private AudioManager mAudioManager;\n    private int mVolumeType = PlaybackInfo.PLAYBACK_TYPE_LOCAL;\n    private int mVolumeControlType = VolumeProvider.VOLUME_CONTROL_ABSOLUTE;\n    private int mMaxVolume = 0;\n    private int mCurrentVolume = 0;\n    private int mOptimisticVolume = -1;\n    private String mVolumeControlId;\n    // End volume handling fields\n\n    private boolean mIsActive = false;\n    private boolean mDestroyed = false;\n\n    private long mDuration = -1;\n    private String mMetadataDescription;\n\n    private int mPolicies;\n\n    public MediaSessionRecord(int ownerPid, int ownerUid, int userId, String ownerPackageName,\n            ISessionCallback cb, String tag, Bundle sessionInfo,\n            MediaSessionService service, Looper handlerLooper, int policies)\n            throws RemoteException {\n        mOwnerPid = ownerPid;\n        mOwnerUid = ownerUid;\n        mUserId = userId;\n        mPackageName = ownerPackageName;\n        mTag = tag;\n        mSessionInfo = sessionInfo;\n        mController = new ControllerStub();\n        mSessionToken = new MediaSession.Token(ownerUid, mController);\n        mSession = new SessionStub();\n        mSessionCb = new SessionCb(cb);\n        mService = service;\n        mContext = mService.getContext();\n        mHandler = new MessageHandler(handlerLooper);\n        mAudioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);\n        mAudioAttrs = DEFAULT_ATTRIBUTES;\n        mPolicies = policies;\n        mUgmInternal = LocalServices.getService(UriGrantsManagerInternal.class);\n        mVolumeAdjustmentForRemoteGroupSessions = mContext.getResources().getBoolean(\n                com.android.internal.R.bool.config_volumeAdjustmentForRemoteGroupSessions);\n\n        // May throw RemoteException if the session app is killed.\n        mSessionCb.mCb.asBinder().linkToDeath(this, 0);\n    }\n\n    /**\n     * Get the session binder for the {@link MediaSession}.\n     *\n     * @return The session binder apps talk to.\n     */\n    public ISession getSessionBinder() {\n        return mSession;\n    }\n\n    /**\n     * Get the session token for creating {@link MediaController}.\n     *\n     * @return The session token.\n     */\n    public MediaSession.Token getSessionToken() {\n        return mSessionToken;\n    }\n\n    /**\n     * Get the info for this session.\n     *\n     * @return Info that identifies this session.\n     */\n    @Override\n    public String getPackageName() {\n        return mPackageName;\n    }\n\n    /**\n     * Get the intent the app set for their media button receiver.\n     *\n     * @return The pending intent set by the app or null.\n     */\n    public MediaButtonReceiverHolder getMediaButtonReceiver() {\n        return mMediaButtonReceiverHolder;\n    }\n\n    /**\n     * Get the UID this session was created for.\n     *\n     * @return The UID for this session.\n     */\n    @Override\n    public int getUid() {\n        return mOwnerUid;\n    }\n\n    /**\n     * Get the user id this session was created for.\n     *\n     * @return The user id for this session.\n     */\n    @Override\n    public int getUserId() {\n        return mUserId;\n    }\n\n    /**\n     * Check if this session has system priorty and should receive media buttons\n     * before any other sessions.\n     *\n     * @return True if this is a system priority session, false otherwise\n     */\n    @Override\n    public boolean isSystemPriority() {\n        return (mFlags & MediaSession.FLAG_EXCLUSIVE_GLOBAL_PRIORITY) != 0;\n    }\n\n    /**\n     * Send a volume adjustment to the session owner. Direction must be one of\n     * {@link AudioManager#ADJUST_LOWER}, {@link AudioManager#ADJUST_RAISE},\n     * {@link AudioManager#ADJUST_SAME}.\n     *\n     * @param packageName The package that made the original volume request.\n     * @param opPackageName The op package that made the original volume request.\n     * @param pid The pid that made the original volume request.\n     * @param uid The uid that made the original volume request.\n     * @param asSystemService {@code true} if the event sent to the session as if it was come from\n     *          the system service instead of the app process. This helps sessions to distinguish\n     *          between the key injection by the app and key events from the hardware devices.\n     *          Should be used only when the volume key events aren't handled by foreground\n     *          activity. {@code false} otherwise to tell session about the real caller.\n     * @param direction The direction to adjust volume in.\n     * @param flags Any of the flags from {@link AudioManager}.\n     * @param useSuggested True to use adjustSuggestedStreamVolumeForUid instead of\n     *          adjustStreamVolumeForUid\n     */\n    public void adjustVolume(String packageName, String opPackageName, int pid, int uid,\n            boolean asSystemService, int direction, int flags, boolean useSuggested) {\n        int previousFlagPlaySound = flags & AudioManager.FLAG_PLAY_SOUND;\n        if (checkPlaybackActiveState(true) || isSystemPriority()) {\n            flags &= ~AudioManager.FLAG_PLAY_SOUND;\n        }\n        if (mVolumeType == PlaybackInfo.PLAYBACK_TYPE_LOCAL) {\n            // Adjust the volume with a handler not to be blocked by other system service.\n            int stream = getVolumeStream(mAudioAttrs);\n            postAdjustLocalVolume(stream, direction, flags, opPackageName, pid, uid,\n                    asSystemService, useSuggested, previousFlagPlaySound);\n        } else {\n            if (mVolumeControlType == VolumeProvider.VOLUME_CONTROL_FIXED) {\n                if (DEBUG) {\n                    Log.d(TAG, \"Session does not support volume adjustment\");\n                }\n            } else if (direction == AudioManager.ADJUST_TOGGLE_MUTE\n                    || direction == AudioManager.ADJUST_MUTE\n                    || direction == AudioManager.ADJUST_UNMUTE) {\n                Log.w(TAG, \"Muting remote playback is not supported\");\n            } else {\n                if (DEBUG) {\n                    Log.w(TAG, \"adjusting volume, pkg=\" + packageName + \", asSystemService=\"\n                            + asSystemService + \", dir=\" + direction);\n                }\n                mSessionCb.adjustVolume(packageName, pid, uid, asSystemService, direction);\n\n                int volumeBefore = (mOptimisticVolume < 0 ? mCurrentVolume : mOptimisticVolume);\n                mOptimisticVolume = volumeBefore + direction;\n                mOptimisticVolume = Math.max(0, Math.min(mOptimisticVolume, mMaxVolume));\n                mHandler.removeCallbacks(mClearOptimisticVolumeRunnable);\n                mHandler.postDelayed(mClearOptimisticVolumeRunnable, OPTIMISTIC_VOLUME_TIMEOUT);\n                if (volumeBefore != mOptimisticVolume) {\n                    pushVolumeUpdate();\n                }\n\n                if (DEBUG) {\n                    Log.d(TAG, \"Adjusted optimistic volume to \" + mOptimisticVolume + \" max is \"\n                            + mMaxVolume);\n                }\n            }\n            // Always notify, even if the volume hasn't changed. This is important to ensure that\n            // System UI receives an event if a hardware volume key is pressed but the session that\n            // handles it does not allow volume adjustment. Without such an event, System UI would\n            // not show volume controls to the user.\n            mService.notifyRemoteVolumeChanged(flags, this);\n        }\n    }\n\n    private void setVolumeTo(String packageName, String opPackageName, int pid, int uid, int value,\n            int flags) {\n        if (mVolumeType == PlaybackInfo.PLAYBACK_TYPE_LOCAL) {\n            int stream = getVolumeStream(mAudioAttrs);\n            final int volumeValue = value;\n            mHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        mAudioManager.setStreamVolumeForUid(stream, volumeValue, flags,\n                                opPackageName, uid, pid,\n                                mContext.getApplicationInfo().targetSdkVersion);\n                    } catch (IllegalArgumentException | SecurityException e) {\n                        Log.e(TAG, \"Cannot set volume: stream=\" + stream + \", value=\" + volumeValue\n                                + \", flags=\" + flags, e);\n                    }\n                }\n            });\n        } else {\n            if (mVolumeControlType != VolumeProvider.VOLUME_CONTROL_ABSOLUTE) {\n                if (DEBUG) {\n                    Log.d(TAG, \"Session does not support setting volume\");\n                }\n            } else {\n                value = Math.max(0, Math.min(value, mMaxVolume));\n                mSessionCb.setVolumeTo(packageName, pid, uid, value);\n\n                int volumeBefore = (mOptimisticVolume < 0 ? mCurrentVolume : mOptimisticVolume);\n                mOptimisticVolume = Math.max(0, Math.min(value, mMaxVolume));\n                mHandler.removeCallbacks(mClearOptimisticVolumeRunnable);\n                mHandler.postDelayed(mClearOptimisticVolumeRunnable, OPTIMISTIC_VOLUME_TIMEOUT);\n                if (volumeBefore != mOptimisticVolume) {\n                    pushVolumeUpdate();\n                }\n\n                if (DEBUG) {\n                    Log.d(TAG, \"Set optimistic volume to \" + mOptimisticVolume + \" max is \"\n                            + mMaxVolume);\n                }\n            }\n            // Always notify, even if the volume hasn't changed.\n            mService.notifyRemoteVolumeChanged(flags, this);\n        }\n    }\n\n    /**\n     * Check if this session has been set to active by the app.\n     * <p>\n     * It's not used to prioritize sessions for dispatching media keys since API 26, but still used\n     * to filter session list in MediaSessionManager#getActiveSessions().\n     *\n     * @return True if the session is active, false otherwise.\n     */\n    @Override\n    public boolean isActive() {\n        return mIsActive && !mDestroyed;\n    }\n\n    /**\n     * Check if the session's playback active state matches with the expectation. This always return\n     * {@code false} if the playback state is {@code null}, where we cannot know the actual playback\n     * state associated with the session.\n     *\n     * @param expected True if playback is expected to be active. false otherwise.\n     * @return True if the session's playback matches with the expectation. false otherwise.\n     */\n    @Override\n    public boolean checkPlaybackActiveState(boolean expected) {\n        if (mPlaybackState == null) {\n            return false;\n        }\n        return mPlaybackState.isActive() == expected;\n    }\n\n    /**\n     * Get whether the playback is local.\n     *\n     * @return {@code true} if the playback is local.\n     */\n    @Override\n    public boolean isPlaybackTypeLocal() {\n        return mVolumeType == PlaybackInfo.PLAYBACK_TYPE_LOCAL;\n    }\n\n    @Override\n    public void binderDied() {\n        mService.onSessionDied(this);\n    }\n\n    /**\n     * Finish cleaning up this session, including disconnecting if connected and\n     * removing the death observer from the callback binder.\n     */\n    @Override\n    public void close() {\n        synchronized (mLock) {\n            if (mDestroyed) {\n                return;\n            }\n            mSessionCb.mCb.asBinder().unlinkToDeath(this, 0);\n            mDestroyed = true;\n            mPlaybackState = null;\n            mHandler.post(MessageHandler.MSG_DESTROYED);\n        }\n    }\n\n    @Override\n    public boolean isClosed() {\n        synchronized (mLock) {\n            return mDestroyed;\n        }\n    }\n\n    /**\n     * Sends media button.\n     *\n     * @param packageName caller package name\n     * @param pid caller pid\n     * @param uid caller uid\n     * @param asSystemService {@code true} if the event sent to the session as if it was come from\n     *          the system service instead of the app process.\n     * @param ke key events\n     * @param sequenceId (optional) sequence id. Use this only when a wake lock is needed.\n     * @param cb (optional) result receiver to receive callback. Use this only when a wake lock is\n     *           needed.\n     * @return {@code true} if the attempt to send media button was successfully.\n     *         {@code false} otherwise.\n     */\n    public boolean sendMediaButton(String packageName, int pid, int uid, boolean asSystemService,\n            KeyEvent ke, int sequenceId, ResultReceiver cb) {\n        return mSessionCb.sendMediaButton(packageName, pid, uid, asSystemService, ke, sequenceId,\n                cb);\n    }\n\n    @Override\n    public boolean canHandleVolumeKey() {\n        if (isPlaybackTypeLocal() || mVolumeAdjustmentForRemoteGroupSessions) {\n            return true;\n        }\n        MediaRouter2Manager mRouter2Manager = MediaRouter2Manager.getInstance(mContext);\n        List<RoutingSessionInfo> sessions =\n                mRouter2Manager.getRoutingSessions(mPackageName);\n        boolean foundNonSystemSession = false;\n        boolean isGroup = false;\n        for (RoutingSessionInfo session : sessions) {\n            if (!session.isSystemSession()) {\n                foundNonSystemSession = true;\n                int selectedRouteCount = session.getSelectedRoutes().size();\n                if (selectedRouteCount > 1) {\n                    isGroup = true;\n                    break;\n                }\n            }\n        }\n        if (!foundNonSystemSession) {\n            Log.d(TAG, \"No routing session for \" + mPackageName);\n            return false;\n        }\n        return !isGroup;\n    }\n\n    @Override\n    public int getSessionPolicies() {\n        synchronized (mLock) {\n            return mPolicies;\n        }\n    }\n\n    @Override\n    public void setSessionPolicies(int policies) {\n        synchronized (mLock) {\n            mPolicies = policies;\n        }\n    }\n\n    @Override\n    public void dump(PrintWriter pw, String prefix) {\n        pw.println(prefix + mTag + \" \" + this);\n\n        final String indent = prefix + \"  \";\n        pw.println(indent + \"ownerPid=\" + mOwnerPid + \", ownerUid=\" + mOwnerUid\n                + \", userId=\" + mUserId);\n        pw.println(indent + \"package=\" + mPackageName);\n        pw.println(indent + \"launchIntent=\" + mLaunchIntent);\n        pw.println(indent + \"mediaButtonReceiver=\" + mMediaButtonReceiverHolder);\n        pw.println(indent + \"active=\" + mIsActive);\n        pw.println(indent + \"flags=\" + mFlags);\n        pw.println(indent + \"rating type=\" + mRatingType);\n        pw.println(indent + \"controllers: \" + mControllerCallbackHolders.size());\n        pw.println(indent + \"state=\" + (mPlaybackState == null ? null : mPlaybackState.toString()));\n        pw.println(indent + \"audioAttrs=\" + mAudioAttrs);\n        pw.println(indent + \"volumeType=\" + mVolumeType + \", controlType=\" + mVolumeControlType\n                + \", max=\" + mMaxVolume + \", current=\" + mCurrentVolume);\n        pw.println(indent + \"metadata: \" + mMetadataDescription);\n        pw.println(indent + \"queueTitle=\" + mQueueTitle + \", size=\"\n                + (mQueue == null ? 0 : mQueue.size()));\n    }\n\n    @Override\n    public String toString() {\n        return mPackageName + \"/\" + mTag + \" (userId=\" + mUserId + \")\";\n    }\n\n    private void postAdjustLocalVolume(final int stream, final int direction, final int flags,\n            final String callingOpPackageName, final int callingPid, final int callingUid,\n            final boolean asSystemService, final boolean useSuggested,\n            final int previousFlagPlaySound) {\n        if (DEBUG) {\n            Log.w(TAG, \"adjusting local volume, stream=\" + stream + \", dir=\" + direction\n                    + \", asSystemService=\" + asSystemService + \", useSuggested=\" + useSuggested);\n        }\n        // Must use opPackageName for adjusting volumes with UID.\n        final String opPackageName;\n        final int uid;\n        final int pid;\n        if (asSystemService) {\n            opPackageName = mContext.getOpPackageName();\n            uid = Process.SYSTEM_UID;\n            pid = Process.myPid();\n        } else {\n            opPackageName = callingOpPackageName;\n            uid = callingUid;\n            pid = callingPid;\n        }\n        mHandler.post(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    if (useSuggested) {\n                        if (AudioSystem.isStreamActive(stream, 0)) {\n                            mAudioManager.adjustSuggestedStreamVolumeForUid(stream,\n                                    direction, flags, opPackageName, uid, pid,\n                                    mContext.getApplicationInfo().targetSdkVersion);\n                        } else {\n                            mAudioManager.adjustSuggestedStreamVolumeForUid(\n                                    AudioManager.USE_DEFAULT_STREAM_TYPE, direction,\n                                    flags | previousFlagPlaySound, opPackageName, uid, pid,\n                                    mContext.getApplicationInfo().targetSdkVersion);\n                        }\n                    } else {\n                        mAudioManager.adjustStreamVolumeForUid(stream, direction, flags,\n                                opPackageName, uid, pid,\n                                mContext.getApplicationInfo().targetSdkVersion);\n                    }\n                } catch (IllegalArgumentException | SecurityException e) {\n                    Log.e(TAG, \"Cannot adjust volume: direction=\" + direction + \", stream=\"\n                            + stream + \", flags=\" + flags + \", opPackageName=\" + opPackageName\n                            + \", uid=\" + uid + \", useSuggested=\" + useSuggested\n                            + \", previousFlagPlaySound=\" + previousFlagPlaySound, e);\n                }\n            }\n        });\n    }\n\n    private void logCallbackException(\n            String msg, ISessionControllerCallbackHolder holder, Exception e) {\n        Log.v(TAG, msg + \", this=\" + this + \", callback package=\" + holder.mPackageName\n                + \", exception=\" + e);\n    }\n\n    private void pushPlaybackStateUpdate() {\n        PlaybackState playbackState;\n        synchronized (mLock) {\n            if (mDestroyed) {\n                return;\n            }\n            playbackState = mPlaybackState;\n        }\n        Collection<ISessionControllerCallbackHolder> deadCallbackHolders = null;\n        for (ISessionControllerCallbackHolder holder : mControllerCallbackHolders) {\n            try {\n                holder.mCallback.onPlaybackStateChanged(playbackState);\n            } catch (DeadObjectException e) {\n                if (deadCallbackHolders == null) {\n                    deadCallbackHolders = new ArrayList<>();\n                }\n                deadCallbackHolders.add(holder);\n                logCallbackException(\"Removing dead callback in pushPlaybackStateUpdate\", holder,\n                        e);\n            } catch (RemoteException e) {\n                logCallbackException(\"unexpected exception in pushPlaybackStateUpdate\", holder, e);\n            }\n        }\n        if (deadCallbackHolders != null) {\n            mControllerCallbackHolders.removeAll(deadCallbackHolders);\n        }\n    }\n\n    private void pushMetadataUpdate() {\n        MediaMetadata metadata;\n        synchronized (mLock) {\n            if (mDestroyed) {\n                return;\n            }\n            metadata = mMetadata;\n        }\n        Collection<ISessionControllerCallbackHolder> deadCallbackHolders = null;\n        for (ISessionControllerCallbackHolder holder : mControllerCallbackHolders) {\n            try {\n                holder.mCallback.onMetadataChanged(metadata);\n            } catch (DeadObjectException e) {\n                if (deadCallbackHolders == null) {\n                    deadCallbackHolders = new ArrayList<>();\n                }\n                deadCallbackHolders.add(holder);\n                logCallbackException(\"Removing dead callback in pushMetadataUpdate\", holder, e);\n            } catch (RemoteException e) {\n                logCallbackException(\"unexpected exception in pushMetadataUpdate\", holder, e);\n            }\n        }\n        if (deadCallbackHolders != null) {\n            mControllerCallbackHolders.removeAll(deadCallbackHolders);\n        }\n    }\n\n    private void pushQueueUpdate() {\n        ParceledListSlice<QueueItem> parcelableQueue;\n        synchronized (mLock) {\n            if (mDestroyed) {\n                return;\n            }\n            if (mQueue == null) {\n                parcelableQueue = null;\n            } else {\n                parcelableQueue = new ParceledListSlice<>(mQueue);\n                // Limit the size of initial Parcel to prevent binder buffer overflow\n                // as onQueueChanged is an async binder call.\n                parcelableQueue.setInlineCountLimit(1);\n            }\n        }\n        Collection<ISessionControllerCallbackHolder> deadCallbackHolders = null;\n        for (ISessionControllerCallbackHolder holder : mControllerCallbackHolders) {\n            try {\n                holder.mCallback.onQueueChanged(parcelableQueue);\n            } catch (DeadObjectException e) {\n                if (deadCallbackHolders == null) {\n                    deadCallbackHolders = new ArrayList<>();\n                }\n                deadCallbackHolders.add(holder);\n                logCallbackException(\"Removing dead callback in pushQueueUpdate\", holder, e);\n            } catch (RemoteException e) {\n                logCallbackException(\"unexpected exception in pushQueueUpdate\", holder, e);\n            }\n        }\n        if (deadCallbackHolders != null) {\n            mControllerCallbackHolders.removeAll(deadCallbackHolders);\n        }\n    }\n\n    private void pushQueueTitleUpdate() {\n        CharSequence queueTitle;\n        synchronized (mLock) {\n            if (mDestroyed) {\n                return;\n            }\n            queueTitle = mQueueTitle;\n        }\n        Collection<ISessionControllerCallbackHolder> deadCallbackHolders = null;\n        for (ISessionControllerCallbackHolder holder : mControllerCallbackHolders) {\n            try {\n                holder.mCallback.onQueueTitleChanged(queueTitle);\n            } catch (DeadObjectException e) {\n                if (deadCallbackHolders == null) {\n                    deadCallbackHolders = new ArrayList<>();\n                }\n                deadCallbackHolders.add(holder);\n                logCallbackException(\"Removing dead callback in pushQueueTitleUpdate\", holder, e);\n            } catch (RemoteException e) {\n                logCallbackException(\"unexpected exception in pushQueueTitleUpdate\", holder, e);\n            }\n        }\n        if (deadCallbackHolders != null) {\n            mControllerCallbackHolders.removeAll(deadCallbackHolders);\n        }\n    }\n\n    private void pushExtrasUpdate() {\n        Bundle extras;\n        synchronized (mLock) {\n            if (mDestroyed) {\n                return;\n            }\n            extras = mExtras;\n        }\n        Collection<ISessionControllerCallbackHolder> deadCallbackHolders = null;\n        for (ISessionControllerCallbackHolder holder : mControllerCallbackHolders) {\n            try {\n                holder.mCallback.onExtrasChanged(extras);\n            } catch (DeadObjectException e) {\n                if (deadCallbackHolders == null) {\n                    deadCallbackHolders = new ArrayList<>();\n                }\n                deadCallbackHolders.add(holder);\n                logCallbackException(\"Removing dead callback in pushExtrasUpdate\", holder, e);\n            } catch (RemoteException e) {\n                logCallbackException(\"unexpected exception in pushExtrasUpdate\", holder, e);\n            }\n        }\n        if (deadCallbackHolders != null) {\n            mControllerCallbackHolders.removeAll(deadCallbackHolders);\n        }\n    }\n\n    private void pushVolumeUpdate() {\n        PlaybackInfo info;\n        synchronized (mLock) {\n            if (mDestroyed) {\n                return;\n            }\n            info = getVolumeAttributes();\n        }\n        Collection<ISessionControllerCallbackHolder> deadCallbackHolders = null;\n        for (ISessionControllerCallbackHolder holder : mControllerCallbackHolders) {\n            try {\n                holder.mCallback.onVolumeInfoChanged(info);\n            } catch (DeadObjectException e) {\n                if (deadCallbackHolders == null) {\n                    deadCallbackHolders = new ArrayList<>();\n                }\n                deadCallbackHolders.add(holder);\n                logCallbackException(\"Removing dead callback in pushVolumeUpdate\", holder, e);\n            } catch (RemoteException e) {\n                logCallbackException(\"unexpected exception in pushVolumeUpdate\", holder, e);\n            }\n        }\n        if (deadCallbackHolders != null) {\n            mControllerCallbackHolders.removeAll(deadCallbackHolders);\n        }\n    }\n\n    private void pushEvent(String event, Bundle data) {\n        synchronized (mLock) {\n            if (mDestroyed) {\n                return;\n            }\n        }\n        Collection<ISessionControllerCallbackHolder> deadCallbackHolders = null;\n        for (ISessionControllerCallbackHolder holder : mControllerCallbackHolders) {\n            try {\n                holder.mCallback.onEvent(event, data);\n            } catch (DeadObjectException e) {\n                if (deadCallbackHolders == null) {\n                    deadCallbackHolders = new ArrayList<>();\n                }\n                deadCallbackHolders.add(holder);\n                logCallbackException(\"Removing dead callback in pushEvent\", holder, e);\n            } catch (RemoteException e) {\n                logCallbackException(\"unexpected exception in pushEvent\", holder, e);\n            }\n        }\n        if (deadCallbackHolders != null) {\n            mControllerCallbackHolders.removeAll(deadCallbackHolders);\n        }\n    }\n\n    private void pushSessionDestroyed() {\n        synchronized (mLock) {\n            // This is the only method that may be (and can only be) called\n            // after the session is destroyed.\n            if (!mDestroyed) {\n                return;\n            }\n        }\n        for (ISessionControllerCallbackHolder holder : mControllerCallbackHolders) {\n            try {\n                holder.mCallback.onSessionDestroyed();\n            } catch (DeadObjectException e) {\n                logCallbackException(\"Removing dead callback in pushSessionDestroyed\", holder, e);\n            } catch (RemoteException e) {\n                logCallbackException(\"unexpected exception in pushSessionDestroyed\", holder, e);\n            }\n        }\n        // After notifying clear all listeners\n        mControllerCallbackHolders.clear();\n    }\n\n    private PlaybackState getStateWithUpdatedPosition() {\n        PlaybackState state;\n        long duration;\n        synchronized (mLock) {\n            if (mDestroyed) {\n                return null;\n            }\n            state = mPlaybackState;\n            duration = mDuration;\n        }\n        PlaybackState result = null;\n        if (state != null) {\n            if (state.getState() == PlaybackState.STATE_PLAYING\n                    || state.getState() == PlaybackState.STATE_FAST_FORWARDING\n                    || state.getState() == PlaybackState.STATE_REWINDING) {\n                long updateTime = state.getLastPositionUpdateTime();\n                long currentTime = SystemClock.elapsedRealtime();\n                if (updateTime > 0) {\n                    long position = (long) (state.getPlaybackSpeed()\n                            * (currentTime - updateTime)) + state.getPosition();\n                    if (duration >= 0 && position > duration) {\n                        position = duration;\n                    } else if (position < 0) {\n                        position = 0;\n                    }\n                    PlaybackState.Builder builder = new PlaybackState.Builder(state);\n                    builder.setState(state.getState(), position, state.getPlaybackSpeed(),\n                            currentTime);\n                    result = builder.build();\n                }\n            }\n        }\n        return result == null ? state : result;\n    }\n\n    private int getControllerHolderIndexForCb(ISessionControllerCallback cb) {\n        IBinder binder = cb.asBinder();\n        for (int i = mControllerCallbackHolders.size() - 1; i >= 0; i--) {\n            if (binder.equals(mControllerCallbackHolders.get(i).mCallback.asBinder())) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    private PlaybackInfo getVolumeAttributes() {\n        int volumeType;\n        AudioAttributes attributes;\n        synchronized (mLock) {\n            if (mVolumeType == PlaybackInfo.PLAYBACK_TYPE_REMOTE) {\n                int current = mOptimisticVolume != -1 ? mOptimisticVolume : mCurrentVolume;\n                return new PlaybackInfo(mVolumeType, mVolumeControlType, mMaxVolume, current,\n                        mAudioAttrs, mVolumeControlId);\n            }\n            volumeType = mVolumeType;\n            attributes = mAudioAttrs;\n        }\n        int stream = getVolumeStream(attributes);\n        int max = mAudioManager.getStreamMaxVolume(stream);\n        int current = mAudioManager.getStreamVolume(stream);\n        return new PlaybackInfo(volumeType, VolumeProvider.VOLUME_CONTROL_ABSOLUTE, max,\n                current, attributes, null);\n    }\n\n    private final Runnable mClearOptimisticVolumeRunnable = new Runnable() {\n        @Override\n        public void run() {\n            boolean needUpdate = (mOptimisticVolume != mCurrentVolume);\n            mOptimisticVolume = -1;\n            if (needUpdate) {\n                pushVolumeUpdate();\n            }\n        }\n    };\n\n    @RequiresPermission(Manifest.permission.INTERACT_ACROSS_USERS)\n    private static boolean componentNameExists(\n            @NonNull ComponentName componentName, @NonNull Context context, int userId) {\n        Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);\n        mediaButtonIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n        mediaButtonIntent.setComponent(componentName);\n\n        UserHandle userHandle = UserHandle.of(userId);\n        PackageManager pm = context.getPackageManager();\n\n        List<ResolveInfo> resolveInfos =\n                pm.queryBroadcastReceiversAsUser(\n                        mediaButtonIntent, /* flags */ 0, userHandle);\n        return !resolveInfos.isEmpty();\n    }\n\n    private final class SessionStub extends ISession.Stub {\n        @Override\n        public void destroySession() throws RemoteException {\n            final long token = Binder.clearCallingIdentity();\n            try {\n                mService.onSessionDied(MediaSessionRecord.this);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n        }\n\n        @Override\n        public void sendEvent(String event, Bundle data) throws RemoteException {\n            mHandler.post(MessageHandler.MSG_SEND_EVENT, event,\n                    data == null ? null : new Bundle(data));\n        }\n\n        @Override\n        public ISessionController getController() throws RemoteException {\n            return mController;\n        }\n\n        @Override\n        public void setActive(boolean active) throws RemoteException {\n            mIsActive = active;\n            final long token = Binder.clearCallingIdentity();\n            try {\n                mService.onSessionActiveStateChanged(MediaSessionRecord.this);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            mHandler.post(MessageHandler.MSG_UPDATE_SESSION_STATE);\n        }\n\n        @Override\n        public void setFlags(int flags) throws RemoteException {\n            if ((flags & MediaSession.FLAG_EXCLUSIVE_GLOBAL_PRIORITY) != 0) {\n                int pid = Binder.getCallingPid();\n                int uid = Binder.getCallingUid();\n                mService.enforcePhoneStatePermission(pid, uid);\n            }\n            mFlags = flags;\n            if ((flags & MediaSession.FLAG_EXCLUSIVE_GLOBAL_PRIORITY) != 0) {\n                final long token = Binder.clearCallingIdentity();\n                try {\n                    mService.setGlobalPrioritySession(MediaSessionRecord.this);\n                } finally {\n                    Binder.restoreCallingIdentity(token);\n                }\n            }\n            mHandler.post(MessageHandler.MSG_UPDATE_SESSION_STATE);\n        }\n\n        @Override\n        public void setMediaButtonReceiver(@Nullable PendingIntent pi) throws RemoteException {\n            final int uid = Binder.getCallingUid();\n            final long token = Binder.clearCallingIdentity();\n            try {\n                if ((mPolicies & MediaSessionPolicyProvider.SESSION_POLICY_IGNORE_BUTTON_RECEIVER)\n                        != 0) {\n                    return;\n                }\n\n                if (pi != null && pi.isActivity()) {\n                    if (CompatChanges.isChangeEnabled(\n                            THROW_FOR_ACTIVITY_MEDIA_BUTTON_RECEIVER, uid)) {\n                        throw new IllegalArgumentException(\n                                \"The media button receiver cannot be set to an activity.\");\n                    } else {\n                        Log.w(TAG, \"Ignoring invalid media button receiver targeting an activity.\");\n                        return;\n                    }\n                }\n\n                mMediaButtonReceiverHolder =\n                        MediaButtonReceiverHolder.create(mUserId, pi, mPackageName);\n                mService.onMediaButtonReceiverChanged(MediaSessionRecord.this);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n        }\n\n        @Override\n        @RequiresPermission(Manifest.permission.INTERACT_ACROSS_USERS)\n        public void setMediaButtonBroadcastReceiver(ComponentName receiver) throws RemoteException {\n            final long token = Binder.clearCallingIdentity();\n            try {\n                //mPackageName has been verified in MediaSessionService.enforcePackageName().\n                if (receiver != null && !TextUtils.equals(\n                        mPackageName, receiver.getPackageName())) {\n                    EventLog.writeEvent(0x534e4554, \"238177121\", -1, \"\"); // SafetyNet logging.\n                    throw new IllegalArgumentException(\"receiver does not belong to \"\n                            + \"package name provided to MediaSessionRecord. Pkg = \" + mPackageName\n                            + \", Receiver Pkg = \" + receiver.getPackageName());\n                }\n                if ((mPolicies & MediaSessionPolicyProvider.SESSION_POLICY_IGNORE_BUTTON_RECEIVER)\n                        != 0) {\n                    return;\n                }\n\n                if (!componentNameExists(receiver, mContext, mUserId)) {\n                    Log.w(\n                            TAG,\n                            \"setMediaButtonBroadcastReceiver(): \"\n                                    + \"Ignoring invalid component name=\"\n                                    + receiver);\n                    return;\n                }\n\n                mMediaButtonReceiverHolder = MediaButtonReceiverHolder.create(mUserId, receiver);\n                mService.onMediaButtonReceiverChanged(MediaSessionRecord.this);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n        }\n\n        @Override\n        public void setLaunchPendingIntent(PendingIntent pi) throws RemoteException {\n            mLaunchIntent = pi;\n        }\n\n        @Override\n        public void setMetadata(MediaMetadata metadata, long duration, String metadataDescription)\n                throws RemoteException {\n            synchronized (mLock) {\n                mDuration = duration;\n                mMetadataDescription = metadataDescription;\n                mMetadata = sanitizeMediaMetadata(metadata);\n            }\n            mHandler.post(MessageHandler.MSG_UPDATE_METADATA);\n        }\n\n        private MediaMetadata sanitizeMediaMetadata(MediaMetadata metadata) {\n            if (metadata == null) {\n                return null;\n            }\n            MediaMetadata.Builder metadataBuilder = new MediaMetadata.Builder(metadata);\n            for (String key: ART_URIS) {\n                String uriString = metadata.getString(key);\n                if (TextUtils.isEmpty(uriString)) {\n                    continue;\n                }\n                Uri uri = Uri.parse(uriString);\n                if (!ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())) {\n                    continue;\n                }\n                try {\n                    mUgmInternal.checkGrantUriPermission(getUid(),\n                            getPackageName(),\n                            ContentProvider.getUriWithoutUserId(uri),\n                            Intent.FLAG_GRANT_READ_URI_PERMISSION,\n                            ContentProvider.getUserIdFromUri(uri, getUserId()));\n                } catch (SecurityException e) {\n                    metadataBuilder.putString(key, null);\n                }\n            }\n            MediaMetadata sanitizedMetadata = metadataBuilder.build();\n            // sanitizedMetadata.size() guarantees that the underlying bundle is unparceled\n            // before we set it to prevent concurrent reads from throwing an\n            // exception\n            sanitizedMetadata.size();\n            return sanitizedMetadata;\n        }\n\n        @Override\n        public void setPlaybackState(PlaybackState state) throws RemoteException {\n            int oldState = mPlaybackState == null\n                    ? PlaybackState.STATE_NONE : mPlaybackState.getState();\n            int newState = state == null\n                    ? PlaybackState.STATE_NONE : state.getState();\n            boolean shouldUpdatePriority = ALWAYS_PRIORITY_STATES.contains(newState)\n                    || (!TRANSITION_PRIORITY_STATES.contains(oldState)\n                    && TRANSITION_PRIORITY_STATES.contains(newState));\n            synchronized (mLock) {\n                mPlaybackState = state;\n            }\n            final long token = Binder.clearCallingIdentity();\n            try {\n                mService.onSessionPlaybackStateChanged(\n                        MediaSessionRecord.this, shouldUpdatePriority);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            mHandler.post(MessageHandler.MSG_UPDATE_PLAYBACK_STATE);\n        }\n\n        @Override\n        public void resetQueue() throws RemoteException {\n            synchronized (mLock) {\n                mQueue = null;\n            }\n            mHandler.post(MessageHandler.MSG_UPDATE_QUEUE);\n        }\n\n        @Override\n        public IBinder getBinderForSetQueue() throws RemoteException {\n            return new ParcelableListBinder<QueueItem>(\n                    QueueItem.class,\n                    (list) -> {\n                        synchronized (mLock) {\n                            mQueue = list;\n                        }\n                        mHandler.post(MessageHandler.MSG_UPDATE_QUEUE);\n                    });\n        }\n\n        @Override\n        public void setQueueTitle(CharSequence title) throws RemoteException {\n            mQueueTitle = title;\n            mHandler.post(MessageHandler.MSG_UPDATE_QUEUE_TITLE);\n        }\n\n        @Override\n        public void setExtras(Bundle extras) throws RemoteException {\n            synchronized (mLock) {\n                mExtras = extras == null ? null : new Bundle(extras);\n            }\n            mHandler.post(MessageHandler.MSG_UPDATE_EXTRAS);\n        }\n\n        @Override\n        public void setRatingType(int type) throws RemoteException {\n            mRatingType = type;\n        }\n\n        @Override\n        public void setCurrentVolume(int volume) throws RemoteException {\n            mCurrentVolume = volume;\n            mHandler.post(MessageHandler.MSG_UPDATE_VOLUME);\n        }\n\n        @Override\n        public void setPlaybackToLocal(AudioAttributes attributes) throws RemoteException {\n            boolean typeChanged;\n            synchronized (mLock) {\n                typeChanged = mVolumeType == PlaybackInfo.PLAYBACK_TYPE_REMOTE;\n                mVolumeType = PlaybackInfo.PLAYBACK_TYPE_LOCAL;\n                mVolumeControlId = null;\n                if (attributes != null) {\n                    mAudioAttrs = attributes;\n                } else {\n                    Log.e(TAG, \"Received null audio attributes, using existing attributes\");\n                }\n            }\n            if (typeChanged) {\n                final long token = Binder.clearCallingIdentity();\n                try {\n                    mService.onSessionPlaybackTypeChanged(MediaSessionRecord.this);\n                } finally {\n                    Binder.restoreCallingIdentity(token);\n                }\n                mHandler.post(MessageHandler.MSG_UPDATE_VOLUME);\n            }\n        }\n\n        @Override\n        public void setPlaybackToRemote(int control, int max, String controlId)\n                throws RemoteException {\n            boolean typeChanged;\n            synchronized (mLock) {\n                typeChanged = mVolumeType == PlaybackInfo.PLAYBACK_TYPE_LOCAL;\n                mVolumeType = PlaybackInfo.PLAYBACK_TYPE_REMOTE;\n                mVolumeControlType = control;\n                mMaxVolume = max;\n                mVolumeControlId = controlId;\n            }\n            if (typeChanged) {\n                final long token = Binder.clearCallingIdentity();\n                try {\n                    mService.onSessionPlaybackTypeChanged(MediaSessionRecord.this);\n                } finally {\n                    Binder.restoreCallingIdentity(token);\n                }\n                mHandler.post(MessageHandler.MSG_UPDATE_VOLUME);\n            }\n        }\n    }\n\n    class SessionCb {\n        private final ISessionCallback mCb;\n\n        SessionCb(ISessionCallback cb) {\n            mCb = cb;\n        }\n\n        public boolean sendMediaButton(String packageName, int pid, int uid,\n                boolean asSystemService, KeyEvent keyEvent, int sequenceId, ResultReceiver cb) {\n            try {\n                if (KeyEvent.isMediaSessionKey(keyEvent.getKeyCode())) {\n                    final String reason = \"action=\" + KeyEvent.actionToString(keyEvent.getAction())\n                            + \";code=\" + KeyEvent.keyCodeToString(keyEvent.getKeyCode());\n                    mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n                            pid, uid, packageName, reason);\n                }\n                if (asSystemService) {\n                    mCb.onMediaButton(mContext.getPackageName(), Process.myPid(),\n                            Process.SYSTEM_UID, createMediaButtonIntent(keyEvent), sequenceId, cb);\n                } else {\n                    mCb.onMediaButton(packageName, pid, uid,\n                            createMediaButtonIntent(keyEvent), sequenceId, cb);\n                }\n                return true;\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in sendMediaRequest.\", e);\n            }\n            return false;\n        }\n\n        public boolean sendMediaButton(String packageName, int pid, int uid,\n                boolean asSystemService, KeyEvent keyEvent) {\n            try {\n                if (KeyEvent.isMediaSessionKey(keyEvent.getKeyCode())) {\n                    final String reason = \"action=\" + KeyEvent.actionToString(keyEvent.getAction())\n                            + \";code=\" + KeyEvent.keyCodeToString(keyEvent.getKeyCode());\n                    mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n                            pid, uid, packageName, reason);\n                }\n                if (asSystemService) {\n                    mCb.onMediaButton(mContext.getPackageName(), Process.myPid(),\n                            Process.SYSTEM_UID, createMediaButtonIntent(keyEvent), 0, null);\n                } else {\n                    mCb.onMediaButtonFromController(packageName, pid, uid,\n                            createMediaButtonIntent(keyEvent));\n                }\n                return true;\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in sendMediaRequest.\", e);\n            }\n            return false;\n        }\n\n        public void sendCommand(String packageName, int pid, int uid, String command, Bundle args,\n                ResultReceiver cb) {\n            try {\n                mCb.onCommand(packageName, pid, uid, command, args, cb);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in sendCommand.\", e);\n            }\n        }\n\n        public void sendCustomAction(String packageName, int pid, int uid, String action,\n                Bundle args) {\n            try {\n                mCb.onCustomAction(packageName, pid, uid, action, args);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in sendCustomAction.\", e);\n            }\n        }\n\n        public void prepare(String packageName, int pid, int uid) {\n            try {\n                mCb.onPrepare(packageName, pid, uid);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in prepare.\", e);\n            }\n        }\n\n        public void prepareFromMediaId(String packageName, int pid, int uid, String mediaId,\n                Bundle extras) {\n            try {\n                mCb.onPrepareFromMediaId(packageName, pid, uid, mediaId, extras);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in prepareFromMediaId.\", e);\n            }\n        }\n\n        public void prepareFromSearch(String packageName, int pid, int uid, String query,\n                Bundle extras) {\n            try {\n                mCb.onPrepareFromSearch(packageName, pid, uid, query, extras);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in prepareFromSearch.\", e);\n            }\n        }\n\n        public void prepareFromUri(String packageName, int pid, int uid, Uri uri, Bundle extras) {\n            try {\n                mCb.onPrepareFromUri(packageName, pid, uid, uri, extras);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in prepareFromUri.\", e);\n            }\n        }\n\n        public void play(String packageName, int pid, int uid) {\n            try {\n                mCb.onPlay(packageName, pid, uid);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in play.\", e);\n            }\n        }\n\n        public void playFromMediaId(String packageName, int pid, int uid, String mediaId,\n                Bundle extras) {\n            try {\n                mCb.onPlayFromMediaId(packageName, pid, uid, mediaId, extras);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in playFromMediaId.\", e);\n            }\n        }\n\n        public void playFromSearch(String packageName, int pid, int uid, String query,\n                Bundle extras) {\n            try {\n                mCb.onPlayFromSearch(packageName, pid, uid, query, extras);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in playFromSearch.\", e);\n            }\n        }\n\n        public void playFromUri(String packageName, int pid, int uid, Uri uri, Bundle extras) {\n            try {\n                mCb.onPlayFromUri(packageName, pid, uid, uri, extras);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in playFromUri.\", e);\n            }\n        }\n\n        public void skipToTrack(String packageName, int pid, int uid, long id) {\n            try {\n                mCb.onSkipToTrack(packageName, pid, uid, id);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in skipToTrack\", e);\n            }\n        }\n\n        public void pause(String packageName, int pid, int uid) {\n            try {\n                mCb.onPause(packageName, pid, uid);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in pause.\", e);\n            }\n        }\n\n        public void stop(String packageName, int pid, int uid) {\n            try {\n                mCb.onStop(packageName, pid, uid);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in stop.\", e);\n            }\n        }\n\n        public void next(String packageName, int pid, int uid) {\n            try {\n                mCb.onNext(packageName, pid, uid);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in next.\", e);\n            }\n        }\n\n        public void previous(String packageName, int pid, int uid) {\n            try {\n                mCb.onPrevious(packageName, pid, uid);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in previous.\", e);\n            }\n        }\n\n        public void fastForward(String packageName, int pid, int uid) {\n            try {\n                mCb.onFastForward(packageName, pid, uid);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in fastForward.\", e);\n            }\n        }\n\n        public void rewind(String packageName, int pid, int uid) {\n            try {\n                mCb.onRewind(packageName, pid, uid);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in rewind.\", e);\n            }\n        }\n\n        public void seekTo(String packageName, int pid, int uid, long pos) {\n            try {\n                mCb.onSeekTo(packageName, pid, uid, pos);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in seekTo.\", e);\n            }\n        }\n\n        public void rate(String packageName, int pid, int uid, Rating rating) {\n            try {\n                mCb.onRate(packageName, pid, uid, rating);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in rate.\", e);\n            }\n        }\n\n        public void setPlaybackSpeed(String packageName, int pid, int uid, float speed) {\n            try {\n                mCb.onSetPlaybackSpeed(packageName, pid, uid, speed);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in setPlaybackSpeed.\", e);\n            }\n        }\n\n        public void adjustVolume(String packageName, int pid, int uid, boolean asSystemService,\n                int direction) {\n            try {\n                if (asSystemService) {\n                    mCb.onAdjustVolume(mContext.getPackageName(), Process.myPid(),\n                            Process.SYSTEM_UID, direction);\n                } else {\n                    mCb.onAdjustVolume(packageName, pid, uid, direction);\n                }\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in adjustVolume.\", e);\n            }\n        }\n\n        public void setVolumeTo(String packageName, int pid, int uid, int value) {\n            try {\n                mCb.onSetVolumeTo(packageName, pid, uid, value);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in setVolumeTo.\", e);\n            }\n        }\n\n        private Intent createMediaButtonIntent(KeyEvent keyEvent) {\n            Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);\n            mediaButtonIntent.putExtra(Intent.EXTRA_KEY_EVENT, keyEvent);\n            return mediaButtonIntent;\n        }\n    }\n\n    class ControllerStub extends ISessionController.Stub {\n        @Override\n        public void sendCommand(String packageName, String command, Bundle args,\n                ResultReceiver cb) {\n            mSessionCb.sendCommand(packageName, Binder.getCallingPid(), Binder.getCallingUid(),\n                    command, args, cb);\n        }\n\n        @Override\n        public boolean sendMediaButton(String packageName, KeyEvent keyEvent) {\n            return mSessionCb.sendMediaButton(packageName, Binder.getCallingPid(),\n                    Binder.getCallingUid(), false, keyEvent);\n        }\n\n        @Override\n        public void registerCallback(String packageName, ISessionControllerCallback cb) {\n            synchronized (mLock) {\n                // If this session is already destroyed tell the caller and\n                // don't add them.\n                if (mDestroyed) {\n                    try {\n                        cb.onSessionDestroyed();\n                    } catch (Exception e) {\n                        // ignored\n                    }\n                    return;\n                }\n                if (getControllerHolderIndexForCb(cb) < 0) {\n                    mControllerCallbackHolders.add(new ISessionControllerCallbackHolder(cb,\n                            packageName, Binder.getCallingUid()));\n                    if (DEBUG) {\n                        Log.d(TAG, \"registering controller callback \" + cb + \" from controller\"\n                                + packageName);\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void unregisterCallback(ISessionControllerCallback cb) {\n            synchronized (mLock) {\n                int index = getControllerHolderIndexForCb(cb);\n                if (index != -1) {\n                    mControllerCallbackHolders.remove(index);\n                }\n                if (DEBUG) {\n                    Log.d(TAG, \"unregistering callback \" + cb.asBinder());\n                }\n            }\n        }\n\n        @Override\n        public String getPackageName() {\n            return mPackageName;\n        }\n\n        @Override\n        public String getTag() {\n            return mTag;\n        }\n\n        @Override\n        public Bundle getSessionInfo() {\n            return mSessionInfo;\n        }\n\n        @Override\n        public PendingIntent getLaunchPendingIntent() {\n            return mLaunchIntent;\n        }\n\n        @Override\n        public long getFlags() {\n            return mFlags;\n        }\n\n        @Override\n        public PlaybackInfo getVolumeAttributes() {\n            return MediaSessionRecord.this.getVolumeAttributes();\n        }\n\n        @Override\n        public void adjustVolume(String packageName, String opPackageName, int direction,\n                int flags) {\n            int pid = Binder.getCallingPid();\n            int uid = Binder.getCallingUid();\n            final long token = Binder.clearCallingIdentity();\n            try {\n                MediaSessionRecord.this.adjustVolume(packageName, opPackageName, pid, uid,\n                        false, direction, flags, false /* useSuggested */);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n        }\n\n        @Override\n        public void setVolumeTo(String packageName, String opPackageName, int value, int flags) {\n            int pid = Binder.getCallingPid();\n            int uid = Binder.getCallingUid();\n            final long token = Binder.clearCallingIdentity();\n            try {\n                MediaSessionRecord.this.setVolumeTo(packageName, opPackageName, pid, uid, value,\n                        flags);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n        }\n\n        @Override\n        public void prepare(String packageName) {\n            mSessionCb.prepare(packageName, Binder.getCallingPid(), Binder.getCallingUid());\n        }\n\n        @Override\n        public void prepareFromMediaId(String packageName, String mediaId, Bundle extras) {\n            mSessionCb.prepareFromMediaId(packageName, Binder.getCallingPid(),\n                    Binder.getCallingUid(), mediaId, extras);\n        }\n\n        @Override\n        public void prepareFromSearch(String packageName, String query, Bundle extras) {\n            mSessionCb.prepareFromSearch(packageName, Binder.getCallingPid(),\n                    Binder.getCallingUid(), query, extras);\n        }\n\n        @Override\n        public void prepareFromUri(String packageName, Uri uri, Bundle extras) {\n            mSessionCb.prepareFromUri(packageName, Binder.getCallingPid(), Binder.getCallingUid(),\n                    uri, extras);\n        }\n\n        @Override\n        public void play(String packageName) {\n            mSessionCb.play(packageName, Binder.getCallingPid(), Binder.getCallingUid());\n        }\n\n        @Override\n        public void playFromMediaId(String packageName, String mediaId, Bundle extras) {\n            mSessionCb.playFromMediaId(packageName, Binder.getCallingPid(), Binder.getCallingUid(),\n                    mediaId, extras);\n        }\n\n        @Override\n        public void playFromSearch(String packageName, String query, Bundle extras) {\n            mSessionCb.playFromSearch(packageName, Binder.getCallingPid(), Binder.getCallingUid(),\n                     query, extras);\n        }\n\n        @Override\n        public void playFromUri(String packageName, Uri uri, Bundle extras) {\n            mSessionCb.playFromUri(packageName, Binder.getCallingPid(), Binder.getCallingUid(),\n                    uri, extras);\n        }\n\n        @Override\n        public void skipToQueueItem(String packageName, long id) {\n            mSessionCb.skipToTrack(packageName, Binder.getCallingPid(), Binder.getCallingUid(), id);\n        }\n\n        @Override\n        public void pause(String packageName) {\n            mSessionCb.pause(packageName, Binder.getCallingPid(), Binder.getCallingUid());\n        }\n\n        @Override\n        public void stop(String packageName) {\n            mSessionCb.stop(packageName, Binder.getCallingPid(), Binder.getCallingUid());\n        }\n\n        @Override\n        public void next(String packageName) {\n            mSessionCb.next(packageName, Binder.getCallingPid(), Binder.getCallingUid());\n        }\n\n        @Override\n        public void previous(String packageName) {\n            mSessionCb.previous(packageName, Binder.getCallingPid(), Binder.getCallingUid());\n        }\n\n        @Override\n        public void fastForward(String packageName) {\n            mSessionCb.fastForward(packageName, Binder.getCallingPid(), Binder.getCallingUid());\n        }\n\n        @Override\n        public void rewind(String packageName) {\n            mSessionCb.rewind(packageName, Binder.getCallingPid(), Binder.getCallingUid());\n        }\n\n        @Override\n        public void seekTo(String packageName, long pos) {\n            mSessionCb.seekTo(packageName, Binder.getCallingPid(), Binder.getCallingUid(), pos);\n        }\n\n        @Override\n        public void rate(String packageName, Rating rating) {\n            mSessionCb.rate(packageName, Binder.getCallingPid(), Binder.getCallingUid(), rating);\n        }\n\n        @Override\n        public void setPlaybackSpeed(String packageName,\n                float speed) {\n            mSessionCb.setPlaybackSpeed(packageName, Binder.getCallingPid(), Binder.getCallingUid(),\n                    speed);\n        }\n\n        @Override\n        public void sendCustomAction(String packageName, String action, Bundle args) {\n            mSessionCb.sendCustomAction(packageName, Binder.getCallingPid(), Binder.getCallingUid(),\n                    action, args);\n        }\n\n        @Override\n        public MediaMetadata getMetadata() {\n            synchronized (mLock) {\n                return mMetadata;\n            }\n        }\n\n        @Override\n        public PlaybackState getPlaybackState() {\n            return getStateWithUpdatedPosition();\n        }\n\n        @Override\n        public ParceledListSlice getQueue() {\n            synchronized (mLock) {\n                return mQueue == null ? null : new ParceledListSlice<>(mQueue);\n            }\n        }\n\n        @Override\n        public CharSequence getQueueTitle() {\n            return mQueueTitle;\n        }\n\n        @Override\n        public Bundle getExtras() {\n            synchronized (mLock) {\n                return mExtras;\n            }\n        }\n\n        @Override\n        public int getRatingType() {\n            return mRatingType;\n        }\n    }\n\n    private class ISessionControllerCallbackHolder {\n        private final ISessionControllerCallback mCallback;\n        private final String mPackageName;\n        private final int mUid;\n\n        ISessionControllerCallbackHolder(ISessionControllerCallback callback, String packageName,\n                int uid) {\n            mCallback = callback;\n            mPackageName = packageName;\n            mUid = uid;\n        }\n    }\n\n    private class MessageHandler extends Handler {\n        private static final int MSG_UPDATE_METADATA = 1;\n        private static final int MSG_UPDATE_PLAYBACK_STATE = 2;\n        private static final int MSG_UPDATE_QUEUE = 3;\n        private static final int MSG_UPDATE_QUEUE_TITLE = 4;\n        private static final int MSG_UPDATE_EXTRAS = 5;\n        private static final int MSG_SEND_EVENT = 6;\n        private static final int MSG_UPDATE_SESSION_STATE = 7;\n        private static final int MSG_UPDATE_VOLUME = 8;\n        private static final int MSG_DESTROYED = 9;\n\n        public MessageHandler(Looper looper) {\n            super(looper);\n        }\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_UPDATE_METADATA:\n                    pushMetadataUpdate();\n                    break;\n                case MSG_UPDATE_PLAYBACK_STATE:\n                    pushPlaybackStateUpdate();\n                    break;\n                case MSG_UPDATE_QUEUE:\n                    pushQueueUpdate();\n                    break;\n                case MSG_UPDATE_QUEUE_TITLE:\n                    pushQueueTitleUpdate();\n                    break;\n                case MSG_UPDATE_EXTRAS:\n                    pushExtrasUpdate();\n                    break;\n                case MSG_SEND_EVENT:\n                    pushEvent((String) msg.obj, msg.getData());\n                    break;\n                case MSG_UPDATE_SESSION_STATE:\n                    // TODO add session state\n                    break;\n                case MSG_UPDATE_VOLUME:\n                    pushVolumeUpdate();\n                    break;\n                case MSG_DESTROYED:\n                    pushSessionDestroyed();\n            }\n        }\n\n        public void post(int what) {\n            post(what, null);\n        }\n\n        public void post(int what, Object obj) {\n            obtainMessage(what, obj).sendToTarget();\n        }\n\n        public void post(int what, Object obj, Bundle data) {\n            Message msg = obtainMessage(what, obj);\n            msg.setData(data);\n            msg.sendToTarget();\n        }\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 13102,
                                        "general": {
                                            "word_based": 5281,
                                            "char_based": 17304
                                        },
                                        "gemini": 15502
                                    }
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-375408314",
            "aliases": [
                "A-375408314",
                "CVE-2025-0074"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-375408314",
            "severity": "Critical",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "7f74d44cebf1cad4b3d7aa9b05236a41cb221e9e"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 7f74d44cebf1cad4b3d7aa9b05236a41cb221e9e Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Wed, 30 Oct 2024 23:58:27 +0000\nSubject: [PATCH] Fix incorrect logging in sdp_discovery\n\nIn two locations in sdp_discovery.cc, log statements use structures that\nmay, in exceptional cases, have been freed by preceding calls.  This can\nlead to use after free and potentially to security vulnerabilities.\n\nUse local variables instead.\n\nBug: 375408314\nBug: 375409435\nTest: m libbluetooth\nTest: researcher POC\nFlag: EXEMPT trivial logic fix\nIgnore-AOSP-First: security\nTag: #security\nChange-Id: I76e1ffa1fe463a5858d61d025447d855ff6b5b84\n---\n system/stack/sdp/sdp_discovery.cc | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\ndiff --git a/system/stack/sdp/sdp_discovery.cc b/system/stack/sdp/sdp_discovery.cc\nindex 2e5cd86da0..75cd5a7ea2 100644\n--- a/system/stack/sdp/sdp_discovery.cc\n+++ b/system/stack/sdp/sdp_discovery.cc\n@@ -183,7 +183,7 @@ static void sdp_snd_service_search_req(tCONN_CB* p_ccb, uint8_t cont_len, uint8_\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_cmd) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_cmd->len);\n+              p_ccb->connection_id, p - p_start);\n   }\n \n   /* Start inactivity timer */\n@@ -711,7 +711,7 @@ static void process_service_search_attr_rsp(tCONN_CB* p_ccb, uint8_t* p_reply,\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_msg) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-                p_ccb->connection_id, p_msg->len);\n+                p_ccb->connection_id, p - p_start);\n     }\n \n     /* Start inactivity timer */\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 611,
                        "general": {
                            "word_based": 230,
                            "char_based": 473
                        },
                        "gemini": 745
                    },
                    "total_downstream_versions_tested": 0,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": []
                }
            ]
        },
        {
            "id": "ASB-A-353240784",
            "aliases": [
                "A-353240784",
                "CVE-2024-49741"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-353240784",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "2a75f7166b028150ea0dcd142e1ede51f7861eb3"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 2a75f7166b028150ea0dcd142e1ede51f7861eb3 Mon Sep 17 00:00:00 2001\nFrom: Pinyao Ting <pinyaoting@google.com>\nDate: Tue, 20 Aug 2024 21:17:13 +0000\nSubject: [PATCH] Enforce hard limits on hosts per package and widgets per\n host.\n\nBug: 353240784\nChange-Id: I60ee7faf57ed719f93cafad212fef24964dec99f\nTest: manually verified with PoC app that at most 20 hosts can exists\nFlag: EXEMPT CVE\n---\n .../appwidget/AppWidgetServiceImpl.java       | 50 ++++++++++++++++++-\n 1 file changed, 49 insertions(+), 1 deletion(-)\n\ndiff --git a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nindex 569615e1683c..f9b731db75b1 100644\n--- a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n+++ b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n@@ -217,6 +217,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // See {@link Provider#pendingDeletedWidgetIds}.\n     private static final String PENDING_DELETED_IDS_ATTR = \"pending_deleted_ids\";\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     // Handles user and package related broadcasts.\n     // See {@link #registerBroadcastReceiver}\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n@@ -2275,7 +2284,7 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (host != null) {\n             return host;\n         }\n-\n+        ensureHostCountBeforeAddLocked(id);\n         host = new Host();\n         host.id = id;\n         mHosts.add(host);\n@@ -2283,6 +2292,24 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         return host;\n     }\n \n+    /**\n+     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n+     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n+     * removes the oldest host.\n+     */\n+    private void ensureHostCountBeforeAddLocked(@NonNull final HostId hostId) {\n+        final List<Host> hosts = new ArrayList<>();\n+        for (Host host : mHosts) {\n+            if (host.id.uid == hostId.uid\n+                    && host.id.packageName.equals(hostId.packageName)) {\n+                hosts.add(host);\n+            }\n+        }\n+        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n+            deleteHostLocked(hosts.remove(0));\n+        }\n+    }\n+\n     private void deleteHostLocked(Host host) {\n         if (DEBUG) {\n             Slog.i(TAG, \"deleteHostLocked() \" + host);\n@@ -3573,11 +3600,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (DEBUG) {\n             Slog.i(TAG, \"addWidgetLocked() \" + widget);\n         }\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(@NonNull final Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 1118,
                        "general": {
                            "word_based": 488,
                            "char_based": 1119
                        },
                        "gemini": 1373
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 0,
                    "failed_patches": 4,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "ae39a3f6538e5a5a73aea4daf8b552539247227f",
                            "repo_path": "android_repos/base",
                            "result": "failure",
                            "downstream_patch_content": "commit ae39a3f6538e5a5a73aea4daf8b552539247227f\nAuthor: Pinyao Ting <pinyaoting@google.com>\nDate:   Tue Aug 20 21:17:13 2024 +0000\n\n    Enforce hard limits on hosts per package and widgets per host.\n    \n    Bug: 353240784\n    Merged-In: I60ee7faf57ed719f93cafad212fef24964dec99f\n    Change-Id: I60ee7faf57ed719f93cafad212fef24964dec99f\n    Test: manually verified with PoC app that at most 20 hosts can exists\n    Flag: EXEMPT CVE\n\ndiff --git a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nindex f5063ac4a023..356613ab3377 100644\n--- a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n+++ b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n@@ -170,6 +170,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // used to verify which request has successfully been received by the host.\n     private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n         @Override\n         public void onReceive(Context context, Intent intent) {\n@@ -1698,7 +1707,7 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (host != null) {\n             return host;\n         }\n-\n+        ensureHostCountBeforeAddLocked(id);\n         host = new Host();\n         host.id = id;\n         mHosts.add(host);\n@@ -1706,6 +1715,24 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         return host;\n     }\n \n+    /**\n+     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n+     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n+     * removes the oldest host.\n+     */\n+    private void ensureHostCountBeforeAddLocked(HostId hostId) {\n+        final List<Host> hosts = new ArrayList<>();\n+        for (Host host : mHosts) {\n+            if (host.id.uid == hostId.uid\n+                    && host.id.packageName.equals(hostId.packageName)) {\n+                hosts.add(host);\n+            }\n+        }\n+        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n+            deleteHostLocked(hosts.remove(0));\n+        }\n+    }\n+\n     private void deleteHostLocked(Host host) {\n         final int N = host.widgets.size();\n         for (int i = N - 1; i >= 0; i--) {\n@@ -2833,11 +2860,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n      * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n      */\n     void addWidgetLocked(Widget widget) {\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.\n",
                            "downstream_patch_tokens": {
                                "openai": 1088,
                                "general": {
                                    "word_based": 485,
                                    "char_based": 1099
                                },
                                "gemini": 1336
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java",
                                    "total_hunks": 4,
                                    "failed_hunks": [
                                        1,
                                        4
                                    ],
                                    "inline_merge_conflicts": [],
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    },
                                    "rej_file_content": "```diff\n--- services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n+++ services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n@@ -217,6 +217,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // See {@link Provider#pendingDeletedWidgetIds}.\n     private static final String PENDING_DELETED_IDS_ATTR = \"pending_deleted_ids\";\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     // Handles user and package related broadcasts.\n     // See {@link #registerBroadcastReceiver}\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n@@ -3591,11 +3618,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (DEBUG) {\n             Slog.i(TAG, \"addWidgetLocked() \" + widget);\n         }\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(@NonNull final Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.\n```",
                                    "rej_file_tokens": {
                                        "openai": 555,
                                        "general": {
                                            "word_based": 254,
                                            "char_based": 607
                                        },
                                        "gemini": 667
                                    },
                                    "patch_apply_output": "patching file services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nHunk #1 FAILED at 217.\nHunk #2 succeeded at 1698 (offset -577 lines).\nHunk #3 succeeded at 1706 with fuzz 2 (offset -577 lines).\nHunk #4 FAILED at 3591.\n2 out of 4 hunks FAILED -- saving rejects to file services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java.rej",
                                    "inline_merge_output": "patching file services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nHunk #1 merged at 229-237.\nHunk #2 already applied at 2296.\nHunk #3 merged at 2322-2339.\nHunk #4 already applied at 3630, merged at 3636-3655.",
                                    "upstream_file_tokens": {
                                        "openai": 50416,
                                        "general": {
                                            "word_based": 21550,
                                            "char_based": 66890
                                        },
                                        "gemini": 60115
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.appwidget;\n\nimport static android.content.Context.KEYGUARD_SERVICE;\nimport static android.content.Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;\nimport static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\nimport static android.content.res.Resources.ID_NULL;\n\nimport static com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME;\n\nimport android.annotation.UserIdInt;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.AlarmManager;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.AppOpsManagerInternal;\nimport android.app.IApplicationThread;\nimport android.app.IServiceConnection;\nimport android.app.KeyguardManager;\nimport android.app.PendingIntent;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.app.admin.DevicePolicyManagerInternal.OnCrossProfileWidgetProvidersChangeListener;\nimport android.app.usage.UsageEvents;\nimport android.app.usage.UsageStatsManagerInternal;\nimport android.appwidget.AppWidgetManager;\nimport android.appwidget.AppWidgetManagerInternal;\nimport android.appwidget.AppWidgetProviderInfo;\nimport android.appwidget.PendingHostUpdate;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.Intent.FilterComparison;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.ServiceConnection;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.LauncherApps;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.ServiceInfo;\nimport android.content.pm.ShortcutServiceInternal;\nimport android.content.pm.SuspendDialogInfo;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.content.res.TypedArray;\nimport android.content.res.XmlResourceParser;\nimport android.graphics.Point;\nimport android.graphics.drawable.Icon;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.service.appwidget.AppWidgetServiceDumpProto;\nimport android.service.appwidget.WidgetProto;\nimport android.text.TextUtils;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.AttributeSet;\nimport android.util.IntArray;\nimport android.util.LongSparseArray;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\nimport android.util.SparseIntArray;\nimport android.util.SparseLongArray;\nimport android.util.TypedValue;\nimport android.util.TypedXmlPullParser;\nimport android.util.TypedXmlSerializer;\nimport android.util.Xml;\nimport android.util.proto.ProtoOutputStream;\nimport android.view.Display;\nimport android.view.View;\nimport android.widget.RemoteViews;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.app.SuspendedAppActivity;\nimport com.android.internal.app.UnlaunchableAppActivity;\nimport com.android.internal.appwidget.IAppWidgetHost;\nimport com.android.internal.appwidget.IAppWidgetService;\nimport com.android.internal.os.BackgroundThread;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.widget.IRemoteViewsFactory;\nimport com.android.server.LocalServices;\nimport com.android.server.WidgetBackupProvider;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicLong;\n\nclass AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBackupProvider,\n        OnCrossProfileWidgetProvidersChangeListener {\n    private static final String TAG = \"AppWidgetServiceImpl\";\n\n    private static boolean DEBUG = false;\n\n    private static final String OLD_KEYGUARD_HOST_PACKAGE = \"android\";\n    private static final String NEW_KEYGUARD_HOST_PACKAGE = \"com.android.keyguard\";\n    private static final int KEYGUARD_HOST_ID = 0x4b455947;\n\n    private static final String STATE_FILENAME = \"appwidgets.xml\";\n\n    private static final int MIN_UPDATE_PERIOD = DEBUG ? 0 : 30 * 60 * 1000; // 30 minutes\n\n    private static final int TAG_UNDEFINED = -1;\n\n    private static final int UNKNOWN_UID = -1;\n\n    private static final int UNKNOWN_USER_ID = -10;\n\n    // Bump if the stored widgets need to be upgraded.\n    private static final int CURRENT_VERSION = 1;\n\n    // Every widget update request is associated which an increasing sequence number. This is\n    // used to verify which request has successfully been received by the host.\n    private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n\n    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            final String action = intent.getAction();\n            final int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Received broadcast: \" + action + \" on user \" + userId);\n            }\n\n            switch (action) {\n                case Intent.ACTION_MANAGED_PROFILE_AVAILABLE:\n                case Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE:\n                    synchronized (mLock) {\n                        reloadWidgetsMaskedState(userId);\n                    }\n                    break;\n                case Intent.ACTION_PACKAGES_SUSPENDED:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    updateWidgetPackageSuspensionMaskedState(intent, true, getSendingUserId());\n                    break;\n                case Intent.ACTION_PACKAGES_UNSUSPENDED:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    updateWidgetPackageSuspensionMaskedState(intent, false, getSendingUserId());\n                    break;\n                default:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    break;\n            }\n        }\n    };\n\n    // Manages persistent references to RemoteViewsServices from different App Widgets.\n    private final HashMap<Pair<Integer, FilterComparison>, HashSet<Integer>>\n            mRemoteViewsServicesAppWidgets = new HashMap<>();\n\n    private final Object mLock = new Object();\n\n    private final ArrayList<Widget> mWidgets = new ArrayList<>();\n    private final ArrayList<Host> mHosts = new ArrayList<>();\n    private final ArrayList<Provider> mProviders = new ArrayList<>();\n\n    private final ArraySet<Pair<Integer, String>> mPackagesWithBindWidgetPermission =\n            new ArraySet<>();\n\n    private final SparseBooleanArray mLoadedUserIds = new SparseBooleanArray();\n\n    private final Object mWidgetPackagesLock = new Object();\n    private final SparseArray<ArraySet<String>> mWidgetPackages = new SparseArray<>();\n\n    private BackupRestoreController mBackupRestoreController;\n\n    private final Context mContext;\n\n    private IPackageManager mPackageManager;\n    private AlarmManager mAlarmManager;\n    private UserManager mUserManager;\n    private AppOpsManager mAppOpsManager;\n    private KeyguardManager mKeyguardManager;\n    private DevicePolicyManagerInternal mDevicePolicyManagerInternal;\n    private PackageManagerInternal mPackageManagerInternal;\n    private ActivityManagerInternal mActivityManagerInternal;\n    private AppOpsManagerInternal mAppOpsManagerInternal;\n    private UsageStatsManagerInternal mUsageStatsManagerInternal;\n\n    private SecurityPolicy mSecurityPolicy;\n\n    private Handler mSaveStateHandler;\n    private Handler mCallbackHandler;\n\n    private final SparseIntArray mNextAppWidgetIds = new SparseIntArray();\n\n    private boolean mSafeMode;\n    private int mMaxWidgetBitmapMemory;\n\n    AppWidgetServiceImpl(Context context) {\n        mContext = context;\n    }\n\n    public void onStart() {\n        mPackageManager = AppGlobals.getPackageManager();\n        mAlarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);\n        mUserManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n        mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);\n        mKeyguardManager = (KeyguardManager) mContext.getSystemService(KEYGUARD_SERVICE);\n        mDevicePolicyManagerInternal = LocalServices.getService(DevicePolicyManagerInternal.class);\n        mPackageManagerInternal = LocalServices.getService(PackageManagerInternal.class);\n        mSaveStateHandler = BackgroundThread.getHandler();\n        mCallbackHandler = new CallbackHandler(mContext.getMainLooper());\n        mBackupRestoreController = new BackupRestoreController();\n        mSecurityPolicy = new SecurityPolicy();\n\n        computeMaximumWidgetBitmapMemory();\n        registerBroadcastReceiver();\n        registerOnCrossProfileProvidersChangedListener();\n\n        LocalServices.addService(AppWidgetManagerInternal.class, new AppWidgetManagerLocal());\n    }\n\n    void systemServicesReady() {\n        mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);\n        mAppOpsManagerInternal = LocalServices.getService(AppOpsManagerInternal.class);\n        mUsageStatsManagerInternal = LocalServices.getService(UsageStatsManagerInternal.class);\n    }\n\n    private void computeMaximumWidgetBitmapMemory() {\n        Display display = mContext.getDisplayNoVerify();\n        Point size = new Point();\n        display.getRealSize(size);\n        // Cap memory usage at 1.5 times the size of the display\n        // 1.5 * 4 bytes/pixel * w * h ==> 6 * w * h\n        mMaxWidgetBitmapMemory = 6 * size.x * size.y;\n    }\n\n    private void registerBroadcastReceiver() {\n        // Register for broadcasts about package install, etc., so we can\n        // update the provider list.\n        IntentFilter packageFilter = new IntentFilter();\n        packageFilter.addAction(Intent.ACTION_PACKAGE_ADDED);\n        packageFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);\n        packageFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);\n        packageFilter.addDataScheme(\"package\");\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                packageFilter, null, null);\n\n        // Register for events related to sdcard installation.\n        IntentFilter sdFilter = new IntentFilter();\n        sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);\n        sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                sdFilter, null, null);\n\n        IntentFilter offModeFilter = new IntentFilter();\n        offModeFilter.addAction(Intent.ACTION_MANAGED_PROFILE_AVAILABLE);\n        offModeFilter.addAction(Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                offModeFilter, null, null);\n\n        IntentFilter suspendPackageFilter = new IntentFilter();\n        suspendPackageFilter.addAction(Intent.ACTION_PACKAGES_SUSPENDED);\n        suspendPackageFilter.addAction(Intent.ACTION_PACKAGES_UNSUSPENDED);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                suspendPackageFilter, null, null);\n    }\n\n    private void registerOnCrossProfileProvidersChangedListener() {\n        // The device policy is an optional component.\n        if (mDevicePolicyManagerInternal != null) {\n            mDevicePolicyManagerInternal.addOnCrossProfileWidgetProvidersChangeListener(this);\n        }\n    }\n\n    public void setSafeMode(boolean safeMode) {\n        mSafeMode = safeMode;\n    }\n\n    private void onPackageBroadcastReceived(Intent intent, int userId) {\n        final String action = intent.getAction();\n        boolean added = false;\n        boolean changed = false;\n        boolean componentsModified = false;\n\n        final String pkgList[];\n        switch (action) {\n            case Intent.ACTION_PACKAGES_SUSPENDED:\n            case Intent.ACTION_PACKAGES_UNSUSPENDED:\n                pkgList = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                changed = true;\n                break;\n            case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:\n                added = true;\n                // Follow through\n            case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:\n                pkgList = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                break;\n            default: {\n                Uri uri = intent.getData();\n                if (uri == null) {\n                    return;\n                }\n                String pkgName = uri.getSchemeSpecificPart();\n                if (pkgName == null) {\n                    return;\n                }\n                pkgList = new String[] { pkgName };\n                added = Intent.ACTION_PACKAGE_ADDED.equals(action);\n                changed = Intent.ACTION_PACKAGE_CHANGED.equals(action);\n            }\n        }\n        if (pkgList == null || pkgList.length == 0) {\n            return;\n        }\n\n        synchronized (mLock) {\n            if (!mUserManager.isUserUnlockingOrUnlocked(userId) ||\n                    isProfileWithLockedParent(userId)) {\n                return;\n            }\n            ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ false);\n\n            Bundle extras = intent.getExtras();\n\n            if (added || changed) {\n                final boolean newPackageAdded = added && (extras == null\n                        || !extras.getBoolean(Intent.EXTRA_REPLACING, false));\n\n                for (String pkgName : pkgList) {\n                    // Fix up the providers - add/remove/update.\n                    componentsModified |= updateProvidersForPackageLocked(pkgName, userId, null);\n\n                    // ... and see if these are hosts we've been awaiting.\n                    // NOTE: We are backing up and restoring only the owner.\n                    // TODO: http://b/22388012\n                    if (newPackageAdded && userId == UserHandle.USER_SYSTEM) {\n                        final int uid = getUidForPackage(pkgName, userId);\n                        if (uid >= 0 ) {\n                            resolveHostUidLocked(pkgName, uid);\n                        }\n                    }\n                }\n            } else {\n                // If the package is being updated, we'll receive a PACKAGE_ADDED\n                // shortly, otherwise it is removed permanently.\n                final boolean packageRemovedPermanently = (extras == null\n                        || !extras.getBoolean(Intent.EXTRA_REPLACING, false));\n\n                if (packageRemovedPermanently) {\n                    for (String pkgName : pkgList) {\n                        componentsModified |= removeHostsAndProvidersForPackageLocked(\n                                pkgName, userId);\n                    }\n                }\n            }\n\n            if (componentsModified) {\n                saveGroupStateAsync(userId);\n\n                // If the set of providers has been modified, notify each active AppWidgetHost\n                scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n                // Possibly notify any new components of widget id changes\n                mBackupRestoreController.widgetComponentsChanged(userId);\n            }\n        }\n    }\n\n    /**\n     * Reload all widgets' masked state for the given user and its associated profiles, including\n     * due to user not being available and package suspension.\n     * userId must be the group parent.\n     */\n    void reloadWidgetsMaskedStateForGroup(int userId) {\n        if (!mUserManager.isUserUnlockingOrUnlocked(userId)) {\n            return;\n        }\n        synchronized (mLock) {\n            reloadWidgetsMaskedState(userId);\n            int[] profileIds = mUserManager.getEnabledProfileIds(userId);\n            for (int profileId : profileIds) {\n                reloadWidgetsMaskedState(profileId);\n            }\n        }\n    }\n\n    private void reloadWidgetsMaskedState(int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            UserInfo user  = mUserManager.getUserInfo(userId);\n\n            boolean lockedProfile = !mUserManager.isUserUnlockingOrUnlocked(userId);\n            boolean quietProfile = user.isQuietModeEnabled();\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                int providerUserId = provider.getUserId();\n                if (providerUserId != userId) {\n                    continue;\n                }\n\n                boolean changed = provider.setMaskedByLockedProfileLocked(lockedProfile);\n                changed |= provider.setMaskedByQuietProfileLocked(quietProfile);\n                try {\n                    boolean suspended;\n                    try {\n                        suspended = mPackageManager.isPackageSuspendedForUser(\n                                provider.id.componentName.getPackageName(), provider.getUserId());\n                    } catch (IllegalArgumentException ex) {\n                        // Package not found.\n                        suspended = false;\n                    }\n                    changed |= provider.setMaskedBySuspendedPackageLocked(suspended);\n                } catch (RemoteException e) {\n                    Slog.e(TAG, \"Failed to query application info\", e);\n                }\n                if (changed) {\n                    if (provider.isMaskedLocked()) {\n                        maskWidgetsViewsLocked(provider, null);\n                    } else {\n                        unmaskWidgetsViewsLocked(provider);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    /**\n     * Incrementally update the masked state due to package suspension state.\n     */\n    private void updateWidgetPackageSuspensionMaskedState(Intent intent, boolean suspended,\n            int profileId) {\n        String[] packagesArray = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n        if (packagesArray == null) {\n            return;\n        }\n        Set<String> packages = new ArraySet<>(Arrays.asList(packagesArray));\n        synchronized (mLock) {\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                int providerUserId = provider.getUserId();\n                if (providerUserId != profileId\n                        || !packages.contains(provider.id.componentName.getPackageName())) {\n                    continue;\n                }\n                if (provider.setMaskedBySuspendedPackageLocked(suspended)) {\n                    if (provider.isMaskedLocked()) {\n                        maskWidgetsViewsLocked(provider, null);\n                    } else {\n                        unmaskWidgetsViewsLocked(provider);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Mask the target widget belonging to the specified provider, or all active widgets\n     * of the provider if target widget == null.\n     */\n    private void maskWidgetsViewsLocked(Provider provider, Widget targetWidget) {\n        final int widgetCount = provider.widgets.size();\n        if (widgetCount == 0) {\n            return;\n        }\n        RemoteViews views = new RemoteViews(mContext.getPackageName(),\n                R.layout.work_widget_mask_view);\n        ApplicationInfo appInfo = provider.info.providerInfo.applicationInfo;\n        final int appUserId = provider.getUserId();\n        boolean showBadge;\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final Intent onClickIntent;\n\n            if (provider.maskedBySuspendedPackage) {\n                showBadge = mUserManager.hasBadge(appUserId);\n                final String suspendingPackage = mPackageManagerInternal.getSuspendingPackage(\n                        appInfo.packageName, appUserId);\n                if (PLATFORM_PACKAGE_NAME.equals(suspendingPackage)) {\n                    onClickIntent = mDevicePolicyManagerInternal.createShowAdminSupportIntent(\n                            appUserId, true);\n                } else {\n                    final SuspendDialogInfo dialogInfo =\n                            mPackageManagerInternal.getSuspendedDialogInfo(\n                                    appInfo.packageName, suspendingPackage, appUserId);\n                    // onUnsuspend is null because we don't want to start any activity on\n                    // unsuspending from a suspended widget.\n                    onClickIntent = SuspendedAppActivity.createSuspendedAppInterceptIntent(\n                            appInfo.packageName, suspendingPackage, dialogInfo, null, null,\n                            appUserId);\n                }\n            } else if (provider.maskedByQuietProfile) {\n                showBadge = true;\n                onClickIntent = UnlaunchableAppActivity.createInQuietModeDialogIntent(appUserId);\n            } else /* provider.maskedByLockedProfile */ {\n                showBadge = true;\n                onClickIntent = mKeyguardManager\n                        .createConfirmDeviceCredentialIntent(null, null, appUserId);\n                if (onClickIntent != null) {\n                    onClickIntent.setFlags(\n                            FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);\n                }\n            }\n\n            if (onClickIntent != null) {\n                views.setOnClickPendingIntent(android.R.id.background,\n                        PendingIntent.getActivity(mContext, 0, onClickIntent,\n                                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE));\n            }\n\n            Icon icon = appInfo.icon != 0\n                    ? Icon.createWithResource(appInfo.packageName, appInfo.icon)\n                    : Icon.createWithResource(mContext, android.R.drawable.sym_def_app_icon);\n            views.setImageViewIcon(R.id.work_widget_app_icon, icon);\n            if (!showBadge) {\n                views.setViewVisibility(R.id.work_widget_badge_icon, View.INVISIBLE);\n            }\n\n            for (int j = 0; j < widgetCount; j++) {\n                Widget widget = provider.widgets.get(j);\n                if (targetWidget != null && targetWidget != widget) continue;\n                if (widget.replaceWithMaskedViewsLocked(views)) {\n                    scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void unmaskWidgetsViewsLocked(Provider provider) {\n        final int widgetCount = provider.widgets.size();\n        for (int j = 0; j < widgetCount; j++) {\n            Widget widget = provider.widgets.get(j);\n            if (widget.clearMaskedViewsLocked()) {\n                scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n            }\n        }\n    }\n\n    private void resolveHostUidLocked(String pkg, int uid) {\n        final int N = mHosts.size();\n        for (int i = 0; i < N; i++) {\n            Host host = mHosts.get(i);\n            if (host.id.uid == UNKNOWN_UID && pkg.equals(host.id.packageName)) {\n                if (DEBUG) {\n                    Slog.i(TAG, \"host \" + host.id + \" resolved to uid \" + uid);\n                }\n                host.id = new HostId(uid, host.id.hostId, host.id.packageName);\n                return;\n            }\n        }\n    }\n\n    private void ensureGroupStateLoadedLocked(int userId) {\n        ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ true );\n    }\n\n    private void ensureGroupStateLoadedLocked(int userId, boolean enforceUserUnlockingOrUnlocked) {\n        if (enforceUserUnlockingOrUnlocked && !isUserRunningAndUnlocked(userId)) {\n            throw new IllegalStateException(\n                    \"User \" + userId + \" must be unlocked for widgets to be available\");\n        }\n        if (enforceUserUnlockingOrUnlocked && isProfileWithLockedParent(userId)) {\n            throw new IllegalStateException(\n                    \"Profile \" + userId + \" must have unlocked parent\");\n        }\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        IntArray newIds = new IntArray(1);\n        for (int profileId : profileIds) {\n            if (!mLoadedUserIds.get(profileId)) {\n                mLoadedUserIds.put(profileId, true);\n                newIds.add(profileId);\n            }\n        }\n        if (newIds.size() <= 0) {\n            return;\n        }\n        final int[] newProfileIds = newIds.toArray();\n        clearProvidersAndHostsTagsLocked();\n\n        loadGroupWidgetProvidersLocked(newProfileIds);\n        loadGroupStateLocked(newProfileIds);\n    }\n\n    private boolean isUserRunningAndUnlocked(@UserIdInt int userId) {\n        return mUserManager.isUserUnlockingOrUnlocked(userId);\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {\n        if (!DumpUtils.checkDumpPermission(mContext, TAG, pw)) return;\n\n        synchronized (mLock) {\n            if (args.length > 0 && \"--proto\".equals(args[0])) {\n                dumpProto(fd);\n            } else {\n                dumpInternalLocked(pw);\n            }\n        }\n    }\n\n    private void dumpProto(FileDescriptor fd) {\n        Slog.i(TAG, \"dump proto for \" + mWidgets.size() + \" widgets\");\n\n        ProtoOutputStream proto = new ProtoOutputStream(fd);\n        int N = mWidgets.size();\n        for (int i=0; i < N; i++) {\n            dumpProtoWidget(proto, mWidgets.get(i));\n        }\n        proto.flush();\n    }\n\n    private void dumpProtoWidget(ProtoOutputStream proto, Widget widget) {\n        if (widget.host == null || widget.provider == null) {\n            Slog.d(TAG, \"skip dumping widget because host or provider is null: widget.host=\"\n                + widget.host + \" widget.provider=\"  + widget.provider);\n            return;\n        }\n        long token = proto.start(AppWidgetServiceDumpProto.WIDGETS);\n        proto.write(WidgetProto.IS_CROSS_PROFILE,\n            widget.host.getUserId() != widget.provider.getUserId());\n        proto.write(WidgetProto.IS_HOST_STOPPED, widget.host.callbacks == null);\n        proto.write(WidgetProto.HOST_PACKAGE, widget.host.id.packageName);\n        proto.write(WidgetProto.PROVIDER_PACKAGE, widget.provider.id.componentName.getPackageName());\n        proto.write(WidgetProto.PROVIDER_CLASS, widget.provider.id.componentName.getClassName());\n        if (widget.options != null) {\n            proto.write(WidgetProto.RESTORE_COMPLETED,\n                    widget.options.getBoolean(AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED));\n            proto.write(WidgetProto.MIN_WIDTH,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH, 0));\n            proto.write(WidgetProto.MIN_HEIGHT,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, 0));\n            proto.write(WidgetProto.MAX_WIDTH,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH, 0));\n            proto.write(WidgetProto.MAX_HEIGHT,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, 0));\n        }\n        proto.end(token);\n    }\n\n    private void dumpInternalLocked(PrintWriter pw) {\n        int N = mProviders.size();\n        pw.println(\"Providers:\");\n        for (int i = 0; i < N; i++) {\n            dumpProviderLocked(mProviders.get(i), i, pw);\n        }\n\n        N = mWidgets.size();\n        pw.println(\" \");\n        pw.println(\"Widgets:\");\n        for (int i = 0; i < N; i++) {\n            dumpWidget(mWidgets.get(i), i, pw);\n        }\n\n        N = mHosts.size();\n        pw.println(\" \");\n        pw.println(\"Hosts:\");\n        for (int i = 0; i < N; i++) {\n            dumpHost(mHosts.get(i), i, pw);\n        }\n\n        N = mPackagesWithBindWidgetPermission.size();\n        pw.println(\" \");\n        pw.println(\"Grants:\");\n        for (int i = 0; i < N; i++) {\n            Pair<Integer, String> grant = mPackagesWithBindWidgetPermission.valueAt(i);\n            dumpGrant(grant, i, pw);\n        }\n    }\n\n    @Override\n    public ParceledListSlice<PendingHostUpdate> startListening(IAppWidgetHost callbacks,\n            String callingPackage, int hostId, int[] appWidgetIds) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"startListening() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            // Instant apps cannot host app widgets.\n            if (mSecurityPolicy.isInstantAppLocked(callingPackage, userId)) {\n                Slog.w(TAG, \"Instant package \" + callingPackage + \" cannot host app widgets\");\n                return ParceledListSlice.emptyList();\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupOrAddHostLocked(id);\n            host.callbacks = callbacks;\n\n            long updateSequenceNo = UPDATE_COUNTER.incrementAndGet();\n            int N = appWidgetIds.length;\n            ArrayList<PendingHostUpdate> outUpdates = new ArrayList<>(N);\n            LongSparseArray<PendingHostUpdate> updatesMap = new LongSparseArray<>();\n            for (int i = 0; i < N; i++) {\n                updatesMap.clear();\n                host.getPendingUpdatesForIdLocked(mContext, appWidgetIds[i], updatesMap);\n                // We key the updates based on request id, so that the values are sorted in the\n                // order they were received.\n                int m = updatesMap.size();\n                for (int j = 0; j < m; j++) {\n                    outUpdates.add(updatesMap.valueAt(j));\n                }\n            }\n            // Reset the update counter once all the updates have been calculated\n            host.lastWidgetUpdateSequenceNo = updateSequenceNo;\n            return new ParceledListSlice<>(outUpdates);\n        }\n    }\n\n    @Override\n    public void stopListening(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"stopListening() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ false);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host != null) {\n                host.callbacks = null;\n                pruneHostLocked(host);\n                mAppOpsManagerInternal.updateAppWidgetVisibility(host.getWidgetUids(), false);\n            }\n        }\n    }\n\n    @Override\n    public int allocateAppWidgetId(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"allocateAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            // Instant apps cannot host app widgets.\n            if (mSecurityPolicy.isInstantAppLocked(callingPackage, userId)) {\n                Slog.w(TAG, \"Instant package \" + callingPackage + \" cannot host app widgets\");\n                return AppWidgetManager.INVALID_APPWIDGET_ID;\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            if (mNextAppWidgetIds.indexOfKey(userId) < 0) {\n                mNextAppWidgetIds.put(userId, AppWidgetManager.INVALID_APPWIDGET_ID + 1);\n            }\n\n            final int appWidgetId = incrementAndGetAppWidgetIdLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupOrAddHostLocked(id);\n\n            Widget widget = new Widget();\n            widget.appWidgetId = appWidgetId;\n            widget.host = host;\n\n            host.widgets.add(widget);\n            addWidgetLocked(widget);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Allocated widget id \" + appWidgetId\n                        + \" for host \" + host.id);\n            }\n\n            return appWidgetId;\n        }\n    }\n\n    @Override\n    public void deleteAppWidgetId(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                return;\n            }\n\n            deleteAppWidgetLocked(widget);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Deleted widget id \" + appWidgetId\n                        + \" for host \" + widget.host.id);\n            }\n        }\n    }\n\n    @Override\n    public boolean hasBindAppWidgetPermission(String packageName, int grantId) {\n        if (DEBUG) {\n            Slog.i(TAG, \"hasBindAppWidgetPermission() \" + UserHandle.getCallingUserId());\n        }\n\n        // A special permission is required for managing allowlisting.\n        mSecurityPolicy.enforceModifyAppWidgetBindPermissions(packageName);\n\n        synchronized (mLock) {\n            // The grants are stored in user state wich gets the grant.\n            ensureGroupStateLoadedLocked(grantId);\n\n            final int packageUid = getUidForPackage(packageName, grantId);\n            if (packageUid < 0) {\n                return false;\n            }\n\n            Pair<Integer, String> packageId = Pair.create(grantId, packageName);\n            return mPackagesWithBindWidgetPermission.contains(packageId);\n        }\n    }\n\n    @Override\n    public void setBindAppWidgetPermission(String packageName, int grantId,\n            boolean grantPermission) {\n        if (DEBUG) {\n            Slog.i(TAG, \"setBindAppWidgetPermission() \" + UserHandle.getCallingUserId());\n        }\n\n        // A special permission is required for managing allowlisting.\n        mSecurityPolicy.enforceModifyAppWidgetBindPermissions(packageName);\n\n        synchronized (mLock) {\n            // The grants are stored in user state wich gets the grant.\n            ensureGroupStateLoadedLocked(grantId);\n\n            final int packageUid = getUidForPackage(packageName, grantId);\n            if (packageUid < 0) {\n                return;\n            }\n\n            Pair<Integer, String> packageId = Pair.create(grantId, packageName);\n            if (grantPermission) {\n                mPackagesWithBindWidgetPermission.add(packageId);\n            } else {\n                mPackagesWithBindWidgetPermission.remove(packageId);\n            }\n\n            saveGroupStateAsync(grantId);\n        }\n    }\n\n    @Override\n    public IntentSender createAppWidgetConfigIntentSender(String callingPackage, int appWidgetId,\n            final int intentFlags) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"createAppWidgetConfigIntentSender() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                throw new IllegalArgumentException(\"Bad widget id \" + appWidgetId);\n            }\n\n            Provider provider = widget.provider;\n            if (provider == null) {\n                throw new IllegalArgumentException(\"Widget not bound \" + appWidgetId);\n            }\n\n            // Make sure only safe flags can be passed it.\n            final int secureFlags = intentFlags & ~Intent.IMMUTABLE_FLAGS;\n\n            Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_CONFIGURE);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);\n            intent.setComponent(provider.getInfoLocked(mContext).configure);\n            intent.setFlags(secureFlags);\n\n            // All right, create the sender.\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return PendingIntent.getActivityAsUser(\n                        mContext, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                                | PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_CANCEL_CURRENT,\n                                null, new UserHandle(provider.getUserId()))\n                        .getIntentSender();\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n    }\n\n    @Override\n    public boolean bindAppWidgetId(String callingPackage, int appWidgetId,\n            int providerProfileId, ComponentName providerComponent, Bundle options) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"bindAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        // Check that if a cross-profile binding is attempted, it is allowed.\n        if (!mSecurityPolicy.isEnabledGroupProfile(providerProfileId)) {\n            return false;\n        }\n\n        // If the provider is not under the calling user, make sure this\n        // provider is allowlisted for access from the parent.\n        if (!mSecurityPolicy.isProviderInCallerOrInProfileAndWhitelListed(\n                providerComponent.getPackageName(), providerProfileId)) {\n            return false;\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // A special permission or allowlisting is required to bind widgets.\n            if (!mSecurityPolicy.hasCallerBindPermissionOrBindWhiteListedLocked(\n                    callingPackage)) {\n                return false;\n            }\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                Slog.e(TAG, \"Bad widget id \" + appWidgetId);\n                return false;\n            }\n\n            if (widget.provider != null) {\n                Slog.e(TAG, \"Widget id \" + appWidgetId\n                        + \" already bound to: \" + widget.provider.id);\n                return false;\n            }\n\n            final int providerUid = getUidForPackage(providerComponent.getPackageName(),\n                    providerProfileId);\n            if (providerUid < 0) {\n                Slog.e(TAG, \"Package \" + providerComponent.getPackageName() + \" not installed \"\n                        + \" for profile \" + providerProfileId);\n                return false;\n            }\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the provider is in the already vetted user profile.\n            ProviderId providerId = new ProviderId(providerUid, providerComponent);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider == null) {\n                Slog.e(TAG, \"No widget provider \" + providerComponent + \" for profile \"\n                        + providerProfileId);\n                return false;\n            }\n\n            if (provider.zombie) {\n                Slog.e(TAG, \"Can't bind to a 3rd party provider in\"\n                        + \" safe mode \" + provider);\n                return false;\n            }\n\n            widget.provider = provider;\n            widget.options = (options != null) ? cloneIfLocalBinder(options) : new Bundle();\n\n            // We need to provide a default value for the widget category if it is not specified\n            if (!widget.options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {\n                widget.options.putInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY,\n                        AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN);\n            }\n\n            provider.widgets.add(widget);\n\n            onWidgetProviderAddedOrChangedLocked(widget);\n\n            final int widgetCount = provider.widgets.size();\n            if (widgetCount == 1) {\n                // Tell the provider that it's ready.\n                sendEnableIntentLocked(provider);\n            }\n\n            // Send an update now -- We need this update now, and just for this appWidgetId.\n            // It's less critical when the next one happens, so when we schedule the next one,\n            // we add updatePeriodMillis to its start time. That time will have some slop,\n            // but that's okay.\n            sendUpdateIntentLocked(provider, new int[] {appWidgetId});\n\n            // Schedule the future updates.\n            registerForBroadcastsLocked(provider, getWidgetIds(provider.widgets));\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Bound widget \" + appWidgetId + \" to provider \" + provider.id);\n            }\n        }\n\n        return true;\n    }\n\n    @Override\n    public int[] getAppWidgetIds(ComponentName componentName) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetIds() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider != null) {\n                return getWidgetIds(provider.widgets);\n            }\n\n            return new int[0];\n        }\n    }\n\n    @Override\n    public int[] getAppWidgetIdsForHost(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetIdsForHost() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access its hosts.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host != null) {\n                return getWidgetIds(host.widgets);\n            }\n\n            return new int[0];\n        }\n    }\n\n    @Override\n    public boolean bindRemoteViewsService(String callingPackage, int appWidgetId, Intent intent,\n            IApplicationThread caller, IBinder activtiyToken, IServiceConnection connection,\n            int flags) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"bindRemoteViewsService() \" + userId);\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                throw new IllegalArgumentException(\"Bad widget id\");\n            }\n\n            // Make sure the widget has a provider.\n            if (widget.provider == null) {\n                throw new IllegalArgumentException(\"No provider for widget \"\n                        + appWidgetId);\n            }\n\n            ComponentName componentName = intent.getComponent();\n\n            // Ensure that the service belongs to the same package as the provider.\n            // But this is not enough as they may be under different users - see below...\n            String providerPackage = widget.provider.id.componentName.getPackageName();\n            String servicePackage = componentName.getPackageName();\n            if (!servicePackage.equals(providerPackage)) {\n                throw new SecurityException(\"The taget service not in the same package\"\n                        + \" as the widget provider\");\n            }\n\n            // Make sure this service exists under the same user as the provider and\n            // requires a permission which allows only the system to bind to it.\n            mSecurityPolicy.enforceServiceExistsAndRequiresBindRemoteViewsPermission(\n                    componentName, widget.provider.getUserId());\n\n            // Good to go - the service package is correct, it exists for the correct\n            // user, and requires the bind permission.\n\n            final long callingIdentity = Binder.clearCallingIdentity();\n            try {\n                // Ask ActivityManager to bind it. Notice that we are binding the service with the\n                // caller app instead of DevicePolicyManagerService.\n                if (ActivityManager.getService().bindService(\n                        caller, activtiyToken, intent,\n                        intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                        connection, flags & (Context.BIND_AUTO_CREATE\n                                | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE),\n                        mContext.getOpPackageName(), widget.provider.getUserId()) != 0) {\n\n                    // Add it to the mapping of RemoteViewsService to appWidgetIds so that we\n                    // can determine when we can call back to the RemoteViewsService later to\n                    // destroy associated factories.\n                    incrementAppWidgetServiceRefCount(appWidgetId,\n                            Pair.create(widget.provider.id.uid, new FilterComparison(intent)));\n                    return true;\n                }\n            } catch (RemoteException ex) {\n                // Same process, should not happen.\n            } finally {\n                Binder.restoreCallingIdentity(callingIdentity);\n            }\n        }\n\n        // Failed to bind.\n        return false;\n    }\n\n    @Override\n    public void deleteHost(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteHost() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts in its uid and package.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host == null) {\n                return;\n            }\n\n            deleteHostLocked(host);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Deleted host \" + host.id);\n            }\n        }\n    }\n\n    @Override\n    public void deleteAllHosts() {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteAllHosts() \" + userId);\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            boolean changed = false;\n\n            final int N = mHosts.size();\n            for (int i = N - 1; i >= 0; i--) {\n                Host host = mHosts.get(i);\n\n                // Delete only hosts in the calling uid.\n                if (host.id.uid == Binder.getCallingUid()) {\n                    deleteHostLocked(host);\n                    changed = true;\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Deleted host \" + host.id);\n                    }\n                }\n            }\n\n            if (changed) {\n                saveGroupStateAsync(userId);\n            }\n        }\n    }\n\n    @Override\n    public AppWidgetProviderInfo getAppWidgetInfo(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetInfo() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null && widget.provider != null && !widget.provider.zombie) {\n                return cloneIfLocalBinder(widget.provider.getInfoLocked(mContext));\n            }\n\n            return null;\n        }\n    }\n\n    @Override\n    public RemoteViews getAppWidgetViews(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetViews() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null) {\n                return cloneIfLocalBinder(widget.getEffectiveViewsLocked());\n            }\n\n            return null;\n        }\n    }\n\n    @Override\n    public void updateAppWidgetOptions(String callingPackage, int appWidgetId, Bundle options) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetOptions() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                return;\n            }\n\n            // Merge the options.\n            widget.options.putAll(options);\n\n            // Send the broacast to notify the provider that options changed.\n            sendOptionsChangedIntentLocked(widget);\n\n            saveGroupStateAsync(userId);\n        }\n    }\n\n    @Override\n    public Bundle getAppWidgetOptions(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetOptions() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null && widget.options != null) {\n                return cloneIfLocalBinder(widget.options);\n            }\n\n            return Bundle.EMPTY;\n        }\n    }\n\n    @Override\n    public void updateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views) {\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetIds() \" + UserHandle.getCallingUserId());\n        }\n\n        updateAppWidgetIds(callingPackage, appWidgetIds, views, false);\n    }\n\n    @Override\n    public void partiallyUpdateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views) {\n        if (DEBUG) {\n            Slog.i(TAG, \"partiallyUpdateAppWidgetIds() \" + UserHandle.getCallingUserId());\n        }\n\n        updateAppWidgetIds(callingPackage, appWidgetIds, views, true);\n    }\n\n    @Override\n    public void notifyAppWidgetViewDataChanged(String callingPackage, int[] appWidgetIds,\n            int viewId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"notifyAppWidgetViewDataChanged() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        if (appWidgetIds == null || appWidgetIds.length == 0) {\n            return;\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            final int N = appWidgetIds.length;\n            for (int i = 0; i < N; i++) {\n                final int appWidgetId = appWidgetIds[i];\n\n                // NOTE: The lookup is enforcing security across users by making\n                // sure the caller can only access widgets it hosts or provides.\n                Widget widget = lookupWidgetLocked(appWidgetId,\n                        Binder.getCallingUid(), callingPackage);\n\n                if (widget != null) {\n                    scheduleNotifyAppWidgetViewDataChanged(widget, viewId);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void updateAppWidgetProvider(ComponentName componentName, RemoteViews views) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetProvider() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider == null) {\n                Slog.w(TAG, \"Provider doesn't exist \" + providerId);\n                return;\n            }\n\n            ArrayList<Widget> instances = provider.widgets;\n            final int N = instances.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = instances.get(i);\n                updateAppWidgetInstanceLocked(widget, views, false);\n            }\n        }\n    }\n\n    @Override\n    public void updateAppWidgetProviderInfo(ComponentName componentName, String metadataKey) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetProvider() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n            if (provider == null) {\n                throw new IllegalArgumentException(\n                        componentName + \" is not a valid AppWidget provider\");\n            }\n            if (Objects.equals(provider.infoTag, metadataKey)) {\n                // No change\n                return;\n            }\n\n            String keyToUse = metadataKey == null\n                    ? AppWidgetManager.META_DATA_APPWIDGET_PROVIDER : metadataKey;\n            AppWidgetProviderInfo info = parseAppWidgetProviderInfo(mContext, providerId,\n                    provider.getPartialInfoLocked().providerInfo, keyToUse);\n            if (info == null) {\n                throw new IllegalArgumentException(\"Unable to parse \" + keyToUse\n                        + \" meta-data to a valid AppWidget provider\");\n            }\n\n            provider.setInfoLocked(info);\n            provider.infoTag = metadataKey;\n\n            // Update all widgets for this provider\n            final int N = provider.widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = provider.widgets.get(i);\n                scheduleNotifyProviderChangedLocked(widget);\n                updateAppWidgetInstanceLocked(widget, widget.views, false /* isPartialUpdate */);\n            }\n\n            saveGroupStateAsync(userId);\n            scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n        }\n    }\n\n    @Override\n    public boolean isRequestPinAppWidgetSupported() {\n        synchronized (mLock) {\n            if (mSecurityPolicy.isCallerInstantAppLocked()) {\n                Slog.w(TAG, \"Instant uid \" + Binder.getCallingUid()\n                        + \" query information about app widgets\");\n                return false;\n            }\n        }\n        return LocalServices.getService(ShortcutServiceInternal.class)\n                .isRequestPinItemSupported(UserHandle.getCallingUserId(),\n                        LauncherApps.PinItemRequest.REQUEST_TYPE_APPWIDGET);\n    }\n\n    @Override\n    public boolean requestPinAppWidget(String callingPackage, ComponentName componentName,\n            Bundle extras, IntentSender resultSender) {\n        final int callingUid = Binder.getCallingUid();\n        final int userId = UserHandle.getUserId(callingUid);\n\n        if (DEBUG) {\n            Slog.i(TAG, \"requestPinAppWidget() \" + userId);\n        }\n\n        final AppWidgetProviderInfo info;\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // Look for the widget associated with the caller.\n            Provider provider = lookupProviderLocked(new ProviderId(callingUid, componentName));\n            if (provider == null || provider.zombie) {\n                return false;\n            }\n            info = provider.getInfoLocked(mContext);\n            if ((info.widgetCategory & AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN) == 0) {\n                return false;\n            }\n        }\n\n        return LocalServices.getService(ShortcutServiceInternal.class)\n                .requestPinAppWidget(callingPackage, info, extras, resultSender, userId);\n    }\n\n    @Override\n    public ParceledListSlice<AppWidgetProviderInfo> getInstalledProvidersForProfile(int categoryFilter,\n            int profileId, String packageName) {\n        final int userId = UserHandle.getCallingUserId();\n        final int callingUid = Binder.getCallingUid();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getInstalledProvidersForProfiles() \" + userId);\n        }\n\n        // Ensure the profile is in the group and enabled.\n        if (!mSecurityPolicy.isEnabledGroupProfile(profileId)) {\n            return null;\n        }\n\n        synchronized (mLock) {\n            if (mSecurityPolicy.isCallerInstantAppLocked()) {\n                Slog.w(TAG, \"Instant uid \" + callingUid\n                        + \" cannot access widget providers\");\n                return ParceledListSlice.emptyList();\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            ArrayList<AppWidgetProviderInfo> result = new ArrayList<AppWidgetProviderInfo>();\n\n            final int providerCount = mProviders.size();\n            for (int i = 0; i < providerCount; i++) {\n                Provider provider = mProviders.get(i);\n                AppWidgetProviderInfo info = provider.getInfoLocked(mContext);\n                final String providerPackageName = provider.id.componentName.getPackageName();\n\n                // Ignore an invalid provider, one not matching the filter,\n                // or one that isn't in the given package, if any.\n                boolean inPackage = packageName == null\n                        || providerPackageName.equals(packageName);\n                if (provider.zombie || (info.widgetCategory & categoryFilter) == 0 || !inPackage) {\n                    continue;\n                }\n\n                // Add providers only for the requested profile that are allowlisted.\n                final int providerProfileId = info.getProfile().getIdentifier();\n                if (providerProfileId == profileId\n                        && mSecurityPolicy.isProviderInCallerOrInProfileAndWhitelListed(\n                        providerPackageName, providerProfileId)\n                        && !mPackageManagerInternal.filterAppAccess(providerPackageName, callingUid,\n                        userId)) {\n                    result.add(cloneIfLocalBinder(info));\n                }\n            }\n\n            return new ParceledListSlice<AppWidgetProviderInfo>(result);\n        }\n    }\n\n    private void updateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views, boolean partially) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (appWidgetIds == null || appWidgetIds.length == 0) {\n            return;\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            final int N = appWidgetIds.length;\n            for (int i = 0; i < N; i++) {\n                final int appWidgetId = appWidgetIds[i];\n\n                // NOTE: The lookup is enforcing security across users by making\n                // sure the caller can only access widgets it hosts or provides.\n                Widget widget = lookupWidgetLocked(appWidgetId,\n                        Binder.getCallingUid(), callingPackage);\n\n                if (widget != null) {\n                    updateAppWidgetInstanceLocked(widget, views, partially);\n                }\n            }\n        }\n    }\n\n    private int incrementAndGetAppWidgetIdLocked(int userId) {\n        final int appWidgetId = peekNextAppWidgetIdLocked(userId) + 1;\n        mNextAppWidgetIds.put(userId, appWidgetId);\n        return appWidgetId;\n    }\n\n    private void setMinAppWidgetIdLocked(int userId, int minWidgetId) {\n        final int nextAppWidgetId = peekNextAppWidgetIdLocked(userId);\n        if (nextAppWidgetId < minWidgetId) {\n            mNextAppWidgetIds.put(userId, minWidgetId);\n        }\n    }\n\n    private int peekNextAppWidgetIdLocked(int userId) {\n        if (mNextAppWidgetIds.indexOfKey(userId) < 0) {\n            return AppWidgetManager.INVALID_APPWIDGET_ID + 1;\n        } else {\n            return mNextAppWidgetIds.get(userId);\n        }\n    }\n\n    private Host lookupOrAddHostLocked(HostId id) {\n        Host host = lookupHostLocked(id);\n        if (host != null) {\n            return host;\n        }\n        ensureHostCountBeforeAddLocked(id);\n        host = new Host();\n        host.id = id;\n        mHosts.add(host);\n\n        return host;\n    }\n\n    /**\n     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n     * removes the oldest host.\n     */\n    private void ensureHostCountBeforeAddLocked(@NonNull final HostId hostId) {\n        final List<Host> hosts = new ArrayList<>();\n        for (Host host : mHosts) {\n            if (host.id.uid == hostId.uid\n                    && host.id.packageName.equals(hostId.packageName)) {\n                hosts.add(host);\n            }\n        }\n        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n            deleteHostLocked(hosts.remove(0));\n        }\n    }\n\n    private void deleteHostLocked(Host host) {\n        final int N = host.widgets.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Widget widget = host.widgets.remove(i);\n            deleteAppWidgetLocked(widget);\n        }\n        mHosts.remove(host);\n\n        // it's gone or going away, abruptly drop the callback connection\n        host.callbacks = null;\n    }\n\n    private void deleteAppWidgetLocked(Widget widget) {\n        // We first unbind all services that are bound to this id\n        // Check if we need to destroy any services (if no other app widgets are\n        // referencing the same service)\n        decrementAppWidgetServiceRefCount(widget);\n\n        Host host = widget.host;\n        host.widgets.remove(widget);\n        pruneHostLocked(host);\n\n        removeWidgetLocked(widget);\n\n        Provider provider = widget.provider;\n        if (provider != null) {\n            provider.widgets.remove(widget);\n            if (!provider.zombie) {\n                // send the broacast saying that this appWidgetId has been deleted\n                sendDeletedIntentLocked(widget);\n\n                if (provider.widgets.isEmpty()) {\n                    // cancel the future updates\n                    cancelBroadcastsLocked(provider);\n\n                    // send the broacast saying that the provider is not in use any more\n                    sendDisabledIntentLocked(provider);\n                }\n            }\n        }\n    }\n\n    private void cancelBroadcastsLocked(Provider provider) {\n        if (DEBUG) {\n            Slog.i(TAG, \"cancelBroadcastsLocked() for \" + provider);\n        }\n        if (provider.broadcast != null) {\n            final PendingIntent broadcast = provider.broadcast;\n            mSaveStateHandler.post(() -> {\n                    mAlarmManager.cancel(broadcast);\n                    broadcast.cancel();\n            });\n            provider.broadcast = null;\n        }\n    }\n\n    // Destroys the cached factory on the RemoteViewsService's side related to the specified intent\n    private void destroyRemoteViewsService(final Intent intent, Widget widget) {\n        final ServiceConnection conn = new ServiceConnection() {\n            @Override\n            public void onServiceConnected(ComponentName name, IBinder service) {\n                final IRemoteViewsFactory cb = IRemoteViewsFactory.Stub.asInterface(service);\n                try {\n                    cb.onDestroy(intent);\n                } catch (RemoteException re) {\n                    Slog.e(TAG, \"Error calling remove view factory\", re);\n                }\n                mContext.unbindService(this);\n            }\n\n            @Override\n            public void onServiceDisconnected(ComponentName name) {\n                // Do nothing\n            }\n        };\n\n        // Bind to the service and remove the static intent->factory mapping in the\n        // RemoteViewsService.\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.bindServiceAsUser(intent, conn,\n                    Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE,\n                    widget.provider.id.getProfile());\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    // Adds to the ref-count for a given RemoteViewsService intent\n    private void incrementAppWidgetServiceRefCount(int appWidgetId,\n            Pair<Integer, FilterComparison> serviceId) {\n        final HashSet<Integer> appWidgetIds;\n        if (mRemoteViewsServicesAppWidgets.containsKey(serviceId)) {\n            appWidgetIds = mRemoteViewsServicesAppWidgets.get(serviceId);\n        } else {\n            appWidgetIds = new HashSet<>();\n            mRemoteViewsServicesAppWidgets.put(serviceId, appWidgetIds);\n        }\n        appWidgetIds.add(appWidgetId);\n    }\n\n    // Subtracts from the ref-count for a given RemoteViewsService intent, prompting a delete if\n    // the ref-count reaches zero.\n    private void decrementAppWidgetServiceRefCount(Widget widget) {\n        Iterator<Pair<Integer, FilterComparison>> it = mRemoteViewsServicesAppWidgets\n                .keySet().iterator();\n        while (it.hasNext()) {\n            final Pair<Integer, FilterComparison> key = it.next();\n            final HashSet<Integer> ids = mRemoteViewsServicesAppWidgets.get(key);\n            if (ids.remove(widget.appWidgetId)) {\n                // If we have removed the last app widget referencing this service, then we\n                // should destroy it and remove it from this set\n                if (ids.isEmpty()) {\n                    destroyRemoteViewsService(key.second.getIntent(), widget);\n                    it.remove();\n                }\n            }\n        }\n    }\n\n    private void saveGroupStateAsync(int groupId) {\n        mSaveStateHandler.post(new SaveStateRunnable(groupId));\n    }\n\n    private void updateAppWidgetInstanceLocked(Widget widget, RemoteViews views,\n            boolean isPartialUpdate) {\n        if (widget != null && widget.provider != null\n                && !widget.provider.zombie && !widget.host.zombie) {\n\n            if (isPartialUpdate && widget.views != null) {\n                // For a partial update, we merge the new RemoteViews with the old.\n                widget.views.mergeRemoteViews(views);\n            } else {\n                // For a full update we replace the RemoteViews completely.\n                widget.views = views;\n            }\n            int memoryUsage;\n            if ((UserHandle.getAppId(Binder.getCallingUid()) != Process.SYSTEM_UID) &&\n                    (widget.views != null) &&\n                    ((memoryUsage = widget.views.estimateMemoryUsage()) > mMaxWidgetBitmapMemory)) {\n                widget.views = null;\n                throw new IllegalArgumentException(\"RemoteViews for widget update exceeds\"\n                        + \" maximum bitmap memory usage (used: \" + memoryUsage\n                        + \", max: \" + mMaxWidgetBitmapMemory + \")\");\n            }\n            scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n        }\n    }\n    private void scheduleNotifyAppWidgetViewDataChanged(Widget widget, int viewId) {\n        if (viewId == ID_VIEWS_UPDATE || viewId == ID_PROVIDER_CHANGED) {\n            // A view id should never collide with these constants but a developer can call this\n            // method with a wrong id. In that case, ignore the call.\n            return;\n        }\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.put(viewId, requestId);\n        }\n        if (widget == null || widget.host == null || widget.host.zombie\n                || widget.host.callbacks == null || widget.provider == null\n                || widget.provider.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = requestId;\n        args.argi1 = widget.appWidgetId;\n        args.argi2 = viewId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_VIEW_DATA_CHANGED,\n                args).sendToTarget();\n    }\n\n\n    private void handleNotifyAppWidgetViewDataChanged(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, int viewId, long requestId) {\n        try {\n            callbacks.viewDataChanged(appWidgetId, viewId);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            // It failed; remove the callback. No need to prune because\n            // we know that this host is still referenced by this instance.\n            callbacks = null;\n        }\n\n        // If the host is unavailable, then we call the associated\n        // RemoteViewsFactory.onDataSetChanged() directly\n        synchronized (mLock) {\n            if (callbacks == null) {\n                host.callbacks = null;\n\n                Set<Pair<Integer, FilterComparison>> keys = mRemoteViewsServicesAppWidgets.keySet();\n                for (Pair<Integer, FilterComparison> key : keys) {\n                    if (mRemoteViewsServicesAppWidgets.get(key).contains(appWidgetId)) {\n                        final ServiceConnection connection = new ServiceConnection() {\n                            @Override\n                            public void onServiceConnected(ComponentName name, IBinder service) {\n                                IRemoteViewsFactory cb = IRemoteViewsFactory.Stub\n                                        .asInterface(service);\n                                try {\n                                    cb.onDataSetChangedAsync();\n                                } catch (RemoteException e) {\n                                    Slog.e(TAG, \"Error calling onDataSetChangedAsync()\", e);\n                                }\n                                mContext.unbindService(this);\n                            }\n\n                            @Override\n                            public void onServiceDisconnected(android.content.ComponentName name) {\n                                // Do nothing\n                            }\n                        };\n\n                        final int userId = UserHandle.getUserId(key.first);\n                        Intent intent = key.second.getIntent();\n\n                        // Bind to the service and call onDataSetChanged()\n                        bindService(intent, connection, new UserHandle(userId));\n                    }\n                }\n            }\n        }\n    }\n\n    private void scheduleNotifyUpdateAppWidgetLocked(Widget widget, RemoteViews updateViews) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.put(ID_VIEWS_UPDATE, requestId);\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n        if (updateViews != null) {\n            updateViews = new RemoteViews(updateViews);\n            updateViews.setProviderInstanceId(requestId);\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = updateViews;\n        args.arg4 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_UPDATE_APP_WIDGET,\n                args).sendToTarget();\n    }\n\n    private void handleNotifyUpdateAppWidget(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, RemoteViews views, long requestId) {\n        try {\n            callbacks.updateAppWidget(appWidgetId, views);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyProviderChangedLocked(Widget widget) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            // When the provider changes, reset everything else.\n            widget.updateSequenceNos.clear();\n            widget.updateSequenceNos.append(ID_PROVIDER_CHANGED, requestId);\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = widget.provider.getInfoLocked(mContext);\n        args.arg4 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_PROVIDER_CHANGED,\n                args).sendToTarget();\n    }\n\n    private void handleNotifyProviderChanged(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, AppWidgetProviderInfo info, long requestId) {\n        try {\n            callbacks.providerChanged(appWidgetId, info);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock){\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyAppWidgetRemovedLocked(Widget widget) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.clear();\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n            CallbackHandler.MSG_NOTIFY_APP_WIDGET_REMOVED,\n            args).sendToTarget();\n    }\n\n    private void handleNotifyAppWidgetRemoved(Host host, IAppWidgetHost callbacks, int appWidgetId,\n            long requestId) {\n        try {\n            callbacks.appWidgetRemoved(appWidgetId);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyGroupHostsForProvidersChangedLocked(int userId) {\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        final int N = mHosts.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Host host = mHosts.get(i);\n\n            boolean hostInGroup = false;\n            final int M = profileIds.length;\n            for (int j = 0; j < M; j++) {\n                final int profileId = profileIds[j];\n                if (host.getUserId() == profileId) {\n                    hostInGroup = true;\n                    break;\n                }\n            }\n\n            if (!hostInGroup) {\n                continue;\n            }\n\n            if (host == null || host.zombie || host.callbacks == null) {\n                continue;\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = host;\n            args.arg2 = host.callbacks;\n\n            mCallbackHandler.obtainMessage(\n                    CallbackHandler.MSG_NOTIFY_PROVIDERS_CHANGED,\n                    args).sendToTarget();\n        }\n    }\n\n    private void handleNotifyProvidersChanged(Host host, IAppWidgetHost callbacks) {\n        try {\n            callbacks.providersChanged();\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private static boolean isLocalBinder() {\n        return Process.myPid() == Binder.getCallingPid();\n    }\n\n    private static RemoteViews cloneIfLocalBinder(RemoteViews rv) {\n        if (isLocalBinder() && rv != null) {\n            return rv.clone();\n        }\n        return rv;\n    }\n\n    private static AppWidgetProviderInfo cloneIfLocalBinder(AppWidgetProviderInfo info) {\n        if (isLocalBinder() && info != null) {\n            return info.clone();\n        }\n        return info;\n    }\n\n    private static Bundle cloneIfLocalBinder(Bundle bundle) {\n        // Note: this is only a shallow copy. For now this will be fine, but it could be problematic\n        // if we start adding objects to the options. Further, it would only be an issue if keyguard\n        // used such options.\n        if (isLocalBinder() && bundle != null) {\n            return (Bundle) bundle.clone();\n        }\n        return bundle;\n    }\n\n    private Widget lookupWidgetLocked(int appWidgetId, int uid, String packageName) {\n        final int N = mWidgets.size();\n        for (int i = 0; i < N; i++) {\n            Widget widget = mWidgets.get(i);\n            if (widget.appWidgetId == appWidgetId\n                    && mSecurityPolicy.canAccessAppWidget(widget, uid, packageName)) {\n                return widget;\n            }\n        }\n        return null;\n    }\n\n    private Provider lookupProviderLocked(ProviderId id) {\n        final int N = mProviders.size();\n        for (int i = 0; i < N; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.id.equals(id)) {\n                return provider;\n            }\n        }\n        return null;\n    }\n\n    private Host lookupHostLocked(HostId hostId) {\n        final int N = mHosts.size();\n        for (int i = 0; i < N; i++) {\n            Host host = mHosts.get(i);\n            if (host.id.equals(hostId)) {\n                return host;\n            }\n        }\n        return null;\n    }\n\n    private void pruneHostLocked(Host host) {\n        if (host.widgets.size() == 0 && host.callbacks == null) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Pruning host \" + host.id);\n            }\n            mHosts.remove(host);\n        }\n    }\n\n    private void loadGroupWidgetProvidersLocked(int[] profileIds) {\n        List<ResolveInfo> allReceivers = null;\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n\n        final int profileCount = profileIds.length;\n        for (int i = 0; i < profileCount; i++) {\n            final int profileId = profileIds[i];\n\n            List<ResolveInfo> receivers = queryIntentReceivers(intent, profileId);\n            if (receivers != null && !receivers.isEmpty()) {\n                if (allReceivers == null) {\n                    allReceivers = new ArrayList<>();\n                }\n                allReceivers.addAll(receivers);\n            }\n        }\n\n        final int N = (allReceivers == null) ? 0 : allReceivers.size();\n        for (int i = 0; i < N; i++) {\n            ResolveInfo receiver = allReceivers.get(i);\n            addProviderLocked(receiver);\n        }\n    }\n\n    private boolean addProviderLocked(ResolveInfo ri) {\n        if ((ri.activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {\n            return false;\n        }\n\n        ComponentName componentName = new ComponentName(ri.activityInfo.packageName,\n                ri.activityInfo.name);\n        ProviderId providerId = new ProviderId(ri.activityInfo.applicationInfo.uid, componentName);\n\n        // we might have an inactive entry for this provider already due to\n        // a preceding restore operation.  if so, fix it up in place; otherwise\n        // just add this new one.\n        Provider existing = lookupProviderLocked(providerId);\n\n        // If the provider was not found it may be because it was restored and\n        // we did not know its UID so let us find if there is such one.\n        if (existing == null) {\n            ProviderId restoredProviderId = new ProviderId(UNKNOWN_UID, componentName);\n            existing = lookupProviderLocked(restoredProviderId);\n        }\n\n        AppWidgetProviderInfo info = createPartialProviderInfo(providerId, ri, existing);\n        if (info != null) {\n            if (existing != null) {\n                if (existing.zombie && !mSafeMode) {\n                    // it's a placeholder that was set up during an app restore\n                    existing.id = providerId;\n                    existing.zombie = false;\n                    existing.setPartialInfoLocked(info);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Provider placeholder now reified: \" + existing);\n                    }\n                }\n            } else {\n                Provider provider = new Provider();\n                provider.id = providerId;\n                provider.setPartialInfoLocked(info);\n                mProviders.add(provider);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    // Remove widgets for provider that are hosted in userId.\n    private void deleteWidgetsLocked(Provider provider, int userId) {\n        final int N = provider.widgets.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Widget widget = provider.widgets.get(i);\n            if (userId == UserHandle.USER_ALL\n                    || userId == widget.host.getUserId()) {\n                provider.widgets.remove(i);\n                // Call back with empty RemoteViews\n                updateAppWidgetInstanceLocked(widget, null, false);\n                // clear out references to this appWidgetId\n                widget.host.widgets.remove(widget);\n                removeWidgetLocked(widget);\n                widget.provider = null;\n                pruneHostLocked(widget.host);\n                widget.host = null;\n            }\n        }\n    }\n\n    private void deleteProviderLocked(Provider provider) {\n        deleteWidgetsLocked(provider, UserHandle.USER_ALL);\n        mProviders.remove(provider);\n\n        // no need to send the DISABLE broadcast, since the receiver is gone anyway\n        cancelBroadcastsLocked(provider);\n    }\n\n    private void sendEnableIntentLocked(Provider p) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_ENABLED);\n        intent.setComponent(p.id.componentName);\n        sendBroadcastAsUser(intent, p.id.getProfile());\n    }\n\n    private void sendUpdateIntentLocked(Provider provider, int[] appWidgetIds) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds);\n        intent.setComponent(provider.id.componentName);\n        sendBroadcastAsUser(intent, provider.id.getProfile());\n    }\n\n    private void sendDeletedIntentLocked(Widget widget) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_DELETED);\n        intent.setComponent(widget.provider.id.componentName);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, widget.appWidgetId);\n        sendBroadcastAsUser(intent, widget.provider.id.getProfile());\n    }\n\n    private void sendDisabledIntentLocked(Provider provider) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_DISABLED);\n        intent.setComponent(provider.id.componentName);\n        sendBroadcastAsUser(intent, provider.id.getProfile());\n    }\n\n    public void sendOptionsChangedIntentLocked(Widget widget) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_OPTIONS_CHANGED);\n        intent.setComponent(widget.provider.id.componentName);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, widget.appWidgetId);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS, widget.options);\n        sendBroadcastAsUser(intent, widget.provider.id.getProfile());\n    }\n\n    private void registerForBroadcastsLocked(Provider provider, int[] appWidgetIds) {\n        AppWidgetProviderInfo info = provider.getInfoLocked(mContext);\n        if (info.updatePeriodMillis > 0) {\n            // if this is the first instance, set the alarm. otherwise,\n            // rely on the fact that we've already set it and that\n            // PendingIntent.getBroadcast will update the extras.\n            boolean alreadyRegistered = provider.broadcast != null;\n            Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds);\n            intent.setComponent(info.provider);\n            final long token = Binder.clearCallingIdentity();\n            try {\n                // Broadcast alarms sent by system are immutable\n                provider.broadcast = PendingIntent.getBroadcastAsUser(mContext, 1, intent,\n                        PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                        info.getProfile());\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (!alreadyRegistered) {\n                // Set the alarm outside of our locks; we've latched the first-time\n                // invariant and established the PendingIntent safely.\n                final long period = Math.max(info.updatePeriodMillis, MIN_UPDATE_PERIOD);\n                final PendingIntent broadcast = provider.broadcast;\n                mSaveStateHandler.post(() ->\n                    mAlarmManager.setInexactRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,\n                            SystemClock.elapsedRealtime() + period, period, broadcast)\n                );\n            }\n        }\n    }\n\n    private static int[] getWidgetIds(ArrayList<Widget> widgets) {\n        int instancesSize = widgets.size();\n        int appWidgetIds[] = new int[instancesSize];\n        for (int i = 0; i < instancesSize; i++) {\n            appWidgetIds[i] = widgets.get(i).appWidgetId;\n        }\n        return appWidgetIds;\n    }\n\n    private static void dumpProviderLocked(Provider provider, int index, PrintWriter pw) {\n        AppWidgetProviderInfo info = provider.getPartialInfoLocked();\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] provider \");\n        pw.println(provider.id);\n        pw.print(\"    min=(\"); pw.print(info.minWidth);\n        pw.print(\"x\"); pw.print(info.minHeight);\n        pw.print(\")   minResize=(\"); pw.print(info.minResizeWidth);\n        pw.print(\"x\"); pw.print(info.minResizeHeight);\n        pw.print(\") updatePeriodMillis=\");\n        pw.print(info.updatePeriodMillis);\n        pw.print(\" resizeMode=\");\n        pw.print(info.resizeMode);\n        pw.print(\" widgetCategory=\");\n        pw.print(info.widgetCategory);\n        pw.print(\" autoAdvanceViewId=\");\n        pw.print(info.autoAdvanceViewId);\n        pw.print(\" initialLayout=#\");\n        pw.print(Integer.toHexString(info.initialLayout));\n        pw.print(\" initialKeyguardLayout=#\");\n        pw.print(Integer.toHexString(info.initialKeyguardLayout));\n        pw.print(\"   zombie=\"); pw.println(provider.zombie);\n    }\n\n    private static void dumpHost(Host host, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] hostId=\");\n        pw.println(host.id);\n        pw.print(\"    callbacks=\"); pw.println(host.callbacks);\n        pw.print(\"    widgets.size=\"); pw.print(host.widgets.size());\n        pw.print(\" zombie=\"); pw.println(host.zombie);\n    }\n\n    private static void dumpGrant(Pair<Integer, String> grant, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(']');\n        pw.print(\" user=\"); pw.print(grant.first);\n        pw.print(\" package=\"); pw.println(grant.second);\n    }\n\n    private static void dumpWidget(Widget widget, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] id=\");\n        pw.println(widget.appWidgetId);\n        pw.print(\"    host=\");\n        pw.println(widget.host.id);\n        if (widget.provider != null) {\n            pw.print(\"    provider=\"); pw.println(widget.provider.id);\n        }\n        if (widget.host != null) {\n            pw.print(\"    host.callbacks=\"); pw.println(widget.host.callbacks);\n        }\n        if (widget.views != null) {\n            pw.print(\"    views=\"); pw.println(widget.views);\n        }\n    }\n\n    private static void serializeProvider(TypedXmlSerializer out, Provider p) throws IOException {\n        out.startTag(null, \"p\");\n        out.attribute(null, \"pkg\", p.id.componentName.getPackageName());\n        out.attribute(null, \"cl\", p.id.componentName.getClassName());\n        out.attributeIntHex(null, \"tag\", p.tag);\n        if (!TextUtils.isEmpty(p.infoTag)) {\n            out.attribute(null, \"info_tag\", p.infoTag);\n        }\n        out.endTag(null, \"p\");\n    }\n\n    private static void serializeHost(TypedXmlSerializer out, Host host) throws IOException {\n        out.startTag(null, \"h\");\n        out.attribute(null, \"pkg\", host.id.packageName);\n        out.attributeIntHex(null, \"id\", host.id.hostId);\n        out.attributeIntHex(null, \"tag\", host.tag);\n        out.endTag(null, \"h\");\n    }\n\n    private static void serializeAppWidget(TypedXmlSerializer out, Widget widget,\n            boolean saveRestoreCompleted) throws IOException {\n        out.startTag(null, \"g\");\n        out.attributeIntHex(null, \"id\", widget.appWidgetId);\n        out.attributeIntHex(null, \"rid\", widget.restoredId);\n        out.attributeIntHex(null, \"h\", widget.host.tag);\n        if (widget.provider != null) {\n            out.attributeIntHex(null, \"p\", widget.provider.tag);\n        }\n        if (widget.options != null) {\n            int minWidth = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH);\n            int minHeight = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT);\n            int maxWidth = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH);\n            int maxHeight = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT);\n            out.attributeIntHex(null, \"min_width\", (minWidth > 0) ? minWidth : 0);\n            out.attributeIntHex(null, \"min_height\", (minHeight > 0) ? minHeight : 0);\n            out.attributeIntHex(null, \"max_width\", (maxWidth > 0) ? maxWidth : 0);\n            out.attributeIntHex(null, \"max_height\", (maxHeight > 0) ? maxHeight : 0);\n            out.attributeIntHex(null, \"host_category\", widget.options.getInt(\n                    AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY));\n            if (saveRestoreCompleted) {\n                boolean restoreCompleted = widget.options.getBoolean(\n                        AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED);\n                out.attributeBoolean(null, \"restore_completed\", restoreCompleted);\n            }\n        }\n        out.endTag(null, \"g\");\n    }\n\n    private static Bundle parseWidgetIdOptions(TypedXmlPullParser parser) {\n        Bundle options = new Bundle();\n        boolean restoreCompleted = parser.getAttributeBoolean(null, \"restore_completed\", false);\n        if (restoreCompleted) {\n            options.putBoolean(AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED, true);\n        }\n        int minWidth = parser.getAttributeIntHex(null, \"min_width\", -1);\n        if (minWidth != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH, minWidth);\n        }\n        int minHeight = parser.getAttributeIntHex(null, \"min_height\", -1);\n        if (minHeight != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, minHeight);\n        }\n        int maxWidth = parser.getAttributeIntHex(null, \"max_width\", -1);\n        if (maxWidth != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH, maxWidth);\n        }\n        int maxHeight = parser.getAttributeIntHex(null, \"max_height\", -1);\n        if (maxHeight != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, maxHeight);\n        }\n        int category = parser.getAttributeIntHex(null, \"host_category\",\n                AppWidgetProviderInfo.WIDGET_CATEGORY_UNKNOWN);\n        if (category != AppWidgetProviderInfo.WIDGET_CATEGORY_UNKNOWN) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY, category);\n        }\n        return options;\n    }\n\n    @Override\n    public List<String> getWidgetParticipants(int userId) {\n        return mBackupRestoreController.getWidgetParticipants(userId);\n    }\n\n    @Override\n    public byte[] getWidgetState(String packageName, int userId) {\n        return mBackupRestoreController.getWidgetState(packageName, userId);\n    }\n\n    @Override\n    public void systemRestoreStarting(int userId) {\n        mBackupRestoreController.systemRestoreStarting(userId);\n    }\n\n    @Override\n    public void restoreWidgetState(String packageName, byte[] restoredState, int userId) {\n        mBackupRestoreController.restoreWidgetState(packageName, restoredState, userId);\n    }\n\n    @Override\n    public void systemRestoreFinished(int userId) {\n        mBackupRestoreController.systemRestoreFinished(userId);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private AppWidgetProviderInfo createPartialProviderInfo(ProviderId providerId, ResolveInfo ri,\n            Provider provider) {\n        boolean hasXmlDefinition = false;\n        Bundle metaData = ri.activityInfo.metaData;\n        if (metaData == null) {\n            return null;\n        }\n\n        if (provider != null && !TextUtils.isEmpty(provider.infoTag)) {\n            hasXmlDefinition = metaData.getInt(provider.infoTag) != 0;\n        }\n        hasXmlDefinition |= metaData.getInt(AppWidgetManager.META_DATA_APPWIDGET_PROVIDER) != 0;\n\n        if (hasXmlDefinition) {\n            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n            info.provider = providerId.componentName;\n            info.providerInfo = ri.activityInfo;\n            return info;\n        }\n        return null;\n    }\n\n    private static AppWidgetProviderInfo parseAppWidgetProviderInfo(Context context,\n            ProviderId providerId, ActivityInfo activityInfo, String metadataKey) {\n        final PackageManager pm = context.getPackageManager();\n        try (XmlResourceParser parser = activityInfo.loadXmlMetaData(pm, metadataKey)) {\n            if (parser == null) {\n                Slog.w(TAG, \"No \" + metadataKey + \" meta-data for AppWidget provider '\"\n                        + providerId + '\\'');\n                return null;\n            }\n\n            AttributeSet attrs = Xml.asAttributeSet(parser);\n\n            int type;\n            while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                    && type != XmlPullParser.START_TAG) {\n                // drain whitespace, comments, etc.\n            }\n\n            String nodeName = parser.getName();\n            if (!\"appwidget-provider\".equals(nodeName)) {\n                Slog.w(TAG, \"Meta-data does not start with appwidget-provider tag for\"\n                        + \" AppWidget provider \" + providerId.componentName\n                        + \" for user \" + providerId.uid);\n                return null;\n            }\n\n            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n            info.provider = providerId.componentName;\n            info.providerInfo = activityInfo;\n\n            final Resources resources;\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final int userId = UserHandle.getUserId(providerId.uid);\n                final ApplicationInfo app = pm.getApplicationInfoAsUser(activityInfo.packageName,\n                        0, userId);\n                resources = pm.getResourcesForApplication(app);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n\n            TypedArray sa = resources.obtainAttributes(attrs,\n                    com.android.internal.R.styleable.AppWidgetProviderInfo);\n\n            // These dimensions has to be resolved in the application's context.\n            // We simply send back the raw complex data, which will be\n            // converted to dp in {@link AppWidgetManager#getAppWidgetInfo}.\n            TypedValue value = sa\n                    .peekValue(com.android.internal.R.styleable.AppWidgetProviderInfo_minWidth);\n            info.minWidth = value != null ? value.data : 0;\n            value = sa.peekValue(com.android.internal.R.styleable.AppWidgetProviderInfo_minHeight);\n            info.minHeight = value != null ? value.data : 0;\n\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_minResizeWidth);\n            info.minResizeWidth = value != null ? value.data : info.minWidth;\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_minResizeHeight);\n            info.minResizeHeight = value != null ? value.data : info.minHeight;\n\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_maxResizeWidth);\n            info.maxResizeWidth = value != null ? value.data : 0;\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_maxResizeHeight);\n            info.maxResizeHeight = value != null ? value.data : 0;\n\n            info.targetCellWidth = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_targetCellWidth, 0);\n            info.targetCellHeight = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_targetCellHeight, 0);\n\n            info.updatePeriodMillis = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_updatePeriodMillis, 0);\n            info.initialLayout = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_initialLayout, ID_NULL);\n            info.initialKeyguardLayout = sa.getResourceId(com.android.internal.R.styleable.\n                    AppWidgetProviderInfo_initialKeyguardLayout, ID_NULL);\n\n            String className = sa\n                    .getString(com.android.internal.R.styleable.AppWidgetProviderInfo_configure);\n            if (className != null) {\n                info.configure = new ComponentName(providerId.componentName.getPackageName(),\n                        className);\n            }\n            info.label = activityInfo.loadLabel(pm).toString();\n            info.icon = activityInfo.getIconResource();\n            info.previewImage = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_previewImage, ID_NULL);\n            info.previewLayout = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_previewLayout, ID_NULL);\n            info.autoAdvanceViewId = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_autoAdvanceViewId,\n                    View.NO_ID);\n            info.resizeMode = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_resizeMode,\n                    AppWidgetProviderInfo.RESIZE_NONE);\n            info.widgetCategory = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_widgetCategory,\n                    AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN);\n            info.widgetFeatures = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_widgetFeatures, 0);\n            info.descriptionRes = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_description, ID_NULL);\n            sa.recycle();\n            return info;\n        } catch (IOException | PackageManager.NameNotFoundException | XmlPullParserException e) {\n            // Ok to catch Exception here, because anything going wrong because\n            // of what a client process passes to us should not be fatal for the\n            // system process.\n            Slog.w(TAG, \"XML parsing failed for AppWidget provider \"\n                    + providerId.componentName + \" for user \" + providerId.uid, e);\n            return null;\n        }\n    }\n\n    private int getUidForPackage(String packageName, int userId) {\n        PackageInfo pkgInfo = null;\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            pkgInfo = mPackageManager.getPackageInfo(packageName, 0, userId);\n        } catch (RemoteException re) {\n            // Shouldn't happen, local call\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n\n        if (pkgInfo == null || pkgInfo.applicationInfo == null) {\n            return -1;\n        }\n\n        return pkgInfo.applicationInfo.uid;\n    }\n\n    private ActivityInfo getProviderInfo(ComponentName componentName, int userId) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.setComponent(componentName);\n\n        List<ResolveInfo> receivers = queryIntentReceivers(intent, userId);\n        // We are setting component, so there is only one or none.\n        if (!receivers.isEmpty()) {\n            return receivers.get(0).activityInfo;\n        }\n\n        return null;\n    }\n\n    private List<ResolveInfo> queryIntentReceivers(Intent intent, int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            int flags = PackageManager.GET_META_DATA;\n\n            // We really need packages to be around and parsed to know if they\n            // provide widgets.\n            flags |= PackageManager.MATCH_DEBUG_TRIAGED_MISSING;\n\n            // Widget hosts that are non-crypto aware may be hosting widgets\n            // from a profile that is still locked, so let them see those\n            // widgets.\n            if (isProfileWithUnlockedParent(userId)) {\n                flags |= PackageManager.MATCH_DIRECT_BOOT_AWARE\n                        | PackageManager.MATCH_DIRECT_BOOT_UNAWARE;\n            }\n\n            // Widgets referencing shared libraries need to have their\n            // dependencies loaded.\n            flags |= PackageManager.GET_SHARED_LIBRARY_FILES;\n\n            return mPackageManager.queryIntentReceivers(intent,\n                    intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                    flags, userId).getList();\n        } catch (RemoteException re) {\n            return Collections.emptyList();\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    /**\n     * This does not use the usual onUserUnlocked() listener mechanism because it is\n     * invoked at a choreographed point in the middle of the user unlock sequence,\n     * before the boot-completed broadcast is issued and the listeners notified.\n     */\n    void handleUserUnlocked(int userId) {\n        if (isProfileWithLockedParent(userId)) {\n            return;\n        }\n        if (!mUserManager.isUserUnlockingOrUnlocked(userId)) {\n            Slog.w(TAG, \"User \" + userId + \" is no longer unlocked - exiting\");\n            return;\n        }\n        long time = SystemClock.elapsedRealtime();\n        synchronized (mLock) {\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"appwidget ensure\");\n            ensureGroupStateLoadedLocked(userId);\n            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"appwidget reload\");\n            reloadWidgetsMaskedStateForGroup(mSecurityPolicy.getGroupParent(userId));\n            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n\n                // Send broadcast only to the providers of the user.\n                if (provider.getUserId() != userId) {\n                    continue;\n                }\n\n                if (provider.widgets.size() > 0) {\n                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,\n                            \"appwidget init \" + provider.id.componentName.getPackageName());\n                    sendEnableIntentLocked(provider);\n                    int[] appWidgetIds = getWidgetIds(provider.widgets);\n                    sendUpdateIntentLocked(provider, appWidgetIds);\n                    registerForBroadcastsLocked(provider, appWidgetIds);\n                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n                }\n            }\n        }\n        Slog.i(TAG, \"Processing of handleUserUnlocked u\" + userId + \" took \"\n                + (SystemClock.elapsedRealtime() - time) + \" ms\");\n    }\n\n    // only call from initialization -- it assumes that the data structures are all empty\n    private void loadGroupStateLocked(int[] profileIds) {\n        // We can bind the widgets to host and providers only after\n        // reading the host and providers for all users since a widget\n        // can have a host and a provider in different users.\n        List<LoadedWidgetState> loadedWidgets = new ArrayList<>();\n\n        int version = 0;\n\n        final int profileIdCount = profileIds.length;\n        for (int i = 0; i < profileIdCount; i++) {\n            final int profileId = profileIds[i];\n\n            // No file written for this user - nothing to do.\n            AtomicFile file = getSavedStateFile(profileId);\n            try (FileInputStream stream = file.openRead()) {\n                version = readProfileStateFromFileLocked(stream, profileId, loadedWidgets);\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to read state: \" + e);\n            }\n        }\n\n        if (version >= 0) {\n            // Hooke'm up...\n            bindLoadedWidgetsLocked(loadedWidgets);\n\n            // upgrade the database if needed\n            performUpgradeLocked(version);\n        } else {\n            // failed reading, clean up\n            Slog.w(TAG, \"Failed to read state, clearing widgets and hosts.\");\n            clearWidgetsLocked();\n            mHosts.clear();\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                mProviders.get(i).widgets.clear();\n            }\n        }\n    }\n\n    private void bindLoadedWidgetsLocked(List<LoadedWidgetState> loadedWidgets) {\n        final int loadedWidgetCount = loadedWidgets.size();\n        for (int i = loadedWidgetCount - 1; i >= 0; i--) {\n            LoadedWidgetState loadedWidget = loadedWidgets.remove(i);\n            Widget widget = loadedWidget.widget;\n\n            widget.provider = findProviderByTag(loadedWidget.providerTag);\n            if (widget.provider == null) {\n                // This provider is gone. We just let the host figure out\n                // that this happened when it fails to load it.\n                continue;\n            }\n\n            widget.host = findHostByTag(loadedWidget.hostTag);\n            if (widget.host == null) {\n                // This host is gone.\n                continue;\n            }\n\n            widget.provider.widgets.add(widget);\n            widget.host.widgets.add(widget);\n            addWidgetLocked(widget);\n        }\n    }\n\n    private Provider findProviderByTag(int tag) {\n        if (tag < 0) {\n            return null;\n        }\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.tag == tag) {\n                return provider;\n            }\n        }\n        return null;\n    }\n\n    private Host findHostByTag(int tag) {\n        if (tag < 0) {\n            return null;\n        }\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            if (host.tag == tag) {\n                return host;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n     */\n    void addWidgetLocked(Widget widget) {\n        mWidgets.add(widget);\n\n        onWidgetProviderAddedOrChangedLocked(widget);\n    }\n\n    /**\n     * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n     * that have bound widgets.\n     */\n    void onWidgetProviderAddedOrChangedLocked(Widget widget) {\n        if (widget.provider == null) return;\n\n        int userId = widget.provider.getUserId();\n        synchronized (mWidgetPackagesLock) {\n            ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages == null) {\n                mWidgetPackages.put(userId, packages = new ArraySet<String>());\n            }\n            packages.add(widget.provider.id.componentName.getPackageName());\n        }\n\n        // If we are adding a widget it might be for a provider that\n        // is currently masked, if so mask the widget.\n        if (widget.provider.isMaskedLocked()) {\n            maskWidgetsViewsLocked(widget.provider, widget);\n        } else {\n            widget.clearMaskedViewsLocked();\n        }\n    }\n\n    /**\n     * Removes a widget from mWidgets and updates the cache of bound widget provider packages.\n     * If there are other widgets with the same package, leaves it in the cache, otherwise it\n     * removes the associated package from the cache.\n     */\n    void removeWidgetLocked(Widget widget) {\n        mWidgets.remove(widget);\n        onWidgetRemovedLocked(widget);\n        scheduleNotifyAppWidgetRemovedLocked(widget);\n    }\n\n    private void onWidgetRemovedLocked(Widget widget) {\n        if (widget.provider == null) return;\n\n        final int userId = widget.provider.getUserId();\n        final String packageName = widget.provider.id.componentName.getPackageName();\n        synchronized (mWidgetPackagesLock) {\n            ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages == null) {\n                return;\n            }\n            // Check if there is any other widget with the same package name.\n            // Remove packageName if none.\n            final int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget w = mWidgets.get(i);\n                if (w.provider == null) continue;\n                if (w.provider.getUserId() == userId\n                        && packageName.equals(w.provider.id.componentName.getPackageName())) {\n                    return;\n                }\n            }\n            packages.remove(packageName);\n        }\n    }\n\n    /**\n     * Clears all widgets and associated cache of packages with bound widgets.\n     */\n    void clearWidgetsLocked() {\n        mWidgets.clear();\n\n        onWidgetsClearedLocked();\n    }\n\n    private void onWidgetsClearedLocked() {\n        synchronized (mWidgetPackagesLock) {\n            mWidgetPackages.clear();\n        }\n    }\n\n    @Override\n    public boolean isBoundWidgetPackage(String packageName, int userId) {\n        if (Binder.getCallingUid() != Process.SYSTEM_UID) {\n            throw new SecurityException(\"Only the system process can call this\");\n        }\n        synchronized (mWidgetPackagesLock) {\n            final ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages != null) {\n                return packages.contains(packageName);\n            }\n        }\n        return false;\n    }\n\n    private void saveStateLocked(int userId) {\n        tagProvidersAndHosts();\n\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        final int profileCount = profileIds.length;\n        for (int i = 0; i < profileCount; i++) {\n            final int profileId = profileIds[i];\n\n            AtomicFile file = getSavedStateFile(profileId);\n            FileOutputStream stream;\n            try {\n                stream = file.startWrite();\n                if (writeProfileStateToFileLocked(stream, profileId)) {\n                    file.finishWrite(stream);\n                } else {\n                    file.failWrite(stream);\n                    Slog.w(TAG, \"Failed to save state, restoring backup.\");\n                }\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed open state file for write: \" + e);\n            }\n        }\n    }\n\n    private void tagProvidersAndHosts() {\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            provider.tag = i;\n        }\n\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            host.tag = i;\n        }\n    }\n\n    private void clearProvidersAndHostsTagsLocked() {\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            provider.tag = TAG_UNDEFINED;\n        }\n\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            host.tag = TAG_UNDEFINED;\n        }\n    }\n\n    private boolean writeProfileStateToFileLocked(FileOutputStream stream, int userId) {\n        int N;\n\n        try {\n            TypedXmlSerializer out = Xml.resolveSerializer(stream);\n            out.startDocument(null, true);\n            out.startTag(null, \"gs\");\n            out.attributeInt(null, \"version\", CURRENT_VERSION);\n\n            N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                // Save only providers for the user.\n                if (provider.getUserId() != userId) {\n                    continue;\n                }\n                if (provider.shouldBePersisted()) {\n                    serializeProvider(out, provider);\n                }\n            }\n\n            N = mHosts.size();\n            for (int i = 0; i < N; i++) {\n                Host host = mHosts.get(i);\n                // Save only hosts for the user.\n                if (host.getUserId() != userId) {\n                    continue;\n                }\n                serializeHost(out, host);\n            }\n\n            N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n                // Save only widgets hosted by the user.\n                if (widget.host.getUserId() != userId) {\n                    continue;\n                }\n                serializeAppWidget(out, widget, true);\n            }\n\n            Iterator<Pair<Integer, String>> it = mPackagesWithBindWidgetPermission.iterator();\n            while (it.hasNext()) {\n                Pair<Integer, String> binding = it.next();\n                // Save only white listings for the user.\n                if (binding.first != userId) {\n                    continue;\n                }\n                out.startTag(null, \"b\");\n                out.attribute(null, \"packageName\", binding.second);\n                out.endTag(null, \"b\");\n            }\n\n            out.endTag(null, \"gs\");\n            out.endDocument();\n            return true;\n        } catch (IOException e) {\n            Slog.w(TAG, \"Failed to write state: \" + e);\n            return false;\n        }\n    }\n\n    private int readProfileStateFromFileLocked(FileInputStream stream, int userId,\n            List<LoadedWidgetState> outLoadedWidgets) {\n        int version = -1;\n        try {\n            TypedXmlPullParser parser = Xml.resolvePullParser(stream);\n\n            int legacyProviderIndex = -1;\n            int legacyHostIndex = -1;\n            int type;\n            do {\n                type = parser.next();\n                if (type == XmlPullParser.START_TAG) {\n                    String tag = parser.getName();\n                    if (\"gs\".equals(tag)) {\n                        version = parser.getAttributeInt(null, \"version\", 0);\n                    } else if (\"p\".equals(tag)) {\n                        legacyProviderIndex++;\n                        // TODO: do we need to check that this package has the same signature\n                        // as before?\n                        String pkg = parser.getAttributeValue(null, \"pkg\");\n                        String cl = parser.getAttributeValue(null, \"cl\");\n\n                        pkg = getCanonicalPackageName(pkg, cl, userId);\n                        if (pkg == null) {\n                            continue;\n                        }\n\n                        final int uid = getUidForPackage(pkg, userId);\n                        if (uid < 0) {\n                            continue;\n                        }\n\n                        ComponentName componentName = new ComponentName(pkg, cl);\n\n                        ActivityInfo providerInfo = getProviderInfo(componentName, userId);\n                        if (providerInfo == null) {\n                            continue;\n                        }\n\n                        ProviderId providerId = new ProviderId(uid, componentName);\n                        Provider provider = lookupProviderLocked(providerId);\n\n                        if (provider == null && mSafeMode) {\n                            // if we're in safe mode, make a temporary one\n                            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n                            info.provider = providerId.componentName;\n                            info.providerInfo = providerInfo;\n\n                            provider = new Provider();\n                            provider.setPartialInfoLocked(info);\n                            provider.zombie = true;\n                            provider.id = providerId;\n                            mProviders.add(provider);\n                        }\n\n                        final int providerTag = parser.getAttributeIntHex(null, \"tag\",\n                                legacyProviderIndex);\n                        provider.tag = providerTag;\n                        provider.infoTag = parser.getAttributeValue(null, \"info_tag\");\n                    } else if (\"h\".equals(tag)) {\n                        legacyHostIndex++;\n                        Host host = new Host();\n                        // TODO: do we need to check that this package has the same signature\n                        // as before?\n                        String pkg = parser.getAttributeValue(null, \"pkg\");\n\n                        final int uid = getUidForPackage(pkg, userId);\n                        if (uid < 0) {\n                            host.zombie = true;\n                        }\n\n                        if (!host.zombie || mSafeMode) {\n                            // In safe mode, we don't discard the hosts we don't recognize\n                            // so that they're not pruned from our list. Otherwise, we do.\n                            final int hostId = parser.getAttributeIntHex(null, \"id\");\n                            final int hostTag = parser.getAttributeIntHex(null, \"tag\",\n                                    legacyHostIndex);\n\n                            host.tag = hostTag;\n                            host.id = new HostId(uid, hostId, pkg);\n                            mHosts.add(host);\n                        }\n                    } else if (\"b\".equals(tag)) {\n                        String packageName = parser.getAttributeValue(null, \"packageName\");\n                        final int uid = getUidForPackage(packageName, userId);\n                        if (uid >= 0) {\n                            Pair<Integer, String> packageId = Pair.create(userId, packageName);\n                            mPackagesWithBindWidgetPermission.add(packageId);\n                        }\n                    } else if (\"g\".equals(tag)) {\n                        Widget widget = new Widget();\n                        widget.appWidgetId = parser.getAttributeIntHex(null, \"id\");\n                        setMinAppWidgetIdLocked(userId, widget.appWidgetId + 1);\n\n                        // restored ID is allowed to be absent\n                        widget.restoredId = parser.getAttributeIntHex(null, \"rid\", 0);\n                        widget.options = parseWidgetIdOptions(parser);\n\n                        final int hostTag = parser.getAttributeIntHex(null, \"h\");\n                        String providerString = parser.getAttributeValue(null, \"p\");\n                        final int providerTag = (providerString != null)\n                                ? parser.getAttributeIntHex(null, \"p\") : TAG_UNDEFINED;\n\n                        // We can match widgets with hosts and providers only after hosts\n                        // and providers for all users have been loaded since the widget\n                        // host and provider can be in different user profiles.\n                        LoadedWidgetState loadedWidgets = new LoadedWidgetState(widget,\n                                hostTag, providerTag);\n                        outLoadedWidgets.add(loadedWidgets);\n                    }\n                }\n            } while (type != XmlPullParser.END_DOCUMENT);\n        } catch (NullPointerException\n                | NumberFormatException\n                | XmlPullParserException\n                | IOException\n                | IndexOutOfBoundsException e) {\n            Slog.w(TAG, \"failed parsing \" + e);\n            return -1;\n        }\n\n        return version;\n    }\n\n    private void performUpgradeLocked(int fromVersion) {\n        if (fromVersion < CURRENT_VERSION) {\n            Slog.v(TAG, \"Upgrading widget database from \" + fromVersion + \" to \"\n                    + CURRENT_VERSION);\n        }\n\n        int version = fromVersion;\n\n        // Update 1: keyguard moved from package \"android\" to \"com.android.keyguard\"\n        if (version == 0) {\n            HostId oldHostId = new HostId(Process.myUid(),\n                    KEYGUARD_HOST_ID, OLD_KEYGUARD_HOST_PACKAGE);\n\n            Host host = lookupHostLocked(oldHostId);\n            if (host != null) {\n                final int uid = getUidForPackage(NEW_KEYGUARD_HOST_PACKAGE,\n                        UserHandle.USER_SYSTEM);\n                if (uid >= 0) {\n                    host.id = new HostId(uid, KEYGUARD_HOST_ID, NEW_KEYGUARD_HOST_PACKAGE);\n                }\n            }\n\n            version = 1;\n        }\n\n        if (version != CURRENT_VERSION) {\n            throw new IllegalStateException(\"Failed to upgrade widget database\");\n        }\n    }\n\n    private static File getStateFile(int userId) {\n        return new File(Environment.getUserSystemDirectory(userId), STATE_FILENAME);\n    }\n\n    private static AtomicFile getSavedStateFile(int userId) {\n        File dir = Environment.getUserSystemDirectory(userId);\n        File settingsFile = getStateFile(userId);\n        if (!settingsFile.exists() && userId == UserHandle.USER_SYSTEM) {\n            if (!dir.exists()) {\n                dir.mkdirs();\n            }\n            // Migrate old data\n            File oldFile = new File(\"/data/system/\" + STATE_FILENAME);\n            // Method doesn't throw an exception on failure. Ignore any errors\n            // in moving the file (like non-existence)\n            oldFile.renameTo(settingsFile);\n        }\n        return new AtomicFile(settingsFile);\n    }\n\n    void onUserStopped(int userId) {\n        synchronized (mLock) {\n            boolean crossProfileWidgetsChanged = false;\n\n            // Remove widgets that have both host and provider in the user.\n            final int widgetCount = mWidgets.size();\n            for (int i = widgetCount - 1; i >= 0; i--) {\n                Widget widget = mWidgets.get(i);\n\n                final boolean hostInUser = widget.host.getUserId() == userId;\n                final boolean hasProvider = widget.provider != null;\n                final boolean providerInUser = hasProvider && widget.provider.getUserId() == userId;\n\n                // If both host and provider are in the user, just drop the widgets\n                // as we do not want to make host callbacks and provider broadcasts\n                // as the host and the provider will be killed.\n                if (hostInUser && (!hasProvider || providerInUser)) {\n                    removeWidgetLocked(widget);\n                    widget.host.widgets.remove(widget);\n                    widget.host = null;\n                    if (hasProvider) {\n                        widget.provider.widgets.remove(widget);\n                        widget.provider = null;\n                    }\n                }\n            }\n\n            // Remove hosts and notify providers in other profiles.\n            final int hostCount = mHosts.size();\n            for (int i = hostCount - 1; i >= 0; i--) {\n                Host host = mHosts.get(i);\n                if (host.getUserId() == userId) {\n                    crossProfileWidgetsChanged |= !host.widgets.isEmpty();\n                    deleteHostLocked(host);\n                }\n            }\n\n            // Leave the providers present as hosts will show the widgets\n            // masked while the user is stopped.\n\n            // Remove grants for this user.\n            final int grantCount = mPackagesWithBindWidgetPermission.size();\n            for (int i = grantCount - 1; i >= 0; i--) {\n                Pair<Integer, String> packageId = mPackagesWithBindWidgetPermission.valueAt(i);\n                if (packageId.first == userId) {\n                    mPackagesWithBindWidgetPermission.removeAt(i);\n                }\n            }\n\n            // Take a note we no longer have state for this user.\n            final int userIndex = mLoadedUserIds.indexOfKey(userId);\n            if (userIndex >= 0) {\n                mLoadedUserIds.removeAt(userIndex);\n            }\n\n            // Remove the widget id counter.\n            final int nextIdIndex = mNextAppWidgetIds.indexOfKey(userId);\n            if (nextIdIndex >= 0) {\n                mNextAppWidgetIds.removeAt(nextIdIndex);\n            }\n\n            // Save state if removing a profile changed the group state.\n            // Nothing will be saved if the group parent was removed.\n            if (crossProfileWidgetsChanged) {\n                saveGroupStateAsync(userId);\n            }\n        }\n    }\n\n    private void applyResourceOverlaysToWidgetsLocked(Set<String> packageNames, int userId,\n            boolean updateFrameworkRes) {\n        for (int i = 0, N = mProviders.size(); i < N; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.getUserId() != userId) {\n                continue;\n            }\n\n            final String packageName = provider.id.componentName.getPackageName();\n            if (!updateFrameworkRes && !packageNames.contains(packageName)) {\n                continue;\n            }\n\n            ApplicationInfo newAppInfo = null;\n            try {\n                newAppInfo = mPackageManager.getApplicationInfo(packageName,\n                        PackageManager.GET_SHARED_LIBRARY_FILES, userId);\n            } catch (RemoteException e) {\n                Slog.w(TAG, \"Failed to retrieve app info for \" + packageName\n                        + \" userId=\" + userId, e);\n            }\n            if (newAppInfo == null || provider.info == null\n                    || provider.info.providerInfo == null) {\n                continue;\n            }\n            ApplicationInfo oldAppInfo = provider.info.providerInfo.applicationInfo;\n            if (oldAppInfo == null || !newAppInfo.sourceDir.equals(oldAppInfo.sourceDir)) {\n                // Overlay paths are generated against a particular version of an application.\n                // The overlays paths of a newly upgraded application are incompatible with the\n                // old version of the application.\n                continue;\n            }\n\n            // Isolate the changes relating to RROs. The app info must be copied to prevent\n            // affecting other parts of system server that may have cached this app info.\n            oldAppInfo = new ApplicationInfo(oldAppInfo);\n            oldAppInfo.overlayPaths = newAppInfo.overlayPaths.clone();\n            oldAppInfo.resourceDirs = newAppInfo.resourceDirs.clone();\n            provider.info.providerInfo.applicationInfo = oldAppInfo;\n\n            for (int j = 0, M = provider.widgets.size(); j < M; j++) {\n                Widget widget = provider.widgets.get(j);\n                if (widget.views != null) {\n                    widget.views.updateAppInfo(oldAppInfo);\n                }\n                if (widget.maskedViews != null) {\n                    widget.maskedViews.updateAppInfo(oldAppInfo);\n                }\n            }\n        }\n    }\n\n    /**\n     * Updates all providers with the specified package names, and records any providers that were\n     * pruned.\n     *\n     * @return whether any providers were updated\n     */\n    private boolean updateProvidersForPackageLocked(String packageName, int userId,\n            Set<ProviderId> removedProviders) {\n        boolean providersUpdated = false;\n\n        HashSet<ProviderId> keep = new HashSet<>();\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.setPackage(packageName);\n        List<ResolveInfo> broadcastReceivers = queryIntentReceivers(intent, userId);\n\n        // add the missing ones and collect which ones to keep\n        int N = broadcastReceivers == null ? 0 : broadcastReceivers.size();\n        for (int i = 0; i < N; i++) {\n            ResolveInfo ri = broadcastReceivers.get(i);\n            ActivityInfo ai = ri.activityInfo;\n\n            if ((ai.applicationInfo.flags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {\n                continue;\n            }\n\n            if (packageName.equals(ai.packageName)) {\n                ProviderId providerId = new ProviderId(ai.applicationInfo.uid,\n                        new ComponentName(ai.packageName, ai.name));\n\n                Provider provider = lookupProviderLocked(providerId);\n                if (provider == null) {\n                    if (addProviderLocked(ri)) {\n                        keep.add(providerId);\n                        providersUpdated = true;\n                    }\n                } else {\n                    AppWidgetProviderInfo info =\n                            createPartialProviderInfo(providerId, ri, provider);\n                    if (info != null) {\n                        keep.add(providerId);\n                        // Use the new AppWidgetProviderInfo.\n                        provider.setPartialInfoLocked(info);\n                        // If it's enabled\n                        final int M = provider.widgets.size();\n                        if (M > 0) {\n                            int[] appWidgetIds = getWidgetIds(provider.widgets);\n                            // Reschedule for the new updatePeriodMillis (don't worry about handling\n                            // it specially if updatePeriodMillis didn't change because we just sent\n                            // an update, and the next one will be updatePeriodMillis from now).\n                            cancelBroadcastsLocked(provider);\n                            registerForBroadcastsLocked(provider, appWidgetIds);\n                            // If it's currently showing, call back with the new\n                            // AppWidgetProviderInfo.\n                            for (int j = 0; j < M; j++) {\n                                Widget widget = provider.widgets.get(j);\n                                widget.views = null;\n                                scheduleNotifyProviderChangedLocked(widget);\n                            }\n                            // Now that we've told the host, push out an update.\n                            sendUpdateIntentLocked(provider, appWidgetIds);\n                        }\n                    }\n                    providersUpdated = true;\n                }\n            }\n        }\n\n        // prune the ones we don't want to keep\n        N = mProviders.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Provider provider = mProviders.get(i);\n            if (packageName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId\n                    && !keep.contains(provider.id)) {\n                if (removedProviders != null) {\n                    removedProviders.add(provider.id);\n                }\n                deleteProviderLocked(provider);\n                providersUpdated = true;\n            }\n        }\n\n        return providersUpdated;\n    }\n\n    // Remove widgets for provider in userId that are hosted in parentUserId\n    private void removeWidgetsForPackageLocked(String pkgName, int userId, int parentUserId) {\n        final int N = mProviders.size();\n        for (int i = 0; i < N; ++i) {\n            Provider provider = mProviders.get(i);\n            if (pkgName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId\n                    && provider.widgets.size() > 0) {\n                deleteWidgetsLocked(provider, parentUserId);\n            }\n        }\n    }\n\n    private boolean removeProvidersForPackageLocked(String pkgName, int userId) {\n        boolean removed = false;\n\n        final int N = mProviders.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Provider provider = mProviders.get(i);\n            if (pkgName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId) {\n                deleteProviderLocked(provider);\n                removed = true;\n            }\n        }\n        return removed;\n    }\n\n    private boolean removeHostsAndProvidersForPackageLocked(String pkgName, int userId) {\n        boolean removed = removeProvidersForPackageLocked(pkgName, userId);\n\n        // Delete the hosts for this package too\n        // By now, we have removed any AppWidgets that were in any hosts here,\n        // so we don't need to worry about sending DISABLE broadcasts to them.\n        final int N = mHosts.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Host host = mHosts.get(i);\n            if (pkgName.equals(host.id.packageName)\n                    && host.getUserId() == userId) {\n                deleteHostLocked(host);\n                removed = true;\n            }\n        }\n\n        return removed;\n    }\n\n    private String getCanonicalPackageName(String packageName, String className, int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            try {\n                AppGlobals.getPackageManager().getReceiverInfo(new ComponentName(packageName,\n                        className), 0, userId);\n                return packageName;\n            } catch (RemoteException re) {\n                String[] packageNames = mContext.getPackageManager()\n                        .currentToCanonicalPackageNames(new String[]{packageName});\n                if (packageNames != null && packageNames.length > 0) {\n                    return packageNames[0];\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n        return null;\n    }\n\n    private void sendBroadcastAsUser(Intent intent, UserHandle userHandle) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            mContext.sendBroadcastAsUser(intent, userHandle);\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void bindService(Intent intent, ServiceConnection connection,\n            UserHandle userHandle) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.bindServiceAsUser(intent, connection,\n                    Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE,\n                    userHandle);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void unbindService(ServiceConnection connection) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.unbindService(connection);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public void onCrossProfileWidgetProvidersChanged(int userId, List<String> packages) {\n        final int parentId = mSecurityPolicy.getProfileParent(userId);\n        // We care only if the allowlisted package is in a profile of\n        // the group parent as only the parent can add widgets from the\n        // profile and not the other way around.\n        if (parentId != userId) {\n            synchronized (mLock) {\n                boolean providersChanged = false;\n\n                ArraySet<String> previousPackages = new ArraySet<String>();\n                final int providerCount = mProviders.size();\n                for (int i = 0; i < providerCount; ++i) {\n                    Provider provider = mProviders.get(i);\n                    if (provider.getUserId() == userId) {\n                        previousPackages.add(provider.id.componentName.getPackageName());\n                    }\n                }\n\n                final int packageCount = packages.size();\n                for (int i = 0; i < packageCount; i++) {\n                    String packageName = packages.get(i);\n                    previousPackages.remove(packageName);\n                    providersChanged |= updateProvidersForPackageLocked(packageName,\n                            userId, null);\n                }\n\n                // Remove widgets from hosts in parent user for packages not in the allowlist\n                final int removedCount = previousPackages.size();\n                for (int i = 0; i < removedCount; ++i) {\n                    removeWidgetsForPackageLocked(previousPackages.valueAt(i),\n                            userId, parentId);\n                }\n\n                if (providersChanged || removedCount > 0) {\n                    saveGroupStateAsync(userId);\n                    scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n                }\n            }\n        }\n    }\n\n    private boolean isProfileWithLockedParent(int userId) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            UserInfo userInfo = mUserManager.getUserInfo(userId);\n            if (userInfo != null && userInfo.isProfile()) {\n                UserInfo parentInfo = mUserManager.getProfileParent(userId);\n                if (parentInfo != null\n                        && !isUserRunningAndUnlocked(parentInfo.getUserHandle().getIdentifier())) {\n                    return true;\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n        return false;\n    }\n\n    private boolean isProfileWithUnlockedParent(int userId) {\n        UserInfo userInfo = mUserManager.getUserInfo(userId);\n        if (userInfo != null && userInfo.isProfile()) {\n            UserInfo parentInfo = mUserManager.getProfileParent(userId);\n            if (parentInfo != null\n                    && mUserManager.isUserUnlockingOrUnlocked(parentInfo.getUserHandle())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Note an app widget is tapped on. If a app widget is tapped, the underlying app is treated as\n     * foreground so the app can get while-in-use permission.\n     *\n     * @param callingPackage calling app's packageName.\n     * @param appWidgetId App widget id.\n     */\n    @Override\n    public void noteAppWidgetTapped(String callingPackage, int appWidgetId) {\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n        final int callingUid = Binder.getCallingUid();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            // The launcher must be at TOP.\n            final int procState = mActivityManagerInternal.getUidProcessState(callingUid);\n            if (procState > ActivityManager.PROCESS_STATE_TOP) {\n                return;\n            }\n            synchronized (mLock) {\n                final Widget widget = lookupWidgetLocked(appWidgetId, callingUid, callingPackage);\n                if (widget == null) {\n                    return;\n                }\n                final ProviderId providerId = widget.provider.id;\n                final String packageName = providerId.componentName.getPackageName();\n                if (packageName == null) {\n                    return;\n                }\n                final SparseArray<String> uid2PackageName = new SparseArray<String>();\n                uid2PackageName.put(providerId.uid, packageName);\n                mAppOpsManagerInternal.updateAppWidgetVisibility(uid2PackageName, true);\n                mUsageStatsManagerInternal.reportEvent(packageName,\n                        UserHandle.getUserId(providerId.uid), UsageEvents.Event.USER_INTERACTION);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    private final class CallbackHandler extends Handler {\n        public static final int MSG_NOTIFY_UPDATE_APP_WIDGET = 1;\n        public static final int MSG_NOTIFY_PROVIDER_CHANGED = 2;\n        public static final int MSG_NOTIFY_PROVIDERS_CHANGED = 3;\n        public static final int MSG_NOTIFY_VIEW_DATA_CHANGED = 4;\n        public static final int MSG_NOTIFY_APP_WIDGET_REMOVED = 5;\n\n        public CallbackHandler(Looper looper) {\n            super(looper, null, false);\n        }\n\n        @Override\n        public void handleMessage(Message message) {\n            switch (message.what) {\n                case MSG_NOTIFY_UPDATE_APP_WIDGET: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    RemoteViews views = (RemoteViews) args.arg3;\n                    long requestId = (Long) args.arg4;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n\n                    handleNotifyUpdateAppWidget(host, callbacks, appWidgetId, views, requestId);\n                } break;\n\n                case MSG_NOTIFY_PROVIDER_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    AppWidgetProviderInfo info = (AppWidgetProviderInfo)args.arg3;\n                    long requestId = (Long) args.arg4;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n\n                    handleNotifyProviderChanged(host, callbacks, appWidgetId, info, requestId);\n                } break;\n\n                case MSG_NOTIFY_APP_WIDGET_REMOVED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    long requestId = (Long) args.arg3;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n                    handleNotifyAppWidgetRemoved(host, callbacks, appWidgetId, requestId);\n                } break;\n\n                case MSG_NOTIFY_PROVIDERS_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    args.recycle();\n\n                    handleNotifyProvidersChanged(host, callbacks);\n                } break;\n\n                case MSG_NOTIFY_VIEW_DATA_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    long requestId = (Long) args.arg3;\n                    final int appWidgetId = args.argi1;\n                    final int viewId = args.argi2;\n                    args.recycle();\n\n                    handleNotifyAppWidgetViewDataChanged(host, callbacks, appWidgetId, viewId,\n                            requestId);\n                } break;\n            }\n        }\n    }\n\n    private final class SecurityPolicy {\n\n        public boolean isEnabledGroupProfile(int profileId) {\n            final int parentId = UserHandle.getCallingUserId();\n            return isParentOrProfile(parentId, profileId) && isProfileEnabled(profileId);\n        }\n\n        public int[] getEnabledGroupProfileIds(int userId) {\n            final int parentId = getGroupParent(userId);\n\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return mUserManager.getEnabledProfileIds(parentId);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n\n        public void enforceServiceExistsAndRequiresBindRemoteViewsPermission(\n                ComponentName componentName, int userId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                ServiceInfo serviceInfo = mPackageManager.getServiceInfo(componentName,\n                        PackageManager.GET_PERMISSIONS, userId);\n                if (serviceInfo == null) {\n                    throw new SecurityException(\"Service \" + componentName\n                            + \" not installed for user \" + userId);\n                }\n                if (!android.Manifest.permission.BIND_REMOTEVIEWS.equals(serviceInfo.permission)) {\n                    throw new SecurityException(\"Service \" + componentName\n                            + \" in user \" + userId + \"does not require \"\n                            + android.Manifest.permission.BIND_REMOTEVIEWS);\n                }\n            } catch (RemoteException re) {\n                // Local call - shouldn't happen.\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n\n        public void enforceModifyAppWidgetBindPermissions(String packageName) {\n            mContext.enforceCallingPermission(\n                    android.Manifest.permission.MODIFY_APPWIDGET_BIND_PERMISSIONS,\n                    \"hasBindAppWidgetPermission packageName=\" + packageName);\n        }\n\n        public boolean isCallerInstantAppLocked() {\n            final int callingUid =  Binder.getCallingUid();\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final String[] uidPackages = mPackageManager.getPackagesForUid(callingUid);\n                if (!ArrayUtils.isEmpty(uidPackages)) {\n                    return mPackageManager.isInstantApp(uidPackages[0],\n                            UserHandle.getUserId(callingUid));\n                }\n            } catch (RemoteException e) {\n                /* ignore - same process */\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return false;\n        }\n\n        public boolean isInstantAppLocked(String packageName, int userId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return mPackageManager.isInstantApp(packageName, userId);\n            } catch (RemoteException e) {\n                /* ignore - same process */\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return false;\n        }\n\n        public void enforceCallFromPackage(String packageName) {\n            mAppOpsManager.checkPackage(Binder.getCallingUid(), packageName);\n        }\n\n        public boolean hasCallerBindPermissionOrBindWhiteListedLocked(String packageName) {\n            try {\n                mContext.enforceCallingOrSelfPermission(\n                        android.Manifest.permission.BIND_APPWIDGET, null);\n            } catch (SecurityException se) {\n                if (!isCallerBindAppWidgetWhiteListedLocked(packageName)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private boolean isCallerBindAppWidgetWhiteListedLocked(String packageName) {\n            final int userId = UserHandle.getCallingUserId();\n            final int packageUid = getUidForPackage(packageName, userId);\n            if (packageUid < 0) {\n                throw new IllegalArgumentException(\"No package \" + packageName\n                        + \" for user \" + userId);\n            }\n            synchronized (mLock) {\n                ensureGroupStateLoadedLocked(userId);\n\n                Pair<Integer, String> packageId = Pair.create(userId, packageName);\n                if (mPackagesWithBindWidgetPermission.contains(packageId)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        public boolean canAccessAppWidget(Widget widget, int uid, String packageName) {\n            if (isHostInPackageForUid(widget.host, uid, packageName)) {\n                // Apps hosting the AppWidget have access to it.\n                return true;\n            }\n            if (isProviderInPackageForUid(widget.provider, uid, packageName)) {\n                // Apps providing the AppWidget have access to it.\n                return true;\n            }\n            if (isHostAccessingProvider(widget.host, widget.provider, uid, packageName)) {\n                // Apps hosting the AppWidget get to bind to a remote view service in the provider.\n                return true;\n            }\n            final int userId = UserHandle.getUserId(uid);\n            if ((widget.host.getUserId() == userId || (widget.provider != null\n                    && widget.provider.getUserId() == userId))\n                && mContext.checkCallingPermission(android.Manifest.permission.BIND_APPWIDGET)\n                    == PackageManager.PERMISSION_GRANTED) {\n                // Apps that run in the same user as either the host or the provider and\n                // have the bind widget permission have access to the widget.\n                return true;\n            }\n            return false;\n        }\n\n        private boolean isParentOrProfile(int parentId, int profileId) {\n            if (parentId == profileId) {\n                return true;\n            }\n            return getProfileParent(profileId) == parentId;\n        }\n\n        public boolean isProviderInCallerOrInProfileAndWhitelListed(String packageName,\n                int profileId) {\n            final int callerId = UserHandle.getCallingUserId();\n            if (profileId == callerId) {\n                return true;\n            }\n            final int parentId = getProfileParent(profileId);\n            if (parentId != callerId) {\n                return false;\n            }\n            return isProviderWhiteListed(packageName, profileId);\n        }\n\n        public boolean isProviderWhiteListed(String packageName, int profileId) {\n            // If the policy manager is not available on the device we deny it all.\n            if (mDevicePolicyManagerInternal == null) {\n                return false;\n            }\n\n            List<String> crossProfilePackages = mDevicePolicyManagerInternal\n                    .getCrossProfileWidgetProviders(profileId);\n\n            return crossProfilePackages.contains(packageName);\n        }\n\n        public int getProfileParent(int profileId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                UserInfo parent = mUserManager.getProfileParent(profileId);\n                if (parent != null) {\n                    return parent.getUserHandle().getIdentifier();\n                }\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return UNKNOWN_USER_ID;\n        }\n\n        public int getGroupParent(int profileId) {\n            final int parentId = mSecurityPolicy.getProfileParent(profileId);\n            return (parentId != UNKNOWN_USER_ID) ? parentId : profileId;\n        }\n\n        public boolean isHostInPackageForUid(Host host, int uid, String packageName) {\n            return host.id.uid == uid && host.id.packageName.equals(packageName);\n        }\n\n        public boolean isProviderInPackageForUid(Provider provider, int uid,\n                String packageName) {\n            // Packages providing the AppWidget have access to it.\n            return provider != null && provider.id.uid == uid\n                    && provider.id.componentName.getPackageName().equals(packageName);\n        }\n\n        public boolean isHostAccessingProvider(Host host, Provider provider, int uid,\n                String packageName) {\n            // The host creates a package context to bind to remote views service in the provider.\n            return host.id.uid == uid && provider != null\n                    && provider.id.componentName.getPackageName().equals(packageName);\n        }\n\n        private boolean isProfileEnabled(int profileId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                UserInfo userInfo = mUserManager.getUserInfo(profileId);\n                if (userInfo == null || !userInfo.isEnabled()) {\n                    return false;\n                }\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return true;\n        }\n    }\n\n    private static final class Provider {\n\n        ProviderId id;\n        AppWidgetProviderInfo info;\n        ArrayList<Widget> widgets = new ArrayList<>();\n        PendingIntent broadcast;\n        String infoTag;\n\n        boolean zombie; // if we're in safe mode, don't prune this just because nobody references it\n\n        boolean maskedByLockedProfile;\n        boolean maskedByQuietProfile;\n        boolean maskedBySuspendedPackage;\n\n        boolean mInfoParsed = false;\n\n        int tag = TAG_UNDEFINED; // for use while saving state (the index)\n\n        public int getUserId() {\n            return UserHandle.getUserId(id.uid);\n        }\n\n        public boolean isInPackageForUser(String packageName, int userId) {\n            return getUserId() == userId\n                    && id.componentName.getPackageName().equals(packageName);\n        }\n\n        // is there an instance of this provider hosted by the given app?\n        public boolean hostedByPackageForUser(String packageName, int userId) {\n            final int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = widgets.get(i);\n                if (packageName.equals(widget.host.id.packageName)\n                        && widget.host.getUserId() == userId) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @GuardedBy(\"mLock\")\n        public AppWidgetProviderInfo getInfoLocked(Context context) {\n            if (!mInfoParsed) {\n                // parse\n                if (!zombie) {\n                    AppWidgetProviderInfo newInfo = null;\n                    if (!TextUtils.isEmpty(infoTag)) {\n                        newInfo = parseAppWidgetProviderInfo(\n                                context, id, info.providerInfo, infoTag);\n                    }\n                    if (newInfo == null) {\n                        newInfo = parseAppWidgetProviderInfo(context, id, info.providerInfo,\n                                AppWidgetManager.META_DATA_APPWIDGET_PROVIDER);\n                    }\n                    if (newInfo != null) {\n                        info = newInfo;\n                    }\n                }\n                mInfoParsed = true;\n            }\n            return info;\n        }\n\n        /**\n         * Returns the last updated AppWidgetProviderInfo for this provider. This info may not\n         * be completely parsed and only contain placeHolder information like\n         * {@link AppWidgetProviderInfo#providerInfo}\n         */\n        @GuardedBy(\"mLock\")\n        public AppWidgetProviderInfo getPartialInfoLocked() {\n            return info;\n        }\n\n        @GuardedBy(\"mLock\")\n        public void setPartialInfoLocked(AppWidgetProviderInfo info) {\n            this.info = info;\n            mInfoParsed = false;\n        }\n\n        @GuardedBy(\"mLock\")\n        public void setInfoLocked(AppWidgetProviderInfo info) {\n            this.info = info;\n            mInfoParsed = true;\n        }\n\n        @Override\n        public String toString() {\n            return \"Provider{\" + id + (zombie ? \" Z\" : \"\") + '}';\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedByQuietProfileLocked(boolean masked) {\n            boolean oldState = maskedByQuietProfile;\n            maskedByQuietProfile = masked;\n            return masked != oldState;\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedByLockedProfileLocked(boolean masked) {\n            boolean oldState = maskedByLockedProfile;\n            maskedByLockedProfile = masked;\n            return masked != oldState;\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedBySuspendedPackageLocked(boolean masked) {\n            boolean oldState = maskedBySuspendedPackage;\n            maskedBySuspendedPackage = masked;\n            return masked != oldState;\n        }\n\n        public boolean isMaskedLocked() {\n            return maskedByQuietProfile || maskedByLockedProfile || maskedBySuspendedPackage;\n        }\n\n        public boolean shouldBePersisted() {\n            return !widgets.isEmpty() || !TextUtils.isEmpty(infoTag);\n        }\n    }\n\n    private static final class ProviderId {\n        final int uid;\n        final ComponentName componentName;\n\n        private ProviderId(int uid, ComponentName componentName) {\n            this.uid = uid;\n            this.componentName = componentName;\n        }\n\n        public UserHandle getProfile() {\n            return UserHandle.getUserHandleForUid(uid);\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            ProviderId other = (ProviderId) obj;\n            if (uid != other.uid)  {\n                return false;\n            }\n            if (componentName == null) {\n                if (other.componentName != null) {\n                    return false;\n                }\n            } else if (!componentName.equals(other.componentName)) {\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = uid;\n            result = 31 * result + ((componentName != null)\n                    ? componentName.hashCode() : 0);\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return \"ProviderId{user:\" + UserHandle.getUserId(uid) + \", app:\"\n                    + UserHandle.getAppId(uid) + \", cmp:\" + componentName + '}';\n        }\n    }\n\n    private static final class Host {\n        HostId id;\n        ArrayList<Widget> widgets = new ArrayList<>();\n        IAppWidgetHost callbacks;\n        boolean zombie; // if we're in safe mode, don't prune this just because nobody references it\n\n        int tag = TAG_UNDEFINED; // for use while saving state (the index)\n        // Sequence no for the last update successfully sent. This is updated whenever a\n        // widget update is successfully sent to the host callbacks. As all new/undelivered updates\n        // will have sequenceNo greater than this, all those updates will be sent when the host\n        // callbacks are attached again.\n        long lastWidgetUpdateSequenceNo;\n\n        public int getUserId() {\n            return UserHandle.getUserId(id.uid);\n        }\n\n        public boolean isInPackageForUser(String packageName, int userId) {\n            return getUserId() == userId && id.packageName.equals(packageName);\n        }\n\n        private boolean hostsPackageForUser(String pkg, int userId) {\n            final int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = widgets.get(i).provider;\n                if (provider != null && provider.getUserId() == userId\n                        && pkg.equals(provider.id.componentName.getPackageName())) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /**\n         * Adds all pending updates in {@param outUpdates} keys by the update time.\n         */\n        public void getPendingUpdatesForIdLocked(Context context, int appWidgetId,\n                LongSparseArray<PendingHostUpdate> outUpdates) {\n            long updateSequenceNo = lastWidgetUpdateSequenceNo;\n            int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = widgets.get(i);\n                if (widget.appWidgetId == appWidgetId) {\n                    for (int j = widget.updateSequenceNos.size() - 1; j >= 0; j--) {\n                        long requestId = widget.updateSequenceNos.valueAt(j);\n                        if (requestId <= updateSequenceNo) {\n                            continue;\n                        }\n                        int id = widget.updateSequenceNos.keyAt(j);\n                        final PendingHostUpdate update;\n                        switch (id) {\n                            case ID_PROVIDER_CHANGED:\n                                update = PendingHostUpdate.providerChanged(\n                                        appWidgetId, widget.provider.getInfoLocked(context));\n                                break;\n                            case ID_VIEWS_UPDATE:\n                                update = PendingHostUpdate.updateAppWidget(appWidgetId,\n                                        cloneIfLocalBinder(widget.getEffectiveViewsLocked()));\n                                break;\n                            default:\n                                update = PendingHostUpdate.viewDataChanged(appWidgetId, id);\n                        }\n                        outUpdates.put(requestId, update);\n                    }\n                    return;\n                }\n            }\n            outUpdates.put(lastWidgetUpdateSequenceNo,\n                    PendingHostUpdate.appWidgetRemoved(appWidgetId));\n        }\n\n        public SparseArray<String> getWidgetUids() {\n            final SparseArray<String> uids = new SparseArray<>();\n            for (int i = widgets.size() - 1; i >= 0; i--) {\n                final Widget widget = widgets.get(i);\n                final ProviderId providerId = widget.provider.id;\n                uids.put(providerId.uid, providerId.componentName.getPackageName());\n            }\n            return uids;\n        }\n\n        @Override\n        public String toString() {\n            return \"Host{\" + id + (zombie ? \" Z\" : \"\") + '}';\n        }\n    }\n\n    private static final class HostId {\n        final int uid;\n        final int hostId;\n        final String packageName;\n\n        public HostId(int uid, int hostId, String packageName) {\n            this.uid = uid;\n            this.hostId = hostId;\n            this.packageName = packageName;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            HostId other = (HostId) obj;\n            if (uid != other.uid)  {\n                return false;\n            }\n            if (hostId != other.hostId) {\n                return false;\n            }\n            if (packageName == null) {\n                if (other.packageName != null) {\n                    return false;\n                }\n            } else if (!packageName.equals(other.packageName)) {\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = uid;\n            result = 31 * result + hostId;\n            result = 31 * result + ((packageName != null)\n                    ? packageName.hashCode() : 0);\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return \"HostId{user:\" + UserHandle.getUserId(uid) + \", app:\"\n                    + UserHandle.getAppId(uid) + \", hostId:\" + hostId\n                    + \", pkg:\" + packageName + '}';\n        }\n    }\n\n    // These can be any constants that would not collide with a resource id.\n    private static final int ID_VIEWS_UPDATE = 0;\n    private static final int ID_PROVIDER_CHANGED = 1;\n\n    private static final class Widget {\n        int appWidgetId;\n        int restoredId;  // tracking & remapping any restored state\n        Provider provider;\n        RemoteViews views;\n        RemoteViews maskedViews;\n        Bundle options;\n        Host host;\n        // Map of request type to updateSequenceNo.\n        SparseLongArray updateSequenceNos = new SparseLongArray(2);\n\n        @Override\n        public String toString() {\n            return \"AppWidgetId{\" + appWidgetId + ':' + host + ':' + provider + '}';\n        }\n\n        private boolean replaceWithMaskedViewsLocked(RemoteViews views) {\n            maskedViews = views;\n            return true;\n        }\n\n        private boolean clearMaskedViewsLocked() {\n            if (maskedViews != null) {\n                maskedViews = null;\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        public RemoteViews getEffectiveViewsLocked() {\n            return maskedViews != null ? maskedViews : views;\n        }\n    }\n\n    private class LoadedWidgetState {\n        final Widget widget;\n        final int hostTag;\n        final int providerTag;\n\n        public LoadedWidgetState(Widget widget, int hostTag, int providerTag) {\n            this.widget = widget;\n            this.hostTag = hostTag;\n            this.providerTag = providerTag;\n        }\n    }\n\n    private final class SaveStateRunnable implements Runnable {\n        final int mUserId;\n\n        public SaveStateRunnable(int userId) {\n            mUserId = userId;\n        }\n\n        @Override\n        public void run() {\n            synchronized (mLock) {\n                // No need to enforce unlocked state when there is no caller. User can be in the\n                // stopping state or removed by the time the message is processed\n                ensureGroupStateLoadedLocked(mUserId, false /* enforceUserUnlockingOrUnlocked */ );\n                saveStateLocked(mUserId);\n            }\n        }\n    }\n\n    /**\n     * This class encapsulates the backup and restore logic for a user group state.\n     */\n    private final class BackupRestoreController {\n        private static final String TAG = \"BackupRestoreController\";\n\n        private static final boolean DEBUG = true;\n\n        // Version of backed-up widget state.\n        private static final int WIDGET_STATE_VERSION = 2;\n\n        // We need to make sure to wipe the pre-restore widget state only once for\n        // a given package.  Keep track of what we've done so far here; the list is\n        // cleared at the start of every system restore pass, but preserved through\n        // any install-time restore operations.\n        private final HashSet<String> mPrunedApps = new HashSet<>();\n\n        private final HashMap<Provider, ArrayList<RestoreUpdateRecord>> mUpdatesByProvider =\n                new HashMap<>();\n        private final HashMap<Host, ArrayList<RestoreUpdateRecord>> mUpdatesByHost =\n                new HashMap<>();\n\n        @GuardedBy(\"mLock\")\n        private boolean mHasSystemRestoreFinished;\n\n        public List<String> getWidgetParticipants(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Getting widget participants for user: \" + userId);\n            }\n\n            HashSet<String> packages = new HashSet<>();\n            synchronized (mLock) {\n                final int N = mWidgets.size();\n                for (int i = 0; i < N; i++) {\n                    Widget widget = mWidgets.get(i);\n\n                    // Skip cross-user widgets.\n                    if (!isProviderAndHostInUser(widget, userId)) {\n                        continue;\n                    }\n\n                    packages.add(widget.host.id.packageName);\n                    Provider provider = widget.provider;\n                    if (provider != null) {\n                        packages.add(provider.id.componentName.getPackageName());\n                    }\n                }\n            }\n            return new ArrayList<>(packages);\n        }\n\n        public byte[] getWidgetState(String backedupPackage, int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Getting widget state for user: \" + userId);\n            }\n\n            ByteArrayOutputStream stream = new ByteArrayOutputStream();\n            synchronized (mLock) {\n                // Preflight: if this app neither hosts nor provides any live widgets\n                // we have no work to do.\n                if (!packageNeedsWidgetBackupLocked(backedupPackage, userId)) {\n                    return null;\n                }\n\n                try {\n                    TypedXmlSerializer out = Xml.newFastSerializer();\n                    out.setOutput(stream, StandardCharsets.UTF_8.name());\n                    out.startDocument(null, true);\n                    out.startTag(null, \"ws\");      // widget state\n                    out.attributeInt(null, \"version\", WIDGET_STATE_VERSION);\n                    out.attribute(null, \"pkg\", backedupPackage);\n\n                    // Remember all the providers that are currently hosted or published\n                    // by this package: that is, all of the entities related to this app\n                    // which will need to be told about id remapping.\n                    int index = 0;\n                    int N = mProviders.size();\n                    for (int i = 0; i < N; i++) {\n                        Provider provider = mProviders.get(i);\n\n                        if (provider.shouldBePersisted()\n                                && (provider.isInPackageForUser(backedupPackage, userId)\n                                || provider.hostedByPackageForUser(backedupPackage, userId))) {\n                            provider.tag = index;\n                            serializeProvider(out, provider);\n                            index++;\n                        }\n                    }\n\n                    N = mHosts.size();\n                    index = 0;\n                    for (int i = 0; i < N; i++) {\n                        Host host = mHosts.get(i);\n\n                        if (!host.widgets.isEmpty()\n                                && (host.isInPackageForUser(backedupPackage, userId)\n                                || host.hostsPackageForUser(backedupPackage, userId))) {\n                            host.tag = index;\n                            serializeHost(out, host);\n                            index++;\n                        }\n                    }\n\n                    // All widget instances involving this package,\n                    // either as host or as provider\n                    N = mWidgets.size();\n                    for (int i = 0; i < N; i++) {\n                        Widget widget = mWidgets.get(i);\n\n                        Provider provider = widget.provider;\n                        if (widget.host.isInPackageForUser(backedupPackage, userId)\n                                || (provider != null\n                                &&  provider.isInPackageForUser(backedupPackage, userId))) {\n                            serializeAppWidget(out, widget, false);\n                        }\n                    }\n\n                    out.endTag(null, \"ws\");\n                    out.endDocument();\n                } catch (IOException e) {\n                    Slog.w(TAG, \"Unable to save widget state for \" + backedupPackage);\n                    return null;\n                }\n            }\n\n            return stream.toByteArray();\n        }\n\n        public void systemRestoreStarting(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"System restore starting for user: \" + userId);\n            }\n\n            synchronized (mLock) {\n                mHasSystemRestoreFinished = false;\n                // We're starting a new \"system\" restore operation, so any widget restore\n                // state that we see from here on is intended to replace the current\n                // widget configuration of any/all of the affected apps.\n                mPrunedApps.clear();\n                mUpdatesByProvider.clear();\n                mUpdatesByHost.clear();\n            }\n        }\n\n        public void restoreWidgetState(String packageName, byte[] restoredState, int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Restoring widget state for user:\" + userId\n                        + \" package: \" + packageName);\n            }\n\n            ByteArrayInputStream stream = new ByteArrayInputStream(restoredState);\n            try {\n                // Providers mentioned in the widget dataset by ordinal\n                ArrayList<Provider> restoredProviders = new ArrayList<>();\n\n                // Hosts mentioned in the widget dataset by ordinal\n                ArrayList<Host> restoredHosts = new ArrayList<>();\n\n                TypedXmlPullParser parser = Xml.newFastPullParser();\n                parser.setInput(stream, StandardCharsets.UTF_8.name());\n\n                synchronized (mLock) {\n                    int type;\n                    do {\n                        type = parser.next();\n                        if (type == XmlPullParser.START_TAG) {\n                            final String tag = parser.getName();\n                            if (\"ws\".equals(tag)) {\n                                final int versionNumber = parser.getAttributeInt(null, \"version\");\n                                if (versionNumber > WIDGET_STATE_VERSION) {\n                                    Slog.w(TAG, \"Unable to process state version \" + versionNumber);\n                                    return;\n                                }\n\n                                // TODO: fix up w.r.t. canonical vs current package names\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n                                if (!packageName.equals(pkg)) {\n                                    Slog.w(TAG, \"Package mismatch in ws\");\n                                    return;\n                                }\n                            } else if (\"p\".equals(tag)) {\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n                                String cl = parser.getAttributeValue(null, \"cl\");\n\n                                // hostedProviders index will match 'p' attribute in widget's\n                                // entry in the xml file being restored\n                                // If there's no live entry for this provider, add an inactive one\n                                // so that widget IDs referring to them can be properly allocated\n\n                                // Backup and resotre only for the parent profile.\n                                ComponentName componentName = new ComponentName(pkg, cl);\n\n                                Provider p = findProviderLocked(componentName, userId);\n                                if (p == null) {\n                                    AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n                                    info.provider = componentName;\n\n                                    p = new Provider();\n                                    p.id = new ProviderId(UNKNOWN_UID, componentName);\n                                    p.setPartialInfoLocked(info);\n                                    p.zombie = true;\n                                    mProviders.add(p);\n                                }\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   provider \" + p.id);\n                                }\n                                restoredProviders.add(p);\n                            } else if (\"h\".equals(tag)) {\n                                // The host app may not yet exist on the device.  If it's here we\n                                // just use the existing Host entry, otherwise we create a\n                                // placeholder whose uid will be fixed up at PACKAGE_ADDED time.\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n\n                                final int uid = getUidForPackage(pkg, userId);\n                                final int hostId = parser.getAttributeIntHex(null, \"id\");\n\n                                HostId id = new HostId(uid, hostId, pkg);\n                                Host h = lookupOrAddHostLocked(id);\n                                restoredHosts.add(h);\n\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   host[\" + restoredHosts.size()\n                                            + \"]: {\" + h.id + \"}\");\n                                }\n                            } else if (\"g\".equals(tag)) {\n                                int restoredId = parser.getAttributeIntHex(null, \"id\");\n                                int hostIndex = parser.getAttributeIntHex(null, \"h\");\n                                Host host = restoredHosts.get(hostIndex);\n                                Provider p = null;\n                                int which = parser.getAttributeIntHex(null, \"p\", -1);\n                                if (which != -1) {\n                                    // could have been null if the app had allocated an id\n                                    // but not yet established a binding under that id\n                                    p = restoredProviders.get(which);\n                                }\n\n                                // We'll be restoring widget state for both the host and\n                                // provider sides of this widget ID, so make sure we are\n                                // beginning from a clean slate on both fronts.\n                                pruneWidgetStateLocked(host.id.packageName, userId);\n                                if (p != null) {\n                                    pruneWidgetStateLocked(p.id.componentName.getPackageName(),\n                                            userId);\n                                }\n\n                                // Have we heard about this ancestral widget instance before?\n                                Widget id = findRestoredWidgetLocked(restoredId, host, p);\n                                if (id == null) {\n                                    id = new Widget();\n                                    id.appWidgetId = incrementAndGetAppWidgetIdLocked(userId);\n                                    id.restoredId = restoredId;\n                                    id.options = parseWidgetIdOptions(parser);\n                                    id.host = host;\n                                    id.host.widgets.add(id);\n                                    id.provider = p;\n                                    if (id.provider != null) {\n                                        id.provider.widgets.add(id);\n                                    }\n                                    if (DEBUG) {\n                                        Slog.i(TAG, \"New restored id \" + restoredId\n                                                + \" now \" + id);\n                                    }\n                                    addWidgetLocked(id);\n                                }\n                                if (id.provider != null\n                                        && id.provider.getPartialInfoLocked() != null) {\n                                    stashProviderRestoreUpdateLocked(id.provider,\n                                            restoredId, id.appWidgetId);\n                                } else {\n                                    Slog.w(TAG, \"Missing provider for restored widget \" + id);\n                                }\n                                stashHostRestoreUpdateLocked(id.host, restoredId, id.appWidgetId);\n\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   instance: \" + restoredId\n                                            + \" -> \" + id.appWidgetId\n                                            + \" :: p=\" + id.provider);\n                                }\n                            }\n                        }\n                    } while (type != XmlPullParser.END_DOCUMENT);\n\n                    // We've updated our own bookkeeping.  We'll need to notify the hosts and\n                    // providers about the changes, but we can't do that yet because the restore\n                    // target is not necessarily fully live at this moment.  Set aside the\n                    // information for now; the backup manager will call us once more at the\n                    // end of the process when all of the targets are in a known state, and we\n                    // will update at that point.\n                }\n            } catch (XmlPullParserException | IOException e) {\n                Slog.w(TAG, \"Unable to restore widget state for \" + packageName);\n            } finally {\n                saveGroupStateAsync(userId);\n            }\n        }\n\n        // Called once following the conclusion of a system restore operation.  This is when we\n        // send out updates to apps involved in widget-state restore telling them about\n        // the new widget ID space.  Apps that are not yet installed will be notifed when they are.\n        public void systemRestoreFinished(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"systemRestoreFinished for \" + userId);\n            }\n            synchronized (mLock) {\n                mHasSystemRestoreFinished = true;\n                maybeSendWidgetRestoreBroadcastsLocked(userId);\n            }\n        }\n\n        // Called when widget components (hosts or providers) are added or changed.  If system\n        // restore has completed, we use this opportunity to tell the apps to update to the new\n        // widget ID space.  If system restore is still in progress, we delay the updates until\n        // the end, to allow all participants to restore their state before updating widget IDs.\n        public void widgetComponentsChanged(int userId) {\n            synchronized (mLock) {\n                if (mHasSystemRestoreFinished) {\n                    maybeSendWidgetRestoreBroadcastsLocked(userId);\n                }\n            }\n        }\n\n        // Called following the conclusion of a restore operation and when widget components\n        // are added or changed.  This is when we send out updates to apps involved in widget-state\n        // restore telling them about the new widget ID space.\n        @GuardedBy(\"mLock\")\n        private void maybeSendWidgetRestoreBroadcastsLocked(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"maybeSendWidgetRestoreBroadcasts for \" + userId);\n            }\n\n            final UserHandle userHandle = new UserHandle(userId);\n            // Build the providers' broadcasts and send them off\n            Set<Map.Entry<Provider, ArrayList<RestoreUpdateRecord>>> providerEntries\n                    = mUpdatesByProvider.entrySet();\n            for (Map.Entry<Provider, ArrayList<RestoreUpdateRecord>> e : providerEntries) {\n                // For each provider there's a list of affected IDs\n                Provider provider = e.getKey();\n                if (provider.zombie) {\n                    // Provider not installed, we can't send them broadcasts yet.\n                    // We'll be called again when the provider is installed.\n                    continue;\n                }\n                ArrayList<RestoreUpdateRecord> updates = e.getValue();\n                final int pending = countPendingUpdates(updates);\n                if (DEBUG) {\n                    Slog.i(TAG, \"Provider \" + provider + \" pending: \" + pending);\n                }\n                if (pending > 0) {\n                    int[] oldIds = new int[pending];\n                    int[] newIds = new int[pending];\n                    final int N = updates.size();\n                    int nextPending = 0;\n                    for (int i = 0; i < N; i++) {\n                        RestoreUpdateRecord r = updates.get(i);\n                        if (!r.notified) {\n                            r.notified = true;\n                            oldIds[nextPending] = r.oldId;\n                            newIds[nextPending] = r.newId;\n                            nextPending++;\n                            if (DEBUG) {\n                                Slog.i(TAG, \"   \" + r.oldId + \" => \" + r.newId);\n                            }\n                        }\n                    }\n                    sendWidgetRestoreBroadcastLocked(\n                            AppWidgetManager.ACTION_APPWIDGET_RESTORED,\n                            provider, null, oldIds, newIds, userHandle);\n                }\n            }\n\n            // same thing per host\n            Set<Map.Entry<Host, ArrayList<RestoreUpdateRecord>>> hostEntries\n                    = mUpdatesByHost.entrySet();\n            for (Map.Entry<Host, ArrayList<RestoreUpdateRecord>> e : hostEntries) {\n                Host host = e.getKey();\n                if (host.id.uid != UNKNOWN_UID) {\n                    ArrayList<RestoreUpdateRecord> updates = e.getValue();\n                    final int pending = countPendingUpdates(updates);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Host \" + host + \" pending: \" + pending);\n                    }\n                    if (pending > 0) {\n                        int[] oldIds = new int[pending];\n                        int[] newIds = new int[pending];\n                        final int N = updates.size();\n                        int nextPending = 0;\n                        for (int i = 0; i < N; i++) {\n                            RestoreUpdateRecord r = updates.get(i);\n                            if (!r.notified) {\n                                r.notified = true;\n                                oldIds[nextPending] = r.oldId;\n                                newIds[nextPending] = r.newId;\n                                nextPending++;\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   \" + r.oldId + \" => \" + r.newId);\n                                }\n                            }\n                        }\n                        sendWidgetRestoreBroadcastLocked(\n                                AppWidgetManager.ACTION_APPWIDGET_HOST_RESTORED,\n                                null, host, oldIds, newIds, userHandle);\n                    }\n                }\n            }\n        }\n\n        private Provider findProviderLocked(ComponentName componentName, int userId) {\n            final int providerCount = mProviders.size();\n            for (int i = 0; i < providerCount; i++) {\n                Provider provider = mProviders.get(i);\n                if (provider.getUserId() == userId\n                        && provider.id.componentName.equals(componentName)) {\n                    return provider;\n                }\n            }\n            return null;\n        }\n\n        private Widget findRestoredWidgetLocked(int restoredId, Host host, Provider p) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Find restored widget: id=\" + restoredId\n                        + \" host=\" + host + \" provider=\" + p);\n            }\n\n            if (p == null || host == null) {\n                return null;\n            }\n\n            final int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n                if (widget.restoredId == restoredId\n                        && widget.host.id.equals(host.id)\n                        && widget.provider.id.equals(p.id)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"   Found at \" + i + \" : \" + widget);\n                    }\n                    return widget;\n                }\n            }\n            return null;\n        }\n\n        private boolean packageNeedsWidgetBackupLocked(String packageName, int userId) {\n            int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n\n                // Skip cross-user widgets.\n                if (!isProviderAndHostInUser(widget, userId)) {\n                    continue;\n                }\n\n                if (widget.host.isInPackageForUser(packageName, userId)) {\n                    // this package is hosting widgets, so it knows widget IDs.\n                    return true;\n                }\n\n                Provider provider = widget.provider;\n                if (provider != null && provider.isInPackageForUser(packageName, userId)) {\n                    // someone is hosting this app's widgets, so it knows widget IDs.\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private void stashProviderRestoreUpdateLocked(Provider provider, int oldId, int newId) {\n            ArrayList<RestoreUpdateRecord> r = mUpdatesByProvider.get(provider);\n            if (r == null) {\n                r = new ArrayList<>();\n                mUpdatesByProvider.put(provider, r);\n            } else {\n                // don't duplicate\n                if (alreadyStashed(r, oldId, newId)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"ID remap \" + oldId + \" -> \" + newId\n                                + \" already stashed for \" + provider);\n                    }\n                    return;\n                }\n            }\n            r.add(new RestoreUpdateRecord(oldId, newId));\n        }\n\n        private boolean alreadyStashed(ArrayList<RestoreUpdateRecord> stash,\n                final int oldId, final int newId) {\n            final int N = stash.size();\n            for (int i = 0; i < N; i++) {\n                RestoreUpdateRecord r = stash.get(i);\n                if (r.oldId == oldId && r.newId == newId) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private void stashHostRestoreUpdateLocked(Host host, int oldId, int newId) {\n            ArrayList<RestoreUpdateRecord> r = mUpdatesByHost.get(host);\n            if (r == null) {\n                r = new ArrayList<>();\n                mUpdatesByHost.put(host, r);\n            } else {\n                if (alreadyStashed(r, oldId, newId)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"ID remap \" + oldId + \" -> \" + newId\n                                + \" already stashed for \" + host);\n                    }\n                    return;\n                }\n            }\n            r.add(new RestoreUpdateRecord(oldId, newId));\n        }\n\n        private void sendWidgetRestoreBroadcastLocked(String action, Provider provider,\n                Host host, int[] oldIds, int[] newIds, UserHandle userHandle) {\n            Intent intent = new Intent(action);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OLD_IDS, oldIds);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, newIds);\n            if (provider != null) {\n                intent.setComponent(provider.id.componentName);\n                sendBroadcastAsUser(intent, userHandle);\n            }\n            if (host != null) {\n                intent.setComponent(null);\n                intent.setPackage(host.id.packageName);\n                intent.putExtra(AppWidgetManager.EXTRA_HOST_ID, host.id.hostId);\n                sendBroadcastAsUser(intent, userHandle);\n            }\n        }\n\n        // We're restoring widget state for 'pkg', so we start by wiping (a) all widget\n        // instances that are hosted by that app, and (b) all instances in other hosts\n        // for which 'pkg' is the provider.  We assume that we'll be restoring all of\n        // these hosts & providers, so will be reconstructing a correct live state.\n        private void pruneWidgetStateLocked(String pkg, int userId) {\n            if (!mPrunedApps.contains(pkg)) {\n                if (DEBUG) {\n                    Slog.i(TAG, \"pruning widget state for restoring package \" + pkg);\n                }\n                for (int i = mWidgets.size() - 1; i >= 0; i--) {\n                    Widget widget = mWidgets.get(i);\n\n                    Host host = widget.host;\n                    Provider provider = widget.provider;\n\n                    if (host.hostsPackageForUser(pkg, userId)\n                            || (provider != null && provider.isInPackageForUser(pkg, userId))) {\n                        // 'pkg' is either the host or the provider for this instances,\n                        // so we tear it down in anticipation of it (possibly) being\n                        // reconstructed due to the restore\n                        host.widgets.remove(widget);\n                        provider.widgets.remove(widget);\n                        // Check if we need to destroy any services (if no other app widgets are\n                        // referencing the same service)\n                        decrementAppWidgetServiceRefCount(widget);\n                        removeWidgetLocked(widget);\n                    }\n                }\n                mPrunedApps.add(pkg);\n            } else {\n                if (DEBUG) {\n                    Slog.i(TAG, \"already pruned \" + pkg + \", continuing normally\");\n                }\n            }\n        }\n\n        private boolean isProviderAndHostInUser(Widget widget, int userId) {\n            // Backup only widgets hosted or provided by the owner profile.\n            return widget.host.getUserId() == userId && (widget.provider == null\n                    || widget.provider.getUserId() == userId);\n        }\n\n        private int countPendingUpdates(ArrayList<RestoreUpdateRecord> updates) {\n            int pending = 0;\n            final int N = updates.size();\n            for (int i = 0; i < N; i++) {\n                RestoreUpdateRecord r = updates.get(i);\n                if (!r.notified) {\n                    pending++;\n                }\n            }\n            return pending;\n        }\n\n        // Accumulate a list of updates that affect the given provider for a final\n        // coalesced notification broadcast once restore is over.\n        private class RestoreUpdateRecord {\n            public int oldId;\n            public int newId;\n            public boolean notified;\n\n            public RestoreUpdateRecord(int theOldId, int theNewId) {\n                oldId = theOldId;\n                newId = theNewId;\n                notified = false;\n            }\n        }\n    }\n\n    private class AppWidgetManagerLocal extends AppWidgetManagerInternal {\n        @Override\n        public ArraySet<String> getHostedWidgetPackages(int uid) {\n            synchronized (mLock) {\n                ArraySet<String> widgetPackages = null;\n                final int widgetCount = mWidgets.size();\n                for (int i = 0; i < widgetCount; i++) {\n                    final Widget widget = mWidgets.get(i);\n                    if  (widget.host.id.uid == uid && widget.provider != null) {\n                        if (widgetPackages == null) {\n                            widgetPackages = new ArraySet<>();\n                        }\n                        widgetPackages.add(widget.provider.id.componentName.getPackageName());\n                    }\n                }\n                return widgetPackages;\n            }\n        }\n\n        @Override\n        public void unlockUser(int userId) {\n            handleUserUnlocked(userId);\n        }\n\n        @Override\n        public void applyResourceOverlaysToWidgets(Set<String> packageNames, int userId,\n                boolean updateFrameworkRes) {\n            synchronized (mLock) {\n                applyResourceOverlaysToWidgetsLocked(new HashSet<>(packageNames), userId,\n                        updateFrameworkRes);\n            }\n        }\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 38238,
                                        "general": {
                                            "word_based": 16459,
                                            "char_based": 50947
                                        },
                                        "gemini": 45851
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "ae39a3f6538e5a5a73aea4daf8b552539247227f",
                            "repo_path": "android_repos/base",
                            "result": "failure",
                            "downstream_patch_content": "commit ae39a3f6538e5a5a73aea4daf8b552539247227f\nAuthor: Pinyao Ting <pinyaoting@google.com>\nDate:   Tue Aug 20 21:17:13 2024 +0000\n\n    Enforce hard limits on hosts per package and widgets per host.\n    \n    Bug: 353240784\n    Merged-In: I60ee7faf57ed719f93cafad212fef24964dec99f\n    Change-Id: I60ee7faf57ed719f93cafad212fef24964dec99f\n    Test: manually verified with PoC app that at most 20 hosts can exists\n    Flag: EXEMPT CVE\n\ndiff --git a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nindex f5063ac4a023..356613ab3377 100644\n--- a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n+++ b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n@@ -170,6 +170,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // used to verify which request has successfully been received by the host.\n     private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n         @Override\n         public void onReceive(Context context, Intent intent) {\n@@ -1698,7 +1707,7 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (host != null) {\n             return host;\n         }\n-\n+        ensureHostCountBeforeAddLocked(id);\n         host = new Host();\n         host.id = id;\n         mHosts.add(host);\n@@ -1706,6 +1715,24 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         return host;\n     }\n \n+    /**\n+     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n+     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n+     * removes the oldest host.\n+     */\n+    private void ensureHostCountBeforeAddLocked(HostId hostId) {\n+        final List<Host> hosts = new ArrayList<>();\n+        for (Host host : mHosts) {\n+            if (host.id.uid == hostId.uid\n+                    && host.id.packageName.equals(hostId.packageName)) {\n+                hosts.add(host);\n+            }\n+        }\n+        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n+            deleteHostLocked(hosts.remove(0));\n+        }\n+    }\n+\n     private void deleteHostLocked(Host host) {\n         final int N = host.widgets.size();\n         for (int i = N - 1; i >= 0; i--) {\n@@ -2833,11 +2860,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n      * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n      */\n     void addWidgetLocked(Widget widget) {\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.\n",
                            "downstream_patch_tokens": {
                                "openai": 1088,
                                "general": {
                                    "word_based": 485,
                                    "char_based": 1099
                                },
                                "gemini": 1336
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java",
                                    "total_hunks": 4,
                                    "failed_hunks": [
                                        1,
                                        4
                                    ],
                                    "inline_merge_conflicts": [],
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    },
                                    "rej_file_content": "```diff\n--- services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n+++ services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n@@ -217,6 +217,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // See {@link Provider#pendingDeletedWidgetIds}.\n     private static final String PENDING_DELETED_IDS_ATTR = \"pending_deleted_ids\";\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     // Handles user and package related broadcasts.\n     // See {@link #registerBroadcastReceiver}\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n@@ -3591,11 +3618,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (DEBUG) {\n             Slog.i(TAG, \"addWidgetLocked() \" + widget);\n         }\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(@NonNull final Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.\n```",
                                    "rej_file_tokens": {
                                        "openai": 555,
                                        "general": {
                                            "word_based": 254,
                                            "char_based": 607
                                        },
                                        "gemini": 667
                                    },
                                    "patch_apply_output": "patching file services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nHunk #1 FAILED at 217.\nHunk #2 succeeded at 1698 (offset -577 lines).\nHunk #3 succeeded at 1706 with fuzz 2 (offset -577 lines).\nHunk #4 FAILED at 3591.\n2 out of 4 hunks FAILED -- saving rejects to file services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java.rej",
                                    "inline_merge_output": "patching file services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nHunk #1 merged at 229-237.\nHunk #2 already applied at 2296.\nHunk #3 merged at 2322-2339.\nHunk #4 already applied at 3630, merged at 3636-3655.",
                                    "upstream_file_tokens": {
                                        "openai": 50416,
                                        "general": {
                                            "word_based": 21550,
                                            "char_based": 66890
                                        },
                                        "gemini": 60115
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.appwidget;\n\nimport static android.content.Context.KEYGUARD_SERVICE;\nimport static android.content.Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;\nimport static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\nimport static android.content.res.Resources.ID_NULL;\n\nimport static com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME;\n\nimport android.annotation.UserIdInt;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.AlarmManager;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.AppOpsManagerInternal;\nimport android.app.IApplicationThread;\nimport android.app.IServiceConnection;\nimport android.app.KeyguardManager;\nimport android.app.PendingIntent;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.app.admin.DevicePolicyManagerInternal.OnCrossProfileWidgetProvidersChangeListener;\nimport android.app.usage.UsageEvents;\nimport android.app.usage.UsageStatsManagerInternal;\nimport android.appwidget.AppWidgetManager;\nimport android.appwidget.AppWidgetManagerInternal;\nimport android.appwidget.AppWidgetProviderInfo;\nimport android.appwidget.PendingHostUpdate;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.Intent.FilterComparison;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.ServiceConnection;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.LauncherApps;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.ServiceInfo;\nimport android.content.pm.ShortcutServiceInternal;\nimport android.content.pm.SuspendDialogInfo;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.content.res.TypedArray;\nimport android.content.res.XmlResourceParser;\nimport android.graphics.Point;\nimport android.graphics.drawable.Icon;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.service.appwidget.AppWidgetServiceDumpProto;\nimport android.service.appwidget.WidgetProto;\nimport android.text.TextUtils;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.AttributeSet;\nimport android.util.IntArray;\nimport android.util.LongSparseArray;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\nimport android.util.SparseIntArray;\nimport android.util.SparseLongArray;\nimport android.util.TypedValue;\nimport android.util.TypedXmlPullParser;\nimport android.util.TypedXmlSerializer;\nimport android.util.Xml;\nimport android.util.proto.ProtoOutputStream;\nimport android.view.Display;\nimport android.view.View;\nimport android.widget.RemoteViews;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.app.SuspendedAppActivity;\nimport com.android.internal.app.UnlaunchableAppActivity;\nimport com.android.internal.appwidget.IAppWidgetHost;\nimport com.android.internal.appwidget.IAppWidgetService;\nimport com.android.internal.os.BackgroundThread;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.widget.IRemoteViewsFactory;\nimport com.android.server.LocalServices;\nimport com.android.server.WidgetBackupProvider;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicLong;\n\nclass AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBackupProvider,\n        OnCrossProfileWidgetProvidersChangeListener {\n    private static final String TAG = \"AppWidgetServiceImpl\";\n\n    private static boolean DEBUG = false;\n\n    private static final String OLD_KEYGUARD_HOST_PACKAGE = \"android\";\n    private static final String NEW_KEYGUARD_HOST_PACKAGE = \"com.android.keyguard\";\n    private static final int KEYGUARD_HOST_ID = 0x4b455947;\n\n    private static final String STATE_FILENAME = \"appwidgets.xml\";\n\n    private static final int MIN_UPDATE_PERIOD = DEBUG ? 0 : 30 * 60 * 1000; // 30 minutes\n\n    private static final int TAG_UNDEFINED = -1;\n\n    private static final int UNKNOWN_UID = -1;\n\n    private static final int UNKNOWN_USER_ID = -10;\n\n    // Bump if the stored widgets need to be upgraded.\n    private static final int CURRENT_VERSION = 1;\n\n    // Every widget update request is associated which an increasing sequence number. This is\n    // used to verify which request has successfully been received by the host.\n    private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n\n    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            final String action = intent.getAction();\n            final int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Received broadcast: \" + action + \" on user \" + userId);\n            }\n\n            switch (action) {\n                case Intent.ACTION_MANAGED_PROFILE_AVAILABLE:\n                case Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE:\n                    synchronized (mLock) {\n                        reloadWidgetsMaskedState(userId);\n                    }\n                    break;\n                case Intent.ACTION_PACKAGES_SUSPENDED:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    updateWidgetPackageSuspensionMaskedState(intent, true, getSendingUserId());\n                    break;\n                case Intent.ACTION_PACKAGES_UNSUSPENDED:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    updateWidgetPackageSuspensionMaskedState(intent, false, getSendingUserId());\n                    break;\n                default:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    break;\n            }\n        }\n    };\n\n    // Manages persistent references to RemoteViewsServices from different App Widgets.\n    private final HashMap<Pair<Integer, FilterComparison>, HashSet<Integer>>\n            mRemoteViewsServicesAppWidgets = new HashMap<>();\n\n    private final Object mLock = new Object();\n\n    private final ArrayList<Widget> mWidgets = new ArrayList<>();\n    private final ArrayList<Host> mHosts = new ArrayList<>();\n    private final ArrayList<Provider> mProviders = new ArrayList<>();\n\n    private final ArraySet<Pair<Integer, String>> mPackagesWithBindWidgetPermission =\n            new ArraySet<>();\n\n    private final SparseBooleanArray mLoadedUserIds = new SparseBooleanArray();\n\n    private final Object mWidgetPackagesLock = new Object();\n    private final SparseArray<ArraySet<String>> mWidgetPackages = new SparseArray<>();\n\n    private BackupRestoreController mBackupRestoreController;\n\n    private final Context mContext;\n\n    private IPackageManager mPackageManager;\n    private AlarmManager mAlarmManager;\n    private UserManager mUserManager;\n    private AppOpsManager mAppOpsManager;\n    private KeyguardManager mKeyguardManager;\n    private DevicePolicyManagerInternal mDevicePolicyManagerInternal;\n    private PackageManagerInternal mPackageManagerInternal;\n    private ActivityManagerInternal mActivityManagerInternal;\n    private AppOpsManagerInternal mAppOpsManagerInternal;\n    private UsageStatsManagerInternal mUsageStatsManagerInternal;\n\n    private SecurityPolicy mSecurityPolicy;\n\n    private Handler mSaveStateHandler;\n    private Handler mCallbackHandler;\n\n    private final SparseIntArray mNextAppWidgetIds = new SparseIntArray();\n\n    private boolean mSafeMode;\n    private int mMaxWidgetBitmapMemory;\n\n    AppWidgetServiceImpl(Context context) {\n        mContext = context;\n    }\n\n    public void onStart() {\n        mPackageManager = AppGlobals.getPackageManager();\n        mAlarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);\n        mUserManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n        mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);\n        mKeyguardManager = (KeyguardManager) mContext.getSystemService(KEYGUARD_SERVICE);\n        mDevicePolicyManagerInternal = LocalServices.getService(DevicePolicyManagerInternal.class);\n        mPackageManagerInternal = LocalServices.getService(PackageManagerInternal.class);\n        mSaveStateHandler = BackgroundThread.getHandler();\n        mCallbackHandler = new CallbackHandler(mContext.getMainLooper());\n        mBackupRestoreController = new BackupRestoreController();\n        mSecurityPolicy = new SecurityPolicy();\n\n        computeMaximumWidgetBitmapMemory();\n        registerBroadcastReceiver();\n        registerOnCrossProfileProvidersChangedListener();\n\n        LocalServices.addService(AppWidgetManagerInternal.class, new AppWidgetManagerLocal());\n    }\n\n    void systemServicesReady() {\n        mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);\n        mAppOpsManagerInternal = LocalServices.getService(AppOpsManagerInternal.class);\n        mUsageStatsManagerInternal = LocalServices.getService(UsageStatsManagerInternal.class);\n    }\n\n    private void computeMaximumWidgetBitmapMemory() {\n        Display display = mContext.getDisplayNoVerify();\n        Point size = new Point();\n        display.getRealSize(size);\n        // Cap memory usage at 1.5 times the size of the display\n        // 1.5 * 4 bytes/pixel * w * h ==> 6 * w * h\n        mMaxWidgetBitmapMemory = 6 * size.x * size.y;\n    }\n\n    private void registerBroadcastReceiver() {\n        // Register for broadcasts about package install, etc., so we can\n        // update the provider list.\n        IntentFilter packageFilter = new IntentFilter();\n        packageFilter.addAction(Intent.ACTION_PACKAGE_ADDED);\n        packageFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);\n        packageFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);\n        packageFilter.addDataScheme(\"package\");\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                packageFilter, null, null);\n\n        // Register for events related to sdcard installation.\n        IntentFilter sdFilter = new IntentFilter();\n        sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);\n        sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                sdFilter, null, null);\n\n        IntentFilter offModeFilter = new IntentFilter();\n        offModeFilter.addAction(Intent.ACTION_MANAGED_PROFILE_AVAILABLE);\n        offModeFilter.addAction(Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                offModeFilter, null, null);\n\n        IntentFilter suspendPackageFilter = new IntentFilter();\n        suspendPackageFilter.addAction(Intent.ACTION_PACKAGES_SUSPENDED);\n        suspendPackageFilter.addAction(Intent.ACTION_PACKAGES_UNSUSPENDED);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                suspendPackageFilter, null, null);\n    }\n\n    private void registerOnCrossProfileProvidersChangedListener() {\n        // The device policy is an optional component.\n        if (mDevicePolicyManagerInternal != null) {\n            mDevicePolicyManagerInternal.addOnCrossProfileWidgetProvidersChangeListener(this);\n        }\n    }\n\n    public void setSafeMode(boolean safeMode) {\n        mSafeMode = safeMode;\n    }\n\n    private void onPackageBroadcastReceived(Intent intent, int userId) {\n        final String action = intent.getAction();\n        boolean added = false;\n        boolean changed = false;\n        boolean componentsModified = false;\n\n        final String pkgList[];\n        switch (action) {\n            case Intent.ACTION_PACKAGES_SUSPENDED:\n            case Intent.ACTION_PACKAGES_UNSUSPENDED:\n                pkgList = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                changed = true;\n                break;\n            case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:\n                added = true;\n                // Follow through\n            case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:\n                pkgList = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                break;\n            default: {\n                Uri uri = intent.getData();\n                if (uri == null) {\n                    return;\n                }\n                String pkgName = uri.getSchemeSpecificPart();\n                if (pkgName == null) {\n                    return;\n                }\n                pkgList = new String[] { pkgName };\n                added = Intent.ACTION_PACKAGE_ADDED.equals(action);\n                changed = Intent.ACTION_PACKAGE_CHANGED.equals(action);\n            }\n        }\n        if (pkgList == null || pkgList.length == 0) {\n            return;\n        }\n\n        synchronized (mLock) {\n            if (!mUserManager.isUserUnlockingOrUnlocked(userId) ||\n                    isProfileWithLockedParent(userId)) {\n                return;\n            }\n            ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ false);\n\n            Bundle extras = intent.getExtras();\n\n            if (added || changed) {\n                final boolean newPackageAdded = added && (extras == null\n                        || !extras.getBoolean(Intent.EXTRA_REPLACING, false));\n\n                for (String pkgName : pkgList) {\n                    // Fix up the providers - add/remove/update.\n                    componentsModified |= updateProvidersForPackageLocked(pkgName, userId, null);\n\n                    // ... and see if these are hosts we've been awaiting.\n                    // NOTE: We are backing up and restoring only the owner.\n                    // TODO: http://b/22388012\n                    if (newPackageAdded && userId == UserHandle.USER_SYSTEM) {\n                        final int uid = getUidForPackage(pkgName, userId);\n                        if (uid >= 0 ) {\n                            resolveHostUidLocked(pkgName, uid);\n                        }\n                    }\n                }\n            } else {\n                // If the package is being updated, we'll receive a PACKAGE_ADDED\n                // shortly, otherwise it is removed permanently.\n                final boolean packageRemovedPermanently = (extras == null\n                        || !extras.getBoolean(Intent.EXTRA_REPLACING, false));\n\n                if (packageRemovedPermanently) {\n                    for (String pkgName : pkgList) {\n                        componentsModified |= removeHostsAndProvidersForPackageLocked(\n                                pkgName, userId);\n                    }\n                }\n            }\n\n            if (componentsModified) {\n                saveGroupStateAsync(userId);\n\n                // If the set of providers has been modified, notify each active AppWidgetHost\n                scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n                // Possibly notify any new components of widget id changes\n                mBackupRestoreController.widgetComponentsChanged(userId);\n            }\n        }\n    }\n\n    /**\n     * Reload all widgets' masked state for the given user and its associated profiles, including\n     * due to user not being available and package suspension.\n     * userId must be the group parent.\n     */\n    void reloadWidgetsMaskedStateForGroup(int userId) {\n        if (!mUserManager.isUserUnlockingOrUnlocked(userId)) {\n            return;\n        }\n        synchronized (mLock) {\n            reloadWidgetsMaskedState(userId);\n            int[] profileIds = mUserManager.getEnabledProfileIds(userId);\n            for (int profileId : profileIds) {\n                reloadWidgetsMaskedState(profileId);\n            }\n        }\n    }\n\n    private void reloadWidgetsMaskedState(int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            UserInfo user  = mUserManager.getUserInfo(userId);\n\n            boolean lockedProfile = !mUserManager.isUserUnlockingOrUnlocked(userId);\n            boolean quietProfile = user.isQuietModeEnabled();\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                int providerUserId = provider.getUserId();\n                if (providerUserId != userId) {\n                    continue;\n                }\n\n                boolean changed = provider.setMaskedByLockedProfileLocked(lockedProfile);\n                changed |= provider.setMaskedByQuietProfileLocked(quietProfile);\n                try {\n                    boolean suspended;\n                    try {\n                        suspended = mPackageManager.isPackageSuspendedForUser(\n                                provider.id.componentName.getPackageName(), provider.getUserId());\n                    } catch (IllegalArgumentException ex) {\n                        // Package not found.\n                        suspended = false;\n                    }\n                    changed |= provider.setMaskedBySuspendedPackageLocked(suspended);\n                } catch (RemoteException e) {\n                    Slog.e(TAG, \"Failed to query application info\", e);\n                }\n                if (changed) {\n                    if (provider.isMaskedLocked()) {\n                        maskWidgetsViewsLocked(provider, null);\n                    } else {\n                        unmaskWidgetsViewsLocked(provider);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    /**\n     * Incrementally update the masked state due to package suspension state.\n     */\n    private void updateWidgetPackageSuspensionMaskedState(Intent intent, boolean suspended,\n            int profileId) {\n        String[] packagesArray = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n        if (packagesArray == null) {\n            return;\n        }\n        Set<String> packages = new ArraySet<>(Arrays.asList(packagesArray));\n        synchronized (mLock) {\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                int providerUserId = provider.getUserId();\n                if (providerUserId != profileId\n                        || !packages.contains(provider.id.componentName.getPackageName())) {\n                    continue;\n                }\n                if (provider.setMaskedBySuspendedPackageLocked(suspended)) {\n                    if (provider.isMaskedLocked()) {\n                        maskWidgetsViewsLocked(provider, null);\n                    } else {\n                        unmaskWidgetsViewsLocked(provider);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Mask the target widget belonging to the specified provider, or all active widgets\n     * of the provider if target widget == null.\n     */\n    private void maskWidgetsViewsLocked(Provider provider, Widget targetWidget) {\n        final int widgetCount = provider.widgets.size();\n        if (widgetCount == 0) {\n            return;\n        }\n        RemoteViews views = new RemoteViews(mContext.getPackageName(),\n                R.layout.work_widget_mask_view);\n        ApplicationInfo appInfo = provider.info.providerInfo.applicationInfo;\n        final int appUserId = provider.getUserId();\n        boolean showBadge;\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final Intent onClickIntent;\n\n            if (provider.maskedBySuspendedPackage) {\n                showBadge = mUserManager.hasBadge(appUserId);\n                final String suspendingPackage = mPackageManagerInternal.getSuspendingPackage(\n                        appInfo.packageName, appUserId);\n                if (PLATFORM_PACKAGE_NAME.equals(suspendingPackage)) {\n                    onClickIntent = mDevicePolicyManagerInternal.createShowAdminSupportIntent(\n                            appUserId, true);\n                } else {\n                    final SuspendDialogInfo dialogInfo =\n                            mPackageManagerInternal.getSuspendedDialogInfo(\n                                    appInfo.packageName, suspendingPackage, appUserId);\n                    // onUnsuspend is null because we don't want to start any activity on\n                    // unsuspending from a suspended widget.\n                    onClickIntent = SuspendedAppActivity.createSuspendedAppInterceptIntent(\n                            appInfo.packageName, suspendingPackage, dialogInfo, null, null,\n                            appUserId);\n                }\n            } else if (provider.maskedByQuietProfile) {\n                showBadge = true;\n                onClickIntent = UnlaunchableAppActivity.createInQuietModeDialogIntent(appUserId);\n            } else /* provider.maskedByLockedProfile */ {\n                showBadge = true;\n                onClickIntent = mKeyguardManager\n                        .createConfirmDeviceCredentialIntent(null, null, appUserId);\n                if (onClickIntent != null) {\n                    onClickIntent.setFlags(\n                            FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);\n                }\n            }\n\n            if (onClickIntent != null) {\n                views.setOnClickPendingIntent(android.R.id.background,\n                        PendingIntent.getActivity(mContext, 0, onClickIntent,\n                                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE));\n            }\n\n            Icon icon = appInfo.icon != 0\n                    ? Icon.createWithResource(appInfo.packageName, appInfo.icon)\n                    : Icon.createWithResource(mContext, android.R.drawable.sym_def_app_icon);\n            views.setImageViewIcon(R.id.work_widget_app_icon, icon);\n            if (!showBadge) {\n                views.setViewVisibility(R.id.work_widget_badge_icon, View.INVISIBLE);\n            }\n\n            for (int j = 0; j < widgetCount; j++) {\n                Widget widget = provider.widgets.get(j);\n                if (targetWidget != null && targetWidget != widget) continue;\n                if (widget.replaceWithMaskedViewsLocked(views)) {\n                    scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void unmaskWidgetsViewsLocked(Provider provider) {\n        final int widgetCount = provider.widgets.size();\n        for (int j = 0; j < widgetCount; j++) {\n            Widget widget = provider.widgets.get(j);\n            if (widget.clearMaskedViewsLocked()) {\n                scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n            }\n        }\n    }\n\n    private void resolveHostUidLocked(String pkg, int uid) {\n        final int N = mHosts.size();\n        for (int i = 0; i < N; i++) {\n            Host host = mHosts.get(i);\n            if (host.id.uid == UNKNOWN_UID && pkg.equals(host.id.packageName)) {\n                if (DEBUG) {\n                    Slog.i(TAG, \"host \" + host.id + \" resolved to uid \" + uid);\n                }\n                host.id = new HostId(uid, host.id.hostId, host.id.packageName);\n                return;\n            }\n        }\n    }\n\n    private void ensureGroupStateLoadedLocked(int userId) {\n        ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ true );\n    }\n\n    private void ensureGroupStateLoadedLocked(int userId, boolean enforceUserUnlockingOrUnlocked) {\n        if (enforceUserUnlockingOrUnlocked && !isUserRunningAndUnlocked(userId)) {\n            throw new IllegalStateException(\n                    \"User \" + userId + \" must be unlocked for widgets to be available\");\n        }\n        if (enforceUserUnlockingOrUnlocked && isProfileWithLockedParent(userId)) {\n            throw new IllegalStateException(\n                    \"Profile \" + userId + \" must have unlocked parent\");\n        }\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        IntArray newIds = new IntArray(1);\n        for (int profileId : profileIds) {\n            if (!mLoadedUserIds.get(profileId)) {\n                mLoadedUserIds.put(profileId, true);\n                newIds.add(profileId);\n            }\n        }\n        if (newIds.size() <= 0) {\n            return;\n        }\n        final int[] newProfileIds = newIds.toArray();\n        clearProvidersAndHostsTagsLocked();\n\n        loadGroupWidgetProvidersLocked(newProfileIds);\n        loadGroupStateLocked(newProfileIds);\n    }\n\n    private boolean isUserRunningAndUnlocked(@UserIdInt int userId) {\n        return mUserManager.isUserUnlockingOrUnlocked(userId);\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {\n        if (!DumpUtils.checkDumpPermission(mContext, TAG, pw)) return;\n\n        synchronized (mLock) {\n            if (args.length > 0 && \"--proto\".equals(args[0])) {\n                dumpProto(fd);\n            } else {\n                dumpInternalLocked(pw);\n            }\n        }\n    }\n\n    private void dumpProto(FileDescriptor fd) {\n        Slog.i(TAG, \"dump proto for \" + mWidgets.size() + \" widgets\");\n\n        ProtoOutputStream proto = new ProtoOutputStream(fd);\n        int N = mWidgets.size();\n        for (int i=0; i < N; i++) {\n            dumpProtoWidget(proto, mWidgets.get(i));\n        }\n        proto.flush();\n    }\n\n    private void dumpProtoWidget(ProtoOutputStream proto, Widget widget) {\n        if (widget.host == null || widget.provider == null) {\n            Slog.d(TAG, \"skip dumping widget because host or provider is null: widget.host=\"\n                + widget.host + \" widget.provider=\"  + widget.provider);\n            return;\n        }\n        long token = proto.start(AppWidgetServiceDumpProto.WIDGETS);\n        proto.write(WidgetProto.IS_CROSS_PROFILE,\n            widget.host.getUserId() != widget.provider.getUserId());\n        proto.write(WidgetProto.IS_HOST_STOPPED, widget.host.callbacks == null);\n        proto.write(WidgetProto.HOST_PACKAGE, widget.host.id.packageName);\n        proto.write(WidgetProto.PROVIDER_PACKAGE, widget.provider.id.componentName.getPackageName());\n        proto.write(WidgetProto.PROVIDER_CLASS, widget.provider.id.componentName.getClassName());\n        if (widget.options != null) {\n            proto.write(WidgetProto.RESTORE_COMPLETED,\n                    widget.options.getBoolean(AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED));\n            proto.write(WidgetProto.MIN_WIDTH,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH, 0));\n            proto.write(WidgetProto.MIN_HEIGHT,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, 0));\n            proto.write(WidgetProto.MAX_WIDTH,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH, 0));\n            proto.write(WidgetProto.MAX_HEIGHT,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, 0));\n        }\n        proto.end(token);\n    }\n\n    private void dumpInternalLocked(PrintWriter pw) {\n        int N = mProviders.size();\n        pw.println(\"Providers:\");\n        for (int i = 0; i < N; i++) {\n            dumpProviderLocked(mProviders.get(i), i, pw);\n        }\n\n        N = mWidgets.size();\n        pw.println(\" \");\n        pw.println(\"Widgets:\");\n        for (int i = 0; i < N; i++) {\n            dumpWidget(mWidgets.get(i), i, pw);\n        }\n\n        N = mHosts.size();\n        pw.println(\" \");\n        pw.println(\"Hosts:\");\n        for (int i = 0; i < N; i++) {\n            dumpHost(mHosts.get(i), i, pw);\n        }\n\n        N = mPackagesWithBindWidgetPermission.size();\n        pw.println(\" \");\n        pw.println(\"Grants:\");\n        for (int i = 0; i < N; i++) {\n            Pair<Integer, String> grant = mPackagesWithBindWidgetPermission.valueAt(i);\n            dumpGrant(grant, i, pw);\n        }\n    }\n\n    @Override\n    public ParceledListSlice<PendingHostUpdate> startListening(IAppWidgetHost callbacks,\n            String callingPackage, int hostId, int[] appWidgetIds) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"startListening() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            // Instant apps cannot host app widgets.\n            if (mSecurityPolicy.isInstantAppLocked(callingPackage, userId)) {\n                Slog.w(TAG, \"Instant package \" + callingPackage + \" cannot host app widgets\");\n                return ParceledListSlice.emptyList();\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupOrAddHostLocked(id);\n            host.callbacks = callbacks;\n\n            long updateSequenceNo = UPDATE_COUNTER.incrementAndGet();\n            int N = appWidgetIds.length;\n            ArrayList<PendingHostUpdate> outUpdates = new ArrayList<>(N);\n            LongSparseArray<PendingHostUpdate> updatesMap = new LongSparseArray<>();\n            for (int i = 0; i < N; i++) {\n                updatesMap.clear();\n                host.getPendingUpdatesForIdLocked(mContext, appWidgetIds[i], updatesMap);\n                // We key the updates based on request id, so that the values are sorted in the\n                // order they were received.\n                int m = updatesMap.size();\n                for (int j = 0; j < m; j++) {\n                    outUpdates.add(updatesMap.valueAt(j));\n                }\n            }\n            // Reset the update counter once all the updates have been calculated\n            host.lastWidgetUpdateSequenceNo = updateSequenceNo;\n            return new ParceledListSlice<>(outUpdates);\n        }\n    }\n\n    @Override\n    public void stopListening(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"stopListening() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ false);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host != null) {\n                host.callbacks = null;\n                pruneHostLocked(host);\n                mAppOpsManagerInternal.updateAppWidgetVisibility(host.getWidgetUids(), false);\n            }\n        }\n    }\n\n    @Override\n    public int allocateAppWidgetId(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"allocateAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            // Instant apps cannot host app widgets.\n            if (mSecurityPolicy.isInstantAppLocked(callingPackage, userId)) {\n                Slog.w(TAG, \"Instant package \" + callingPackage + \" cannot host app widgets\");\n                return AppWidgetManager.INVALID_APPWIDGET_ID;\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            if (mNextAppWidgetIds.indexOfKey(userId) < 0) {\n                mNextAppWidgetIds.put(userId, AppWidgetManager.INVALID_APPWIDGET_ID + 1);\n            }\n\n            final int appWidgetId = incrementAndGetAppWidgetIdLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupOrAddHostLocked(id);\n\n            Widget widget = new Widget();\n            widget.appWidgetId = appWidgetId;\n            widget.host = host;\n\n            host.widgets.add(widget);\n            addWidgetLocked(widget);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Allocated widget id \" + appWidgetId\n                        + \" for host \" + host.id);\n            }\n\n            return appWidgetId;\n        }\n    }\n\n    @Override\n    public void deleteAppWidgetId(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                return;\n            }\n\n            deleteAppWidgetLocked(widget);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Deleted widget id \" + appWidgetId\n                        + \" for host \" + widget.host.id);\n            }\n        }\n    }\n\n    @Override\n    public boolean hasBindAppWidgetPermission(String packageName, int grantId) {\n        if (DEBUG) {\n            Slog.i(TAG, \"hasBindAppWidgetPermission() \" + UserHandle.getCallingUserId());\n        }\n\n        // A special permission is required for managing allowlisting.\n        mSecurityPolicy.enforceModifyAppWidgetBindPermissions(packageName);\n\n        synchronized (mLock) {\n            // The grants are stored in user state wich gets the grant.\n            ensureGroupStateLoadedLocked(grantId);\n\n            final int packageUid = getUidForPackage(packageName, grantId);\n            if (packageUid < 0) {\n                return false;\n            }\n\n            Pair<Integer, String> packageId = Pair.create(grantId, packageName);\n            return mPackagesWithBindWidgetPermission.contains(packageId);\n        }\n    }\n\n    @Override\n    public void setBindAppWidgetPermission(String packageName, int grantId,\n            boolean grantPermission) {\n        if (DEBUG) {\n            Slog.i(TAG, \"setBindAppWidgetPermission() \" + UserHandle.getCallingUserId());\n        }\n\n        // A special permission is required for managing allowlisting.\n        mSecurityPolicy.enforceModifyAppWidgetBindPermissions(packageName);\n\n        synchronized (mLock) {\n            // The grants are stored in user state wich gets the grant.\n            ensureGroupStateLoadedLocked(grantId);\n\n            final int packageUid = getUidForPackage(packageName, grantId);\n            if (packageUid < 0) {\n                return;\n            }\n\n            Pair<Integer, String> packageId = Pair.create(grantId, packageName);\n            if (grantPermission) {\n                mPackagesWithBindWidgetPermission.add(packageId);\n            } else {\n                mPackagesWithBindWidgetPermission.remove(packageId);\n            }\n\n            saveGroupStateAsync(grantId);\n        }\n    }\n\n    @Override\n    public IntentSender createAppWidgetConfigIntentSender(String callingPackage, int appWidgetId,\n            final int intentFlags) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"createAppWidgetConfigIntentSender() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                throw new IllegalArgumentException(\"Bad widget id \" + appWidgetId);\n            }\n\n            Provider provider = widget.provider;\n            if (provider == null) {\n                throw new IllegalArgumentException(\"Widget not bound \" + appWidgetId);\n            }\n\n            // Make sure only safe flags can be passed it.\n            final int secureFlags = intentFlags & ~Intent.IMMUTABLE_FLAGS;\n\n            Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_CONFIGURE);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);\n            intent.setComponent(provider.getInfoLocked(mContext).configure);\n            intent.setFlags(secureFlags);\n\n            // All right, create the sender.\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return PendingIntent.getActivityAsUser(\n                        mContext, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                                | PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_CANCEL_CURRENT,\n                                null, new UserHandle(provider.getUserId()))\n                        .getIntentSender();\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n    }\n\n    @Override\n    public boolean bindAppWidgetId(String callingPackage, int appWidgetId,\n            int providerProfileId, ComponentName providerComponent, Bundle options) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"bindAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        // Check that if a cross-profile binding is attempted, it is allowed.\n        if (!mSecurityPolicy.isEnabledGroupProfile(providerProfileId)) {\n            return false;\n        }\n\n        // If the provider is not under the calling user, make sure this\n        // provider is allowlisted for access from the parent.\n        if (!mSecurityPolicy.isProviderInCallerOrInProfileAndWhitelListed(\n                providerComponent.getPackageName(), providerProfileId)) {\n            return false;\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // A special permission or allowlisting is required to bind widgets.\n            if (!mSecurityPolicy.hasCallerBindPermissionOrBindWhiteListedLocked(\n                    callingPackage)) {\n                return false;\n            }\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                Slog.e(TAG, \"Bad widget id \" + appWidgetId);\n                return false;\n            }\n\n            if (widget.provider != null) {\n                Slog.e(TAG, \"Widget id \" + appWidgetId\n                        + \" already bound to: \" + widget.provider.id);\n                return false;\n            }\n\n            final int providerUid = getUidForPackage(providerComponent.getPackageName(),\n                    providerProfileId);\n            if (providerUid < 0) {\n                Slog.e(TAG, \"Package \" + providerComponent.getPackageName() + \" not installed \"\n                        + \" for profile \" + providerProfileId);\n                return false;\n            }\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the provider is in the already vetted user profile.\n            ProviderId providerId = new ProviderId(providerUid, providerComponent);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider == null) {\n                Slog.e(TAG, \"No widget provider \" + providerComponent + \" for profile \"\n                        + providerProfileId);\n                return false;\n            }\n\n            if (provider.zombie) {\n                Slog.e(TAG, \"Can't bind to a 3rd party provider in\"\n                        + \" safe mode \" + provider);\n                return false;\n            }\n\n            widget.provider = provider;\n            widget.options = (options != null) ? cloneIfLocalBinder(options) : new Bundle();\n\n            // We need to provide a default value for the widget category if it is not specified\n            if (!widget.options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {\n                widget.options.putInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY,\n                        AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN);\n            }\n\n            provider.widgets.add(widget);\n\n            onWidgetProviderAddedOrChangedLocked(widget);\n\n            final int widgetCount = provider.widgets.size();\n            if (widgetCount == 1) {\n                // Tell the provider that it's ready.\n                sendEnableIntentLocked(provider);\n            }\n\n            // Send an update now -- We need this update now, and just for this appWidgetId.\n            // It's less critical when the next one happens, so when we schedule the next one,\n            // we add updatePeriodMillis to its start time. That time will have some slop,\n            // but that's okay.\n            sendUpdateIntentLocked(provider, new int[] {appWidgetId});\n\n            // Schedule the future updates.\n            registerForBroadcastsLocked(provider, getWidgetIds(provider.widgets));\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Bound widget \" + appWidgetId + \" to provider \" + provider.id);\n            }\n        }\n\n        return true;\n    }\n\n    @Override\n    public int[] getAppWidgetIds(ComponentName componentName) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetIds() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider != null) {\n                return getWidgetIds(provider.widgets);\n            }\n\n            return new int[0];\n        }\n    }\n\n    @Override\n    public int[] getAppWidgetIdsForHost(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetIdsForHost() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access its hosts.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host != null) {\n                return getWidgetIds(host.widgets);\n            }\n\n            return new int[0];\n        }\n    }\n\n    @Override\n    public boolean bindRemoteViewsService(String callingPackage, int appWidgetId, Intent intent,\n            IApplicationThread caller, IBinder activtiyToken, IServiceConnection connection,\n            int flags) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"bindRemoteViewsService() \" + userId);\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                throw new IllegalArgumentException(\"Bad widget id\");\n            }\n\n            // Make sure the widget has a provider.\n            if (widget.provider == null) {\n                throw new IllegalArgumentException(\"No provider for widget \"\n                        + appWidgetId);\n            }\n\n            ComponentName componentName = intent.getComponent();\n\n            // Ensure that the service belongs to the same package as the provider.\n            // But this is not enough as they may be under different users - see below...\n            String providerPackage = widget.provider.id.componentName.getPackageName();\n            String servicePackage = componentName.getPackageName();\n            if (!servicePackage.equals(providerPackage)) {\n                throw new SecurityException(\"The taget service not in the same package\"\n                        + \" as the widget provider\");\n            }\n\n            // Make sure this service exists under the same user as the provider and\n            // requires a permission which allows only the system to bind to it.\n            mSecurityPolicy.enforceServiceExistsAndRequiresBindRemoteViewsPermission(\n                    componentName, widget.provider.getUserId());\n\n            // Good to go - the service package is correct, it exists for the correct\n            // user, and requires the bind permission.\n\n            final long callingIdentity = Binder.clearCallingIdentity();\n            try {\n                // Ask ActivityManager to bind it. Notice that we are binding the service with the\n                // caller app instead of DevicePolicyManagerService.\n                if (ActivityManager.getService().bindService(\n                        caller, activtiyToken, intent,\n                        intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                        connection, flags & (Context.BIND_AUTO_CREATE\n                                | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE),\n                        mContext.getOpPackageName(), widget.provider.getUserId()) != 0) {\n\n                    // Add it to the mapping of RemoteViewsService to appWidgetIds so that we\n                    // can determine when we can call back to the RemoteViewsService later to\n                    // destroy associated factories.\n                    incrementAppWidgetServiceRefCount(appWidgetId,\n                            Pair.create(widget.provider.id.uid, new FilterComparison(intent)));\n                    return true;\n                }\n            } catch (RemoteException ex) {\n                // Same process, should not happen.\n            } finally {\n                Binder.restoreCallingIdentity(callingIdentity);\n            }\n        }\n\n        // Failed to bind.\n        return false;\n    }\n\n    @Override\n    public void deleteHost(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteHost() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts in its uid and package.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host == null) {\n                return;\n            }\n\n            deleteHostLocked(host);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Deleted host \" + host.id);\n            }\n        }\n    }\n\n    @Override\n    public void deleteAllHosts() {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteAllHosts() \" + userId);\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            boolean changed = false;\n\n            final int N = mHosts.size();\n            for (int i = N - 1; i >= 0; i--) {\n                Host host = mHosts.get(i);\n\n                // Delete only hosts in the calling uid.\n                if (host.id.uid == Binder.getCallingUid()) {\n                    deleteHostLocked(host);\n                    changed = true;\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Deleted host \" + host.id);\n                    }\n                }\n            }\n\n            if (changed) {\n                saveGroupStateAsync(userId);\n            }\n        }\n    }\n\n    @Override\n    public AppWidgetProviderInfo getAppWidgetInfo(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetInfo() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null && widget.provider != null && !widget.provider.zombie) {\n                return cloneIfLocalBinder(widget.provider.getInfoLocked(mContext));\n            }\n\n            return null;\n        }\n    }\n\n    @Override\n    public RemoteViews getAppWidgetViews(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetViews() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null) {\n                return cloneIfLocalBinder(widget.getEffectiveViewsLocked());\n            }\n\n            return null;\n        }\n    }\n\n    @Override\n    public void updateAppWidgetOptions(String callingPackage, int appWidgetId, Bundle options) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetOptions() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                return;\n            }\n\n            // Merge the options.\n            widget.options.putAll(options);\n\n            // Send the broacast to notify the provider that options changed.\n            sendOptionsChangedIntentLocked(widget);\n\n            saveGroupStateAsync(userId);\n        }\n    }\n\n    @Override\n    public Bundle getAppWidgetOptions(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetOptions() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null && widget.options != null) {\n                return cloneIfLocalBinder(widget.options);\n            }\n\n            return Bundle.EMPTY;\n        }\n    }\n\n    @Override\n    public void updateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views) {\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetIds() \" + UserHandle.getCallingUserId());\n        }\n\n        updateAppWidgetIds(callingPackage, appWidgetIds, views, false);\n    }\n\n    @Override\n    public void partiallyUpdateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views) {\n        if (DEBUG) {\n            Slog.i(TAG, \"partiallyUpdateAppWidgetIds() \" + UserHandle.getCallingUserId());\n        }\n\n        updateAppWidgetIds(callingPackage, appWidgetIds, views, true);\n    }\n\n    @Override\n    public void notifyAppWidgetViewDataChanged(String callingPackage, int[] appWidgetIds,\n            int viewId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"notifyAppWidgetViewDataChanged() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        if (appWidgetIds == null || appWidgetIds.length == 0) {\n            return;\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            final int N = appWidgetIds.length;\n            for (int i = 0; i < N; i++) {\n                final int appWidgetId = appWidgetIds[i];\n\n                // NOTE: The lookup is enforcing security across users by making\n                // sure the caller can only access widgets it hosts or provides.\n                Widget widget = lookupWidgetLocked(appWidgetId,\n                        Binder.getCallingUid(), callingPackage);\n\n                if (widget != null) {\n                    scheduleNotifyAppWidgetViewDataChanged(widget, viewId);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void updateAppWidgetProvider(ComponentName componentName, RemoteViews views) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetProvider() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider == null) {\n                Slog.w(TAG, \"Provider doesn't exist \" + providerId);\n                return;\n            }\n\n            ArrayList<Widget> instances = provider.widgets;\n            final int N = instances.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = instances.get(i);\n                updateAppWidgetInstanceLocked(widget, views, false);\n            }\n        }\n    }\n\n    @Override\n    public void updateAppWidgetProviderInfo(ComponentName componentName, String metadataKey) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetProvider() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n            if (provider == null) {\n                throw new IllegalArgumentException(\n                        componentName + \" is not a valid AppWidget provider\");\n            }\n            if (Objects.equals(provider.infoTag, metadataKey)) {\n                // No change\n                return;\n            }\n\n            String keyToUse = metadataKey == null\n                    ? AppWidgetManager.META_DATA_APPWIDGET_PROVIDER : metadataKey;\n            AppWidgetProviderInfo info = parseAppWidgetProviderInfo(mContext, providerId,\n                    provider.getPartialInfoLocked().providerInfo, keyToUse);\n            if (info == null) {\n                throw new IllegalArgumentException(\"Unable to parse \" + keyToUse\n                        + \" meta-data to a valid AppWidget provider\");\n            }\n\n            provider.setInfoLocked(info);\n            provider.infoTag = metadataKey;\n\n            // Update all widgets for this provider\n            final int N = provider.widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = provider.widgets.get(i);\n                scheduleNotifyProviderChangedLocked(widget);\n                updateAppWidgetInstanceLocked(widget, widget.views, false /* isPartialUpdate */);\n            }\n\n            saveGroupStateAsync(userId);\n            scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n        }\n    }\n\n    @Override\n    public boolean isRequestPinAppWidgetSupported() {\n        synchronized (mLock) {\n            if (mSecurityPolicy.isCallerInstantAppLocked()) {\n                Slog.w(TAG, \"Instant uid \" + Binder.getCallingUid()\n                        + \" query information about app widgets\");\n                return false;\n            }\n        }\n        return LocalServices.getService(ShortcutServiceInternal.class)\n                .isRequestPinItemSupported(UserHandle.getCallingUserId(),\n                        LauncherApps.PinItemRequest.REQUEST_TYPE_APPWIDGET);\n    }\n\n    @Override\n    public boolean requestPinAppWidget(String callingPackage, ComponentName componentName,\n            Bundle extras, IntentSender resultSender) {\n        final int callingUid = Binder.getCallingUid();\n        final int userId = UserHandle.getUserId(callingUid);\n\n        if (DEBUG) {\n            Slog.i(TAG, \"requestPinAppWidget() \" + userId);\n        }\n\n        final AppWidgetProviderInfo info;\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // Look for the widget associated with the caller.\n            Provider provider = lookupProviderLocked(new ProviderId(callingUid, componentName));\n            if (provider == null || provider.zombie) {\n                return false;\n            }\n            info = provider.getInfoLocked(mContext);\n            if ((info.widgetCategory & AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN) == 0) {\n                return false;\n            }\n        }\n\n        return LocalServices.getService(ShortcutServiceInternal.class)\n                .requestPinAppWidget(callingPackage, info, extras, resultSender, userId);\n    }\n\n    @Override\n    public ParceledListSlice<AppWidgetProviderInfo> getInstalledProvidersForProfile(int categoryFilter,\n            int profileId, String packageName) {\n        final int userId = UserHandle.getCallingUserId();\n        final int callingUid = Binder.getCallingUid();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getInstalledProvidersForProfiles() \" + userId);\n        }\n\n        // Ensure the profile is in the group and enabled.\n        if (!mSecurityPolicy.isEnabledGroupProfile(profileId)) {\n            return null;\n        }\n\n        synchronized (mLock) {\n            if (mSecurityPolicy.isCallerInstantAppLocked()) {\n                Slog.w(TAG, \"Instant uid \" + callingUid\n                        + \" cannot access widget providers\");\n                return ParceledListSlice.emptyList();\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            ArrayList<AppWidgetProviderInfo> result = new ArrayList<AppWidgetProviderInfo>();\n\n            final int providerCount = mProviders.size();\n            for (int i = 0; i < providerCount; i++) {\n                Provider provider = mProviders.get(i);\n                AppWidgetProviderInfo info = provider.getInfoLocked(mContext);\n                final String providerPackageName = provider.id.componentName.getPackageName();\n\n                // Ignore an invalid provider, one not matching the filter,\n                // or one that isn't in the given package, if any.\n                boolean inPackage = packageName == null\n                        || providerPackageName.equals(packageName);\n                if (provider.zombie || (info.widgetCategory & categoryFilter) == 0 || !inPackage) {\n                    continue;\n                }\n\n                // Add providers only for the requested profile that are allowlisted.\n                final int providerProfileId = info.getProfile().getIdentifier();\n                if (providerProfileId == profileId\n                        && mSecurityPolicy.isProviderInCallerOrInProfileAndWhitelListed(\n                        providerPackageName, providerProfileId)\n                        && !mPackageManagerInternal.filterAppAccess(providerPackageName, callingUid,\n                        userId)) {\n                    result.add(cloneIfLocalBinder(info));\n                }\n            }\n\n            return new ParceledListSlice<AppWidgetProviderInfo>(result);\n        }\n    }\n\n    private void updateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views, boolean partially) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (appWidgetIds == null || appWidgetIds.length == 0) {\n            return;\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            final int N = appWidgetIds.length;\n            for (int i = 0; i < N; i++) {\n                final int appWidgetId = appWidgetIds[i];\n\n                // NOTE: The lookup is enforcing security across users by making\n                // sure the caller can only access widgets it hosts or provides.\n                Widget widget = lookupWidgetLocked(appWidgetId,\n                        Binder.getCallingUid(), callingPackage);\n\n                if (widget != null) {\n                    updateAppWidgetInstanceLocked(widget, views, partially);\n                }\n            }\n        }\n    }\n\n    private int incrementAndGetAppWidgetIdLocked(int userId) {\n        final int appWidgetId = peekNextAppWidgetIdLocked(userId) + 1;\n        mNextAppWidgetIds.put(userId, appWidgetId);\n        return appWidgetId;\n    }\n\n    private void setMinAppWidgetIdLocked(int userId, int minWidgetId) {\n        final int nextAppWidgetId = peekNextAppWidgetIdLocked(userId);\n        if (nextAppWidgetId < minWidgetId) {\n            mNextAppWidgetIds.put(userId, minWidgetId);\n        }\n    }\n\n    private int peekNextAppWidgetIdLocked(int userId) {\n        if (mNextAppWidgetIds.indexOfKey(userId) < 0) {\n            return AppWidgetManager.INVALID_APPWIDGET_ID + 1;\n        } else {\n            return mNextAppWidgetIds.get(userId);\n        }\n    }\n\n    private Host lookupOrAddHostLocked(HostId id) {\n        Host host = lookupHostLocked(id);\n        if (host != null) {\n            return host;\n        }\n        ensureHostCountBeforeAddLocked(id);\n        host = new Host();\n        host.id = id;\n        mHosts.add(host);\n\n        return host;\n    }\n\n    /**\n     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n     * removes the oldest host.\n     */\n    private void ensureHostCountBeforeAddLocked(@NonNull final HostId hostId) {\n        final List<Host> hosts = new ArrayList<>();\n        for (Host host : mHosts) {\n            if (host.id.uid == hostId.uid\n                    && host.id.packageName.equals(hostId.packageName)) {\n                hosts.add(host);\n            }\n        }\n        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n            deleteHostLocked(hosts.remove(0));\n        }\n    }\n\n    private void deleteHostLocked(Host host) {\n        final int N = host.widgets.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Widget widget = host.widgets.remove(i);\n            deleteAppWidgetLocked(widget);\n        }\n        mHosts.remove(host);\n\n        // it's gone or going away, abruptly drop the callback connection\n        host.callbacks = null;\n    }\n\n    private void deleteAppWidgetLocked(Widget widget) {\n        // We first unbind all services that are bound to this id\n        // Check if we need to destroy any services (if no other app widgets are\n        // referencing the same service)\n        decrementAppWidgetServiceRefCount(widget);\n\n        Host host = widget.host;\n        host.widgets.remove(widget);\n        pruneHostLocked(host);\n\n        removeWidgetLocked(widget);\n\n        Provider provider = widget.provider;\n        if (provider != null) {\n            provider.widgets.remove(widget);\n            if (!provider.zombie) {\n                // send the broacast saying that this appWidgetId has been deleted\n                sendDeletedIntentLocked(widget);\n\n                if (provider.widgets.isEmpty()) {\n                    // cancel the future updates\n                    cancelBroadcastsLocked(provider);\n\n                    // send the broacast saying that the provider is not in use any more\n                    sendDisabledIntentLocked(provider);\n                }\n            }\n        }\n    }\n\n    private void cancelBroadcastsLocked(Provider provider) {\n        if (DEBUG) {\n            Slog.i(TAG, \"cancelBroadcastsLocked() for \" + provider);\n        }\n        if (provider.broadcast != null) {\n            final PendingIntent broadcast = provider.broadcast;\n            mSaveStateHandler.post(() -> {\n                    mAlarmManager.cancel(broadcast);\n                    broadcast.cancel();\n            });\n            provider.broadcast = null;\n        }\n    }\n\n    // Destroys the cached factory on the RemoteViewsService's side related to the specified intent\n    private void destroyRemoteViewsService(final Intent intent, Widget widget) {\n        final ServiceConnection conn = new ServiceConnection() {\n            @Override\n            public void onServiceConnected(ComponentName name, IBinder service) {\n                final IRemoteViewsFactory cb = IRemoteViewsFactory.Stub.asInterface(service);\n                try {\n                    cb.onDestroy(intent);\n                } catch (RemoteException re) {\n                    Slog.e(TAG, \"Error calling remove view factory\", re);\n                }\n                mContext.unbindService(this);\n            }\n\n            @Override\n            public void onServiceDisconnected(ComponentName name) {\n                // Do nothing\n            }\n        };\n\n        // Bind to the service and remove the static intent->factory mapping in the\n        // RemoteViewsService.\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.bindServiceAsUser(intent, conn,\n                    Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE,\n                    widget.provider.id.getProfile());\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    // Adds to the ref-count for a given RemoteViewsService intent\n    private void incrementAppWidgetServiceRefCount(int appWidgetId,\n            Pair<Integer, FilterComparison> serviceId) {\n        final HashSet<Integer> appWidgetIds;\n        if (mRemoteViewsServicesAppWidgets.containsKey(serviceId)) {\n            appWidgetIds = mRemoteViewsServicesAppWidgets.get(serviceId);\n        } else {\n            appWidgetIds = new HashSet<>();\n            mRemoteViewsServicesAppWidgets.put(serviceId, appWidgetIds);\n        }\n        appWidgetIds.add(appWidgetId);\n    }\n\n    // Subtracts from the ref-count for a given RemoteViewsService intent, prompting a delete if\n    // the ref-count reaches zero.\n    private void decrementAppWidgetServiceRefCount(Widget widget) {\n        Iterator<Pair<Integer, FilterComparison>> it = mRemoteViewsServicesAppWidgets\n                .keySet().iterator();\n        while (it.hasNext()) {\n            final Pair<Integer, FilterComparison> key = it.next();\n            final HashSet<Integer> ids = mRemoteViewsServicesAppWidgets.get(key);\n            if (ids.remove(widget.appWidgetId)) {\n                // If we have removed the last app widget referencing this service, then we\n                // should destroy it and remove it from this set\n                if (ids.isEmpty()) {\n                    destroyRemoteViewsService(key.second.getIntent(), widget);\n                    it.remove();\n                }\n            }\n        }\n    }\n\n    private void saveGroupStateAsync(int groupId) {\n        mSaveStateHandler.post(new SaveStateRunnable(groupId));\n    }\n\n    private void updateAppWidgetInstanceLocked(Widget widget, RemoteViews views,\n            boolean isPartialUpdate) {\n        if (widget != null && widget.provider != null\n                && !widget.provider.zombie && !widget.host.zombie) {\n\n            if (isPartialUpdate && widget.views != null) {\n                // For a partial update, we merge the new RemoteViews with the old.\n                widget.views.mergeRemoteViews(views);\n            } else {\n                // For a full update we replace the RemoteViews completely.\n                widget.views = views;\n            }\n            int memoryUsage;\n            if ((UserHandle.getAppId(Binder.getCallingUid()) != Process.SYSTEM_UID) &&\n                    (widget.views != null) &&\n                    ((memoryUsage = widget.views.estimateMemoryUsage()) > mMaxWidgetBitmapMemory)) {\n                widget.views = null;\n                throw new IllegalArgumentException(\"RemoteViews for widget update exceeds\"\n                        + \" maximum bitmap memory usage (used: \" + memoryUsage\n                        + \", max: \" + mMaxWidgetBitmapMemory + \")\");\n            }\n            scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n        }\n    }\n    private void scheduleNotifyAppWidgetViewDataChanged(Widget widget, int viewId) {\n        if (viewId == ID_VIEWS_UPDATE || viewId == ID_PROVIDER_CHANGED) {\n            // A view id should never collide with these constants but a developer can call this\n            // method with a wrong id. In that case, ignore the call.\n            return;\n        }\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.put(viewId, requestId);\n        }\n        if (widget == null || widget.host == null || widget.host.zombie\n                || widget.host.callbacks == null || widget.provider == null\n                || widget.provider.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = requestId;\n        args.argi1 = widget.appWidgetId;\n        args.argi2 = viewId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_VIEW_DATA_CHANGED,\n                args).sendToTarget();\n    }\n\n\n    private void handleNotifyAppWidgetViewDataChanged(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, int viewId, long requestId) {\n        try {\n            callbacks.viewDataChanged(appWidgetId, viewId);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            // It failed; remove the callback. No need to prune because\n            // we know that this host is still referenced by this instance.\n            callbacks = null;\n        }\n\n        // If the host is unavailable, then we call the associated\n        // RemoteViewsFactory.onDataSetChanged() directly\n        synchronized (mLock) {\n            if (callbacks == null) {\n                host.callbacks = null;\n\n                Set<Pair<Integer, FilterComparison>> keys = mRemoteViewsServicesAppWidgets.keySet();\n                for (Pair<Integer, FilterComparison> key : keys) {\n                    if (mRemoteViewsServicesAppWidgets.get(key).contains(appWidgetId)) {\n                        final ServiceConnection connection = new ServiceConnection() {\n                            @Override\n                            public void onServiceConnected(ComponentName name, IBinder service) {\n                                IRemoteViewsFactory cb = IRemoteViewsFactory.Stub\n                                        .asInterface(service);\n                                try {\n                                    cb.onDataSetChangedAsync();\n                                } catch (RemoteException e) {\n                                    Slog.e(TAG, \"Error calling onDataSetChangedAsync()\", e);\n                                }\n                                mContext.unbindService(this);\n                            }\n\n                            @Override\n                            public void onServiceDisconnected(android.content.ComponentName name) {\n                                // Do nothing\n                            }\n                        };\n\n                        final int userId = UserHandle.getUserId(key.first);\n                        Intent intent = key.second.getIntent();\n\n                        // Bind to the service and call onDataSetChanged()\n                        bindService(intent, connection, new UserHandle(userId));\n                    }\n                }\n            }\n        }\n    }\n\n    private void scheduleNotifyUpdateAppWidgetLocked(Widget widget, RemoteViews updateViews) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.put(ID_VIEWS_UPDATE, requestId);\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n        if (updateViews != null) {\n            updateViews = new RemoteViews(updateViews);\n            updateViews.setProviderInstanceId(requestId);\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = updateViews;\n        args.arg4 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_UPDATE_APP_WIDGET,\n                args).sendToTarget();\n    }\n\n    private void handleNotifyUpdateAppWidget(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, RemoteViews views, long requestId) {\n        try {\n            callbacks.updateAppWidget(appWidgetId, views);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyProviderChangedLocked(Widget widget) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            // When the provider changes, reset everything else.\n            widget.updateSequenceNos.clear();\n            widget.updateSequenceNos.append(ID_PROVIDER_CHANGED, requestId);\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = widget.provider.getInfoLocked(mContext);\n        args.arg4 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_PROVIDER_CHANGED,\n                args).sendToTarget();\n    }\n\n    private void handleNotifyProviderChanged(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, AppWidgetProviderInfo info, long requestId) {\n        try {\n            callbacks.providerChanged(appWidgetId, info);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock){\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyAppWidgetRemovedLocked(Widget widget) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.clear();\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n            CallbackHandler.MSG_NOTIFY_APP_WIDGET_REMOVED,\n            args).sendToTarget();\n    }\n\n    private void handleNotifyAppWidgetRemoved(Host host, IAppWidgetHost callbacks, int appWidgetId,\n            long requestId) {\n        try {\n            callbacks.appWidgetRemoved(appWidgetId);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyGroupHostsForProvidersChangedLocked(int userId) {\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        final int N = mHosts.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Host host = mHosts.get(i);\n\n            boolean hostInGroup = false;\n            final int M = profileIds.length;\n            for (int j = 0; j < M; j++) {\n                final int profileId = profileIds[j];\n                if (host.getUserId() == profileId) {\n                    hostInGroup = true;\n                    break;\n                }\n            }\n\n            if (!hostInGroup) {\n                continue;\n            }\n\n            if (host == null || host.zombie || host.callbacks == null) {\n                continue;\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = host;\n            args.arg2 = host.callbacks;\n\n            mCallbackHandler.obtainMessage(\n                    CallbackHandler.MSG_NOTIFY_PROVIDERS_CHANGED,\n                    args).sendToTarget();\n        }\n    }\n\n    private void handleNotifyProvidersChanged(Host host, IAppWidgetHost callbacks) {\n        try {\n            callbacks.providersChanged();\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private static boolean isLocalBinder() {\n        return Process.myPid() == Binder.getCallingPid();\n    }\n\n    private static RemoteViews cloneIfLocalBinder(RemoteViews rv) {\n        if (isLocalBinder() && rv != null) {\n            return rv.clone();\n        }\n        return rv;\n    }\n\n    private static AppWidgetProviderInfo cloneIfLocalBinder(AppWidgetProviderInfo info) {\n        if (isLocalBinder() && info != null) {\n            return info.clone();\n        }\n        return info;\n    }\n\n    private static Bundle cloneIfLocalBinder(Bundle bundle) {\n        // Note: this is only a shallow copy. For now this will be fine, but it could be problematic\n        // if we start adding objects to the options. Further, it would only be an issue if keyguard\n        // used such options.\n        if (isLocalBinder() && bundle != null) {\n            return (Bundle) bundle.clone();\n        }\n        return bundle;\n    }\n\n    private Widget lookupWidgetLocked(int appWidgetId, int uid, String packageName) {\n        final int N = mWidgets.size();\n        for (int i = 0; i < N; i++) {\n            Widget widget = mWidgets.get(i);\n            if (widget.appWidgetId == appWidgetId\n                    && mSecurityPolicy.canAccessAppWidget(widget, uid, packageName)) {\n                return widget;\n            }\n        }\n        return null;\n    }\n\n    private Provider lookupProviderLocked(ProviderId id) {\n        final int N = mProviders.size();\n        for (int i = 0; i < N; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.id.equals(id)) {\n                return provider;\n            }\n        }\n        return null;\n    }\n\n    private Host lookupHostLocked(HostId hostId) {\n        final int N = mHosts.size();\n        for (int i = 0; i < N; i++) {\n            Host host = mHosts.get(i);\n            if (host.id.equals(hostId)) {\n                return host;\n            }\n        }\n        return null;\n    }\n\n    private void pruneHostLocked(Host host) {\n        if (host.widgets.size() == 0 && host.callbacks == null) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Pruning host \" + host.id);\n            }\n            mHosts.remove(host);\n        }\n    }\n\n    private void loadGroupWidgetProvidersLocked(int[] profileIds) {\n        List<ResolveInfo> allReceivers = null;\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n\n        final int profileCount = profileIds.length;\n        for (int i = 0; i < profileCount; i++) {\n            final int profileId = profileIds[i];\n\n            List<ResolveInfo> receivers = queryIntentReceivers(intent, profileId);\n            if (receivers != null && !receivers.isEmpty()) {\n                if (allReceivers == null) {\n                    allReceivers = new ArrayList<>();\n                }\n                allReceivers.addAll(receivers);\n            }\n        }\n\n        final int N = (allReceivers == null) ? 0 : allReceivers.size();\n        for (int i = 0; i < N; i++) {\n            ResolveInfo receiver = allReceivers.get(i);\n            addProviderLocked(receiver);\n        }\n    }\n\n    private boolean addProviderLocked(ResolveInfo ri) {\n        if ((ri.activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {\n            return false;\n        }\n\n        ComponentName componentName = new ComponentName(ri.activityInfo.packageName,\n                ri.activityInfo.name);\n        ProviderId providerId = new ProviderId(ri.activityInfo.applicationInfo.uid, componentName);\n\n        // we might have an inactive entry for this provider already due to\n        // a preceding restore operation.  if so, fix it up in place; otherwise\n        // just add this new one.\n        Provider existing = lookupProviderLocked(providerId);\n\n        // If the provider was not found it may be because it was restored and\n        // we did not know its UID so let us find if there is such one.\n        if (existing == null) {\n            ProviderId restoredProviderId = new ProviderId(UNKNOWN_UID, componentName);\n            existing = lookupProviderLocked(restoredProviderId);\n        }\n\n        AppWidgetProviderInfo info = createPartialProviderInfo(providerId, ri, existing);\n        if (info != null) {\n            if (existing != null) {\n                if (existing.zombie && !mSafeMode) {\n                    // it's a placeholder that was set up during an app restore\n                    existing.id = providerId;\n                    existing.zombie = false;\n                    existing.setPartialInfoLocked(info);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Provider placeholder now reified: \" + existing);\n                    }\n                }\n            } else {\n                Provider provider = new Provider();\n                provider.id = providerId;\n                provider.setPartialInfoLocked(info);\n                mProviders.add(provider);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    // Remove widgets for provider that are hosted in userId.\n    private void deleteWidgetsLocked(Provider provider, int userId) {\n        final int N = provider.widgets.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Widget widget = provider.widgets.get(i);\n            if (userId == UserHandle.USER_ALL\n                    || userId == widget.host.getUserId()) {\n                provider.widgets.remove(i);\n                // Call back with empty RemoteViews\n                updateAppWidgetInstanceLocked(widget, null, false);\n                // clear out references to this appWidgetId\n                widget.host.widgets.remove(widget);\n                removeWidgetLocked(widget);\n                widget.provider = null;\n                pruneHostLocked(widget.host);\n                widget.host = null;\n            }\n        }\n    }\n\n    private void deleteProviderLocked(Provider provider) {\n        deleteWidgetsLocked(provider, UserHandle.USER_ALL);\n        mProviders.remove(provider);\n\n        // no need to send the DISABLE broadcast, since the receiver is gone anyway\n        cancelBroadcastsLocked(provider);\n    }\n\n    private void sendEnableIntentLocked(Provider p) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_ENABLED);\n        intent.setComponent(p.id.componentName);\n        sendBroadcastAsUser(intent, p.id.getProfile());\n    }\n\n    private void sendUpdateIntentLocked(Provider provider, int[] appWidgetIds) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds);\n        intent.setComponent(provider.id.componentName);\n        sendBroadcastAsUser(intent, provider.id.getProfile());\n    }\n\n    private void sendDeletedIntentLocked(Widget widget) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_DELETED);\n        intent.setComponent(widget.provider.id.componentName);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, widget.appWidgetId);\n        sendBroadcastAsUser(intent, widget.provider.id.getProfile());\n    }\n\n    private void sendDisabledIntentLocked(Provider provider) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_DISABLED);\n        intent.setComponent(provider.id.componentName);\n        sendBroadcastAsUser(intent, provider.id.getProfile());\n    }\n\n    public void sendOptionsChangedIntentLocked(Widget widget) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_OPTIONS_CHANGED);\n        intent.setComponent(widget.provider.id.componentName);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, widget.appWidgetId);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS, widget.options);\n        sendBroadcastAsUser(intent, widget.provider.id.getProfile());\n    }\n\n    private void registerForBroadcastsLocked(Provider provider, int[] appWidgetIds) {\n        AppWidgetProviderInfo info = provider.getInfoLocked(mContext);\n        if (info.updatePeriodMillis > 0) {\n            // if this is the first instance, set the alarm. otherwise,\n            // rely on the fact that we've already set it and that\n            // PendingIntent.getBroadcast will update the extras.\n            boolean alreadyRegistered = provider.broadcast != null;\n            Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds);\n            intent.setComponent(info.provider);\n            final long token = Binder.clearCallingIdentity();\n            try {\n                // Broadcast alarms sent by system are immutable\n                provider.broadcast = PendingIntent.getBroadcastAsUser(mContext, 1, intent,\n                        PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                        info.getProfile());\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (!alreadyRegistered) {\n                // Set the alarm outside of our locks; we've latched the first-time\n                // invariant and established the PendingIntent safely.\n                final long period = Math.max(info.updatePeriodMillis, MIN_UPDATE_PERIOD);\n                final PendingIntent broadcast = provider.broadcast;\n                mSaveStateHandler.post(() ->\n                    mAlarmManager.setInexactRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,\n                            SystemClock.elapsedRealtime() + period, period, broadcast)\n                );\n            }\n        }\n    }\n\n    private static int[] getWidgetIds(ArrayList<Widget> widgets) {\n        int instancesSize = widgets.size();\n        int appWidgetIds[] = new int[instancesSize];\n        for (int i = 0; i < instancesSize; i++) {\n            appWidgetIds[i] = widgets.get(i).appWidgetId;\n        }\n        return appWidgetIds;\n    }\n\n    private static void dumpProviderLocked(Provider provider, int index, PrintWriter pw) {\n        AppWidgetProviderInfo info = provider.getPartialInfoLocked();\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] provider \");\n        pw.println(provider.id);\n        pw.print(\"    min=(\"); pw.print(info.minWidth);\n        pw.print(\"x\"); pw.print(info.minHeight);\n        pw.print(\")   minResize=(\"); pw.print(info.minResizeWidth);\n        pw.print(\"x\"); pw.print(info.minResizeHeight);\n        pw.print(\") updatePeriodMillis=\");\n        pw.print(info.updatePeriodMillis);\n        pw.print(\" resizeMode=\");\n        pw.print(info.resizeMode);\n        pw.print(\" widgetCategory=\");\n        pw.print(info.widgetCategory);\n        pw.print(\" autoAdvanceViewId=\");\n        pw.print(info.autoAdvanceViewId);\n        pw.print(\" initialLayout=#\");\n        pw.print(Integer.toHexString(info.initialLayout));\n        pw.print(\" initialKeyguardLayout=#\");\n        pw.print(Integer.toHexString(info.initialKeyguardLayout));\n        pw.print(\"   zombie=\"); pw.println(provider.zombie);\n    }\n\n    private static void dumpHost(Host host, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] hostId=\");\n        pw.println(host.id);\n        pw.print(\"    callbacks=\"); pw.println(host.callbacks);\n        pw.print(\"    widgets.size=\"); pw.print(host.widgets.size());\n        pw.print(\" zombie=\"); pw.println(host.zombie);\n    }\n\n    private static void dumpGrant(Pair<Integer, String> grant, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(']');\n        pw.print(\" user=\"); pw.print(grant.first);\n        pw.print(\" package=\"); pw.println(grant.second);\n    }\n\n    private static void dumpWidget(Widget widget, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] id=\");\n        pw.println(widget.appWidgetId);\n        pw.print(\"    host=\");\n        pw.println(widget.host.id);\n        if (widget.provider != null) {\n            pw.print(\"    provider=\"); pw.println(widget.provider.id);\n        }\n        if (widget.host != null) {\n            pw.print(\"    host.callbacks=\"); pw.println(widget.host.callbacks);\n        }\n        if (widget.views != null) {\n            pw.print(\"    views=\"); pw.println(widget.views);\n        }\n    }\n\n    private static void serializeProvider(TypedXmlSerializer out, Provider p) throws IOException {\n        out.startTag(null, \"p\");\n        out.attribute(null, \"pkg\", p.id.componentName.getPackageName());\n        out.attribute(null, \"cl\", p.id.componentName.getClassName());\n        out.attributeIntHex(null, \"tag\", p.tag);\n        if (!TextUtils.isEmpty(p.infoTag)) {\n            out.attribute(null, \"info_tag\", p.infoTag);\n        }\n        out.endTag(null, \"p\");\n    }\n\n    private static void serializeHost(TypedXmlSerializer out, Host host) throws IOException {\n        out.startTag(null, \"h\");\n        out.attribute(null, \"pkg\", host.id.packageName);\n        out.attributeIntHex(null, \"id\", host.id.hostId);\n        out.attributeIntHex(null, \"tag\", host.tag);\n        out.endTag(null, \"h\");\n    }\n\n    private static void serializeAppWidget(TypedXmlSerializer out, Widget widget,\n            boolean saveRestoreCompleted) throws IOException {\n        out.startTag(null, \"g\");\n        out.attributeIntHex(null, \"id\", widget.appWidgetId);\n        out.attributeIntHex(null, \"rid\", widget.restoredId);\n        out.attributeIntHex(null, \"h\", widget.host.tag);\n        if (widget.provider != null) {\n            out.attributeIntHex(null, \"p\", widget.provider.tag);\n        }\n        if (widget.options != null) {\n            int minWidth = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH);\n            int minHeight = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT);\n            int maxWidth = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH);\n            int maxHeight = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT);\n            out.attributeIntHex(null, \"min_width\", (minWidth > 0) ? minWidth : 0);\n            out.attributeIntHex(null, \"min_height\", (minHeight > 0) ? minHeight : 0);\n            out.attributeIntHex(null, \"max_width\", (maxWidth > 0) ? maxWidth : 0);\n            out.attributeIntHex(null, \"max_height\", (maxHeight > 0) ? maxHeight : 0);\n            out.attributeIntHex(null, \"host_category\", widget.options.getInt(\n                    AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY));\n            if (saveRestoreCompleted) {\n                boolean restoreCompleted = widget.options.getBoolean(\n                        AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED);\n                out.attributeBoolean(null, \"restore_completed\", restoreCompleted);\n            }\n        }\n        out.endTag(null, \"g\");\n    }\n\n    private static Bundle parseWidgetIdOptions(TypedXmlPullParser parser) {\n        Bundle options = new Bundle();\n        boolean restoreCompleted = parser.getAttributeBoolean(null, \"restore_completed\", false);\n        if (restoreCompleted) {\n            options.putBoolean(AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED, true);\n        }\n        int minWidth = parser.getAttributeIntHex(null, \"min_width\", -1);\n        if (minWidth != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH, minWidth);\n        }\n        int minHeight = parser.getAttributeIntHex(null, \"min_height\", -1);\n        if (minHeight != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, minHeight);\n        }\n        int maxWidth = parser.getAttributeIntHex(null, \"max_width\", -1);\n        if (maxWidth != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH, maxWidth);\n        }\n        int maxHeight = parser.getAttributeIntHex(null, \"max_height\", -1);\n        if (maxHeight != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, maxHeight);\n        }\n        int category = parser.getAttributeIntHex(null, \"host_category\",\n                AppWidgetProviderInfo.WIDGET_CATEGORY_UNKNOWN);\n        if (category != AppWidgetProviderInfo.WIDGET_CATEGORY_UNKNOWN) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY, category);\n        }\n        return options;\n    }\n\n    @Override\n    public List<String> getWidgetParticipants(int userId) {\n        return mBackupRestoreController.getWidgetParticipants(userId);\n    }\n\n    @Override\n    public byte[] getWidgetState(String packageName, int userId) {\n        return mBackupRestoreController.getWidgetState(packageName, userId);\n    }\n\n    @Override\n    public void systemRestoreStarting(int userId) {\n        mBackupRestoreController.systemRestoreStarting(userId);\n    }\n\n    @Override\n    public void restoreWidgetState(String packageName, byte[] restoredState, int userId) {\n        mBackupRestoreController.restoreWidgetState(packageName, restoredState, userId);\n    }\n\n    @Override\n    public void systemRestoreFinished(int userId) {\n        mBackupRestoreController.systemRestoreFinished(userId);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private AppWidgetProviderInfo createPartialProviderInfo(ProviderId providerId, ResolveInfo ri,\n            Provider provider) {\n        boolean hasXmlDefinition = false;\n        Bundle metaData = ri.activityInfo.metaData;\n        if (metaData == null) {\n            return null;\n        }\n\n        if (provider != null && !TextUtils.isEmpty(provider.infoTag)) {\n            hasXmlDefinition = metaData.getInt(provider.infoTag) != 0;\n        }\n        hasXmlDefinition |= metaData.getInt(AppWidgetManager.META_DATA_APPWIDGET_PROVIDER) != 0;\n\n        if (hasXmlDefinition) {\n            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n            info.provider = providerId.componentName;\n            info.providerInfo = ri.activityInfo;\n            return info;\n        }\n        return null;\n    }\n\n    private static AppWidgetProviderInfo parseAppWidgetProviderInfo(Context context,\n            ProviderId providerId, ActivityInfo activityInfo, String metadataKey) {\n        final PackageManager pm = context.getPackageManager();\n        try (XmlResourceParser parser = activityInfo.loadXmlMetaData(pm, metadataKey)) {\n            if (parser == null) {\n                Slog.w(TAG, \"No \" + metadataKey + \" meta-data for AppWidget provider '\"\n                        + providerId + '\\'');\n                return null;\n            }\n\n            AttributeSet attrs = Xml.asAttributeSet(parser);\n\n            int type;\n            while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                    && type != XmlPullParser.START_TAG) {\n                // drain whitespace, comments, etc.\n            }\n\n            String nodeName = parser.getName();\n            if (!\"appwidget-provider\".equals(nodeName)) {\n                Slog.w(TAG, \"Meta-data does not start with appwidget-provider tag for\"\n                        + \" AppWidget provider \" + providerId.componentName\n                        + \" for user \" + providerId.uid);\n                return null;\n            }\n\n            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n            info.provider = providerId.componentName;\n            info.providerInfo = activityInfo;\n\n            final Resources resources;\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final int userId = UserHandle.getUserId(providerId.uid);\n                final ApplicationInfo app = pm.getApplicationInfoAsUser(activityInfo.packageName,\n                        0, userId);\n                resources = pm.getResourcesForApplication(app);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n\n            TypedArray sa = resources.obtainAttributes(attrs,\n                    com.android.internal.R.styleable.AppWidgetProviderInfo);\n\n            // These dimensions has to be resolved in the application's context.\n            // We simply send back the raw complex data, which will be\n            // converted to dp in {@link AppWidgetManager#getAppWidgetInfo}.\n            TypedValue value = sa\n                    .peekValue(com.android.internal.R.styleable.AppWidgetProviderInfo_minWidth);\n            info.minWidth = value != null ? value.data : 0;\n            value = sa.peekValue(com.android.internal.R.styleable.AppWidgetProviderInfo_minHeight);\n            info.minHeight = value != null ? value.data : 0;\n\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_minResizeWidth);\n            info.minResizeWidth = value != null ? value.data : info.minWidth;\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_minResizeHeight);\n            info.minResizeHeight = value != null ? value.data : info.minHeight;\n\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_maxResizeWidth);\n            info.maxResizeWidth = value != null ? value.data : 0;\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_maxResizeHeight);\n            info.maxResizeHeight = value != null ? value.data : 0;\n\n            info.targetCellWidth = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_targetCellWidth, 0);\n            info.targetCellHeight = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_targetCellHeight, 0);\n\n            info.updatePeriodMillis = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_updatePeriodMillis, 0);\n            info.initialLayout = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_initialLayout, ID_NULL);\n            info.initialKeyguardLayout = sa.getResourceId(com.android.internal.R.styleable.\n                    AppWidgetProviderInfo_initialKeyguardLayout, ID_NULL);\n\n            String className = sa\n                    .getString(com.android.internal.R.styleable.AppWidgetProviderInfo_configure);\n            if (className != null) {\n                info.configure = new ComponentName(providerId.componentName.getPackageName(),\n                        className);\n            }\n            info.label = activityInfo.loadLabel(pm).toString();\n            info.icon = activityInfo.getIconResource();\n            info.previewImage = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_previewImage, ID_NULL);\n            info.previewLayout = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_previewLayout, ID_NULL);\n            info.autoAdvanceViewId = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_autoAdvanceViewId,\n                    View.NO_ID);\n            info.resizeMode = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_resizeMode,\n                    AppWidgetProviderInfo.RESIZE_NONE);\n            info.widgetCategory = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_widgetCategory,\n                    AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN);\n            info.widgetFeatures = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_widgetFeatures, 0);\n            info.descriptionRes = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_description, ID_NULL);\n            sa.recycle();\n            return info;\n        } catch (IOException | PackageManager.NameNotFoundException | XmlPullParserException e) {\n            // Ok to catch Exception here, because anything going wrong because\n            // of what a client process passes to us should not be fatal for the\n            // system process.\n            Slog.w(TAG, \"XML parsing failed for AppWidget provider \"\n                    + providerId.componentName + \" for user \" + providerId.uid, e);\n            return null;\n        }\n    }\n\n    private int getUidForPackage(String packageName, int userId) {\n        PackageInfo pkgInfo = null;\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            pkgInfo = mPackageManager.getPackageInfo(packageName, 0, userId);\n        } catch (RemoteException re) {\n            // Shouldn't happen, local call\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n\n        if (pkgInfo == null || pkgInfo.applicationInfo == null) {\n            return -1;\n        }\n\n        return pkgInfo.applicationInfo.uid;\n    }\n\n    private ActivityInfo getProviderInfo(ComponentName componentName, int userId) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.setComponent(componentName);\n\n        List<ResolveInfo> receivers = queryIntentReceivers(intent, userId);\n        // We are setting component, so there is only one or none.\n        if (!receivers.isEmpty()) {\n            return receivers.get(0).activityInfo;\n        }\n\n        return null;\n    }\n\n    private List<ResolveInfo> queryIntentReceivers(Intent intent, int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            int flags = PackageManager.GET_META_DATA;\n\n            // We really need packages to be around and parsed to know if they\n            // provide widgets.\n            flags |= PackageManager.MATCH_DEBUG_TRIAGED_MISSING;\n\n            // Widget hosts that are non-crypto aware may be hosting widgets\n            // from a profile that is still locked, so let them see those\n            // widgets.\n            if (isProfileWithUnlockedParent(userId)) {\n                flags |= PackageManager.MATCH_DIRECT_BOOT_AWARE\n                        | PackageManager.MATCH_DIRECT_BOOT_UNAWARE;\n            }\n\n            // Widgets referencing shared libraries need to have their\n            // dependencies loaded.\n            flags |= PackageManager.GET_SHARED_LIBRARY_FILES;\n\n            return mPackageManager.queryIntentReceivers(intent,\n                    intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                    flags, userId).getList();\n        } catch (RemoteException re) {\n            return Collections.emptyList();\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    /**\n     * This does not use the usual onUserUnlocked() listener mechanism because it is\n     * invoked at a choreographed point in the middle of the user unlock sequence,\n     * before the boot-completed broadcast is issued and the listeners notified.\n     */\n    void handleUserUnlocked(int userId) {\n        if (isProfileWithLockedParent(userId)) {\n            return;\n        }\n        if (!mUserManager.isUserUnlockingOrUnlocked(userId)) {\n            Slog.w(TAG, \"User \" + userId + \" is no longer unlocked - exiting\");\n            return;\n        }\n        long time = SystemClock.elapsedRealtime();\n        synchronized (mLock) {\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"appwidget ensure\");\n            ensureGroupStateLoadedLocked(userId);\n            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"appwidget reload\");\n            reloadWidgetsMaskedStateForGroup(mSecurityPolicy.getGroupParent(userId));\n            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n\n                // Send broadcast only to the providers of the user.\n                if (provider.getUserId() != userId) {\n                    continue;\n                }\n\n                if (provider.widgets.size() > 0) {\n                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,\n                            \"appwidget init \" + provider.id.componentName.getPackageName());\n                    sendEnableIntentLocked(provider);\n                    int[] appWidgetIds = getWidgetIds(provider.widgets);\n                    sendUpdateIntentLocked(provider, appWidgetIds);\n                    registerForBroadcastsLocked(provider, appWidgetIds);\n                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n                }\n            }\n        }\n        Slog.i(TAG, \"Processing of handleUserUnlocked u\" + userId + \" took \"\n                + (SystemClock.elapsedRealtime() - time) + \" ms\");\n    }\n\n    // only call from initialization -- it assumes that the data structures are all empty\n    private void loadGroupStateLocked(int[] profileIds) {\n        // We can bind the widgets to host and providers only after\n        // reading the host and providers for all users since a widget\n        // can have a host and a provider in different users.\n        List<LoadedWidgetState> loadedWidgets = new ArrayList<>();\n\n        int version = 0;\n\n        final int profileIdCount = profileIds.length;\n        for (int i = 0; i < profileIdCount; i++) {\n            final int profileId = profileIds[i];\n\n            // No file written for this user - nothing to do.\n            AtomicFile file = getSavedStateFile(profileId);\n            try (FileInputStream stream = file.openRead()) {\n                version = readProfileStateFromFileLocked(stream, profileId, loadedWidgets);\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to read state: \" + e);\n            }\n        }\n\n        if (version >= 0) {\n            // Hooke'm up...\n            bindLoadedWidgetsLocked(loadedWidgets);\n\n            // upgrade the database if needed\n            performUpgradeLocked(version);\n        } else {\n            // failed reading, clean up\n            Slog.w(TAG, \"Failed to read state, clearing widgets and hosts.\");\n            clearWidgetsLocked();\n            mHosts.clear();\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                mProviders.get(i).widgets.clear();\n            }\n        }\n    }\n\n    private void bindLoadedWidgetsLocked(List<LoadedWidgetState> loadedWidgets) {\n        final int loadedWidgetCount = loadedWidgets.size();\n        for (int i = loadedWidgetCount - 1; i >= 0; i--) {\n            LoadedWidgetState loadedWidget = loadedWidgets.remove(i);\n            Widget widget = loadedWidget.widget;\n\n            widget.provider = findProviderByTag(loadedWidget.providerTag);\n            if (widget.provider == null) {\n                // This provider is gone. We just let the host figure out\n                // that this happened when it fails to load it.\n                continue;\n            }\n\n            widget.host = findHostByTag(loadedWidget.hostTag);\n            if (widget.host == null) {\n                // This host is gone.\n                continue;\n            }\n\n            widget.provider.widgets.add(widget);\n            widget.host.widgets.add(widget);\n            addWidgetLocked(widget);\n        }\n    }\n\n    private Provider findProviderByTag(int tag) {\n        if (tag < 0) {\n            return null;\n        }\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.tag == tag) {\n                return provider;\n            }\n        }\n        return null;\n    }\n\n    private Host findHostByTag(int tag) {\n        if (tag < 0) {\n            return null;\n        }\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            if (host.tag == tag) {\n                return host;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n     */\n    void addWidgetLocked(Widget widget) {\n        mWidgets.add(widget);\n\n        onWidgetProviderAddedOrChangedLocked(widget);\n    }\n\n    /**\n     * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n     * that have bound widgets.\n     */\n    void onWidgetProviderAddedOrChangedLocked(Widget widget) {\n        if (widget.provider == null) return;\n\n        int userId = widget.provider.getUserId();\n        synchronized (mWidgetPackagesLock) {\n            ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages == null) {\n                mWidgetPackages.put(userId, packages = new ArraySet<String>());\n            }\n            packages.add(widget.provider.id.componentName.getPackageName());\n        }\n\n        // If we are adding a widget it might be for a provider that\n        // is currently masked, if so mask the widget.\n        if (widget.provider.isMaskedLocked()) {\n            maskWidgetsViewsLocked(widget.provider, widget);\n        } else {\n            widget.clearMaskedViewsLocked();\n        }\n    }\n\n    /**\n     * Removes a widget from mWidgets and updates the cache of bound widget provider packages.\n     * If there are other widgets with the same package, leaves it in the cache, otherwise it\n     * removes the associated package from the cache.\n     */\n    void removeWidgetLocked(Widget widget) {\n        mWidgets.remove(widget);\n        onWidgetRemovedLocked(widget);\n        scheduleNotifyAppWidgetRemovedLocked(widget);\n    }\n\n    private void onWidgetRemovedLocked(Widget widget) {\n        if (widget.provider == null) return;\n\n        final int userId = widget.provider.getUserId();\n        final String packageName = widget.provider.id.componentName.getPackageName();\n        synchronized (mWidgetPackagesLock) {\n            ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages == null) {\n                return;\n            }\n            // Check if there is any other widget with the same package name.\n            // Remove packageName if none.\n            final int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget w = mWidgets.get(i);\n                if (w.provider == null) continue;\n                if (w.provider.getUserId() == userId\n                        && packageName.equals(w.provider.id.componentName.getPackageName())) {\n                    return;\n                }\n            }\n            packages.remove(packageName);\n        }\n    }\n\n    /**\n     * Clears all widgets and associated cache of packages with bound widgets.\n     */\n    void clearWidgetsLocked() {\n        mWidgets.clear();\n\n        onWidgetsClearedLocked();\n    }\n\n    private void onWidgetsClearedLocked() {\n        synchronized (mWidgetPackagesLock) {\n            mWidgetPackages.clear();\n        }\n    }\n\n    @Override\n    public boolean isBoundWidgetPackage(String packageName, int userId) {\n        if (Binder.getCallingUid() != Process.SYSTEM_UID) {\n            throw new SecurityException(\"Only the system process can call this\");\n        }\n        synchronized (mWidgetPackagesLock) {\n            final ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages != null) {\n                return packages.contains(packageName);\n            }\n        }\n        return false;\n    }\n\n    private void saveStateLocked(int userId) {\n        tagProvidersAndHosts();\n\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        final int profileCount = profileIds.length;\n        for (int i = 0; i < profileCount; i++) {\n            final int profileId = profileIds[i];\n\n            AtomicFile file = getSavedStateFile(profileId);\n            FileOutputStream stream;\n            try {\n                stream = file.startWrite();\n                if (writeProfileStateToFileLocked(stream, profileId)) {\n                    file.finishWrite(stream);\n                } else {\n                    file.failWrite(stream);\n                    Slog.w(TAG, \"Failed to save state, restoring backup.\");\n                }\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed open state file for write: \" + e);\n            }\n        }\n    }\n\n    private void tagProvidersAndHosts() {\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            provider.tag = i;\n        }\n\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            host.tag = i;\n        }\n    }\n\n    private void clearProvidersAndHostsTagsLocked() {\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            provider.tag = TAG_UNDEFINED;\n        }\n\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            host.tag = TAG_UNDEFINED;\n        }\n    }\n\n    private boolean writeProfileStateToFileLocked(FileOutputStream stream, int userId) {\n        int N;\n\n        try {\n            TypedXmlSerializer out = Xml.resolveSerializer(stream);\n            out.startDocument(null, true);\n            out.startTag(null, \"gs\");\n            out.attributeInt(null, \"version\", CURRENT_VERSION);\n\n            N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                // Save only providers for the user.\n                if (provider.getUserId() != userId) {\n                    continue;\n                }\n                if (provider.shouldBePersisted()) {\n                    serializeProvider(out, provider);\n                }\n            }\n\n            N = mHosts.size();\n            for (int i = 0; i < N; i++) {\n                Host host = mHosts.get(i);\n                // Save only hosts for the user.\n                if (host.getUserId() != userId) {\n                    continue;\n                }\n                serializeHost(out, host);\n            }\n\n            N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n                // Save only widgets hosted by the user.\n                if (widget.host.getUserId() != userId) {\n                    continue;\n                }\n                serializeAppWidget(out, widget, true);\n            }\n\n            Iterator<Pair<Integer, String>> it = mPackagesWithBindWidgetPermission.iterator();\n            while (it.hasNext()) {\n                Pair<Integer, String> binding = it.next();\n                // Save only white listings for the user.\n                if (binding.first != userId) {\n                    continue;\n                }\n                out.startTag(null, \"b\");\n                out.attribute(null, \"packageName\", binding.second);\n                out.endTag(null, \"b\");\n            }\n\n            out.endTag(null, \"gs\");\n            out.endDocument();\n            return true;\n        } catch (IOException e) {\n            Slog.w(TAG, \"Failed to write state: \" + e);\n            return false;\n        }\n    }\n\n    private int readProfileStateFromFileLocked(FileInputStream stream, int userId,\n            List<LoadedWidgetState> outLoadedWidgets) {\n        int version = -1;\n        try {\n            TypedXmlPullParser parser = Xml.resolvePullParser(stream);\n\n            int legacyProviderIndex = -1;\n            int legacyHostIndex = -1;\n            int type;\n            do {\n                type = parser.next();\n                if (type == XmlPullParser.START_TAG) {\n                    String tag = parser.getName();\n                    if (\"gs\".equals(tag)) {\n                        version = parser.getAttributeInt(null, \"version\", 0);\n                    } else if (\"p\".equals(tag)) {\n                        legacyProviderIndex++;\n                        // TODO: do we need to check that this package has the same signature\n                        // as before?\n                        String pkg = parser.getAttributeValue(null, \"pkg\");\n                        String cl = parser.getAttributeValue(null, \"cl\");\n\n                        pkg = getCanonicalPackageName(pkg, cl, userId);\n                        if (pkg == null) {\n                            continue;\n                        }\n\n                        final int uid = getUidForPackage(pkg, userId);\n                        if (uid < 0) {\n                            continue;\n                        }\n\n                        ComponentName componentName = new ComponentName(pkg, cl);\n\n                        ActivityInfo providerInfo = getProviderInfo(componentName, userId);\n                        if (providerInfo == null) {\n                            continue;\n                        }\n\n                        ProviderId providerId = new ProviderId(uid, componentName);\n                        Provider provider = lookupProviderLocked(providerId);\n\n                        if (provider == null && mSafeMode) {\n                            // if we're in safe mode, make a temporary one\n                            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n                            info.provider = providerId.componentName;\n                            info.providerInfo = providerInfo;\n\n                            provider = new Provider();\n                            provider.setPartialInfoLocked(info);\n                            provider.zombie = true;\n                            provider.id = providerId;\n                            mProviders.add(provider);\n                        }\n\n                        final int providerTag = parser.getAttributeIntHex(null, \"tag\",\n                                legacyProviderIndex);\n                        provider.tag = providerTag;\n                        provider.infoTag = parser.getAttributeValue(null, \"info_tag\");\n                    } else if (\"h\".equals(tag)) {\n                        legacyHostIndex++;\n                        Host host = new Host();\n                        // TODO: do we need to check that this package has the same signature\n                        // as before?\n                        String pkg = parser.getAttributeValue(null, \"pkg\");\n\n                        final int uid = getUidForPackage(pkg, userId);\n                        if (uid < 0) {\n                            host.zombie = true;\n                        }\n\n                        if (!host.zombie || mSafeMode) {\n                            // In safe mode, we don't discard the hosts we don't recognize\n                            // so that they're not pruned from our list. Otherwise, we do.\n                            final int hostId = parser.getAttributeIntHex(null, \"id\");\n                            final int hostTag = parser.getAttributeIntHex(null, \"tag\",\n                                    legacyHostIndex);\n\n                            host.tag = hostTag;\n                            host.id = new HostId(uid, hostId, pkg);\n                            mHosts.add(host);\n                        }\n                    } else if (\"b\".equals(tag)) {\n                        String packageName = parser.getAttributeValue(null, \"packageName\");\n                        final int uid = getUidForPackage(packageName, userId);\n                        if (uid >= 0) {\n                            Pair<Integer, String> packageId = Pair.create(userId, packageName);\n                            mPackagesWithBindWidgetPermission.add(packageId);\n                        }\n                    } else if (\"g\".equals(tag)) {\n                        Widget widget = new Widget();\n                        widget.appWidgetId = parser.getAttributeIntHex(null, \"id\");\n                        setMinAppWidgetIdLocked(userId, widget.appWidgetId + 1);\n\n                        // restored ID is allowed to be absent\n                        widget.restoredId = parser.getAttributeIntHex(null, \"rid\", 0);\n                        widget.options = parseWidgetIdOptions(parser);\n\n                        final int hostTag = parser.getAttributeIntHex(null, \"h\");\n                        String providerString = parser.getAttributeValue(null, \"p\");\n                        final int providerTag = (providerString != null)\n                                ? parser.getAttributeIntHex(null, \"p\") : TAG_UNDEFINED;\n\n                        // We can match widgets with hosts and providers only after hosts\n                        // and providers for all users have been loaded since the widget\n                        // host and provider can be in different user profiles.\n                        LoadedWidgetState loadedWidgets = new LoadedWidgetState(widget,\n                                hostTag, providerTag);\n                        outLoadedWidgets.add(loadedWidgets);\n                    }\n                }\n            } while (type != XmlPullParser.END_DOCUMENT);\n        } catch (NullPointerException\n                | NumberFormatException\n                | XmlPullParserException\n                | IOException\n                | IndexOutOfBoundsException e) {\n            Slog.w(TAG, \"failed parsing \" + e);\n            return -1;\n        }\n\n        return version;\n    }\n\n    private void performUpgradeLocked(int fromVersion) {\n        if (fromVersion < CURRENT_VERSION) {\n            Slog.v(TAG, \"Upgrading widget database from \" + fromVersion + \" to \"\n                    + CURRENT_VERSION);\n        }\n\n        int version = fromVersion;\n\n        // Update 1: keyguard moved from package \"android\" to \"com.android.keyguard\"\n        if (version == 0) {\n            HostId oldHostId = new HostId(Process.myUid(),\n                    KEYGUARD_HOST_ID, OLD_KEYGUARD_HOST_PACKAGE);\n\n            Host host = lookupHostLocked(oldHostId);\n            if (host != null) {\n                final int uid = getUidForPackage(NEW_KEYGUARD_HOST_PACKAGE,\n                        UserHandle.USER_SYSTEM);\n                if (uid >= 0) {\n                    host.id = new HostId(uid, KEYGUARD_HOST_ID, NEW_KEYGUARD_HOST_PACKAGE);\n                }\n            }\n\n            version = 1;\n        }\n\n        if (version != CURRENT_VERSION) {\n            throw new IllegalStateException(\"Failed to upgrade widget database\");\n        }\n    }\n\n    private static File getStateFile(int userId) {\n        return new File(Environment.getUserSystemDirectory(userId), STATE_FILENAME);\n    }\n\n    private static AtomicFile getSavedStateFile(int userId) {\n        File dir = Environment.getUserSystemDirectory(userId);\n        File settingsFile = getStateFile(userId);\n        if (!settingsFile.exists() && userId == UserHandle.USER_SYSTEM) {\n            if (!dir.exists()) {\n                dir.mkdirs();\n            }\n            // Migrate old data\n            File oldFile = new File(\"/data/system/\" + STATE_FILENAME);\n            // Method doesn't throw an exception on failure. Ignore any errors\n            // in moving the file (like non-existence)\n            oldFile.renameTo(settingsFile);\n        }\n        return new AtomicFile(settingsFile);\n    }\n\n    void onUserStopped(int userId) {\n        synchronized (mLock) {\n            boolean crossProfileWidgetsChanged = false;\n\n            // Remove widgets that have both host and provider in the user.\n            final int widgetCount = mWidgets.size();\n            for (int i = widgetCount - 1; i >= 0; i--) {\n                Widget widget = mWidgets.get(i);\n\n                final boolean hostInUser = widget.host.getUserId() == userId;\n                final boolean hasProvider = widget.provider != null;\n                final boolean providerInUser = hasProvider && widget.provider.getUserId() == userId;\n\n                // If both host and provider are in the user, just drop the widgets\n                // as we do not want to make host callbacks and provider broadcasts\n                // as the host and the provider will be killed.\n                if (hostInUser && (!hasProvider || providerInUser)) {\n                    removeWidgetLocked(widget);\n                    widget.host.widgets.remove(widget);\n                    widget.host = null;\n                    if (hasProvider) {\n                        widget.provider.widgets.remove(widget);\n                        widget.provider = null;\n                    }\n                }\n            }\n\n            // Remove hosts and notify providers in other profiles.\n            final int hostCount = mHosts.size();\n            for (int i = hostCount - 1; i >= 0; i--) {\n                Host host = mHosts.get(i);\n                if (host.getUserId() == userId) {\n                    crossProfileWidgetsChanged |= !host.widgets.isEmpty();\n                    deleteHostLocked(host);\n                }\n            }\n\n            // Leave the providers present as hosts will show the widgets\n            // masked while the user is stopped.\n\n            // Remove grants for this user.\n            final int grantCount = mPackagesWithBindWidgetPermission.size();\n            for (int i = grantCount - 1; i >= 0; i--) {\n                Pair<Integer, String> packageId = mPackagesWithBindWidgetPermission.valueAt(i);\n                if (packageId.first == userId) {\n                    mPackagesWithBindWidgetPermission.removeAt(i);\n                }\n            }\n\n            // Take a note we no longer have state for this user.\n            final int userIndex = mLoadedUserIds.indexOfKey(userId);\n            if (userIndex >= 0) {\n                mLoadedUserIds.removeAt(userIndex);\n            }\n\n            // Remove the widget id counter.\n            final int nextIdIndex = mNextAppWidgetIds.indexOfKey(userId);\n            if (nextIdIndex >= 0) {\n                mNextAppWidgetIds.removeAt(nextIdIndex);\n            }\n\n            // Save state if removing a profile changed the group state.\n            // Nothing will be saved if the group parent was removed.\n            if (crossProfileWidgetsChanged) {\n                saveGroupStateAsync(userId);\n            }\n        }\n    }\n\n    private void applyResourceOverlaysToWidgetsLocked(Set<String> packageNames, int userId,\n            boolean updateFrameworkRes) {\n        for (int i = 0, N = mProviders.size(); i < N; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.getUserId() != userId) {\n                continue;\n            }\n\n            final String packageName = provider.id.componentName.getPackageName();\n            if (!updateFrameworkRes && !packageNames.contains(packageName)) {\n                continue;\n            }\n\n            ApplicationInfo newAppInfo = null;\n            try {\n                newAppInfo = mPackageManager.getApplicationInfo(packageName,\n                        PackageManager.GET_SHARED_LIBRARY_FILES, userId);\n            } catch (RemoteException e) {\n                Slog.w(TAG, \"Failed to retrieve app info for \" + packageName\n                        + \" userId=\" + userId, e);\n            }\n            if (newAppInfo == null || provider.info == null\n                    || provider.info.providerInfo == null) {\n                continue;\n            }\n            ApplicationInfo oldAppInfo = provider.info.providerInfo.applicationInfo;\n            if (oldAppInfo == null || !newAppInfo.sourceDir.equals(oldAppInfo.sourceDir)) {\n                // Overlay paths are generated against a particular version of an application.\n                // The overlays paths of a newly upgraded application are incompatible with the\n                // old version of the application.\n                continue;\n            }\n\n            // Isolate the changes relating to RROs. The app info must be copied to prevent\n            // affecting other parts of system server that may have cached this app info.\n            oldAppInfo = new ApplicationInfo(oldAppInfo);\n            oldAppInfo.overlayPaths = newAppInfo.overlayPaths.clone();\n            oldAppInfo.resourceDirs = newAppInfo.resourceDirs.clone();\n            provider.info.providerInfo.applicationInfo = oldAppInfo;\n\n            for (int j = 0, M = provider.widgets.size(); j < M; j++) {\n                Widget widget = provider.widgets.get(j);\n                if (widget.views != null) {\n                    widget.views.updateAppInfo(oldAppInfo);\n                }\n                if (widget.maskedViews != null) {\n                    widget.maskedViews.updateAppInfo(oldAppInfo);\n                }\n            }\n        }\n    }\n\n    /**\n     * Updates all providers with the specified package names, and records any providers that were\n     * pruned.\n     *\n     * @return whether any providers were updated\n     */\n    private boolean updateProvidersForPackageLocked(String packageName, int userId,\n            Set<ProviderId> removedProviders) {\n        boolean providersUpdated = false;\n\n        HashSet<ProviderId> keep = new HashSet<>();\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.setPackage(packageName);\n        List<ResolveInfo> broadcastReceivers = queryIntentReceivers(intent, userId);\n\n        // add the missing ones and collect which ones to keep\n        int N = broadcastReceivers == null ? 0 : broadcastReceivers.size();\n        for (int i = 0; i < N; i++) {\n            ResolveInfo ri = broadcastReceivers.get(i);\n            ActivityInfo ai = ri.activityInfo;\n\n            if ((ai.applicationInfo.flags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {\n                continue;\n            }\n\n            if (packageName.equals(ai.packageName)) {\n                ProviderId providerId = new ProviderId(ai.applicationInfo.uid,\n                        new ComponentName(ai.packageName, ai.name));\n\n                Provider provider = lookupProviderLocked(providerId);\n                if (provider == null) {\n                    if (addProviderLocked(ri)) {\n                        keep.add(providerId);\n                        providersUpdated = true;\n                    }\n                } else {\n                    AppWidgetProviderInfo info =\n                            createPartialProviderInfo(providerId, ri, provider);\n                    if (info != null) {\n                        keep.add(providerId);\n                        // Use the new AppWidgetProviderInfo.\n                        provider.setPartialInfoLocked(info);\n                        // If it's enabled\n                        final int M = provider.widgets.size();\n                        if (M > 0) {\n                            int[] appWidgetIds = getWidgetIds(provider.widgets);\n                            // Reschedule for the new updatePeriodMillis (don't worry about handling\n                            // it specially if updatePeriodMillis didn't change because we just sent\n                            // an update, and the next one will be updatePeriodMillis from now).\n                            cancelBroadcastsLocked(provider);\n                            registerForBroadcastsLocked(provider, appWidgetIds);\n                            // If it's currently showing, call back with the new\n                            // AppWidgetProviderInfo.\n                            for (int j = 0; j < M; j++) {\n                                Widget widget = provider.widgets.get(j);\n                                widget.views = null;\n                                scheduleNotifyProviderChangedLocked(widget);\n                            }\n                            // Now that we've told the host, push out an update.\n                            sendUpdateIntentLocked(provider, appWidgetIds);\n                        }\n                    }\n                    providersUpdated = true;\n                }\n            }\n        }\n\n        // prune the ones we don't want to keep\n        N = mProviders.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Provider provider = mProviders.get(i);\n            if (packageName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId\n                    && !keep.contains(provider.id)) {\n                if (removedProviders != null) {\n                    removedProviders.add(provider.id);\n                }\n                deleteProviderLocked(provider);\n                providersUpdated = true;\n            }\n        }\n\n        return providersUpdated;\n    }\n\n    // Remove widgets for provider in userId that are hosted in parentUserId\n    private void removeWidgetsForPackageLocked(String pkgName, int userId, int parentUserId) {\n        final int N = mProviders.size();\n        for (int i = 0; i < N; ++i) {\n            Provider provider = mProviders.get(i);\n            if (pkgName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId\n                    && provider.widgets.size() > 0) {\n                deleteWidgetsLocked(provider, parentUserId);\n            }\n        }\n    }\n\n    private boolean removeProvidersForPackageLocked(String pkgName, int userId) {\n        boolean removed = false;\n\n        final int N = mProviders.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Provider provider = mProviders.get(i);\n            if (pkgName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId) {\n                deleteProviderLocked(provider);\n                removed = true;\n            }\n        }\n        return removed;\n    }\n\n    private boolean removeHostsAndProvidersForPackageLocked(String pkgName, int userId) {\n        boolean removed = removeProvidersForPackageLocked(pkgName, userId);\n\n        // Delete the hosts for this package too\n        // By now, we have removed any AppWidgets that were in any hosts here,\n        // so we don't need to worry about sending DISABLE broadcasts to them.\n        final int N = mHosts.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Host host = mHosts.get(i);\n            if (pkgName.equals(host.id.packageName)\n                    && host.getUserId() == userId) {\n                deleteHostLocked(host);\n                removed = true;\n            }\n        }\n\n        return removed;\n    }\n\n    private String getCanonicalPackageName(String packageName, String className, int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            try {\n                AppGlobals.getPackageManager().getReceiverInfo(new ComponentName(packageName,\n                        className), 0, userId);\n                return packageName;\n            } catch (RemoteException re) {\n                String[] packageNames = mContext.getPackageManager()\n                        .currentToCanonicalPackageNames(new String[]{packageName});\n                if (packageNames != null && packageNames.length > 0) {\n                    return packageNames[0];\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n        return null;\n    }\n\n    private void sendBroadcastAsUser(Intent intent, UserHandle userHandle) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            mContext.sendBroadcastAsUser(intent, userHandle);\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void bindService(Intent intent, ServiceConnection connection,\n            UserHandle userHandle) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.bindServiceAsUser(intent, connection,\n                    Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE,\n                    userHandle);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void unbindService(ServiceConnection connection) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.unbindService(connection);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public void onCrossProfileWidgetProvidersChanged(int userId, List<String> packages) {\n        final int parentId = mSecurityPolicy.getProfileParent(userId);\n        // We care only if the allowlisted package is in a profile of\n        // the group parent as only the parent can add widgets from the\n        // profile and not the other way around.\n        if (parentId != userId) {\n            synchronized (mLock) {\n                boolean providersChanged = false;\n\n                ArraySet<String> previousPackages = new ArraySet<String>();\n                final int providerCount = mProviders.size();\n                for (int i = 0; i < providerCount; ++i) {\n                    Provider provider = mProviders.get(i);\n                    if (provider.getUserId() == userId) {\n                        previousPackages.add(provider.id.componentName.getPackageName());\n                    }\n                }\n\n                final int packageCount = packages.size();\n                for (int i = 0; i < packageCount; i++) {\n                    String packageName = packages.get(i);\n                    previousPackages.remove(packageName);\n                    providersChanged |= updateProvidersForPackageLocked(packageName,\n                            userId, null);\n                }\n\n                // Remove widgets from hosts in parent user for packages not in the allowlist\n                final int removedCount = previousPackages.size();\n                for (int i = 0; i < removedCount; ++i) {\n                    removeWidgetsForPackageLocked(previousPackages.valueAt(i),\n                            userId, parentId);\n                }\n\n                if (providersChanged || removedCount > 0) {\n                    saveGroupStateAsync(userId);\n                    scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n                }\n            }\n        }\n    }\n\n    private boolean isProfileWithLockedParent(int userId) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            UserInfo userInfo = mUserManager.getUserInfo(userId);\n            if (userInfo != null && userInfo.isProfile()) {\n                UserInfo parentInfo = mUserManager.getProfileParent(userId);\n                if (parentInfo != null\n                        && !isUserRunningAndUnlocked(parentInfo.getUserHandle().getIdentifier())) {\n                    return true;\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n        return false;\n    }\n\n    private boolean isProfileWithUnlockedParent(int userId) {\n        UserInfo userInfo = mUserManager.getUserInfo(userId);\n        if (userInfo != null && userInfo.isProfile()) {\n            UserInfo parentInfo = mUserManager.getProfileParent(userId);\n            if (parentInfo != null\n                    && mUserManager.isUserUnlockingOrUnlocked(parentInfo.getUserHandle())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Note an app widget is tapped on. If a app widget is tapped, the underlying app is treated as\n     * foreground so the app can get while-in-use permission.\n     *\n     * @param callingPackage calling app's packageName.\n     * @param appWidgetId App widget id.\n     */\n    @Override\n    public void noteAppWidgetTapped(String callingPackage, int appWidgetId) {\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n        final int callingUid = Binder.getCallingUid();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            // The launcher must be at TOP.\n            final int procState = mActivityManagerInternal.getUidProcessState(callingUid);\n            if (procState > ActivityManager.PROCESS_STATE_TOP) {\n                return;\n            }\n            synchronized (mLock) {\n                final Widget widget = lookupWidgetLocked(appWidgetId, callingUid, callingPackage);\n                if (widget == null) {\n                    return;\n                }\n                final ProviderId providerId = widget.provider.id;\n                final String packageName = providerId.componentName.getPackageName();\n                if (packageName == null) {\n                    return;\n                }\n                final SparseArray<String> uid2PackageName = new SparseArray<String>();\n                uid2PackageName.put(providerId.uid, packageName);\n                mAppOpsManagerInternal.updateAppWidgetVisibility(uid2PackageName, true);\n                mUsageStatsManagerInternal.reportEvent(packageName,\n                        UserHandle.getUserId(providerId.uid), UsageEvents.Event.USER_INTERACTION);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    private final class CallbackHandler extends Handler {\n        public static final int MSG_NOTIFY_UPDATE_APP_WIDGET = 1;\n        public static final int MSG_NOTIFY_PROVIDER_CHANGED = 2;\n        public static final int MSG_NOTIFY_PROVIDERS_CHANGED = 3;\n        public static final int MSG_NOTIFY_VIEW_DATA_CHANGED = 4;\n        public static final int MSG_NOTIFY_APP_WIDGET_REMOVED = 5;\n\n        public CallbackHandler(Looper looper) {\n            super(looper, null, false);\n        }\n\n        @Override\n        public void handleMessage(Message message) {\n            switch (message.what) {\n                case MSG_NOTIFY_UPDATE_APP_WIDGET: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    RemoteViews views = (RemoteViews) args.arg3;\n                    long requestId = (Long) args.arg4;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n\n                    handleNotifyUpdateAppWidget(host, callbacks, appWidgetId, views, requestId);\n                } break;\n\n                case MSG_NOTIFY_PROVIDER_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    AppWidgetProviderInfo info = (AppWidgetProviderInfo)args.arg3;\n                    long requestId = (Long) args.arg4;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n\n                    handleNotifyProviderChanged(host, callbacks, appWidgetId, info, requestId);\n                } break;\n\n                case MSG_NOTIFY_APP_WIDGET_REMOVED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    long requestId = (Long) args.arg3;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n                    handleNotifyAppWidgetRemoved(host, callbacks, appWidgetId, requestId);\n                } break;\n\n                case MSG_NOTIFY_PROVIDERS_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    args.recycle();\n\n                    handleNotifyProvidersChanged(host, callbacks);\n                } break;\n\n                case MSG_NOTIFY_VIEW_DATA_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    long requestId = (Long) args.arg3;\n                    final int appWidgetId = args.argi1;\n                    final int viewId = args.argi2;\n                    args.recycle();\n\n                    handleNotifyAppWidgetViewDataChanged(host, callbacks, appWidgetId, viewId,\n                            requestId);\n                } break;\n            }\n        }\n    }\n\n    private final class SecurityPolicy {\n\n        public boolean isEnabledGroupProfile(int profileId) {\n            final int parentId = UserHandle.getCallingUserId();\n            return isParentOrProfile(parentId, profileId) && isProfileEnabled(profileId);\n        }\n\n        public int[] getEnabledGroupProfileIds(int userId) {\n            final int parentId = getGroupParent(userId);\n\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return mUserManager.getEnabledProfileIds(parentId);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n\n        public void enforceServiceExistsAndRequiresBindRemoteViewsPermission(\n                ComponentName componentName, int userId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                ServiceInfo serviceInfo = mPackageManager.getServiceInfo(componentName,\n                        PackageManager.GET_PERMISSIONS, userId);\n                if (serviceInfo == null) {\n                    throw new SecurityException(\"Service \" + componentName\n                            + \" not installed for user \" + userId);\n                }\n                if (!android.Manifest.permission.BIND_REMOTEVIEWS.equals(serviceInfo.permission)) {\n                    throw new SecurityException(\"Service \" + componentName\n                            + \" in user \" + userId + \"does not require \"\n                            + android.Manifest.permission.BIND_REMOTEVIEWS);\n                }\n            } catch (RemoteException re) {\n                // Local call - shouldn't happen.\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n\n        public void enforceModifyAppWidgetBindPermissions(String packageName) {\n            mContext.enforceCallingPermission(\n                    android.Manifest.permission.MODIFY_APPWIDGET_BIND_PERMISSIONS,\n                    \"hasBindAppWidgetPermission packageName=\" + packageName);\n        }\n\n        public boolean isCallerInstantAppLocked() {\n            final int callingUid =  Binder.getCallingUid();\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final String[] uidPackages = mPackageManager.getPackagesForUid(callingUid);\n                if (!ArrayUtils.isEmpty(uidPackages)) {\n                    return mPackageManager.isInstantApp(uidPackages[0],\n                            UserHandle.getUserId(callingUid));\n                }\n            } catch (RemoteException e) {\n                /* ignore - same process */\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return false;\n        }\n\n        public boolean isInstantAppLocked(String packageName, int userId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return mPackageManager.isInstantApp(packageName, userId);\n            } catch (RemoteException e) {\n                /* ignore - same process */\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return false;\n        }\n\n        public void enforceCallFromPackage(String packageName) {\n            mAppOpsManager.checkPackage(Binder.getCallingUid(), packageName);\n        }\n\n        public boolean hasCallerBindPermissionOrBindWhiteListedLocked(String packageName) {\n            try {\n                mContext.enforceCallingOrSelfPermission(\n                        android.Manifest.permission.BIND_APPWIDGET, null);\n            } catch (SecurityException se) {\n                if (!isCallerBindAppWidgetWhiteListedLocked(packageName)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private boolean isCallerBindAppWidgetWhiteListedLocked(String packageName) {\n            final int userId = UserHandle.getCallingUserId();\n            final int packageUid = getUidForPackage(packageName, userId);\n            if (packageUid < 0) {\n                throw new IllegalArgumentException(\"No package \" + packageName\n                        + \" for user \" + userId);\n            }\n            synchronized (mLock) {\n                ensureGroupStateLoadedLocked(userId);\n\n                Pair<Integer, String> packageId = Pair.create(userId, packageName);\n                if (mPackagesWithBindWidgetPermission.contains(packageId)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        public boolean canAccessAppWidget(Widget widget, int uid, String packageName) {\n            if (isHostInPackageForUid(widget.host, uid, packageName)) {\n                // Apps hosting the AppWidget have access to it.\n                return true;\n            }\n            if (isProviderInPackageForUid(widget.provider, uid, packageName)) {\n                // Apps providing the AppWidget have access to it.\n                return true;\n            }\n            if (isHostAccessingProvider(widget.host, widget.provider, uid, packageName)) {\n                // Apps hosting the AppWidget get to bind to a remote view service in the provider.\n                return true;\n            }\n            final int userId = UserHandle.getUserId(uid);\n            if ((widget.host.getUserId() == userId || (widget.provider != null\n                    && widget.provider.getUserId() == userId))\n                && mContext.checkCallingPermission(android.Manifest.permission.BIND_APPWIDGET)\n                    == PackageManager.PERMISSION_GRANTED) {\n                // Apps that run in the same user as either the host or the provider and\n                // have the bind widget permission have access to the widget.\n                return true;\n            }\n            return false;\n        }\n\n        private boolean isParentOrProfile(int parentId, int profileId) {\n            if (parentId == profileId) {\n                return true;\n            }\n            return getProfileParent(profileId) == parentId;\n        }\n\n        public boolean isProviderInCallerOrInProfileAndWhitelListed(String packageName,\n                int profileId) {\n            final int callerId = UserHandle.getCallingUserId();\n            if (profileId == callerId) {\n                return true;\n            }\n            final int parentId = getProfileParent(profileId);\n            if (parentId != callerId) {\n                return false;\n            }\n            return isProviderWhiteListed(packageName, profileId);\n        }\n\n        public boolean isProviderWhiteListed(String packageName, int profileId) {\n            // If the policy manager is not available on the device we deny it all.\n            if (mDevicePolicyManagerInternal == null) {\n                return false;\n            }\n\n            List<String> crossProfilePackages = mDevicePolicyManagerInternal\n                    .getCrossProfileWidgetProviders(profileId);\n\n            return crossProfilePackages.contains(packageName);\n        }\n\n        public int getProfileParent(int profileId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                UserInfo parent = mUserManager.getProfileParent(profileId);\n                if (parent != null) {\n                    return parent.getUserHandle().getIdentifier();\n                }\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return UNKNOWN_USER_ID;\n        }\n\n        public int getGroupParent(int profileId) {\n            final int parentId = mSecurityPolicy.getProfileParent(profileId);\n            return (parentId != UNKNOWN_USER_ID) ? parentId : profileId;\n        }\n\n        public boolean isHostInPackageForUid(Host host, int uid, String packageName) {\n            return host.id.uid == uid && host.id.packageName.equals(packageName);\n        }\n\n        public boolean isProviderInPackageForUid(Provider provider, int uid,\n                String packageName) {\n            // Packages providing the AppWidget have access to it.\n            return provider != null && provider.id.uid == uid\n                    && provider.id.componentName.getPackageName().equals(packageName);\n        }\n\n        public boolean isHostAccessingProvider(Host host, Provider provider, int uid,\n                String packageName) {\n            // The host creates a package context to bind to remote views service in the provider.\n            return host.id.uid == uid && provider != null\n                    && provider.id.componentName.getPackageName().equals(packageName);\n        }\n\n        private boolean isProfileEnabled(int profileId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                UserInfo userInfo = mUserManager.getUserInfo(profileId);\n                if (userInfo == null || !userInfo.isEnabled()) {\n                    return false;\n                }\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return true;\n        }\n    }\n\n    private static final class Provider {\n\n        ProviderId id;\n        AppWidgetProviderInfo info;\n        ArrayList<Widget> widgets = new ArrayList<>();\n        PendingIntent broadcast;\n        String infoTag;\n\n        boolean zombie; // if we're in safe mode, don't prune this just because nobody references it\n\n        boolean maskedByLockedProfile;\n        boolean maskedByQuietProfile;\n        boolean maskedBySuspendedPackage;\n\n        boolean mInfoParsed = false;\n\n        int tag = TAG_UNDEFINED; // for use while saving state (the index)\n\n        public int getUserId() {\n            return UserHandle.getUserId(id.uid);\n        }\n\n        public boolean isInPackageForUser(String packageName, int userId) {\n            return getUserId() == userId\n                    && id.componentName.getPackageName().equals(packageName);\n        }\n\n        // is there an instance of this provider hosted by the given app?\n        public boolean hostedByPackageForUser(String packageName, int userId) {\n            final int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = widgets.get(i);\n                if (packageName.equals(widget.host.id.packageName)\n                        && widget.host.getUserId() == userId) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @GuardedBy(\"mLock\")\n        public AppWidgetProviderInfo getInfoLocked(Context context) {\n            if (!mInfoParsed) {\n                // parse\n                if (!zombie) {\n                    AppWidgetProviderInfo newInfo = null;\n                    if (!TextUtils.isEmpty(infoTag)) {\n                        newInfo = parseAppWidgetProviderInfo(\n                                context, id, info.providerInfo, infoTag);\n                    }\n                    if (newInfo == null) {\n                        newInfo = parseAppWidgetProviderInfo(context, id, info.providerInfo,\n                                AppWidgetManager.META_DATA_APPWIDGET_PROVIDER);\n                    }\n                    if (newInfo != null) {\n                        info = newInfo;\n                    }\n                }\n                mInfoParsed = true;\n            }\n            return info;\n        }\n\n        /**\n         * Returns the last updated AppWidgetProviderInfo for this provider. This info may not\n         * be completely parsed and only contain placeHolder information like\n         * {@link AppWidgetProviderInfo#providerInfo}\n         */\n        @GuardedBy(\"mLock\")\n        public AppWidgetProviderInfo getPartialInfoLocked() {\n            return info;\n        }\n\n        @GuardedBy(\"mLock\")\n        public void setPartialInfoLocked(AppWidgetProviderInfo info) {\n            this.info = info;\n            mInfoParsed = false;\n        }\n\n        @GuardedBy(\"mLock\")\n        public void setInfoLocked(AppWidgetProviderInfo info) {\n            this.info = info;\n            mInfoParsed = true;\n        }\n\n        @Override\n        public String toString() {\n            return \"Provider{\" + id + (zombie ? \" Z\" : \"\") + '}';\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedByQuietProfileLocked(boolean masked) {\n            boolean oldState = maskedByQuietProfile;\n            maskedByQuietProfile = masked;\n            return masked != oldState;\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedByLockedProfileLocked(boolean masked) {\n            boolean oldState = maskedByLockedProfile;\n            maskedByLockedProfile = masked;\n            return masked != oldState;\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedBySuspendedPackageLocked(boolean masked) {\n            boolean oldState = maskedBySuspendedPackage;\n            maskedBySuspendedPackage = masked;\n            return masked != oldState;\n        }\n\n        public boolean isMaskedLocked() {\n            return maskedByQuietProfile || maskedByLockedProfile || maskedBySuspendedPackage;\n        }\n\n        public boolean shouldBePersisted() {\n            return !widgets.isEmpty() || !TextUtils.isEmpty(infoTag);\n        }\n    }\n\n    private static final class ProviderId {\n        final int uid;\n        final ComponentName componentName;\n\n        private ProviderId(int uid, ComponentName componentName) {\n            this.uid = uid;\n            this.componentName = componentName;\n        }\n\n        public UserHandle getProfile() {\n            return UserHandle.getUserHandleForUid(uid);\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            ProviderId other = (ProviderId) obj;\n            if (uid != other.uid)  {\n                return false;\n            }\n            if (componentName == null) {\n                if (other.componentName != null) {\n                    return false;\n                }\n            } else if (!componentName.equals(other.componentName)) {\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = uid;\n            result = 31 * result + ((componentName != null)\n                    ? componentName.hashCode() : 0);\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return \"ProviderId{user:\" + UserHandle.getUserId(uid) + \", app:\"\n                    + UserHandle.getAppId(uid) + \", cmp:\" + componentName + '}';\n        }\n    }\n\n    private static final class Host {\n        HostId id;\n        ArrayList<Widget> widgets = new ArrayList<>();\n        IAppWidgetHost callbacks;\n        boolean zombie; // if we're in safe mode, don't prune this just because nobody references it\n\n        int tag = TAG_UNDEFINED; // for use while saving state (the index)\n        // Sequence no for the last update successfully sent. This is updated whenever a\n        // widget update is successfully sent to the host callbacks. As all new/undelivered updates\n        // will have sequenceNo greater than this, all those updates will be sent when the host\n        // callbacks are attached again.\n        long lastWidgetUpdateSequenceNo;\n\n        public int getUserId() {\n            return UserHandle.getUserId(id.uid);\n        }\n\n        public boolean isInPackageForUser(String packageName, int userId) {\n            return getUserId() == userId && id.packageName.equals(packageName);\n        }\n\n        private boolean hostsPackageForUser(String pkg, int userId) {\n            final int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = widgets.get(i).provider;\n                if (provider != null && provider.getUserId() == userId\n                        && pkg.equals(provider.id.componentName.getPackageName())) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /**\n         * Adds all pending updates in {@param outUpdates} keys by the update time.\n         */\n        public void getPendingUpdatesForIdLocked(Context context, int appWidgetId,\n                LongSparseArray<PendingHostUpdate> outUpdates) {\n            long updateSequenceNo = lastWidgetUpdateSequenceNo;\n            int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = widgets.get(i);\n                if (widget.appWidgetId == appWidgetId) {\n                    for (int j = widget.updateSequenceNos.size() - 1; j >= 0; j--) {\n                        long requestId = widget.updateSequenceNos.valueAt(j);\n                        if (requestId <= updateSequenceNo) {\n                            continue;\n                        }\n                        int id = widget.updateSequenceNos.keyAt(j);\n                        final PendingHostUpdate update;\n                        switch (id) {\n                            case ID_PROVIDER_CHANGED:\n                                update = PendingHostUpdate.providerChanged(\n                                        appWidgetId, widget.provider.getInfoLocked(context));\n                                break;\n                            case ID_VIEWS_UPDATE:\n                                update = PendingHostUpdate.updateAppWidget(appWidgetId,\n                                        cloneIfLocalBinder(widget.getEffectiveViewsLocked()));\n                                break;\n                            default:\n                                update = PendingHostUpdate.viewDataChanged(appWidgetId, id);\n                        }\n                        outUpdates.put(requestId, update);\n                    }\n                    return;\n                }\n            }\n            outUpdates.put(lastWidgetUpdateSequenceNo,\n                    PendingHostUpdate.appWidgetRemoved(appWidgetId));\n        }\n\n        public SparseArray<String> getWidgetUids() {\n            final SparseArray<String> uids = new SparseArray<>();\n            for (int i = widgets.size() - 1; i >= 0; i--) {\n                final Widget widget = widgets.get(i);\n                final ProviderId providerId = widget.provider.id;\n                uids.put(providerId.uid, providerId.componentName.getPackageName());\n            }\n            return uids;\n        }\n\n        @Override\n        public String toString() {\n            return \"Host{\" + id + (zombie ? \" Z\" : \"\") + '}';\n        }\n    }\n\n    private static final class HostId {\n        final int uid;\n        final int hostId;\n        final String packageName;\n\n        public HostId(int uid, int hostId, String packageName) {\n            this.uid = uid;\n            this.hostId = hostId;\n            this.packageName = packageName;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            HostId other = (HostId) obj;\n            if (uid != other.uid)  {\n                return false;\n            }\n            if (hostId != other.hostId) {\n                return false;\n            }\n            if (packageName == null) {\n                if (other.packageName != null) {\n                    return false;\n                }\n            } else if (!packageName.equals(other.packageName)) {\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = uid;\n            result = 31 * result + hostId;\n            result = 31 * result + ((packageName != null)\n                    ? packageName.hashCode() : 0);\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return \"HostId{user:\" + UserHandle.getUserId(uid) + \", app:\"\n                    + UserHandle.getAppId(uid) + \", hostId:\" + hostId\n                    + \", pkg:\" + packageName + '}';\n        }\n    }\n\n    // These can be any constants that would not collide with a resource id.\n    private static final int ID_VIEWS_UPDATE = 0;\n    private static final int ID_PROVIDER_CHANGED = 1;\n\n    private static final class Widget {\n        int appWidgetId;\n        int restoredId;  // tracking & remapping any restored state\n        Provider provider;\n        RemoteViews views;\n        RemoteViews maskedViews;\n        Bundle options;\n        Host host;\n        // Map of request type to updateSequenceNo.\n        SparseLongArray updateSequenceNos = new SparseLongArray(2);\n\n        @Override\n        public String toString() {\n            return \"AppWidgetId{\" + appWidgetId + ':' + host + ':' + provider + '}';\n        }\n\n        private boolean replaceWithMaskedViewsLocked(RemoteViews views) {\n            maskedViews = views;\n            return true;\n        }\n\n        private boolean clearMaskedViewsLocked() {\n            if (maskedViews != null) {\n                maskedViews = null;\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        public RemoteViews getEffectiveViewsLocked() {\n            return maskedViews != null ? maskedViews : views;\n        }\n    }\n\n    private class LoadedWidgetState {\n        final Widget widget;\n        final int hostTag;\n        final int providerTag;\n\n        public LoadedWidgetState(Widget widget, int hostTag, int providerTag) {\n            this.widget = widget;\n            this.hostTag = hostTag;\n            this.providerTag = providerTag;\n        }\n    }\n\n    private final class SaveStateRunnable implements Runnable {\n        final int mUserId;\n\n        public SaveStateRunnable(int userId) {\n            mUserId = userId;\n        }\n\n        @Override\n        public void run() {\n            synchronized (mLock) {\n                // No need to enforce unlocked state when there is no caller. User can be in the\n                // stopping state or removed by the time the message is processed\n                ensureGroupStateLoadedLocked(mUserId, false /* enforceUserUnlockingOrUnlocked */ );\n                saveStateLocked(mUserId);\n            }\n        }\n    }\n\n    /**\n     * This class encapsulates the backup and restore logic for a user group state.\n     */\n    private final class BackupRestoreController {\n        private static final String TAG = \"BackupRestoreController\";\n\n        private static final boolean DEBUG = true;\n\n        // Version of backed-up widget state.\n        private static final int WIDGET_STATE_VERSION = 2;\n\n        // We need to make sure to wipe the pre-restore widget state only once for\n        // a given package.  Keep track of what we've done so far here; the list is\n        // cleared at the start of every system restore pass, but preserved through\n        // any install-time restore operations.\n        private final HashSet<String> mPrunedApps = new HashSet<>();\n\n        private final HashMap<Provider, ArrayList<RestoreUpdateRecord>> mUpdatesByProvider =\n                new HashMap<>();\n        private final HashMap<Host, ArrayList<RestoreUpdateRecord>> mUpdatesByHost =\n                new HashMap<>();\n\n        @GuardedBy(\"mLock\")\n        private boolean mHasSystemRestoreFinished;\n\n        public List<String> getWidgetParticipants(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Getting widget participants for user: \" + userId);\n            }\n\n            HashSet<String> packages = new HashSet<>();\n            synchronized (mLock) {\n                final int N = mWidgets.size();\n                for (int i = 0; i < N; i++) {\n                    Widget widget = mWidgets.get(i);\n\n                    // Skip cross-user widgets.\n                    if (!isProviderAndHostInUser(widget, userId)) {\n                        continue;\n                    }\n\n                    packages.add(widget.host.id.packageName);\n                    Provider provider = widget.provider;\n                    if (provider != null) {\n                        packages.add(provider.id.componentName.getPackageName());\n                    }\n                }\n            }\n            return new ArrayList<>(packages);\n        }\n\n        public byte[] getWidgetState(String backedupPackage, int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Getting widget state for user: \" + userId);\n            }\n\n            ByteArrayOutputStream stream = new ByteArrayOutputStream();\n            synchronized (mLock) {\n                // Preflight: if this app neither hosts nor provides any live widgets\n                // we have no work to do.\n                if (!packageNeedsWidgetBackupLocked(backedupPackage, userId)) {\n                    return null;\n                }\n\n                try {\n                    TypedXmlSerializer out = Xml.newFastSerializer();\n                    out.setOutput(stream, StandardCharsets.UTF_8.name());\n                    out.startDocument(null, true);\n                    out.startTag(null, \"ws\");      // widget state\n                    out.attributeInt(null, \"version\", WIDGET_STATE_VERSION);\n                    out.attribute(null, \"pkg\", backedupPackage);\n\n                    // Remember all the providers that are currently hosted or published\n                    // by this package: that is, all of the entities related to this app\n                    // which will need to be told about id remapping.\n                    int index = 0;\n                    int N = mProviders.size();\n                    for (int i = 0; i < N; i++) {\n                        Provider provider = mProviders.get(i);\n\n                        if (provider.shouldBePersisted()\n                                && (provider.isInPackageForUser(backedupPackage, userId)\n                                || provider.hostedByPackageForUser(backedupPackage, userId))) {\n                            provider.tag = index;\n                            serializeProvider(out, provider);\n                            index++;\n                        }\n                    }\n\n                    N = mHosts.size();\n                    index = 0;\n                    for (int i = 0; i < N; i++) {\n                        Host host = mHosts.get(i);\n\n                        if (!host.widgets.isEmpty()\n                                && (host.isInPackageForUser(backedupPackage, userId)\n                                || host.hostsPackageForUser(backedupPackage, userId))) {\n                            host.tag = index;\n                            serializeHost(out, host);\n                            index++;\n                        }\n                    }\n\n                    // All widget instances involving this package,\n                    // either as host or as provider\n                    N = mWidgets.size();\n                    for (int i = 0; i < N; i++) {\n                        Widget widget = mWidgets.get(i);\n\n                        Provider provider = widget.provider;\n                        if (widget.host.isInPackageForUser(backedupPackage, userId)\n                                || (provider != null\n                                &&  provider.isInPackageForUser(backedupPackage, userId))) {\n                            serializeAppWidget(out, widget, false);\n                        }\n                    }\n\n                    out.endTag(null, \"ws\");\n                    out.endDocument();\n                } catch (IOException e) {\n                    Slog.w(TAG, \"Unable to save widget state for \" + backedupPackage);\n                    return null;\n                }\n            }\n\n            return stream.toByteArray();\n        }\n\n        public void systemRestoreStarting(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"System restore starting for user: \" + userId);\n            }\n\n            synchronized (mLock) {\n                mHasSystemRestoreFinished = false;\n                // We're starting a new \"system\" restore operation, so any widget restore\n                // state that we see from here on is intended to replace the current\n                // widget configuration of any/all of the affected apps.\n                mPrunedApps.clear();\n                mUpdatesByProvider.clear();\n                mUpdatesByHost.clear();\n            }\n        }\n\n        public void restoreWidgetState(String packageName, byte[] restoredState, int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Restoring widget state for user:\" + userId\n                        + \" package: \" + packageName);\n            }\n\n            ByteArrayInputStream stream = new ByteArrayInputStream(restoredState);\n            try {\n                // Providers mentioned in the widget dataset by ordinal\n                ArrayList<Provider> restoredProviders = new ArrayList<>();\n\n                // Hosts mentioned in the widget dataset by ordinal\n                ArrayList<Host> restoredHosts = new ArrayList<>();\n\n                TypedXmlPullParser parser = Xml.newFastPullParser();\n                parser.setInput(stream, StandardCharsets.UTF_8.name());\n\n                synchronized (mLock) {\n                    int type;\n                    do {\n                        type = parser.next();\n                        if (type == XmlPullParser.START_TAG) {\n                            final String tag = parser.getName();\n                            if (\"ws\".equals(tag)) {\n                                final int versionNumber = parser.getAttributeInt(null, \"version\");\n                                if (versionNumber > WIDGET_STATE_VERSION) {\n                                    Slog.w(TAG, \"Unable to process state version \" + versionNumber);\n                                    return;\n                                }\n\n                                // TODO: fix up w.r.t. canonical vs current package names\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n                                if (!packageName.equals(pkg)) {\n                                    Slog.w(TAG, \"Package mismatch in ws\");\n                                    return;\n                                }\n                            } else if (\"p\".equals(tag)) {\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n                                String cl = parser.getAttributeValue(null, \"cl\");\n\n                                // hostedProviders index will match 'p' attribute in widget's\n                                // entry in the xml file being restored\n                                // If there's no live entry for this provider, add an inactive one\n                                // so that widget IDs referring to them can be properly allocated\n\n                                // Backup and resotre only for the parent profile.\n                                ComponentName componentName = new ComponentName(pkg, cl);\n\n                                Provider p = findProviderLocked(componentName, userId);\n                                if (p == null) {\n                                    AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n                                    info.provider = componentName;\n\n                                    p = new Provider();\n                                    p.id = new ProviderId(UNKNOWN_UID, componentName);\n                                    p.setPartialInfoLocked(info);\n                                    p.zombie = true;\n                                    mProviders.add(p);\n                                }\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   provider \" + p.id);\n                                }\n                                restoredProviders.add(p);\n                            } else if (\"h\".equals(tag)) {\n                                // The host app may not yet exist on the device.  If it's here we\n                                // just use the existing Host entry, otherwise we create a\n                                // placeholder whose uid will be fixed up at PACKAGE_ADDED time.\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n\n                                final int uid = getUidForPackage(pkg, userId);\n                                final int hostId = parser.getAttributeIntHex(null, \"id\");\n\n                                HostId id = new HostId(uid, hostId, pkg);\n                                Host h = lookupOrAddHostLocked(id);\n                                restoredHosts.add(h);\n\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   host[\" + restoredHosts.size()\n                                            + \"]: {\" + h.id + \"}\");\n                                }\n                            } else if (\"g\".equals(tag)) {\n                                int restoredId = parser.getAttributeIntHex(null, \"id\");\n                                int hostIndex = parser.getAttributeIntHex(null, \"h\");\n                                Host host = restoredHosts.get(hostIndex);\n                                Provider p = null;\n                                int which = parser.getAttributeIntHex(null, \"p\", -1);\n                                if (which != -1) {\n                                    // could have been null if the app had allocated an id\n                                    // but not yet established a binding under that id\n                                    p = restoredProviders.get(which);\n                                }\n\n                                // We'll be restoring widget state for both the host and\n                                // provider sides of this widget ID, so make sure we are\n                                // beginning from a clean slate on both fronts.\n                                pruneWidgetStateLocked(host.id.packageName, userId);\n                                if (p != null) {\n                                    pruneWidgetStateLocked(p.id.componentName.getPackageName(),\n                                            userId);\n                                }\n\n                                // Have we heard about this ancestral widget instance before?\n                                Widget id = findRestoredWidgetLocked(restoredId, host, p);\n                                if (id == null) {\n                                    id = new Widget();\n                                    id.appWidgetId = incrementAndGetAppWidgetIdLocked(userId);\n                                    id.restoredId = restoredId;\n                                    id.options = parseWidgetIdOptions(parser);\n                                    id.host = host;\n                                    id.host.widgets.add(id);\n                                    id.provider = p;\n                                    if (id.provider != null) {\n                                        id.provider.widgets.add(id);\n                                    }\n                                    if (DEBUG) {\n                                        Slog.i(TAG, \"New restored id \" + restoredId\n                                                + \" now \" + id);\n                                    }\n                                    addWidgetLocked(id);\n                                }\n                                if (id.provider != null\n                                        && id.provider.getPartialInfoLocked() != null) {\n                                    stashProviderRestoreUpdateLocked(id.provider,\n                                            restoredId, id.appWidgetId);\n                                } else {\n                                    Slog.w(TAG, \"Missing provider for restored widget \" + id);\n                                }\n                                stashHostRestoreUpdateLocked(id.host, restoredId, id.appWidgetId);\n\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   instance: \" + restoredId\n                                            + \" -> \" + id.appWidgetId\n                                            + \" :: p=\" + id.provider);\n                                }\n                            }\n                        }\n                    } while (type != XmlPullParser.END_DOCUMENT);\n\n                    // We've updated our own bookkeeping.  We'll need to notify the hosts and\n                    // providers about the changes, but we can't do that yet because the restore\n                    // target is not necessarily fully live at this moment.  Set aside the\n                    // information for now; the backup manager will call us once more at the\n                    // end of the process when all of the targets are in a known state, and we\n                    // will update at that point.\n                }\n            } catch (XmlPullParserException | IOException e) {\n                Slog.w(TAG, \"Unable to restore widget state for \" + packageName);\n            } finally {\n                saveGroupStateAsync(userId);\n            }\n        }\n\n        // Called once following the conclusion of a system restore operation.  This is when we\n        // send out updates to apps involved in widget-state restore telling them about\n        // the new widget ID space.  Apps that are not yet installed will be notifed when they are.\n        public void systemRestoreFinished(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"systemRestoreFinished for \" + userId);\n            }\n            synchronized (mLock) {\n                mHasSystemRestoreFinished = true;\n                maybeSendWidgetRestoreBroadcastsLocked(userId);\n            }\n        }\n\n        // Called when widget components (hosts or providers) are added or changed.  If system\n        // restore has completed, we use this opportunity to tell the apps to update to the new\n        // widget ID space.  If system restore is still in progress, we delay the updates until\n        // the end, to allow all participants to restore their state before updating widget IDs.\n        public void widgetComponentsChanged(int userId) {\n            synchronized (mLock) {\n                if (mHasSystemRestoreFinished) {\n                    maybeSendWidgetRestoreBroadcastsLocked(userId);\n                }\n            }\n        }\n\n        // Called following the conclusion of a restore operation and when widget components\n        // are added or changed.  This is when we send out updates to apps involved in widget-state\n        // restore telling them about the new widget ID space.\n        @GuardedBy(\"mLock\")\n        private void maybeSendWidgetRestoreBroadcastsLocked(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"maybeSendWidgetRestoreBroadcasts for \" + userId);\n            }\n\n            final UserHandle userHandle = new UserHandle(userId);\n            // Build the providers' broadcasts and send them off\n            Set<Map.Entry<Provider, ArrayList<RestoreUpdateRecord>>> providerEntries\n                    = mUpdatesByProvider.entrySet();\n            for (Map.Entry<Provider, ArrayList<RestoreUpdateRecord>> e : providerEntries) {\n                // For each provider there's a list of affected IDs\n                Provider provider = e.getKey();\n                if (provider.zombie) {\n                    // Provider not installed, we can't send them broadcasts yet.\n                    // We'll be called again when the provider is installed.\n                    continue;\n                }\n                ArrayList<RestoreUpdateRecord> updates = e.getValue();\n                final int pending = countPendingUpdates(updates);\n                if (DEBUG) {\n                    Slog.i(TAG, \"Provider \" + provider + \" pending: \" + pending);\n                }\n                if (pending > 0) {\n                    int[] oldIds = new int[pending];\n                    int[] newIds = new int[pending];\n                    final int N = updates.size();\n                    int nextPending = 0;\n                    for (int i = 0; i < N; i++) {\n                        RestoreUpdateRecord r = updates.get(i);\n                        if (!r.notified) {\n                            r.notified = true;\n                            oldIds[nextPending] = r.oldId;\n                            newIds[nextPending] = r.newId;\n                            nextPending++;\n                            if (DEBUG) {\n                                Slog.i(TAG, \"   \" + r.oldId + \" => \" + r.newId);\n                            }\n                        }\n                    }\n                    sendWidgetRestoreBroadcastLocked(\n                            AppWidgetManager.ACTION_APPWIDGET_RESTORED,\n                            provider, null, oldIds, newIds, userHandle);\n                }\n            }\n\n            // same thing per host\n            Set<Map.Entry<Host, ArrayList<RestoreUpdateRecord>>> hostEntries\n                    = mUpdatesByHost.entrySet();\n            for (Map.Entry<Host, ArrayList<RestoreUpdateRecord>> e : hostEntries) {\n                Host host = e.getKey();\n                if (host.id.uid != UNKNOWN_UID) {\n                    ArrayList<RestoreUpdateRecord> updates = e.getValue();\n                    final int pending = countPendingUpdates(updates);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Host \" + host + \" pending: \" + pending);\n                    }\n                    if (pending > 0) {\n                        int[] oldIds = new int[pending];\n                        int[] newIds = new int[pending];\n                        final int N = updates.size();\n                        int nextPending = 0;\n                        for (int i = 0; i < N; i++) {\n                            RestoreUpdateRecord r = updates.get(i);\n                            if (!r.notified) {\n                                r.notified = true;\n                                oldIds[nextPending] = r.oldId;\n                                newIds[nextPending] = r.newId;\n                                nextPending++;\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   \" + r.oldId + \" => \" + r.newId);\n                                }\n                            }\n                        }\n                        sendWidgetRestoreBroadcastLocked(\n                                AppWidgetManager.ACTION_APPWIDGET_HOST_RESTORED,\n                                null, host, oldIds, newIds, userHandle);\n                    }\n                }\n            }\n        }\n\n        private Provider findProviderLocked(ComponentName componentName, int userId) {\n            final int providerCount = mProviders.size();\n            for (int i = 0; i < providerCount; i++) {\n                Provider provider = mProviders.get(i);\n                if (provider.getUserId() == userId\n                        && provider.id.componentName.equals(componentName)) {\n                    return provider;\n                }\n            }\n            return null;\n        }\n\n        private Widget findRestoredWidgetLocked(int restoredId, Host host, Provider p) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Find restored widget: id=\" + restoredId\n                        + \" host=\" + host + \" provider=\" + p);\n            }\n\n            if (p == null || host == null) {\n                return null;\n            }\n\n            final int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n                if (widget.restoredId == restoredId\n                        && widget.host.id.equals(host.id)\n                        && widget.provider.id.equals(p.id)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"   Found at \" + i + \" : \" + widget);\n                    }\n                    return widget;\n                }\n            }\n            return null;\n        }\n\n        private boolean packageNeedsWidgetBackupLocked(String packageName, int userId) {\n            int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n\n                // Skip cross-user widgets.\n                if (!isProviderAndHostInUser(widget, userId)) {\n                    continue;\n                }\n\n                if (widget.host.isInPackageForUser(packageName, userId)) {\n                    // this package is hosting widgets, so it knows widget IDs.\n                    return true;\n                }\n\n                Provider provider = widget.provider;\n                if (provider != null && provider.isInPackageForUser(packageName, userId)) {\n                    // someone is hosting this app's widgets, so it knows widget IDs.\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private void stashProviderRestoreUpdateLocked(Provider provider, int oldId, int newId) {\n            ArrayList<RestoreUpdateRecord> r = mUpdatesByProvider.get(provider);\n            if (r == null) {\n                r = new ArrayList<>();\n                mUpdatesByProvider.put(provider, r);\n            } else {\n                // don't duplicate\n                if (alreadyStashed(r, oldId, newId)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"ID remap \" + oldId + \" -> \" + newId\n                                + \" already stashed for \" + provider);\n                    }\n                    return;\n                }\n            }\n            r.add(new RestoreUpdateRecord(oldId, newId));\n        }\n\n        private boolean alreadyStashed(ArrayList<RestoreUpdateRecord> stash,\n                final int oldId, final int newId) {\n            final int N = stash.size();\n            for (int i = 0; i < N; i++) {\n                RestoreUpdateRecord r = stash.get(i);\n                if (r.oldId == oldId && r.newId == newId) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private void stashHostRestoreUpdateLocked(Host host, int oldId, int newId) {\n            ArrayList<RestoreUpdateRecord> r = mUpdatesByHost.get(host);\n            if (r == null) {\n                r = new ArrayList<>();\n                mUpdatesByHost.put(host, r);\n            } else {\n                if (alreadyStashed(r, oldId, newId)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"ID remap \" + oldId + \" -> \" + newId\n                                + \" already stashed for \" + host);\n                    }\n                    return;\n                }\n            }\n            r.add(new RestoreUpdateRecord(oldId, newId));\n        }\n\n        private void sendWidgetRestoreBroadcastLocked(String action, Provider provider,\n                Host host, int[] oldIds, int[] newIds, UserHandle userHandle) {\n            Intent intent = new Intent(action);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OLD_IDS, oldIds);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, newIds);\n            if (provider != null) {\n                intent.setComponent(provider.id.componentName);\n                sendBroadcastAsUser(intent, userHandle);\n            }\n            if (host != null) {\n                intent.setComponent(null);\n                intent.setPackage(host.id.packageName);\n                intent.putExtra(AppWidgetManager.EXTRA_HOST_ID, host.id.hostId);\n                sendBroadcastAsUser(intent, userHandle);\n            }\n        }\n\n        // We're restoring widget state for 'pkg', so we start by wiping (a) all widget\n        // instances that are hosted by that app, and (b) all instances in other hosts\n        // for which 'pkg' is the provider.  We assume that we'll be restoring all of\n        // these hosts & providers, so will be reconstructing a correct live state.\n        private void pruneWidgetStateLocked(String pkg, int userId) {\n            if (!mPrunedApps.contains(pkg)) {\n                if (DEBUG) {\n                    Slog.i(TAG, \"pruning widget state for restoring package \" + pkg);\n                }\n                for (int i = mWidgets.size() - 1; i >= 0; i--) {\n                    Widget widget = mWidgets.get(i);\n\n                    Host host = widget.host;\n                    Provider provider = widget.provider;\n\n                    if (host.hostsPackageForUser(pkg, userId)\n                            || (provider != null && provider.isInPackageForUser(pkg, userId))) {\n                        // 'pkg' is either the host or the provider for this instances,\n                        // so we tear it down in anticipation of it (possibly) being\n                        // reconstructed due to the restore\n                        host.widgets.remove(widget);\n                        provider.widgets.remove(widget);\n                        // Check if we need to destroy any services (if no other app widgets are\n                        // referencing the same service)\n                        decrementAppWidgetServiceRefCount(widget);\n                        removeWidgetLocked(widget);\n                    }\n                }\n                mPrunedApps.add(pkg);\n            } else {\n                if (DEBUG) {\n                    Slog.i(TAG, \"already pruned \" + pkg + \", continuing normally\");\n                }\n            }\n        }\n\n        private boolean isProviderAndHostInUser(Widget widget, int userId) {\n            // Backup only widgets hosted or provided by the owner profile.\n            return widget.host.getUserId() == userId && (widget.provider == null\n                    || widget.provider.getUserId() == userId);\n        }\n\n        private int countPendingUpdates(ArrayList<RestoreUpdateRecord> updates) {\n            int pending = 0;\n            final int N = updates.size();\n            for (int i = 0; i < N; i++) {\n                RestoreUpdateRecord r = updates.get(i);\n                if (!r.notified) {\n                    pending++;\n                }\n            }\n            return pending;\n        }\n\n        // Accumulate a list of updates that affect the given provider for a final\n        // coalesced notification broadcast once restore is over.\n        private class RestoreUpdateRecord {\n            public int oldId;\n            public int newId;\n            public boolean notified;\n\n            public RestoreUpdateRecord(int theOldId, int theNewId) {\n                oldId = theOldId;\n                newId = theNewId;\n                notified = false;\n            }\n        }\n    }\n\n    private class AppWidgetManagerLocal extends AppWidgetManagerInternal {\n        @Override\n        public ArraySet<String> getHostedWidgetPackages(int uid) {\n            synchronized (mLock) {\n                ArraySet<String> widgetPackages = null;\n                final int widgetCount = mWidgets.size();\n                for (int i = 0; i < widgetCount; i++) {\n                    final Widget widget = mWidgets.get(i);\n                    if  (widget.host.id.uid == uid && widget.provider != null) {\n                        if (widgetPackages == null) {\n                            widgetPackages = new ArraySet<>();\n                        }\n                        widgetPackages.add(widget.provider.id.componentName.getPackageName());\n                    }\n                }\n                return widgetPackages;\n            }\n        }\n\n        @Override\n        public void unlockUser(int userId) {\n            handleUserUnlocked(userId);\n        }\n\n        @Override\n        public void applyResourceOverlaysToWidgets(Set<String> packageNames, int userId,\n                boolean updateFrameworkRes) {\n            synchronized (mLock) {\n                applyResourceOverlaysToWidgetsLocked(new HashSet<>(packageNames), userId,\n                        updateFrameworkRes);\n            }\n        }\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 38238,
                                        "general": {
                                            "word_based": 16459,
                                            "char_based": 50947
                                        },
                                        "gemini": 45851
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "ae39a3f6538e5a5a73aea4daf8b552539247227f",
                            "repo_path": "android_repos/base",
                            "result": "failure",
                            "downstream_patch_content": "commit ae39a3f6538e5a5a73aea4daf8b552539247227f\nAuthor: Pinyao Ting <pinyaoting@google.com>\nDate:   Tue Aug 20 21:17:13 2024 +0000\n\n    Enforce hard limits on hosts per package and widgets per host.\n    \n    Bug: 353240784\n    Merged-In: I60ee7faf57ed719f93cafad212fef24964dec99f\n    Change-Id: I60ee7faf57ed719f93cafad212fef24964dec99f\n    Test: manually verified with PoC app that at most 20 hosts can exists\n    Flag: EXEMPT CVE\n\ndiff --git a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nindex f5063ac4a023..356613ab3377 100644\n--- a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n+++ b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n@@ -170,6 +170,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // used to verify which request has successfully been received by the host.\n     private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n         @Override\n         public void onReceive(Context context, Intent intent) {\n@@ -1698,7 +1707,7 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (host != null) {\n             return host;\n         }\n-\n+        ensureHostCountBeforeAddLocked(id);\n         host = new Host();\n         host.id = id;\n         mHosts.add(host);\n@@ -1706,6 +1715,24 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         return host;\n     }\n \n+    /**\n+     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n+     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n+     * removes the oldest host.\n+     */\n+    private void ensureHostCountBeforeAddLocked(HostId hostId) {\n+        final List<Host> hosts = new ArrayList<>();\n+        for (Host host : mHosts) {\n+            if (host.id.uid == hostId.uid\n+                    && host.id.packageName.equals(hostId.packageName)) {\n+                hosts.add(host);\n+            }\n+        }\n+        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n+            deleteHostLocked(hosts.remove(0));\n+        }\n+    }\n+\n     private void deleteHostLocked(Host host) {\n         final int N = host.widgets.size();\n         for (int i = N - 1; i >= 0; i--) {\n@@ -2833,11 +2860,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n      * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n      */\n     void addWidgetLocked(Widget widget) {\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.\n",
                            "downstream_patch_tokens": {
                                "openai": 1088,
                                "general": {
                                    "word_based": 485,
                                    "char_based": 1099
                                },
                                "gemini": 1336
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java",
                                    "total_hunks": 4,
                                    "failed_hunks": [
                                        1,
                                        4
                                    ],
                                    "inline_merge_conflicts": [],
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    },
                                    "rej_file_content": "```diff\n--- services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n+++ services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n@@ -217,6 +217,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // See {@link Provider#pendingDeletedWidgetIds}.\n     private static final String PENDING_DELETED_IDS_ATTR = \"pending_deleted_ids\";\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     // Handles user and package related broadcasts.\n     // See {@link #registerBroadcastReceiver}\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n@@ -3591,11 +3618,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (DEBUG) {\n             Slog.i(TAG, \"addWidgetLocked() \" + widget);\n         }\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(@NonNull final Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.\n```",
                                    "rej_file_tokens": {
                                        "openai": 555,
                                        "general": {
                                            "word_based": 254,
                                            "char_based": 607
                                        },
                                        "gemini": 667
                                    },
                                    "patch_apply_output": "patching file services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nHunk #1 FAILED at 217.\nHunk #2 succeeded at 1698 (offset -577 lines).\nHunk #3 succeeded at 1706 with fuzz 2 (offset -577 lines).\nHunk #4 FAILED at 3591.\n2 out of 4 hunks FAILED -- saving rejects to file services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java.rej",
                                    "inline_merge_output": "patching file services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nHunk #1 merged at 229-237.\nHunk #2 already applied at 2296.\nHunk #3 merged at 2322-2339.\nHunk #4 already applied at 3630, merged at 3636-3655.",
                                    "upstream_file_tokens": {
                                        "openai": 50416,
                                        "general": {
                                            "word_based": 21550,
                                            "char_based": 66890
                                        },
                                        "gemini": 60115
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.appwidget;\n\nimport static android.content.Context.KEYGUARD_SERVICE;\nimport static android.content.Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;\nimport static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\nimport static android.content.res.Resources.ID_NULL;\n\nimport static com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME;\n\nimport android.annotation.UserIdInt;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.AlarmManager;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.AppOpsManagerInternal;\nimport android.app.IApplicationThread;\nimport android.app.IServiceConnection;\nimport android.app.KeyguardManager;\nimport android.app.PendingIntent;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.app.admin.DevicePolicyManagerInternal.OnCrossProfileWidgetProvidersChangeListener;\nimport android.app.usage.UsageEvents;\nimport android.app.usage.UsageStatsManagerInternal;\nimport android.appwidget.AppWidgetManager;\nimport android.appwidget.AppWidgetManagerInternal;\nimport android.appwidget.AppWidgetProviderInfo;\nimport android.appwidget.PendingHostUpdate;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.Intent.FilterComparison;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.ServiceConnection;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.LauncherApps;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.ServiceInfo;\nimport android.content.pm.ShortcutServiceInternal;\nimport android.content.pm.SuspendDialogInfo;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.content.res.TypedArray;\nimport android.content.res.XmlResourceParser;\nimport android.graphics.Point;\nimport android.graphics.drawable.Icon;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.service.appwidget.AppWidgetServiceDumpProto;\nimport android.service.appwidget.WidgetProto;\nimport android.text.TextUtils;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.AttributeSet;\nimport android.util.IntArray;\nimport android.util.LongSparseArray;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\nimport android.util.SparseIntArray;\nimport android.util.SparseLongArray;\nimport android.util.TypedValue;\nimport android.util.TypedXmlPullParser;\nimport android.util.TypedXmlSerializer;\nimport android.util.Xml;\nimport android.util.proto.ProtoOutputStream;\nimport android.view.Display;\nimport android.view.View;\nimport android.widget.RemoteViews;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.app.SuspendedAppActivity;\nimport com.android.internal.app.UnlaunchableAppActivity;\nimport com.android.internal.appwidget.IAppWidgetHost;\nimport com.android.internal.appwidget.IAppWidgetService;\nimport com.android.internal.os.BackgroundThread;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.widget.IRemoteViewsFactory;\nimport com.android.server.LocalServices;\nimport com.android.server.WidgetBackupProvider;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicLong;\n\nclass AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBackupProvider,\n        OnCrossProfileWidgetProvidersChangeListener {\n    private static final String TAG = \"AppWidgetServiceImpl\";\n\n    private static boolean DEBUG = false;\n\n    private static final String OLD_KEYGUARD_HOST_PACKAGE = \"android\";\n    private static final String NEW_KEYGUARD_HOST_PACKAGE = \"com.android.keyguard\";\n    private static final int KEYGUARD_HOST_ID = 0x4b455947;\n\n    private static final String STATE_FILENAME = \"appwidgets.xml\";\n\n    private static final int MIN_UPDATE_PERIOD = DEBUG ? 0 : 30 * 60 * 1000; // 30 minutes\n\n    private static final int TAG_UNDEFINED = -1;\n\n    private static final int UNKNOWN_UID = -1;\n\n    private static final int UNKNOWN_USER_ID = -10;\n\n    // Bump if the stored widgets need to be upgraded.\n    private static final int CURRENT_VERSION = 1;\n\n    // Every widget update request is associated which an increasing sequence number. This is\n    // used to verify which request has successfully been received by the host.\n    private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n\n    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            final String action = intent.getAction();\n            final int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Received broadcast: \" + action + \" on user \" + userId);\n            }\n\n            switch (action) {\n                case Intent.ACTION_MANAGED_PROFILE_AVAILABLE:\n                case Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE:\n                    synchronized (mLock) {\n                        reloadWidgetsMaskedState(userId);\n                    }\n                    break;\n                case Intent.ACTION_PACKAGES_SUSPENDED:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    updateWidgetPackageSuspensionMaskedState(intent, true, getSendingUserId());\n                    break;\n                case Intent.ACTION_PACKAGES_UNSUSPENDED:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    updateWidgetPackageSuspensionMaskedState(intent, false, getSendingUserId());\n                    break;\n                default:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    break;\n            }\n        }\n    };\n\n    // Manages persistent references to RemoteViewsServices from different App Widgets.\n    private final HashMap<Pair<Integer, FilterComparison>, HashSet<Integer>>\n            mRemoteViewsServicesAppWidgets = new HashMap<>();\n\n    private final Object mLock = new Object();\n\n    private final ArrayList<Widget> mWidgets = new ArrayList<>();\n    private final ArrayList<Host> mHosts = new ArrayList<>();\n    private final ArrayList<Provider> mProviders = new ArrayList<>();\n\n    private final ArraySet<Pair<Integer, String>> mPackagesWithBindWidgetPermission =\n            new ArraySet<>();\n\n    private final SparseBooleanArray mLoadedUserIds = new SparseBooleanArray();\n\n    private final Object mWidgetPackagesLock = new Object();\n    private final SparseArray<ArraySet<String>> mWidgetPackages = new SparseArray<>();\n\n    private BackupRestoreController mBackupRestoreController;\n\n    private final Context mContext;\n\n    private IPackageManager mPackageManager;\n    private AlarmManager mAlarmManager;\n    private UserManager mUserManager;\n    private AppOpsManager mAppOpsManager;\n    private KeyguardManager mKeyguardManager;\n    private DevicePolicyManagerInternal mDevicePolicyManagerInternal;\n    private PackageManagerInternal mPackageManagerInternal;\n    private ActivityManagerInternal mActivityManagerInternal;\n    private AppOpsManagerInternal mAppOpsManagerInternal;\n    private UsageStatsManagerInternal mUsageStatsManagerInternal;\n\n    private SecurityPolicy mSecurityPolicy;\n\n    private Handler mSaveStateHandler;\n    private Handler mCallbackHandler;\n\n    private final SparseIntArray mNextAppWidgetIds = new SparseIntArray();\n\n    private boolean mSafeMode;\n    private int mMaxWidgetBitmapMemory;\n\n    AppWidgetServiceImpl(Context context) {\n        mContext = context;\n    }\n\n    public void onStart() {\n        mPackageManager = AppGlobals.getPackageManager();\n        mAlarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);\n        mUserManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n        mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);\n        mKeyguardManager = (KeyguardManager) mContext.getSystemService(KEYGUARD_SERVICE);\n        mDevicePolicyManagerInternal = LocalServices.getService(DevicePolicyManagerInternal.class);\n        mPackageManagerInternal = LocalServices.getService(PackageManagerInternal.class);\n        mSaveStateHandler = BackgroundThread.getHandler();\n        mCallbackHandler = new CallbackHandler(mContext.getMainLooper());\n        mBackupRestoreController = new BackupRestoreController();\n        mSecurityPolicy = new SecurityPolicy();\n\n        computeMaximumWidgetBitmapMemory();\n        registerBroadcastReceiver();\n        registerOnCrossProfileProvidersChangedListener();\n\n        LocalServices.addService(AppWidgetManagerInternal.class, new AppWidgetManagerLocal());\n    }\n\n    void systemServicesReady() {\n        mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);\n        mAppOpsManagerInternal = LocalServices.getService(AppOpsManagerInternal.class);\n        mUsageStatsManagerInternal = LocalServices.getService(UsageStatsManagerInternal.class);\n    }\n\n    private void computeMaximumWidgetBitmapMemory() {\n        Display display = mContext.getDisplayNoVerify();\n        Point size = new Point();\n        display.getRealSize(size);\n        // Cap memory usage at 1.5 times the size of the display\n        // 1.5 * 4 bytes/pixel * w * h ==> 6 * w * h\n        mMaxWidgetBitmapMemory = 6 * size.x * size.y;\n    }\n\n    private void registerBroadcastReceiver() {\n        // Register for broadcasts about package install, etc., so we can\n        // update the provider list.\n        IntentFilter packageFilter = new IntentFilter();\n        packageFilter.addAction(Intent.ACTION_PACKAGE_ADDED);\n        packageFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);\n        packageFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);\n        packageFilter.addDataScheme(\"package\");\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                packageFilter, null, null);\n\n        // Register for events related to sdcard installation.\n        IntentFilter sdFilter = new IntentFilter();\n        sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);\n        sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                sdFilter, null, null);\n\n        IntentFilter offModeFilter = new IntentFilter();\n        offModeFilter.addAction(Intent.ACTION_MANAGED_PROFILE_AVAILABLE);\n        offModeFilter.addAction(Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                offModeFilter, null, null);\n\n        IntentFilter suspendPackageFilter = new IntentFilter();\n        suspendPackageFilter.addAction(Intent.ACTION_PACKAGES_SUSPENDED);\n        suspendPackageFilter.addAction(Intent.ACTION_PACKAGES_UNSUSPENDED);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                suspendPackageFilter, null, null);\n    }\n\n    private void registerOnCrossProfileProvidersChangedListener() {\n        // The device policy is an optional component.\n        if (mDevicePolicyManagerInternal != null) {\n            mDevicePolicyManagerInternal.addOnCrossProfileWidgetProvidersChangeListener(this);\n        }\n    }\n\n    public void setSafeMode(boolean safeMode) {\n        mSafeMode = safeMode;\n    }\n\n    private void onPackageBroadcastReceived(Intent intent, int userId) {\n        final String action = intent.getAction();\n        boolean added = false;\n        boolean changed = false;\n        boolean componentsModified = false;\n\n        final String pkgList[];\n        switch (action) {\n            case Intent.ACTION_PACKAGES_SUSPENDED:\n            case Intent.ACTION_PACKAGES_UNSUSPENDED:\n                pkgList = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                changed = true;\n                break;\n            case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:\n                added = true;\n                // Follow through\n            case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:\n                pkgList = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                break;\n            default: {\n                Uri uri = intent.getData();\n                if (uri == null) {\n                    return;\n                }\n                String pkgName = uri.getSchemeSpecificPart();\n                if (pkgName == null) {\n                    return;\n                }\n                pkgList = new String[] { pkgName };\n                added = Intent.ACTION_PACKAGE_ADDED.equals(action);\n                changed = Intent.ACTION_PACKAGE_CHANGED.equals(action);\n            }\n        }\n        if (pkgList == null || pkgList.length == 0) {\n            return;\n        }\n\n        synchronized (mLock) {\n            if (!mUserManager.isUserUnlockingOrUnlocked(userId) ||\n                    isProfileWithLockedParent(userId)) {\n                return;\n            }\n            ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ false);\n\n            Bundle extras = intent.getExtras();\n\n            if (added || changed) {\n                final boolean newPackageAdded = added && (extras == null\n                        || !extras.getBoolean(Intent.EXTRA_REPLACING, false));\n\n                for (String pkgName : pkgList) {\n                    // Fix up the providers - add/remove/update.\n                    componentsModified |= updateProvidersForPackageLocked(pkgName, userId, null);\n\n                    // ... and see if these are hosts we've been awaiting.\n                    // NOTE: We are backing up and restoring only the owner.\n                    // TODO: http://b/22388012\n                    if (newPackageAdded && userId == UserHandle.USER_SYSTEM) {\n                        final int uid = getUidForPackage(pkgName, userId);\n                        if (uid >= 0 ) {\n                            resolveHostUidLocked(pkgName, uid);\n                        }\n                    }\n                }\n            } else {\n                // If the package is being updated, we'll receive a PACKAGE_ADDED\n                // shortly, otherwise it is removed permanently.\n                final boolean packageRemovedPermanently = (extras == null\n                        || !extras.getBoolean(Intent.EXTRA_REPLACING, false));\n\n                if (packageRemovedPermanently) {\n                    for (String pkgName : pkgList) {\n                        componentsModified |= removeHostsAndProvidersForPackageLocked(\n                                pkgName, userId);\n                    }\n                }\n            }\n\n            if (componentsModified) {\n                saveGroupStateAsync(userId);\n\n                // If the set of providers has been modified, notify each active AppWidgetHost\n                scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n                // Possibly notify any new components of widget id changes\n                mBackupRestoreController.widgetComponentsChanged(userId);\n            }\n        }\n    }\n\n    /**\n     * Reload all widgets' masked state for the given user and its associated profiles, including\n     * due to user not being available and package suspension.\n     * userId must be the group parent.\n     */\n    void reloadWidgetsMaskedStateForGroup(int userId) {\n        if (!mUserManager.isUserUnlockingOrUnlocked(userId)) {\n            return;\n        }\n        synchronized (mLock) {\n            reloadWidgetsMaskedState(userId);\n            int[] profileIds = mUserManager.getEnabledProfileIds(userId);\n            for (int profileId : profileIds) {\n                reloadWidgetsMaskedState(profileId);\n            }\n        }\n    }\n\n    private void reloadWidgetsMaskedState(int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            UserInfo user  = mUserManager.getUserInfo(userId);\n\n            boolean lockedProfile = !mUserManager.isUserUnlockingOrUnlocked(userId);\n            boolean quietProfile = user.isQuietModeEnabled();\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                int providerUserId = provider.getUserId();\n                if (providerUserId != userId) {\n                    continue;\n                }\n\n                boolean changed = provider.setMaskedByLockedProfileLocked(lockedProfile);\n                changed |= provider.setMaskedByQuietProfileLocked(quietProfile);\n                try {\n                    boolean suspended;\n                    try {\n                        suspended = mPackageManager.isPackageSuspendedForUser(\n                                provider.id.componentName.getPackageName(), provider.getUserId());\n                    } catch (IllegalArgumentException ex) {\n                        // Package not found.\n                        suspended = false;\n                    }\n                    changed |= provider.setMaskedBySuspendedPackageLocked(suspended);\n                } catch (RemoteException e) {\n                    Slog.e(TAG, \"Failed to query application info\", e);\n                }\n                if (changed) {\n                    if (provider.isMaskedLocked()) {\n                        maskWidgetsViewsLocked(provider, null);\n                    } else {\n                        unmaskWidgetsViewsLocked(provider);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    /**\n     * Incrementally update the masked state due to package suspension state.\n     */\n    private void updateWidgetPackageSuspensionMaskedState(Intent intent, boolean suspended,\n            int profileId) {\n        String[] packagesArray = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n        if (packagesArray == null) {\n            return;\n        }\n        Set<String> packages = new ArraySet<>(Arrays.asList(packagesArray));\n        synchronized (mLock) {\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                int providerUserId = provider.getUserId();\n                if (providerUserId != profileId\n                        || !packages.contains(provider.id.componentName.getPackageName())) {\n                    continue;\n                }\n                if (provider.setMaskedBySuspendedPackageLocked(suspended)) {\n                    if (provider.isMaskedLocked()) {\n                        maskWidgetsViewsLocked(provider, null);\n                    } else {\n                        unmaskWidgetsViewsLocked(provider);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Mask the target widget belonging to the specified provider, or all active widgets\n     * of the provider if target widget == null.\n     */\n    private void maskWidgetsViewsLocked(Provider provider, Widget targetWidget) {\n        final int widgetCount = provider.widgets.size();\n        if (widgetCount == 0) {\n            return;\n        }\n        RemoteViews views = new RemoteViews(mContext.getPackageName(),\n                R.layout.work_widget_mask_view);\n        ApplicationInfo appInfo = provider.info.providerInfo.applicationInfo;\n        final int appUserId = provider.getUserId();\n        boolean showBadge;\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final Intent onClickIntent;\n\n            if (provider.maskedBySuspendedPackage) {\n                showBadge = mUserManager.hasBadge(appUserId);\n                final String suspendingPackage = mPackageManagerInternal.getSuspendingPackage(\n                        appInfo.packageName, appUserId);\n                if (PLATFORM_PACKAGE_NAME.equals(suspendingPackage)) {\n                    onClickIntent = mDevicePolicyManagerInternal.createShowAdminSupportIntent(\n                            appUserId, true);\n                } else {\n                    final SuspendDialogInfo dialogInfo =\n                            mPackageManagerInternal.getSuspendedDialogInfo(\n                                    appInfo.packageName, suspendingPackage, appUserId);\n                    // onUnsuspend is null because we don't want to start any activity on\n                    // unsuspending from a suspended widget.\n                    onClickIntent = SuspendedAppActivity.createSuspendedAppInterceptIntent(\n                            appInfo.packageName, suspendingPackage, dialogInfo, null, null,\n                            appUserId);\n                }\n            } else if (provider.maskedByQuietProfile) {\n                showBadge = true;\n                onClickIntent = UnlaunchableAppActivity.createInQuietModeDialogIntent(appUserId);\n            } else /* provider.maskedByLockedProfile */ {\n                showBadge = true;\n                onClickIntent = mKeyguardManager\n                        .createConfirmDeviceCredentialIntent(null, null, appUserId);\n                if (onClickIntent != null) {\n                    onClickIntent.setFlags(\n                            FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);\n                }\n            }\n\n            if (onClickIntent != null) {\n                views.setOnClickPendingIntent(android.R.id.background,\n                        PendingIntent.getActivity(mContext, 0, onClickIntent,\n                                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE));\n            }\n\n            Icon icon = appInfo.icon != 0\n                    ? Icon.createWithResource(appInfo.packageName, appInfo.icon)\n                    : Icon.createWithResource(mContext, android.R.drawable.sym_def_app_icon);\n            views.setImageViewIcon(R.id.work_widget_app_icon, icon);\n            if (!showBadge) {\n                views.setViewVisibility(R.id.work_widget_badge_icon, View.INVISIBLE);\n            }\n\n            for (int j = 0; j < widgetCount; j++) {\n                Widget widget = provider.widgets.get(j);\n                if (targetWidget != null && targetWidget != widget) continue;\n                if (widget.replaceWithMaskedViewsLocked(views)) {\n                    scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void unmaskWidgetsViewsLocked(Provider provider) {\n        final int widgetCount = provider.widgets.size();\n        for (int j = 0; j < widgetCount; j++) {\n            Widget widget = provider.widgets.get(j);\n            if (widget.clearMaskedViewsLocked()) {\n                scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n            }\n        }\n    }\n\n    private void resolveHostUidLocked(String pkg, int uid) {\n        final int N = mHosts.size();\n        for (int i = 0; i < N; i++) {\n            Host host = mHosts.get(i);\n            if (host.id.uid == UNKNOWN_UID && pkg.equals(host.id.packageName)) {\n                if (DEBUG) {\n                    Slog.i(TAG, \"host \" + host.id + \" resolved to uid \" + uid);\n                }\n                host.id = new HostId(uid, host.id.hostId, host.id.packageName);\n                return;\n            }\n        }\n    }\n\n    private void ensureGroupStateLoadedLocked(int userId) {\n        ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ true );\n    }\n\n    private void ensureGroupStateLoadedLocked(int userId, boolean enforceUserUnlockingOrUnlocked) {\n        if (enforceUserUnlockingOrUnlocked && !isUserRunningAndUnlocked(userId)) {\n            throw new IllegalStateException(\n                    \"User \" + userId + \" must be unlocked for widgets to be available\");\n        }\n        if (enforceUserUnlockingOrUnlocked && isProfileWithLockedParent(userId)) {\n            throw new IllegalStateException(\n                    \"Profile \" + userId + \" must have unlocked parent\");\n        }\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        IntArray newIds = new IntArray(1);\n        for (int profileId : profileIds) {\n            if (!mLoadedUserIds.get(profileId)) {\n                mLoadedUserIds.put(profileId, true);\n                newIds.add(profileId);\n            }\n        }\n        if (newIds.size() <= 0) {\n            return;\n        }\n        final int[] newProfileIds = newIds.toArray();\n        clearProvidersAndHostsTagsLocked();\n\n        loadGroupWidgetProvidersLocked(newProfileIds);\n        loadGroupStateLocked(newProfileIds);\n    }\n\n    private boolean isUserRunningAndUnlocked(@UserIdInt int userId) {\n        return mUserManager.isUserUnlockingOrUnlocked(userId);\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {\n        if (!DumpUtils.checkDumpPermission(mContext, TAG, pw)) return;\n\n        synchronized (mLock) {\n            if (args.length > 0 && \"--proto\".equals(args[0])) {\n                dumpProto(fd);\n            } else {\n                dumpInternalLocked(pw);\n            }\n        }\n    }\n\n    private void dumpProto(FileDescriptor fd) {\n        Slog.i(TAG, \"dump proto for \" + mWidgets.size() + \" widgets\");\n\n        ProtoOutputStream proto = new ProtoOutputStream(fd);\n        int N = mWidgets.size();\n        for (int i=0; i < N; i++) {\n            dumpProtoWidget(proto, mWidgets.get(i));\n        }\n        proto.flush();\n    }\n\n    private void dumpProtoWidget(ProtoOutputStream proto, Widget widget) {\n        if (widget.host == null || widget.provider == null) {\n            Slog.d(TAG, \"skip dumping widget because host or provider is null: widget.host=\"\n                + widget.host + \" widget.provider=\"  + widget.provider);\n            return;\n        }\n        long token = proto.start(AppWidgetServiceDumpProto.WIDGETS);\n        proto.write(WidgetProto.IS_CROSS_PROFILE,\n            widget.host.getUserId() != widget.provider.getUserId());\n        proto.write(WidgetProto.IS_HOST_STOPPED, widget.host.callbacks == null);\n        proto.write(WidgetProto.HOST_PACKAGE, widget.host.id.packageName);\n        proto.write(WidgetProto.PROVIDER_PACKAGE, widget.provider.id.componentName.getPackageName());\n        proto.write(WidgetProto.PROVIDER_CLASS, widget.provider.id.componentName.getClassName());\n        if (widget.options != null) {\n            proto.write(WidgetProto.RESTORE_COMPLETED,\n                    widget.options.getBoolean(AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED));\n            proto.write(WidgetProto.MIN_WIDTH,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH, 0));\n            proto.write(WidgetProto.MIN_HEIGHT,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, 0));\n            proto.write(WidgetProto.MAX_WIDTH,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH, 0));\n            proto.write(WidgetProto.MAX_HEIGHT,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, 0));\n        }\n        proto.end(token);\n    }\n\n    private void dumpInternalLocked(PrintWriter pw) {\n        int N = mProviders.size();\n        pw.println(\"Providers:\");\n        for (int i = 0; i < N; i++) {\n            dumpProviderLocked(mProviders.get(i), i, pw);\n        }\n\n        N = mWidgets.size();\n        pw.println(\" \");\n        pw.println(\"Widgets:\");\n        for (int i = 0; i < N; i++) {\n            dumpWidget(mWidgets.get(i), i, pw);\n        }\n\n        N = mHosts.size();\n        pw.println(\" \");\n        pw.println(\"Hosts:\");\n        for (int i = 0; i < N; i++) {\n            dumpHost(mHosts.get(i), i, pw);\n        }\n\n        N = mPackagesWithBindWidgetPermission.size();\n        pw.println(\" \");\n        pw.println(\"Grants:\");\n        for (int i = 0; i < N; i++) {\n            Pair<Integer, String> grant = mPackagesWithBindWidgetPermission.valueAt(i);\n            dumpGrant(grant, i, pw);\n        }\n    }\n\n    @Override\n    public ParceledListSlice<PendingHostUpdate> startListening(IAppWidgetHost callbacks,\n            String callingPackage, int hostId, int[] appWidgetIds) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"startListening() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            // Instant apps cannot host app widgets.\n            if (mSecurityPolicy.isInstantAppLocked(callingPackage, userId)) {\n                Slog.w(TAG, \"Instant package \" + callingPackage + \" cannot host app widgets\");\n                return ParceledListSlice.emptyList();\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupOrAddHostLocked(id);\n            host.callbacks = callbacks;\n\n            long updateSequenceNo = UPDATE_COUNTER.incrementAndGet();\n            int N = appWidgetIds.length;\n            ArrayList<PendingHostUpdate> outUpdates = new ArrayList<>(N);\n            LongSparseArray<PendingHostUpdate> updatesMap = new LongSparseArray<>();\n            for (int i = 0; i < N; i++) {\n                updatesMap.clear();\n                host.getPendingUpdatesForIdLocked(mContext, appWidgetIds[i], updatesMap);\n                // We key the updates based on request id, so that the values are sorted in the\n                // order they were received.\n                int m = updatesMap.size();\n                for (int j = 0; j < m; j++) {\n                    outUpdates.add(updatesMap.valueAt(j));\n                }\n            }\n            // Reset the update counter once all the updates have been calculated\n            host.lastWidgetUpdateSequenceNo = updateSequenceNo;\n            return new ParceledListSlice<>(outUpdates);\n        }\n    }\n\n    @Override\n    public void stopListening(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"stopListening() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ false);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host != null) {\n                host.callbacks = null;\n                pruneHostLocked(host);\n                mAppOpsManagerInternal.updateAppWidgetVisibility(host.getWidgetUids(), false);\n            }\n        }\n    }\n\n    @Override\n    public int allocateAppWidgetId(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"allocateAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            // Instant apps cannot host app widgets.\n            if (mSecurityPolicy.isInstantAppLocked(callingPackage, userId)) {\n                Slog.w(TAG, \"Instant package \" + callingPackage + \" cannot host app widgets\");\n                return AppWidgetManager.INVALID_APPWIDGET_ID;\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            if (mNextAppWidgetIds.indexOfKey(userId) < 0) {\n                mNextAppWidgetIds.put(userId, AppWidgetManager.INVALID_APPWIDGET_ID + 1);\n            }\n\n            final int appWidgetId = incrementAndGetAppWidgetIdLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupOrAddHostLocked(id);\n\n            Widget widget = new Widget();\n            widget.appWidgetId = appWidgetId;\n            widget.host = host;\n\n            host.widgets.add(widget);\n            addWidgetLocked(widget);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Allocated widget id \" + appWidgetId\n                        + \" for host \" + host.id);\n            }\n\n            return appWidgetId;\n        }\n    }\n\n    @Override\n    public void deleteAppWidgetId(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                return;\n            }\n\n            deleteAppWidgetLocked(widget);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Deleted widget id \" + appWidgetId\n                        + \" for host \" + widget.host.id);\n            }\n        }\n    }\n\n    @Override\n    public boolean hasBindAppWidgetPermission(String packageName, int grantId) {\n        if (DEBUG) {\n            Slog.i(TAG, \"hasBindAppWidgetPermission() \" + UserHandle.getCallingUserId());\n        }\n\n        // A special permission is required for managing allowlisting.\n        mSecurityPolicy.enforceModifyAppWidgetBindPermissions(packageName);\n\n        synchronized (mLock) {\n            // The grants are stored in user state wich gets the grant.\n            ensureGroupStateLoadedLocked(grantId);\n\n            final int packageUid = getUidForPackage(packageName, grantId);\n            if (packageUid < 0) {\n                return false;\n            }\n\n            Pair<Integer, String> packageId = Pair.create(grantId, packageName);\n            return mPackagesWithBindWidgetPermission.contains(packageId);\n        }\n    }\n\n    @Override\n    public void setBindAppWidgetPermission(String packageName, int grantId,\n            boolean grantPermission) {\n        if (DEBUG) {\n            Slog.i(TAG, \"setBindAppWidgetPermission() \" + UserHandle.getCallingUserId());\n        }\n\n        // A special permission is required for managing allowlisting.\n        mSecurityPolicy.enforceModifyAppWidgetBindPermissions(packageName);\n\n        synchronized (mLock) {\n            // The grants are stored in user state wich gets the grant.\n            ensureGroupStateLoadedLocked(grantId);\n\n            final int packageUid = getUidForPackage(packageName, grantId);\n            if (packageUid < 0) {\n                return;\n            }\n\n            Pair<Integer, String> packageId = Pair.create(grantId, packageName);\n            if (grantPermission) {\n                mPackagesWithBindWidgetPermission.add(packageId);\n            } else {\n                mPackagesWithBindWidgetPermission.remove(packageId);\n            }\n\n            saveGroupStateAsync(grantId);\n        }\n    }\n\n    @Override\n    public IntentSender createAppWidgetConfigIntentSender(String callingPackage, int appWidgetId,\n            final int intentFlags) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"createAppWidgetConfigIntentSender() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                throw new IllegalArgumentException(\"Bad widget id \" + appWidgetId);\n            }\n\n            Provider provider = widget.provider;\n            if (provider == null) {\n                throw new IllegalArgumentException(\"Widget not bound \" + appWidgetId);\n            }\n\n            // Make sure only safe flags can be passed it.\n            final int secureFlags = intentFlags & ~Intent.IMMUTABLE_FLAGS;\n\n            Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_CONFIGURE);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);\n            intent.setComponent(provider.getInfoLocked(mContext).configure);\n            intent.setFlags(secureFlags);\n\n            // All right, create the sender.\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return PendingIntent.getActivityAsUser(\n                        mContext, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                                | PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_CANCEL_CURRENT,\n                                null, new UserHandle(provider.getUserId()))\n                        .getIntentSender();\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n    }\n\n    @Override\n    public boolean bindAppWidgetId(String callingPackage, int appWidgetId,\n            int providerProfileId, ComponentName providerComponent, Bundle options) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"bindAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        // Check that if a cross-profile binding is attempted, it is allowed.\n        if (!mSecurityPolicy.isEnabledGroupProfile(providerProfileId)) {\n            return false;\n        }\n\n        // If the provider is not under the calling user, make sure this\n        // provider is allowlisted for access from the parent.\n        if (!mSecurityPolicy.isProviderInCallerOrInProfileAndWhitelListed(\n                providerComponent.getPackageName(), providerProfileId)) {\n            return false;\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // A special permission or allowlisting is required to bind widgets.\n            if (!mSecurityPolicy.hasCallerBindPermissionOrBindWhiteListedLocked(\n                    callingPackage)) {\n                return false;\n            }\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                Slog.e(TAG, \"Bad widget id \" + appWidgetId);\n                return false;\n            }\n\n            if (widget.provider != null) {\n                Slog.e(TAG, \"Widget id \" + appWidgetId\n                        + \" already bound to: \" + widget.provider.id);\n                return false;\n            }\n\n            final int providerUid = getUidForPackage(providerComponent.getPackageName(),\n                    providerProfileId);\n            if (providerUid < 0) {\n                Slog.e(TAG, \"Package \" + providerComponent.getPackageName() + \" not installed \"\n                        + \" for profile \" + providerProfileId);\n                return false;\n            }\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the provider is in the already vetted user profile.\n            ProviderId providerId = new ProviderId(providerUid, providerComponent);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider == null) {\n                Slog.e(TAG, \"No widget provider \" + providerComponent + \" for profile \"\n                        + providerProfileId);\n                return false;\n            }\n\n            if (provider.zombie) {\n                Slog.e(TAG, \"Can't bind to a 3rd party provider in\"\n                        + \" safe mode \" + provider);\n                return false;\n            }\n\n            widget.provider = provider;\n            widget.options = (options != null) ? cloneIfLocalBinder(options) : new Bundle();\n\n            // We need to provide a default value for the widget category if it is not specified\n            if (!widget.options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {\n                widget.options.putInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY,\n                        AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN);\n            }\n\n            provider.widgets.add(widget);\n\n            onWidgetProviderAddedOrChangedLocked(widget);\n\n            final int widgetCount = provider.widgets.size();\n            if (widgetCount == 1) {\n                // Tell the provider that it's ready.\n                sendEnableIntentLocked(provider);\n            }\n\n            // Send an update now -- We need this update now, and just for this appWidgetId.\n            // It's less critical when the next one happens, so when we schedule the next one,\n            // we add updatePeriodMillis to its start time. That time will have some slop,\n            // but that's okay.\n            sendUpdateIntentLocked(provider, new int[] {appWidgetId});\n\n            // Schedule the future updates.\n            registerForBroadcastsLocked(provider, getWidgetIds(provider.widgets));\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Bound widget \" + appWidgetId + \" to provider \" + provider.id);\n            }\n        }\n\n        return true;\n    }\n\n    @Override\n    public int[] getAppWidgetIds(ComponentName componentName) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetIds() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider != null) {\n                return getWidgetIds(provider.widgets);\n            }\n\n            return new int[0];\n        }\n    }\n\n    @Override\n    public int[] getAppWidgetIdsForHost(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetIdsForHost() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access its hosts.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host != null) {\n                return getWidgetIds(host.widgets);\n            }\n\n            return new int[0];\n        }\n    }\n\n    @Override\n    public boolean bindRemoteViewsService(String callingPackage, int appWidgetId, Intent intent,\n            IApplicationThread caller, IBinder activtiyToken, IServiceConnection connection,\n            int flags) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"bindRemoteViewsService() \" + userId);\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                throw new IllegalArgumentException(\"Bad widget id\");\n            }\n\n            // Make sure the widget has a provider.\n            if (widget.provider == null) {\n                throw new IllegalArgumentException(\"No provider for widget \"\n                        + appWidgetId);\n            }\n\n            ComponentName componentName = intent.getComponent();\n\n            // Ensure that the service belongs to the same package as the provider.\n            // But this is not enough as they may be under different users - see below...\n            String providerPackage = widget.provider.id.componentName.getPackageName();\n            String servicePackage = componentName.getPackageName();\n            if (!servicePackage.equals(providerPackage)) {\n                throw new SecurityException(\"The taget service not in the same package\"\n                        + \" as the widget provider\");\n            }\n\n            // Make sure this service exists under the same user as the provider and\n            // requires a permission which allows only the system to bind to it.\n            mSecurityPolicy.enforceServiceExistsAndRequiresBindRemoteViewsPermission(\n                    componentName, widget.provider.getUserId());\n\n            // Good to go - the service package is correct, it exists for the correct\n            // user, and requires the bind permission.\n\n            final long callingIdentity = Binder.clearCallingIdentity();\n            try {\n                // Ask ActivityManager to bind it. Notice that we are binding the service with the\n                // caller app instead of DevicePolicyManagerService.\n                if (ActivityManager.getService().bindService(\n                        caller, activtiyToken, intent,\n                        intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                        connection, flags & (Context.BIND_AUTO_CREATE\n                                | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE),\n                        mContext.getOpPackageName(), widget.provider.getUserId()) != 0) {\n\n                    // Add it to the mapping of RemoteViewsService to appWidgetIds so that we\n                    // can determine when we can call back to the RemoteViewsService later to\n                    // destroy associated factories.\n                    incrementAppWidgetServiceRefCount(appWidgetId,\n                            Pair.create(widget.provider.id.uid, new FilterComparison(intent)));\n                    return true;\n                }\n            } catch (RemoteException ex) {\n                // Same process, should not happen.\n            } finally {\n                Binder.restoreCallingIdentity(callingIdentity);\n            }\n        }\n\n        // Failed to bind.\n        return false;\n    }\n\n    @Override\n    public void deleteHost(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteHost() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts in its uid and package.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host == null) {\n                return;\n            }\n\n            deleteHostLocked(host);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Deleted host \" + host.id);\n            }\n        }\n    }\n\n    @Override\n    public void deleteAllHosts() {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteAllHosts() \" + userId);\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            boolean changed = false;\n\n            final int N = mHosts.size();\n            for (int i = N - 1; i >= 0; i--) {\n                Host host = mHosts.get(i);\n\n                // Delete only hosts in the calling uid.\n                if (host.id.uid == Binder.getCallingUid()) {\n                    deleteHostLocked(host);\n                    changed = true;\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Deleted host \" + host.id);\n                    }\n                }\n            }\n\n            if (changed) {\n                saveGroupStateAsync(userId);\n            }\n        }\n    }\n\n    @Override\n    public AppWidgetProviderInfo getAppWidgetInfo(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetInfo() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null && widget.provider != null && !widget.provider.zombie) {\n                return cloneIfLocalBinder(widget.provider.getInfoLocked(mContext));\n            }\n\n            return null;\n        }\n    }\n\n    @Override\n    public RemoteViews getAppWidgetViews(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetViews() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null) {\n                return cloneIfLocalBinder(widget.getEffectiveViewsLocked());\n            }\n\n            return null;\n        }\n    }\n\n    @Override\n    public void updateAppWidgetOptions(String callingPackage, int appWidgetId, Bundle options) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetOptions() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                return;\n            }\n\n            // Merge the options.\n            widget.options.putAll(options);\n\n            // Send the broacast to notify the provider that options changed.\n            sendOptionsChangedIntentLocked(widget);\n\n            saveGroupStateAsync(userId);\n        }\n    }\n\n    @Override\n    public Bundle getAppWidgetOptions(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetOptions() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null && widget.options != null) {\n                return cloneIfLocalBinder(widget.options);\n            }\n\n            return Bundle.EMPTY;\n        }\n    }\n\n    @Override\n    public void updateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views) {\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetIds() \" + UserHandle.getCallingUserId());\n        }\n\n        updateAppWidgetIds(callingPackage, appWidgetIds, views, false);\n    }\n\n    @Override\n    public void partiallyUpdateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views) {\n        if (DEBUG) {\n            Slog.i(TAG, \"partiallyUpdateAppWidgetIds() \" + UserHandle.getCallingUserId());\n        }\n\n        updateAppWidgetIds(callingPackage, appWidgetIds, views, true);\n    }\n\n    @Override\n    public void notifyAppWidgetViewDataChanged(String callingPackage, int[] appWidgetIds,\n            int viewId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"notifyAppWidgetViewDataChanged() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        if (appWidgetIds == null || appWidgetIds.length == 0) {\n            return;\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            final int N = appWidgetIds.length;\n            for (int i = 0; i < N; i++) {\n                final int appWidgetId = appWidgetIds[i];\n\n                // NOTE: The lookup is enforcing security across users by making\n                // sure the caller can only access widgets it hosts or provides.\n                Widget widget = lookupWidgetLocked(appWidgetId,\n                        Binder.getCallingUid(), callingPackage);\n\n                if (widget != null) {\n                    scheduleNotifyAppWidgetViewDataChanged(widget, viewId);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void updateAppWidgetProvider(ComponentName componentName, RemoteViews views) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetProvider() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider == null) {\n                Slog.w(TAG, \"Provider doesn't exist \" + providerId);\n                return;\n            }\n\n            ArrayList<Widget> instances = provider.widgets;\n            final int N = instances.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = instances.get(i);\n                updateAppWidgetInstanceLocked(widget, views, false);\n            }\n        }\n    }\n\n    @Override\n    public void updateAppWidgetProviderInfo(ComponentName componentName, String metadataKey) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetProvider() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n            if (provider == null) {\n                throw new IllegalArgumentException(\n                        componentName + \" is not a valid AppWidget provider\");\n            }\n            if (Objects.equals(provider.infoTag, metadataKey)) {\n                // No change\n                return;\n            }\n\n            String keyToUse = metadataKey == null\n                    ? AppWidgetManager.META_DATA_APPWIDGET_PROVIDER : metadataKey;\n            AppWidgetProviderInfo info = parseAppWidgetProviderInfo(mContext, providerId,\n                    provider.getPartialInfoLocked().providerInfo, keyToUse);\n            if (info == null) {\n                throw new IllegalArgumentException(\"Unable to parse \" + keyToUse\n                        + \" meta-data to a valid AppWidget provider\");\n            }\n\n            provider.setInfoLocked(info);\n            provider.infoTag = metadataKey;\n\n            // Update all widgets for this provider\n            final int N = provider.widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = provider.widgets.get(i);\n                scheduleNotifyProviderChangedLocked(widget);\n                updateAppWidgetInstanceLocked(widget, widget.views, false /* isPartialUpdate */);\n            }\n\n            saveGroupStateAsync(userId);\n            scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n        }\n    }\n\n    @Override\n    public boolean isRequestPinAppWidgetSupported() {\n        synchronized (mLock) {\n            if (mSecurityPolicy.isCallerInstantAppLocked()) {\n                Slog.w(TAG, \"Instant uid \" + Binder.getCallingUid()\n                        + \" query information about app widgets\");\n                return false;\n            }\n        }\n        return LocalServices.getService(ShortcutServiceInternal.class)\n                .isRequestPinItemSupported(UserHandle.getCallingUserId(),\n                        LauncherApps.PinItemRequest.REQUEST_TYPE_APPWIDGET);\n    }\n\n    @Override\n    public boolean requestPinAppWidget(String callingPackage, ComponentName componentName,\n            Bundle extras, IntentSender resultSender) {\n        final int callingUid = Binder.getCallingUid();\n        final int userId = UserHandle.getUserId(callingUid);\n\n        if (DEBUG) {\n            Slog.i(TAG, \"requestPinAppWidget() \" + userId);\n        }\n\n        final AppWidgetProviderInfo info;\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // Look for the widget associated with the caller.\n            Provider provider = lookupProviderLocked(new ProviderId(callingUid, componentName));\n            if (provider == null || provider.zombie) {\n                return false;\n            }\n            info = provider.getInfoLocked(mContext);\n            if ((info.widgetCategory & AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN) == 0) {\n                return false;\n            }\n        }\n\n        return LocalServices.getService(ShortcutServiceInternal.class)\n                .requestPinAppWidget(callingPackage, info, extras, resultSender, userId);\n    }\n\n    @Override\n    public ParceledListSlice<AppWidgetProviderInfo> getInstalledProvidersForProfile(int categoryFilter,\n            int profileId, String packageName) {\n        final int userId = UserHandle.getCallingUserId();\n        final int callingUid = Binder.getCallingUid();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getInstalledProvidersForProfiles() \" + userId);\n        }\n\n        // Ensure the profile is in the group and enabled.\n        if (!mSecurityPolicy.isEnabledGroupProfile(profileId)) {\n            return null;\n        }\n\n        synchronized (mLock) {\n            if (mSecurityPolicy.isCallerInstantAppLocked()) {\n                Slog.w(TAG, \"Instant uid \" + callingUid\n                        + \" cannot access widget providers\");\n                return ParceledListSlice.emptyList();\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            ArrayList<AppWidgetProviderInfo> result = new ArrayList<AppWidgetProviderInfo>();\n\n            final int providerCount = mProviders.size();\n            for (int i = 0; i < providerCount; i++) {\n                Provider provider = mProviders.get(i);\n                AppWidgetProviderInfo info = provider.getInfoLocked(mContext);\n                final String providerPackageName = provider.id.componentName.getPackageName();\n\n                // Ignore an invalid provider, one not matching the filter,\n                // or one that isn't in the given package, if any.\n                boolean inPackage = packageName == null\n                        || providerPackageName.equals(packageName);\n                if (provider.zombie || (info.widgetCategory & categoryFilter) == 0 || !inPackage) {\n                    continue;\n                }\n\n                // Add providers only for the requested profile that are allowlisted.\n                final int providerProfileId = info.getProfile().getIdentifier();\n                if (providerProfileId == profileId\n                        && mSecurityPolicy.isProviderInCallerOrInProfileAndWhitelListed(\n                        providerPackageName, providerProfileId)\n                        && !mPackageManagerInternal.filterAppAccess(providerPackageName, callingUid,\n                        userId)) {\n                    result.add(cloneIfLocalBinder(info));\n                }\n            }\n\n            return new ParceledListSlice<AppWidgetProviderInfo>(result);\n        }\n    }\n\n    private void updateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views, boolean partially) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (appWidgetIds == null || appWidgetIds.length == 0) {\n            return;\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            final int N = appWidgetIds.length;\n            for (int i = 0; i < N; i++) {\n                final int appWidgetId = appWidgetIds[i];\n\n                // NOTE: The lookup is enforcing security across users by making\n                // sure the caller can only access widgets it hosts or provides.\n                Widget widget = lookupWidgetLocked(appWidgetId,\n                        Binder.getCallingUid(), callingPackage);\n\n                if (widget != null) {\n                    updateAppWidgetInstanceLocked(widget, views, partially);\n                }\n            }\n        }\n    }\n\n    private int incrementAndGetAppWidgetIdLocked(int userId) {\n        final int appWidgetId = peekNextAppWidgetIdLocked(userId) + 1;\n        mNextAppWidgetIds.put(userId, appWidgetId);\n        return appWidgetId;\n    }\n\n    private void setMinAppWidgetIdLocked(int userId, int minWidgetId) {\n        final int nextAppWidgetId = peekNextAppWidgetIdLocked(userId);\n        if (nextAppWidgetId < minWidgetId) {\n            mNextAppWidgetIds.put(userId, minWidgetId);\n        }\n    }\n\n    private int peekNextAppWidgetIdLocked(int userId) {\n        if (mNextAppWidgetIds.indexOfKey(userId) < 0) {\n            return AppWidgetManager.INVALID_APPWIDGET_ID + 1;\n        } else {\n            return mNextAppWidgetIds.get(userId);\n        }\n    }\n\n    private Host lookupOrAddHostLocked(HostId id) {\n        Host host = lookupHostLocked(id);\n        if (host != null) {\n            return host;\n        }\n        ensureHostCountBeforeAddLocked(id);\n        host = new Host();\n        host.id = id;\n        mHosts.add(host);\n\n        return host;\n    }\n\n    /**\n     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n     * removes the oldest host.\n     */\n    private void ensureHostCountBeforeAddLocked(@NonNull final HostId hostId) {\n        final List<Host> hosts = new ArrayList<>();\n        for (Host host : mHosts) {\n            if (host.id.uid == hostId.uid\n                    && host.id.packageName.equals(hostId.packageName)) {\n                hosts.add(host);\n            }\n        }\n        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n            deleteHostLocked(hosts.remove(0));\n        }\n    }\n\n    private void deleteHostLocked(Host host) {\n        final int N = host.widgets.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Widget widget = host.widgets.remove(i);\n            deleteAppWidgetLocked(widget);\n        }\n        mHosts.remove(host);\n\n        // it's gone or going away, abruptly drop the callback connection\n        host.callbacks = null;\n    }\n\n    private void deleteAppWidgetLocked(Widget widget) {\n        // We first unbind all services that are bound to this id\n        // Check if we need to destroy any services (if no other app widgets are\n        // referencing the same service)\n        decrementAppWidgetServiceRefCount(widget);\n\n        Host host = widget.host;\n        host.widgets.remove(widget);\n        pruneHostLocked(host);\n\n        removeWidgetLocked(widget);\n\n        Provider provider = widget.provider;\n        if (provider != null) {\n            provider.widgets.remove(widget);\n            if (!provider.zombie) {\n                // send the broacast saying that this appWidgetId has been deleted\n                sendDeletedIntentLocked(widget);\n\n                if (provider.widgets.isEmpty()) {\n                    // cancel the future updates\n                    cancelBroadcastsLocked(provider);\n\n                    // send the broacast saying that the provider is not in use any more\n                    sendDisabledIntentLocked(provider);\n                }\n            }\n        }\n    }\n\n    private void cancelBroadcastsLocked(Provider provider) {\n        if (DEBUG) {\n            Slog.i(TAG, \"cancelBroadcastsLocked() for \" + provider);\n        }\n        if (provider.broadcast != null) {\n            final PendingIntent broadcast = provider.broadcast;\n            mSaveStateHandler.post(() -> {\n                    mAlarmManager.cancel(broadcast);\n                    broadcast.cancel();\n            });\n            provider.broadcast = null;\n        }\n    }\n\n    // Destroys the cached factory on the RemoteViewsService's side related to the specified intent\n    private void destroyRemoteViewsService(final Intent intent, Widget widget) {\n        final ServiceConnection conn = new ServiceConnection() {\n            @Override\n            public void onServiceConnected(ComponentName name, IBinder service) {\n                final IRemoteViewsFactory cb = IRemoteViewsFactory.Stub.asInterface(service);\n                try {\n                    cb.onDestroy(intent);\n                } catch (RemoteException re) {\n                    Slog.e(TAG, \"Error calling remove view factory\", re);\n                }\n                mContext.unbindService(this);\n            }\n\n            @Override\n            public void onServiceDisconnected(ComponentName name) {\n                // Do nothing\n            }\n        };\n\n        // Bind to the service and remove the static intent->factory mapping in the\n        // RemoteViewsService.\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.bindServiceAsUser(intent, conn,\n                    Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE,\n                    widget.provider.id.getProfile());\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    // Adds to the ref-count for a given RemoteViewsService intent\n    private void incrementAppWidgetServiceRefCount(int appWidgetId,\n            Pair<Integer, FilterComparison> serviceId) {\n        final HashSet<Integer> appWidgetIds;\n        if (mRemoteViewsServicesAppWidgets.containsKey(serviceId)) {\n            appWidgetIds = mRemoteViewsServicesAppWidgets.get(serviceId);\n        } else {\n            appWidgetIds = new HashSet<>();\n            mRemoteViewsServicesAppWidgets.put(serviceId, appWidgetIds);\n        }\n        appWidgetIds.add(appWidgetId);\n    }\n\n    // Subtracts from the ref-count for a given RemoteViewsService intent, prompting a delete if\n    // the ref-count reaches zero.\n    private void decrementAppWidgetServiceRefCount(Widget widget) {\n        Iterator<Pair<Integer, FilterComparison>> it = mRemoteViewsServicesAppWidgets\n                .keySet().iterator();\n        while (it.hasNext()) {\n            final Pair<Integer, FilterComparison> key = it.next();\n            final HashSet<Integer> ids = mRemoteViewsServicesAppWidgets.get(key);\n            if (ids.remove(widget.appWidgetId)) {\n                // If we have removed the last app widget referencing this service, then we\n                // should destroy it and remove it from this set\n                if (ids.isEmpty()) {\n                    destroyRemoteViewsService(key.second.getIntent(), widget);\n                    it.remove();\n                }\n            }\n        }\n    }\n\n    private void saveGroupStateAsync(int groupId) {\n        mSaveStateHandler.post(new SaveStateRunnable(groupId));\n    }\n\n    private void updateAppWidgetInstanceLocked(Widget widget, RemoteViews views,\n            boolean isPartialUpdate) {\n        if (widget != null && widget.provider != null\n                && !widget.provider.zombie && !widget.host.zombie) {\n\n            if (isPartialUpdate && widget.views != null) {\n                // For a partial update, we merge the new RemoteViews with the old.\n                widget.views.mergeRemoteViews(views);\n            } else {\n                // For a full update we replace the RemoteViews completely.\n                widget.views = views;\n            }\n            int memoryUsage;\n            if ((UserHandle.getAppId(Binder.getCallingUid()) != Process.SYSTEM_UID) &&\n                    (widget.views != null) &&\n                    ((memoryUsage = widget.views.estimateMemoryUsage()) > mMaxWidgetBitmapMemory)) {\n                widget.views = null;\n                throw new IllegalArgumentException(\"RemoteViews for widget update exceeds\"\n                        + \" maximum bitmap memory usage (used: \" + memoryUsage\n                        + \", max: \" + mMaxWidgetBitmapMemory + \")\");\n            }\n            scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n        }\n    }\n    private void scheduleNotifyAppWidgetViewDataChanged(Widget widget, int viewId) {\n        if (viewId == ID_VIEWS_UPDATE || viewId == ID_PROVIDER_CHANGED) {\n            // A view id should never collide with these constants but a developer can call this\n            // method with a wrong id. In that case, ignore the call.\n            return;\n        }\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.put(viewId, requestId);\n        }\n        if (widget == null || widget.host == null || widget.host.zombie\n                || widget.host.callbacks == null || widget.provider == null\n                || widget.provider.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = requestId;\n        args.argi1 = widget.appWidgetId;\n        args.argi2 = viewId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_VIEW_DATA_CHANGED,\n                args).sendToTarget();\n    }\n\n\n    private void handleNotifyAppWidgetViewDataChanged(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, int viewId, long requestId) {\n        try {\n            callbacks.viewDataChanged(appWidgetId, viewId);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            // It failed; remove the callback. No need to prune because\n            // we know that this host is still referenced by this instance.\n            callbacks = null;\n        }\n\n        // If the host is unavailable, then we call the associated\n        // RemoteViewsFactory.onDataSetChanged() directly\n        synchronized (mLock) {\n            if (callbacks == null) {\n                host.callbacks = null;\n\n                Set<Pair<Integer, FilterComparison>> keys = mRemoteViewsServicesAppWidgets.keySet();\n                for (Pair<Integer, FilterComparison> key : keys) {\n                    if (mRemoteViewsServicesAppWidgets.get(key).contains(appWidgetId)) {\n                        final ServiceConnection connection = new ServiceConnection() {\n                            @Override\n                            public void onServiceConnected(ComponentName name, IBinder service) {\n                                IRemoteViewsFactory cb = IRemoteViewsFactory.Stub\n                                        .asInterface(service);\n                                try {\n                                    cb.onDataSetChangedAsync();\n                                } catch (RemoteException e) {\n                                    Slog.e(TAG, \"Error calling onDataSetChangedAsync()\", e);\n                                }\n                                mContext.unbindService(this);\n                            }\n\n                            @Override\n                            public void onServiceDisconnected(android.content.ComponentName name) {\n                                // Do nothing\n                            }\n                        };\n\n                        final int userId = UserHandle.getUserId(key.first);\n                        Intent intent = key.second.getIntent();\n\n                        // Bind to the service and call onDataSetChanged()\n                        bindService(intent, connection, new UserHandle(userId));\n                    }\n                }\n            }\n        }\n    }\n\n    private void scheduleNotifyUpdateAppWidgetLocked(Widget widget, RemoteViews updateViews) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.put(ID_VIEWS_UPDATE, requestId);\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n        if (updateViews != null) {\n            updateViews = new RemoteViews(updateViews);\n            updateViews.setProviderInstanceId(requestId);\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = updateViews;\n        args.arg4 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_UPDATE_APP_WIDGET,\n                args).sendToTarget();\n    }\n\n    private void handleNotifyUpdateAppWidget(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, RemoteViews views, long requestId) {\n        try {\n            callbacks.updateAppWidget(appWidgetId, views);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyProviderChangedLocked(Widget widget) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            // When the provider changes, reset everything else.\n            widget.updateSequenceNos.clear();\n            widget.updateSequenceNos.append(ID_PROVIDER_CHANGED, requestId);\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = widget.provider.getInfoLocked(mContext);\n        args.arg4 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_PROVIDER_CHANGED,\n                args).sendToTarget();\n    }\n\n    private void handleNotifyProviderChanged(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, AppWidgetProviderInfo info, long requestId) {\n        try {\n            callbacks.providerChanged(appWidgetId, info);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock){\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyAppWidgetRemovedLocked(Widget widget) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.clear();\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n            CallbackHandler.MSG_NOTIFY_APP_WIDGET_REMOVED,\n            args).sendToTarget();\n    }\n\n    private void handleNotifyAppWidgetRemoved(Host host, IAppWidgetHost callbacks, int appWidgetId,\n            long requestId) {\n        try {\n            callbacks.appWidgetRemoved(appWidgetId);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyGroupHostsForProvidersChangedLocked(int userId) {\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        final int N = mHosts.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Host host = mHosts.get(i);\n\n            boolean hostInGroup = false;\n            final int M = profileIds.length;\n            for (int j = 0; j < M; j++) {\n                final int profileId = profileIds[j];\n                if (host.getUserId() == profileId) {\n                    hostInGroup = true;\n                    break;\n                }\n            }\n\n            if (!hostInGroup) {\n                continue;\n            }\n\n            if (host == null || host.zombie || host.callbacks == null) {\n                continue;\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = host;\n            args.arg2 = host.callbacks;\n\n            mCallbackHandler.obtainMessage(\n                    CallbackHandler.MSG_NOTIFY_PROVIDERS_CHANGED,\n                    args).sendToTarget();\n        }\n    }\n\n    private void handleNotifyProvidersChanged(Host host, IAppWidgetHost callbacks) {\n        try {\n            callbacks.providersChanged();\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private static boolean isLocalBinder() {\n        return Process.myPid() == Binder.getCallingPid();\n    }\n\n    private static RemoteViews cloneIfLocalBinder(RemoteViews rv) {\n        if (isLocalBinder() && rv != null) {\n            return rv.clone();\n        }\n        return rv;\n    }\n\n    private static AppWidgetProviderInfo cloneIfLocalBinder(AppWidgetProviderInfo info) {\n        if (isLocalBinder() && info != null) {\n            return info.clone();\n        }\n        return info;\n    }\n\n    private static Bundle cloneIfLocalBinder(Bundle bundle) {\n        // Note: this is only a shallow copy. For now this will be fine, but it could be problematic\n        // if we start adding objects to the options. Further, it would only be an issue if keyguard\n        // used such options.\n        if (isLocalBinder() && bundle != null) {\n            return (Bundle) bundle.clone();\n        }\n        return bundle;\n    }\n\n    private Widget lookupWidgetLocked(int appWidgetId, int uid, String packageName) {\n        final int N = mWidgets.size();\n        for (int i = 0; i < N; i++) {\n            Widget widget = mWidgets.get(i);\n            if (widget.appWidgetId == appWidgetId\n                    && mSecurityPolicy.canAccessAppWidget(widget, uid, packageName)) {\n                return widget;\n            }\n        }\n        return null;\n    }\n\n    private Provider lookupProviderLocked(ProviderId id) {\n        final int N = mProviders.size();\n        for (int i = 0; i < N; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.id.equals(id)) {\n                return provider;\n            }\n        }\n        return null;\n    }\n\n    private Host lookupHostLocked(HostId hostId) {\n        final int N = mHosts.size();\n        for (int i = 0; i < N; i++) {\n            Host host = mHosts.get(i);\n            if (host.id.equals(hostId)) {\n                return host;\n            }\n        }\n        return null;\n    }\n\n    private void pruneHostLocked(Host host) {\n        if (host.widgets.size() == 0 && host.callbacks == null) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Pruning host \" + host.id);\n            }\n            mHosts.remove(host);\n        }\n    }\n\n    private void loadGroupWidgetProvidersLocked(int[] profileIds) {\n        List<ResolveInfo> allReceivers = null;\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n\n        final int profileCount = profileIds.length;\n        for (int i = 0; i < profileCount; i++) {\n            final int profileId = profileIds[i];\n\n            List<ResolveInfo> receivers = queryIntentReceivers(intent, profileId);\n            if (receivers != null && !receivers.isEmpty()) {\n                if (allReceivers == null) {\n                    allReceivers = new ArrayList<>();\n                }\n                allReceivers.addAll(receivers);\n            }\n        }\n\n        final int N = (allReceivers == null) ? 0 : allReceivers.size();\n        for (int i = 0; i < N; i++) {\n            ResolveInfo receiver = allReceivers.get(i);\n            addProviderLocked(receiver);\n        }\n    }\n\n    private boolean addProviderLocked(ResolveInfo ri) {\n        if ((ri.activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {\n            return false;\n        }\n\n        ComponentName componentName = new ComponentName(ri.activityInfo.packageName,\n                ri.activityInfo.name);\n        ProviderId providerId = new ProviderId(ri.activityInfo.applicationInfo.uid, componentName);\n\n        // we might have an inactive entry for this provider already due to\n        // a preceding restore operation.  if so, fix it up in place; otherwise\n        // just add this new one.\n        Provider existing = lookupProviderLocked(providerId);\n\n        // If the provider was not found it may be because it was restored and\n        // we did not know its UID so let us find if there is such one.\n        if (existing == null) {\n            ProviderId restoredProviderId = new ProviderId(UNKNOWN_UID, componentName);\n            existing = lookupProviderLocked(restoredProviderId);\n        }\n\n        AppWidgetProviderInfo info = createPartialProviderInfo(providerId, ri, existing);\n        if (info != null) {\n            if (existing != null) {\n                if (existing.zombie && !mSafeMode) {\n                    // it's a placeholder that was set up during an app restore\n                    existing.id = providerId;\n                    existing.zombie = false;\n                    existing.setPartialInfoLocked(info);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Provider placeholder now reified: \" + existing);\n                    }\n                }\n            } else {\n                Provider provider = new Provider();\n                provider.id = providerId;\n                provider.setPartialInfoLocked(info);\n                mProviders.add(provider);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    // Remove widgets for provider that are hosted in userId.\n    private void deleteWidgetsLocked(Provider provider, int userId) {\n        final int N = provider.widgets.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Widget widget = provider.widgets.get(i);\n            if (userId == UserHandle.USER_ALL\n                    || userId == widget.host.getUserId()) {\n                provider.widgets.remove(i);\n                // Call back with empty RemoteViews\n                updateAppWidgetInstanceLocked(widget, null, false);\n                // clear out references to this appWidgetId\n                widget.host.widgets.remove(widget);\n                removeWidgetLocked(widget);\n                widget.provider = null;\n                pruneHostLocked(widget.host);\n                widget.host = null;\n            }\n        }\n    }\n\n    private void deleteProviderLocked(Provider provider) {\n        deleteWidgetsLocked(provider, UserHandle.USER_ALL);\n        mProviders.remove(provider);\n\n        // no need to send the DISABLE broadcast, since the receiver is gone anyway\n        cancelBroadcastsLocked(provider);\n    }\n\n    private void sendEnableIntentLocked(Provider p) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_ENABLED);\n        intent.setComponent(p.id.componentName);\n        sendBroadcastAsUser(intent, p.id.getProfile());\n    }\n\n    private void sendUpdateIntentLocked(Provider provider, int[] appWidgetIds) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds);\n        intent.setComponent(provider.id.componentName);\n        sendBroadcastAsUser(intent, provider.id.getProfile());\n    }\n\n    private void sendDeletedIntentLocked(Widget widget) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_DELETED);\n        intent.setComponent(widget.provider.id.componentName);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, widget.appWidgetId);\n        sendBroadcastAsUser(intent, widget.provider.id.getProfile());\n    }\n\n    private void sendDisabledIntentLocked(Provider provider) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_DISABLED);\n        intent.setComponent(provider.id.componentName);\n        sendBroadcastAsUser(intent, provider.id.getProfile());\n    }\n\n    public void sendOptionsChangedIntentLocked(Widget widget) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_OPTIONS_CHANGED);\n        intent.setComponent(widget.provider.id.componentName);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, widget.appWidgetId);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS, widget.options);\n        sendBroadcastAsUser(intent, widget.provider.id.getProfile());\n    }\n\n    private void registerForBroadcastsLocked(Provider provider, int[] appWidgetIds) {\n        AppWidgetProviderInfo info = provider.getInfoLocked(mContext);\n        if (info.updatePeriodMillis > 0) {\n            // if this is the first instance, set the alarm. otherwise,\n            // rely on the fact that we've already set it and that\n            // PendingIntent.getBroadcast will update the extras.\n            boolean alreadyRegistered = provider.broadcast != null;\n            Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds);\n            intent.setComponent(info.provider);\n            final long token = Binder.clearCallingIdentity();\n            try {\n                // Broadcast alarms sent by system are immutable\n                provider.broadcast = PendingIntent.getBroadcastAsUser(mContext, 1, intent,\n                        PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                        info.getProfile());\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (!alreadyRegistered) {\n                // Set the alarm outside of our locks; we've latched the first-time\n                // invariant and established the PendingIntent safely.\n                final long period = Math.max(info.updatePeriodMillis, MIN_UPDATE_PERIOD);\n                final PendingIntent broadcast = provider.broadcast;\n                mSaveStateHandler.post(() ->\n                    mAlarmManager.setInexactRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,\n                            SystemClock.elapsedRealtime() + period, period, broadcast)\n                );\n            }\n        }\n    }\n\n    private static int[] getWidgetIds(ArrayList<Widget> widgets) {\n        int instancesSize = widgets.size();\n        int appWidgetIds[] = new int[instancesSize];\n        for (int i = 0; i < instancesSize; i++) {\n            appWidgetIds[i] = widgets.get(i).appWidgetId;\n        }\n        return appWidgetIds;\n    }\n\n    private static void dumpProviderLocked(Provider provider, int index, PrintWriter pw) {\n        AppWidgetProviderInfo info = provider.getPartialInfoLocked();\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] provider \");\n        pw.println(provider.id);\n        pw.print(\"    min=(\"); pw.print(info.minWidth);\n        pw.print(\"x\"); pw.print(info.minHeight);\n        pw.print(\")   minResize=(\"); pw.print(info.minResizeWidth);\n        pw.print(\"x\"); pw.print(info.minResizeHeight);\n        pw.print(\") updatePeriodMillis=\");\n        pw.print(info.updatePeriodMillis);\n        pw.print(\" resizeMode=\");\n        pw.print(info.resizeMode);\n        pw.print(\" widgetCategory=\");\n        pw.print(info.widgetCategory);\n        pw.print(\" autoAdvanceViewId=\");\n        pw.print(info.autoAdvanceViewId);\n        pw.print(\" initialLayout=#\");\n        pw.print(Integer.toHexString(info.initialLayout));\n        pw.print(\" initialKeyguardLayout=#\");\n        pw.print(Integer.toHexString(info.initialKeyguardLayout));\n        pw.print(\"   zombie=\"); pw.println(provider.zombie);\n    }\n\n    private static void dumpHost(Host host, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] hostId=\");\n        pw.println(host.id);\n        pw.print(\"    callbacks=\"); pw.println(host.callbacks);\n        pw.print(\"    widgets.size=\"); pw.print(host.widgets.size());\n        pw.print(\" zombie=\"); pw.println(host.zombie);\n    }\n\n    private static void dumpGrant(Pair<Integer, String> grant, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(']');\n        pw.print(\" user=\"); pw.print(grant.first);\n        pw.print(\" package=\"); pw.println(grant.second);\n    }\n\n    private static void dumpWidget(Widget widget, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] id=\");\n        pw.println(widget.appWidgetId);\n        pw.print(\"    host=\");\n        pw.println(widget.host.id);\n        if (widget.provider != null) {\n            pw.print(\"    provider=\"); pw.println(widget.provider.id);\n        }\n        if (widget.host != null) {\n            pw.print(\"    host.callbacks=\"); pw.println(widget.host.callbacks);\n        }\n        if (widget.views != null) {\n            pw.print(\"    views=\"); pw.println(widget.views);\n        }\n    }\n\n    private static void serializeProvider(TypedXmlSerializer out, Provider p) throws IOException {\n        out.startTag(null, \"p\");\n        out.attribute(null, \"pkg\", p.id.componentName.getPackageName());\n        out.attribute(null, \"cl\", p.id.componentName.getClassName());\n        out.attributeIntHex(null, \"tag\", p.tag);\n        if (!TextUtils.isEmpty(p.infoTag)) {\n            out.attribute(null, \"info_tag\", p.infoTag);\n        }\n        out.endTag(null, \"p\");\n    }\n\n    private static void serializeHost(TypedXmlSerializer out, Host host) throws IOException {\n        out.startTag(null, \"h\");\n        out.attribute(null, \"pkg\", host.id.packageName);\n        out.attributeIntHex(null, \"id\", host.id.hostId);\n        out.attributeIntHex(null, \"tag\", host.tag);\n        out.endTag(null, \"h\");\n    }\n\n    private static void serializeAppWidget(TypedXmlSerializer out, Widget widget,\n            boolean saveRestoreCompleted) throws IOException {\n        out.startTag(null, \"g\");\n        out.attributeIntHex(null, \"id\", widget.appWidgetId);\n        out.attributeIntHex(null, \"rid\", widget.restoredId);\n        out.attributeIntHex(null, \"h\", widget.host.tag);\n        if (widget.provider != null) {\n            out.attributeIntHex(null, \"p\", widget.provider.tag);\n        }\n        if (widget.options != null) {\n            int minWidth = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH);\n            int minHeight = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT);\n            int maxWidth = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH);\n            int maxHeight = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT);\n            out.attributeIntHex(null, \"min_width\", (minWidth > 0) ? minWidth : 0);\n            out.attributeIntHex(null, \"min_height\", (minHeight > 0) ? minHeight : 0);\n            out.attributeIntHex(null, \"max_width\", (maxWidth > 0) ? maxWidth : 0);\n            out.attributeIntHex(null, \"max_height\", (maxHeight > 0) ? maxHeight : 0);\n            out.attributeIntHex(null, \"host_category\", widget.options.getInt(\n                    AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY));\n            if (saveRestoreCompleted) {\n                boolean restoreCompleted = widget.options.getBoolean(\n                        AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED);\n                out.attributeBoolean(null, \"restore_completed\", restoreCompleted);\n            }\n        }\n        out.endTag(null, \"g\");\n    }\n\n    private static Bundle parseWidgetIdOptions(TypedXmlPullParser parser) {\n        Bundle options = new Bundle();\n        boolean restoreCompleted = parser.getAttributeBoolean(null, \"restore_completed\", false);\n        if (restoreCompleted) {\n            options.putBoolean(AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED, true);\n        }\n        int minWidth = parser.getAttributeIntHex(null, \"min_width\", -1);\n        if (minWidth != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH, minWidth);\n        }\n        int minHeight = parser.getAttributeIntHex(null, \"min_height\", -1);\n        if (minHeight != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, minHeight);\n        }\n        int maxWidth = parser.getAttributeIntHex(null, \"max_width\", -1);\n        if (maxWidth != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH, maxWidth);\n        }\n        int maxHeight = parser.getAttributeIntHex(null, \"max_height\", -1);\n        if (maxHeight != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, maxHeight);\n        }\n        int category = parser.getAttributeIntHex(null, \"host_category\",\n                AppWidgetProviderInfo.WIDGET_CATEGORY_UNKNOWN);\n        if (category != AppWidgetProviderInfo.WIDGET_CATEGORY_UNKNOWN) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY, category);\n        }\n        return options;\n    }\n\n    @Override\n    public List<String> getWidgetParticipants(int userId) {\n        return mBackupRestoreController.getWidgetParticipants(userId);\n    }\n\n    @Override\n    public byte[] getWidgetState(String packageName, int userId) {\n        return mBackupRestoreController.getWidgetState(packageName, userId);\n    }\n\n    @Override\n    public void systemRestoreStarting(int userId) {\n        mBackupRestoreController.systemRestoreStarting(userId);\n    }\n\n    @Override\n    public void restoreWidgetState(String packageName, byte[] restoredState, int userId) {\n        mBackupRestoreController.restoreWidgetState(packageName, restoredState, userId);\n    }\n\n    @Override\n    public void systemRestoreFinished(int userId) {\n        mBackupRestoreController.systemRestoreFinished(userId);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private AppWidgetProviderInfo createPartialProviderInfo(ProviderId providerId, ResolveInfo ri,\n            Provider provider) {\n        boolean hasXmlDefinition = false;\n        Bundle metaData = ri.activityInfo.metaData;\n        if (metaData == null) {\n            return null;\n        }\n\n        if (provider != null && !TextUtils.isEmpty(provider.infoTag)) {\n            hasXmlDefinition = metaData.getInt(provider.infoTag) != 0;\n        }\n        hasXmlDefinition |= metaData.getInt(AppWidgetManager.META_DATA_APPWIDGET_PROVIDER) != 0;\n\n        if (hasXmlDefinition) {\n            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n            info.provider = providerId.componentName;\n            info.providerInfo = ri.activityInfo;\n            return info;\n        }\n        return null;\n    }\n\n    private static AppWidgetProviderInfo parseAppWidgetProviderInfo(Context context,\n            ProviderId providerId, ActivityInfo activityInfo, String metadataKey) {\n        final PackageManager pm = context.getPackageManager();\n        try (XmlResourceParser parser = activityInfo.loadXmlMetaData(pm, metadataKey)) {\n            if (parser == null) {\n                Slog.w(TAG, \"No \" + metadataKey + \" meta-data for AppWidget provider '\"\n                        + providerId + '\\'');\n                return null;\n            }\n\n            AttributeSet attrs = Xml.asAttributeSet(parser);\n\n            int type;\n            while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                    && type != XmlPullParser.START_TAG) {\n                // drain whitespace, comments, etc.\n            }\n\n            String nodeName = parser.getName();\n            if (!\"appwidget-provider\".equals(nodeName)) {\n                Slog.w(TAG, \"Meta-data does not start with appwidget-provider tag for\"\n                        + \" AppWidget provider \" + providerId.componentName\n                        + \" for user \" + providerId.uid);\n                return null;\n            }\n\n            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n            info.provider = providerId.componentName;\n            info.providerInfo = activityInfo;\n\n            final Resources resources;\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final int userId = UserHandle.getUserId(providerId.uid);\n                final ApplicationInfo app = pm.getApplicationInfoAsUser(activityInfo.packageName,\n                        0, userId);\n                resources = pm.getResourcesForApplication(app);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n\n            TypedArray sa = resources.obtainAttributes(attrs,\n                    com.android.internal.R.styleable.AppWidgetProviderInfo);\n\n            // These dimensions has to be resolved in the application's context.\n            // We simply send back the raw complex data, which will be\n            // converted to dp in {@link AppWidgetManager#getAppWidgetInfo}.\n            TypedValue value = sa\n                    .peekValue(com.android.internal.R.styleable.AppWidgetProviderInfo_minWidth);\n            info.minWidth = value != null ? value.data : 0;\n            value = sa.peekValue(com.android.internal.R.styleable.AppWidgetProviderInfo_minHeight);\n            info.minHeight = value != null ? value.data : 0;\n\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_minResizeWidth);\n            info.minResizeWidth = value != null ? value.data : info.minWidth;\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_minResizeHeight);\n            info.minResizeHeight = value != null ? value.data : info.minHeight;\n\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_maxResizeWidth);\n            info.maxResizeWidth = value != null ? value.data : 0;\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_maxResizeHeight);\n            info.maxResizeHeight = value != null ? value.data : 0;\n\n            info.targetCellWidth = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_targetCellWidth, 0);\n            info.targetCellHeight = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_targetCellHeight, 0);\n\n            info.updatePeriodMillis = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_updatePeriodMillis, 0);\n            info.initialLayout = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_initialLayout, ID_NULL);\n            info.initialKeyguardLayout = sa.getResourceId(com.android.internal.R.styleable.\n                    AppWidgetProviderInfo_initialKeyguardLayout, ID_NULL);\n\n            String className = sa\n                    .getString(com.android.internal.R.styleable.AppWidgetProviderInfo_configure);\n            if (className != null) {\n                info.configure = new ComponentName(providerId.componentName.getPackageName(),\n                        className);\n            }\n            info.label = activityInfo.loadLabel(pm).toString();\n            info.icon = activityInfo.getIconResource();\n            info.previewImage = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_previewImage, ID_NULL);\n            info.previewLayout = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_previewLayout, ID_NULL);\n            info.autoAdvanceViewId = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_autoAdvanceViewId,\n                    View.NO_ID);\n            info.resizeMode = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_resizeMode,\n                    AppWidgetProviderInfo.RESIZE_NONE);\n            info.widgetCategory = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_widgetCategory,\n                    AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN);\n            info.widgetFeatures = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_widgetFeatures, 0);\n            info.descriptionRes = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_description, ID_NULL);\n            sa.recycle();\n            return info;\n        } catch (IOException | PackageManager.NameNotFoundException | XmlPullParserException e) {\n            // Ok to catch Exception here, because anything going wrong because\n            // of what a client process passes to us should not be fatal for the\n            // system process.\n            Slog.w(TAG, \"XML parsing failed for AppWidget provider \"\n                    + providerId.componentName + \" for user \" + providerId.uid, e);\n            return null;\n        }\n    }\n\n    private int getUidForPackage(String packageName, int userId) {\n        PackageInfo pkgInfo = null;\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            pkgInfo = mPackageManager.getPackageInfo(packageName, 0, userId);\n        } catch (RemoteException re) {\n            // Shouldn't happen, local call\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n\n        if (pkgInfo == null || pkgInfo.applicationInfo == null) {\n            return -1;\n        }\n\n        return pkgInfo.applicationInfo.uid;\n    }\n\n    private ActivityInfo getProviderInfo(ComponentName componentName, int userId) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.setComponent(componentName);\n\n        List<ResolveInfo> receivers = queryIntentReceivers(intent, userId);\n        // We are setting component, so there is only one or none.\n        if (!receivers.isEmpty()) {\n            return receivers.get(0).activityInfo;\n        }\n\n        return null;\n    }\n\n    private List<ResolveInfo> queryIntentReceivers(Intent intent, int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            int flags = PackageManager.GET_META_DATA;\n\n            // We really need packages to be around and parsed to know if they\n            // provide widgets.\n            flags |= PackageManager.MATCH_DEBUG_TRIAGED_MISSING;\n\n            // Widget hosts that are non-crypto aware may be hosting widgets\n            // from a profile that is still locked, so let them see those\n            // widgets.\n            if (isProfileWithUnlockedParent(userId)) {\n                flags |= PackageManager.MATCH_DIRECT_BOOT_AWARE\n                        | PackageManager.MATCH_DIRECT_BOOT_UNAWARE;\n            }\n\n            // Widgets referencing shared libraries need to have their\n            // dependencies loaded.\n            flags |= PackageManager.GET_SHARED_LIBRARY_FILES;\n\n            return mPackageManager.queryIntentReceivers(intent,\n                    intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                    flags, userId).getList();\n        } catch (RemoteException re) {\n            return Collections.emptyList();\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    /**\n     * This does not use the usual onUserUnlocked() listener mechanism because it is\n     * invoked at a choreographed point in the middle of the user unlock sequence,\n     * before the boot-completed broadcast is issued and the listeners notified.\n     */\n    void handleUserUnlocked(int userId) {\n        if (isProfileWithLockedParent(userId)) {\n            return;\n        }\n        if (!mUserManager.isUserUnlockingOrUnlocked(userId)) {\n            Slog.w(TAG, \"User \" + userId + \" is no longer unlocked - exiting\");\n            return;\n        }\n        long time = SystemClock.elapsedRealtime();\n        synchronized (mLock) {\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"appwidget ensure\");\n            ensureGroupStateLoadedLocked(userId);\n            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"appwidget reload\");\n            reloadWidgetsMaskedStateForGroup(mSecurityPolicy.getGroupParent(userId));\n            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n\n                // Send broadcast only to the providers of the user.\n                if (provider.getUserId() != userId) {\n                    continue;\n                }\n\n                if (provider.widgets.size() > 0) {\n                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,\n                            \"appwidget init \" + provider.id.componentName.getPackageName());\n                    sendEnableIntentLocked(provider);\n                    int[] appWidgetIds = getWidgetIds(provider.widgets);\n                    sendUpdateIntentLocked(provider, appWidgetIds);\n                    registerForBroadcastsLocked(provider, appWidgetIds);\n                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n                }\n            }\n        }\n        Slog.i(TAG, \"Processing of handleUserUnlocked u\" + userId + \" took \"\n                + (SystemClock.elapsedRealtime() - time) + \" ms\");\n    }\n\n    // only call from initialization -- it assumes that the data structures are all empty\n    private void loadGroupStateLocked(int[] profileIds) {\n        // We can bind the widgets to host and providers only after\n        // reading the host and providers for all users since a widget\n        // can have a host and a provider in different users.\n        List<LoadedWidgetState> loadedWidgets = new ArrayList<>();\n\n        int version = 0;\n\n        final int profileIdCount = profileIds.length;\n        for (int i = 0; i < profileIdCount; i++) {\n            final int profileId = profileIds[i];\n\n            // No file written for this user - nothing to do.\n            AtomicFile file = getSavedStateFile(profileId);\n            try (FileInputStream stream = file.openRead()) {\n                version = readProfileStateFromFileLocked(stream, profileId, loadedWidgets);\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to read state: \" + e);\n            }\n        }\n\n        if (version >= 0) {\n            // Hooke'm up...\n            bindLoadedWidgetsLocked(loadedWidgets);\n\n            // upgrade the database if needed\n            performUpgradeLocked(version);\n        } else {\n            // failed reading, clean up\n            Slog.w(TAG, \"Failed to read state, clearing widgets and hosts.\");\n            clearWidgetsLocked();\n            mHosts.clear();\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                mProviders.get(i).widgets.clear();\n            }\n        }\n    }\n\n    private void bindLoadedWidgetsLocked(List<LoadedWidgetState> loadedWidgets) {\n        final int loadedWidgetCount = loadedWidgets.size();\n        for (int i = loadedWidgetCount - 1; i >= 0; i--) {\n            LoadedWidgetState loadedWidget = loadedWidgets.remove(i);\n            Widget widget = loadedWidget.widget;\n\n            widget.provider = findProviderByTag(loadedWidget.providerTag);\n            if (widget.provider == null) {\n                // This provider is gone. We just let the host figure out\n                // that this happened when it fails to load it.\n                continue;\n            }\n\n            widget.host = findHostByTag(loadedWidget.hostTag);\n            if (widget.host == null) {\n                // This host is gone.\n                continue;\n            }\n\n            widget.provider.widgets.add(widget);\n            widget.host.widgets.add(widget);\n            addWidgetLocked(widget);\n        }\n    }\n\n    private Provider findProviderByTag(int tag) {\n        if (tag < 0) {\n            return null;\n        }\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.tag == tag) {\n                return provider;\n            }\n        }\n        return null;\n    }\n\n    private Host findHostByTag(int tag) {\n        if (tag < 0) {\n            return null;\n        }\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            if (host.tag == tag) {\n                return host;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n     */\n    void addWidgetLocked(Widget widget) {\n        mWidgets.add(widget);\n\n        onWidgetProviderAddedOrChangedLocked(widget);\n    }\n\n    /**\n     * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n     * that have bound widgets.\n     */\n    void onWidgetProviderAddedOrChangedLocked(Widget widget) {\n        if (widget.provider == null) return;\n\n        int userId = widget.provider.getUserId();\n        synchronized (mWidgetPackagesLock) {\n            ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages == null) {\n                mWidgetPackages.put(userId, packages = new ArraySet<String>());\n            }\n            packages.add(widget.provider.id.componentName.getPackageName());\n        }\n\n        // If we are adding a widget it might be for a provider that\n        // is currently masked, if so mask the widget.\n        if (widget.provider.isMaskedLocked()) {\n            maskWidgetsViewsLocked(widget.provider, widget);\n        } else {\n            widget.clearMaskedViewsLocked();\n        }\n    }\n\n    /**\n     * Removes a widget from mWidgets and updates the cache of bound widget provider packages.\n     * If there are other widgets with the same package, leaves it in the cache, otherwise it\n     * removes the associated package from the cache.\n     */\n    void removeWidgetLocked(Widget widget) {\n        mWidgets.remove(widget);\n        onWidgetRemovedLocked(widget);\n        scheduleNotifyAppWidgetRemovedLocked(widget);\n    }\n\n    private void onWidgetRemovedLocked(Widget widget) {\n        if (widget.provider == null) return;\n\n        final int userId = widget.provider.getUserId();\n        final String packageName = widget.provider.id.componentName.getPackageName();\n        synchronized (mWidgetPackagesLock) {\n            ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages == null) {\n                return;\n            }\n            // Check if there is any other widget with the same package name.\n            // Remove packageName if none.\n            final int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget w = mWidgets.get(i);\n                if (w.provider == null) continue;\n                if (w.provider.getUserId() == userId\n                        && packageName.equals(w.provider.id.componentName.getPackageName())) {\n                    return;\n                }\n            }\n            packages.remove(packageName);\n        }\n    }\n\n    /**\n     * Clears all widgets and associated cache of packages with bound widgets.\n     */\n    void clearWidgetsLocked() {\n        mWidgets.clear();\n\n        onWidgetsClearedLocked();\n    }\n\n    private void onWidgetsClearedLocked() {\n        synchronized (mWidgetPackagesLock) {\n            mWidgetPackages.clear();\n        }\n    }\n\n    @Override\n    public boolean isBoundWidgetPackage(String packageName, int userId) {\n        if (Binder.getCallingUid() != Process.SYSTEM_UID) {\n            throw new SecurityException(\"Only the system process can call this\");\n        }\n        synchronized (mWidgetPackagesLock) {\n            final ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages != null) {\n                return packages.contains(packageName);\n            }\n        }\n        return false;\n    }\n\n    private void saveStateLocked(int userId) {\n        tagProvidersAndHosts();\n\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        final int profileCount = profileIds.length;\n        for (int i = 0; i < profileCount; i++) {\n            final int profileId = profileIds[i];\n\n            AtomicFile file = getSavedStateFile(profileId);\n            FileOutputStream stream;\n            try {\n                stream = file.startWrite();\n                if (writeProfileStateToFileLocked(stream, profileId)) {\n                    file.finishWrite(stream);\n                } else {\n                    file.failWrite(stream);\n                    Slog.w(TAG, \"Failed to save state, restoring backup.\");\n                }\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed open state file for write: \" + e);\n            }\n        }\n    }\n\n    private void tagProvidersAndHosts() {\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            provider.tag = i;\n        }\n\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            host.tag = i;\n        }\n    }\n\n    private void clearProvidersAndHostsTagsLocked() {\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            provider.tag = TAG_UNDEFINED;\n        }\n\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            host.tag = TAG_UNDEFINED;\n        }\n    }\n\n    private boolean writeProfileStateToFileLocked(FileOutputStream stream, int userId) {\n        int N;\n\n        try {\n            TypedXmlSerializer out = Xml.resolveSerializer(stream);\n            out.startDocument(null, true);\n            out.startTag(null, \"gs\");\n            out.attributeInt(null, \"version\", CURRENT_VERSION);\n\n            N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                // Save only providers for the user.\n                if (provider.getUserId() != userId) {\n                    continue;\n                }\n                if (provider.shouldBePersisted()) {\n                    serializeProvider(out, provider);\n                }\n            }\n\n            N = mHosts.size();\n            for (int i = 0; i < N; i++) {\n                Host host = mHosts.get(i);\n                // Save only hosts for the user.\n                if (host.getUserId() != userId) {\n                    continue;\n                }\n                serializeHost(out, host);\n            }\n\n            N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n                // Save only widgets hosted by the user.\n                if (widget.host.getUserId() != userId) {\n                    continue;\n                }\n                serializeAppWidget(out, widget, true);\n            }\n\n            Iterator<Pair<Integer, String>> it = mPackagesWithBindWidgetPermission.iterator();\n            while (it.hasNext()) {\n                Pair<Integer, String> binding = it.next();\n                // Save only white listings for the user.\n                if (binding.first != userId) {\n                    continue;\n                }\n                out.startTag(null, \"b\");\n                out.attribute(null, \"packageName\", binding.second);\n                out.endTag(null, \"b\");\n            }\n\n            out.endTag(null, \"gs\");\n            out.endDocument();\n            return true;\n        } catch (IOException e) {\n            Slog.w(TAG, \"Failed to write state: \" + e);\n            return false;\n        }\n    }\n\n    private int readProfileStateFromFileLocked(FileInputStream stream, int userId,\n            List<LoadedWidgetState> outLoadedWidgets) {\n        int version = -1;\n        try {\n            TypedXmlPullParser parser = Xml.resolvePullParser(stream);\n\n            int legacyProviderIndex = -1;\n            int legacyHostIndex = -1;\n            int type;\n            do {\n                type = parser.next();\n                if (type == XmlPullParser.START_TAG) {\n                    String tag = parser.getName();\n                    if (\"gs\".equals(tag)) {\n                        version = parser.getAttributeInt(null, \"version\", 0);\n                    } else if (\"p\".equals(tag)) {\n                        legacyProviderIndex++;\n                        // TODO: do we need to check that this package has the same signature\n                        // as before?\n                        String pkg = parser.getAttributeValue(null, \"pkg\");\n                        String cl = parser.getAttributeValue(null, \"cl\");\n\n                        pkg = getCanonicalPackageName(pkg, cl, userId);\n                        if (pkg == null) {\n                            continue;\n                        }\n\n                        final int uid = getUidForPackage(pkg, userId);\n                        if (uid < 0) {\n                            continue;\n                        }\n\n                        ComponentName componentName = new ComponentName(pkg, cl);\n\n                        ActivityInfo providerInfo = getProviderInfo(componentName, userId);\n                        if (providerInfo == null) {\n                            continue;\n                        }\n\n                        ProviderId providerId = new ProviderId(uid, componentName);\n                        Provider provider = lookupProviderLocked(providerId);\n\n                        if (provider == null && mSafeMode) {\n                            // if we're in safe mode, make a temporary one\n                            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n                            info.provider = providerId.componentName;\n                            info.providerInfo = providerInfo;\n\n                            provider = new Provider();\n                            provider.setPartialInfoLocked(info);\n                            provider.zombie = true;\n                            provider.id = providerId;\n                            mProviders.add(provider);\n                        }\n\n                        final int providerTag = parser.getAttributeIntHex(null, \"tag\",\n                                legacyProviderIndex);\n                        provider.tag = providerTag;\n                        provider.infoTag = parser.getAttributeValue(null, \"info_tag\");\n                    } else if (\"h\".equals(tag)) {\n                        legacyHostIndex++;\n                        Host host = new Host();\n                        // TODO: do we need to check that this package has the same signature\n                        // as before?\n                        String pkg = parser.getAttributeValue(null, \"pkg\");\n\n                        final int uid = getUidForPackage(pkg, userId);\n                        if (uid < 0) {\n                            host.zombie = true;\n                        }\n\n                        if (!host.zombie || mSafeMode) {\n                            // In safe mode, we don't discard the hosts we don't recognize\n                            // so that they're not pruned from our list. Otherwise, we do.\n                            final int hostId = parser.getAttributeIntHex(null, \"id\");\n                            final int hostTag = parser.getAttributeIntHex(null, \"tag\",\n                                    legacyHostIndex);\n\n                            host.tag = hostTag;\n                            host.id = new HostId(uid, hostId, pkg);\n                            mHosts.add(host);\n                        }\n                    } else if (\"b\".equals(tag)) {\n                        String packageName = parser.getAttributeValue(null, \"packageName\");\n                        final int uid = getUidForPackage(packageName, userId);\n                        if (uid >= 0) {\n                            Pair<Integer, String> packageId = Pair.create(userId, packageName);\n                            mPackagesWithBindWidgetPermission.add(packageId);\n                        }\n                    } else if (\"g\".equals(tag)) {\n                        Widget widget = new Widget();\n                        widget.appWidgetId = parser.getAttributeIntHex(null, \"id\");\n                        setMinAppWidgetIdLocked(userId, widget.appWidgetId + 1);\n\n                        // restored ID is allowed to be absent\n                        widget.restoredId = parser.getAttributeIntHex(null, \"rid\", 0);\n                        widget.options = parseWidgetIdOptions(parser);\n\n                        final int hostTag = parser.getAttributeIntHex(null, \"h\");\n                        String providerString = parser.getAttributeValue(null, \"p\");\n                        final int providerTag = (providerString != null)\n                                ? parser.getAttributeIntHex(null, \"p\") : TAG_UNDEFINED;\n\n                        // We can match widgets with hosts and providers only after hosts\n                        // and providers for all users have been loaded since the widget\n                        // host and provider can be in different user profiles.\n                        LoadedWidgetState loadedWidgets = new LoadedWidgetState(widget,\n                                hostTag, providerTag);\n                        outLoadedWidgets.add(loadedWidgets);\n                    }\n                }\n            } while (type != XmlPullParser.END_DOCUMENT);\n        } catch (NullPointerException\n                | NumberFormatException\n                | XmlPullParserException\n                | IOException\n                | IndexOutOfBoundsException e) {\n            Slog.w(TAG, \"failed parsing \" + e);\n            return -1;\n        }\n\n        return version;\n    }\n\n    private void performUpgradeLocked(int fromVersion) {\n        if (fromVersion < CURRENT_VERSION) {\n            Slog.v(TAG, \"Upgrading widget database from \" + fromVersion + \" to \"\n                    + CURRENT_VERSION);\n        }\n\n        int version = fromVersion;\n\n        // Update 1: keyguard moved from package \"android\" to \"com.android.keyguard\"\n        if (version == 0) {\n            HostId oldHostId = new HostId(Process.myUid(),\n                    KEYGUARD_HOST_ID, OLD_KEYGUARD_HOST_PACKAGE);\n\n            Host host = lookupHostLocked(oldHostId);\n            if (host != null) {\n                final int uid = getUidForPackage(NEW_KEYGUARD_HOST_PACKAGE,\n                        UserHandle.USER_SYSTEM);\n                if (uid >= 0) {\n                    host.id = new HostId(uid, KEYGUARD_HOST_ID, NEW_KEYGUARD_HOST_PACKAGE);\n                }\n            }\n\n            version = 1;\n        }\n\n        if (version != CURRENT_VERSION) {\n            throw new IllegalStateException(\"Failed to upgrade widget database\");\n        }\n    }\n\n    private static File getStateFile(int userId) {\n        return new File(Environment.getUserSystemDirectory(userId), STATE_FILENAME);\n    }\n\n    private static AtomicFile getSavedStateFile(int userId) {\n        File dir = Environment.getUserSystemDirectory(userId);\n        File settingsFile = getStateFile(userId);\n        if (!settingsFile.exists() && userId == UserHandle.USER_SYSTEM) {\n            if (!dir.exists()) {\n                dir.mkdirs();\n            }\n            // Migrate old data\n            File oldFile = new File(\"/data/system/\" + STATE_FILENAME);\n            // Method doesn't throw an exception on failure. Ignore any errors\n            // in moving the file (like non-existence)\n            oldFile.renameTo(settingsFile);\n        }\n        return new AtomicFile(settingsFile);\n    }\n\n    void onUserStopped(int userId) {\n        synchronized (mLock) {\n            boolean crossProfileWidgetsChanged = false;\n\n            // Remove widgets that have both host and provider in the user.\n            final int widgetCount = mWidgets.size();\n            for (int i = widgetCount - 1; i >= 0; i--) {\n                Widget widget = mWidgets.get(i);\n\n                final boolean hostInUser = widget.host.getUserId() == userId;\n                final boolean hasProvider = widget.provider != null;\n                final boolean providerInUser = hasProvider && widget.provider.getUserId() == userId;\n\n                // If both host and provider are in the user, just drop the widgets\n                // as we do not want to make host callbacks and provider broadcasts\n                // as the host and the provider will be killed.\n                if (hostInUser && (!hasProvider || providerInUser)) {\n                    removeWidgetLocked(widget);\n                    widget.host.widgets.remove(widget);\n                    widget.host = null;\n                    if (hasProvider) {\n                        widget.provider.widgets.remove(widget);\n                        widget.provider = null;\n                    }\n                }\n            }\n\n            // Remove hosts and notify providers in other profiles.\n            final int hostCount = mHosts.size();\n            for (int i = hostCount - 1; i >= 0; i--) {\n                Host host = mHosts.get(i);\n                if (host.getUserId() == userId) {\n                    crossProfileWidgetsChanged |= !host.widgets.isEmpty();\n                    deleteHostLocked(host);\n                }\n            }\n\n            // Leave the providers present as hosts will show the widgets\n            // masked while the user is stopped.\n\n            // Remove grants for this user.\n            final int grantCount = mPackagesWithBindWidgetPermission.size();\n            for (int i = grantCount - 1; i >= 0; i--) {\n                Pair<Integer, String> packageId = mPackagesWithBindWidgetPermission.valueAt(i);\n                if (packageId.first == userId) {\n                    mPackagesWithBindWidgetPermission.removeAt(i);\n                }\n            }\n\n            // Take a note we no longer have state for this user.\n            final int userIndex = mLoadedUserIds.indexOfKey(userId);\n            if (userIndex >= 0) {\n                mLoadedUserIds.removeAt(userIndex);\n            }\n\n            // Remove the widget id counter.\n            final int nextIdIndex = mNextAppWidgetIds.indexOfKey(userId);\n            if (nextIdIndex >= 0) {\n                mNextAppWidgetIds.removeAt(nextIdIndex);\n            }\n\n            // Save state if removing a profile changed the group state.\n            // Nothing will be saved if the group parent was removed.\n            if (crossProfileWidgetsChanged) {\n                saveGroupStateAsync(userId);\n            }\n        }\n    }\n\n    private void applyResourceOverlaysToWidgetsLocked(Set<String> packageNames, int userId,\n            boolean updateFrameworkRes) {\n        for (int i = 0, N = mProviders.size(); i < N; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.getUserId() != userId) {\n                continue;\n            }\n\n            final String packageName = provider.id.componentName.getPackageName();\n            if (!updateFrameworkRes && !packageNames.contains(packageName)) {\n                continue;\n            }\n\n            ApplicationInfo newAppInfo = null;\n            try {\n                newAppInfo = mPackageManager.getApplicationInfo(packageName,\n                        PackageManager.GET_SHARED_LIBRARY_FILES, userId);\n            } catch (RemoteException e) {\n                Slog.w(TAG, \"Failed to retrieve app info for \" + packageName\n                        + \" userId=\" + userId, e);\n            }\n            if (newAppInfo == null || provider.info == null\n                    || provider.info.providerInfo == null) {\n                continue;\n            }\n            ApplicationInfo oldAppInfo = provider.info.providerInfo.applicationInfo;\n            if (oldAppInfo == null || !newAppInfo.sourceDir.equals(oldAppInfo.sourceDir)) {\n                // Overlay paths are generated against a particular version of an application.\n                // The overlays paths of a newly upgraded application are incompatible with the\n                // old version of the application.\n                continue;\n            }\n\n            // Isolate the changes relating to RROs. The app info must be copied to prevent\n            // affecting other parts of system server that may have cached this app info.\n            oldAppInfo = new ApplicationInfo(oldAppInfo);\n            oldAppInfo.overlayPaths = newAppInfo.overlayPaths.clone();\n            oldAppInfo.resourceDirs = newAppInfo.resourceDirs.clone();\n            provider.info.providerInfo.applicationInfo = oldAppInfo;\n\n            for (int j = 0, M = provider.widgets.size(); j < M; j++) {\n                Widget widget = provider.widgets.get(j);\n                if (widget.views != null) {\n                    widget.views.updateAppInfo(oldAppInfo);\n                }\n                if (widget.maskedViews != null) {\n                    widget.maskedViews.updateAppInfo(oldAppInfo);\n                }\n            }\n        }\n    }\n\n    /**\n     * Updates all providers with the specified package names, and records any providers that were\n     * pruned.\n     *\n     * @return whether any providers were updated\n     */\n    private boolean updateProvidersForPackageLocked(String packageName, int userId,\n            Set<ProviderId> removedProviders) {\n        boolean providersUpdated = false;\n\n        HashSet<ProviderId> keep = new HashSet<>();\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.setPackage(packageName);\n        List<ResolveInfo> broadcastReceivers = queryIntentReceivers(intent, userId);\n\n        // add the missing ones and collect which ones to keep\n        int N = broadcastReceivers == null ? 0 : broadcastReceivers.size();\n        for (int i = 0; i < N; i++) {\n            ResolveInfo ri = broadcastReceivers.get(i);\n            ActivityInfo ai = ri.activityInfo;\n\n            if ((ai.applicationInfo.flags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {\n                continue;\n            }\n\n            if (packageName.equals(ai.packageName)) {\n                ProviderId providerId = new ProviderId(ai.applicationInfo.uid,\n                        new ComponentName(ai.packageName, ai.name));\n\n                Provider provider = lookupProviderLocked(providerId);\n                if (provider == null) {\n                    if (addProviderLocked(ri)) {\n                        keep.add(providerId);\n                        providersUpdated = true;\n                    }\n                } else {\n                    AppWidgetProviderInfo info =\n                            createPartialProviderInfo(providerId, ri, provider);\n                    if (info != null) {\n                        keep.add(providerId);\n                        // Use the new AppWidgetProviderInfo.\n                        provider.setPartialInfoLocked(info);\n                        // If it's enabled\n                        final int M = provider.widgets.size();\n                        if (M > 0) {\n                            int[] appWidgetIds = getWidgetIds(provider.widgets);\n                            // Reschedule for the new updatePeriodMillis (don't worry about handling\n                            // it specially if updatePeriodMillis didn't change because we just sent\n                            // an update, and the next one will be updatePeriodMillis from now).\n                            cancelBroadcastsLocked(provider);\n                            registerForBroadcastsLocked(provider, appWidgetIds);\n                            // If it's currently showing, call back with the new\n                            // AppWidgetProviderInfo.\n                            for (int j = 0; j < M; j++) {\n                                Widget widget = provider.widgets.get(j);\n                                widget.views = null;\n                                scheduleNotifyProviderChangedLocked(widget);\n                            }\n                            // Now that we've told the host, push out an update.\n                            sendUpdateIntentLocked(provider, appWidgetIds);\n                        }\n                    }\n                    providersUpdated = true;\n                }\n            }\n        }\n\n        // prune the ones we don't want to keep\n        N = mProviders.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Provider provider = mProviders.get(i);\n            if (packageName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId\n                    && !keep.contains(provider.id)) {\n                if (removedProviders != null) {\n                    removedProviders.add(provider.id);\n                }\n                deleteProviderLocked(provider);\n                providersUpdated = true;\n            }\n        }\n\n        return providersUpdated;\n    }\n\n    // Remove widgets for provider in userId that are hosted in parentUserId\n    private void removeWidgetsForPackageLocked(String pkgName, int userId, int parentUserId) {\n        final int N = mProviders.size();\n        for (int i = 0; i < N; ++i) {\n            Provider provider = mProviders.get(i);\n            if (pkgName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId\n                    && provider.widgets.size() > 0) {\n                deleteWidgetsLocked(provider, parentUserId);\n            }\n        }\n    }\n\n    private boolean removeProvidersForPackageLocked(String pkgName, int userId) {\n        boolean removed = false;\n\n        final int N = mProviders.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Provider provider = mProviders.get(i);\n            if (pkgName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId) {\n                deleteProviderLocked(provider);\n                removed = true;\n            }\n        }\n        return removed;\n    }\n\n    private boolean removeHostsAndProvidersForPackageLocked(String pkgName, int userId) {\n        boolean removed = removeProvidersForPackageLocked(pkgName, userId);\n\n        // Delete the hosts for this package too\n        // By now, we have removed any AppWidgets that were in any hosts here,\n        // so we don't need to worry about sending DISABLE broadcasts to them.\n        final int N = mHosts.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Host host = mHosts.get(i);\n            if (pkgName.equals(host.id.packageName)\n                    && host.getUserId() == userId) {\n                deleteHostLocked(host);\n                removed = true;\n            }\n        }\n\n        return removed;\n    }\n\n    private String getCanonicalPackageName(String packageName, String className, int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            try {\n                AppGlobals.getPackageManager().getReceiverInfo(new ComponentName(packageName,\n                        className), 0, userId);\n                return packageName;\n            } catch (RemoteException re) {\n                String[] packageNames = mContext.getPackageManager()\n                        .currentToCanonicalPackageNames(new String[]{packageName});\n                if (packageNames != null && packageNames.length > 0) {\n                    return packageNames[0];\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n        return null;\n    }\n\n    private void sendBroadcastAsUser(Intent intent, UserHandle userHandle) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            mContext.sendBroadcastAsUser(intent, userHandle);\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void bindService(Intent intent, ServiceConnection connection,\n            UserHandle userHandle) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.bindServiceAsUser(intent, connection,\n                    Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE,\n                    userHandle);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void unbindService(ServiceConnection connection) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.unbindService(connection);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public void onCrossProfileWidgetProvidersChanged(int userId, List<String> packages) {\n        final int parentId = mSecurityPolicy.getProfileParent(userId);\n        // We care only if the allowlisted package is in a profile of\n        // the group parent as only the parent can add widgets from the\n        // profile and not the other way around.\n        if (parentId != userId) {\n            synchronized (mLock) {\n                boolean providersChanged = false;\n\n                ArraySet<String> previousPackages = new ArraySet<String>();\n                final int providerCount = mProviders.size();\n                for (int i = 0; i < providerCount; ++i) {\n                    Provider provider = mProviders.get(i);\n                    if (provider.getUserId() == userId) {\n                        previousPackages.add(provider.id.componentName.getPackageName());\n                    }\n                }\n\n                final int packageCount = packages.size();\n                for (int i = 0; i < packageCount; i++) {\n                    String packageName = packages.get(i);\n                    previousPackages.remove(packageName);\n                    providersChanged |= updateProvidersForPackageLocked(packageName,\n                            userId, null);\n                }\n\n                // Remove widgets from hosts in parent user for packages not in the allowlist\n                final int removedCount = previousPackages.size();\n                for (int i = 0; i < removedCount; ++i) {\n                    removeWidgetsForPackageLocked(previousPackages.valueAt(i),\n                            userId, parentId);\n                }\n\n                if (providersChanged || removedCount > 0) {\n                    saveGroupStateAsync(userId);\n                    scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n                }\n            }\n        }\n    }\n\n    private boolean isProfileWithLockedParent(int userId) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            UserInfo userInfo = mUserManager.getUserInfo(userId);\n            if (userInfo != null && userInfo.isProfile()) {\n                UserInfo parentInfo = mUserManager.getProfileParent(userId);\n                if (parentInfo != null\n                        && !isUserRunningAndUnlocked(parentInfo.getUserHandle().getIdentifier())) {\n                    return true;\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n        return false;\n    }\n\n    private boolean isProfileWithUnlockedParent(int userId) {\n        UserInfo userInfo = mUserManager.getUserInfo(userId);\n        if (userInfo != null && userInfo.isProfile()) {\n            UserInfo parentInfo = mUserManager.getProfileParent(userId);\n            if (parentInfo != null\n                    && mUserManager.isUserUnlockingOrUnlocked(parentInfo.getUserHandle())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Note an app widget is tapped on. If a app widget is tapped, the underlying app is treated as\n     * foreground so the app can get while-in-use permission.\n     *\n     * @param callingPackage calling app's packageName.\n     * @param appWidgetId App widget id.\n     */\n    @Override\n    public void noteAppWidgetTapped(String callingPackage, int appWidgetId) {\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n        final int callingUid = Binder.getCallingUid();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            // The launcher must be at TOP.\n            final int procState = mActivityManagerInternal.getUidProcessState(callingUid);\n            if (procState > ActivityManager.PROCESS_STATE_TOP) {\n                return;\n            }\n            synchronized (mLock) {\n                final Widget widget = lookupWidgetLocked(appWidgetId, callingUid, callingPackage);\n                if (widget == null) {\n                    return;\n                }\n                final ProviderId providerId = widget.provider.id;\n                final String packageName = providerId.componentName.getPackageName();\n                if (packageName == null) {\n                    return;\n                }\n                final SparseArray<String> uid2PackageName = new SparseArray<String>();\n                uid2PackageName.put(providerId.uid, packageName);\n                mAppOpsManagerInternal.updateAppWidgetVisibility(uid2PackageName, true);\n                mUsageStatsManagerInternal.reportEvent(packageName,\n                        UserHandle.getUserId(providerId.uid), UsageEvents.Event.USER_INTERACTION);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    private final class CallbackHandler extends Handler {\n        public static final int MSG_NOTIFY_UPDATE_APP_WIDGET = 1;\n        public static final int MSG_NOTIFY_PROVIDER_CHANGED = 2;\n        public static final int MSG_NOTIFY_PROVIDERS_CHANGED = 3;\n        public static final int MSG_NOTIFY_VIEW_DATA_CHANGED = 4;\n        public static final int MSG_NOTIFY_APP_WIDGET_REMOVED = 5;\n\n        public CallbackHandler(Looper looper) {\n            super(looper, null, false);\n        }\n\n        @Override\n        public void handleMessage(Message message) {\n            switch (message.what) {\n                case MSG_NOTIFY_UPDATE_APP_WIDGET: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    RemoteViews views = (RemoteViews) args.arg3;\n                    long requestId = (Long) args.arg4;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n\n                    handleNotifyUpdateAppWidget(host, callbacks, appWidgetId, views, requestId);\n                } break;\n\n                case MSG_NOTIFY_PROVIDER_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    AppWidgetProviderInfo info = (AppWidgetProviderInfo)args.arg3;\n                    long requestId = (Long) args.arg4;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n\n                    handleNotifyProviderChanged(host, callbacks, appWidgetId, info, requestId);\n                } break;\n\n                case MSG_NOTIFY_APP_WIDGET_REMOVED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    long requestId = (Long) args.arg3;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n                    handleNotifyAppWidgetRemoved(host, callbacks, appWidgetId, requestId);\n                } break;\n\n                case MSG_NOTIFY_PROVIDERS_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    args.recycle();\n\n                    handleNotifyProvidersChanged(host, callbacks);\n                } break;\n\n                case MSG_NOTIFY_VIEW_DATA_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    long requestId = (Long) args.arg3;\n                    final int appWidgetId = args.argi1;\n                    final int viewId = args.argi2;\n                    args.recycle();\n\n                    handleNotifyAppWidgetViewDataChanged(host, callbacks, appWidgetId, viewId,\n                            requestId);\n                } break;\n            }\n        }\n    }\n\n    private final class SecurityPolicy {\n\n        public boolean isEnabledGroupProfile(int profileId) {\n            final int parentId = UserHandle.getCallingUserId();\n            return isParentOrProfile(parentId, profileId) && isProfileEnabled(profileId);\n        }\n\n        public int[] getEnabledGroupProfileIds(int userId) {\n            final int parentId = getGroupParent(userId);\n\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return mUserManager.getEnabledProfileIds(parentId);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n\n        public void enforceServiceExistsAndRequiresBindRemoteViewsPermission(\n                ComponentName componentName, int userId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                ServiceInfo serviceInfo = mPackageManager.getServiceInfo(componentName,\n                        PackageManager.GET_PERMISSIONS, userId);\n                if (serviceInfo == null) {\n                    throw new SecurityException(\"Service \" + componentName\n                            + \" not installed for user \" + userId);\n                }\n                if (!android.Manifest.permission.BIND_REMOTEVIEWS.equals(serviceInfo.permission)) {\n                    throw new SecurityException(\"Service \" + componentName\n                            + \" in user \" + userId + \"does not require \"\n                            + android.Manifest.permission.BIND_REMOTEVIEWS);\n                }\n            } catch (RemoteException re) {\n                // Local call - shouldn't happen.\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n\n        public void enforceModifyAppWidgetBindPermissions(String packageName) {\n            mContext.enforceCallingPermission(\n                    android.Manifest.permission.MODIFY_APPWIDGET_BIND_PERMISSIONS,\n                    \"hasBindAppWidgetPermission packageName=\" + packageName);\n        }\n\n        public boolean isCallerInstantAppLocked() {\n            final int callingUid =  Binder.getCallingUid();\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final String[] uidPackages = mPackageManager.getPackagesForUid(callingUid);\n                if (!ArrayUtils.isEmpty(uidPackages)) {\n                    return mPackageManager.isInstantApp(uidPackages[0],\n                            UserHandle.getUserId(callingUid));\n                }\n            } catch (RemoteException e) {\n                /* ignore - same process */\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return false;\n        }\n\n        public boolean isInstantAppLocked(String packageName, int userId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return mPackageManager.isInstantApp(packageName, userId);\n            } catch (RemoteException e) {\n                /* ignore - same process */\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return false;\n        }\n\n        public void enforceCallFromPackage(String packageName) {\n            mAppOpsManager.checkPackage(Binder.getCallingUid(), packageName);\n        }\n\n        public boolean hasCallerBindPermissionOrBindWhiteListedLocked(String packageName) {\n            try {\n                mContext.enforceCallingOrSelfPermission(\n                        android.Manifest.permission.BIND_APPWIDGET, null);\n            } catch (SecurityException se) {\n                if (!isCallerBindAppWidgetWhiteListedLocked(packageName)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private boolean isCallerBindAppWidgetWhiteListedLocked(String packageName) {\n            final int userId = UserHandle.getCallingUserId();\n            final int packageUid = getUidForPackage(packageName, userId);\n            if (packageUid < 0) {\n                throw new IllegalArgumentException(\"No package \" + packageName\n                        + \" for user \" + userId);\n            }\n            synchronized (mLock) {\n                ensureGroupStateLoadedLocked(userId);\n\n                Pair<Integer, String> packageId = Pair.create(userId, packageName);\n                if (mPackagesWithBindWidgetPermission.contains(packageId)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        public boolean canAccessAppWidget(Widget widget, int uid, String packageName) {\n            if (isHostInPackageForUid(widget.host, uid, packageName)) {\n                // Apps hosting the AppWidget have access to it.\n                return true;\n            }\n            if (isProviderInPackageForUid(widget.provider, uid, packageName)) {\n                // Apps providing the AppWidget have access to it.\n                return true;\n            }\n            if (isHostAccessingProvider(widget.host, widget.provider, uid, packageName)) {\n                // Apps hosting the AppWidget get to bind to a remote view service in the provider.\n                return true;\n            }\n            final int userId = UserHandle.getUserId(uid);\n            if ((widget.host.getUserId() == userId || (widget.provider != null\n                    && widget.provider.getUserId() == userId))\n                && mContext.checkCallingPermission(android.Manifest.permission.BIND_APPWIDGET)\n                    == PackageManager.PERMISSION_GRANTED) {\n                // Apps that run in the same user as either the host or the provider and\n                // have the bind widget permission have access to the widget.\n                return true;\n            }\n            return false;\n        }\n\n        private boolean isParentOrProfile(int parentId, int profileId) {\n            if (parentId == profileId) {\n                return true;\n            }\n            return getProfileParent(profileId) == parentId;\n        }\n\n        public boolean isProviderInCallerOrInProfileAndWhitelListed(String packageName,\n                int profileId) {\n            final int callerId = UserHandle.getCallingUserId();\n            if (profileId == callerId) {\n                return true;\n            }\n            final int parentId = getProfileParent(profileId);\n            if (parentId != callerId) {\n                return false;\n            }\n            return isProviderWhiteListed(packageName, profileId);\n        }\n\n        public boolean isProviderWhiteListed(String packageName, int profileId) {\n            // If the policy manager is not available on the device we deny it all.\n            if (mDevicePolicyManagerInternal == null) {\n                return false;\n            }\n\n            List<String> crossProfilePackages = mDevicePolicyManagerInternal\n                    .getCrossProfileWidgetProviders(profileId);\n\n            return crossProfilePackages.contains(packageName);\n        }\n\n        public int getProfileParent(int profileId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                UserInfo parent = mUserManager.getProfileParent(profileId);\n                if (parent != null) {\n                    return parent.getUserHandle().getIdentifier();\n                }\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return UNKNOWN_USER_ID;\n        }\n\n        public int getGroupParent(int profileId) {\n            final int parentId = mSecurityPolicy.getProfileParent(profileId);\n            return (parentId != UNKNOWN_USER_ID) ? parentId : profileId;\n        }\n\n        public boolean isHostInPackageForUid(Host host, int uid, String packageName) {\n            return host.id.uid == uid && host.id.packageName.equals(packageName);\n        }\n\n        public boolean isProviderInPackageForUid(Provider provider, int uid,\n                String packageName) {\n            // Packages providing the AppWidget have access to it.\n            return provider != null && provider.id.uid == uid\n                    && provider.id.componentName.getPackageName().equals(packageName);\n        }\n\n        public boolean isHostAccessingProvider(Host host, Provider provider, int uid,\n                String packageName) {\n            // The host creates a package context to bind to remote views service in the provider.\n            return host.id.uid == uid && provider != null\n                    && provider.id.componentName.getPackageName().equals(packageName);\n        }\n\n        private boolean isProfileEnabled(int profileId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                UserInfo userInfo = mUserManager.getUserInfo(profileId);\n                if (userInfo == null || !userInfo.isEnabled()) {\n                    return false;\n                }\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return true;\n        }\n    }\n\n    private static final class Provider {\n\n        ProviderId id;\n        AppWidgetProviderInfo info;\n        ArrayList<Widget> widgets = new ArrayList<>();\n        PendingIntent broadcast;\n        String infoTag;\n\n        boolean zombie; // if we're in safe mode, don't prune this just because nobody references it\n\n        boolean maskedByLockedProfile;\n        boolean maskedByQuietProfile;\n        boolean maskedBySuspendedPackage;\n\n        boolean mInfoParsed = false;\n\n        int tag = TAG_UNDEFINED; // for use while saving state (the index)\n\n        public int getUserId() {\n            return UserHandle.getUserId(id.uid);\n        }\n\n        public boolean isInPackageForUser(String packageName, int userId) {\n            return getUserId() == userId\n                    && id.componentName.getPackageName().equals(packageName);\n        }\n\n        // is there an instance of this provider hosted by the given app?\n        public boolean hostedByPackageForUser(String packageName, int userId) {\n            final int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = widgets.get(i);\n                if (packageName.equals(widget.host.id.packageName)\n                        && widget.host.getUserId() == userId) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @GuardedBy(\"mLock\")\n        public AppWidgetProviderInfo getInfoLocked(Context context) {\n            if (!mInfoParsed) {\n                // parse\n                if (!zombie) {\n                    AppWidgetProviderInfo newInfo = null;\n                    if (!TextUtils.isEmpty(infoTag)) {\n                        newInfo = parseAppWidgetProviderInfo(\n                                context, id, info.providerInfo, infoTag);\n                    }\n                    if (newInfo == null) {\n                        newInfo = parseAppWidgetProviderInfo(context, id, info.providerInfo,\n                                AppWidgetManager.META_DATA_APPWIDGET_PROVIDER);\n                    }\n                    if (newInfo != null) {\n                        info = newInfo;\n                    }\n                }\n                mInfoParsed = true;\n            }\n            return info;\n        }\n\n        /**\n         * Returns the last updated AppWidgetProviderInfo for this provider. This info may not\n         * be completely parsed and only contain placeHolder information like\n         * {@link AppWidgetProviderInfo#providerInfo}\n         */\n        @GuardedBy(\"mLock\")\n        public AppWidgetProviderInfo getPartialInfoLocked() {\n            return info;\n        }\n\n        @GuardedBy(\"mLock\")\n        public void setPartialInfoLocked(AppWidgetProviderInfo info) {\n            this.info = info;\n            mInfoParsed = false;\n        }\n\n        @GuardedBy(\"mLock\")\n        public void setInfoLocked(AppWidgetProviderInfo info) {\n            this.info = info;\n            mInfoParsed = true;\n        }\n\n        @Override\n        public String toString() {\n            return \"Provider{\" + id + (zombie ? \" Z\" : \"\") + '}';\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedByQuietProfileLocked(boolean masked) {\n            boolean oldState = maskedByQuietProfile;\n            maskedByQuietProfile = masked;\n            return masked != oldState;\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedByLockedProfileLocked(boolean masked) {\n            boolean oldState = maskedByLockedProfile;\n            maskedByLockedProfile = masked;\n            return masked != oldState;\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedBySuspendedPackageLocked(boolean masked) {\n            boolean oldState = maskedBySuspendedPackage;\n            maskedBySuspendedPackage = masked;\n            return masked != oldState;\n        }\n\n        public boolean isMaskedLocked() {\n            return maskedByQuietProfile || maskedByLockedProfile || maskedBySuspendedPackage;\n        }\n\n        public boolean shouldBePersisted() {\n            return !widgets.isEmpty() || !TextUtils.isEmpty(infoTag);\n        }\n    }\n\n    private static final class ProviderId {\n        final int uid;\n        final ComponentName componentName;\n\n        private ProviderId(int uid, ComponentName componentName) {\n            this.uid = uid;\n            this.componentName = componentName;\n        }\n\n        public UserHandle getProfile() {\n            return UserHandle.getUserHandleForUid(uid);\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            ProviderId other = (ProviderId) obj;\n            if (uid != other.uid)  {\n                return false;\n            }\n            if (componentName == null) {\n                if (other.componentName != null) {\n                    return false;\n                }\n            } else if (!componentName.equals(other.componentName)) {\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = uid;\n            result = 31 * result + ((componentName != null)\n                    ? componentName.hashCode() : 0);\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return \"ProviderId{user:\" + UserHandle.getUserId(uid) + \", app:\"\n                    + UserHandle.getAppId(uid) + \", cmp:\" + componentName + '}';\n        }\n    }\n\n    private static final class Host {\n        HostId id;\n        ArrayList<Widget> widgets = new ArrayList<>();\n        IAppWidgetHost callbacks;\n        boolean zombie; // if we're in safe mode, don't prune this just because nobody references it\n\n        int tag = TAG_UNDEFINED; // for use while saving state (the index)\n        // Sequence no for the last update successfully sent. This is updated whenever a\n        // widget update is successfully sent to the host callbacks. As all new/undelivered updates\n        // will have sequenceNo greater than this, all those updates will be sent when the host\n        // callbacks are attached again.\n        long lastWidgetUpdateSequenceNo;\n\n        public int getUserId() {\n            return UserHandle.getUserId(id.uid);\n        }\n\n        public boolean isInPackageForUser(String packageName, int userId) {\n            return getUserId() == userId && id.packageName.equals(packageName);\n        }\n\n        private boolean hostsPackageForUser(String pkg, int userId) {\n            final int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = widgets.get(i).provider;\n                if (provider != null && provider.getUserId() == userId\n                        && pkg.equals(provider.id.componentName.getPackageName())) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /**\n         * Adds all pending updates in {@param outUpdates} keys by the update time.\n         */\n        public void getPendingUpdatesForIdLocked(Context context, int appWidgetId,\n                LongSparseArray<PendingHostUpdate> outUpdates) {\n            long updateSequenceNo = lastWidgetUpdateSequenceNo;\n            int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = widgets.get(i);\n                if (widget.appWidgetId == appWidgetId) {\n                    for (int j = widget.updateSequenceNos.size() - 1; j >= 0; j--) {\n                        long requestId = widget.updateSequenceNos.valueAt(j);\n                        if (requestId <= updateSequenceNo) {\n                            continue;\n                        }\n                        int id = widget.updateSequenceNos.keyAt(j);\n                        final PendingHostUpdate update;\n                        switch (id) {\n                            case ID_PROVIDER_CHANGED:\n                                update = PendingHostUpdate.providerChanged(\n                                        appWidgetId, widget.provider.getInfoLocked(context));\n                                break;\n                            case ID_VIEWS_UPDATE:\n                                update = PendingHostUpdate.updateAppWidget(appWidgetId,\n                                        cloneIfLocalBinder(widget.getEffectiveViewsLocked()));\n                                break;\n                            default:\n                                update = PendingHostUpdate.viewDataChanged(appWidgetId, id);\n                        }\n                        outUpdates.put(requestId, update);\n                    }\n                    return;\n                }\n            }\n            outUpdates.put(lastWidgetUpdateSequenceNo,\n                    PendingHostUpdate.appWidgetRemoved(appWidgetId));\n        }\n\n        public SparseArray<String> getWidgetUids() {\n            final SparseArray<String> uids = new SparseArray<>();\n            for (int i = widgets.size() - 1; i >= 0; i--) {\n                final Widget widget = widgets.get(i);\n                final ProviderId providerId = widget.provider.id;\n                uids.put(providerId.uid, providerId.componentName.getPackageName());\n            }\n            return uids;\n        }\n\n        @Override\n        public String toString() {\n            return \"Host{\" + id + (zombie ? \" Z\" : \"\") + '}';\n        }\n    }\n\n    private static final class HostId {\n        final int uid;\n        final int hostId;\n        final String packageName;\n\n        public HostId(int uid, int hostId, String packageName) {\n            this.uid = uid;\n            this.hostId = hostId;\n            this.packageName = packageName;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            HostId other = (HostId) obj;\n            if (uid != other.uid)  {\n                return false;\n            }\n            if (hostId != other.hostId) {\n                return false;\n            }\n            if (packageName == null) {\n                if (other.packageName != null) {\n                    return false;\n                }\n            } else if (!packageName.equals(other.packageName)) {\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = uid;\n            result = 31 * result + hostId;\n            result = 31 * result + ((packageName != null)\n                    ? packageName.hashCode() : 0);\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return \"HostId{user:\" + UserHandle.getUserId(uid) + \", app:\"\n                    + UserHandle.getAppId(uid) + \", hostId:\" + hostId\n                    + \", pkg:\" + packageName + '}';\n        }\n    }\n\n    // These can be any constants that would not collide with a resource id.\n    private static final int ID_VIEWS_UPDATE = 0;\n    private static final int ID_PROVIDER_CHANGED = 1;\n\n    private static final class Widget {\n        int appWidgetId;\n        int restoredId;  // tracking & remapping any restored state\n        Provider provider;\n        RemoteViews views;\n        RemoteViews maskedViews;\n        Bundle options;\n        Host host;\n        // Map of request type to updateSequenceNo.\n        SparseLongArray updateSequenceNos = new SparseLongArray(2);\n\n        @Override\n        public String toString() {\n            return \"AppWidgetId{\" + appWidgetId + ':' + host + ':' + provider + '}';\n        }\n\n        private boolean replaceWithMaskedViewsLocked(RemoteViews views) {\n            maskedViews = views;\n            return true;\n        }\n\n        private boolean clearMaskedViewsLocked() {\n            if (maskedViews != null) {\n                maskedViews = null;\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        public RemoteViews getEffectiveViewsLocked() {\n            return maskedViews != null ? maskedViews : views;\n        }\n    }\n\n    private class LoadedWidgetState {\n        final Widget widget;\n        final int hostTag;\n        final int providerTag;\n\n        public LoadedWidgetState(Widget widget, int hostTag, int providerTag) {\n            this.widget = widget;\n            this.hostTag = hostTag;\n            this.providerTag = providerTag;\n        }\n    }\n\n    private final class SaveStateRunnable implements Runnable {\n        final int mUserId;\n\n        public SaveStateRunnable(int userId) {\n            mUserId = userId;\n        }\n\n        @Override\n        public void run() {\n            synchronized (mLock) {\n                // No need to enforce unlocked state when there is no caller. User can be in the\n                // stopping state or removed by the time the message is processed\n                ensureGroupStateLoadedLocked(mUserId, false /* enforceUserUnlockingOrUnlocked */ );\n                saveStateLocked(mUserId);\n            }\n        }\n    }\n\n    /**\n     * This class encapsulates the backup and restore logic for a user group state.\n     */\n    private final class BackupRestoreController {\n        private static final String TAG = \"BackupRestoreController\";\n\n        private static final boolean DEBUG = true;\n\n        // Version of backed-up widget state.\n        private static final int WIDGET_STATE_VERSION = 2;\n\n        // We need to make sure to wipe the pre-restore widget state only once for\n        // a given package.  Keep track of what we've done so far here; the list is\n        // cleared at the start of every system restore pass, but preserved through\n        // any install-time restore operations.\n        private final HashSet<String> mPrunedApps = new HashSet<>();\n\n        private final HashMap<Provider, ArrayList<RestoreUpdateRecord>> mUpdatesByProvider =\n                new HashMap<>();\n        private final HashMap<Host, ArrayList<RestoreUpdateRecord>> mUpdatesByHost =\n                new HashMap<>();\n\n        @GuardedBy(\"mLock\")\n        private boolean mHasSystemRestoreFinished;\n\n        public List<String> getWidgetParticipants(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Getting widget participants for user: \" + userId);\n            }\n\n            HashSet<String> packages = new HashSet<>();\n            synchronized (mLock) {\n                final int N = mWidgets.size();\n                for (int i = 0; i < N; i++) {\n                    Widget widget = mWidgets.get(i);\n\n                    // Skip cross-user widgets.\n                    if (!isProviderAndHostInUser(widget, userId)) {\n                        continue;\n                    }\n\n                    packages.add(widget.host.id.packageName);\n                    Provider provider = widget.provider;\n                    if (provider != null) {\n                        packages.add(provider.id.componentName.getPackageName());\n                    }\n                }\n            }\n            return new ArrayList<>(packages);\n        }\n\n        public byte[] getWidgetState(String backedupPackage, int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Getting widget state for user: \" + userId);\n            }\n\n            ByteArrayOutputStream stream = new ByteArrayOutputStream();\n            synchronized (mLock) {\n                // Preflight: if this app neither hosts nor provides any live widgets\n                // we have no work to do.\n                if (!packageNeedsWidgetBackupLocked(backedupPackage, userId)) {\n                    return null;\n                }\n\n                try {\n                    TypedXmlSerializer out = Xml.newFastSerializer();\n                    out.setOutput(stream, StandardCharsets.UTF_8.name());\n                    out.startDocument(null, true);\n                    out.startTag(null, \"ws\");      // widget state\n                    out.attributeInt(null, \"version\", WIDGET_STATE_VERSION);\n                    out.attribute(null, \"pkg\", backedupPackage);\n\n                    // Remember all the providers that are currently hosted or published\n                    // by this package: that is, all of the entities related to this app\n                    // which will need to be told about id remapping.\n                    int index = 0;\n                    int N = mProviders.size();\n                    for (int i = 0; i < N; i++) {\n                        Provider provider = mProviders.get(i);\n\n                        if (provider.shouldBePersisted()\n                                && (provider.isInPackageForUser(backedupPackage, userId)\n                                || provider.hostedByPackageForUser(backedupPackage, userId))) {\n                            provider.tag = index;\n                            serializeProvider(out, provider);\n                            index++;\n                        }\n                    }\n\n                    N = mHosts.size();\n                    index = 0;\n                    for (int i = 0; i < N; i++) {\n                        Host host = mHosts.get(i);\n\n                        if (!host.widgets.isEmpty()\n                                && (host.isInPackageForUser(backedupPackage, userId)\n                                || host.hostsPackageForUser(backedupPackage, userId))) {\n                            host.tag = index;\n                            serializeHost(out, host);\n                            index++;\n                        }\n                    }\n\n                    // All widget instances involving this package,\n                    // either as host or as provider\n                    N = mWidgets.size();\n                    for (int i = 0; i < N; i++) {\n                        Widget widget = mWidgets.get(i);\n\n                        Provider provider = widget.provider;\n                        if (widget.host.isInPackageForUser(backedupPackage, userId)\n                                || (provider != null\n                                &&  provider.isInPackageForUser(backedupPackage, userId))) {\n                            serializeAppWidget(out, widget, false);\n                        }\n                    }\n\n                    out.endTag(null, \"ws\");\n                    out.endDocument();\n                } catch (IOException e) {\n                    Slog.w(TAG, \"Unable to save widget state for \" + backedupPackage);\n                    return null;\n                }\n            }\n\n            return stream.toByteArray();\n        }\n\n        public void systemRestoreStarting(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"System restore starting for user: \" + userId);\n            }\n\n            synchronized (mLock) {\n                mHasSystemRestoreFinished = false;\n                // We're starting a new \"system\" restore operation, so any widget restore\n                // state that we see from here on is intended to replace the current\n                // widget configuration of any/all of the affected apps.\n                mPrunedApps.clear();\n                mUpdatesByProvider.clear();\n                mUpdatesByHost.clear();\n            }\n        }\n\n        public void restoreWidgetState(String packageName, byte[] restoredState, int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Restoring widget state for user:\" + userId\n                        + \" package: \" + packageName);\n            }\n\n            ByteArrayInputStream stream = new ByteArrayInputStream(restoredState);\n            try {\n                // Providers mentioned in the widget dataset by ordinal\n                ArrayList<Provider> restoredProviders = new ArrayList<>();\n\n                // Hosts mentioned in the widget dataset by ordinal\n                ArrayList<Host> restoredHosts = new ArrayList<>();\n\n                TypedXmlPullParser parser = Xml.newFastPullParser();\n                parser.setInput(stream, StandardCharsets.UTF_8.name());\n\n                synchronized (mLock) {\n                    int type;\n                    do {\n                        type = parser.next();\n                        if (type == XmlPullParser.START_TAG) {\n                            final String tag = parser.getName();\n                            if (\"ws\".equals(tag)) {\n                                final int versionNumber = parser.getAttributeInt(null, \"version\");\n                                if (versionNumber > WIDGET_STATE_VERSION) {\n                                    Slog.w(TAG, \"Unable to process state version \" + versionNumber);\n                                    return;\n                                }\n\n                                // TODO: fix up w.r.t. canonical vs current package names\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n                                if (!packageName.equals(pkg)) {\n                                    Slog.w(TAG, \"Package mismatch in ws\");\n                                    return;\n                                }\n                            } else if (\"p\".equals(tag)) {\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n                                String cl = parser.getAttributeValue(null, \"cl\");\n\n                                // hostedProviders index will match 'p' attribute in widget's\n                                // entry in the xml file being restored\n                                // If there's no live entry for this provider, add an inactive one\n                                // so that widget IDs referring to them can be properly allocated\n\n                                // Backup and resotre only for the parent profile.\n                                ComponentName componentName = new ComponentName(pkg, cl);\n\n                                Provider p = findProviderLocked(componentName, userId);\n                                if (p == null) {\n                                    AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n                                    info.provider = componentName;\n\n                                    p = new Provider();\n                                    p.id = new ProviderId(UNKNOWN_UID, componentName);\n                                    p.setPartialInfoLocked(info);\n                                    p.zombie = true;\n                                    mProviders.add(p);\n                                }\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   provider \" + p.id);\n                                }\n                                restoredProviders.add(p);\n                            } else if (\"h\".equals(tag)) {\n                                // The host app may not yet exist on the device.  If it's here we\n                                // just use the existing Host entry, otherwise we create a\n                                // placeholder whose uid will be fixed up at PACKAGE_ADDED time.\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n\n                                final int uid = getUidForPackage(pkg, userId);\n                                final int hostId = parser.getAttributeIntHex(null, \"id\");\n\n                                HostId id = new HostId(uid, hostId, pkg);\n                                Host h = lookupOrAddHostLocked(id);\n                                restoredHosts.add(h);\n\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   host[\" + restoredHosts.size()\n                                            + \"]: {\" + h.id + \"}\");\n                                }\n                            } else if (\"g\".equals(tag)) {\n                                int restoredId = parser.getAttributeIntHex(null, \"id\");\n                                int hostIndex = parser.getAttributeIntHex(null, \"h\");\n                                Host host = restoredHosts.get(hostIndex);\n                                Provider p = null;\n                                int which = parser.getAttributeIntHex(null, \"p\", -1);\n                                if (which != -1) {\n                                    // could have been null if the app had allocated an id\n                                    // but not yet established a binding under that id\n                                    p = restoredProviders.get(which);\n                                }\n\n                                // We'll be restoring widget state for both the host and\n                                // provider sides of this widget ID, so make sure we are\n                                // beginning from a clean slate on both fronts.\n                                pruneWidgetStateLocked(host.id.packageName, userId);\n                                if (p != null) {\n                                    pruneWidgetStateLocked(p.id.componentName.getPackageName(),\n                                            userId);\n                                }\n\n                                // Have we heard about this ancestral widget instance before?\n                                Widget id = findRestoredWidgetLocked(restoredId, host, p);\n                                if (id == null) {\n                                    id = new Widget();\n                                    id.appWidgetId = incrementAndGetAppWidgetIdLocked(userId);\n                                    id.restoredId = restoredId;\n                                    id.options = parseWidgetIdOptions(parser);\n                                    id.host = host;\n                                    id.host.widgets.add(id);\n                                    id.provider = p;\n                                    if (id.provider != null) {\n                                        id.provider.widgets.add(id);\n                                    }\n                                    if (DEBUG) {\n                                        Slog.i(TAG, \"New restored id \" + restoredId\n                                                + \" now \" + id);\n                                    }\n                                    addWidgetLocked(id);\n                                }\n                                if (id.provider != null\n                                        && id.provider.getPartialInfoLocked() != null) {\n                                    stashProviderRestoreUpdateLocked(id.provider,\n                                            restoredId, id.appWidgetId);\n                                } else {\n                                    Slog.w(TAG, \"Missing provider for restored widget \" + id);\n                                }\n                                stashHostRestoreUpdateLocked(id.host, restoredId, id.appWidgetId);\n\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   instance: \" + restoredId\n                                            + \" -> \" + id.appWidgetId\n                                            + \" :: p=\" + id.provider);\n                                }\n                            }\n                        }\n                    } while (type != XmlPullParser.END_DOCUMENT);\n\n                    // We've updated our own bookkeeping.  We'll need to notify the hosts and\n                    // providers about the changes, but we can't do that yet because the restore\n                    // target is not necessarily fully live at this moment.  Set aside the\n                    // information for now; the backup manager will call us once more at the\n                    // end of the process when all of the targets are in a known state, and we\n                    // will update at that point.\n                }\n            } catch (XmlPullParserException | IOException e) {\n                Slog.w(TAG, \"Unable to restore widget state for \" + packageName);\n            } finally {\n                saveGroupStateAsync(userId);\n            }\n        }\n\n        // Called once following the conclusion of a system restore operation.  This is when we\n        // send out updates to apps involved in widget-state restore telling them about\n        // the new widget ID space.  Apps that are not yet installed will be notifed when they are.\n        public void systemRestoreFinished(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"systemRestoreFinished for \" + userId);\n            }\n            synchronized (mLock) {\n                mHasSystemRestoreFinished = true;\n                maybeSendWidgetRestoreBroadcastsLocked(userId);\n            }\n        }\n\n        // Called when widget components (hosts or providers) are added or changed.  If system\n        // restore has completed, we use this opportunity to tell the apps to update to the new\n        // widget ID space.  If system restore is still in progress, we delay the updates until\n        // the end, to allow all participants to restore their state before updating widget IDs.\n        public void widgetComponentsChanged(int userId) {\n            synchronized (mLock) {\n                if (mHasSystemRestoreFinished) {\n                    maybeSendWidgetRestoreBroadcastsLocked(userId);\n                }\n            }\n        }\n\n        // Called following the conclusion of a restore operation and when widget components\n        // are added or changed.  This is when we send out updates to apps involved in widget-state\n        // restore telling them about the new widget ID space.\n        @GuardedBy(\"mLock\")\n        private void maybeSendWidgetRestoreBroadcastsLocked(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"maybeSendWidgetRestoreBroadcasts for \" + userId);\n            }\n\n            final UserHandle userHandle = new UserHandle(userId);\n            // Build the providers' broadcasts and send them off\n            Set<Map.Entry<Provider, ArrayList<RestoreUpdateRecord>>> providerEntries\n                    = mUpdatesByProvider.entrySet();\n            for (Map.Entry<Provider, ArrayList<RestoreUpdateRecord>> e : providerEntries) {\n                // For each provider there's a list of affected IDs\n                Provider provider = e.getKey();\n                if (provider.zombie) {\n                    // Provider not installed, we can't send them broadcasts yet.\n                    // We'll be called again when the provider is installed.\n                    continue;\n                }\n                ArrayList<RestoreUpdateRecord> updates = e.getValue();\n                final int pending = countPendingUpdates(updates);\n                if (DEBUG) {\n                    Slog.i(TAG, \"Provider \" + provider + \" pending: \" + pending);\n                }\n                if (pending > 0) {\n                    int[] oldIds = new int[pending];\n                    int[] newIds = new int[pending];\n                    final int N = updates.size();\n                    int nextPending = 0;\n                    for (int i = 0; i < N; i++) {\n                        RestoreUpdateRecord r = updates.get(i);\n                        if (!r.notified) {\n                            r.notified = true;\n                            oldIds[nextPending] = r.oldId;\n                            newIds[nextPending] = r.newId;\n                            nextPending++;\n                            if (DEBUG) {\n                                Slog.i(TAG, \"   \" + r.oldId + \" => \" + r.newId);\n                            }\n                        }\n                    }\n                    sendWidgetRestoreBroadcastLocked(\n                            AppWidgetManager.ACTION_APPWIDGET_RESTORED,\n                            provider, null, oldIds, newIds, userHandle);\n                }\n            }\n\n            // same thing per host\n            Set<Map.Entry<Host, ArrayList<RestoreUpdateRecord>>> hostEntries\n                    = mUpdatesByHost.entrySet();\n            for (Map.Entry<Host, ArrayList<RestoreUpdateRecord>> e : hostEntries) {\n                Host host = e.getKey();\n                if (host.id.uid != UNKNOWN_UID) {\n                    ArrayList<RestoreUpdateRecord> updates = e.getValue();\n                    final int pending = countPendingUpdates(updates);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Host \" + host + \" pending: \" + pending);\n                    }\n                    if (pending > 0) {\n                        int[] oldIds = new int[pending];\n                        int[] newIds = new int[pending];\n                        final int N = updates.size();\n                        int nextPending = 0;\n                        for (int i = 0; i < N; i++) {\n                            RestoreUpdateRecord r = updates.get(i);\n                            if (!r.notified) {\n                                r.notified = true;\n                                oldIds[nextPending] = r.oldId;\n                                newIds[nextPending] = r.newId;\n                                nextPending++;\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   \" + r.oldId + \" => \" + r.newId);\n                                }\n                            }\n                        }\n                        sendWidgetRestoreBroadcastLocked(\n                                AppWidgetManager.ACTION_APPWIDGET_HOST_RESTORED,\n                                null, host, oldIds, newIds, userHandle);\n                    }\n                }\n            }\n        }\n\n        private Provider findProviderLocked(ComponentName componentName, int userId) {\n            final int providerCount = mProviders.size();\n            for (int i = 0; i < providerCount; i++) {\n                Provider provider = mProviders.get(i);\n                if (provider.getUserId() == userId\n                        && provider.id.componentName.equals(componentName)) {\n                    return provider;\n                }\n            }\n            return null;\n        }\n\n        private Widget findRestoredWidgetLocked(int restoredId, Host host, Provider p) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Find restored widget: id=\" + restoredId\n                        + \" host=\" + host + \" provider=\" + p);\n            }\n\n            if (p == null || host == null) {\n                return null;\n            }\n\n            final int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n                if (widget.restoredId == restoredId\n                        && widget.host.id.equals(host.id)\n                        && widget.provider.id.equals(p.id)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"   Found at \" + i + \" : \" + widget);\n                    }\n                    return widget;\n                }\n            }\n            return null;\n        }\n\n        private boolean packageNeedsWidgetBackupLocked(String packageName, int userId) {\n            int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n\n                // Skip cross-user widgets.\n                if (!isProviderAndHostInUser(widget, userId)) {\n                    continue;\n                }\n\n                if (widget.host.isInPackageForUser(packageName, userId)) {\n                    // this package is hosting widgets, so it knows widget IDs.\n                    return true;\n                }\n\n                Provider provider = widget.provider;\n                if (provider != null && provider.isInPackageForUser(packageName, userId)) {\n                    // someone is hosting this app's widgets, so it knows widget IDs.\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private void stashProviderRestoreUpdateLocked(Provider provider, int oldId, int newId) {\n            ArrayList<RestoreUpdateRecord> r = mUpdatesByProvider.get(provider);\n            if (r == null) {\n                r = new ArrayList<>();\n                mUpdatesByProvider.put(provider, r);\n            } else {\n                // don't duplicate\n                if (alreadyStashed(r, oldId, newId)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"ID remap \" + oldId + \" -> \" + newId\n                                + \" already stashed for \" + provider);\n                    }\n                    return;\n                }\n            }\n            r.add(new RestoreUpdateRecord(oldId, newId));\n        }\n\n        private boolean alreadyStashed(ArrayList<RestoreUpdateRecord> stash,\n                final int oldId, final int newId) {\n            final int N = stash.size();\n            for (int i = 0; i < N; i++) {\n                RestoreUpdateRecord r = stash.get(i);\n                if (r.oldId == oldId && r.newId == newId) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private void stashHostRestoreUpdateLocked(Host host, int oldId, int newId) {\n            ArrayList<RestoreUpdateRecord> r = mUpdatesByHost.get(host);\n            if (r == null) {\n                r = new ArrayList<>();\n                mUpdatesByHost.put(host, r);\n            } else {\n                if (alreadyStashed(r, oldId, newId)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"ID remap \" + oldId + \" -> \" + newId\n                                + \" already stashed for \" + host);\n                    }\n                    return;\n                }\n            }\n            r.add(new RestoreUpdateRecord(oldId, newId));\n        }\n\n        private void sendWidgetRestoreBroadcastLocked(String action, Provider provider,\n                Host host, int[] oldIds, int[] newIds, UserHandle userHandle) {\n            Intent intent = new Intent(action);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OLD_IDS, oldIds);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, newIds);\n            if (provider != null) {\n                intent.setComponent(provider.id.componentName);\n                sendBroadcastAsUser(intent, userHandle);\n            }\n            if (host != null) {\n                intent.setComponent(null);\n                intent.setPackage(host.id.packageName);\n                intent.putExtra(AppWidgetManager.EXTRA_HOST_ID, host.id.hostId);\n                sendBroadcastAsUser(intent, userHandle);\n            }\n        }\n\n        // We're restoring widget state for 'pkg', so we start by wiping (a) all widget\n        // instances that are hosted by that app, and (b) all instances in other hosts\n        // for which 'pkg' is the provider.  We assume that we'll be restoring all of\n        // these hosts & providers, so will be reconstructing a correct live state.\n        private void pruneWidgetStateLocked(String pkg, int userId) {\n            if (!mPrunedApps.contains(pkg)) {\n                if (DEBUG) {\n                    Slog.i(TAG, \"pruning widget state for restoring package \" + pkg);\n                }\n                for (int i = mWidgets.size() - 1; i >= 0; i--) {\n                    Widget widget = mWidgets.get(i);\n\n                    Host host = widget.host;\n                    Provider provider = widget.provider;\n\n                    if (host.hostsPackageForUser(pkg, userId)\n                            || (provider != null && provider.isInPackageForUser(pkg, userId))) {\n                        // 'pkg' is either the host or the provider for this instances,\n                        // so we tear it down in anticipation of it (possibly) being\n                        // reconstructed due to the restore\n                        host.widgets.remove(widget);\n                        provider.widgets.remove(widget);\n                        // Check if we need to destroy any services (if no other app widgets are\n                        // referencing the same service)\n                        decrementAppWidgetServiceRefCount(widget);\n                        removeWidgetLocked(widget);\n                    }\n                }\n                mPrunedApps.add(pkg);\n            } else {\n                if (DEBUG) {\n                    Slog.i(TAG, \"already pruned \" + pkg + \", continuing normally\");\n                }\n            }\n        }\n\n        private boolean isProviderAndHostInUser(Widget widget, int userId) {\n            // Backup only widgets hosted or provided by the owner profile.\n            return widget.host.getUserId() == userId && (widget.provider == null\n                    || widget.provider.getUserId() == userId);\n        }\n\n        private int countPendingUpdates(ArrayList<RestoreUpdateRecord> updates) {\n            int pending = 0;\n            final int N = updates.size();\n            for (int i = 0; i < N; i++) {\n                RestoreUpdateRecord r = updates.get(i);\n                if (!r.notified) {\n                    pending++;\n                }\n            }\n            return pending;\n        }\n\n        // Accumulate a list of updates that affect the given provider for a final\n        // coalesced notification broadcast once restore is over.\n        private class RestoreUpdateRecord {\n            public int oldId;\n            public int newId;\n            public boolean notified;\n\n            public RestoreUpdateRecord(int theOldId, int theNewId) {\n                oldId = theOldId;\n                newId = theNewId;\n                notified = false;\n            }\n        }\n    }\n\n    private class AppWidgetManagerLocal extends AppWidgetManagerInternal {\n        @Override\n        public ArraySet<String> getHostedWidgetPackages(int uid) {\n            synchronized (mLock) {\n                ArraySet<String> widgetPackages = null;\n                final int widgetCount = mWidgets.size();\n                for (int i = 0; i < widgetCount; i++) {\n                    final Widget widget = mWidgets.get(i);\n                    if  (widget.host.id.uid == uid && widget.provider != null) {\n                        if (widgetPackages == null) {\n                            widgetPackages = new ArraySet<>();\n                        }\n                        widgetPackages.add(widget.provider.id.componentName.getPackageName());\n                    }\n                }\n                return widgetPackages;\n            }\n        }\n\n        @Override\n        public void unlockUser(int userId) {\n            handleUserUnlocked(userId);\n        }\n\n        @Override\n        public void applyResourceOverlaysToWidgets(Set<String> packageNames, int userId,\n                boolean updateFrameworkRes) {\n            synchronized (mLock) {\n                applyResourceOverlaysToWidgetsLocked(new HashSet<>(packageNames), userId,\n                        updateFrameworkRes);\n            }\n        }\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 38238,
                                        "general": {
                                            "word_based": 16459,
                                            "char_based": 50947
                                        },
                                        "gemini": 45851
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "ae39a3f6538e5a5a73aea4daf8b552539247227f",
                            "repo_path": "android_repos/base",
                            "result": "failure",
                            "downstream_patch_content": "commit ae39a3f6538e5a5a73aea4daf8b552539247227f\nAuthor: Pinyao Ting <pinyaoting@google.com>\nDate:   Tue Aug 20 21:17:13 2024 +0000\n\n    Enforce hard limits on hosts per package and widgets per host.\n    \n    Bug: 353240784\n    Merged-In: I60ee7faf57ed719f93cafad212fef24964dec99f\n    Change-Id: I60ee7faf57ed719f93cafad212fef24964dec99f\n    Test: manually verified with PoC app that at most 20 hosts can exists\n    Flag: EXEMPT CVE\n\ndiff --git a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nindex f5063ac4a023..356613ab3377 100644\n--- a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n+++ b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n@@ -170,6 +170,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // used to verify which request has successfully been received by the host.\n     private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n         @Override\n         public void onReceive(Context context, Intent intent) {\n@@ -1698,7 +1707,7 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (host != null) {\n             return host;\n         }\n-\n+        ensureHostCountBeforeAddLocked(id);\n         host = new Host();\n         host.id = id;\n         mHosts.add(host);\n@@ -1706,6 +1715,24 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         return host;\n     }\n \n+    /**\n+     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n+     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n+     * removes the oldest host.\n+     */\n+    private void ensureHostCountBeforeAddLocked(HostId hostId) {\n+        final List<Host> hosts = new ArrayList<>();\n+        for (Host host : mHosts) {\n+            if (host.id.uid == hostId.uid\n+                    && host.id.packageName.equals(hostId.packageName)) {\n+                hosts.add(host);\n+            }\n+        }\n+        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n+            deleteHostLocked(hosts.remove(0));\n+        }\n+    }\n+\n     private void deleteHostLocked(Host host) {\n         final int N = host.widgets.size();\n         for (int i = N - 1; i >= 0; i--) {\n@@ -2833,11 +2860,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n      * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n      */\n     void addWidgetLocked(Widget widget) {\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.\n",
                            "downstream_patch_tokens": {
                                "openai": 1088,
                                "general": {
                                    "word_based": 485,
                                    "char_based": 1099
                                },
                                "gemini": 1336
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java",
                                    "total_hunks": 4,
                                    "failed_hunks": [
                                        1,
                                        4
                                    ],
                                    "inline_merge_conflicts": [],
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    },
                                    "rej_file_content": "```diff\n--- services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n+++ services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n@@ -217,6 +217,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // See {@link Provider#pendingDeletedWidgetIds}.\n     private static final String PENDING_DELETED_IDS_ATTR = \"pending_deleted_ids\";\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     // Handles user and package related broadcasts.\n     // See {@link #registerBroadcastReceiver}\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n@@ -3591,11 +3618,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (DEBUG) {\n             Slog.i(TAG, \"addWidgetLocked() \" + widget);\n         }\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(@NonNull final Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.\n```",
                                    "rej_file_tokens": {
                                        "openai": 555,
                                        "general": {
                                            "word_based": 254,
                                            "char_based": 607
                                        },
                                        "gemini": 667
                                    },
                                    "patch_apply_output": "patching file services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nHunk #1 FAILED at 217.\nHunk #2 succeeded at 1698 (offset -577 lines).\nHunk #3 succeeded at 1706 with fuzz 2 (offset -577 lines).\nHunk #4 FAILED at 3591.\n2 out of 4 hunks FAILED -- saving rejects to file services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java.rej",
                                    "inline_merge_output": "patching file services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nHunk #1 merged at 229-237.\nHunk #2 already applied at 2296.\nHunk #3 merged at 2322-2339.\nHunk #4 already applied at 3630, merged at 3636-3655.",
                                    "upstream_file_tokens": {
                                        "openai": 50416,
                                        "general": {
                                            "word_based": 21550,
                                            "char_based": 66890
                                        },
                                        "gemini": 60115
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.appwidget;\n\nimport static android.content.Context.KEYGUARD_SERVICE;\nimport static android.content.Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;\nimport static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\nimport static android.content.res.Resources.ID_NULL;\n\nimport static com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME;\n\nimport android.annotation.UserIdInt;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.AlarmManager;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.AppOpsManagerInternal;\nimport android.app.IApplicationThread;\nimport android.app.IServiceConnection;\nimport android.app.KeyguardManager;\nimport android.app.PendingIntent;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.app.admin.DevicePolicyManagerInternal.OnCrossProfileWidgetProvidersChangeListener;\nimport android.app.usage.UsageEvents;\nimport android.app.usage.UsageStatsManagerInternal;\nimport android.appwidget.AppWidgetManager;\nimport android.appwidget.AppWidgetManagerInternal;\nimport android.appwidget.AppWidgetProviderInfo;\nimport android.appwidget.PendingHostUpdate;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.Intent.FilterComparison;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.ServiceConnection;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.LauncherApps;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.ServiceInfo;\nimport android.content.pm.ShortcutServiceInternal;\nimport android.content.pm.SuspendDialogInfo;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.content.res.TypedArray;\nimport android.content.res.XmlResourceParser;\nimport android.graphics.Point;\nimport android.graphics.drawable.Icon;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.service.appwidget.AppWidgetServiceDumpProto;\nimport android.service.appwidget.WidgetProto;\nimport android.text.TextUtils;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.AttributeSet;\nimport android.util.IntArray;\nimport android.util.LongSparseArray;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\nimport android.util.SparseIntArray;\nimport android.util.SparseLongArray;\nimport android.util.TypedValue;\nimport android.util.TypedXmlPullParser;\nimport android.util.TypedXmlSerializer;\nimport android.util.Xml;\nimport android.util.proto.ProtoOutputStream;\nimport android.view.Display;\nimport android.view.View;\nimport android.widget.RemoteViews;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.app.SuspendedAppActivity;\nimport com.android.internal.app.UnlaunchableAppActivity;\nimport com.android.internal.appwidget.IAppWidgetHost;\nimport com.android.internal.appwidget.IAppWidgetService;\nimport com.android.internal.os.BackgroundThread;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.widget.IRemoteViewsFactory;\nimport com.android.server.LocalServices;\nimport com.android.server.WidgetBackupProvider;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicLong;\n\nclass AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBackupProvider,\n        OnCrossProfileWidgetProvidersChangeListener {\n    private static final String TAG = \"AppWidgetServiceImpl\";\n\n    private static boolean DEBUG = false;\n\n    private static final String OLD_KEYGUARD_HOST_PACKAGE = \"android\";\n    private static final String NEW_KEYGUARD_HOST_PACKAGE = \"com.android.keyguard\";\n    private static final int KEYGUARD_HOST_ID = 0x4b455947;\n\n    private static final String STATE_FILENAME = \"appwidgets.xml\";\n\n    private static final int MIN_UPDATE_PERIOD = DEBUG ? 0 : 30 * 60 * 1000; // 30 minutes\n\n    private static final int TAG_UNDEFINED = -1;\n\n    private static final int UNKNOWN_UID = -1;\n\n    private static final int UNKNOWN_USER_ID = -10;\n\n    // Bump if the stored widgets need to be upgraded.\n    private static final int CURRENT_VERSION = 1;\n\n    // Every widget update request is associated which an increasing sequence number. This is\n    // used to verify which request has successfully been received by the host.\n    private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n\n    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            final String action = intent.getAction();\n            final int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Received broadcast: \" + action + \" on user \" + userId);\n            }\n\n            switch (action) {\n                case Intent.ACTION_MANAGED_PROFILE_AVAILABLE:\n                case Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE:\n                    synchronized (mLock) {\n                        reloadWidgetsMaskedState(userId);\n                    }\n                    break;\n                case Intent.ACTION_PACKAGES_SUSPENDED:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    updateWidgetPackageSuspensionMaskedState(intent, true, getSendingUserId());\n                    break;\n                case Intent.ACTION_PACKAGES_UNSUSPENDED:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    updateWidgetPackageSuspensionMaskedState(intent, false, getSendingUserId());\n                    break;\n                default:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    break;\n            }\n        }\n    };\n\n    // Manages persistent references to RemoteViewsServices from different App Widgets.\n    private final HashMap<Pair<Integer, FilterComparison>, HashSet<Integer>>\n            mRemoteViewsServicesAppWidgets = new HashMap<>();\n\n    private final Object mLock = new Object();\n\n    private final ArrayList<Widget> mWidgets = new ArrayList<>();\n    private final ArrayList<Host> mHosts = new ArrayList<>();\n    private final ArrayList<Provider> mProviders = new ArrayList<>();\n\n    private final ArraySet<Pair<Integer, String>> mPackagesWithBindWidgetPermission =\n            new ArraySet<>();\n\n    private final SparseBooleanArray mLoadedUserIds = new SparseBooleanArray();\n\n    private final Object mWidgetPackagesLock = new Object();\n    private final SparseArray<ArraySet<String>> mWidgetPackages = new SparseArray<>();\n\n    private BackupRestoreController mBackupRestoreController;\n\n    private final Context mContext;\n\n    private IPackageManager mPackageManager;\n    private AlarmManager mAlarmManager;\n    private UserManager mUserManager;\n    private AppOpsManager mAppOpsManager;\n    private KeyguardManager mKeyguardManager;\n    private DevicePolicyManagerInternal mDevicePolicyManagerInternal;\n    private PackageManagerInternal mPackageManagerInternal;\n    private ActivityManagerInternal mActivityManagerInternal;\n    private AppOpsManagerInternal mAppOpsManagerInternal;\n    private UsageStatsManagerInternal mUsageStatsManagerInternal;\n\n    private SecurityPolicy mSecurityPolicy;\n\n    private Handler mSaveStateHandler;\n    private Handler mCallbackHandler;\n\n    private final SparseIntArray mNextAppWidgetIds = new SparseIntArray();\n\n    private boolean mSafeMode;\n    private int mMaxWidgetBitmapMemory;\n\n    AppWidgetServiceImpl(Context context) {\n        mContext = context;\n    }\n\n    public void onStart() {\n        mPackageManager = AppGlobals.getPackageManager();\n        mAlarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);\n        mUserManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n        mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);\n        mKeyguardManager = (KeyguardManager) mContext.getSystemService(KEYGUARD_SERVICE);\n        mDevicePolicyManagerInternal = LocalServices.getService(DevicePolicyManagerInternal.class);\n        mPackageManagerInternal = LocalServices.getService(PackageManagerInternal.class);\n        mSaveStateHandler = BackgroundThread.getHandler();\n        mCallbackHandler = new CallbackHandler(mContext.getMainLooper());\n        mBackupRestoreController = new BackupRestoreController();\n        mSecurityPolicy = new SecurityPolicy();\n\n        computeMaximumWidgetBitmapMemory();\n        registerBroadcastReceiver();\n        registerOnCrossProfileProvidersChangedListener();\n\n        LocalServices.addService(AppWidgetManagerInternal.class, new AppWidgetManagerLocal());\n    }\n\n    void systemServicesReady() {\n        mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);\n        mAppOpsManagerInternal = LocalServices.getService(AppOpsManagerInternal.class);\n        mUsageStatsManagerInternal = LocalServices.getService(UsageStatsManagerInternal.class);\n    }\n\n    private void computeMaximumWidgetBitmapMemory() {\n        Display display = mContext.getDisplayNoVerify();\n        Point size = new Point();\n        display.getRealSize(size);\n        // Cap memory usage at 1.5 times the size of the display\n        // 1.5 * 4 bytes/pixel * w * h ==> 6 * w * h\n        mMaxWidgetBitmapMemory = 6 * size.x * size.y;\n    }\n\n    private void registerBroadcastReceiver() {\n        // Register for broadcasts about package install, etc., so we can\n        // update the provider list.\n        IntentFilter packageFilter = new IntentFilter();\n        packageFilter.addAction(Intent.ACTION_PACKAGE_ADDED);\n        packageFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);\n        packageFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);\n        packageFilter.addDataScheme(\"package\");\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                packageFilter, null, null);\n\n        // Register for events related to sdcard installation.\n        IntentFilter sdFilter = new IntentFilter();\n        sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);\n        sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                sdFilter, null, null);\n\n        IntentFilter offModeFilter = new IntentFilter();\n        offModeFilter.addAction(Intent.ACTION_MANAGED_PROFILE_AVAILABLE);\n        offModeFilter.addAction(Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                offModeFilter, null, null);\n\n        IntentFilter suspendPackageFilter = new IntentFilter();\n        suspendPackageFilter.addAction(Intent.ACTION_PACKAGES_SUSPENDED);\n        suspendPackageFilter.addAction(Intent.ACTION_PACKAGES_UNSUSPENDED);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                suspendPackageFilter, null, null);\n    }\n\n    private void registerOnCrossProfileProvidersChangedListener() {\n        // The device policy is an optional component.\n        if (mDevicePolicyManagerInternal != null) {\n            mDevicePolicyManagerInternal.addOnCrossProfileWidgetProvidersChangeListener(this);\n        }\n    }\n\n    public void setSafeMode(boolean safeMode) {\n        mSafeMode = safeMode;\n    }\n\n    private void onPackageBroadcastReceived(Intent intent, int userId) {\n        final String action = intent.getAction();\n        boolean added = false;\n        boolean changed = false;\n        boolean componentsModified = false;\n\n        final String pkgList[];\n        switch (action) {\n            case Intent.ACTION_PACKAGES_SUSPENDED:\n            case Intent.ACTION_PACKAGES_UNSUSPENDED:\n                pkgList = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                changed = true;\n                break;\n            case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:\n                added = true;\n                // Follow through\n            case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:\n                pkgList = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                break;\n            default: {\n                Uri uri = intent.getData();\n                if (uri == null) {\n                    return;\n                }\n                String pkgName = uri.getSchemeSpecificPart();\n                if (pkgName == null) {\n                    return;\n                }\n                pkgList = new String[] { pkgName };\n                added = Intent.ACTION_PACKAGE_ADDED.equals(action);\n                changed = Intent.ACTION_PACKAGE_CHANGED.equals(action);\n            }\n        }\n        if (pkgList == null || pkgList.length == 0) {\n            return;\n        }\n\n        synchronized (mLock) {\n            if (!mUserManager.isUserUnlockingOrUnlocked(userId) ||\n                    isProfileWithLockedParent(userId)) {\n                return;\n            }\n            ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ false);\n\n            Bundle extras = intent.getExtras();\n\n            if (added || changed) {\n                final boolean newPackageAdded = added && (extras == null\n                        || !extras.getBoolean(Intent.EXTRA_REPLACING, false));\n\n                for (String pkgName : pkgList) {\n                    // Fix up the providers - add/remove/update.\n                    componentsModified |= updateProvidersForPackageLocked(pkgName, userId, null);\n\n                    // ... and see if these are hosts we've been awaiting.\n                    // NOTE: We are backing up and restoring only the owner.\n                    // TODO: http://b/22388012\n                    if (newPackageAdded && userId == UserHandle.USER_SYSTEM) {\n                        final int uid = getUidForPackage(pkgName, userId);\n                        if (uid >= 0 ) {\n                            resolveHostUidLocked(pkgName, uid);\n                        }\n                    }\n                }\n            } else {\n                // If the package is being updated, we'll receive a PACKAGE_ADDED\n                // shortly, otherwise it is removed permanently.\n                final boolean packageRemovedPermanently = (extras == null\n                        || !extras.getBoolean(Intent.EXTRA_REPLACING, false));\n\n                if (packageRemovedPermanently) {\n                    for (String pkgName : pkgList) {\n                        componentsModified |= removeHostsAndProvidersForPackageLocked(\n                                pkgName, userId);\n                    }\n                }\n            }\n\n            if (componentsModified) {\n                saveGroupStateAsync(userId);\n\n                // If the set of providers has been modified, notify each active AppWidgetHost\n                scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n                // Possibly notify any new components of widget id changes\n                mBackupRestoreController.widgetComponentsChanged(userId);\n            }\n        }\n    }\n\n    /**\n     * Reload all widgets' masked state for the given user and its associated profiles, including\n     * due to user not being available and package suspension.\n     * userId must be the group parent.\n     */\n    void reloadWidgetsMaskedStateForGroup(int userId) {\n        if (!mUserManager.isUserUnlockingOrUnlocked(userId)) {\n            return;\n        }\n        synchronized (mLock) {\n            reloadWidgetsMaskedState(userId);\n            int[] profileIds = mUserManager.getEnabledProfileIds(userId);\n            for (int profileId : profileIds) {\n                reloadWidgetsMaskedState(profileId);\n            }\n        }\n    }\n\n    private void reloadWidgetsMaskedState(int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            UserInfo user  = mUserManager.getUserInfo(userId);\n\n            boolean lockedProfile = !mUserManager.isUserUnlockingOrUnlocked(userId);\n            boolean quietProfile = user.isQuietModeEnabled();\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                int providerUserId = provider.getUserId();\n                if (providerUserId != userId) {\n                    continue;\n                }\n\n                boolean changed = provider.setMaskedByLockedProfileLocked(lockedProfile);\n                changed |= provider.setMaskedByQuietProfileLocked(quietProfile);\n                try {\n                    boolean suspended;\n                    try {\n                        suspended = mPackageManager.isPackageSuspendedForUser(\n                                provider.id.componentName.getPackageName(), provider.getUserId());\n                    } catch (IllegalArgumentException ex) {\n                        // Package not found.\n                        suspended = false;\n                    }\n                    changed |= provider.setMaskedBySuspendedPackageLocked(suspended);\n                } catch (RemoteException e) {\n                    Slog.e(TAG, \"Failed to query application info\", e);\n                }\n                if (changed) {\n                    if (provider.isMaskedLocked()) {\n                        maskWidgetsViewsLocked(provider, null);\n                    } else {\n                        unmaskWidgetsViewsLocked(provider);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    /**\n     * Incrementally update the masked state due to package suspension state.\n     */\n    private void updateWidgetPackageSuspensionMaskedState(Intent intent, boolean suspended,\n            int profileId) {\n        String[] packagesArray = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n        if (packagesArray == null) {\n            return;\n        }\n        Set<String> packages = new ArraySet<>(Arrays.asList(packagesArray));\n        synchronized (mLock) {\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                int providerUserId = provider.getUserId();\n                if (providerUserId != profileId\n                        || !packages.contains(provider.id.componentName.getPackageName())) {\n                    continue;\n                }\n                if (provider.setMaskedBySuspendedPackageLocked(suspended)) {\n                    if (provider.isMaskedLocked()) {\n                        maskWidgetsViewsLocked(provider, null);\n                    } else {\n                        unmaskWidgetsViewsLocked(provider);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Mask the target widget belonging to the specified provider, or all active widgets\n     * of the provider if target widget == null.\n     */\n    private void maskWidgetsViewsLocked(Provider provider, Widget targetWidget) {\n        final int widgetCount = provider.widgets.size();\n        if (widgetCount == 0) {\n            return;\n        }\n        RemoteViews views = new RemoteViews(mContext.getPackageName(),\n                R.layout.work_widget_mask_view);\n        ApplicationInfo appInfo = provider.info.providerInfo.applicationInfo;\n        final int appUserId = provider.getUserId();\n        boolean showBadge;\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final Intent onClickIntent;\n\n            if (provider.maskedBySuspendedPackage) {\n                showBadge = mUserManager.hasBadge(appUserId);\n                final String suspendingPackage = mPackageManagerInternal.getSuspendingPackage(\n                        appInfo.packageName, appUserId);\n                if (PLATFORM_PACKAGE_NAME.equals(suspendingPackage)) {\n                    onClickIntent = mDevicePolicyManagerInternal.createShowAdminSupportIntent(\n                            appUserId, true);\n                } else {\n                    final SuspendDialogInfo dialogInfo =\n                            mPackageManagerInternal.getSuspendedDialogInfo(\n                                    appInfo.packageName, suspendingPackage, appUserId);\n                    // onUnsuspend is null because we don't want to start any activity on\n                    // unsuspending from a suspended widget.\n                    onClickIntent = SuspendedAppActivity.createSuspendedAppInterceptIntent(\n                            appInfo.packageName, suspendingPackage, dialogInfo, null, null,\n                            appUserId);\n                }\n            } else if (provider.maskedByQuietProfile) {\n                showBadge = true;\n                onClickIntent = UnlaunchableAppActivity.createInQuietModeDialogIntent(appUserId);\n            } else /* provider.maskedByLockedProfile */ {\n                showBadge = true;\n                onClickIntent = mKeyguardManager\n                        .createConfirmDeviceCredentialIntent(null, null, appUserId);\n                if (onClickIntent != null) {\n                    onClickIntent.setFlags(\n                            FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);\n                }\n            }\n\n            if (onClickIntent != null) {\n                views.setOnClickPendingIntent(android.R.id.background,\n                        PendingIntent.getActivity(mContext, 0, onClickIntent,\n                                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE));\n            }\n\n            Icon icon = appInfo.icon != 0\n                    ? Icon.createWithResource(appInfo.packageName, appInfo.icon)\n                    : Icon.createWithResource(mContext, android.R.drawable.sym_def_app_icon);\n            views.setImageViewIcon(R.id.work_widget_app_icon, icon);\n            if (!showBadge) {\n                views.setViewVisibility(R.id.work_widget_badge_icon, View.INVISIBLE);\n            }\n\n            for (int j = 0; j < widgetCount; j++) {\n                Widget widget = provider.widgets.get(j);\n                if (targetWidget != null && targetWidget != widget) continue;\n                if (widget.replaceWithMaskedViewsLocked(views)) {\n                    scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void unmaskWidgetsViewsLocked(Provider provider) {\n        final int widgetCount = provider.widgets.size();\n        for (int j = 0; j < widgetCount; j++) {\n            Widget widget = provider.widgets.get(j);\n            if (widget.clearMaskedViewsLocked()) {\n                scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n            }\n        }\n    }\n\n    private void resolveHostUidLocked(String pkg, int uid) {\n        final int N = mHosts.size();\n        for (int i = 0; i < N; i++) {\n            Host host = mHosts.get(i);\n            if (host.id.uid == UNKNOWN_UID && pkg.equals(host.id.packageName)) {\n                if (DEBUG) {\n                    Slog.i(TAG, \"host \" + host.id + \" resolved to uid \" + uid);\n                }\n                host.id = new HostId(uid, host.id.hostId, host.id.packageName);\n                return;\n            }\n        }\n    }\n\n    private void ensureGroupStateLoadedLocked(int userId) {\n        ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ true );\n    }\n\n    private void ensureGroupStateLoadedLocked(int userId, boolean enforceUserUnlockingOrUnlocked) {\n        if (enforceUserUnlockingOrUnlocked && !isUserRunningAndUnlocked(userId)) {\n            throw new IllegalStateException(\n                    \"User \" + userId + \" must be unlocked for widgets to be available\");\n        }\n        if (enforceUserUnlockingOrUnlocked && isProfileWithLockedParent(userId)) {\n            throw new IllegalStateException(\n                    \"Profile \" + userId + \" must have unlocked parent\");\n        }\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        IntArray newIds = new IntArray(1);\n        for (int profileId : profileIds) {\n            if (!mLoadedUserIds.get(profileId)) {\n                mLoadedUserIds.put(profileId, true);\n                newIds.add(profileId);\n            }\n        }\n        if (newIds.size() <= 0) {\n            return;\n        }\n        final int[] newProfileIds = newIds.toArray();\n        clearProvidersAndHostsTagsLocked();\n\n        loadGroupWidgetProvidersLocked(newProfileIds);\n        loadGroupStateLocked(newProfileIds);\n    }\n\n    private boolean isUserRunningAndUnlocked(@UserIdInt int userId) {\n        return mUserManager.isUserUnlockingOrUnlocked(userId);\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {\n        if (!DumpUtils.checkDumpPermission(mContext, TAG, pw)) return;\n\n        synchronized (mLock) {\n            if (args.length > 0 && \"--proto\".equals(args[0])) {\n                dumpProto(fd);\n            } else {\n                dumpInternalLocked(pw);\n            }\n        }\n    }\n\n    private void dumpProto(FileDescriptor fd) {\n        Slog.i(TAG, \"dump proto for \" + mWidgets.size() + \" widgets\");\n\n        ProtoOutputStream proto = new ProtoOutputStream(fd);\n        int N = mWidgets.size();\n        for (int i=0; i < N; i++) {\n            dumpProtoWidget(proto, mWidgets.get(i));\n        }\n        proto.flush();\n    }\n\n    private void dumpProtoWidget(ProtoOutputStream proto, Widget widget) {\n        if (widget.host == null || widget.provider == null) {\n            Slog.d(TAG, \"skip dumping widget because host or provider is null: widget.host=\"\n                + widget.host + \" widget.provider=\"  + widget.provider);\n            return;\n        }\n        long token = proto.start(AppWidgetServiceDumpProto.WIDGETS);\n        proto.write(WidgetProto.IS_CROSS_PROFILE,\n            widget.host.getUserId() != widget.provider.getUserId());\n        proto.write(WidgetProto.IS_HOST_STOPPED, widget.host.callbacks == null);\n        proto.write(WidgetProto.HOST_PACKAGE, widget.host.id.packageName);\n        proto.write(WidgetProto.PROVIDER_PACKAGE, widget.provider.id.componentName.getPackageName());\n        proto.write(WidgetProto.PROVIDER_CLASS, widget.provider.id.componentName.getClassName());\n        if (widget.options != null) {\n            proto.write(WidgetProto.RESTORE_COMPLETED,\n                    widget.options.getBoolean(AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED));\n            proto.write(WidgetProto.MIN_WIDTH,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH, 0));\n            proto.write(WidgetProto.MIN_HEIGHT,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, 0));\n            proto.write(WidgetProto.MAX_WIDTH,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH, 0));\n            proto.write(WidgetProto.MAX_HEIGHT,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, 0));\n        }\n        proto.end(token);\n    }\n\n    private void dumpInternalLocked(PrintWriter pw) {\n        int N = mProviders.size();\n        pw.println(\"Providers:\");\n        for (int i = 0; i < N; i++) {\n            dumpProviderLocked(mProviders.get(i), i, pw);\n        }\n\n        N = mWidgets.size();\n        pw.println(\" \");\n        pw.println(\"Widgets:\");\n        for (int i = 0; i < N; i++) {\n            dumpWidget(mWidgets.get(i), i, pw);\n        }\n\n        N = mHosts.size();\n        pw.println(\" \");\n        pw.println(\"Hosts:\");\n        for (int i = 0; i < N; i++) {\n            dumpHost(mHosts.get(i), i, pw);\n        }\n\n        N = mPackagesWithBindWidgetPermission.size();\n        pw.println(\" \");\n        pw.println(\"Grants:\");\n        for (int i = 0; i < N; i++) {\n            Pair<Integer, String> grant = mPackagesWithBindWidgetPermission.valueAt(i);\n            dumpGrant(grant, i, pw);\n        }\n    }\n\n    @Override\n    public ParceledListSlice<PendingHostUpdate> startListening(IAppWidgetHost callbacks,\n            String callingPackage, int hostId, int[] appWidgetIds) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"startListening() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            // Instant apps cannot host app widgets.\n            if (mSecurityPolicy.isInstantAppLocked(callingPackage, userId)) {\n                Slog.w(TAG, \"Instant package \" + callingPackage + \" cannot host app widgets\");\n                return ParceledListSlice.emptyList();\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupOrAddHostLocked(id);\n            host.callbacks = callbacks;\n\n            long updateSequenceNo = UPDATE_COUNTER.incrementAndGet();\n            int N = appWidgetIds.length;\n            ArrayList<PendingHostUpdate> outUpdates = new ArrayList<>(N);\n            LongSparseArray<PendingHostUpdate> updatesMap = new LongSparseArray<>();\n            for (int i = 0; i < N; i++) {\n                updatesMap.clear();\n                host.getPendingUpdatesForIdLocked(mContext, appWidgetIds[i], updatesMap);\n                // We key the updates based on request id, so that the values are sorted in the\n                // order they were received.\n                int m = updatesMap.size();\n                for (int j = 0; j < m; j++) {\n                    outUpdates.add(updatesMap.valueAt(j));\n                }\n            }\n            // Reset the update counter once all the updates have been calculated\n            host.lastWidgetUpdateSequenceNo = updateSequenceNo;\n            return new ParceledListSlice<>(outUpdates);\n        }\n    }\n\n    @Override\n    public void stopListening(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"stopListening() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ false);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host != null) {\n                host.callbacks = null;\n                pruneHostLocked(host);\n                mAppOpsManagerInternal.updateAppWidgetVisibility(host.getWidgetUids(), false);\n            }\n        }\n    }\n\n    @Override\n    public int allocateAppWidgetId(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"allocateAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            // Instant apps cannot host app widgets.\n            if (mSecurityPolicy.isInstantAppLocked(callingPackage, userId)) {\n                Slog.w(TAG, \"Instant package \" + callingPackage + \" cannot host app widgets\");\n                return AppWidgetManager.INVALID_APPWIDGET_ID;\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            if (mNextAppWidgetIds.indexOfKey(userId) < 0) {\n                mNextAppWidgetIds.put(userId, AppWidgetManager.INVALID_APPWIDGET_ID + 1);\n            }\n\n            final int appWidgetId = incrementAndGetAppWidgetIdLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupOrAddHostLocked(id);\n\n            Widget widget = new Widget();\n            widget.appWidgetId = appWidgetId;\n            widget.host = host;\n\n            host.widgets.add(widget);\n            addWidgetLocked(widget);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Allocated widget id \" + appWidgetId\n                        + \" for host \" + host.id);\n            }\n\n            return appWidgetId;\n        }\n    }\n\n    @Override\n    public void deleteAppWidgetId(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                return;\n            }\n\n            deleteAppWidgetLocked(widget);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Deleted widget id \" + appWidgetId\n                        + \" for host \" + widget.host.id);\n            }\n        }\n    }\n\n    @Override\n    public boolean hasBindAppWidgetPermission(String packageName, int grantId) {\n        if (DEBUG) {\n            Slog.i(TAG, \"hasBindAppWidgetPermission() \" + UserHandle.getCallingUserId());\n        }\n\n        // A special permission is required for managing allowlisting.\n        mSecurityPolicy.enforceModifyAppWidgetBindPermissions(packageName);\n\n        synchronized (mLock) {\n            // The grants are stored in user state wich gets the grant.\n            ensureGroupStateLoadedLocked(grantId);\n\n            final int packageUid = getUidForPackage(packageName, grantId);\n            if (packageUid < 0) {\n                return false;\n            }\n\n            Pair<Integer, String> packageId = Pair.create(grantId, packageName);\n            return mPackagesWithBindWidgetPermission.contains(packageId);\n        }\n    }\n\n    @Override\n    public void setBindAppWidgetPermission(String packageName, int grantId,\n            boolean grantPermission) {\n        if (DEBUG) {\n            Slog.i(TAG, \"setBindAppWidgetPermission() \" + UserHandle.getCallingUserId());\n        }\n\n        // A special permission is required for managing allowlisting.\n        mSecurityPolicy.enforceModifyAppWidgetBindPermissions(packageName);\n\n        synchronized (mLock) {\n            // The grants are stored in user state wich gets the grant.\n            ensureGroupStateLoadedLocked(grantId);\n\n            final int packageUid = getUidForPackage(packageName, grantId);\n            if (packageUid < 0) {\n                return;\n            }\n\n            Pair<Integer, String> packageId = Pair.create(grantId, packageName);\n            if (grantPermission) {\n                mPackagesWithBindWidgetPermission.add(packageId);\n            } else {\n                mPackagesWithBindWidgetPermission.remove(packageId);\n            }\n\n            saveGroupStateAsync(grantId);\n        }\n    }\n\n    @Override\n    public IntentSender createAppWidgetConfigIntentSender(String callingPackage, int appWidgetId,\n            final int intentFlags) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"createAppWidgetConfigIntentSender() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                throw new IllegalArgumentException(\"Bad widget id \" + appWidgetId);\n            }\n\n            Provider provider = widget.provider;\n            if (provider == null) {\n                throw new IllegalArgumentException(\"Widget not bound \" + appWidgetId);\n            }\n\n            // Make sure only safe flags can be passed it.\n            final int secureFlags = intentFlags & ~Intent.IMMUTABLE_FLAGS;\n\n            Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_CONFIGURE);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);\n            intent.setComponent(provider.getInfoLocked(mContext).configure);\n            intent.setFlags(secureFlags);\n\n            // All right, create the sender.\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return PendingIntent.getActivityAsUser(\n                        mContext, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                                | PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_CANCEL_CURRENT,\n                                null, new UserHandle(provider.getUserId()))\n                        .getIntentSender();\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n    }\n\n    @Override\n    public boolean bindAppWidgetId(String callingPackage, int appWidgetId,\n            int providerProfileId, ComponentName providerComponent, Bundle options) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"bindAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        // Check that if a cross-profile binding is attempted, it is allowed.\n        if (!mSecurityPolicy.isEnabledGroupProfile(providerProfileId)) {\n            return false;\n        }\n\n        // If the provider is not under the calling user, make sure this\n        // provider is allowlisted for access from the parent.\n        if (!mSecurityPolicy.isProviderInCallerOrInProfileAndWhitelListed(\n                providerComponent.getPackageName(), providerProfileId)) {\n            return false;\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // A special permission or allowlisting is required to bind widgets.\n            if (!mSecurityPolicy.hasCallerBindPermissionOrBindWhiteListedLocked(\n                    callingPackage)) {\n                return false;\n            }\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                Slog.e(TAG, \"Bad widget id \" + appWidgetId);\n                return false;\n            }\n\n            if (widget.provider != null) {\n                Slog.e(TAG, \"Widget id \" + appWidgetId\n                        + \" already bound to: \" + widget.provider.id);\n                return false;\n            }\n\n            final int providerUid = getUidForPackage(providerComponent.getPackageName(),\n                    providerProfileId);\n            if (providerUid < 0) {\n                Slog.e(TAG, \"Package \" + providerComponent.getPackageName() + \" not installed \"\n                        + \" for profile \" + providerProfileId);\n                return false;\n            }\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the provider is in the already vetted user profile.\n            ProviderId providerId = new ProviderId(providerUid, providerComponent);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider == null) {\n                Slog.e(TAG, \"No widget provider \" + providerComponent + \" for profile \"\n                        + providerProfileId);\n                return false;\n            }\n\n            if (provider.zombie) {\n                Slog.e(TAG, \"Can't bind to a 3rd party provider in\"\n                        + \" safe mode \" + provider);\n                return false;\n            }\n\n            widget.provider = provider;\n            widget.options = (options != null) ? cloneIfLocalBinder(options) : new Bundle();\n\n            // We need to provide a default value for the widget category if it is not specified\n            if (!widget.options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {\n                widget.options.putInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY,\n                        AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN);\n            }\n\n            provider.widgets.add(widget);\n\n            onWidgetProviderAddedOrChangedLocked(widget);\n\n            final int widgetCount = provider.widgets.size();\n            if (widgetCount == 1) {\n                // Tell the provider that it's ready.\n                sendEnableIntentLocked(provider);\n            }\n\n            // Send an update now -- We need this update now, and just for this appWidgetId.\n            // It's less critical when the next one happens, so when we schedule the next one,\n            // we add updatePeriodMillis to its start time. That time will have some slop,\n            // but that's okay.\n            sendUpdateIntentLocked(provider, new int[] {appWidgetId});\n\n            // Schedule the future updates.\n            registerForBroadcastsLocked(provider, getWidgetIds(provider.widgets));\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Bound widget \" + appWidgetId + \" to provider \" + provider.id);\n            }\n        }\n\n        return true;\n    }\n\n    @Override\n    public int[] getAppWidgetIds(ComponentName componentName) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetIds() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider != null) {\n                return getWidgetIds(provider.widgets);\n            }\n\n            return new int[0];\n        }\n    }\n\n    @Override\n    public int[] getAppWidgetIdsForHost(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetIdsForHost() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access its hosts.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host != null) {\n                return getWidgetIds(host.widgets);\n            }\n\n            return new int[0];\n        }\n    }\n\n    @Override\n    public boolean bindRemoteViewsService(String callingPackage, int appWidgetId, Intent intent,\n            IApplicationThread caller, IBinder activtiyToken, IServiceConnection connection,\n            int flags) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"bindRemoteViewsService() \" + userId);\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                throw new IllegalArgumentException(\"Bad widget id\");\n            }\n\n            // Make sure the widget has a provider.\n            if (widget.provider == null) {\n                throw new IllegalArgumentException(\"No provider for widget \"\n                        + appWidgetId);\n            }\n\n            ComponentName componentName = intent.getComponent();\n\n            // Ensure that the service belongs to the same package as the provider.\n            // But this is not enough as they may be under different users - see below...\n            String providerPackage = widget.provider.id.componentName.getPackageName();\n            String servicePackage = componentName.getPackageName();\n            if (!servicePackage.equals(providerPackage)) {\n                throw new SecurityException(\"The taget service not in the same package\"\n                        + \" as the widget provider\");\n            }\n\n            // Make sure this service exists under the same user as the provider and\n            // requires a permission which allows only the system to bind to it.\n            mSecurityPolicy.enforceServiceExistsAndRequiresBindRemoteViewsPermission(\n                    componentName, widget.provider.getUserId());\n\n            // Good to go - the service package is correct, it exists for the correct\n            // user, and requires the bind permission.\n\n            final long callingIdentity = Binder.clearCallingIdentity();\n            try {\n                // Ask ActivityManager to bind it. Notice that we are binding the service with the\n                // caller app instead of DevicePolicyManagerService.\n                if (ActivityManager.getService().bindService(\n                        caller, activtiyToken, intent,\n                        intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                        connection, flags & (Context.BIND_AUTO_CREATE\n                                | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE),\n                        mContext.getOpPackageName(), widget.provider.getUserId()) != 0) {\n\n                    // Add it to the mapping of RemoteViewsService to appWidgetIds so that we\n                    // can determine when we can call back to the RemoteViewsService later to\n                    // destroy associated factories.\n                    incrementAppWidgetServiceRefCount(appWidgetId,\n                            Pair.create(widget.provider.id.uid, new FilterComparison(intent)));\n                    return true;\n                }\n            } catch (RemoteException ex) {\n                // Same process, should not happen.\n            } finally {\n                Binder.restoreCallingIdentity(callingIdentity);\n            }\n        }\n\n        // Failed to bind.\n        return false;\n    }\n\n    @Override\n    public void deleteHost(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteHost() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts in its uid and package.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host == null) {\n                return;\n            }\n\n            deleteHostLocked(host);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Deleted host \" + host.id);\n            }\n        }\n    }\n\n    @Override\n    public void deleteAllHosts() {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteAllHosts() \" + userId);\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            boolean changed = false;\n\n            final int N = mHosts.size();\n            for (int i = N - 1; i >= 0; i--) {\n                Host host = mHosts.get(i);\n\n                // Delete only hosts in the calling uid.\n                if (host.id.uid == Binder.getCallingUid()) {\n                    deleteHostLocked(host);\n                    changed = true;\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Deleted host \" + host.id);\n                    }\n                }\n            }\n\n            if (changed) {\n                saveGroupStateAsync(userId);\n            }\n        }\n    }\n\n    @Override\n    public AppWidgetProviderInfo getAppWidgetInfo(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetInfo() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null && widget.provider != null && !widget.provider.zombie) {\n                return cloneIfLocalBinder(widget.provider.getInfoLocked(mContext));\n            }\n\n            return null;\n        }\n    }\n\n    @Override\n    public RemoteViews getAppWidgetViews(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetViews() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null) {\n                return cloneIfLocalBinder(widget.getEffectiveViewsLocked());\n            }\n\n            return null;\n        }\n    }\n\n    @Override\n    public void updateAppWidgetOptions(String callingPackage, int appWidgetId, Bundle options) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetOptions() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                return;\n            }\n\n            // Merge the options.\n            widget.options.putAll(options);\n\n            // Send the broacast to notify the provider that options changed.\n            sendOptionsChangedIntentLocked(widget);\n\n            saveGroupStateAsync(userId);\n        }\n    }\n\n    @Override\n    public Bundle getAppWidgetOptions(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetOptions() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null && widget.options != null) {\n                return cloneIfLocalBinder(widget.options);\n            }\n\n            return Bundle.EMPTY;\n        }\n    }\n\n    @Override\n    public void updateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views) {\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetIds() \" + UserHandle.getCallingUserId());\n        }\n\n        updateAppWidgetIds(callingPackage, appWidgetIds, views, false);\n    }\n\n    @Override\n    public void partiallyUpdateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views) {\n        if (DEBUG) {\n            Slog.i(TAG, \"partiallyUpdateAppWidgetIds() \" + UserHandle.getCallingUserId());\n        }\n\n        updateAppWidgetIds(callingPackage, appWidgetIds, views, true);\n    }\n\n    @Override\n    public void notifyAppWidgetViewDataChanged(String callingPackage, int[] appWidgetIds,\n            int viewId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"notifyAppWidgetViewDataChanged() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        if (appWidgetIds == null || appWidgetIds.length == 0) {\n            return;\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            final int N = appWidgetIds.length;\n            for (int i = 0; i < N; i++) {\n                final int appWidgetId = appWidgetIds[i];\n\n                // NOTE: The lookup is enforcing security across users by making\n                // sure the caller can only access widgets it hosts or provides.\n                Widget widget = lookupWidgetLocked(appWidgetId,\n                        Binder.getCallingUid(), callingPackage);\n\n                if (widget != null) {\n                    scheduleNotifyAppWidgetViewDataChanged(widget, viewId);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void updateAppWidgetProvider(ComponentName componentName, RemoteViews views) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetProvider() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider == null) {\n                Slog.w(TAG, \"Provider doesn't exist \" + providerId);\n                return;\n            }\n\n            ArrayList<Widget> instances = provider.widgets;\n            final int N = instances.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = instances.get(i);\n                updateAppWidgetInstanceLocked(widget, views, false);\n            }\n        }\n    }\n\n    @Override\n    public void updateAppWidgetProviderInfo(ComponentName componentName, String metadataKey) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetProvider() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n            if (provider == null) {\n                throw new IllegalArgumentException(\n                        componentName + \" is not a valid AppWidget provider\");\n            }\n            if (Objects.equals(provider.infoTag, metadataKey)) {\n                // No change\n                return;\n            }\n\n            String keyToUse = metadataKey == null\n                    ? AppWidgetManager.META_DATA_APPWIDGET_PROVIDER : metadataKey;\n            AppWidgetProviderInfo info = parseAppWidgetProviderInfo(mContext, providerId,\n                    provider.getPartialInfoLocked().providerInfo, keyToUse);\n            if (info == null) {\n                throw new IllegalArgumentException(\"Unable to parse \" + keyToUse\n                        + \" meta-data to a valid AppWidget provider\");\n            }\n\n            provider.setInfoLocked(info);\n            provider.infoTag = metadataKey;\n\n            // Update all widgets for this provider\n            final int N = provider.widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = provider.widgets.get(i);\n                scheduleNotifyProviderChangedLocked(widget);\n                updateAppWidgetInstanceLocked(widget, widget.views, false /* isPartialUpdate */);\n            }\n\n            saveGroupStateAsync(userId);\n            scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n        }\n    }\n\n    @Override\n    public boolean isRequestPinAppWidgetSupported() {\n        synchronized (mLock) {\n            if (mSecurityPolicy.isCallerInstantAppLocked()) {\n                Slog.w(TAG, \"Instant uid \" + Binder.getCallingUid()\n                        + \" query information about app widgets\");\n                return false;\n            }\n        }\n        return LocalServices.getService(ShortcutServiceInternal.class)\n                .isRequestPinItemSupported(UserHandle.getCallingUserId(),\n                        LauncherApps.PinItemRequest.REQUEST_TYPE_APPWIDGET);\n    }\n\n    @Override\n    public boolean requestPinAppWidget(String callingPackage, ComponentName componentName,\n            Bundle extras, IntentSender resultSender) {\n        final int callingUid = Binder.getCallingUid();\n        final int userId = UserHandle.getUserId(callingUid);\n\n        if (DEBUG) {\n            Slog.i(TAG, \"requestPinAppWidget() \" + userId);\n        }\n\n        final AppWidgetProviderInfo info;\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // Look for the widget associated with the caller.\n            Provider provider = lookupProviderLocked(new ProviderId(callingUid, componentName));\n            if (provider == null || provider.zombie) {\n                return false;\n            }\n            info = provider.getInfoLocked(mContext);\n            if ((info.widgetCategory & AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN) == 0) {\n                return false;\n            }\n        }\n\n        return LocalServices.getService(ShortcutServiceInternal.class)\n                .requestPinAppWidget(callingPackage, info, extras, resultSender, userId);\n    }\n\n    @Override\n    public ParceledListSlice<AppWidgetProviderInfo> getInstalledProvidersForProfile(int categoryFilter,\n            int profileId, String packageName) {\n        final int userId = UserHandle.getCallingUserId();\n        final int callingUid = Binder.getCallingUid();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getInstalledProvidersForProfiles() \" + userId);\n        }\n\n        // Ensure the profile is in the group and enabled.\n        if (!mSecurityPolicy.isEnabledGroupProfile(profileId)) {\n            return null;\n        }\n\n        synchronized (mLock) {\n            if (mSecurityPolicy.isCallerInstantAppLocked()) {\n                Slog.w(TAG, \"Instant uid \" + callingUid\n                        + \" cannot access widget providers\");\n                return ParceledListSlice.emptyList();\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            ArrayList<AppWidgetProviderInfo> result = new ArrayList<AppWidgetProviderInfo>();\n\n            final int providerCount = mProviders.size();\n            for (int i = 0; i < providerCount; i++) {\n                Provider provider = mProviders.get(i);\n                AppWidgetProviderInfo info = provider.getInfoLocked(mContext);\n                final String providerPackageName = provider.id.componentName.getPackageName();\n\n                // Ignore an invalid provider, one not matching the filter,\n                // or one that isn't in the given package, if any.\n                boolean inPackage = packageName == null\n                        || providerPackageName.equals(packageName);\n                if (provider.zombie || (info.widgetCategory & categoryFilter) == 0 || !inPackage) {\n                    continue;\n                }\n\n                // Add providers only for the requested profile that are allowlisted.\n                final int providerProfileId = info.getProfile().getIdentifier();\n                if (providerProfileId == profileId\n                        && mSecurityPolicy.isProviderInCallerOrInProfileAndWhitelListed(\n                        providerPackageName, providerProfileId)\n                        && !mPackageManagerInternal.filterAppAccess(providerPackageName, callingUid,\n                        userId)) {\n                    result.add(cloneIfLocalBinder(info));\n                }\n            }\n\n            return new ParceledListSlice<AppWidgetProviderInfo>(result);\n        }\n    }\n\n    private void updateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views, boolean partially) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (appWidgetIds == null || appWidgetIds.length == 0) {\n            return;\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            final int N = appWidgetIds.length;\n            for (int i = 0; i < N; i++) {\n                final int appWidgetId = appWidgetIds[i];\n\n                // NOTE: The lookup is enforcing security across users by making\n                // sure the caller can only access widgets it hosts or provides.\n                Widget widget = lookupWidgetLocked(appWidgetId,\n                        Binder.getCallingUid(), callingPackage);\n\n                if (widget != null) {\n                    updateAppWidgetInstanceLocked(widget, views, partially);\n                }\n            }\n        }\n    }\n\n    private int incrementAndGetAppWidgetIdLocked(int userId) {\n        final int appWidgetId = peekNextAppWidgetIdLocked(userId) + 1;\n        mNextAppWidgetIds.put(userId, appWidgetId);\n        return appWidgetId;\n    }\n\n    private void setMinAppWidgetIdLocked(int userId, int minWidgetId) {\n        final int nextAppWidgetId = peekNextAppWidgetIdLocked(userId);\n        if (nextAppWidgetId < minWidgetId) {\n            mNextAppWidgetIds.put(userId, minWidgetId);\n        }\n    }\n\n    private int peekNextAppWidgetIdLocked(int userId) {\n        if (mNextAppWidgetIds.indexOfKey(userId) < 0) {\n            return AppWidgetManager.INVALID_APPWIDGET_ID + 1;\n        } else {\n            return mNextAppWidgetIds.get(userId);\n        }\n    }\n\n    private Host lookupOrAddHostLocked(HostId id) {\n        Host host = lookupHostLocked(id);\n        if (host != null) {\n            return host;\n        }\n        ensureHostCountBeforeAddLocked(id);\n        host = new Host();\n        host.id = id;\n        mHosts.add(host);\n\n        return host;\n    }\n\n    /**\n     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n     * removes the oldest host.\n     */\n    private void ensureHostCountBeforeAddLocked(@NonNull final HostId hostId) {\n        final List<Host> hosts = new ArrayList<>();\n        for (Host host : mHosts) {\n            if (host.id.uid == hostId.uid\n                    && host.id.packageName.equals(hostId.packageName)) {\n                hosts.add(host);\n            }\n        }\n        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n            deleteHostLocked(hosts.remove(0));\n        }\n    }\n\n    private void deleteHostLocked(Host host) {\n        final int N = host.widgets.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Widget widget = host.widgets.remove(i);\n            deleteAppWidgetLocked(widget);\n        }\n        mHosts.remove(host);\n\n        // it's gone or going away, abruptly drop the callback connection\n        host.callbacks = null;\n    }\n\n    private void deleteAppWidgetLocked(Widget widget) {\n        // We first unbind all services that are bound to this id\n        // Check if we need to destroy any services (if no other app widgets are\n        // referencing the same service)\n        decrementAppWidgetServiceRefCount(widget);\n\n        Host host = widget.host;\n        host.widgets.remove(widget);\n        pruneHostLocked(host);\n\n        removeWidgetLocked(widget);\n\n        Provider provider = widget.provider;\n        if (provider != null) {\n            provider.widgets.remove(widget);\n            if (!provider.zombie) {\n                // send the broacast saying that this appWidgetId has been deleted\n                sendDeletedIntentLocked(widget);\n\n                if (provider.widgets.isEmpty()) {\n                    // cancel the future updates\n                    cancelBroadcastsLocked(provider);\n\n                    // send the broacast saying that the provider is not in use any more\n                    sendDisabledIntentLocked(provider);\n                }\n            }\n        }\n    }\n\n    private void cancelBroadcastsLocked(Provider provider) {\n        if (DEBUG) {\n            Slog.i(TAG, \"cancelBroadcastsLocked() for \" + provider);\n        }\n        if (provider.broadcast != null) {\n            final PendingIntent broadcast = provider.broadcast;\n            mSaveStateHandler.post(() -> {\n                    mAlarmManager.cancel(broadcast);\n                    broadcast.cancel();\n            });\n            provider.broadcast = null;\n        }\n    }\n\n    // Destroys the cached factory on the RemoteViewsService's side related to the specified intent\n    private void destroyRemoteViewsService(final Intent intent, Widget widget) {\n        final ServiceConnection conn = new ServiceConnection() {\n            @Override\n            public void onServiceConnected(ComponentName name, IBinder service) {\n                final IRemoteViewsFactory cb = IRemoteViewsFactory.Stub.asInterface(service);\n                try {\n                    cb.onDestroy(intent);\n                } catch (RemoteException re) {\n                    Slog.e(TAG, \"Error calling remove view factory\", re);\n                }\n                mContext.unbindService(this);\n            }\n\n            @Override\n            public void onServiceDisconnected(ComponentName name) {\n                // Do nothing\n            }\n        };\n\n        // Bind to the service and remove the static intent->factory mapping in the\n        // RemoteViewsService.\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.bindServiceAsUser(intent, conn,\n                    Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE,\n                    widget.provider.id.getProfile());\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    // Adds to the ref-count for a given RemoteViewsService intent\n    private void incrementAppWidgetServiceRefCount(int appWidgetId,\n            Pair<Integer, FilterComparison> serviceId) {\n        final HashSet<Integer> appWidgetIds;\n        if (mRemoteViewsServicesAppWidgets.containsKey(serviceId)) {\n            appWidgetIds = mRemoteViewsServicesAppWidgets.get(serviceId);\n        } else {\n            appWidgetIds = new HashSet<>();\n            mRemoteViewsServicesAppWidgets.put(serviceId, appWidgetIds);\n        }\n        appWidgetIds.add(appWidgetId);\n    }\n\n    // Subtracts from the ref-count for a given RemoteViewsService intent, prompting a delete if\n    // the ref-count reaches zero.\n    private void decrementAppWidgetServiceRefCount(Widget widget) {\n        Iterator<Pair<Integer, FilterComparison>> it = mRemoteViewsServicesAppWidgets\n                .keySet().iterator();\n        while (it.hasNext()) {\n            final Pair<Integer, FilterComparison> key = it.next();\n            final HashSet<Integer> ids = mRemoteViewsServicesAppWidgets.get(key);\n            if (ids.remove(widget.appWidgetId)) {\n                // If we have removed the last app widget referencing this service, then we\n                // should destroy it and remove it from this set\n                if (ids.isEmpty()) {\n                    destroyRemoteViewsService(key.second.getIntent(), widget);\n                    it.remove();\n                }\n            }\n        }\n    }\n\n    private void saveGroupStateAsync(int groupId) {\n        mSaveStateHandler.post(new SaveStateRunnable(groupId));\n    }\n\n    private void updateAppWidgetInstanceLocked(Widget widget, RemoteViews views,\n            boolean isPartialUpdate) {\n        if (widget != null && widget.provider != null\n                && !widget.provider.zombie && !widget.host.zombie) {\n\n            if (isPartialUpdate && widget.views != null) {\n                // For a partial update, we merge the new RemoteViews with the old.\n                widget.views.mergeRemoteViews(views);\n            } else {\n                // For a full update we replace the RemoteViews completely.\n                widget.views = views;\n            }\n            int memoryUsage;\n            if ((UserHandle.getAppId(Binder.getCallingUid()) != Process.SYSTEM_UID) &&\n                    (widget.views != null) &&\n                    ((memoryUsage = widget.views.estimateMemoryUsage()) > mMaxWidgetBitmapMemory)) {\n                widget.views = null;\n                throw new IllegalArgumentException(\"RemoteViews for widget update exceeds\"\n                        + \" maximum bitmap memory usage (used: \" + memoryUsage\n                        + \", max: \" + mMaxWidgetBitmapMemory + \")\");\n            }\n            scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n        }\n    }\n    private void scheduleNotifyAppWidgetViewDataChanged(Widget widget, int viewId) {\n        if (viewId == ID_VIEWS_UPDATE || viewId == ID_PROVIDER_CHANGED) {\n            // A view id should never collide with these constants but a developer can call this\n            // method with a wrong id. In that case, ignore the call.\n            return;\n        }\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.put(viewId, requestId);\n        }\n        if (widget == null || widget.host == null || widget.host.zombie\n                || widget.host.callbacks == null || widget.provider == null\n                || widget.provider.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = requestId;\n        args.argi1 = widget.appWidgetId;\n        args.argi2 = viewId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_VIEW_DATA_CHANGED,\n                args).sendToTarget();\n    }\n\n\n    private void handleNotifyAppWidgetViewDataChanged(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, int viewId, long requestId) {\n        try {\n            callbacks.viewDataChanged(appWidgetId, viewId);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            // It failed; remove the callback. No need to prune because\n            // we know that this host is still referenced by this instance.\n            callbacks = null;\n        }\n\n        // If the host is unavailable, then we call the associated\n        // RemoteViewsFactory.onDataSetChanged() directly\n        synchronized (mLock) {\n            if (callbacks == null) {\n                host.callbacks = null;\n\n                Set<Pair<Integer, FilterComparison>> keys = mRemoteViewsServicesAppWidgets.keySet();\n                for (Pair<Integer, FilterComparison> key : keys) {\n                    if (mRemoteViewsServicesAppWidgets.get(key).contains(appWidgetId)) {\n                        final ServiceConnection connection = new ServiceConnection() {\n                            @Override\n                            public void onServiceConnected(ComponentName name, IBinder service) {\n                                IRemoteViewsFactory cb = IRemoteViewsFactory.Stub\n                                        .asInterface(service);\n                                try {\n                                    cb.onDataSetChangedAsync();\n                                } catch (RemoteException e) {\n                                    Slog.e(TAG, \"Error calling onDataSetChangedAsync()\", e);\n                                }\n                                mContext.unbindService(this);\n                            }\n\n                            @Override\n                            public void onServiceDisconnected(android.content.ComponentName name) {\n                                // Do nothing\n                            }\n                        };\n\n                        final int userId = UserHandle.getUserId(key.first);\n                        Intent intent = key.second.getIntent();\n\n                        // Bind to the service and call onDataSetChanged()\n                        bindService(intent, connection, new UserHandle(userId));\n                    }\n                }\n            }\n        }\n    }\n\n    private void scheduleNotifyUpdateAppWidgetLocked(Widget widget, RemoteViews updateViews) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.put(ID_VIEWS_UPDATE, requestId);\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n        if (updateViews != null) {\n            updateViews = new RemoteViews(updateViews);\n            updateViews.setProviderInstanceId(requestId);\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = updateViews;\n        args.arg4 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_UPDATE_APP_WIDGET,\n                args).sendToTarget();\n    }\n\n    private void handleNotifyUpdateAppWidget(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, RemoteViews views, long requestId) {\n        try {\n            callbacks.updateAppWidget(appWidgetId, views);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyProviderChangedLocked(Widget widget) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            // When the provider changes, reset everything else.\n            widget.updateSequenceNos.clear();\n            widget.updateSequenceNos.append(ID_PROVIDER_CHANGED, requestId);\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = widget.provider.getInfoLocked(mContext);\n        args.arg4 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_PROVIDER_CHANGED,\n                args).sendToTarget();\n    }\n\n    private void handleNotifyProviderChanged(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, AppWidgetProviderInfo info, long requestId) {\n        try {\n            callbacks.providerChanged(appWidgetId, info);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock){\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyAppWidgetRemovedLocked(Widget widget) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.clear();\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n            CallbackHandler.MSG_NOTIFY_APP_WIDGET_REMOVED,\n            args).sendToTarget();\n    }\n\n    private void handleNotifyAppWidgetRemoved(Host host, IAppWidgetHost callbacks, int appWidgetId,\n            long requestId) {\n        try {\n            callbacks.appWidgetRemoved(appWidgetId);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyGroupHostsForProvidersChangedLocked(int userId) {\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        final int N = mHosts.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Host host = mHosts.get(i);\n\n            boolean hostInGroup = false;\n            final int M = profileIds.length;\n            for (int j = 0; j < M; j++) {\n                final int profileId = profileIds[j];\n                if (host.getUserId() == profileId) {\n                    hostInGroup = true;\n                    break;\n                }\n            }\n\n            if (!hostInGroup) {\n                continue;\n            }\n\n            if (host == null || host.zombie || host.callbacks == null) {\n                continue;\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = host;\n            args.arg2 = host.callbacks;\n\n            mCallbackHandler.obtainMessage(\n                    CallbackHandler.MSG_NOTIFY_PROVIDERS_CHANGED,\n                    args).sendToTarget();\n        }\n    }\n\n    private void handleNotifyProvidersChanged(Host host, IAppWidgetHost callbacks) {\n        try {\n            callbacks.providersChanged();\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private static boolean isLocalBinder() {\n        return Process.myPid() == Binder.getCallingPid();\n    }\n\n    private static RemoteViews cloneIfLocalBinder(RemoteViews rv) {\n        if (isLocalBinder() && rv != null) {\n            return rv.clone();\n        }\n        return rv;\n    }\n\n    private static AppWidgetProviderInfo cloneIfLocalBinder(AppWidgetProviderInfo info) {\n        if (isLocalBinder() && info != null) {\n            return info.clone();\n        }\n        return info;\n    }\n\n    private static Bundle cloneIfLocalBinder(Bundle bundle) {\n        // Note: this is only a shallow copy. For now this will be fine, but it could be problematic\n        // if we start adding objects to the options. Further, it would only be an issue if keyguard\n        // used such options.\n        if (isLocalBinder() && bundle != null) {\n            return (Bundle) bundle.clone();\n        }\n        return bundle;\n    }\n\n    private Widget lookupWidgetLocked(int appWidgetId, int uid, String packageName) {\n        final int N = mWidgets.size();\n        for (int i = 0; i < N; i++) {\n            Widget widget = mWidgets.get(i);\n            if (widget.appWidgetId == appWidgetId\n                    && mSecurityPolicy.canAccessAppWidget(widget, uid, packageName)) {\n                return widget;\n            }\n        }\n        return null;\n    }\n\n    private Provider lookupProviderLocked(ProviderId id) {\n        final int N = mProviders.size();\n        for (int i = 0; i < N; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.id.equals(id)) {\n                return provider;\n            }\n        }\n        return null;\n    }\n\n    private Host lookupHostLocked(HostId hostId) {\n        final int N = mHosts.size();\n        for (int i = 0; i < N; i++) {\n            Host host = mHosts.get(i);\n            if (host.id.equals(hostId)) {\n                return host;\n            }\n        }\n        return null;\n    }\n\n    private void pruneHostLocked(Host host) {\n        if (host.widgets.size() == 0 && host.callbacks == null) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Pruning host \" + host.id);\n            }\n            mHosts.remove(host);\n        }\n    }\n\n    private void loadGroupWidgetProvidersLocked(int[] profileIds) {\n        List<ResolveInfo> allReceivers = null;\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n\n        final int profileCount = profileIds.length;\n        for (int i = 0; i < profileCount; i++) {\n            final int profileId = profileIds[i];\n\n            List<ResolveInfo> receivers = queryIntentReceivers(intent, profileId);\n            if (receivers != null && !receivers.isEmpty()) {\n                if (allReceivers == null) {\n                    allReceivers = new ArrayList<>();\n                }\n                allReceivers.addAll(receivers);\n            }\n        }\n\n        final int N = (allReceivers == null) ? 0 : allReceivers.size();\n        for (int i = 0; i < N; i++) {\n            ResolveInfo receiver = allReceivers.get(i);\n            addProviderLocked(receiver);\n        }\n    }\n\n    private boolean addProviderLocked(ResolveInfo ri) {\n        if ((ri.activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {\n            return false;\n        }\n\n        ComponentName componentName = new ComponentName(ri.activityInfo.packageName,\n                ri.activityInfo.name);\n        ProviderId providerId = new ProviderId(ri.activityInfo.applicationInfo.uid, componentName);\n\n        // we might have an inactive entry for this provider already due to\n        // a preceding restore operation.  if so, fix it up in place; otherwise\n        // just add this new one.\n        Provider existing = lookupProviderLocked(providerId);\n\n        // If the provider was not found it may be because it was restored and\n        // we did not know its UID so let us find if there is such one.\n        if (existing == null) {\n            ProviderId restoredProviderId = new ProviderId(UNKNOWN_UID, componentName);\n            existing = lookupProviderLocked(restoredProviderId);\n        }\n\n        AppWidgetProviderInfo info = createPartialProviderInfo(providerId, ri, existing);\n        if (info != null) {\n            if (existing != null) {\n                if (existing.zombie && !mSafeMode) {\n                    // it's a placeholder that was set up during an app restore\n                    existing.id = providerId;\n                    existing.zombie = false;\n                    existing.setPartialInfoLocked(info);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Provider placeholder now reified: \" + existing);\n                    }\n                }\n            } else {\n                Provider provider = new Provider();\n                provider.id = providerId;\n                provider.setPartialInfoLocked(info);\n                mProviders.add(provider);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    // Remove widgets for provider that are hosted in userId.\n    private void deleteWidgetsLocked(Provider provider, int userId) {\n        final int N = provider.widgets.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Widget widget = provider.widgets.get(i);\n            if (userId == UserHandle.USER_ALL\n                    || userId == widget.host.getUserId()) {\n                provider.widgets.remove(i);\n                // Call back with empty RemoteViews\n                updateAppWidgetInstanceLocked(widget, null, false);\n                // clear out references to this appWidgetId\n                widget.host.widgets.remove(widget);\n                removeWidgetLocked(widget);\n                widget.provider = null;\n                pruneHostLocked(widget.host);\n                widget.host = null;\n            }\n        }\n    }\n\n    private void deleteProviderLocked(Provider provider) {\n        deleteWidgetsLocked(provider, UserHandle.USER_ALL);\n        mProviders.remove(provider);\n\n        // no need to send the DISABLE broadcast, since the receiver is gone anyway\n        cancelBroadcastsLocked(provider);\n    }\n\n    private void sendEnableIntentLocked(Provider p) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_ENABLED);\n        intent.setComponent(p.id.componentName);\n        sendBroadcastAsUser(intent, p.id.getProfile());\n    }\n\n    private void sendUpdateIntentLocked(Provider provider, int[] appWidgetIds) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds);\n        intent.setComponent(provider.id.componentName);\n        sendBroadcastAsUser(intent, provider.id.getProfile());\n    }\n\n    private void sendDeletedIntentLocked(Widget widget) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_DELETED);\n        intent.setComponent(widget.provider.id.componentName);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, widget.appWidgetId);\n        sendBroadcastAsUser(intent, widget.provider.id.getProfile());\n    }\n\n    private void sendDisabledIntentLocked(Provider provider) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_DISABLED);\n        intent.setComponent(provider.id.componentName);\n        sendBroadcastAsUser(intent, provider.id.getProfile());\n    }\n\n    public void sendOptionsChangedIntentLocked(Widget widget) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_OPTIONS_CHANGED);\n        intent.setComponent(widget.provider.id.componentName);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, widget.appWidgetId);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS, widget.options);\n        sendBroadcastAsUser(intent, widget.provider.id.getProfile());\n    }\n\n    private void registerForBroadcastsLocked(Provider provider, int[] appWidgetIds) {\n        AppWidgetProviderInfo info = provider.getInfoLocked(mContext);\n        if (info.updatePeriodMillis > 0) {\n            // if this is the first instance, set the alarm. otherwise,\n            // rely on the fact that we've already set it and that\n            // PendingIntent.getBroadcast will update the extras.\n            boolean alreadyRegistered = provider.broadcast != null;\n            Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds);\n            intent.setComponent(info.provider);\n            final long token = Binder.clearCallingIdentity();\n            try {\n                // Broadcast alarms sent by system are immutable\n                provider.broadcast = PendingIntent.getBroadcastAsUser(mContext, 1, intent,\n                        PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                        info.getProfile());\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (!alreadyRegistered) {\n                // Set the alarm outside of our locks; we've latched the first-time\n                // invariant and established the PendingIntent safely.\n                final long period = Math.max(info.updatePeriodMillis, MIN_UPDATE_PERIOD);\n                final PendingIntent broadcast = provider.broadcast;\n                mSaveStateHandler.post(() ->\n                    mAlarmManager.setInexactRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,\n                            SystemClock.elapsedRealtime() + period, period, broadcast)\n                );\n            }\n        }\n    }\n\n    private static int[] getWidgetIds(ArrayList<Widget> widgets) {\n        int instancesSize = widgets.size();\n        int appWidgetIds[] = new int[instancesSize];\n        for (int i = 0; i < instancesSize; i++) {\n            appWidgetIds[i] = widgets.get(i).appWidgetId;\n        }\n        return appWidgetIds;\n    }\n\n    private static void dumpProviderLocked(Provider provider, int index, PrintWriter pw) {\n        AppWidgetProviderInfo info = provider.getPartialInfoLocked();\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] provider \");\n        pw.println(provider.id);\n        pw.print(\"    min=(\"); pw.print(info.minWidth);\n        pw.print(\"x\"); pw.print(info.minHeight);\n        pw.print(\")   minResize=(\"); pw.print(info.minResizeWidth);\n        pw.print(\"x\"); pw.print(info.minResizeHeight);\n        pw.print(\") updatePeriodMillis=\");\n        pw.print(info.updatePeriodMillis);\n        pw.print(\" resizeMode=\");\n        pw.print(info.resizeMode);\n        pw.print(\" widgetCategory=\");\n        pw.print(info.widgetCategory);\n        pw.print(\" autoAdvanceViewId=\");\n        pw.print(info.autoAdvanceViewId);\n        pw.print(\" initialLayout=#\");\n        pw.print(Integer.toHexString(info.initialLayout));\n        pw.print(\" initialKeyguardLayout=#\");\n        pw.print(Integer.toHexString(info.initialKeyguardLayout));\n        pw.print(\"   zombie=\"); pw.println(provider.zombie);\n    }\n\n    private static void dumpHost(Host host, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] hostId=\");\n        pw.println(host.id);\n        pw.print(\"    callbacks=\"); pw.println(host.callbacks);\n        pw.print(\"    widgets.size=\"); pw.print(host.widgets.size());\n        pw.print(\" zombie=\"); pw.println(host.zombie);\n    }\n\n    private static void dumpGrant(Pair<Integer, String> grant, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(']');\n        pw.print(\" user=\"); pw.print(grant.first);\n        pw.print(\" package=\"); pw.println(grant.second);\n    }\n\n    private static void dumpWidget(Widget widget, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] id=\");\n        pw.println(widget.appWidgetId);\n        pw.print(\"    host=\");\n        pw.println(widget.host.id);\n        if (widget.provider != null) {\n            pw.print(\"    provider=\"); pw.println(widget.provider.id);\n        }\n        if (widget.host != null) {\n            pw.print(\"    host.callbacks=\"); pw.println(widget.host.callbacks);\n        }\n        if (widget.views != null) {\n            pw.print(\"    views=\"); pw.println(widget.views);\n        }\n    }\n\n    private static void serializeProvider(TypedXmlSerializer out, Provider p) throws IOException {\n        out.startTag(null, \"p\");\n        out.attribute(null, \"pkg\", p.id.componentName.getPackageName());\n        out.attribute(null, \"cl\", p.id.componentName.getClassName());\n        out.attributeIntHex(null, \"tag\", p.tag);\n        if (!TextUtils.isEmpty(p.infoTag)) {\n            out.attribute(null, \"info_tag\", p.infoTag);\n        }\n        out.endTag(null, \"p\");\n    }\n\n    private static void serializeHost(TypedXmlSerializer out, Host host) throws IOException {\n        out.startTag(null, \"h\");\n        out.attribute(null, \"pkg\", host.id.packageName);\n        out.attributeIntHex(null, \"id\", host.id.hostId);\n        out.attributeIntHex(null, \"tag\", host.tag);\n        out.endTag(null, \"h\");\n    }\n\n    private static void serializeAppWidget(TypedXmlSerializer out, Widget widget,\n            boolean saveRestoreCompleted) throws IOException {\n        out.startTag(null, \"g\");\n        out.attributeIntHex(null, \"id\", widget.appWidgetId);\n        out.attributeIntHex(null, \"rid\", widget.restoredId);\n        out.attributeIntHex(null, \"h\", widget.host.tag);\n        if (widget.provider != null) {\n            out.attributeIntHex(null, \"p\", widget.provider.tag);\n        }\n        if (widget.options != null) {\n            int minWidth = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH);\n            int minHeight = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT);\n            int maxWidth = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH);\n            int maxHeight = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT);\n            out.attributeIntHex(null, \"min_width\", (minWidth > 0) ? minWidth : 0);\n            out.attributeIntHex(null, \"min_height\", (minHeight > 0) ? minHeight : 0);\n            out.attributeIntHex(null, \"max_width\", (maxWidth > 0) ? maxWidth : 0);\n            out.attributeIntHex(null, \"max_height\", (maxHeight > 0) ? maxHeight : 0);\n            out.attributeIntHex(null, \"host_category\", widget.options.getInt(\n                    AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY));\n            if (saveRestoreCompleted) {\n                boolean restoreCompleted = widget.options.getBoolean(\n                        AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED);\n                out.attributeBoolean(null, \"restore_completed\", restoreCompleted);\n            }\n        }\n        out.endTag(null, \"g\");\n    }\n\n    private static Bundle parseWidgetIdOptions(TypedXmlPullParser parser) {\n        Bundle options = new Bundle();\n        boolean restoreCompleted = parser.getAttributeBoolean(null, \"restore_completed\", false);\n        if (restoreCompleted) {\n            options.putBoolean(AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED, true);\n        }\n        int minWidth = parser.getAttributeIntHex(null, \"min_width\", -1);\n        if (minWidth != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH, minWidth);\n        }\n        int minHeight = parser.getAttributeIntHex(null, \"min_height\", -1);\n        if (minHeight != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, minHeight);\n        }\n        int maxWidth = parser.getAttributeIntHex(null, \"max_width\", -1);\n        if (maxWidth != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH, maxWidth);\n        }\n        int maxHeight = parser.getAttributeIntHex(null, \"max_height\", -1);\n        if (maxHeight != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, maxHeight);\n        }\n        int category = parser.getAttributeIntHex(null, \"host_category\",\n                AppWidgetProviderInfo.WIDGET_CATEGORY_UNKNOWN);\n        if (category != AppWidgetProviderInfo.WIDGET_CATEGORY_UNKNOWN) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY, category);\n        }\n        return options;\n    }\n\n    @Override\n    public List<String> getWidgetParticipants(int userId) {\n        return mBackupRestoreController.getWidgetParticipants(userId);\n    }\n\n    @Override\n    public byte[] getWidgetState(String packageName, int userId) {\n        return mBackupRestoreController.getWidgetState(packageName, userId);\n    }\n\n    @Override\n    public void systemRestoreStarting(int userId) {\n        mBackupRestoreController.systemRestoreStarting(userId);\n    }\n\n    @Override\n    public void restoreWidgetState(String packageName, byte[] restoredState, int userId) {\n        mBackupRestoreController.restoreWidgetState(packageName, restoredState, userId);\n    }\n\n    @Override\n    public void systemRestoreFinished(int userId) {\n        mBackupRestoreController.systemRestoreFinished(userId);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private AppWidgetProviderInfo createPartialProviderInfo(ProviderId providerId, ResolveInfo ri,\n            Provider provider) {\n        boolean hasXmlDefinition = false;\n        Bundle metaData = ri.activityInfo.metaData;\n        if (metaData == null) {\n            return null;\n        }\n\n        if (provider != null && !TextUtils.isEmpty(provider.infoTag)) {\n            hasXmlDefinition = metaData.getInt(provider.infoTag) != 0;\n        }\n        hasXmlDefinition |= metaData.getInt(AppWidgetManager.META_DATA_APPWIDGET_PROVIDER) != 0;\n\n        if (hasXmlDefinition) {\n            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n            info.provider = providerId.componentName;\n            info.providerInfo = ri.activityInfo;\n            return info;\n        }\n        return null;\n    }\n\n    private static AppWidgetProviderInfo parseAppWidgetProviderInfo(Context context,\n            ProviderId providerId, ActivityInfo activityInfo, String metadataKey) {\n        final PackageManager pm = context.getPackageManager();\n        try (XmlResourceParser parser = activityInfo.loadXmlMetaData(pm, metadataKey)) {\n            if (parser == null) {\n                Slog.w(TAG, \"No \" + metadataKey + \" meta-data for AppWidget provider '\"\n                        + providerId + '\\'');\n                return null;\n            }\n\n            AttributeSet attrs = Xml.asAttributeSet(parser);\n\n            int type;\n            while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                    && type != XmlPullParser.START_TAG) {\n                // drain whitespace, comments, etc.\n            }\n\n            String nodeName = parser.getName();\n            if (!\"appwidget-provider\".equals(nodeName)) {\n                Slog.w(TAG, \"Meta-data does not start with appwidget-provider tag for\"\n                        + \" AppWidget provider \" + providerId.componentName\n                        + \" for user \" + providerId.uid);\n                return null;\n            }\n\n            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n            info.provider = providerId.componentName;\n            info.providerInfo = activityInfo;\n\n            final Resources resources;\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final int userId = UserHandle.getUserId(providerId.uid);\n                final ApplicationInfo app = pm.getApplicationInfoAsUser(activityInfo.packageName,\n                        0, userId);\n                resources = pm.getResourcesForApplication(app);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n\n            TypedArray sa = resources.obtainAttributes(attrs,\n                    com.android.internal.R.styleable.AppWidgetProviderInfo);\n\n            // These dimensions has to be resolved in the application's context.\n            // We simply send back the raw complex data, which will be\n            // converted to dp in {@link AppWidgetManager#getAppWidgetInfo}.\n            TypedValue value = sa\n                    .peekValue(com.android.internal.R.styleable.AppWidgetProviderInfo_minWidth);\n            info.minWidth = value != null ? value.data : 0;\n            value = sa.peekValue(com.android.internal.R.styleable.AppWidgetProviderInfo_minHeight);\n            info.minHeight = value != null ? value.data : 0;\n\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_minResizeWidth);\n            info.minResizeWidth = value != null ? value.data : info.minWidth;\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_minResizeHeight);\n            info.minResizeHeight = value != null ? value.data : info.minHeight;\n\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_maxResizeWidth);\n            info.maxResizeWidth = value != null ? value.data : 0;\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_maxResizeHeight);\n            info.maxResizeHeight = value != null ? value.data : 0;\n\n            info.targetCellWidth = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_targetCellWidth, 0);\n            info.targetCellHeight = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_targetCellHeight, 0);\n\n            info.updatePeriodMillis = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_updatePeriodMillis, 0);\n            info.initialLayout = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_initialLayout, ID_NULL);\n            info.initialKeyguardLayout = sa.getResourceId(com.android.internal.R.styleable.\n                    AppWidgetProviderInfo_initialKeyguardLayout, ID_NULL);\n\n            String className = sa\n                    .getString(com.android.internal.R.styleable.AppWidgetProviderInfo_configure);\n            if (className != null) {\n                info.configure = new ComponentName(providerId.componentName.getPackageName(),\n                        className);\n            }\n            info.label = activityInfo.loadLabel(pm).toString();\n            info.icon = activityInfo.getIconResource();\n            info.previewImage = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_previewImage, ID_NULL);\n            info.previewLayout = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_previewLayout, ID_NULL);\n            info.autoAdvanceViewId = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_autoAdvanceViewId,\n                    View.NO_ID);\n            info.resizeMode = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_resizeMode,\n                    AppWidgetProviderInfo.RESIZE_NONE);\n            info.widgetCategory = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_widgetCategory,\n                    AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN);\n            info.widgetFeatures = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_widgetFeatures, 0);\n            info.descriptionRes = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_description, ID_NULL);\n            sa.recycle();\n            return info;\n        } catch (IOException | PackageManager.NameNotFoundException | XmlPullParserException e) {\n            // Ok to catch Exception here, because anything going wrong because\n            // of what a client process passes to us should not be fatal for the\n            // system process.\n            Slog.w(TAG, \"XML parsing failed for AppWidget provider \"\n                    + providerId.componentName + \" for user \" + providerId.uid, e);\n            return null;\n        }\n    }\n\n    private int getUidForPackage(String packageName, int userId) {\n        PackageInfo pkgInfo = null;\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            pkgInfo = mPackageManager.getPackageInfo(packageName, 0, userId);\n        } catch (RemoteException re) {\n            // Shouldn't happen, local call\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n\n        if (pkgInfo == null || pkgInfo.applicationInfo == null) {\n            return -1;\n        }\n\n        return pkgInfo.applicationInfo.uid;\n    }\n\n    private ActivityInfo getProviderInfo(ComponentName componentName, int userId) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.setComponent(componentName);\n\n        List<ResolveInfo> receivers = queryIntentReceivers(intent, userId);\n        // We are setting component, so there is only one or none.\n        if (!receivers.isEmpty()) {\n            return receivers.get(0).activityInfo;\n        }\n\n        return null;\n    }\n\n    private List<ResolveInfo> queryIntentReceivers(Intent intent, int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            int flags = PackageManager.GET_META_DATA;\n\n            // We really need packages to be around and parsed to know if they\n            // provide widgets.\n            flags |= PackageManager.MATCH_DEBUG_TRIAGED_MISSING;\n\n            // Widget hosts that are non-crypto aware may be hosting widgets\n            // from a profile that is still locked, so let them see those\n            // widgets.\n            if (isProfileWithUnlockedParent(userId)) {\n                flags |= PackageManager.MATCH_DIRECT_BOOT_AWARE\n                        | PackageManager.MATCH_DIRECT_BOOT_UNAWARE;\n            }\n\n            // Widgets referencing shared libraries need to have their\n            // dependencies loaded.\n            flags |= PackageManager.GET_SHARED_LIBRARY_FILES;\n\n            return mPackageManager.queryIntentReceivers(intent,\n                    intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                    flags, userId).getList();\n        } catch (RemoteException re) {\n            return Collections.emptyList();\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    /**\n     * This does not use the usual onUserUnlocked() listener mechanism because it is\n     * invoked at a choreographed point in the middle of the user unlock sequence,\n     * before the boot-completed broadcast is issued and the listeners notified.\n     */\n    void handleUserUnlocked(int userId) {\n        if (isProfileWithLockedParent(userId)) {\n            return;\n        }\n        if (!mUserManager.isUserUnlockingOrUnlocked(userId)) {\n            Slog.w(TAG, \"User \" + userId + \" is no longer unlocked - exiting\");\n            return;\n        }\n        long time = SystemClock.elapsedRealtime();\n        synchronized (mLock) {\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"appwidget ensure\");\n            ensureGroupStateLoadedLocked(userId);\n            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"appwidget reload\");\n            reloadWidgetsMaskedStateForGroup(mSecurityPolicy.getGroupParent(userId));\n            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n\n                // Send broadcast only to the providers of the user.\n                if (provider.getUserId() != userId) {\n                    continue;\n                }\n\n                if (provider.widgets.size() > 0) {\n                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,\n                            \"appwidget init \" + provider.id.componentName.getPackageName());\n                    sendEnableIntentLocked(provider);\n                    int[] appWidgetIds = getWidgetIds(provider.widgets);\n                    sendUpdateIntentLocked(provider, appWidgetIds);\n                    registerForBroadcastsLocked(provider, appWidgetIds);\n                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n                }\n            }\n        }\n        Slog.i(TAG, \"Processing of handleUserUnlocked u\" + userId + \" took \"\n                + (SystemClock.elapsedRealtime() - time) + \" ms\");\n    }\n\n    // only call from initialization -- it assumes that the data structures are all empty\n    private void loadGroupStateLocked(int[] profileIds) {\n        // We can bind the widgets to host and providers only after\n        // reading the host and providers for all users since a widget\n        // can have a host and a provider in different users.\n        List<LoadedWidgetState> loadedWidgets = new ArrayList<>();\n\n        int version = 0;\n\n        final int profileIdCount = profileIds.length;\n        for (int i = 0; i < profileIdCount; i++) {\n            final int profileId = profileIds[i];\n\n            // No file written for this user - nothing to do.\n            AtomicFile file = getSavedStateFile(profileId);\n            try (FileInputStream stream = file.openRead()) {\n                version = readProfileStateFromFileLocked(stream, profileId, loadedWidgets);\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to read state: \" + e);\n            }\n        }\n\n        if (version >= 0) {\n            // Hooke'm up...\n            bindLoadedWidgetsLocked(loadedWidgets);\n\n            // upgrade the database if needed\n            performUpgradeLocked(version);\n        } else {\n            // failed reading, clean up\n            Slog.w(TAG, \"Failed to read state, clearing widgets and hosts.\");\n            clearWidgetsLocked();\n            mHosts.clear();\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                mProviders.get(i).widgets.clear();\n            }\n        }\n    }\n\n    private void bindLoadedWidgetsLocked(List<LoadedWidgetState> loadedWidgets) {\n        final int loadedWidgetCount = loadedWidgets.size();\n        for (int i = loadedWidgetCount - 1; i >= 0; i--) {\n            LoadedWidgetState loadedWidget = loadedWidgets.remove(i);\n            Widget widget = loadedWidget.widget;\n\n            widget.provider = findProviderByTag(loadedWidget.providerTag);\n            if (widget.provider == null) {\n                // This provider is gone. We just let the host figure out\n                // that this happened when it fails to load it.\n                continue;\n            }\n\n            widget.host = findHostByTag(loadedWidget.hostTag);\n            if (widget.host == null) {\n                // This host is gone.\n                continue;\n            }\n\n            widget.provider.widgets.add(widget);\n            widget.host.widgets.add(widget);\n            addWidgetLocked(widget);\n        }\n    }\n\n    private Provider findProviderByTag(int tag) {\n        if (tag < 0) {\n            return null;\n        }\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.tag == tag) {\n                return provider;\n            }\n        }\n        return null;\n    }\n\n    private Host findHostByTag(int tag) {\n        if (tag < 0) {\n            return null;\n        }\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            if (host.tag == tag) {\n                return host;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n     */\n    void addWidgetLocked(Widget widget) {\n        mWidgets.add(widget);\n\n        onWidgetProviderAddedOrChangedLocked(widget);\n    }\n\n    /**\n     * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n     * that have bound widgets.\n     */\n    void onWidgetProviderAddedOrChangedLocked(Widget widget) {\n        if (widget.provider == null) return;\n\n        int userId = widget.provider.getUserId();\n        synchronized (mWidgetPackagesLock) {\n            ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages == null) {\n                mWidgetPackages.put(userId, packages = new ArraySet<String>());\n            }\n            packages.add(widget.provider.id.componentName.getPackageName());\n        }\n\n        // If we are adding a widget it might be for a provider that\n        // is currently masked, if so mask the widget.\n        if (widget.provider.isMaskedLocked()) {\n            maskWidgetsViewsLocked(widget.provider, widget);\n        } else {\n            widget.clearMaskedViewsLocked();\n        }\n    }\n\n    /**\n     * Removes a widget from mWidgets and updates the cache of bound widget provider packages.\n     * If there are other widgets with the same package, leaves it in the cache, otherwise it\n     * removes the associated package from the cache.\n     */\n    void removeWidgetLocked(Widget widget) {\n        mWidgets.remove(widget);\n        onWidgetRemovedLocked(widget);\n        scheduleNotifyAppWidgetRemovedLocked(widget);\n    }\n\n    private void onWidgetRemovedLocked(Widget widget) {\n        if (widget.provider == null) return;\n\n        final int userId = widget.provider.getUserId();\n        final String packageName = widget.provider.id.componentName.getPackageName();\n        synchronized (mWidgetPackagesLock) {\n            ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages == null) {\n                return;\n            }\n            // Check if there is any other widget with the same package name.\n            // Remove packageName if none.\n            final int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget w = mWidgets.get(i);\n                if (w.provider == null) continue;\n                if (w.provider.getUserId() == userId\n                        && packageName.equals(w.provider.id.componentName.getPackageName())) {\n                    return;\n                }\n            }\n            packages.remove(packageName);\n        }\n    }\n\n    /**\n     * Clears all widgets and associated cache of packages with bound widgets.\n     */\n    void clearWidgetsLocked() {\n        mWidgets.clear();\n\n        onWidgetsClearedLocked();\n    }\n\n    private void onWidgetsClearedLocked() {\n        synchronized (mWidgetPackagesLock) {\n            mWidgetPackages.clear();\n        }\n    }\n\n    @Override\n    public boolean isBoundWidgetPackage(String packageName, int userId) {\n        if (Binder.getCallingUid() != Process.SYSTEM_UID) {\n            throw new SecurityException(\"Only the system process can call this\");\n        }\n        synchronized (mWidgetPackagesLock) {\n            final ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages != null) {\n                return packages.contains(packageName);\n            }\n        }\n        return false;\n    }\n\n    private void saveStateLocked(int userId) {\n        tagProvidersAndHosts();\n\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        final int profileCount = profileIds.length;\n        for (int i = 0; i < profileCount; i++) {\n            final int profileId = profileIds[i];\n\n            AtomicFile file = getSavedStateFile(profileId);\n            FileOutputStream stream;\n            try {\n                stream = file.startWrite();\n                if (writeProfileStateToFileLocked(stream, profileId)) {\n                    file.finishWrite(stream);\n                } else {\n                    file.failWrite(stream);\n                    Slog.w(TAG, \"Failed to save state, restoring backup.\");\n                }\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed open state file for write: \" + e);\n            }\n        }\n    }\n\n    private void tagProvidersAndHosts() {\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            provider.tag = i;\n        }\n\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            host.tag = i;\n        }\n    }\n\n    private void clearProvidersAndHostsTagsLocked() {\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            provider.tag = TAG_UNDEFINED;\n        }\n\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            host.tag = TAG_UNDEFINED;\n        }\n    }\n\n    private boolean writeProfileStateToFileLocked(FileOutputStream stream, int userId) {\n        int N;\n\n        try {\n            TypedXmlSerializer out = Xml.resolveSerializer(stream);\n            out.startDocument(null, true);\n            out.startTag(null, \"gs\");\n            out.attributeInt(null, \"version\", CURRENT_VERSION);\n\n            N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                // Save only providers for the user.\n                if (provider.getUserId() != userId) {\n                    continue;\n                }\n                if (provider.shouldBePersisted()) {\n                    serializeProvider(out, provider);\n                }\n            }\n\n            N = mHosts.size();\n            for (int i = 0; i < N; i++) {\n                Host host = mHosts.get(i);\n                // Save only hosts for the user.\n                if (host.getUserId() != userId) {\n                    continue;\n                }\n                serializeHost(out, host);\n            }\n\n            N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n                // Save only widgets hosted by the user.\n                if (widget.host.getUserId() != userId) {\n                    continue;\n                }\n                serializeAppWidget(out, widget, true);\n            }\n\n            Iterator<Pair<Integer, String>> it = mPackagesWithBindWidgetPermission.iterator();\n            while (it.hasNext()) {\n                Pair<Integer, String> binding = it.next();\n                // Save only white listings for the user.\n                if (binding.first != userId) {\n                    continue;\n                }\n                out.startTag(null, \"b\");\n                out.attribute(null, \"packageName\", binding.second);\n                out.endTag(null, \"b\");\n            }\n\n            out.endTag(null, \"gs\");\n            out.endDocument();\n            return true;\n        } catch (IOException e) {\n            Slog.w(TAG, \"Failed to write state: \" + e);\n            return false;\n        }\n    }\n\n    private int readProfileStateFromFileLocked(FileInputStream stream, int userId,\n            List<LoadedWidgetState> outLoadedWidgets) {\n        int version = -1;\n        try {\n            TypedXmlPullParser parser = Xml.resolvePullParser(stream);\n\n            int legacyProviderIndex = -1;\n            int legacyHostIndex = -1;\n            int type;\n            do {\n                type = parser.next();\n                if (type == XmlPullParser.START_TAG) {\n                    String tag = parser.getName();\n                    if (\"gs\".equals(tag)) {\n                        version = parser.getAttributeInt(null, \"version\", 0);\n                    } else if (\"p\".equals(tag)) {\n                        legacyProviderIndex++;\n                        // TODO: do we need to check that this package has the same signature\n                        // as before?\n                        String pkg = parser.getAttributeValue(null, \"pkg\");\n                        String cl = parser.getAttributeValue(null, \"cl\");\n\n                        pkg = getCanonicalPackageName(pkg, cl, userId);\n                        if (pkg == null) {\n                            continue;\n                        }\n\n                        final int uid = getUidForPackage(pkg, userId);\n                        if (uid < 0) {\n                            continue;\n                        }\n\n                        ComponentName componentName = new ComponentName(pkg, cl);\n\n                        ActivityInfo providerInfo = getProviderInfo(componentName, userId);\n                        if (providerInfo == null) {\n                            continue;\n                        }\n\n                        ProviderId providerId = new ProviderId(uid, componentName);\n                        Provider provider = lookupProviderLocked(providerId);\n\n                        if (provider == null && mSafeMode) {\n                            // if we're in safe mode, make a temporary one\n                            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n                            info.provider = providerId.componentName;\n                            info.providerInfo = providerInfo;\n\n                            provider = new Provider();\n                            provider.setPartialInfoLocked(info);\n                            provider.zombie = true;\n                            provider.id = providerId;\n                            mProviders.add(provider);\n                        }\n\n                        final int providerTag = parser.getAttributeIntHex(null, \"tag\",\n                                legacyProviderIndex);\n                        provider.tag = providerTag;\n                        provider.infoTag = parser.getAttributeValue(null, \"info_tag\");\n                    } else if (\"h\".equals(tag)) {\n                        legacyHostIndex++;\n                        Host host = new Host();\n                        // TODO: do we need to check that this package has the same signature\n                        // as before?\n                        String pkg = parser.getAttributeValue(null, \"pkg\");\n\n                        final int uid = getUidForPackage(pkg, userId);\n                        if (uid < 0) {\n                            host.zombie = true;\n                        }\n\n                        if (!host.zombie || mSafeMode) {\n                            // In safe mode, we don't discard the hosts we don't recognize\n                            // so that they're not pruned from our list. Otherwise, we do.\n                            final int hostId = parser.getAttributeIntHex(null, \"id\");\n                            final int hostTag = parser.getAttributeIntHex(null, \"tag\",\n                                    legacyHostIndex);\n\n                            host.tag = hostTag;\n                            host.id = new HostId(uid, hostId, pkg);\n                            mHosts.add(host);\n                        }\n                    } else if (\"b\".equals(tag)) {\n                        String packageName = parser.getAttributeValue(null, \"packageName\");\n                        final int uid = getUidForPackage(packageName, userId);\n                        if (uid >= 0) {\n                            Pair<Integer, String> packageId = Pair.create(userId, packageName);\n                            mPackagesWithBindWidgetPermission.add(packageId);\n                        }\n                    } else if (\"g\".equals(tag)) {\n                        Widget widget = new Widget();\n                        widget.appWidgetId = parser.getAttributeIntHex(null, \"id\");\n                        setMinAppWidgetIdLocked(userId, widget.appWidgetId + 1);\n\n                        // restored ID is allowed to be absent\n                        widget.restoredId = parser.getAttributeIntHex(null, \"rid\", 0);\n                        widget.options = parseWidgetIdOptions(parser);\n\n                        final int hostTag = parser.getAttributeIntHex(null, \"h\");\n                        String providerString = parser.getAttributeValue(null, \"p\");\n                        final int providerTag = (providerString != null)\n                                ? parser.getAttributeIntHex(null, \"p\") : TAG_UNDEFINED;\n\n                        // We can match widgets with hosts and providers only after hosts\n                        // and providers for all users have been loaded since the widget\n                        // host and provider can be in different user profiles.\n                        LoadedWidgetState loadedWidgets = new LoadedWidgetState(widget,\n                                hostTag, providerTag);\n                        outLoadedWidgets.add(loadedWidgets);\n                    }\n                }\n            } while (type != XmlPullParser.END_DOCUMENT);\n        } catch (NullPointerException\n                | NumberFormatException\n                | XmlPullParserException\n                | IOException\n                | IndexOutOfBoundsException e) {\n            Slog.w(TAG, \"failed parsing \" + e);\n            return -1;\n        }\n\n        return version;\n    }\n\n    private void performUpgradeLocked(int fromVersion) {\n        if (fromVersion < CURRENT_VERSION) {\n            Slog.v(TAG, \"Upgrading widget database from \" + fromVersion + \" to \"\n                    + CURRENT_VERSION);\n        }\n\n        int version = fromVersion;\n\n        // Update 1: keyguard moved from package \"android\" to \"com.android.keyguard\"\n        if (version == 0) {\n            HostId oldHostId = new HostId(Process.myUid(),\n                    KEYGUARD_HOST_ID, OLD_KEYGUARD_HOST_PACKAGE);\n\n            Host host = lookupHostLocked(oldHostId);\n            if (host != null) {\n                final int uid = getUidForPackage(NEW_KEYGUARD_HOST_PACKAGE,\n                        UserHandle.USER_SYSTEM);\n                if (uid >= 0) {\n                    host.id = new HostId(uid, KEYGUARD_HOST_ID, NEW_KEYGUARD_HOST_PACKAGE);\n                }\n            }\n\n            version = 1;\n        }\n\n        if (version != CURRENT_VERSION) {\n            throw new IllegalStateException(\"Failed to upgrade widget database\");\n        }\n    }\n\n    private static File getStateFile(int userId) {\n        return new File(Environment.getUserSystemDirectory(userId), STATE_FILENAME);\n    }\n\n    private static AtomicFile getSavedStateFile(int userId) {\n        File dir = Environment.getUserSystemDirectory(userId);\n        File settingsFile = getStateFile(userId);\n        if (!settingsFile.exists() && userId == UserHandle.USER_SYSTEM) {\n            if (!dir.exists()) {\n                dir.mkdirs();\n            }\n            // Migrate old data\n            File oldFile = new File(\"/data/system/\" + STATE_FILENAME);\n            // Method doesn't throw an exception on failure. Ignore any errors\n            // in moving the file (like non-existence)\n            oldFile.renameTo(settingsFile);\n        }\n        return new AtomicFile(settingsFile);\n    }\n\n    void onUserStopped(int userId) {\n        synchronized (mLock) {\n            boolean crossProfileWidgetsChanged = false;\n\n            // Remove widgets that have both host and provider in the user.\n            final int widgetCount = mWidgets.size();\n            for (int i = widgetCount - 1; i >= 0; i--) {\n                Widget widget = mWidgets.get(i);\n\n                final boolean hostInUser = widget.host.getUserId() == userId;\n                final boolean hasProvider = widget.provider != null;\n                final boolean providerInUser = hasProvider && widget.provider.getUserId() == userId;\n\n                // If both host and provider are in the user, just drop the widgets\n                // as we do not want to make host callbacks and provider broadcasts\n                // as the host and the provider will be killed.\n                if (hostInUser && (!hasProvider || providerInUser)) {\n                    removeWidgetLocked(widget);\n                    widget.host.widgets.remove(widget);\n                    widget.host = null;\n                    if (hasProvider) {\n                        widget.provider.widgets.remove(widget);\n                        widget.provider = null;\n                    }\n                }\n            }\n\n            // Remove hosts and notify providers in other profiles.\n            final int hostCount = mHosts.size();\n            for (int i = hostCount - 1; i >= 0; i--) {\n                Host host = mHosts.get(i);\n                if (host.getUserId() == userId) {\n                    crossProfileWidgetsChanged |= !host.widgets.isEmpty();\n                    deleteHostLocked(host);\n                }\n            }\n\n            // Leave the providers present as hosts will show the widgets\n            // masked while the user is stopped.\n\n            // Remove grants for this user.\n            final int grantCount = mPackagesWithBindWidgetPermission.size();\n            for (int i = grantCount - 1; i >= 0; i--) {\n                Pair<Integer, String> packageId = mPackagesWithBindWidgetPermission.valueAt(i);\n                if (packageId.first == userId) {\n                    mPackagesWithBindWidgetPermission.removeAt(i);\n                }\n            }\n\n            // Take a note we no longer have state for this user.\n            final int userIndex = mLoadedUserIds.indexOfKey(userId);\n            if (userIndex >= 0) {\n                mLoadedUserIds.removeAt(userIndex);\n            }\n\n            // Remove the widget id counter.\n            final int nextIdIndex = mNextAppWidgetIds.indexOfKey(userId);\n            if (nextIdIndex >= 0) {\n                mNextAppWidgetIds.removeAt(nextIdIndex);\n            }\n\n            // Save state if removing a profile changed the group state.\n            // Nothing will be saved if the group parent was removed.\n            if (crossProfileWidgetsChanged) {\n                saveGroupStateAsync(userId);\n            }\n        }\n    }\n\n    private void applyResourceOverlaysToWidgetsLocked(Set<String> packageNames, int userId,\n            boolean updateFrameworkRes) {\n        for (int i = 0, N = mProviders.size(); i < N; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.getUserId() != userId) {\n                continue;\n            }\n\n            final String packageName = provider.id.componentName.getPackageName();\n            if (!updateFrameworkRes && !packageNames.contains(packageName)) {\n                continue;\n            }\n\n            ApplicationInfo newAppInfo = null;\n            try {\n                newAppInfo = mPackageManager.getApplicationInfo(packageName,\n                        PackageManager.GET_SHARED_LIBRARY_FILES, userId);\n            } catch (RemoteException e) {\n                Slog.w(TAG, \"Failed to retrieve app info for \" + packageName\n                        + \" userId=\" + userId, e);\n            }\n            if (newAppInfo == null || provider.info == null\n                    || provider.info.providerInfo == null) {\n                continue;\n            }\n            ApplicationInfo oldAppInfo = provider.info.providerInfo.applicationInfo;\n            if (oldAppInfo == null || !newAppInfo.sourceDir.equals(oldAppInfo.sourceDir)) {\n                // Overlay paths are generated against a particular version of an application.\n                // The overlays paths of a newly upgraded application are incompatible with the\n                // old version of the application.\n                continue;\n            }\n\n            // Isolate the changes relating to RROs. The app info must be copied to prevent\n            // affecting other parts of system server that may have cached this app info.\n            oldAppInfo = new ApplicationInfo(oldAppInfo);\n            oldAppInfo.overlayPaths = newAppInfo.overlayPaths.clone();\n            oldAppInfo.resourceDirs = newAppInfo.resourceDirs.clone();\n            provider.info.providerInfo.applicationInfo = oldAppInfo;\n\n            for (int j = 0, M = provider.widgets.size(); j < M; j++) {\n                Widget widget = provider.widgets.get(j);\n                if (widget.views != null) {\n                    widget.views.updateAppInfo(oldAppInfo);\n                }\n                if (widget.maskedViews != null) {\n                    widget.maskedViews.updateAppInfo(oldAppInfo);\n                }\n            }\n        }\n    }\n\n    /**\n     * Updates all providers with the specified package names, and records any providers that were\n     * pruned.\n     *\n     * @return whether any providers were updated\n     */\n    private boolean updateProvidersForPackageLocked(String packageName, int userId,\n            Set<ProviderId> removedProviders) {\n        boolean providersUpdated = false;\n\n        HashSet<ProviderId> keep = new HashSet<>();\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.setPackage(packageName);\n        List<ResolveInfo> broadcastReceivers = queryIntentReceivers(intent, userId);\n\n        // add the missing ones and collect which ones to keep\n        int N = broadcastReceivers == null ? 0 : broadcastReceivers.size();\n        for (int i = 0; i < N; i++) {\n            ResolveInfo ri = broadcastReceivers.get(i);\n            ActivityInfo ai = ri.activityInfo;\n\n            if ((ai.applicationInfo.flags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {\n                continue;\n            }\n\n            if (packageName.equals(ai.packageName)) {\n                ProviderId providerId = new ProviderId(ai.applicationInfo.uid,\n                        new ComponentName(ai.packageName, ai.name));\n\n                Provider provider = lookupProviderLocked(providerId);\n                if (provider == null) {\n                    if (addProviderLocked(ri)) {\n                        keep.add(providerId);\n                        providersUpdated = true;\n                    }\n                } else {\n                    AppWidgetProviderInfo info =\n                            createPartialProviderInfo(providerId, ri, provider);\n                    if (info != null) {\n                        keep.add(providerId);\n                        // Use the new AppWidgetProviderInfo.\n                        provider.setPartialInfoLocked(info);\n                        // If it's enabled\n                        final int M = provider.widgets.size();\n                        if (M > 0) {\n                            int[] appWidgetIds = getWidgetIds(provider.widgets);\n                            // Reschedule for the new updatePeriodMillis (don't worry about handling\n                            // it specially if updatePeriodMillis didn't change because we just sent\n                            // an update, and the next one will be updatePeriodMillis from now).\n                            cancelBroadcastsLocked(provider);\n                            registerForBroadcastsLocked(provider, appWidgetIds);\n                            // If it's currently showing, call back with the new\n                            // AppWidgetProviderInfo.\n                            for (int j = 0; j < M; j++) {\n                                Widget widget = provider.widgets.get(j);\n                                widget.views = null;\n                                scheduleNotifyProviderChangedLocked(widget);\n                            }\n                            // Now that we've told the host, push out an update.\n                            sendUpdateIntentLocked(provider, appWidgetIds);\n                        }\n                    }\n                    providersUpdated = true;\n                }\n            }\n        }\n\n        // prune the ones we don't want to keep\n        N = mProviders.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Provider provider = mProviders.get(i);\n            if (packageName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId\n                    && !keep.contains(provider.id)) {\n                if (removedProviders != null) {\n                    removedProviders.add(provider.id);\n                }\n                deleteProviderLocked(provider);\n                providersUpdated = true;\n            }\n        }\n\n        return providersUpdated;\n    }\n\n    // Remove widgets for provider in userId that are hosted in parentUserId\n    private void removeWidgetsForPackageLocked(String pkgName, int userId, int parentUserId) {\n        final int N = mProviders.size();\n        for (int i = 0; i < N; ++i) {\n            Provider provider = mProviders.get(i);\n            if (pkgName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId\n                    && provider.widgets.size() > 0) {\n                deleteWidgetsLocked(provider, parentUserId);\n            }\n        }\n    }\n\n    private boolean removeProvidersForPackageLocked(String pkgName, int userId) {\n        boolean removed = false;\n\n        final int N = mProviders.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Provider provider = mProviders.get(i);\n            if (pkgName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId) {\n                deleteProviderLocked(provider);\n                removed = true;\n            }\n        }\n        return removed;\n    }\n\n    private boolean removeHostsAndProvidersForPackageLocked(String pkgName, int userId) {\n        boolean removed = removeProvidersForPackageLocked(pkgName, userId);\n\n        // Delete the hosts for this package too\n        // By now, we have removed any AppWidgets that were in any hosts here,\n        // so we don't need to worry about sending DISABLE broadcasts to them.\n        final int N = mHosts.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Host host = mHosts.get(i);\n            if (pkgName.equals(host.id.packageName)\n                    && host.getUserId() == userId) {\n                deleteHostLocked(host);\n                removed = true;\n            }\n        }\n\n        return removed;\n    }\n\n    private String getCanonicalPackageName(String packageName, String className, int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            try {\n                AppGlobals.getPackageManager().getReceiverInfo(new ComponentName(packageName,\n                        className), 0, userId);\n                return packageName;\n            } catch (RemoteException re) {\n                String[] packageNames = mContext.getPackageManager()\n                        .currentToCanonicalPackageNames(new String[]{packageName});\n                if (packageNames != null && packageNames.length > 0) {\n                    return packageNames[0];\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n        return null;\n    }\n\n    private void sendBroadcastAsUser(Intent intent, UserHandle userHandle) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            mContext.sendBroadcastAsUser(intent, userHandle);\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void bindService(Intent intent, ServiceConnection connection,\n            UserHandle userHandle) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.bindServiceAsUser(intent, connection,\n                    Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE,\n                    userHandle);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void unbindService(ServiceConnection connection) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.unbindService(connection);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public void onCrossProfileWidgetProvidersChanged(int userId, List<String> packages) {\n        final int parentId = mSecurityPolicy.getProfileParent(userId);\n        // We care only if the allowlisted package is in a profile of\n        // the group parent as only the parent can add widgets from the\n        // profile and not the other way around.\n        if (parentId != userId) {\n            synchronized (mLock) {\n                boolean providersChanged = false;\n\n                ArraySet<String> previousPackages = new ArraySet<String>();\n                final int providerCount = mProviders.size();\n                for (int i = 0; i < providerCount; ++i) {\n                    Provider provider = mProviders.get(i);\n                    if (provider.getUserId() == userId) {\n                        previousPackages.add(provider.id.componentName.getPackageName());\n                    }\n                }\n\n                final int packageCount = packages.size();\n                for (int i = 0; i < packageCount; i++) {\n                    String packageName = packages.get(i);\n                    previousPackages.remove(packageName);\n                    providersChanged |= updateProvidersForPackageLocked(packageName,\n                            userId, null);\n                }\n\n                // Remove widgets from hosts in parent user for packages not in the allowlist\n                final int removedCount = previousPackages.size();\n                for (int i = 0; i < removedCount; ++i) {\n                    removeWidgetsForPackageLocked(previousPackages.valueAt(i),\n                            userId, parentId);\n                }\n\n                if (providersChanged || removedCount > 0) {\n                    saveGroupStateAsync(userId);\n                    scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n                }\n            }\n        }\n    }\n\n    private boolean isProfileWithLockedParent(int userId) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            UserInfo userInfo = mUserManager.getUserInfo(userId);\n            if (userInfo != null && userInfo.isProfile()) {\n                UserInfo parentInfo = mUserManager.getProfileParent(userId);\n                if (parentInfo != null\n                        && !isUserRunningAndUnlocked(parentInfo.getUserHandle().getIdentifier())) {\n                    return true;\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n        return false;\n    }\n\n    private boolean isProfileWithUnlockedParent(int userId) {\n        UserInfo userInfo = mUserManager.getUserInfo(userId);\n        if (userInfo != null && userInfo.isProfile()) {\n            UserInfo parentInfo = mUserManager.getProfileParent(userId);\n            if (parentInfo != null\n                    && mUserManager.isUserUnlockingOrUnlocked(parentInfo.getUserHandle())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Note an app widget is tapped on. If a app widget is tapped, the underlying app is treated as\n     * foreground so the app can get while-in-use permission.\n     *\n     * @param callingPackage calling app's packageName.\n     * @param appWidgetId App widget id.\n     */\n    @Override\n    public void noteAppWidgetTapped(String callingPackage, int appWidgetId) {\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n        final int callingUid = Binder.getCallingUid();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            // The launcher must be at TOP.\n            final int procState = mActivityManagerInternal.getUidProcessState(callingUid);\n            if (procState > ActivityManager.PROCESS_STATE_TOP) {\n                return;\n            }\n            synchronized (mLock) {\n                final Widget widget = lookupWidgetLocked(appWidgetId, callingUid, callingPackage);\n                if (widget == null) {\n                    return;\n                }\n                final ProviderId providerId = widget.provider.id;\n                final String packageName = providerId.componentName.getPackageName();\n                if (packageName == null) {\n                    return;\n                }\n                final SparseArray<String> uid2PackageName = new SparseArray<String>();\n                uid2PackageName.put(providerId.uid, packageName);\n                mAppOpsManagerInternal.updateAppWidgetVisibility(uid2PackageName, true);\n                mUsageStatsManagerInternal.reportEvent(packageName,\n                        UserHandle.getUserId(providerId.uid), UsageEvents.Event.USER_INTERACTION);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    private final class CallbackHandler extends Handler {\n        public static final int MSG_NOTIFY_UPDATE_APP_WIDGET = 1;\n        public static final int MSG_NOTIFY_PROVIDER_CHANGED = 2;\n        public static final int MSG_NOTIFY_PROVIDERS_CHANGED = 3;\n        public static final int MSG_NOTIFY_VIEW_DATA_CHANGED = 4;\n        public static final int MSG_NOTIFY_APP_WIDGET_REMOVED = 5;\n\n        public CallbackHandler(Looper looper) {\n            super(looper, null, false);\n        }\n\n        @Override\n        public void handleMessage(Message message) {\n            switch (message.what) {\n                case MSG_NOTIFY_UPDATE_APP_WIDGET: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    RemoteViews views = (RemoteViews) args.arg3;\n                    long requestId = (Long) args.arg4;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n\n                    handleNotifyUpdateAppWidget(host, callbacks, appWidgetId, views, requestId);\n                } break;\n\n                case MSG_NOTIFY_PROVIDER_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    AppWidgetProviderInfo info = (AppWidgetProviderInfo)args.arg3;\n                    long requestId = (Long) args.arg4;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n\n                    handleNotifyProviderChanged(host, callbacks, appWidgetId, info, requestId);\n                } break;\n\n                case MSG_NOTIFY_APP_WIDGET_REMOVED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    long requestId = (Long) args.arg3;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n                    handleNotifyAppWidgetRemoved(host, callbacks, appWidgetId, requestId);\n                } break;\n\n                case MSG_NOTIFY_PROVIDERS_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    args.recycle();\n\n                    handleNotifyProvidersChanged(host, callbacks);\n                } break;\n\n                case MSG_NOTIFY_VIEW_DATA_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    long requestId = (Long) args.arg3;\n                    final int appWidgetId = args.argi1;\n                    final int viewId = args.argi2;\n                    args.recycle();\n\n                    handleNotifyAppWidgetViewDataChanged(host, callbacks, appWidgetId, viewId,\n                            requestId);\n                } break;\n            }\n        }\n    }\n\n    private final class SecurityPolicy {\n\n        public boolean isEnabledGroupProfile(int profileId) {\n            final int parentId = UserHandle.getCallingUserId();\n            return isParentOrProfile(parentId, profileId) && isProfileEnabled(profileId);\n        }\n\n        public int[] getEnabledGroupProfileIds(int userId) {\n            final int parentId = getGroupParent(userId);\n\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return mUserManager.getEnabledProfileIds(parentId);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n\n        public void enforceServiceExistsAndRequiresBindRemoteViewsPermission(\n                ComponentName componentName, int userId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                ServiceInfo serviceInfo = mPackageManager.getServiceInfo(componentName,\n                        PackageManager.GET_PERMISSIONS, userId);\n                if (serviceInfo == null) {\n                    throw new SecurityException(\"Service \" + componentName\n                            + \" not installed for user \" + userId);\n                }\n                if (!android.Manifest.permission.BIND_REMOTEVIEWS.equals(serviceInfo.permission)) {\n                    throw new SecurityException(\"Service \" + componentName\n                            + \" in user \" + userId + \"does not require \"\n                            + android.Manifest.permission.BIND_REMOTEVIEWS);\n                }\n            } catch (RemoteException re) {\n                // Local call - shouldn't happen.\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n\n        public void enforceModifyAppWidgetBindPermissions(String packageName) {\n            mContext.enforceCallingPermission(\n                    android.Manifest.permission.MODIFY_APPWIDGET_BIND_PERMISSIONS,\n                    \"hasBindAppWidgetPermission packageName=\" + packageName);\n        }\n\n        public boolean isCallerInstantAppLocked() {\n            final int callingUid =  Binder.getCallingUid();\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final String[] uidPackages = mPackageManager.getPackagesForUid(callingUid);\n                if (!ArrayUtils.isEmpty(uidPackages)) {\n                    return mPackageManager.isInstantApp(uidPackages[0],\n                            UserHandle.getUserId(callingUid));\n                }\n            } catch (RemoteException e) {\n                /* ignore - same process */\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return false;\n        }\n\n        public boolean isInstantAppLocked(String packageName, int userId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return mPackageManager.isInstantApp(packageName, userId);\n            } catch (RemoteException e) {\n                /* ignore - same process */\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return false;\n        }\n\n        public void enforceCallFromPackage(String packageName) {\n            mAppOpsManager.checkPackage(Binder.getCallingUid(), packageName);\n        }\n\n        public boolean hasCallerBindPermissionOrBindWhiteListedLocked(String packageName) {\n            try {\n                mContext.enforceCallingOrSelfPermission(\n                        android.Manifest.permission.BIND_APPWIDGET, null);\n            } catch (SecurityException se) {\n                if (!isCallerBindAppWidgetWhiteListedLocked(packageName)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private boolean isCallerBindAppWidgetWhiteListedLocked(String packageName) {\n            final int userId = UserHandle.getCallingUserId();\n            final int packageUid = getUidForPackage(packageName, userId);\n            if (packageUid < 0) {\n                throw new IllegalArgumentException(\"No package \" + packageName\n                        + \" for user \" + userId);\n            }\n            synchronized (mLock) {\n                ensureGroupStateLoadedLocked(userId);\n\n                Pair<Integer, String> packageId = Pair.create(userId, packageName);\n                if (mPackagesWithBindWidgetPermission.contains(packageId)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        public boolean canAccessAppWidget(Widget widget, int uid, String packageName) {\n            if (isHostInPackageForUid(widget.host, uid, packageName)) {\n                // Apps hosting the AppWidget have access to it.\n                return true;\n            }\n            if (isProviderInPackageForUid(widget.provider, uid, packageName)) {\n                // Apps providing the AppWidget have access to it.\n                return true;\n            }\n            if (isHostAccessingProvider(widget.host, widget.provider, uid, packageName)) {\n                // Apps hosting the AppWidget get to bind to a remote view service in the provider.\n                return true;\n            }\n            final int userId = UserHandle.getUserId(uid);\n            if ((widget.host.getUserId() == userId || (widget.provider != null\n                    && widget.provider.getUserId() == userId))\n                && mContext.checkCallingPermission(android.Manifest.permission.BIND_APPWIDGET)\n                    == PackageManager.PERMISSION_GRANTED) {\n                // Apps that run in the same user as either the host or the provider and\n                // have the bind widget permission have access to the widget.\n                return true;\n            }\n            return false;\n        }\n\n        private boolean isParentOrProfile(int parentId, int profileId) {\n            if (parentId == profileId) {\n                return true;\n            }\n            return getProfileParent(profileId) == parentId;\n        }\n\n        public boolean isProviderInCallerOrInProfileAndWhitelListed(String packageName,\n                int profileId) {\n            final int callerId = UserHandle.getCallingUserId();\n            if (profileId == callerId) {\n                return true;\n            }\n            final int parentId = getProfileParent(profileId);\n            if (parentId != callerId) {\n                return false;\n            }\n            return isProviderWhiteListed(packageName, profileId);\n        }\n\n        public boolean isProviderWhiteListed(String packageName, int profileId) {\n            // If the policy manager is not available on the device we deny it all.\n            if (mDevicePolicyManagerInternal == null) {\n                return false;\n            }\n\n            List<String> crossProfilePackages = mDevicePolicyManagerInternal\n                    .getCrossProfileWidgetProviders(profileId);\n\n            return crossProfilePackages.contains(packageName);\n        }\n\n        public int getProfileParent(int profileId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                UserInfo parent = mUserManager.getProfileParent(profileId);\n                if (parent != null) {\n                    return parent.getUserHandle().getIdentifier();\n                }\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return UNKNOWN_USER_ID;\n        }\n\n        public int getGroupParent(int profileId) {\n            final int parentId = mSecurityPolicy.getProfileParent(profileId);\n            return (parentId != UNKNOWN_USER_ID) ? parentId : profileId;\n        }\n\n        public boolean isHostInPackageForUid(Host host, int uid, String packageName) {\n            return host.id.uid == uid && host.id.packageName.equals(packageName);\n        }\n\n        public boolean isProviderInPackageForUid(Provider provider, int uid,\n                String packageName) {\n            // Packages providing the AppWidget have access to it.\n            return provider != null && provider.id.uid == uid\n                    && provider.id.componentName.getPackageName().equals(packageName);\n        }\n\n        public boolean isHostAccessingProvider(Host host, Provider provider, int uid,\n                String packageName) {\n            // The host creates a package context to bind to remote views service in the provider.\n            return host.id.uid == uid && provider != null\n                    && provider.id.componentName.getPackageName().equals(packageName);\n        }\n\n        private boolean isProfileEnabled(int profileId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                UserInfo userInfo = mUserManager.getUserInfo(profileId);\n                if (userInfo == null || !userInfo.isEnabled()) {\n                    return false;\n                }\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return true;\n        }\n    }\n\n    private static final class Provider {\n\n        ProviderId id;\n        AppWidgetProviderInfo info;\n        ArrayList<Widget> widgets = new ArrayList<>();\n        PendingIntent broadcast;\n        String infoTag;\n\n        boolean zombie; // if we're in safe mode, don't prune this just because nobody references it\n\n        boolean maskedByLockedProfile;\n        boolean maskedByQuietProfile;\n        boolean maskedBySuspendedPackage;\n\n        boolean mInfoParsed = false;\n\n        int tag = TAG_UNDEFINED; // for use while saving state (the index)\n\n        public int getUserId() {\n            return UserHandle.getUserId(id.uid);\n        }\n\n        public boolean isInPackageForUser(String packageName, int userId) {\n            return getUserId() == userId\n                    && id.componentName.getPackageName().equals(packageName);\n        }\n\n        // is there an instance of this provider hosted by the given app?\n        public boolean hostedByPackageForUser(String packageName, int userId) {\n            final int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = widgets.get(i);\n                if (packageName.equals(widget.host.id.packageName)\n                        && widget.host.getUserId() == userId) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @GuardedBy(\"mLock\")\n        public AppWidgetProviderInfo getInfoLocked(Context context) {\n            if (!mInfoParsed) {\n                // parse\n                if (!zombie) {\n                    AppWidgetProviderInfo newInfo = null;\n                    if (!TextUtils.isEmpty(infoTag)) {\n                        newInfo = parseAppWidgetProviderInfo(\n                                context, id, info.providerInfo, infoTag);\n                    }\n                    if (newInfo == null) {\n                        newInfo = parseAppWidgetProviderInfo(context, id, info.providerInfo,\n                                AppWidgetManager.META_DATA_APPWIDGET_PROVIDER);\n                    }\n                    if (newInfo != null) {\n                        info = newInfo;\n                    }\n                }\n                mInfoParsed = true;\n            }\n            return info;\n        }\n\n        /**\n         * Returns the last updated AppWidgetProviderInfo for this provider. This info may not\n         * be completely parsed and only contain placeHolder information like\n         * {@link AppWidgetProviderInfo#providerInfo}\n         */\n        @GuardedBy(\"mLock\")\n        public AppWidgetProviderInfo getPartialInfoLocked() {\n            return info;\n        }\n\n        @GuardedBy(\"mLock\")\n        public void setPartialInfoLocked(AppWidgetProviderInfo info) {\n            this.info = info;\n            mInfoParsed = false;\n        }\n\n        @GuardedBy(\"mLock\")\n        public void setInfoLocked(AppWidgetProviderInfo info) {\n            this.info = info;\n            mInfoParsed = true;\n        }\n\n        @Override\n        public String toString() {\n            return \"Provider{\" + id + (zombie ? \" Z\" : \"\") + '}';\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedByQuietProfileLocked(boolean masked) {\n            boolean oldState = maskedByQuietProfile;\n            maskedByQuietProfile = masked;\n            return masked != oldState;\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedByLockedProfileLocked(boolean masked) {\n            boolean oldState = maskedByLockedProfile;\n            maskedByLockedProfile = masked;\n            return masked != oldState;\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedBySuspendedPackageLocked(boolean masked) {\n            boolean oldState = maskedBySuspendedPackage;\n            maskedBySuspendedPackage = masked;\n            return masked != oldState;\n        }\n\n        public boolean isMaskedLocked() {\n            return maskedByQuietProfile || maskedByLockedProfile || maskedBySuspendedPackage;\n        }\n\n        public boolean shouldBePersisted() {\n            return !widgets.isEmpty() || !TextUtils.isEmpty(infoTag);\n        }\n    }\n\n    private static final class ProviderId {\n        final int uid;\n        final ComponentName componentName;\n\n        private ProviderId(int uid, ComponentName componentName) {\n            this.uid = uid;\n            this.componentName = componentName;\n        }\n\n        public UserHandle getProfile() {\n            return UserHandle.getUserHandleForUid(uid);\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            ProviderId other = (ProviderId) obj;\n            if (uid != other.uid)  {\n                return false;\n            }\n            if (componentName == null) {\n                if (other.componentName != null) {\n                    return false;\n                }\n            } else if (!componentName.equals(other.componentName)) {\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = uid;\n            result = 31 * result + ((componentName != null)\n                    ? componentName.hashCode() : 0);\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return \"ProviderId{user:\" + UserHandle.getUserId(uid) + \", app:\"\n                    + UserHandle.getAppId(uid) + \", cmp:\" + componentName + '}';\n        }\n    }\n\n    private static final class Host {\n        HostId id;\n        ArrayList<Widget> widgets = new ArrayList<>();\n        IAppWidgetHost callbacks;\n        boolean zombie; // if we're in safe mode, don't prune this just because nobody references it\n\n        int tag = TAG_UNDEFINED; // for use while saving state (the index)\n        // Sequence no for the last update successfully sent. This is updated whenever a\n        // widget update is successfully sent to the host callbacks. As all new/undelivered updates\n        // will have sequenceNo greater than this, all those updates will be sent when the host\n        // callbacks are attached again.\n        long lastWidgetUpdateSequenceNo;\n\n        public int getUserId() {\n            return UserHandle.getUserId(id.uid);\n        }\n\n        public boolean isInPackageForUser(String packageName, int userId) {\n            return getUserId() == userId && id.packageName.equals(packageName);\n        }\n\n        private boolean hostsPackageForUser(String pkg, int userId) {\n            final int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = widgets.get(i).provider;\n                if (provider != null && provider.getUserId() == userId\n                        && pkg.equals(provider.id.componentName.getPackageName())) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /**\n         * Adds all pending updates in {@param outUpdates} keys by the update time.\n         */\n        public void getPendingUpdatesForIdLocked(Context context, int appWidgetId,\n                LongSparseArray<PendingHostUpdate> outUpdates) {\n            long updateSequenceNo = lastWidgetUpdateSequenceNo;\n            int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = widgets.get(i);\n                if (widget.appWidgetId == appWidgetId) {\n                    for (int j = widget.updateSequenceNos.size() - 1; j >= 0; j--) {\n                        long requestId = widget.updateSequenceNos.valueAt(j);\n                        if (requestId <= updateSequenceNo) {\n                            continue;\n                        }\n                        int id = widget.updateSequenceNos.keyAt(j);\n                        final PendingHostUpdate update;\n                        switch (id) {\n                            case ID_PROVIDER_CHANGED:\n                                update = PendingHostUpdate.providerChanged(\n                                        appWidgetId, widget.provider.getInfoLocked(context));\n                                break;\n                            case ID_VIEWS_UPDATE:\n                                update = PendingHostUpdate.updateAppWidget(appWidgetId,\n                                        cloneIfLocalBinder(widget.getEffectiveViewsLocked()));\n                                break;\n                            default:\n                                update = PendingHostUpdate.viewDataChanged(appWidgetId, id);\n                        }\n                        outUpdates.put(requestId, update);\n                    }\n                    return;\n                }\n            }\n            outUpdates.put(lastWidgetUpdateSequenceNo,\n                    PendingHostUpdate.appWidgetRemoved(appWidgetId));\n        }\n\n        public SparseArray<String> getWidgetUids() {\n            final SparseArray<String> uids = new SparseArray<>();\n            for (int i = widgets.size() - 1; i >= 0; i--) {\n                final Widget widget = widgets.get(i);\n                final ProviderId providerId = widget.provider.id;\n                uids.put(providerId.uid, providerId.componentName.getPackageName());\n            }\n            return uids;\n        }\n\n        @Override\n        public String toString() {\n            return \"Host{\" + id + (zombie ? \" Z\" : \"\") + '}';\n        }\n    }\n\n    private static final class HostId {\n        final int uid;\n        final int hostId;\n        final String packageName;\n\n        public HostId(int uid, int hostId, String packageName) {\n            this.uid = uid;\n            this.hostId = hostId;\n            this.packageName = packageName;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            HostId other = (HostId) obj;\n            if (uid != other.uid)  {\n                return false;\n            }\n            if (hostId != other.hostId) {\n                return false;\n            }\n            if (packageName == null) {\n                if (other.packageName != null) {\n                    return false;\n                }\n            } else if (!packageName.equals(other.packageName)) {\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = uid;\n            result = 31 * result + hostId;\n            result = 31 * result + ((packageName != null)\n                    ? packageName.hashCode() : 0);\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return \"HostId{user:\" + UserHandle.getUserId(uid) + \", app:\"\n                    + UserHandle.getAppId(uid) + \", hostId:\" + hostId\n                    + \", pkg:\" + packageName + '}';\n        }\n    }\n\n    // These can be any constants that would not collide with a resource id.\n    private static final int ID_VIEWS_UPDATE = 0;\n    private static final int ID_PROVIDER_CHANGED = 1;\n\n    private static final class Widget {\n        int appWidgetId;\n        int restoredId;  // tracking & remapping any restored state\n        Provider provider;\n        RemoteViews views;\n        RemoteViews maskedViews;\n        Bundle options;\n        Host host;\n        // Map of request type to updateSequenceNo.\n        SparseLongArray updateSequenceNos = new SparseLongArray(2);\n\n        @Override\n        public String toString() {\n            return \"AppWidgetId{\" + appWidgetId + ':' + host + ':' + provider + '}';\n        }\n\n        private boolean replaceWithMaskedViewsLocked(RemoteViews views) {\n            maskedViews = views;\n            return true;\n        }\n\n        private boolean clearMaskedViewsLocked() {\n            if (maskedViews != null) {\n                maskedViews = null;\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        public RemoteViews getEffectiveViewsLocked() {\n            return maskedViews != null ? maskedViews : views;\n        }\n    }\n\n    private class LoadedWidgetState {\n        final Widget widget;\n        final int hostTag;\n        final int providerTag;\n\n        public LoadedWidgetState(Widget widget, int hostTag, int providerTag) {\n            this.widget = widget;\n            this.hostTag = hostTag;\n            this.providerTag = providerTag;\n        }\n    }\n\n    private final class SaveStateRunnable implements Runnable {\n        final int mUserId;\n\n        public SaveStateRunnable(int userId) {\n            mUserId = userId;\n        }\n\n        @Override\n        public void run() {\n            synchronized (mLock) {\n                // No need to enforce unlocked state when there is no caller. User can be in the\n                // stopping state or removed by the time the message is processed\n                ensureGroupStateLoadedLocked(mUserId, false /* enforceUserUnlockingOrUnlocked */ );\n                saveStateLocked(mUserId);\n            }\n        }\n    }\n\n    /**\n     * This class encapsulates the backup and restore logic for a user group state.\n     */\n    private final class BackupRestoreController {\n        private static final String TAG = \"BackupRestoreController\";\n\n        private static final boolean DEBUG = true;\n\n        // Version of backed-up widget state.\n        private static final int WIDGET_STATE_VERSION = 2;\n\n        // We need to make sure to wipe the pre-restore widget state only once for\n        // a given package.  Keep track of what we've done so far here; the list is\n        // cleared at the start of every system restore pass, but preserved through\n        // any install-time restore operations.\n        private final HashSet<String> mPrunedApps = new HashSet<>();\n\n        private final HashMap<Provider, ArrayList<RestoreUpdateRecord>> mUpdatesByProvider =\n                new HashMap<>();\n        private final HashMap<Host, ArrayList<RestoreUpdateRecord>> mUpdatesByHost =\n                new HashMap<>();\n\n        @GuardedBy(\"mLock\")\n        private boolean mHasSystemRestoreFinished;\n\n        public List<String> getWidgetParticipants(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Getting widget participants for user: \" + userId);\n            }\n\n            HashSet<String> packages = new HashSet<>();\n            synchronized (mLock) {\n                final int N = mWidgets.size();\n                for (int i = 0; i < N; i++) {\n                    Widget widget = mWidgets.get(i);\n\n                    // Skip cross-user widgets.\n                    if (!isProviderAndHostInUser(widget, userId)) {\n                        continue;\n                    }\n\n                    packages.add(widget.host.id.packageName);\n                    Provider provider = widget.provider;\n                    if (provider != null) {\n                        packages.add(provider.id.componentName.getPackageName());\n                    }\n                }\n            }\n            return new ArrayList<>(packages);\n        }\n\n        public byte[] getWidgetState(String backedupPackage, int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Getting widget state for user: \" + userId);\n            }\n\n            ByteArrayOutputStream stream = new ByteArrayOutputStream();\n            synchronized (mLock) {\n                // Preflight: if this app neither hosts nor provides any live widgets\n                // we have no work to do.\n                if (!packageNeedsWidgetBackupLocked(backedupPackage, userId)) {\n                    return null;\n                }\n\n                try {\n                    TypedXmlSerializer out = Xml.newFastSerializer();\n                    out.setOutput(stream, StandardCharsets.UTF_8.name());\n                    out.startDocument(null, true);\n                    out.startTag(null, \"ws\");      // widget state\n                    out.attributeInt(null, \"version\", WIDGET_STATE_VERSION);\n                    out.attribute(null, \"pkg\", backedupPackage);\n\n                    // Remember all the providers that are currently hosted or published\n                    // by this package: that is, all of the entities related to this app\n                    // which will need to be told about id remapping.\n                    int index = 0;\n                    int N = mProviders.size();\n                    for (int i = 0; i < N; i++) {\n                        Provider provider = mProviders.get(i);\n\n                        if (provider.shouldBePersisted()\n                                && (provider.isInPackageForUser(backedupPackage, userId)\n                                || provider.hostedByPackageForUser(backedupPackage, userId))) {\n                            provider.tag = index;\n                            serializeProvider(out, provider);\n                            index++;\n                        }\n                    }\n\n                    N = mHosts.size();\n                    index = 0;\n                    for (int i = 0; i < N; i++) {\n                        Host host = mHosts.get(i);\n\n                        if (!host.widgets.isEmpty()\n                                && (host.isInPackageForUser(backedupPackage, userId)\n                                || host.hostsPackageForUser(backedupPackage, userId))) {\n                            host.tag = index;\n                            serializeHost(out, host);\n                            index++;\n                        }\n                    }\n\n                    // All widget instances involving this package,\n                    // either as host or as provider\n                    N = mWidgets.size();\n                    for (int i = 0; i < N; i++) {\n                        Widget widget = mWidgets.get(i);\n\n                        Provider provider = widget.provider;\n                        if (widget.host.isInPackageForUser(backedupPackage, userId)\n                                || (provider != null\n                                &&  provider.isInPackageForUser(backedupPackage, userId))) {\n                            serializeAppWidget(out, widget, false);\n                        }\n                    }\n\n                    out.endTag(null, \"ws\");\n                    out.endDocument();\n                } catch (IOException e) {\n                    Slog.w(TAG, \"Unable to save widget state for \" + backedupPackage);\n                    return null;\n                }\n            }\n\n            return stream.toByteArray();\n        }\n\n        public void systemRestoreStarting(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"System restore starting for user: \" + userId);\n            }\n\n            synchronized (mLock) {\n                mHasSystemRestoreFinished = false;\n                // We're starting a new \"system\" restore operation, so any widget restore\n                // state that we see from here on is intended to replace the current\n                // widget configuration of any/all of the affected apps.\n                mPrunedApps.clear();\n                mUpdatesByProvider.clear();\n                mUpdatesByHost.clear();\n            }\n        }\n\n        public void restoreWidgetState(String packageName, byte[] restoredState, int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Restoring widget state for user:\" + userId\n                        + \" package: \" + packageName);\n            }\n\n            ByteArrayInputStream stream = new ByteArrayInputStream(restoredState);\n            try {\n                // Providers mentioned in the widget dataset by ordinal\n                ArrayList<Provider> restoredProviders = new ArrayList<>();\n\n                // Hosts mentioned in the widget dataset by ordinal\n                ArrayList<Host> restoredHosts = new ArrayList<>();\n\n                TypedXmlPullParser parser = Xml.newFastPullParser();\n                parser.setInput(stream, StandardCharsets.UTF_8.name());\n\n                synchronized (mLock) {\n                    int type;\n                    do {\n                        type = parser.next();\n                        if (type == XmlPullParser.START_TAG) {\n                            final String tag = parser.getName();\n                            if (\"ws\".equals(tag)) {\n                                final int versionNumber = parser.getAttributeInt(null, \"version\");\n                                if (versionNumber > WIDGET_STATE_VERSION) {\n                                    Slog.w(TAG, \"Unable to process state version \" + versionNumber);\n                                    return;\n                                }\n\n                                // TODO: fix up w.r.t. canonical vs current package names\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n                                if (!packageName.equals(pkg)) {\n                                    Slog.w(TAG, \"Package mismatch in ws\");\n                                    return;\n                                }\n                            } else if (\"p\".equals(tag)) {\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n                                String cl = parser.getAttributeValue(null, \"cl\");\n\n                                // hostedProviders index will match 'p' attribute in widget's\n                                // entry in the xml file being restored\n                                // If there's no live entry for this provider, add an inactive one\n                                // so that widget IDs referring to them can be properly allocated\n\n                                // Backup and resotre only for the parent profile.\n                                ComponentName componentName = new ComponentName(pkg, cl);\n\n                                Provider p = findProviderLocked(componentName, userId);\n                                if (p == null) {\n                                    AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n                                    info.provider = componentName;\n\n                                    p = new Provider();\n                                    p.id = new ProviderId(UNKNOWN_UID, componentName);\n                                    p.setPartialInfoLocked(info);\n                                    p.zombie = true;\n                                    mProviders.add(p);\n                                }\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   provider \" + p.id);\n                                }\n                                restoredProviders.add(p);\n                            } else if (\"h\".equals(tag)) {\n                                // The host app may not yet exist on the device.  If it's here we\n                                // just use the existing Host entry, otherwise we create a\n                                // placeholder whose uid will be fixed up at PACKAGE_ADDED time.\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n\n                                final int uid = getUidForPackage(pkg, userId);\n                                final int hostId = parser.getAttributeIntHex(null, \"id\");\n\n                                HostId id = new HostId(uid, hostId, pkg);\n                                Host h = lookupOrAddHostLocked(id);\n                                restoredHosts.add(h);\n\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   host[\" + restoredHosts.size()\n                                            + \"]: {\" + h.id + \"}\");\n                                }\n                            } else if (\"g\".equals(tag)) {\n                                int restoredId = parser.getAttributeIntHex(null, \"id\");\n                                int hostIndex = parser.getAttributeIntHex(null, \"h\");\n                                Host host = restoredHosts.get(hostIndex);\n                                Provider p = null;\n                                int which = parser.getAttributeIntHex(null, \"p\", -1);\n                                if (which != -1) {\n                                    // could have been null if the app had allocated an id\n                                    // but not yet established a binding under that id\n                                    p = restoredProviders.get(which);\n                                }\n\n                                // We'll be restoring widget state for both the host and\n                                // provider sides of this widget ID, so make sure we are\n                                // beginning from a clean slate on both fronts.\n                                pruneWidgetStateLocked(host.id.packageName, userId);\n                                if (p != null) {\n                                    pruneWidgetStateLocked(p.id.componentName.getPackageName(),\n                                            userId);\n                                }\n\n                                // Have we heard about this ancestral widget instance before?\n                                Widget id = findRestoredWidgetLocked(restoredId, host, p);\n                                if (id == null) {\n                                    id = new Widget();\n                                    id.appWidgetId = incrementAndGetAppWidgetIdLocked(userId);\n                                    id.restoredId = restoredId;\n                                    id.options = parseWidgetIdOptions(parser);\n                                    id.host = host;\n                                    id.host.widgets.add(id);\n                                    id.provider = p;\n                                    if (id.provider != null) {\n                                        id.provider.widgets.add(id);\n                                    }\n                                    if (DEBUG) {\n                                        Slog.i(TAG, \"New restored id \" + restoredId\n                                                + \" now \" + id);\n                                    }\n                                    addWidgetLocked(id);\n                                }\n                                if (id.provider != null\n                                        && id.provider.getPartialInfoLocked() != null) {\n                                    stashProviderRestoreUpdateLocked(id.provider,\n                                            restoredId, id.appWidgetId);\n                                } else {\n                                    Slog.w(TAG, \"Missing provider for restored widget \" + id);\n                                }\n                                stashHostRestoreUpdateLocked(id.host, restoredId, id.appWidgetId);\n\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   instance: \" + restoredId\n                                            + \" -> \" + id.appWidgetId\n                                            + \" :: p=\" + id.provider);\n                                }\n                            }\n                        }\n                    } while (type != XmlPullParser.END_DOCUMENT);\n\n                    // We've updated our own bookkeeping.  We'll need to notify the hosts and\n                    // providers about the changes, but we can't do that yet because the restore\n                    // target is not necessarily fully live at this moment.  Set aside the\n                    // information for now; the backup manager will call us once more at the\n                    // end of the process when all of the targets are in a known state, and we\n                    // will update at that point.\n                }\n            } catch (XmlPullParserException | IOException e) {\n                Slog.w(TAG, \"Unable to restore widget state for \" + packageName);\n            } finally {\n                saveGroupStateAsync(userId);\n            }\n        }\n\n        // Called once following the conclusion of a system restore operation.  This is when we\n        // send out updates to apps involved in widget-state restore telling them about\n        // the new widget ID space.  Apps that are not yet installed will be notifed when they are.\n        public void systemRestoreFinished(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"systemRestoreFinished for \" + userId);\n            }\n            synchronized (mLock) {\n                mHasSystemRestoreFinished = true;\n                maybeSendWidgetRestoreBroadcastsLocked(userId);\n            }\n        }\n\n        // Called when widget components (hosts or providers) are added or changed.  If system\n        // restore has completed, we use this opportunity to tell the apps to update to the new\n        // widget ID space.  If system restore is still in progress, we delay the updates until\n        // the end, to allow all participants to restore their state before updating widget IDs.\n        public void widgetComponentsChanged(int userId) {\n            synchronized (mLock) {\n                if (mHasSystemRestoreFinished) {\n                    maybeSendWidgetRestoreBroadcastsLocked(userId);\n                }\n            }\n        }\n\n        // Called following the conclusion of a restore operation and when widget components\n        // are added or changed.  This is when we send out updates to apps involved in widget-state\n        // restore telling them about the new widget ID space.\n        @GuardedBy(\"mLock\")\n        private void maybeSendWidgetRestoreBroadcastsLocked(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"maybeSendWidgetRestoreBroadcasts for \" + userId);\n            }\n\n            final UserHandle userHandle = new UserHandle(userId);\n            // Build the providers' broadcasts and send them off\n            Set<Map.Entry<Provider, ArrayList<RestoreUpdateRecord>>> providerEntries\n                    = mUpdatesByProvider.entrySet();\n            for (Map.Entry<Provider, ArrayList<RestoreUpdateRecord>> e : providerEntries) {\n                // For each provider there's a list of affected IDs\n                Provider provider = e.getKey();\n                if (provider.zombie) {\n                    // Provider not installed, we can't send them broadcasts yet.\n                    // We'll be called again when the provider is installed.\n                    continue;\n                }\n                ArrayList<RestoreUpdateRecord> updates = e.getValue();\n                final int pending = countPendingUpdates(updates);\n                if (DEBUG) {\n                    Slog.i(TAG, \"Provider \" + provider + \" pending: \" + pending);\n                }\n                if (pending > 0) {\n                    int[] oldIds = new int[pending];\n                    int[] newIds = new int[pending];\n                    final int N = updates.size();\n                    int nextPending = 0;\n                    for (int i = 0; i < N; i++) {\n                        RestoreUpdateRecord r = updates.get(i);\n                        if (!r.notified) {\n                            r.notified = true;\n                            oldIds[nextPending] = r.oldId;\n                            newIds[nextPending] = r.newId;\n                            nextPending++;\n                            if (DEBUG) {\n                                Slog.i(TAG, \"   \" + r.oldId + \" => \" + r.newId);\n                            }\n                        }\n                    }\n                    sendWidgetRestoreBroadcastLocked(\n                            AppWidgetManager.ACTION_APPWIDGET_RESTORED,\n                            provider, null, oldIds, newIds, userHandle);\n                }\n            }\n\n            // same thing per host\n            Set<Map.Entry<Host, ArrayList<RestoreUpdateRecord>>> hostEntries\n                    = mUpdatesByHost.entrySet();\n            for (Map.Entry<Host, ArrayList<RestoreUpdateRecord>> e : hostEntries) {\n                Host host = e.getKey();\n                if (host.id.uid != UNKNOWN_UID) {\n                    ArrayList<RestoreUpdateRecord> updates = e.getValue();\n                    final int pending = countPendingUpdates(updates);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Host \" + host + \" pending: \" + pending);\n                    }\n                    if (pending > 0) {\n                        int[] oldIds = new int[pending];\n                        int[] newIds = new int[pending];\n                        final int N = updates.size();\n                        int nextPending = 0;\n                        for (int i = 0; i < N; i++) {\n                            RestoreUpdateRecord r = updates.get(i);\n                            if (!r.notified) {\n                                r.notified = true;\n                                oldIds[nextPending] = r.oldId;\n                                newIds[nextPending] = r.newId;\n                                nextPending++;\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   \" + r.oldId + \" => \" + r.newId);\n                                }\n                            }\n                        }\n                        sendWidgetRestoreBroadcastLocked(\n                                AppWidgetManager.ACTION_APPWIDGET_HOST_RESTORED,\n                                null, host, oldIds, newIds, userHandle);\n                    }\n                }\n            }\n        }\n\n        private Provider findProviderLocked(ComponentName componentName, int userId) {\n            final int providerCount = mProviders.size();\n            for (int i = 0; i < providerCount; i++) {\n                Provider provider = mProviders.get(i);\n                if (provider.getUserId() == userId\n                        && provider.id.componentName.equals(componentName)) {\n                    return provider;\n                }\n            }\n            return null;\n        }\n\n        private Widget findRestoredWidgetLocked(int restoredId, Host host, Provider p) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Find restored widget: id=\" + restoredId\n                        + \" host=\" + host + \" provider=\" + p);\n            }\n\n            if (p == null || host == null) {\n                return null;\n            }\n\n            final int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n                if (widget.restoredId == restoredId\n                        && widget.host.id.equals(host.id)\n                        && widget.provider.id.equals(p.id)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"   Found at \" + i + \" : \" + widget);\n                    }\n                    return widget;\n                }\n            }\n            return null;\n        }\n\n        private boolean packageNeedsWidgetBackupLocked(String packageName, int userId) {\n            int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n\n                // Skip cross-user widgets.\n                if (!isProviderAndHostInUser(widget, userId)) {\n                    continue;\n                }\n\n                if (widget.host.isInPackageForUser(packageName, userId)) {\n                    // this package is hosting widgets, so it knows widget IDs.\n                    return true;\n                }\n\n                Provider provider = widget.provider;\n                if (provider != null && provider.isInPackageForUser(packageName, userId)) {\n                    // someone is hosting this app's widgets, so it knows widget IDs.\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private void stashProviderRestoreUpdateLocked(Provider provider, int oldId, int newId) {\n            ArrayList<RestoreUpdateRecord> r = mUpdatesByProvider.get(provider);\n            if (r == null) {\n                r = new ArrayList<>();\n                mUpdatesByProvider.put(provider, r);\n            } else {\n                // don't duplicate\n                if (alreadyStashed(r, oldId, newId)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"ID remap \" + oldId + \" -> \" + newId\n                                + \" already stashed for \" + provider);\n                    }\n                    return;\n                }\n            }\n            r.add(new RestoreUpdateRecord(oldId, newId));\n        }\n\n        private boolean alreadyStashed(ArrayList<RestoreUpdateRecord> stash,\n                final int oldId, final int newId) {\n            final int N = stash.size();\n            for (int i = 0; i < N; i++) {\n                RestoreUpdateRecord r = stash.get(i);\n                if (r.oldId == oldId && r.newId == newId) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private void stashHostRestoreUpdateLocked(Host host, int oldId, int newId) {\n            ArrayList<RestoreUpdateRecord> r = mUpdatesByHost.get(host);\n            if (r == null) {\n                r = new ArrayList<>();\n                mUpdatesByHost.put(host, r);\n            } else {\n                if (alreadyStashed(r, oldId, newId)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"ID remap \" + oldId + \" -> \" + newId\n                                + \" already stashed for \" + host);\n                    }\n                    return;\n                }\n            }\n            r.add(new RestoreUpdateRecord(oldId, newId));\n        }\n\n        private void sendWidgetRestoreBroadcastLocked(String action, Provider provider,\n                Host host, int[] oldIds, int[] newIds, UserHandle userHandle) {\n            Intent intent = new Intent(action);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OLD_IDS, oldIds);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, newIds);\n            if (provider != null) {\n                intent.setComponent(provider.id.componentName);\n                sendBroadcastAsUser(intent, userHandle);\n            }\n            if (host != null) {\n                intent.setComponent(null);\n                intent.setPackage(host.id.packageName);\n                intent.putExtra(AppWidgetManager.EXTRA_HOST_ID, host.id.hostId);\n                sendBroadcastAsUser(intent, userHandle);\n            }\n        }\n\n        // We're restoring widget state for 'pkg', so we start by wiping (a) all widget\n        // instances that are hosted by that app, and (b) all instances in other hosts\n        // for which 'pkg' is the provider.  We assume that we'll be restoring all of\n        // these hosts & providers, so will be reconstructing a correct live state.\n        private void pruneWidgetStateLocked(String pkg, int userId) {\n            if (!mPrunedApps.contains(pkg)) {\n                if (DEBUG) {\n                    Slog.i(TAG, \"pruning widget state for restoring package \" + pkg);\n                }\n                for (int i = mWidgets.size() - 1; i >= 0; i--) {\n                    Widget widget = mWidgets.get(i);\n\n                    Host host = widget.host;\n                    Provider provider = widget.provider;\n\n                    if (host.hostsPackageForUser(pkg, userId)\n                            || (provider != null && provider.isInPackageForUser(pkg, userId))) {\n                        // 'pkg' is either the host or the provider for this instances,\n                        // so we tear it down in anticipation of it (possibly) being\n                        // reconstructed due to the restore\n                        host.widgets.remove(widget);\n                        provider.widgets.remove(widget);\n                        // Check if we need to destroy any services (if no other app widgets are\n                        // referencing the same service)\n                        decrementAppWidgetServiceRefCount(widget);\n                        removeWidgetLocked(widget);\n                    }\n                }\n                mPrunedApps.add(pkg);\n            } else {\n                if (DEBUG) {\n                    Slog.i(TAG, \"already pruned \" + pkg + \", continuing normally\");\n                }\n            }\n        }\n\n        private boolean isProviderAndHostInUser(Widget widget, int userId) {\n            // Backup only widgets hosted or provided by the owner profile.\n            return widget.host.getUserId() == userId && (widget.provider == null\n                    || widget.provider.getUserId() == userId);\n        }\n\n        private int countPendingUpdates(ArrayList<RestoreUpdateRecord> updates) {\n            int pending = 0;\n            final int N = updates.size();\n            for (int i = 0; i < N; i++) {\n                RestoreUpdateRecord r = updates.get(i);\n                if (!r.notified) {\n                    pending++;\n                }\n            }\n            return pending;\n        }\n\n        // Accumulate a list of updates that affect the given provider for a final\n        // coalesced notification broadcast once restore is over.\n        private class RestoreUpdateRecord {\n            public int oldId;\n            public int newId;\n            public boolean notified;\n\n            public RestoreUpdateRecord(int theOldId, int theNewId) {\n                oldId = theOldId;\n                newId = theNewId;\n                notified = false;\n            }\n        }\n    }\n\n    private class AppWidgetManagerLocal extends AppWidgetManagerInternal {\n        @Override\n        public ArraySet<String> getHostedWidgetPackages(int uid) {\n            synchronized (mLock) {\n                ArraySet<String> widgetPackages = null;\n                final int widgetCount = mWidgets.size();\n                for (int i = 0; i < widgetCount; i++) {\n                    final Widget widget = mWidgets.get(i);\n                    if  (widget.host.id.uid == uid && widget.provider != null) {\n                        if (widgetPackages == null) {\n                            widgetPackages = new ArraySet<>();\n                        }\n                        widgetPackages.add(widget.provider.id.componentName.getPackageName());\n                    }\n                }\n                return widgetPackages;\n            }\n        }\n\n        @Override\n        public void unlockUser(int userId) {\n            handleUserUnlocked(userId);\n        }\n\n        @Override\n        public void applyResourceOverlaysToWidgets(Set<String> packageNames, int userId,\n                boolean updateFrameworkRes) {\n            synchronized (mLock) {\n                applyResourceOverlaysToWidgetsLocked(new HashSet<>(packageNames), userId,\n                        updateFrameworkRes);\n            }\n        }\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 38238,
                                        "general": {
                                            "word_based": 16459,
                                            "char_based": 50947
                                        },
                                        "gemini": 45851
                                    }
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-340480881",
            "aliases": [
                "A-340480881",
                "CVE-2024-43095"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-340480881",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "46abb4e1fd365a88efdfe3f2b1f87da4d255b41b"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 46abb4e1fd365a88efdfe3f2b1f87da4d255b41b Mon Sep 17 00:00:00 2001\nFrom: Yi-an Chen <theianchen@google.com>\nDate: Wed, 17 Jul 2024 00:43:30 +0000\nSubject: [PATCH] Fix Dynamic Permission group auto grant behaivor\n\nFix the Dynamic Permission group auto grant behaivor so that a\npermission group is only considered granted when (1) all permissions\nwere auto-granted or (2) a platform permission in the same group is\ngranted.\n\nBug: 340480881\nTest: DynamicPermissionsTest\nChange-Id: Ie7de1b9826df72c708df02a4b73707c8fcffac86\n---\n .../permission/data/LightPermInfoLiveData.kt  |  2 +-\n .../permission/data/PermGroupLiveData.kt      | 45 ++++++++++---------\n .../model/livedatatypes/LightAppPermGroup.kt  | 30 +++++++++----\n .../model/livedatatypes/LightPackageInfo.kt   |  4 +-\n .../model/livedatatypes/LightPermInfo.kt      | 10 +++--\n .../model/livedatatypes/LightPermission.kt    | 19 +++++---\n .../service/AutoRevokePermissions.kt          |  2 +-\n .../RuntimePermissionsUpgradeController.kt    |  6 +--\n .../handheld/ReviewPermissionsFragment.java   |  4 +-\n .../ui/model/AppPermissionViewModel.kt        | 24 +++++-----\n .../ui/model/GrantPermissionsViewModel.kt     | 28 +++++++-----\n .../ui/model/ReviewPermissionsViewModel.kt    |  2 +-\n .../BackgroundGrantBehavior.kt                |  9 ++--\n .../model/grantPermissions/GrantBehavior.kt   |  2 +-\n .../grantPermissions/HealthGrantBehavior.kt   |  2 +-\n .../grantPermissions/LocationGrantBehavior.kt |  7 ++-\n .../grantPermissions/StorageGrantBehavior.kt  | 10 ++---\n .../permission/utils/KotlinUtils.kt           | 30 ++++++-------\n .../permission/utils/SafetyNetLogger.java     |  2 +-\n .../model/ReviewPermissionsViewModelTest.kt   |  2 +-\n .../permission/utils/GrantRevokeTests.kt      |  6 ++-\n 21 files changed, 138 insertions(+), 108 deletions(-)\n\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt b/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\nindex 091c45b928..68aa55e14b 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\n@@ -67,7 +67,7 @@ private constructor(private val app: Application, private val permissionName: St\n \n         val newValue =\n             try {\n-                LightPermInfo(app.packageManager.getPermissionInfo(permissionName, 0))\n+                LightPermInfo(app.packageManager.getPermissionInfo(permissionName, 0), null)\n             } catch (e: PackageManager.NameNotFoundException) {\n                 Log.w(LOG_TAG, \"Permission \\\"$permissionName\\\" not found\")\n                 invalidateSingle(permissionName)\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt b/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\nindex d44fea233a..e923746d73 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\n@@ -17,6 +17,7 @@\n package com.android.permissioncontroller.permission.data\n \n import android.app.Application\n+import android.content.pm.ApplicationInfo\n import android.content.pm.PackageItemInfo\n import android.content.pm.PackageManager\n import android.content.pm.PermissionGroupInfo\n@@ -64,7 +65,6 @@ private constructor(private val app: Application, private val groupName: String)\n      */\n     override fun onUpdate() {\n         val permissionInfos = mutableMapOf<String, LightPermInfo>()\n-\n         groupInfo =\n             Utils.getGroupInfo(groupName, context)\n                 ?: run {\n@@ -73,28 +73,25 @@ private constructor(private val app: Application, private val groupName: String)\n                     value = null\n                     return\n                 }\n-\n+        val permInfos = mutableListOf<PermissionInfo>()\n         when (groupInfo) {\n             is PermissionGroupInfo -> {\n-                val permInfos =\n-                    try {\n+                try {\n+                    permInfos.addAll(\n                         Utils.getInstalledRuntimePermissionInfosForGroup(\n                             context.packageManager,\n                             groupName\n                         )\n-                    } catch (e: PackageManager.NameNotFoundException) {\n-                        Log.e(LOG_TAG, \"Invalid permission group $groupName\")\n-                        invalidateSingle(groupName)\n-                        value = null\n-                        return\n-                    }\n-\n-                for (permInfo in permInfos) {\n-                    permissionInfos[permInfo.name] = LightPermInfo(permInfo)\n+                    )\n+                } catch (e: PackageManager.NameNotFoundException) {\n+                    Log.e(LOG_TAG, \"Invalid permission group $groupName\")\n+                    invalidateSingle(groupName)\n+                    value = null\n+                    return\n                 }\n             }\n             is PermissionInfo -> {\n-                permissionInfos[groupInfo.name] = LightPermInfo(groupInfo as PermissionInfo)\n+                permInfos.add(groupInfo as PermissionInfo)\n             }\n             else -> {\n                 value = null\n@@ -102,19 +99,25 @@ private constructor(private val app: Application, private val groupName: String)\n             }\n         }\n \n-        val permGroup = PermGroup(LightPermGroupInfo(groupInfo), permissionInfos)\n-\n-        value = permGroup\n-\n-        val packageNames =\n-            permissionInfos.values.map { permInfo -> permInfo.packageName }.toMutableSet()\n+        val packageNames = permInfos.map { permInfo -> permInfo.packageName }.toMutableSet()\n         packageNames.add(groupInfo.packageName)\n-\n         // TODO ntmyren: What if the package isn't installed for the system user?\n         val getLiveData = { packageName: String ->\n             LightPackageInfoLiveData[packageName, UserHandle.SYSTEM]\n         }\n         setSourcesToDifference(packageNames, packageLiveDatas, getLiveData)\n+        if (!packageLiveDatas.all { it.value.isInitialized }) {\n+            return\n+        }\n+        for (permInfo in permInfos) {\n+            val lightPackageInfo = packageLiveDatas[permInfo.packageName]?.value\n+            val isSystem =\n+                lightPackageInfo?.let { it.appFlags and ApplicationInfo.FLAG_SYSTEM != 0 }\n+            permissionInfos[permInfo.name] = LightPermInfo(permInfo, isSystem)\n+        }\n+\n+        val permGroup = PermGroup(LightPermGroupInfo(groupInfo), permissionInfos)\n+        value = permGroup\n     }\n \n     override fun onInactive() {\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\nindex a5736ca83a..61a604de85 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\n@@ -20,6 +20,7 @@ import android.Manifest\n import android.Manifest.permission.ACCESS_COARSE_LOCATION\n import android.os.Build\n import android.os.UserHandle\n+import com.android.permissioncontroller.permission.utils.Utils\n \n /**\n  * A lightweight version of the AppPermissionGroup data structure. Represents information about a\n@@ -75,10 +76,13 @@ data class LightAppPermGroup(\n         get() =\n             permissions.mapNotNull { (name, _) -> if (name !in backgroundPermNames) name else null }\n \n+    val isPlatformPermissionGroup = permGroupInfo.packageName == Utils.OS_PKG\n+\n     val foreground =\n         AppPermSubGroup(\n             permissions.filter { it.key in foregroundPermNames },\n             packageInfo,\n+            isPlatformPermissionGroup,\n             specialLocationGrant\n         )\n \n@@ -86,6 +90,7 @@ data class LightAppPermGroup(\n         AppPermSubGroup(\n             permissions.filter { it.key in backgroundPermNames },\n             packageInfo,\n+            isPlatformPermissionGroup,\n             specialLocationGrant\n         )\n \n@@ -123,7 +128,7 @@ data class LightAppPermGroup(\n     val isOneTime =\n         (permGroupName != Manifest.permission_group.LOCATION &&\n             permissions.any { it.value.isOneTime } &&\n-            permissions.none { !it.value.isOneTime && it.value.isGrantedIncludingAppOp }) ||\n+            permissions.none { !it.value.isOneTime && it.value.isGranted }) ||\n             (permGroupName == Manifest.permission_group.LOCATION &&\n                 permissions[ACCESS_COARSE_LOCATION]?.isOneTime == true)\n \n@@ -160,16 +165,24 @@ data class LightAppPermGroup(\n      *\n      * @param permissions The permissions contained within this subgroup, a subset of those\n      *   contained in the full group\n+     * @param isPlatformPermissionGroup Whether this is a platform permission group\n      * @param specialLocationGrant Whether this is a special location package\n      */\n     data class AppPermSubGroup\n     internal constructor(\n         private val permissions: Map<String, LightPermission>,\n         private val packageInfo: LightPackageInfo,\n+        private val isPlatformPermissionGroup: Boolean,\n         private val specialLocationGrant: Boolean?\n     ) {\n         /** Whether any of this App Permission SubGroup's permissions are granted */\n-        val isGranted = specialLocationGrant ?: permissions.any { it.value.isGrantedIncludingAppOp }\n+        val isGranted =\n+            specialLocationGrant\n+                ?: permissions.any {\n+                    val mayGrantByPlatformOrSystem =\n+                        !isPlatformPermissionGroup || it.value.isPlatformOrSystem\n+                    it.value.isGranted && mayGrantByPlatformOrSystem\n+                }\n \n         /**\n          * Whether this App Permission SubGroup should be treated as granted. This means either:\n@@ -178,14 +191,13 @@ data class LightAppPermGroup(\n          * 2) All permissions were auto-granted (all permissions are all granted and all\n          *    RevokeWhenRequested.)\n          */\n-        val isGrantedExcludingRWROrAllRWR =\n+        val allowFullGroupGrant =\n             specialLocationGrant\n                 ?: (permissions.any {\n-                    it.value.isGrantedIncludingAppOp && !it.value.isRevokeWhenRequested\n-                } ||\n-                    permissions.all {\n-                        it.value.isGrantedIncludingAppOp && it.value.isRevokeWhenRequested\n-                    })\n+                    val mayGrantByPlatformOrSystem =\n+                        !isPlatformPermissionGroup || it.value.isPlatformOrSystem\n+                    it.value.allowFullGroupGrant && mayGrantByPlatformOrSystem\n+                } || permissions.all { it.value.isGranted && it.value.isRevokeWhenRequested })\n \n         /** Whether any of this App Permission SubGroup's permissions are granted by default */\n         val isGrantedByDefault = permissions.any { it.value.isGrantedByDefault }\n@@ -196,7 +208,7 @@ data class LightAppPermGroup(\n          */\n         val isOneTime =\n             permissions.any { it.value.isOneTime } &&\n-                permissions.none { it.value.isGrantedIncludingAppOp && !it.value.isOneTime }\n+                permissions.none { it.value.isGranted && !it.value.isOneTime }\n \n         /**\n          * Whether any of this App Permission Subgroup's foreground permissions are fixed by policy\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\nindex ab8afae08f..32bc3c5268 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\n@@ -61,7 +61,9 @@ data class LightPackageInfo(\n         pI: PackageInfo\n     ) : this(\n         pI.packageName,\n-        pI.permissions?.map { perm -> LightPermInfo(perm) } ?: emptyList(),\n+        pI.permissions?.map { perm ->\n+            LightPermInfo(perm, pI.applicationInfo!!.flags and ApplicationInfo.FLAG_SYSTEM != 0)\n+        } ?: emptyList(),\n         pI.requestedPermissions?.toList() ?: emptyList(),\n         pI.requestedPermissionsFlags?.toList() ?: emptyList(),\n         pI.applicationInfo!!.uid,\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\nindex c1d2710986..a25dcc24ba 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\n@@ -30,6 +30,7 @@ import android.content.pm.PermissionInfo\n  * @param protection The protection level of this permission\n  * @param protection Extra information about the protection of this permission\n  * @param flags The system flags of this permission\n+ * @param isSystem Whether this permission is defined by a system app\n  */\n data class LightPermInfo(\n     val name: String,\n@@ -38,10 +39,12 @@ data class LightPermInfo(\n     val backgroundPermission: String?,\n     val protection: Int,\n     val protectionFlags: Int,\n-    val flags: Int\n+    val flags: Int,\n+    val isSystem: Boolean?,\n ) {\n     constructor(\n-        permInfo: PermissionInfo\n+        permInfo: PermissionInfo,\n+        isSystem: Boolean?\n     ) : this(\n         permInfo.name,\n         permInfo.packageName,\n@@ -49,7 +52,8 @@ data class LightPermInfo(\n         permInfo.backgroundPermission,\n         permInfo.protection,\n         permInfo.protectionFlags,\n-        permInfo.flags\n+        permInfo.flags,\n+        isSystem\n     )\n \n     /**\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\nindex 7492ea6e02..66a0765512 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\n@@ -28,8 +28,8 @@ import com.android.permissioncontroller.permission.utils.Utils\n  *\n  * @param pkgInfo The package requesting the permission\n  * @param permInfo The permissionInfo this represents\n- * @param isGrantedIncludingAppOp Whether or not this permission is functionally granted. A\n- *   non-granted app op but granted permission is counted as not granted\n+ * @param isGranted Whether or not this permission is functionally granted. A non-granted app op but\n+ *   granted permission is counted as not granted\n  * @param flags The PermissionController flags for this permission\n  * @param foregroundPerms The foreground permission names corresponding to this permission, if this\n  *   permission is a background permission\n@@ -37,7 +37,7 @@ import com.android.permissioncontroller.permission.utils.Utils\n data class LightPermission(\n     val pkgInfo: LightPackageInfo,\n     val permInfo: LightPermInfo,\n-    val isGrantedIncludingAppOp: Boolean,\n+    val isGranted: Boolean,\n     val flags: Int,\n     val foregroundPerms: List<String>?\n ) {\n@@ -98,9 +98,9 @@ data class LightPermission(\n     /** Whether this permission is user sensitive in its current grant state */\n     val isUserSensitive =\n         !isRuntimePlatformPermission(permInfo.name) ||\n-            (isGrantedIncludingAppOp &&\n+            (isGranted &&\n                 (flags and PackageManager.FLAG_PERMISSION_USER_SENSITIVE_WHEN_GRANTED) != 0) ||\n-            (!isGrantedIncludingAppOp &&\n+            (!isGranted &&\n                 (flags and PackageManager.FLAG_PERMISSION_USER_SENSITIVE_WHEN_DENIED) != 0)\n     /** Whether the permission is restricted */\n     val isRestricted =\n@@ -122,10 +122,17 @@ data class LightPermission(\n      */\n     val isSelectedLocationAccuracy =\n         flags and PackageManager.FLAG_PERMISSION_SELECTED_LOCATION_ACCURACY != 0\n+    /** Whether this permission is defined by platform or a system app */\n+    val isPlatformOrSystem = permInfo.packageName == Utils.OS_PKG || permInfo.isSystem == true\n+    /**\n+     * Whether this permission is granted including app op and does not hold the\n+     * PackageManager.FLAG_PERMISSION_REVOKE_WHEN_REQUESTED flag.\n+     */\n+    val allowFullGroupGrant = isGranted && !isRevokeWhenRequested\n \n     override fun toString() = buildString {\n         append(name)\n-        if (isGrantedIncludingAppOp) append(\", Granted\") else append(\", NotGranted\")\n+        if (isGranted) append(\", Granted\") else append(\", NotGranted\")\n         if (isPolicyFixed) append(\", PolicyFixed\")\n         if (isSystemFixed) append(\", SystemFixed\")\n         if (isUserFixed) append(\", UserFixed\")\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt b/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\nindex cfe753019a..aae2aa2120 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\n@@ -132,7 +132,7 @@ suspend fun revokeAppPermissions(\n                 val fixed = group.isBackgroundFixed || group.isForegroundFixed\n                 val granted =\n                     group.permissions.any { (_, perm) ->\n-                        perm.isGrantedIncludingAppOp && perm.name !in AUTO_REVOKE_EXEMPT_PERMISSIONS\n+                        perm.isGranted && perm.name !in AUTO_REVOKE_EXEMPT_PERMISSIONS\n                     }\n                 if (\n                     !fixed &&\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt b/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\nindex af3b607023..2734116dd0 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\n@@ -492,7 +492,7 @@ object RuntimePermissionsUpgradeController {\n                     LightPermission(\n                         perm.pkgInfo,\n                         perm.permInfo,\n-                        perm.isGrantedIncludingAppOp,\n+                        perm.isGranted,\n                         perm.flags or FLAG_PERMISSION_RESTRICTION_UPGRADE_EXEMPT,\n                         perm.foregroundPerms\n                     )\n@@ -569,7 +569,7 @@ object RuntimePermissionsUpgradeController {\n                         !perm.isUserSet &&\n                             !perm.isSystemFixed &&\n                             !perm.isPolicyFixed &&\n-                            !perm.isGrantedIncludingAppOp\n+                            !perm.isGranted\n                     ) {\n                         grants.add(\n                             Grant(false, appPermGroup, listOf(permission.ACCESS_MEDIA_LOCATION))\n@@ -670,7 +670,7 @@ object RuntimePermissionsUpgradeController {\n                         LightPermission(\n                             perm.pkgInfo,\n                             perm.permInfo,\n-                            perm.isGrantedIncludingAppOp,\n+                            perm.isGranted,\n                             perm.flags or FLAG_PERMISSION_RESTRICTION_UPGRADE_EXEMPT,\n                             perm.foregroundPerms\n                         )\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java b/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\nindex 5a7c3f2b54..14f3497772 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n@@ -267,11 +267,11 @@ public final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.i(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }\n \ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\nindex 5b6d8b8db7..1f0a41c59f 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\n@@ -325,6 +325,7 @@ class AppPermissionViewModel(\n \n         private val mainLocListener = { isEnabled: Boolean -> checkAndUpdateStatus(!isEnabled) }\n         private val locBypassListener = { _: Boolean -> checkAndUpdateStatus() }\n+\n         override fun onUpdate() {\n             checkAndUpdateStatus()\n         }\n@@ -692,8 +693,7 @@ class AppPermissionViewModel(\n                 app,\n                 packageName,\n                 permGroupName\n-            )\n-                ?: return\n+            ) ?: return\n         fragment.startActivity(restrictionIntent)\n     }\n \n@@ -726,10 +726,8 @@ class AppPermissionViewModel(\n             // 2. Else if FINE or COARSE have the isSelectedLocationAccuracy flag set, then return\n             //    true if FINE isSelectedLocationAccuracy is set.\n             // 3. Else, return default precision from device config.\n-            return if (\n-                fineLocation.isGrantedIncludingAppOp || coarseLocation.isGrantedIncludingAppOp\n-            ) {\n-                fineLocation.isGrantedIncludingAppOp\n+            return if (fineLocation.isGranted || coarseLocation.isGranted) {\n+                fineLocation.isGranted\n             } else if (\n                 fineLocation.isSelectedLocationAccuracy || coarseLocation.isSelectedLocationAccuracy\n             ) {\n@@ -1381,9 +1379,7 @@ class AppPermissionViewModel(\n     }\n \n     private fun getIndividualPermissionDetailResId(group: LightAppPermGroup): Pair<Int, Int> {\n-        return when (\n-            val numRevoked = group.permissions.filter { !it.value.isGrantedIncludingAppOp }.size\n-        ) {\n+        return when (val numRevoked = group.permissions.filter { !it.value.isGranted }.size) {\n             0 -> R.string.permission_revoked_none to numRevoked\n             group.permissions.size -> R.string.permission_revoked_all to numRevoked\n             else -> R.string.permission_revoked_count to numRevoked\n@@ -1454,7 +1450,7 @@ class AppPermissionViewModel(\n             val newPermission = newGroup.permissions[permName] ?: continue\n \n             if (\n-                permission.isGrantedIncludingAppOp != newPermission.isGrantedIncludingAppOp ||\n+                permission.isGranted != newPermission.isGranted ||\n                     permission.flags != newPermission.flags\n             ) {\n                 logAppPermissionFragmentActionReported(changeId, newPermission, buttonPressed)\n@@ -1462,7 +1458,7 @@ class AppPermissionViewModel(\n                     app.applicationContext,\n                     packageName,\n                     permGroupName,\n-                    newPermission.isGrantedIncludingAppOp\n+                    newPermission.isGranted\n                 )\n                 PermissionChangeStorageImpl.recordPermissionChange(packageName)\n             }\n@@ -1492,7 +1488,7 @@ class AppPermissionViewModel(\n             uid,\n             packageName,\n             permission.permInfo.name,\n-            permission.isGrantedIncludingAppOp,\n+            permission.isGranted,\n             permission.flags,\n             buttonPressed\n         )\n@@ -1502,7 +1498,7 @@ class AppPermissionViewModel(\n                 \"$changeId uid=$uid packageName=$packageName permission=\" +\n                 permission.permInfo.name +\n                 \" isGranted=\" +\n-                permission.isGrantedIncludingAppOp +\n+                permission.isGranted +\n                 \" permissionFlags=\" +\n                 permission.flags +\n                 \" buttonPressed=$buttonPressed\"\n@@ -1544,7 +1540,7 @@ class AppPermissionViewModel(\n \n         return group.isGranted &&\n             group.permissions.values.all {\n-                it.name in partialPerms || (it.name !in partialPerms && !it.isGrantedIncludingAppOp)\n+                it.name in partialPerms || (it.name !in partialPerms && !it.isGranted)\n             }\n     }\n }\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\nindex b5df6f4102..0a01929e6c 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\n@@ -338,7 +338,7 @@ class GrantPermissionsViewModel(\n                     if (state != null) {\n                         val allAffectedGranted =\n                             state.affectedPermissions.all { perm ->\n-                                appPermGroup.permissions[perm]?.isGrantedIncludingAppOp == true &&\n+                                appPermGroup.permissions[perm]?.isGranted == true &&\n                                     appPermGroup.permissions[perm]?.isRevokeWhenRequested == false\n                             }\n                         if (allAffectedGranted) {\n@@ -592,7 +592,7 @@ class GrantPermissionsViewModel(\n \n         val behavior = getGrantBehavior(group)\n         return if (behavior.isGroupFullyGranted(group, groupRequestedPermissions)) {\n-            if (group.permissions[perm]?.isGrantedIncludingAppOp == false) {\n+            if (group.permissions[perm]?.isGranted == false) {\n                 if (isBackground) {\n                     grantBackgroundRuntimePermissions(app, group, listOf(perm))\n                 } else {\n@@ -864,18 +864,15 @@ class GrantPermissionsViewModel(\n                 } else {\n                     PERMISSION_GRANT_REQUEST_RESULT_REPORTED__RESULT__USER_GRANTED\n                 }\n+            var affectedPermissions: Collection<String> = groupState.affectedPermissions\n             if (shouldAffectBackgroundPermissions) {\n-                grantBackgroundRuntimePermissions(\n-                    app,\n-                    groupState.group,\n-                    groupState.affectedPermissions\n-                )\n+                grantBackgroundRuntimePermissions(app, groupState.group, affectedPermissions)\n             } else if (shouldAffectForegroundPermssions) {\n                 if (affectedForegroundPermissions == null) {\n                     grantForegroundRuntimePermissions(\n                         app,\n                         groupState.group,\n-                        groupState.affectedPermissions,\n+                        affectedPermissions,\n                         isOneTime\n                     )\n                     // This prevents weird flag state when app targetSDK switches from S+ to R-\n@@ -883,11 +880,12 @@ class GrantPermissionsViewModel(\n                         KotlinUtils.setFlagsWhenLocationAccuracyChanged(app, groupState.group, true)\n                     }\n                 } else {\n+                    affectedPermissions = affectedForegroundPermissions\n                     val newGroup =\n                         grantForegroundRuntimePermissions(\n                             app,\n                             groupState.group,\n-                            affectedForegroundPermissions,\n+                            affectedPermissions,\n                             isOneTime\n                         )\n                     if (!isOneTime || newGroup.isOneTime) {\n@@ -899,7 +897,17 @@ class GrantPermissionsViewModel(\n                     }\n                 }\n             }\n-            groupState.state = STATE_GRANTED\n+            val shouldDenyFullGroupGrant =\n+                groupState.group.isPlatformPermissionGroup &&\n+                    affectedPermissions.none {\n+                        groupState.group.permissions[it]?.isPlatformOrSystem == true\n+                    }\n+            groupState.state =\n+                if (shouldDenyFullGroupGrant) {\n+                    STATE_UNKNOWN\n+                } else {\n+                    STATE_GRANTED\n+                }\n         } else {\n             if (shouldAffectBackgroundPermissions) {\n                 revokeBackgroundRuntimePermissions(\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/ReviewPermissionsViewModel.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/ReviewPermissionsViewModel.kt\nindex 8613d1cae6..ecb551ffc8 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/ReviewPermissionsViewModel.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/ReviewPermissionsViewModel.kt\n@@ -133,7 +133,7 @@ class ReviewPermissionsViewModel(val app: Application, val packageInfo: PackageI\n         val lightPerms = permGroup.allPermissions.values.toList()\n         val permissionCount = lightPerms.size\n         for (i in 0 until permissionCount) {\n-            if (!lightPerms[i].isGrantedIncludingAppOp) {\n+            if (!lightPerms[i].isGranted) {\n                 revokedCount++\n             }\n         }\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/BackgroundGrantBehavior.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/BackgroundGrantBehavior.kt\nindex 6234b27557..7112d180f3 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/BackgroundGrantBehavior.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/BackgroundGrantBehavior.kt\n@@ -57,7 +57,7 @@ object BackgroundGrantBehavior : GrantBehavior() {\n         val requestsBg = hasBgPerms(group, requestedPerms)\n         val requestsFg = requestedPerms.any { it !in group.backgroundPermNames }\n         val isOneTimeGroup = PermissionMapping.supportsOneTimeGrant(group.permGroupName)\n-        val isFgGranted = group.foreground.isGrantedExcludingRWROrAllRWR\n+        val isFgGranted = group.foreground.allowFullGroupGrant\n         val isFgOneTime = group.foreground.isOneTime\n         val splitSdk = getSdkGroupWasSplitToBg(requestedPerms)\n         val isAppIsOlderThanSplitToBg = group.packageInfo.targetSdkVersion < splitSdk\n@@ -171,16 +171,15 @@ object BackgroundGrantBehavior : GrantBehavior() {\n         group: LightAppPermGroup,\n         requestedPerms: Set<String>\n     ): Boolean {\n-        return (!hasBgPerms(group, requestedPerms) ||\n-            group.background.isGrantedExcludingRWROrAllRWR) &&\n-            group.foreground.isGrantedExcludingRWROrAllRWR\n+        return (!hasBgPerms(group, requestedPerms) || group.background.allowFullGroupGrant) &&\n+            group.foreground.allowFullGroupGrant\n     }\n \n     override fun isForegroundFullyGranted(\n         group: LightAppPermGroup,\n         requestedPerms: Set<String>\n     ): Boolean {\n-        return group.foreground.isGrantedExcludingRWROrAllRWR\n+        return group.foreground.allowFullGroupGrant\n     }\n \n     override fun isPermissionFixed(group: LightAppPermGroup, perm: String): Boolean {\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/GrantBehavior.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/GrantBehavior.kt\nindex 3b3619084d..54d6dc0f36 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/GrantBehavior.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/GrantBehavior.kt\n@@ -58,7 +58,7 @@ abstract class GrantBehavior {\n      * group not already granted will be granted.\n      */\n     open fun isGroupFullyGranted(group: LightAppPermGroup, requestedPerms: Set<String>): Boolean {\n-        return group.foreground.isGrantedExcludingRWROrAllRWR\n+        return group.foreground.allowFullGroupGrant\n     }\n \n     /**\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/HealthGrantBehavior.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/HealthGrantBehavior.kt\nindex 8e540701a6..4f5def312b 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/HealthGrantBehavior.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/HealthGrantBehavior.kt\n@@ -47,7 +47,7 @@ object HealthGrantBehavior : GrantBehavior() {\n         group: LightAppPermGroup,\n         requestedPerms: Set<String>\n     ): Boolean {\n-        return requestedPerms.all { group.permissions[it]?.isGrantedIncludingAppOp != false }\n+        return requestedPerms.all { group.permissions[it]?.isGranted != false }\n     }\n \n     override fun isPermissionFixed(group: LightAppPermGroup, perm: String): Boolean {\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/LocationGrantBehavior.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/LocationGrantBehavior.kt\nindex 2c5e2b7324..31ac04cab8 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/LocationGrantBehavior.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/LocationGrantBehavior.kt\n@@ -37,8 +37,7 @@ object LocationGrantBehavior : GrantBehavior() {\n     ): Prompt {\n         val backgroundPrompt = BackgroundGrantBehavior.getPrompt(group, requestedPerms)\n         val requestsBackground = requestedPerms.any { it in group.backgroundPermNames }\n-        val coarseGranted =\n-            group.permissions[ACCESS_COARSE_LOCATION]?.isGrantedIncludingAppOp == true\n+        val coarseGranted = group.permissions[ACCESS_COARSE_LOCATION]?.isGranted == true\n         return if (!supportsLocationAccuracy(group) || requestsBackground) {\n             backgroundPrompt\n         } else if (requestedPerms.contains(ACCESS_FINE_LOCATION)) {\n@@ -84,10 +83,10 @@ object LocationGrantBehavior : GrantBehavior() {\n         }\n \n         if (requestedPerms.contains(ACCESS_FINE_LOCATION)) {\n-            return group.permissions[ACCESS_FINE_LOCATION]?.isGrantedIncludingAppOp == true\n+            return group.permissions[ACCESS_FINE_LOCATION]?.isGranted == true\n         }\n \n-        return group.foreground.isGrantedExcludingRWROrAllRWR\n+        return group.foreground.allowFullGroupGrant\n     }\n \n     override fun isPermissionFixed(group: LightAppPermGroup, perm: String): Boolean {\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/StorageGrantBehavior.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/StorageGrantBehavior.kt\nindex a690f5f598..9dd87674ae 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/StorageGrantBehavior.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/grantPermissions/StorageGrantBehavior.kt\n@@ -66,11 +66,11 @@ object StorageGrantBehavior : GrantBehavior() {\n         }\n \n         val userSelectedPerm = group.permissions[READ_MEDIA_VISUAL_USER_SELECTED]\n-        if (userSelectedPerm?.isUserFixed == true && userSelectedPerm.isGrantedIncludingAppOp) {\n+        if (userSelectedPerm?.isUserFixed == true && userSelectedPerm.isGranted) {\n             return Prompt.NO_UI_PHOTO_PICKER_REDIRECT\n         }\n \n-        if (userSelectedPerm?.isGrantedIncludingAppOp == true) {\n+        if (userSelectedPerm?.isGranted == true) {\n             return Prompt.SELECT_MORE_PHOTOS\n         } else {\n             return Prompt.SELECT_PHOTOS\n@@ -97,16 +97,14 @@ object StorageGrantBehavior : GrantBehavior() {\n         }\n \n         return group.permissions.values.any {\n-            it.name !in getPartialGrantPermissions(group) && it.isGrantedIncludingAppOp\n+            it.name !in getPartialGrantPermissions(group) && it.isGranted\n         }\n     }\n \n     override fun isPermissionFixed(group: LightAppPermGroup, perm: String): Boolean {\n         val userSelectedPerm = group.permissions[READ_MEDIA_VISUAL_USER_SELECTED]\n         if (\n-            userSelectedPerm != null &&\n-                userSelectedPerm.isGrantedIncludingAppOp &&\n-                userSelectedPerm.isUserFixed\n+            userSelectedPerm != null && userSelectedPerm.isGranted && userSelectedPerm.isUserFixed\n         ) {\n             // If the user selected permission is fixed and granted, we immediately show the\n             // photo picker, rather than filtering\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt b/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\nindex b822aa5418..93c30939d0 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\n@@ -771,7 +771,7 @@ object KotlinUtils {\n                 LightPermission(\n                     group.packageInfo,\n                     perm.permInfo,\n-                    perm.isGrantedIncludingAppOp,\n+                    perm.isGranted,\n                     perm.flags or flagsToSet,\n                     perm.foregroundPerms\n                 )\n@@ -904,7 +904,7 @@ object KotlinUtils {\n                 group.specialLocationGrant\n             )\n         // If any permission in the group is one time granted, start one time permission session.\n-        if (newGroup.permissions.any { it.value.isOneTime && it.value.isGrantedIncludingAppOp }) {\n+        if (newGroup.permissions.any { it.value.isOneTime && it.value.isGranted }) {\n             if (SdkLevel.isAtLeastT()) {\n                 context\n                     .getSystemService(PermissionManager::class.java)!!\n@@ -966,7 +966,7 @@ object KotlinUtils {\n \n         var newFlags = perm.flags\n         var oldFlags = perm.flags\n-        var isGranted = perm.isGrantedIncludingAppOp\n+        var isGranted = perm.isGranted\n         var shouldKill = false\n \n         // Create a new context with the given deviceId so that permission updates will be bound\n@@ -974,7 +974,7 @@ object KotlinUtils {\n         val context = ContextCompat.createDeviceContext(app.applicationContext, deviceId)\n \n         // Grant the permission if needed.\n-        if (!perm.isGrantedIncludingAppOp) {\n+        if (!perm.isGranted) {\n             val affectsAppOp = permissionToOp(perm.name) != null || perm.isBackgroundPermission\n \n             // TODO 195016052: investigate adding split permission handling\n@@ -1043,14 +1043,14 @@ object KotlinUtils {\n \n         // If we newly grant background access to the fine location, double-guess the user some\n         // time later if this was really the right choice.\n-        if (!perm.isGrantedIncludingAppOp && isGranted) {\n+        if (!perm.isGranted && isGranted) {\n             var triggerLocationAccessCheck = false\n             if (perm.name == ACCESS_FINE_LOCATION) {\n                 val bgPerm = group.permissions[perm.backgroundPermission]\n-                triggerLocationAccessCheck = bgPerm?.isGrantedIncludingAppOp == true\n+                triggerLocationAccessCheck = bgPerm?.isGranted == true\n             } else if (perm.name == ACCESS_BACKGROUND_LOCATION) {\n                 val fgPerm = group.permissions[ACCESS_FINE_LOCATION]\n-                triggerLocationAccessCheck = fgPerm?.isGrantedIncludingAppOp == true\n+                triggerLocationAccessCheck = fgPerm?.isGranted == true\n             }\n             if (triggerLocationAccessCheck) {\n                 // trigger location access check\n@@ -1289,7 +1289,7 @@ object KotlinUtils {\n         val user = UserHandle.getUserHandleForUid(group.packageInfo.uid)\n         var newFlags = perm.flags\n         val deviceId = group.deviceId\n-        var isGranted = perm.isGrantedIncludingAppOp\n+        var isGranted = perm.isGranted\n         val supportsRuntime = group.packageInfo.targetSdkVersion >= Build.VERSION_CODES.M\n         var shouldKill = false\n \n@@ -1299,7 +1299,7 @@ object KotlinUtils {\n         // to the device\n         val context = ContextCompat.createDeviceContext(app.applicationContext, deviceId)\n \n-        if (perm.isGrantedIncludingAppOp || (perm.isCompatRevoked && forceRemoveRevokedCompat)) {\n+        if (perm.isGranted || (perm.isCompatRevoked && forceRemoveRevokedCompat)) {\n             if (\n                 supportsRuntime &&\n                     !isPermissionSplitFromNonRuntime(\n@@ -1363,14 +1363,14 @@ object KotlinUtils {\n \n         // If we revoke background access to the fine location, we trigger a check to remove\n         // notification warning about background location access\n-        if (perm.isGrantedIncludingAppOp && !isGranted) {\n+        if (perm.isGranted && !isGranted) {\n             var cancelLocationAccessWarning = false\n             if (perm.name == ACCESS_FINE_LOCATION) {\n                 val bgPerm = group.permissions[perm.backgroundPermission]\n-                cancelLocationAccessWarning = bgPerm?.isGrantedIncludingAppOp == true\n+                cancelLocationAccessWarning = bgPerm?.isGranted == true\n             } else if (perm.name == ACCESS_BACKGROUND_LOCATION) {\n                 val fgPerm = group.permissions[ACCESS_FINE_LOCATION]\n-                cancelLocationAccessWarning = fgPerm?.isGrantedIncludingAppOp == true\n+                cancelLocationAccessWarning = fgPerm?.isGranted == true\n             }\n             if (cancelLocationAccessWarning) {\n                 // cancel location access warning notification\n@@ -1430,7 +1430,7 @@ object KotlinUtils {\n                 val fgPerm = group.permissions[foregroundPermName]\n                 val appOpName = permissionToOp(foregroundPermName) ?: continue\n \n-                if (fgPerm != null && fgPerm.isGrantedIncludingAppOp) {\n+                if (fgPerm != null && fgPerm.isGranted) {\n                     wasChanged =\n                         setOpMode(appOpName, uid, packageName, MODE_ALLOWED, appOpsManager) ||\n                             wasChanged\n@@ -1443,7 +1443,7 @@ object KotlinUtils {\n                     if (group.permissions.containsKey(perm.backgroundPermission)) {\n                         val bgPerm = group.permissions[perm.backgroundPermission]\n                         val mode =\n-                            if (bgPerm != null && bgPerm.isGrantedIncludingAppOp) MODE_ALLOWED\n+                            if (bgPerm != null && bgPerm.isGranted) MODE_ALLOWED\n                             else MODE_FOREGROUND\n \n                         setOpMode(appOpName, uid, packageName, mode, appOpsManager)\n@@ -1490,7 +1490,7 @@ object KotlinUtils {\n         if (perm.isBackgroundPermission && perm.foregroundPerms != null) {\n             for (foregroundPermName in perm.foregroundPerms) {\n                 val fgPerm = group.permissions[foregroundPermName]\n-                if (fgPerm != null && fgPerm.isGrantedIncludingAppOp) {\n+                if (fgPerm != null && fgPerm.isGranted) {\n                     val appOpName = permissionToOp(foregroundPermName) ?: return false\n                     wasChanged =\n                         wasChanged ||\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java b/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\nindex 828857cc6d..c9b023c443 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\n@@ -95,7 +95,7 @@ public final class SafetyNetLogger {\n             }\n \n             builder.append(permission.getName()).append('|');\n-            builder.append(permission.isGrantedIncludingAppOp()).append('|');\n+            builder.append(permission.isGranted()).append('|');\n             builder.append(permission.getFlags());\n         }\n     }\ndiff --git a/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/ui/model/ReviewPermissionsViewModelTest.kt b/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/ui/model/ReviewPermissionsViewModelTest.kt\nindex 899a026c42..0e8890df59 100644\n--- a/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/ui/model/ReviewPermissionsViewModelTest.kt\n+++ b/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/ui/model/ReviewPermissionsViewModelTest.kt\n@@ -104,7 +104,7 @@ class ReviewPermissionsViewModelTest {\n         permissionsMap[\"mockedPermission1\"] = permission2\n \n         whenever(permGroup.allPermissions).thenReturn(permissionsMap)\n-        whenever(permission1.isGrantedIncludingAppOp).thenReturn(true)\n+        whenever(permission1.isGranted).thenReturn(true)\n \n         val summary = model.getSummaryForIndividuallyControlledPermGroup(permGroup)\n         assertEquals(\ndiff --git a/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/utils/GrantRevokeTests.kt b/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/utils/GrantRevokeTests.kt\nindex 8bd61ebe6a..28f69b1369 100644\n--- a/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/utils/GrantRevokeTests.kt\n+++ b/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/utils/GrantRevokeTests.kt\n@@ -25,6 +25,7 @@ import android.app.AppOpsManager.MODE_IGNORED\n import android.app.AppOpsManager.permissionToOp\n import android.app.Application\n import android.content.Context\n+import android.content.pm.ApplicationInfo\n import android.content.pm.PackageManager\n import android.content.pm.PackageManager.FLAG_PERMISSION_AUTO_REVOKED\n import android.content.pm.PackageManager.FLAG_PERMISSION_ONE_TIME\n@@ -216,7 +217,8 @@ class GrantRevokeTests {\n                 backgroundPerm,\n                 PermissionInfo.PROTECTION_DANGEROUS,\n                 permInfoProtectionFlags,\n-                0\n+                0,\n+                pkgInfo.appFlags and ApplicationInfo.FLAG_SYSTEM != 0\n             )\n         return LightPermission(\n             pkgInfo,\n@@ -292,7 +294,7 @@ class GrantRevokeTests {\n             val flags = state.second\n \n             assertWithMessage(\"permission $permName grant state incorrect\")\n-                .that(perms[permName]?.isGrantedIncludingAppOp)\n+                .that(perms[permName]?.isGranted)\n                 .isEqualTo(granted)\n \n             val actualFlags = perms[permName]!!.flags\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 10348,
                        "general": {
                            "word_based": 4024,
                            "char_based": 12221
                        },
                        "gemini": 12468
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 0,
                    "failed_patches": 4,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "6843ffaa44ed01868c9b67bfc1c13bac4c2bd71a",
                            "repo_path": "android_repos/Permission",
                            "result": "failure",
                            "downstream_patch_content": "commit 6843ffaa44ed01868c9b67bfc1c13bac4c2bd71a\nAuthor: Yi-an Chen <theianchen@google.com>\nDate:   Thu Aug 8 01:15:57 2024 +0000\n\n    RESTRICT AUTOMERGE Fix Dynamic Permission group auto grant behaivor\n    \n    Fix the Dynamic Permission group auto grant behaivor so that a\n    permission group is only considered granted when (1) all permissions\n    were auto-granted or (2) a platform permission in the same group is\n    granted.\n    \n    Bug: 340480881\n    Test: DynamicPermissionsTest\n    Change-Id: I37b550f0c3933bc790c2917a14e917efbcccc4e8\n    Merged-In: I37b550f0c3933bc790c2917a14e917efbcccc4e8\n\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt b/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\nindex 97389b0984..bf43f15c3f 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\n@@ -66,7 +66,7 @@ class LightPermInfoLiveData private constructor(\n         }\n \n         val newValue = try {\n-            LightPermInfo(app.packageManager.getPermissionInfo(permissionName, 0))\n+            LightPermInfo(app.packageManager.getPermissionInfo(permissionName, 0), null)\n         } catch (e: PackageManager.NameNotFoundException) {\n             Log.w(LOG_TAG, \"Permission \\\"$permissionName\\\" not found\")\n             invalidateSingle(permissionName)\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt b/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\nindex 78f2f72c63..948815646a 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\n@@ -17,6 +17,7 @@\n package com.android.permissioncontroller.permission.data\n \n import android.app.Application\n+import android.content.pm.ApplicationInfo\n import android.content.pm.PackageItemInfo\n import android.content.pm.PackageManager\n import android.content.pm.PermissionGroupInfo\n@@ -68,32 +69,31 @@ class PermGroupLiveData private constructor(\n      */\n     override fun onUpdate() {\n         val permissionInfos = mutableMapOf<String, LightPermInfo>()\n-\n         groupInfo = Utils.getGroupInfo(groupName, context) ?: run {\n             Log.e(LOG_TAG, \"Invalid permission group $groupName\")\n             invalidateSingle(groupName)\n             value = null\n             return\n         }\n-\n+        val permInfos = mutableListOf<PermissionInfo>()\n         when (groupInfo) {\n             is PermissionGroupInfo -> {\n-                val permInfos = try {\n-                    Utils.getInstalledRuntimePermissionInfosForGroup(context.packageManager,\n-                        groupName)\n+                try {\n+                    permInfos.addAll(\n+                        Utils.getInstalledRuntimePermissionInfosForGroup(\n+                            context.packageManager,\n+                            groupName\n+                        )\n+                    )\n                 } catch (e: PackageManager.NameNotFoundException) {\n                     Log.e(LOG_TAG, \"Invalid permission group $groupName\")\n                     invalidateSingle(groupName)\n                     value = null\n                     return\n                 }\n-\n-                for (permInfo in permInfos) {\n-                    permissionInfos[permInfo.name] = LightPermInfo(permInfo)\n-                }\n             }\n             is PermissionInfo -> {\n-                permissionInfos[groupInfo.name] = LightPermInfo(groupInfo as PermissionInfo)\n+                permInfos.add(groupInfo as PermissionInfo)\n             }\n             else -> {\n                 value = null\n@@ -101,19 +101,25 @@ class PermGroupLiveData private constructor(\n             }\n         }\n \n-        val permGroup = PermGroup(LightPermGroupInfo(groupInfo), permissionInfos)\n-\n-        value = permGroup\n-\n-        val packageNames = permissionInfos.values.map { permInfo -> permInfo.packageName }\n-            .toMutableSet()\n+        val packageNames = permInfos.map { permInfo -> permInfo.packageName }.toMutableSet()\n         packageNames.add(groupInfo.packageName)\n-\n         // TODO ntmyren: What if the package isn't installed for the system user?\n         val getLiveData = { packageName: String ->\n             LightPackageInfoLiveData[packageName, UserHandle.SYSTEM]\n         }\n         setSourcesToDifference(packageNames, packageLiveDatas, getLiveData)\n+        if (!packageLiveDatas.all { it.value.isInitialized }) {\n+            return\n+        }\n+        for (permInfo in permInfos) {\n+            val lightPackageInfo = packageLiveDatas[permInfo.packageName]?.value\n+            val isSystem =\n+                lightPackageInfo?.let { it.appFlags and ApplicationInfo.FLAG_SYSTEM != 0 }\n+            permissionInfos[permInfo.name] = LightPermInfo(permInfo, isSystem)\n+        }\n+\n+        val permGroup = PermGroup(LightPermGroupInfo(groupInfo), permissionInfos)\n+        value = permGroup\n     }\n \n     override fun onInactive() {\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\nindex cbfac4b244..1d807292ad 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\n@@ -20,6 +20,7 @@ import android.Manifest\n import android.Manifest.permission.ACCESS_COARSE_LOCATION\n import android.os.Build\n import android.os.UserHandle\n+import com.android.permissioncontroller.permission.utils.Utils\n \n /**\n  * A lightweight version of the AppPermissionGroup data structure. Represents information about a\n@@ -79,11 +80,13 @@ data class LightAppPermGroup(\n         if (name !in backgroundPermNames) name else null\n     }\n \n+    val isPlatformPermissionGroup = permGroupInfo.packageName == Utils.OS_PKG\n+\n     val foreground = AppPermSubGroup(permissions.filter { it.key in foregroundPermNames },\n-        packageInfo, specialLocationGrant)\n+        packageInfo, isPlatformPermissionGroup, specialLocationGrant)\n \n     val background = AppPermSubGroup(permissions.filter { it.key in backgroundPermNames },\n-        packageInfo, specialLocationGrant)\n+        packageInfo, isPlatformPermissionGroup, specialLocationGrant)\n \n     /**\n      * Whether or not this App Permission Group has a permission which has a background mode\n@@ -152,24 +155,34 @@ data class LightAppPermGroup(\n      *\n      * @param permissions The permissions contained within this subgroup, a subset of those contained\n      * in the full group\n+     * @param isPlatformPermissionGroup Whether this is a platform permission group\n      * @param specialLocationGrant Whether this is a special location package\n      */\n     data class AppPermSubGroup internal constructor(\n         private val permissions: Map<String, LightPermission>,\n         private val packageInfo: LightPackageInfo,\n+        private val isPlatformPermissionGroup: Boolean,\n         private val specialLocationGrant: Boolean?\n     ) {\n-        /**\n-         * Whether any of this App Permission SubGroup's permissions are granted\n-         */\n-        val isGranted = specialLocationGrant ?: permissions.any { it.value.isGrantedIncludingAppOp }\n+        /** Whether any of this App Permission SubGroup's permissions are granted */\n+        val isGranted =\n+            specialLocationGrant\n+                ?: permissions.any {\n+                    val mayGrantByPlatformOrSystem =\n+                        !isPlatformPermissionGroup || it.value.isPlatformOrSystem\n+                    it.value.isGranted && mayGrantByPlatformOrSystem\n+                }\n \n         /**\n          * Whether any of this App Permission SubGroup's permissions are granted excluding\n          * auto granted permissions during install time with flag RevokeWhenRequested\n          */\n-        val isGrantedExcludeRevokeWhenRequestedPermissions = specialLocationGrant ?: permissions\n-            .any { it.value.isGrantedIncludingAppOp && !it.value.isRevokeWhenRequested }\n+        val allowFullGroupGrant = specialLocationGrant ?: permissions\n+            .any {\n+                val mayGrantByPlatformOrSystem =\n+                        !isPlatformPermissionGroup || it.value.isPlatformOrSystem\n+                it.value.allowFullGroupGrant && mayGrantByPlatformOrSystem\n+            }\n \n         /**\n          * Whether any of this App Permission SubGroup's permissions are granted by default\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\nindex 182de1a597..a37a47163f 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\n@@ -49,7 +49,9 @@ data class LightPackageInfo(\n     val firstInstallTime: Long\n ) {\n     constructor(pI: PackageInfo) : this(pI.packageName,\n-        pI.permissions?.map { perm -> LightPermInfo(perm) } ?: emptyList(),\n+        pI.permissions?.map { perm ->\n+            LightPermInfo(perm, pI.applicationInfo!!.flags and ApplicationInfo.FLAG_SYSTEM != 0)\n+        } ?: emptyList(),\n         pI.requestedPermissions?.toList() ?: emptyList(),\n         pI.requestedPermissionsFlags?.toList() ?: emptyList(),\n         pI.applicationInfo.uid, pI.applicationInfo.targetSdkVersion,\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\nindex 3954b74722..582742da43 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\n@@ -30,6 +30,7 @@ import android.content.pm.PermissionInfo\n  * @param protection The protection level of this permission\n  * @param protection Extra information about the protection of this permission\n  * @param flags The system flags of this permission\n+ * @param isSystem Whether this permission is defined by a system app\n  */\n data class LightPermInfo(\n     val name: String,\n@@ -38,11 +39,13 @@ data class LightPermInfo(\n     val backgroundPermission: String?,\n     val protection: Int,\n     val protectionFlags: Int,\n-    val flags: Int\n+    val flags: Int,\n+    val isSystem: Boolean?\n ) {\n-    constructor (permInfo: PermissionInfo): this(permInfo.name, permInfo.packageName,\n-        permInfo.group, permInfo.backgroundPermission, permInfo.protection,\n-        permInfo.protectionFlags, permInfo.flags)\n+    constructor (permInfo: PermissionInfo, isSystem: Boolean?) : this(\n+        permInfo.name, permInfo.packageName, permInfo.group, permInfo.backgroundPermission,\n+        permInfo.protection, permInfo.protectionFlags, permInfo.flags, isSystem\n+    )\n \n     /**\n      * Gets the PermissionInfo for this permission from the system.\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\nindex c3d087fd24..45c3b1e92a 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\n@@ -27,7 +27,7 @@ import com.android.permissioncontroller.permission.utils.Utils.isRuntimePlatform\n  *\n  * @param pkgInfo The package requesting the permission\n  * @param permInfo The permissionInfo this represents\n- * @param isGrantedIncludingAppOp Whether or not this permission is functionally granted.\n+ * @param isGranted Whether or not this permission is functionally granted.\n  * A non-granted app op but granted permission is counted as not granted\n  * @param flags The PermissionController flags for this permission\n  * @param foregroundPerms The foreground permission names corresponding to this permission, if this\n@@ -36,7 +36,7 @@ import com.android.permissioncontroller.permission.utils.Utils.isRuntimePlatform\n data class LightPermission(\n     val pkgInfo: LightPackageInfo,\n     val permInfo: LightPermInfo,\n-    val isGrantedIncludingAppOp: Boolean,\n+    val isGranted: Boolean,\n     val flags: Int,\n     val foregroundPerms: List<String>?\n ) {\n@@ -82,9 +82,9 @@ data class LightPermission(\n     val isRevokeWhenRequested = flags and PackageManager.FLAG_PERMISSION_REVOKE_WHEN_REQUESTED != 0\n     /** Whether this permission is user sensitive in its current grant state */\n     val isUserSensitive = !isRuntimePlatformPermission(permInfo.name) ||\n-            (isGrantedIncludingAppOp &&\n+            (isGranted &&\n                     (flags and PackageManager.FLAG_PERMISSION_USER_SENSITIVE_WHEN_GRANTED) != 0) ||\n-            (!isGrantedIncludingAppOp &&\n+            (!isGranted &&\n                     (flags and PackageManager.FLAG_PERMISSION_USER_SENSITIVE_WHEN_DENIED) != 0)\n     /** Whether the permission is restricted */\n     val isRestricted = when {\n@@ -105,10 +105,17 @@ data class LightPermission(\n      */\n     val isSelectedLocationAccuracy =\n         flags and PackageManager.FLAG_PERMISSION_SELECTED_LOCATION_ACCURACY != 0\n+    /** Whether this permission is defined by platform or a system app */\n+    val isPlatformOrSystem = permInfo.packageName == Utils.OS_PKG || permInfo.isSystem == true\n+    /**\n+     * Whether this permission is granted including app op and does not hold the\n+     * PackageManager.FLAG_PERMISSION_REVOKE_WHEN_REQUESTED flag.\n+     */\n+    val allowFullGroupGrant = isGranted && !isRevokeWhenRequested\n \n     override fun toString() = buildString {\n         append(name)\n-        if (isGrantedIncludingAppOp) append(\", Granted\") else append(\", NotGranted\")\n+        if (isGranted) append(\", Granted\") else append(\", NotGranted\")\n         if (isPolicyFixed) append(\", PolicyFixed\")\n         if (isSystemFixed) append(\", SystemFixed\")\n         if (isUserFixed) append(\", UserFixed\")\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt b/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\nindex d57e797519..92bfa887e8 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\n@@ -93,7 +93,7 @@ suspend fun revokeAppPermissions(\n \n                 val fixed = group.isBackgroundFixed || group.isForegroundFixed\n                 val granted = group.permissions.any { (_, perm) ->\n-                    perm.isGrantedIncludingAppOp && perm.name !in EXEMPT_PERMISSIONS\n+                    perm.isGranted && perm.name !in EXEMPT_PERMISSIONS\n                 }\n                 if (!fixed &&\n                     granted &&\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt b/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\nindex c22e5dd422..6369eeada3 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\n@@ -382,7 +382,7 @@ internal object RuntimePermissionsUpgradeController {\n \n                 val allPermissionsWithxemption = bgApp.allPermissions.toMutableMap()\n                 allPermissionsWithxemption[permission.ACCESS_BACKGROUND_LOCATION] =\n-                        LightPermission(perm.pkgInfo, perm.permInfo, perm.isGrantedIncludingAppOp,\n+                        LightPermission(perm.pkgInfo, perm.permInfo, perm.isGranted,\n                         perm.flags or FLAG_PERMISSION_RESTRICTION_UPGRADE_EXEMPT,\n                         perm.foregroundPerms)\n \n@@ -444,7 +444,7 @@ internal object RuntimePermissionsUpgradeController {\n                             ?: continue\n \n                     if (!perm.isUserSet && !perm.isSystemFixed && !perm.isPolicyFixed &&\n-                            !perm.isGrantedIncludingAppOp) {\n+                            !perm.isGranted) {\n                         grants.add(Grant(false, appPermGroup,\n                                 listOf(permission.ACCESS_MEDIA_LOCATION)))\n                     }\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\nindex 05c5849f06..244fdd2bb2 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\n@@ -698,7 +698,7 @@ class AppPermissionViewModel(\n \n     private fun getIndividualPermissionDetailResId(group: LightAppPermGroup): Pair<Int, Int> {\n         return when (val numRevoked =\n-            group.permissions.filter { !it.value.isGrantedIncludingAppOp }.size) {\n+            group.permissions.filter { !it.value.isGranted }.size) {\n             0 -> R.string.permission_revoked_none to numRevoked\n             group.permissions.size -> R.string.permission_revoked_all to numRevoked\n             else -> R.string.permission_revoked_count to numRevoked\n@@ -767,7 +767,7 @@ class AppPermissionViewModel(\n         for ((permName, permission) in oldGroup.permissions) {\n             val newPermission = newGroup.permissions[permName] ?: continue\n \n-            if (permission.isGrantedIncludingAppOp != newPermission.isGrantedIncludingAppOp ||\n+            if (permission.isGranted != newPermission.isGranted ||\n                 permission.flags != newPermission.flags) {\n                 logAppPermissionFragmentActionReported(changeId, newPermission, buttonPressed)\n             }\n@@ -782,10 +782,10 @@ class AppPermissionViewModel(\n         val uid = KotlinUtils.getPackageUid(app, packageName, user) ?: return\n         PermissionControllerStatsLog.write(APP_PERMISSION_FRAGMENT_ACTION_REPORTED, sessionId,\n             changeId, uid, packageName, permission.permInfo.name,\n-            permission.isGrantedIncludingAppOp, permission.flags, buttonPressed)\n+            permission.isGranted, permission.flags, buttonPressed)\n         Log.v(LOG_TAG, \"Permission changed via UI with sessionId=$sessionId changeId=\" +\n             \"$changeId uid=$uid packageName=$packageName permission=\" + permission.permInfo.name +\n-            \" isGranted=\" + permission.isGrantedIncludingAppOp + \" permissionFlags=\" +\n+            \" isGranted=\" + permission.isGranted + \" permissionFlags=\" +\n             permission.flags + \" buttonPressed=$buttonPressed\")\n     }\n \ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\nindex 93f0f74a47..61211b0f02 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\n@@ -237,7 +237,7 @@ class GrantPermissionsViewModel(\n                     // some requests might have been granted, check for that\n                     for ((key, state) in states) {\n                         val allAffectedGranted = state.affectedPermissions.all { perm ->\n-                            appPermGroup.permissions[perm]?.isGrantedIncludingAppOp == true &&\n+                            appPermGroup.permissions[perm]?.isGranted == true &&\n                                 appPermGroup.permissions[perm]?.isRevokeWhenRequested == false\n                         }\n                         if (allAffectedGranted) {\n@@ -275,7 +275,7 @@ class GrantPermissionsViewModel(\n                 if (fgState?.group != null) {\n                     val fgGroup = fgState.group\n                     for (perm in fgState.affectedPermissions) {\n-                        if (fgGroup.permissions[perm]?.isGrantedIncludingAppOp == false) {\n+                        if (fgGroup.permissions[perm]?.isGranted == false) {\n                             // If any of the requested permissions is not granted,\n                             // needFgPermissions = true\n                             needFgPermissions = true\n@@ -425,7 +425,7 @@ class GrantPermissionsViewModel(\n                                 fgState.affectedPermissions.contains(ACCESS_FINE_LOCATION)) {\n                             val coarseLocationPerm =\n                                 groupState.group.allPermissions[ACCESS_COARSE_LOCATION]\n-                            if (coarseLocationPerm?.isGrantedIncludingAppOp == true) {\n+                            if (coarseLocationPerm?.isGranted == true) {\n                                 // Upgrade flow\n                                 locationVisibilities[DIALOG_WITH_FINE_LOCATION_ONLY] = true\n                                 message = RequestMessage.FG_FINE_LOCATION_MESSAGE\n@@ -648,7 +648,7 @@ class GrantPermissionsViewModel(\n \n         // Do not attempt to grant background access if foreground access is not either already\n         // granted or requested\n-        if (isBackground && !group.foreground.isGrantedExcludeRevokeWhenRequestedPermissions &&\n+        if (isBackground && !group.foreground.allowFullGroupGrant &&\n             !hasForegroundRequest) {\n             Log.w(LOG_TAG, \"Cannot grant $perm as the matching foreground permission is not \" +\n                 \"already granted.\")\n@@ -660,21 +660,22 @@ class GrantPermissionsViewModel(\n             return STATE_SKIPPED\n         }\n \n-        if (isBackground && group.background.isGrantedExcludeRevokeWhenRequestedPermissions ||\n-            !isBackground && group.foreground.isGrantedExcludeRevokeWhenRequestedPermissions) {\n+        if (isBackground && group.background.allowFullGroupGrant ||\n+            !isBackground && group.foreground.allowFullGroupGrant) {\n             // If FINE location is not granted, do not grant it automatically when COARSE\n             // location is already granted.\n             if (group.permGroupName == LOCATION &&\n-                    group.allPermissions[ACCESS_FINE_LOCATION]?.isGrantedIncludingAppOp\n+                    group.allPermissions[ACCESS_FINE_LOCATION]?.isGranted\n                     == false) {\n                 return STATE_UNKNOWN\n             }\n \n-            if (group.permissions[perm]?.isGrantedIncludingAppOp == false) {\n+            if (group.permissions[perm]?.isGranted == false) {\n                 if (isBackground) {\n                     KotlinUtils.grantBackgroundRuntimePermissions(app, group, listOf(perm))\n                 } else {\n-                    KotlinUtils.grantForegroundRuntimePermissions(app, group, listOf(perm), group.isOneTime)\n+                    KotlinUtils.grantForegroundRuntimePermissions(app, group, listOf(perm),\n+                            group.isOneTime)\n                 }\n                 KotlinUtils.setGroupFlags(app, group, FLAG_PERMISSION_USER_SET to false,\n                     FLAG_PERMISSION_USER_FIXED to false, filterPermissions = listOf(perm))\n@@ -845,28 +846,40 @@ class GrantPermissionsViewModel(\n             } else {\n                 PERMISSION_GRANT_REQUEST_RESULT_REPORTED__RESULT__USER_GRANTED\n             }\n+            var affectedPermissions: List<String> = groupState.affectedPermissions\n             if (groupState.isBackground) {\n                 KotlinUtils.grantBackgroundRuntimePermissions(app, groupState.group,\n-                    groupState.affectedPermissions)\n+                    affectedPermissions)\n             } else {\n                 if (affectedForegroundPermissions == null) {\n                     KotlinUtils.grantForegroundRuntimePermissions(app, groupState.group,\n-                        groupState.affectedPermissions, isOneTime)\n+                        affectedPermissions, isOneTime)\n                     // This prevents weird flag state when app targetSDK switches from S+ to R-\n                     if (groupState.affectedPermissions.contains(ACCESS_FINE_LOCATION)) {\n                         KotlinUtils.setFlagsWhenLocationAccuracyChanged(\n                                 app, groupState.group, true)\n                     }\n                 } else {\n+                    affectedPermissions = affectedForegroundPermissions\n                     val newGroup = KotlinUtils.grantForegroundRuntimePermissions(app,\n-                            groupState.group, affectedForegroundPermissions, isOneTime)\n+                            groupState.group, affectedPermissions, isOneTime)\n                     if (!isOneTime || newGroup.isOneTime) {\n                         KotlinUtils.setFlagsWhenLocationAccuracyChanged(app, newGroup,\n                                 affectedForegroundPermissions.contains(ACCESS_FINE_LOCATION))\n                     }\n                 }\n             }\n-            groupState.state = STATE_ALLOWED\n+            val shouldDenyFullGroupGrant =\n+                groupState.group.isPlatformPermissionGroup &&\n+                        affectedPermissions.none {\n+                            groupState.group.permissions[it]?.isPlatformOrSystem == true\n+                        }\n+            groupState.state =\n+                if (shouldDenyFullGroupGrant) {\n+                    STATE_UNKNOWN\n+                } else {\n+                    STATE_ALLOWED\n+                }\n         } else {\n             if (groupState.isBackground) {\n                 KotlinUtils.revokeBackgroundRuntimePermissions(app, groupState.group,\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt b/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\nindex da93d4f782..85908cb0ef 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\n@@ -440,7 +440,7 @@ object KotlinUtils {\n                     group.userHandle, *flags)\n             }\n             newPerms[permName] = LightPermission(group.packageInfo, perm.permInfo,\n-                perm.isGrantedIncludingAppOp, perm.flags or flagsToSet, perm.foregroundPerms)\n+                perm.isGranted, perm.flags or flagsToSet, perm.foregroundPerms)\n         }\n         return LightAppPermGroup(group.packageInfo, group.permGroupInfo, newPerms,\n             group.hasInstallToRuntimeSplit, group.specialLocationGrant)\n@@ -518,7 +518,7 @@ object KotlinUtils {\n         val newGroup = LightAppPermGroup(group.packageInfo, group.permGroupInfo, newPerms,\n             group.hasInstallToRuntimeSplit, group.specialLocationGrant)\n         // If any permission in the group is one time granted, start one time permission session.\n-        if (newGroup.permissions.any { it.value.isOneTime && it.value.isGrantedIncludingAppOp }) {\n+        if (newGroup.permissions.any { it.value.isOneTime && it.value.isGranted }) {\n             app.getSystemService(PermissionManager::class.java)!!.startOneTimePermissionSession(\n                 group.packageName, Utils.getOneTimePermissionsTimeout(),\n                 ONE_TIME_PACKAGE_IMPORTANCE_LEVEL_TO_RESET_TIMER,\n@@ -555,11 +555,11 @@ object KotlinUtils {\n         }\n \n         var newFlags = perm.flags\n-        var isGranted = perm.isGrantedIncludingAppOp\n+        var isGranted = perm.isGranted\n         var shouldKill = false\n \n         // Grant the permission if needed.\n-        if (!perm.isGrantedIncludingAppOp) {\n+        if (!perm.isGranted) {\n             val affectsAppOp = permissionToOp(perm.name) != null || perm.isBackgroundPermission\n \n             // TODO 195016052: investigate adding split permission handling\n@@ -602,14 +602,14 @@ object KotlinUtils {\n \n         // If we newly grant background access to the fine location, double-guess the user some\n         // time later if this was really the right choice.\n-        if (!perm.isGrantedIncludingAppOp && isGranted) {\n+        if (!perm.isGranted && isGranted) {\n             var triggerLocationAccessCheck = false\n             if (perm.name == ACCESS_FINE_LOCATION) {\n                 val bgPerm = group.permissions[perm.backgroundPermission]\n-                triggerLocationAccessCheck = bgPerm?.isGrantedIncludingAppOp == true\n+                triggerLocationAccessCheck = bgPerm?.isGranted == true\n             } else if (perm.name == ACCESS_BACKGROUND_LOCATION) {\n                 val fgPerm = group.permissions[ACCESS_FINE_LOCATION]\n-                triggerLocationAccessCheck = fgPerm?.isGrantedIncludingAppOp == true\n+                triggerLocationAccessCheck = fgPerm?.isGranted == true\n             }\n             if (triggerLocationAccessCheck) {\n                 // trigger location access check\n@@ -774,13 +774,13 @@ object KotlinUtils {\n \n         val user = UserHandle.getUserHandleForUid(group.packageInfo.uid)\n         var newFlags = perm.flags\n-        var isGranted = perm.isGrantedIncludingAppOp\n+        var isGranted = perm.isGranted\n         val supportsRuntime = group.packageInfo.targetSdkVersion >= Build.VERSION_CODES.M\n         var shouldKill = false\n \n         val affectsAppOp = permissionToOp(perm.name) != null || perm.isBackgroundPermission\n \n-        if (perm.isGrantedIncludingAppOp) {\n+        if (perm.isGranted) {\n             if (supportsRuntime && !isPermissionSplitFromNonRuntime(app, perm.name,\n                             group.packageInfo.targetSdkVersion)) {\n                 // Revoke the permission if needed.\n@@ -874,7 +874,7 @@ object KotlinUtils {\n                 val fgPerm = group.permissions[foregroundPermName]\n                 val appOpName = permissionToOp(foregroundPermName) ?: continue\n \n-                if (fgPerm != null && fgPerm.isGrantedIncludingAppOp) {\n+                if (fgPerm != null && fgPerm.isGranted) {\n                     wasChanged = wasChanged || setOpMode(appOpName, uid, packageName, MODE_ALLOWED,\n                         appOpsManager)\n                 }\n@@ -884,7 +884,7 @@ object KotlinUtils {\n             if (perm.backgroundPermission != null) {\n                 wasChanged = if (group.permissions.containsKey(perm.backgroundPermission)) {\n                     val bgPerm = group.permissions[perm.backgroundPermission]\n-                    val mode = if (bgPerm != null && bgPerm.isGrantedIncludingAppOp) MODE_ALLOWED\n+                    val mode = if (bgPerm != null && bgPerm.isGranted) MODE_ALLOWED\n                     else MODE_FOREGROUND\n \n                     setOpMode(appOpName, uid, packageName, mode, appOpsManager)\n@@ -935,7 +935,7 @@ object KotlinUtils {\n         if (perm.isBackgroundPermission && perm.foregroundPerms != null) {\n             for (foregroundPermName in perm.foregroundPerms) {\n                 val fgPerm = group.permissions[foregroundPermName]\n-                if (fgPerm != null && fgPerm.isGrantedIncludingAppOp) {\n+                if (fgPerm != null && fgPerm.isGranted) {\n                     val appOpName = permissionToOp(foregroundPermName) ?: return false\n                     wasChanged = wasChanged || setOpMode(appOpName, uid, packageName,\n                         MODE_FOREGROUND, appOpsManager)\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java b/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\nindex f0227cad54..96eccd0a8d 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\n@@ -162,7 +162,7 @@ public final class SafetyNetLogger {\n             }\n \n             builder.append(permission.getName()).append('|');\n-            builder.append(permission.isGrantedIncludingAppOp()).append('|');\n+            builder.append(permission.isGranted()).append('|');\n             builder.append(permission.getFlags());\n         }\n     }\ndiff --git a/PermissionController/tests/mocking/src/com/android/permissioncontroller/permission/utils/GrantRevokeTests.kt b/PermissionController/tests/mocking/src/com/android/permissioncontroller/permission/utils/GrantRevokeTests.kt\nindex 8f7494124e..496cca01cc 100644\n--- a/PermissionController/tests/mocking/src/com/android/permissioncontroller/permission/utils/GrantRevokeTests.kt\n+++ b/PermissionController/tests/mocking/src/com/android/permissioncontroller/permission/utils/GrantRevokeTests.kt\n@@ -24,6 +24,7 @@ import android.app.AppOpsManager.MODE_FOREGROUND\n import android.app.AppOpsManager.MODE_IGNORED\n import android.app.AppOpsManager.permissionToOp\n import android.app.Application\n+import android.content.pm.ApplicationInfo\n import android.content.pm.PackageManager\n import android.content.pm.PackageManager.FLAG_PERMISSION_AUTO_REVOKED\n import android.content.pm.PackageManager.FLAG_PERMISSION_ONE_TIME\n@@ -180,7 +181,8 @@ class GrantRevokeTests {\n         permInfoProtectionFlags: Int = 0\n     ): LightPermission {\n         val permInfo = LightPermInfo(permName, TEST_PACKAGE_NAME, PERM_GROUP_NAME, backgroundPerm,\n-            PermissionInfo.PROTECTION_DANGEROUS, permInfoProtectionFlags, 0)\n+            PermissionInfo.PROTECTION_DANGEROUS, permInfoProtectionFlags, 0,\n+                pkgInfo.appFlags and ApplicationInfo.FLAG_SYSTEM != 0)\n         return LightPermission(pkgInfo, permInfo,\n                 pkgInfo.requestedPermissionsFlags[pkgInfo.requestedPermissions.indexOf(permName)]\n                         == PERMISSION_GRANTED, flags, foregroundPerms)\n@@ -251,7 +253,7 @@ class GrantRevokeTests {\n             val flags = state.second\n \n             assertWithMessage(\"permission $permName grant state incorrect\")\n-                .that(perms[permName]?.isGrantedIncludingAppOp).isEqualTo(granted)\n+                .that(perms[permName]?.isGranted).isEqualTo(granted)\n \n             val actualFlags = perms[permName]!!.flags\n             assertWithMessage(\"permission $permName flags incorrect, expected\" +\n",
                            "downstream_patch_tokens": {
                                "openai": 7334,
                                "general": {
                                    "word_based": 2909,
                                    "char_based": 8789
                                },
                                "gemini": 8838
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java",
                                    "total_hunks": 1,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [],
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    },
                                    "rej_file_content": "```diff\n--- PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n+++ PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n@@ -267,11 +267,11 @@ public final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.i(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }\n```",
                                    "rej_file_tokens": {
                                        "openai": 203,
                                        "general": {
                                            "word_based": 77,
                                            "char_based": 289
                                        },
                                        "gemini": 250
                                    },
                                    "patch_apply_output": "patching file PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\nHunk #1 FAILED at 267.\n1 out of 1 hunk FAILED -- saving rejects to file PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java.rej\npatching file PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\nHunk #1 succeeded at 162 (offset 67 lines).",
                                    "inline_merge_output": "patching file PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\nHunk #1 already applied at 270,274.",
                                    "upstream_file_tokens": {
                                        "openai": 3650,
                                        "general": {
                                            "word_based": 1580,
                                            "char_based": 5344
                                        },
                                        "gemini": 4529
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.permissioncontroller.permission.ui.handheld;\n\nimport static android.content.pm.PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED;\n\nimport static com.android.permissioncontroller.PermissionControllerStatsLog.REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.content.IntentSender;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.graphics.drawable.Drawable;\nimport android.os.Bundle;\nimport android.os.RemoteCallback;\nimport android.os.UserHandle;\nimport android.text.Html;\nimport android.text.Spanned;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.ImageView;\nimport android.widget.TextView;\n\nimport androidx.annotation.NonNull;\nimport androidx.preference.Preference;\nimport androidx.preference.PreferenceCategory;\nimport androidx.preference.PreferenceFragmentCompat;\nimport androidx.preference.PreferenceGroup;\nimport androidx.preference.PreferenceScreen;\n\nimport com.android.permissioncontroller.PermissionControllerStatsLog;\nimport com.android.permissioncontroller.R;\nimport com.android.permissioncontroller.permission.model.AppPermissionGroup;\nimport com.android.permissioncontroller.permission.model.AppPermissions;\nimport com.android.permissioncontroller.permission.model.Permission;\nimport com.android.permissioncontroller.permission.ui.ManagePermissionsActivity;\nimport com.android.permissioncontroller.permission.utils.ArrayUtils;\nimport com.android.permissioncontroller.permission.utils.Utils;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\n/**\n * If an app does not support runtime permissions the user is prompted via this fragment to select\n * which permissions to grant to the app before first use and if an update changed the permissions.\n */\npublic final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n        implements View.OnClickListener, PermissionPreference.PermissionPreferenceChangeListener,\n        PermissionPreference.PermissionPreferenceOwnerFragment {\n\n    private static final String EXTRA_PACKAGE_INFO =\n            \"com.android.permissioncontroller.permission.ui.extra.PACKAGE_INFO\";\n    private static final String LOG_TAG = ReviewPermissionsFragment.class.getSimpleName();\n\n    private AppPermissions mAppPermissions;\n\n    private Button mContinueButton;\n    private Button mCancelButton;\n    private Button mMoreInfoButton;\n\n    private PreferenceCategory mNewPermissionsCategory;\n    private PreferenceCategory mCurrentPermissionsCategory;\n\n    private boolean mHasConfirmedRevoke;\n\n    /**\n     * @return a new fragment\n     */\n    public static ReviewPermissionsFragment newInstance(PackageInfo packageInfo) {\n        Bundle arguments = new Bundle();\n        arguments.putParcelable(EXTRA_PACKAGE_INFO, packageInfo);\n        ReviewPermissionsFragment instance = new ReviewPermissionsFragment();\n        instance.setArguments(arguments);\n        instance.setRetainInstance(true);\n        return instance;\n    }\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n\n        PackageInfo packageInfo = getArguments().getParcelable(EXTRA_PACKAGE_INFO);\n        if (packageInfo == null) {\n            activity.finishAfterTransition();\n            return;\n        }\n\n        mAppPermissions = new AppPermissions(activity, packageInfo, false, true,\n                () -> getActivity().finishAfterTransition());\n\n        boolean reviewRequired = false;\n        for (AppPermissionGroup group : mAppPermissions.getPermissionGroups()) {\n            if (group.isReviewRequired() || (group.getBackgroundPermissions() != null\n                    && group.getBackgroundPermissions().isReviewRequired())) {\n                reviewRequired = true;\n                break;\n            }\n        }\n\n        if (!reviewRequired) {\n            // If the system called for a review but no groups are found, this means that all groups\n            // are restricted. Hence there is nothing to review and instantly continue.\n            confirmPermissionsReview();\n            executeCallback(true);\n            activity.finishAfterTransition();\n        }\n    }\n\n    @Override\n    public void onCreatePreferences(Bundle bundle, String s) {\n        // empty\n    }\n\n    @Override\n    public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {\n        super.onViewCreated(view, savedInstanceState);\n        bindUi();\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        mAppPermissions.refresh();\n        loadPreferences();\n    }\n\n    @Override\n    public void onClick(View view) {\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n        if (view == mContinueButton) {\n            confirmPermissionsReview();\n            executeCallback(true);\n        } else if (view == mCancelButton) {\n            executeCallback(false);\n            activity.setResult(Activity.RESULT_CANCELED);\n        } else if (view == mMoreInfoButton) {\n            Intent intent = new Intent(Intent.ACTION_MANAGE_APP_PERMISSIONS);\n            intent.putExtra(Intent.EXTRA_PACKAGE_NAME,\n                    mAppPermissions.getPackageInfo().packageName);\n            intent.putExtra(Intent.EXTRA_USER, UserHandle.getUserHandleForUid(\n                    mAppPermissions.getPackageInfo().applicationInfo.uid));\n            intent.putExtra(ManagePermissionsActivity.EXTRA_ALL_PERMISSIONS, true);\n            getActivity().startActivity(intent);\n        }\n        activity.finishAfterTransition();\n    }\n\n    private void grantReviewedPermission(AppPermissionGroup group) {\n        String[] permissionsToGrant = null;\n        final int permissionCount = group.getPermissions().size();\n        for (int j = 0; j < permissionCount; j++) {\n            final Permission permission = group.getPermissions().get(j);\n            if (permission.isReviewRequired()) {\n                permissionsToGrant = ArrayUtils.appendString(\n                        permissionsToGrant, permission.getName());\n            }\n        }\n        if (permissionsToGrant != null) {\n            group.grantRuntimePermissions(true, false, permissionsToGrant);\n        }\n    }\n\n    private void confirmPermissionsReview() {\n        final List<PreferenceGroup> preferenceGroups = new ArrayList<>();\n        if (mNewPermissionsCategory != null) {\n            preferenceGroups.add(mNewPermissionsCategory);\n            preferenceGroups.add(mCurrentPermissionsCategory);\n        } else {\n            PreferenceScreen preferenceScreen = getPreferenceScreen();\n            if (preferenceScreen != null) {\n                preferenceGroups.add(preferenceScreen);\n            }\n        }\n\n        final int preferenceGroupCount = preferenceGroups.size();\n        long changeIdForLogging = new Random().nextLong();\n\n        for (int groupNum = 0; groupNum < preferenceGroupCount; groupNum++) {\n            final PreferenceGroup preferenceGroup = preferenceGroups.get(groupNum);\n\n            final int preferenceCount = preferenceGroup.getPreferenceCount();\n            for (int prefNum = 0; prefNum < preferenceCount; prefNum++) {\n                Preference preference = preferenceGroup.getPreference(prefNum);\n                if (preference instanceof PermissionReviewPreference) {\n                    PermissionReviewPreference permPreference =\n                            (PermissionReviewPreference) preference;\n                    AppPermissionGroup group = permPreference.getGroup();\n\n                    // If the preference wasn't toggled we show it as \"granted\"\n                    if (group.isReviewRequired() && !permPreference.wasChanged()) {\n                        grantReviewedPermission(group);\n                    }\n                    logReviewPermissionsFragmentResult(changeIdForLogging, group);\n\n                    AppPermissionGroup backgroundGroup = group.getBackgroundPermissions();\n                    if (backgroundGroup != null) {\n                        // If the preference wasn't toggled we show it as \"fully granted\"\n                        if (backgroundGroup.isReviewRequired() && !permPreference.wasChanged()) {\n                            grantReviewedPermission(backgroundGroup);\n                        }\n                        logReviewPermissionsFragmentResult(changeIdForLogging, backgroundGroup);\n                    }\n                }\n            }\n        }\n        mAppPermissions.persistChanges(true);\n\n        // Some permission might be restricted and hence there is no AppPermissionGroup for it.\n        // Manually unset all review-required flags, regardless of restriction.\n        PackageManager pm = getContext().getPackageManager();\n        PackageInfo pkg = mAppPermissions.getPackageInfo();\n        UserHandle user = UserHandle.getUserHandleForUid(pkg.applicationInfo.uid);\n\n        for (String perm : pkg.requestedPermissions) {\n            try {\n                pm.updatePermissionFlags(perm, pkg.packageName, FLAG_PERMISSION_REVIEW_REQUIRED,\n                        0, user);\n            } catch (IllegalArgumentException e) {\n                Log.e(LOG_TAG, \"Cannot unmark \" + perm + \" requested by \" + pkg.packageName\n                        + \" as review required\", e);\n            }\n        }\n    }\n\n    private void logReviewPermissionsFragmentResult(long changeId, AppPermissionGroup group) {\n        ArrayList<Permission> permissions = group.getPermissions();\n\n        int numPermissions = permissions.size();\n        for (int i = 0; i < numPermissions; i++) {\n            Permission permission = permissions.get(i);\n\n            PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                    changeId, group.getApp().applicationInfo.uid, group.getApp().packageName,\n                    permission.getName(), permission.isGrantedIncludingAppOp());\n            Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                    + group.getApp().applicationInfo.uid + \" packageName=\"\n                    + group.getApp().packageName + \" permission=\"\n                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n        }\n    }\n\n    private void bindUi() {\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n\n        // Set icon\n        Drawable icon = mAppPermissions.getPackageInfo().applicationInfo.loadIcon(\n                activity.getPackageManager());\n        ImageView iconView = activity.requireViewById(R.id.app_icon);\n        iconView.setImageDrawable(icon);\n\n        // Set message\n        final int labelTemplateResId = isPackageUpdated()\n                ? R.string.permission_review_title_template_update\n                : R.string.permission_review_title_template_install;\n        Spanned message = Html.fromHtml(getString(labelTemplateResId,\n                mAppPermissions.getAppLabel()), 0);\n\n        // Set the permission message as the title so it can be announced.\n        activity.setTitle(message.toString());\n\n        // Color the app name.\n        TextView permissionsMessageView = activity.requireViewById(\n                R.id.permissions_message);\n        permissionsMessageView.setText(message);\n\n        mContinueButton = getActivity().requireViewById(R.id.continue_button);\n        mContinueButton.setOnClickListener(this);\n\n        mCancelButton = getActivity().requireViewById(R.id.cancel_button);\n        mCancelButton.setOnClickListener(this);\n\n        if (activity.getPackageManager().arePermissionsIndividuallyControlled()) {\n            mMoreInfoButton = getActivity().requireViewById(\n                    R.id.permission_more_info_button);\n            mMoreInfoButton.setOnClickListener(this);\n            mMoreInfoButton.setVisibility(View.VISIBLE);\n        }\n    }\n\n    private PermissionReviewPreference getPreference(String key) {\n        if (mNewPermissionsCategory != null) {\n            PermissionReviewPreference pref =\n                    (PermissionReviewPreference) mNewPermissionsCategory.findPreference(key);\n\n            if (pref == null && mCurrentPermissionsCategory != null) {\n                return (PermissionReviewPreference) mCurrentPermissionsCategory.findPreference(key);\n            } else {\n                return pref;\n            }\n        } else {\n            return (PermissionReviewPreference) getPreferenceScreen().findPreference(key);\n        }\n    }\n\n    private void loadPreferences() {\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n\n        PreferenceScreen screen = getPreferenceScreen();\n        if (screen == null) {\n            screen = getPreferenceManager().createPreferenceScreen(getContext());\n            setPreferenceScreen(screen);\n        } else {\n            screen.removeAll();\n        }\n\n        mCurrentPermissionsCategory = null;\n        mNewPermissionsCategory = null;\n\n        final boolean isPackageUpdated = isPackageUpdated();\n\n        for (AppPermissionGroup group : mAppPermissions.getPermissionGroups()) {\n            if (!Utils.shouldShowPermission(getContext(), group)\n                    || !Utils.OS_PKG.equals(group.getDeclaringPackage())) {\n                continue;\n            }\n\n            PermissionReviewPreference preference = getPreference(group.getName());\n            if (preference == null) {\n                preference = new PermissionReviewPreference(this, group, this);\n\n                preference.setKey(group.getName());\n                Drawable icon = Utils.loadDrawable(activity.getPackageManager(),\n                        group.getIconPkg(), group.getIconResId());\n                preference.setIcon(Utils.applyTint(getContext(), icon,\n                        android.R.attr.colorControlNormal));\n                preference.setTitle(group.getLabel());\n            } else {\n                preference.updateUi();\n            }\n\n            if (group.isReviewRequired() || (group.getBackgroundPermissions() != null\n                    && group.getBackgroundPermissions().isReviewRequired())) {\n                if (!isPackageUpdated) {\n                    screen.addPreference(preference);\n                } else {\n                    if (mNewPermissionsCategory == null) {\n                        mNewPermissionsCategory = new PreferenceCategory(activity);\n                        mNewPermissionsCategory.setTitle(R.string.new_permissions_category);\n                        mNewPermissionsCategory.setOrder(1);\n                        screen.addPreference(mNewPermissionsCategory);\n                    }\n                    mNewPermissionsCategory.addPreference(preference);\n                }\n            } else {\n                if (mCurrentPermissionsCategory == null) {\n                    mCurrentPermissionsCategory = new PreferenceCategory(activity);\n                    mCurrentPermissionsCategory.setTitle(R.string.current_permissions_category);\n                    mCurrentPermissionsCategory.setOrder(2);\n                    screen.addPreference(mCurrentPermissionsCategory);\n                }\n                mCurrentPermissionsCategory.addPreference(preference);\n            }\n        }\n    }\n\n    private boolean isPackageUpdated() {\n        List<AppPermissionGroup> groups = mAppPermissions.getPermissionGroups();\n        final int groupCount = groups.size();\n        for (int i = 0; i < groupCount; i++) {\n            AppPermissionGroup group = groups.get(i);\n            if (!(group.isReviewRequired() || (group.getBackgroundPermissions() != null\n                    && group.getBackgroundPermissions().isReviewRequired()))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void executeCallback(boolean success) {\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n        if (success) {\n            IntentSender intent = activity.getIntent().getParcelableExtra(Intent.EXTRA_INTENT);\n            if (intent != null) {\n                try {\n                    int flagMask = 0;\n                    int flagValues = 0;\n                    if (activity.getIntent().getBooleanExtra(\n                            Intent.EXTRA_RESULT_NEEDED, false)) {\n                        flagMask = Intent.FLAG_ACTIVITY_FORWARD_RESULT;\n                        flagValues = Intent.FLAG_ACTIVITY_FORWARD_RESULT;\n                    }\n                    activity.startIntentSenderForResult(intent, -1, null,\n                            flagMask, flagValues, 0);\n                } catch (IntentSender.SendIntentException e) {\n                        /* ignore */\n                }\n                return;\n            }\n        }\n        RemoteCallback callback = activity.getIntent().getParcelableExtra(\n                Intent.EXTRA_REMOTE_CALLBACK);\n        if (callback != null) {\n            Bundle result = new Bundle();\n            result.putBoolean(Intent.EXTRA_RETURN_RESULT, success);\n            callback.sendResult(result);\n        }\n    }\n\n    @Override\n    public boolean shouldConfirmDefaultPermissionRevoke() {\n        return !mHasConfirmedRevoke;\n    }\n\n    @Override\n    public void hasConfirmDefaultPermissionRevoke() {\n        mHasConfirmedRevoke = true;\n    }\n\n    @Override\n    public void onPreferenceChanged(String key) {\n        getPreference(key).setChanged();\n    }\n\n    @Override\n    public void onDenyAnyWay(String key, int changeTarget) {\n        getPreference(key).onDenyAnyWay(changeTarget);\n    }\n\n    @Override\n    public void onBackgroundAccessChosen(String key, int chosenItem) {\n        getPreference(key).onBackgroundAccessChosen(chosenItem);\n    }\n\n    /**\n     * Extend the {@link PermissionPreference}:\n     * <ul>\n     *     <li>Show the description of the permission group</li>\n     *     <li>Show the permission group as granted if the user has not toggled it yet. This means\n     *     that if the user does not touch the preference, we will later grant the permission\n     *     in {@link #confirmPermissionsReview()}.</li>\n     * </ul>\n     */\n    private static class PermissionReviewPreference extends PermissionPreference {\n        private final AppPermissionGroup mGroup;\n        private boolean mWasChanged;\n\n        PermissionReviewPreference(PreferenceFragmentCompat fragment, AppPermissionGroup group,\n                PermissionPreferenceChangeListener callbacks) {\n            super(fragment, group, callbacks);\n\n            mGroup = group;\n            updateUi();\n        }\n\n        AppPermissionGroup getGroup() {\n            return mGroup;\n        }\n\n        /**\n         * Mark the permission as changed by the user\n         */\n        void setChanged() {\n            mWasChanged = true;\n            updateUi();\n        }\n\n        /**\n         * @return {@code true} iff the permission was changed by the user\n         */\n        boolean wasChanged() {\n            return mWasChanged;\n        }\n\n        @Override\n        void updateUi() {\n            // updateUi might be called in super-constructor before group is initialized\n            if (mGroup == null) {\n                return;\n            }\n\n            super.updateUi();\n\n            if (isEnabled()) {\n                if (mGroup.isReviewRequired() && !mWasChanged) {\n                    setSummary(mGroup.getDescription());\n                    setCheckedOverride(true);\n                } else if (TextUtils.isEmpty(getSummary())) {\n                    // Sometimes the summary is already used, e.g. when this for a\n                    // foreground/background group. In this case show leave the original summary.\n                    setSummary(mGroup.getDescription());\n                }\n            }\n        }\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 3612,
                                        "general": {
                                            "word_based": 1531,
                                            "char_based": 5161
                                        },
                                        "gemini": 4423
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "2bf7a6ef16585b120dfeee6e4f701be62525ee12",
                            "repo_path": "android_repos/Permission",
                            "result": "failure",
                            "downstream_patch_content": "commit 2bf7a6ef16585b120dfeee6e4f701be62525ee12\nAuthor: Yi-an Chen <theianchen@google.com>\nDate:   Thu Aug 8 01:15:57 2024 +0000\n\n    RESTRICT AUTOMERGE Fix Dynamic Permission group auto grant behaivor\n    \n    Fix the Dynamic Permission group auto grant behaivor so that a\n    permission group is only considered granted when (1) all permissions\n    were auto-granted or (2) a platform permission in the same group is\n    granted.\n    \n    Bug: 340480881\n    Test: DynamicPermissionsTest\n    Change-Id: I37b550f0c3933bc790c2917a14e917efbcccc4e8\n    Merged-In: I37b550f0c3933bc790c2917a14e917efbcccc4e8\n\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt b/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\nindex 97389b0984..bf43f15c3f 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\n@@ -66,7 +66,7 @@ class LightPermInfoLiveData private constructor(\n         }\n \n         val newValue = try {\n-            LightPermInfo(app.packageManager.getPermissionInfo(permissionName, 0))\n+            LightPermInfo(app.packageManager.getPermissionInfo(permissionName, 0), null)\n         } catch (e: PackageManager.NameNotFoundException) {\n             Log.w(LOG_TAG, \"Permission \\\"$permissionName\\\" not found\")\n             invalidateSingle(permissionName)\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt b/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\nindex 78f2f72c63..948815646a 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\n@@ -17,6 +17,7 @@\n package com.android.permissioncontroller.permission.data\n \n import android.app.Application\n+import android.content.pm.ApplicationInfo\n import android.content.pm.PackageItemInfo\n import android.content.pm.PackageManager\n import android.content.pm.PermissionGroupInfo\n@@ -68,32 +69,31 @@ class PermGroupLiveData private constructor(\n      */\n     override fun onUpdate() {\n         val permissionInfos = mutableMapOf<String, LightPermInfo>()\n-\n         groupInfo = Utils.getGroupInfo(groupName, context) ?: run {\n             Log.e(LOG_TAG, \"Invalid permission group $groupName\")\n             invalidateSingle(groupName)\n             value = null\n             return\n         }\n-\n+        val permInfos = mutableListOf<PermissionInfo>()\n         when (groupInfo) {\n             is PermissionGroupInfo -> {\n-                val permInfos = try {\n-                    Utils.getInstalledRuntimePermissionInfosForGroup(context.packageManager,\n-                        groupName)\n+                try {\n+                    permInfos.addAll(\n+                        Utils.getInstalledRuntimePermissionInfosForGroup(\n+                            context.packageManager,\n+                            groupName\n+                        )\n+                    )\n                 } catch (e: PackageManager.NameNotFoundException) {\n                     Log.e(LOG_TAG, \"Invalid permission group $groupName\")\n                     invalidateSingle(groupName)\n                     value = null\n                     return\n                 }\n-\n-                for (permInfo in permInfos) {\n-                    permissionInfos[permInfo.name] = LightPermInfo(permInfo)\n-                }\n             }\n             is PermissionInfo -> {\n-                permissionInfos[groupInfo.name] = LightPermInfo(groupInfo as PermissionInfo)\n+                permInfos.add(groupInfo as PermissionInfo)\n             }\n             else -> {\n                 value = null\n@@ -101,19 +101,25 @@ class PermGroupLiveData private constructor(\n             }\n         }\n \n-        val permGroup = PermGroup(LightPermGroupInfo(groupInfo), permissionInfos)\n-\n-        value = permGroup\n-\n-        val packageNames = permissionInfos.values.map { permInfo -> permInfo.packageName }\n-            .toMutableSet()\n+        val packageNames = permInfos.map { permInfo -> permInfo.packageName }.toMutableSet()\n         packageNames.add(groupInfo.packageName)\n-\n         // TODO ntmyren: What if the package isn't installed for the system user?\n         val getLiveData = { packageName: String ->\n             LightPackageInfoLiveData[packageName, UserHandle.SYSTEM]\n         }\n         setSourcesToDifference(packageNames, packageLiveDatas, getLiveData)\n+        if (!packageLiveDatas.all { it.value.isInitialized }) {\n+            return\n+        }\n+        for (permInfo in permInfos) {\n+            val lightPackageInfo = packageLiveDatas[permInfo.packageName]?.value\n+            val isSystem =\n+                lightPackageInfo?.let { it.appFlags and ApplicationInfo.FLAG_SYSTEM != 0 }\n+            permissionInfos[permInfo.name] = LightPermInfo(permInfo, isSystem)\n+        }\n+\n+        val permGroup = PermGroup(LightPermGroupInfo(groupInfo), permissionInfos)\n+        value = permGroup\n     }\n \n     override fun onInactive() {\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\nindex cbfac4b244..1d807292ad 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\n@@ -20,6 +20,7 @@ import android.Manifest\n import android.Manifest.permission.ACCESS_COARSE_LOCATION\n import android.os.Build\n import android.os.UserHandle\n+import com.android.permissioncontroller.permission.utils.Utils\n \n /**\n  * A lightweight version of the AppPermissionGroup data structure. Represents information about a\n@@ -79,11 +80,13 @@ data class LightAppPermGroup(\n         if (name !in backgroundPermNames) name else null\n     }\n \n+    val isPlatformPermissionGroup = permGroupInfo.packageName == Utils.OS_PKG\n+\n     val foreground = AppPermSubGroup(permissions.filter { it.key in foregroundPermNames },\n-        packageInfo, specialLocationGrant)\n+        packageInfo, isPlatformPermissionGroup, specialLocationGrant)\n \n     val background = AppPermSubGroup(permissions.filter { it.key in backgroundPermNames },\n-        packageInfo, specialLocationGrant)\n+        packageInfo, isPlatformPermissionGroup, specialLocationGrant)\n \n     /**\n      * Whether or not this App Permission Group has a permission which has a background mode\n@@ -152,24 +155,34 @@ data class LightAppPermGroup(\n      *\n      * @param permissions The permissions contained within this subgroup, a subset of those contained\n      * in the full group\n+     * @param isPlatformPermissionGroup Whether this is a platform permission group\n      * @param specialLocationGrant Whether this is a special location package\n      */\n     data class AppPermSubGroup internal constructor(\n         private val permissions: Map<String, LightPermission>,\n         private val packageInfo: LightPackageInfo,\n+        private val isPlatformPermissionGroup: Boolean,\n         private val specialLocationGrant: Boolean?\n     ) {\n-        /**\n-         * Whether any of this App Permission SubGroup's permissions are granted\n-         */\n-        val isGranted = specialLocationGrant ?: permissions.any { it.value.isGrantedIncludingAppOp }\n+        /** Whether any of this App Permission SubGroup's permissions are granted */\n+        val isGranted =\n+            specialLocationGrant\n+                ?: permissions.any {\n+                    val mayGrantByPlatformOrSystem =\n+                        !isPlatformPermissionGroup || it.value.isPlatformOrSystem\n+                    it.value.isGranted && mayGrantByPlatformOrSystem\n+                }\n \n         /**\n          * Whether any of this App Permission SubGroup's permissions are granted excluding\n          * auto granted permissions during install time with flag RevokeWhenRequested\n          */\n-        val isGrantedExcludeRevokeWhenRequestedPermissions = specialLocationGrant ?: permissions\n-            .any { it.value.isGrantedIncludingAppOp && !it.value.isRevokeWhenRequested }\n+        val allowFullGroupGrant = specialLocationGrant ?: permissions\n+            .any {\n+                val mayGrantByPlatformOrSystem =\n+                        !isPlatformPermissionGroup || it.value.isPlatformOrSystem\n+                it.value.allowFullGroupGrant && mayGrantByPlatformOrSystem\n+            }\n \n         /**\n          * Whether any of this App Permission SubGroup's permissions are granted by default\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\nindex 182de1a597..a37a47163f 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\n@@ -49,7 +49,9 @@ data class LightPackageInfo(\n     val firstInstallTime: Long\n ) {\n     constructor(pI: PackageInfo) : this(pI.packageName,\n-        pI.permissions?.map { perm -> LightPermInfo(perm) } ?: emptyList(),\n+        pI.permissions?.map { perm ->\n+            LightPermInfo(perm, pI.applicationInfo!!.flags and ApplicationInfo.FLAG_SYSTEM != 0)\n+        } ?: emptyList(),\n         pI.requestedPermissions?.toList() ?: emptyList(),\n         pI.requestedPermissionsFlags?.toList() ?: emptyList(),\n         pI.applicationInfo.uid, pI.applicationInfo.targetSdkVersion,\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\nindex 3954b74722..582742da43 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\n@@ -30,6 +30,7 @@ import android.content.pm.PermissionInfo\n  * @param protection The protection level of this permission\n  * @param protection Extra information about the protection of this permission\n  * @param flags The system flags of this permission\n+ * @param isSystem Whether this permission is defined by a system app\n  */\n data class LightPermInfo(\n     val name: String,\n@@ -38,11 +39,13 @@ data class LightPermInfo(\n     val backgroundPermission: String?,\n     val protection: Int,\n     val protectionFlags: Int,\n-    val flags: Int\n+    val flags: Int,\n+    val isSystem: Boolean?\n ) {\n-    constructor (permInfo: PermissionInfo): this(permInfo.name, permInfo.packageName,\n-        permInfo.group, permInfo.backgroundPermission, permInfo.protection,\n-        permInfo.protectionFlags, permInfo.flags)\n+    constructor (permInfo: PermissionInfo, isSystem: Boolean?) : this(\n+        permInfo.name, permInfo.packageName, permInfo.group, permInfo.backgroundPermission,\n+        permInfo.protection, permInfo.protectionFlags, permInfo.flags, isSystem\n+    )\n \n     /**\n      * Gets the PermissionInfo for this permission from the system.\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\nindex c3d087fd24..45c3b1e92a 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\n@@ -27,7 +27,7 @@ import com.android.permissioncontroller.permission.utils.Utils.isRuntimePlatform\n  *\n  * @param pkgInfo The package requesting the permission\n  * @param permInfo The permissionInfo this represents\n- * @param isGrantedIncludingAppOp Whether or not this permission is functionally granted.\n+ * @param isGranted Whether or not this permission is functionally granted.\n  * A non-granted app op but granted permission is counted as not granted\n  * @param flags The PermissionController flags for this permission\n  * @param foregroundPerms The foreground permission names corresponding to this permission, if this\n@@ -36,7 +36,7 @@ import com.android.permissioncontroller.permission.utils.Utils.isRuntimePlatform\n data class LightPermission(\n     val pkgInfo: LightPackageInfo,\n     val permInfo: LightPermInfo,\n-    val isGrantedIncludingAppOp: Boolean,\n+    val isGranted: Boolean,\n     val flags: Int,\n     val foregroundPerms: List<String>?\n ) {\n@@ -82,9 +82,9 @@ data class LightPermission(\n     val isRevokeWhenRequested = flags and PackageManager.FLAG_PERMISSION_REVOKE_WHEN_REQUESTED != 0\n     /** Whether this permission is user sensitive in its current grant state */\n     val isUserSensitive = !isRuntimePlatformPermission(permInfo.name) ||\n-            (isGrantedIncludingAppOp &&\n+            (isGranted &&\n                     (flags and PackageManager.FLAG_PERMISSION_USER_SENSITIVE_WHEN_GRANTED) != 0) ||\n-            (!isGrantedIncludingAppOp &&\n+            (!isGranted &&\n                     (flags and PackageManager.FLAG_PERMISSION_USER_SENSITIVE_WHEN_DENIED) != 0)\n     /** Whether the permission is restricted */\n     val isRestricted = when {\n@@ -105,10 +105,17 @@ data class LightPermission(\n      */\n     val isSelectedLocationAccuracy =\n         flags and PackageManager.FLAG_PERMISSION_SELECTED_LOCATION_ACCURACY != 0\n+    /** Whether this permission is defined by platform or a system app */\n+    val isPlatformOrSystem = permInfo.packageName == Utils.OS_PKG || permInfo.isSystem == true\n+    /**\n+     * Whether this permission is granted including app op and does not hold the\n+     * PackageManager.FLAG_PERMISSION_REVOKE_WHEN_REQUESTED flag.\n+     */\n+    val allowFullGroupGrant = isGranted && !isRevokeWhenRequested\n \n     override fun toString() = buildString {\n         append(name)\n-        if (isGrantedIncludingAppOp) append(\", Granted\") else append(\", NotGranted\")\n+        if (isGranted) append(\", Granted\") else append(\", NotGranted\")\n         if (isPolicyFixed) append(\", PolicyFixed\")\n         if (isSystemFixed) append(\", SystemFixed\")\n         if (isUserFixed) append(\", UserFixed\")\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt b/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\nindex d57e797519..92bfa887e8 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\n@@ -93,7 +93,7 @@ suspend fun revokeAppPermissions(\n \n                 val fixed = group.isBackgroundFixed || group.isForegroundFixed\n                 val granted = group.permissions.any { (_, perm) ->\n-                    perm.isGrantedIncludingAppOp && perm.name !in EXEMPT_PERMISSIONS\n+                    perm.isGranted && perm.name !in EXEMPT_PERMISSIONS\n                 }\n                 if (!fixed &&\n                     granted &&\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt b/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\nindex c22e5dd422..6369eeada3 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\n@@ -382,7 +382,7 @@ internal object RuntimePermissionsUpgradeController {\n \n                 val allPermissionsWithxemption = bgApp.allPermissions.toMutableMap()\n                 allPermissionsWithxemption[permission.ACCESS_BACKGROUND_LOCATION] =\n-                        LightPermission(perm.pkgInfo, perm.permInfo, perm.isGrantedIncludingAppOp,\n+                        LightPermission(perm.pkgInfo, perm.permInfo, perm.isGranted,\n                         perm.flags or FLAG_PERMISSION_RESTRICTION_UPGRADE_EXEMPT,\n                         perm.foregroundPerms)\n \n@@ -444,7 +444,7 @@ internal object RuntimePermissionsUpgradeController {\n                             ?: continue\n \n                     if (!perm.isUserSet && !perm.isSystemFixed && !perm.isPolicyFixed &&\n-                            !perm.isGrantedIncludingAppOp) {\n+                            !perm.isGranted) {\n                         grants.add(Grant(false, appPermGroup,\n                                 listOf(permission.ACCESS_MEDIA_LOCATION)))\n                     }\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\nindex 05c5849f06..244fdd2bb2 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\n@@ -698,7 +698,7 @@ class AppPermissionViewModel(\n \n     private fun getIndividualPermissionDetailResId(group: LightAppPermGroup): Pair<Int, Int> {\n         return when (val numRevoked =\n-            group.permissions.filter { !it.value.isGrantedIncludingAppOp }.size) {\n+            group.permissions.filter { !it.value.isGranted }.size) {\n             0 -> R.string.permission_revoked_none to numRevoked\n             group.permissions.size -> R.string.permission_revoked_all to numRevoked\n             else -> R.string.permission_revoked_count to numRevoked\n@@ -767,7 +767,7 @@ class AppPermissionViewModel(\n         for ((permName, permission) in oldGroup.permissions) {\n             val newPermission = newGroup.permissions[permName] ?: continue\n \n-            if (permission.isGrantedIncludingAppOp != newPermission.isGrantedIncludingAppOp ||\n+            if (permission.isGranted != newPermission.isGranted ||\n                 permission.flags != newPermission.flags) {\n                 logAppPermissionFragmentActionReported(changeId, newPermission, buttonPressed)\n             }\n@@ -782,10 +782,10 @@ class AppPermissionViewModel(\n         val uid = KotlinUtils.getPackageUid(app, packageName, user) ?: return\n         PermissionControllerStatsLog.write(APP_PERMISSION_FRAGMENT_ACTION_REPORTED, sessionId,\n             changeId, uid, packageName, permission.permInfo.name,\n-            permission.isGrantedIncludingAppOp, permission.flags, buttonPressed)\n+            permission.isGranted, permission.flags, buttonPressed)\n         Log.v(LOG_TAG, \"Permission changed via UI with sessionId=$sessionId changeId=\" +\n             \"$changeId uid=$uid packageName=$packageName permission=\" + permission.permInfo.name +\n-            \" isGranted=\" + permission.isGrantedIncludingAppOp + \" permissionFlags=\" +\n+            \" isGranted=\" + permission.isGranted + \" permissionFlags=\" +\n             permission.flags + \" buttonPressed=$buttonPressed\")\n     }\n \ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\nindex 00c45a063b..4ab26a9aef 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\n@@ -237,7 +237,7 @@ class GrantPermissionsViewModel(\n                     // some requests might have been granted, check for that\n                     for ((key, state) in states) {\n                         val allAffectedGranted = state.affectedPermissions.all { perm ->\n-                            appPermGroup.permissions[perm]?.isGrantedIncludingAppOp == true &&\n+                            appPermGroup.permissions[perm]?.isGranted == true &&\n                                 appPermGroup.permissions[perm]?.isRevokeWhenRequested == false\n                         }\n                         if (allAffectedGranted) {\n@@ -275,7 +275,7 @@ class GrantPermissionsViewModel(\n                 if (fgState?.group != null) {\n                     val fgGroup = fgState.group\n                     for (perm in fgState.affectedPermissions) {\n-                        if (fgGroup.permissions[perm]?.isGrantedIncludingAppOp == false) {\n+                        if (fgGroup.permissions[perm]?.isGranted == false) {\n                             // If any of the requested permissions is not granted,\n                             // needFgPermissions = true\n                             needFgPermissions = true\n@@ -426,7 +426,7 @@ class GrantPermissionsViewModel(\n                                 fgState.affectedPermissions.contains(ACCESS_FINE_LOCATION)) {\n                             val coarseLocationPerm =\n                                 groupState.group.allPermissions[ACCESS_COARSE_LOCATION]\n-                            if (coarseLocationPerm?.isGrantedIncludingAppOp == true) {\n+                            if (coarseLocationPerm?.isGranted == true) {\n                                 // Upgrade flow\n                                 locationVisibilities[DIALOG_WITH_FINE_LOCATION_ONLY] = true\n                                 message = RequestMessage.FG_FINE_LOCATION_MESSAGE\n@@ -655,7 +655,7 @@ class GrantPermissionsViewModel(\n \n         // Do not attempt to grant background access if foreground access is not either already\n         // granted or requested\n-        if (isBackground && !group.foreground.isGrantedExcludeRevokeWhenRequestedPermissions &&\n+        if (isBackground && !group.foreground.allowFullGroupGrant &&\n             !hasForegroundRequest) {\n             Log.w(LOG_TAG, \"Cannot grant $perm as the matching foreground permission is not \" +\n                 \"already granted.\")\n@@ -667,21 +667,22 @@ class GrantPermissionsViewModel(\n             return STATE_SKIPPED\n         }\n \n-        if (isBackground && group.background.isGrantedExcludeRevokeWhenRequestedPermissions ||\n-            !isBackground && group.foreground.isGrantedExcludeRevokeWhenRequestedPermissions) {\n+        if (isBackground && group.background.allowFullGroupGrant ||\n+            !isBackground && group.foreground.allowFullGroupGrant) {\n             // If FINE location is not granted, do not grant it automatically when COARSE\n             // location is already granted.\n             if (group.permGroupName == LOCATION &&\n-                    group.allPermissions[ACCESS_FINE_LOCATION]?.isGrantedIncludingAppOp\n+                    group.allPermissions[ACCESS_FINE_LOCATION]?.isGranted\n                     == false) {\n                 return STATE_UNKNOWN\n             }\n \n-            if (group.permissions[perm]?.isGrantedIncludingAppOp == false) {\n+            if (group.permissions[perm]?.isGranted == false) {\n                 if (isBackground) {\n                     KotlinUtils.grantBackgroundRuntimePermissions(app, group, listOf(perm))\n                 } else {\n-                    KotlinUtils.grantForegroundRuntimePermissions(app, group, listOf(perm), group.isOneTime)\n+                    KotlinUtils.grantForegroundRuntimePermissions(app, group, listOf(perm),\n+                            group.isOneTime)\n                 }\n                 KotlinUtils.setGroupFlags(app, group, FLAG_PERMISSION_USER_SET to false,\n                     FLAG_PERMISSION_USER_FIXED to false, filterPermissions = listOf(perm))\n@@ -852,28 +853,40 @@ class GrantPermissionsViewModel(\n             } else {\n                 PERMISSION_GRANT_REQUEST_RESULT_REPORTED__RESULT__USER_GRANTED\n             }\n+            var affectedPermissions: List<String> = groupState.affectedPermissions\n             if (groupState.isBackground) {\n                 KotlinUtils.grantBackgroundRuntimePermissions(app, groupState.group,\n-                    groupState.affectedPermissions)\n+                    affectedPermissions)\n             } else {\n                 if (affectedForegroundPermissions == null) {\n                     KotlinUtils.grantForegroundRuntimePermissions(app, groupState.group,\n-                        groupState.affectedPermissions, isOneTime)\n+                        affectedPermissions, isOneTime)\n                     // This prevents weird flag state when app targetSDK switches from S+ to R-\n                     if (groupState.affectedPermissions.contains(ACCESS_FINE_LOCATION)) {\n                         KotlinUtils.setFlagsWhenLocationAccuracyChanged(\n                                 app, groupState.group, true)\n                     }\n                 } else {\n+                    affectedPermissions = affectedForegroundPermissions\n                     val newGroup = KotlinUtils.grantForegroundRuntimePermissions(app,\n-                            groupState.group, affectedForegroundPermissions, isOneTime)\n+                            groupState.group, affectedPermissions, isOneTime)\n                     if (!isOneTime || newGroup.isOneTime) {\n                         KotlinUtils.setFlagsWhenLocationAccuracyChanged(app, newGroup,\n                                 affectedForegroundPermissions.contains(ACCESS_FINE_LOCATION))\n                     }\n                 }\n             }\n-            groupState.state = STATE_ALLOWED\n+            val shouldDenyFullGroupGrant =\n+                groupState.group.isPlatformPermissionGroup &&\n+                        affectedPermissions.none {\n+                            groupState.group.permissions[it]?.isPlatformOrSystem == true\n+                        }\n+            groupState.state =\n+                if (shouldDenyFullGroupGrant) {\n+                    STATE_UNKNOWN\n+                } else {\n+                    STATE_ALLOWED\n+                }\n         } else {\n             if (groupState.isBackground) {\n                 KotlinUtils.revokeBackgroundRuntimePermissions(app, groupState.group,\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt b/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\nindex da93d4f782..85908cb0ef 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\n@@ -440,7 +440,7 @@ object KotlinUtils {\n                     group.userHandle, *flags)\n             }\n             newPerms[permName] = LightPermission(group.packageInfo, perm.permInfo,\n-                perm.isGrantedIncludingAppOp, perm.flags or flagsToSet, perm.foregroundPerms)\n+                perm.isGranted, perm.flags or flagsToSet, perm.foregroundPerms)\n         }\n         return LightAppPermGroup(group.packageInfo, group.permGroupInfo, newPerms,\n             group.hasInstallToRuntimeSplit, group.specialLocationGrant)\n@@ -518,7 +518,7 @@ object KotlinUtils {\n         val newGroup = LightAppPermGroup(group.packageInfo, group.permGroupInfo, newPerms,\n             group.hasInstallToRuntimeSplit, group.specialLocationGrant)\n         // If any permission in the group is one time granted, start one time permission session.\n-        if (newGroup.permissions.any { it.value.isOneTime && it.value.isGrantedIncludingAppOp }) {\n+        if (newGroup.permissions.any { it.value.isOneTime && it.value.isGranted }) {\n             app.getSystemService(PermissionManager::class.java)!!.startOneTimePermissionSession(\n                 group.packageName, Utils.getOneTimePermissionsTimeout(),\n                 ONE_TIME_PACKAGE_IMPORTANCE_LEVEL_TO_RESET_TIMER,\n@@ -555,11 +555,11 @@ object KotlinUtils {\n         }\n \n         var newFlags = perm.flags\n-        var isGranted = perm.isGrantedIncludingAppOp\n+        var isGranted = perm.isGranted\n         var shouldKill = false\n \n         // Grant the permission if needed.\n-        if (!perm.isGrantedIncludingAppOp) {\n+        if (!perm.isGranted) {\n             val affectsAppOp = permissionToOp(perm.name) != null || perm.isBackgroundPermission\n \n             // TODO 195016052: investigate adding split permission handling\n@@ -602,14 +602,14 @@ object KotlinUtils {\n \n         // If we newly grant background access to the fine location, double-guess the user some\n         // time later if this was really the right choice.\n-        if (!perm.isGrantedIncludingAppOp && isGranted) {\n+        if (!perm.isGranted && isGranted) {\n             var triggerLocationAccessCheck = false\n             if (perm.name == ACCESS_FINE_LOCATION) {\n                 val bgPerm = group.permissions[perm.backgroundPermission]\n-                triggerLocationAccessCheck = bgPerm?.isGrantedIncludingAppOp == true\n+                triggerLocationAccessCheck = bgPerm?.isGranted == true\n             } else if (perm.name == ACCESS_BACKGROUND_LOCATION) {\n                 val fgPerm = group.permissions[ACCESS_FINE_LOCATION]\n-                triggerLocationAccessCheck = fgPerm?.isGrantedIncludingAppOp == true\n+                triggerLocationAccessCheck = fgPerm?.isGranted == true\n             }\n             if (triggerLocationAccessCheck) {\n                 // trigger location access check\n@@ -774,13 +774,13 @@ object KotlinUtils {\n \n         val user = UserHandle.getUserHandleForUid(group.packageInfo.uid)\n         var newFlags = perm.flags\n-        var isGranted = perm.isGrantedIncludingAppOp\n+        var isGranted = perm.isGranted\n         val supportsRuntime = group.packageInfo.targetSdkVersion >= Build.VERSION_CODES.M\n         var shouldKill = false\n \n         val affectsAppOp = permissionToOp(perm.name) != null || perm.isBackgroundPermission\n \n-        if (perm.isGrantedIncludingAppOp) {\n+        if (perm.isGranted) {\n             if (supportsRuntime && !isPermissionSplitFromNonRuntime(app, perm.name,\n                             group.packageInfo.targetSdkVersion)) {\n                 // Revoke the permission if needed.\n@@ -874,7 +874,7 @@ object KotlinUtils {\n                 val fgPerm = group.permissions[foregroundPermName]\n                 val appOpName = permissionToOp(foregroundPermName) ?: continue\n \n-                if (fgPerm != null && fgPerm.isGrantedIncludingAppOp) {\n+                if (fgPerm != null && fgPerm.isGranted) {\n                     wasChanged = wasChanged || setOpMode(appOpName, uid, packageName, MODE_ALLOWED,\n                         appOpsManager)\n                 }\n@@ -884,7 +884,7 @@ object KotlinUtils {\n             if (perm.backgroundPermission != null) {\n                 wasChanged = if (group.permissions.containsKey(perm.backgroundPermission)) {\n                     val bgPerm = group.permissions[perm.backgroundPermission]\n-                    val mode = if (bgPerm != null && bgPerm.isGrantedIncludingAppOp) MODE_ALLOWED\n+                    val mode = if (bgPerm != null && bgPerm.isGranted) MODE_ALLOWED\n                     else MODE_FOREGROUND\n \n                     setOpMode(appOpName, uid, packageName, mode, appOpsManager)\n@@ -935,7 +935,7 @@ object KotlinUtils {\n         if (perm.isBackgroundPermission && perm.foregroundPerms != null) {\n             for (foregroundPermName in perm.foregroundPerms) {\n                 val fgPerm = group.permissions[foregroundPermName]\n-                if (fgPerm != null && fgPerm.isGrantedIncludingAppOp) {\n+                if (fgPerm != null && fgPerm.isGranted) {\n                     val appOpName = permissionToOp(foregroundPermName) ?: return false\n                     wasChanged = wasChanged || setOpMode(appOpName, uid, packageName,\n                         MODE_FOREGROUND, appOpsManager)\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java b/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\nindex f0227cad54..96eccd0a8d 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\n@@ -162,7 +162,7 @@ public final class SafetyNetLogger {\n             }\n \n             builder.append(permission.getName()).append('|');\n-            builder.append(permission.isGrantedIncludingAppOp()).append('|');\n+            builder.append(permission.isGranted()).append('|');\n             builder.append(permission.getFlags());\n         }\n     }\ndiff --git a/PermissionController/tests/mocking/src/com/android/permissioncontroller/permission/utils/GrantRevokeTests.kt b/PermissionController/tests/mocking/src/com/android/permissioncontroller/permission/utils/GrantRevokeTests.kt\nindex 8f7494124e..496cca01cc 100644\n--- a/PermissionController/tests/mocking/src/com/android/permissioncontroller/permission/utils/GrantRevokeTests.kt\n+++ b/PermissionController/tests/mocking/src/com/android/permissioncontroller/permission/utils/GrantRevokeTests.kt\n@@ -24,6 +24,7 @@ import android.app.AppOpsManager.MODE_FOREGROUND\n import android.app.AppOpsManager.MODE_IGNORED\n import android.app.AppOpsManager.permissionToOp\n import android.app.Application\n+import android.content.pm.ApplicationInfo\n import android.content.pm.PackageManager\n import android.content.pm.PackageManager.FLAG_PERMISSION_AUTO_REVOKED\n import android.content.pm.PackageManager.FLAG_PERMISSION_ONE_TIME\n@@ -180,7 +181,8 @@ class GrantRevokeTests {\n         permInfoProtectionFlags: Int = 0\n     ): LightPermission {\n         val permInfo = LightPermInfo(permName, TEST_PACKAGE_NAME, PERM_GROUP_NAME, backgroundPerm,\n-            PermissionInfo.PROTECTION_DANGEROUS, permInfoProtectionFlags, 0)\n+            PermissionInfo.PROTECTION_DANGEROUS, permInfoProtectionFlags, 0,\n+                pkgInfo.appFlags and ApplicationInfo.FLAG_SYSTEM != 0)\n         return LightPermission(pkgInfo, permInfo,\n                 pkgInfo.requestedPermissionsFlags[pkgInfo.requestedPermissions.indexOf(permName)]\n                         == PERMISSION_GRANTED, flags, foregroundPerms)\n@@ -251,7 +253,7 @@ class GrantRevokeTests {\n             val flags = state.second\n \n             assertWithMessage(\"permission $permName grant state incorrect\")\n-                .that(perms[permName]?.isGrantedIncludingAppOp).isEqualTo(granted)\n+                .that(perms[permName]?.isGranted).isEqualTo(granted)\n \n             val actualFlags = perms[permName]!!.flags\n             assertWithMessage(\"permission $permName flags incorrect, expected\" +\n",
                            "downstream_patch_tokens": {
                                "openai": 7333,
                                "general": {
                                    "word_based": 2909,
                                    "char_based": 8789
                                },
                                "gemini": 8837
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java",
                                    "total_hunks": 1,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [],
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    },
                                    "rej_file_content": "```diff\n--- PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n+++ PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n@@ -267,11 +267,11 @@ public final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.i(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }\n```",
                                    "rej_file_tokens": {
                                        "openai": 203,
                                        "general": {
                                            "word_based": 77,
                                            "char_based": 289
                                        },
                                        "gemini": 250
                                    },
                                    "patch_apply_output": "patching file PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\nHunk #1 FAILED at 267.\n1 out of 1 hunk FAILED -- saving rejects to file PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java.rej\npatching file PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\nHunk #1 succeeded at 162 (offset 67 lines).",
                                    "inline_merge_output": "patching file PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\nHunk #1 already applied at 270,274.",
                                    "upstream_file_tokens": {
                                        "openai": 3650,
                                        "general": {
                                            "word_based": 1580,
                                            "char_based": 5344
                                        },
                                        "gemini": 4529
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.permissioncontroller.permission.ui.handheld;\n\nimport static android.content.pm.PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED;\n\nimport static com.android.permissioncontroller.PermissionControllerStatsLog.REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.content.IntentSender;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.graphics.drawable.Drawable;\nimport android.os.Bundle;\nimport android.os.RemoteCallback;\nimport android.os.UserHandle;\nimport android.text.Html;\nimport android.text.Spanned;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.ImageView;\nimport android.widget.TextView;\n\nimport androidx.annotation.NonNull;\nimport androidx.preference.Preference;\nimport androidx.preference.PreferenceCategory;\nimport androidx.preference.PreferenceFragmentCompat;\nimport androidx.preference.PreferenceGroup;\nimport androidx.preference.PreferenceScreen;\n\nimport com.android.permissioncontroller.PermissionControllerStatsLog;\nimport com.android.permissioncontroller.R;\nimport com.android.permissioncontroller.permission.model.AppPermissionGroup;\nimport com.android.permissioncontroller.permission.model.AppPermissions;\nimport com.android.permissioncontroller.permission.model.Permission;\nimport com.android.permissioncontroller.permission.ui.ManagePermissionsActivity;\nimport com.android.permissioncontroller.permission.utils.ArrayUtils;\nimport com.android.permissioncontroller.permission.utils.Utils;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\n/**\n * If an app does not support runtime permissions the user is prompted via this fragment to select\n * which permissions to grant to the app before first use and if an update changed the permissions.\n */\npublic final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n        implements View.OnClickListener, PermissionPreference.PermissionPreferenceChangeListener,\n        PermissionPreference.PermissionPreferenceOwnerFragment {\n\n    private static final String EXTRA_PACKAGE_INFO =\n            \"com.android.permissioncontroller.permission.ui.extra.PACKAGE_INFO\";\n    private static final String LOG_TAG = ReviewPermissionsFragment.class.getSimpleName();\n\n    private AppPermissions mAppPermissions;\n\n    private Button mContinueButton;\n    private Button mCancelButton;\n    private Button mMoreInfoButton;\n\n    private PreferenceCategory mNewPermissionsCategory;\n    private PreferenceCategory mCurrentPermissionsCategory;\n\n    private boolean mHasConfirmedRevoke;\n\n    /**\n     * @return a new fragment\n     */\n    public static ReviewPermissionsFragment newInstance(PackageInfo packageInfo) {\n        Bundle arguments = new Bundle();\n        arguments.putParcelable(EXTRA_PACKAGE_INFO, packageInfo);\n        ReviewPermissionsFragment instance = new ReviewPermissionsFragment();\n        instance.setArguments(arguments);\n        instance.setRetainInstance(true);\n        return instance;\n    }\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n\n        PackageInfo packageInfo = getArguments().getParcelable(EXTRA_PACKAGE_INFO);\n        if (packageInfo == null) {\n            activity.finishAfterTransition();\n            return;\n        }\n\n        mAppPermissions = new AppPermissions(activity, packageInfo, false, true,\n                () -> getActivity().finishAfterTransition());\n\n        boolean reviewRequired = false;\n        for (AppPermissionGroup group : mAppPermissions.getPermissionGroups()) {\n            if (group.isReviewRequired() || (group.getBackgroundPermissions() != null\n                    && group.getBackgroundPermissions().isReviewRequired())) {\n                reviewRequired = true;\n                break;\n            }\n        }\n\n        if (!reviewRequired) {\n            // If the system called for a review but no groups are found, this means that all groups\n            // are restricted. Hence there is nothing to review and instantly continue.\n            confirmPermissionsReview();\n            executeCallback(true);\n            activity.finishAfterTransition();\n        }\n    }\n\n    @Override\n    public void onCreatePreferences(Bundle bundle, String s) {\n        // empty\n    }\n\n    @Override\n    public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {\n        super.onViewCreated(view, savedInstanceState);\n        bindUi();\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        mAppPermissions.refresh();\n        loadPreferences();\n    }\n\n    @Override\n    public void onClick(View view) {\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n        if (view == mContinueButton) {\n            confirmPermissionsReview();\n            executeCallback(true);\n        } else if (view == mCancelButton) {\n            executeCallback(false);\n            activity.setResult(Activity.RESULT_CANCELED);\n        } else if (view == mMoreInfoButton) {\n            Intent intent = new Intent(Intent.ACTION_MANAGE_APP_PERMISSIONS);\n            intent.putExtra(Intent.EXTRA_PACKAGE_NAME,\n                    mAppPermissions.getPackageInfo().packageName);\n            intent.putExtra(Intent.EXTRA_USER, UserHandle.getUserHandleForUid(\n                    mAppPermissions.getPackageInfo().applicationInfo.uid));\n            intent.putExtra(ManagePermissionsActivity.EXTRA_ALL_PERMISSIONS, true);\n            getActivity().startActivity(intent);\n        }\n        activity.finishAfterTransition();\n    }\n\n    private void grantReviewedPermission(AppPermissionGroup group) {\n        String[] permissionsToGrant = null;\n        final int permissionCount = group.getPermissions().size();\n        for (int j = 0; j < permissionCount; j++) {\n            final Permission permission = group.getPermissions().get(j);\n            if (permission.isReviewRequired()) {\n                permissionsToGrant = ArrayUtils.appendString(\n                        permissionsToGrant, permission.getName());\n            }\n        }\n        if (permissionsToGrant != null) {\n            group.grantRuntimePermissions(true, false, permissionsToGrant);\n        }\n    }\n\n    private void confirmPermissionsReview() {\n        final List<PreferenceGroup> preferenceGroups = new ArrayList<>();\n        if (mNewPermissionsCategory != null) {\n            preferenceGroups.add(mNewPermissionsCategory);\n            preferenceGroups.add(mCurrentPermissionsCategory);\n        } else {\n            PreferenceScreen preferenceScreen = getPreferenceScreen();\n            if (preferenceScreen != null) {\n                preferenceGroups.add(preferenceScreen);\n            }\n        }\n\n        final int preferenceGroupCount = preferenceGroups.size();\n        long changeIdForLogging = new Random().nextLong();\n\n        for (int groupNum = 0; groupNum < preferenceGroupCount; groupNum++) {\n            final PreferenceGroup preferenceGroup = preferenceGroups.get(groupNum);\n\n            final int preferenceCount = preferenceGroup.getPreferenceCount();\n            for (int prefNum = 0; prefNum < preferenceCount; prefNum++) {\n                Preference preference = preferenceGroup.getPreference(prefNum);\n                if (preference instanceof PermissionReviewPreference) {\n                    PermissionReviewPreference permPreference =\n                            (PermissionReviewPreference) preference;\n                    AppPermissionGroup group = permPreference.getGroup();\n\n                    // If the preference wasn't toggled we show it as \"granted\"\n                    if (group.isReviewRequired() && !permPreference.wasChanged()) {\n                        grantReviewedPermission(group);\n                    }\n                    logReviewPermissionsFragmentResult(changeIdForLogging, group);\n\n                    AppPermissionGroup backgroundGroup = group.getBackgroundPermissions();\n                    if (backgroundGroup != null) {\n                        // If the preference wasn't toggled we show it as \"fully granted\"\n                        if (backgroundGroup.isReviewRequired() && !permPreference.wasChanged()) {\n                            grantReviewedPermission(backgroundGroup);\n                        }\n                        logReviewPermissionsFragmentResult(changeIdForLogging, backgroundGroup);\n                    }\n                }\n            }\n        }\n        mAppPermissions.persistChanges(true);\n\n        // Some permission might be restricted and hence there is no AppPermissionGroup for it.\n        // Manually unset all review-required flags, regardless of restriction.\n        PackageManager pm = getContext().getPackageManager();\n        PackageInfo pkg = mAppPermissions.getPackageInfo();\n        UserHandle user = UserHandle.getUserHandleForUid(pkg.applicationInfo.uid);\n\n        for (String perm : pkg.requestedPermissions) {\n            try {\n                pm.updatePermissionFlags(perm, pkg.packageName, FLAG_PERMISSION_REVIEW_REQUIRED,\n                        0, user);\n            } catch (IllegalArgumentException e) {\n                Log.e(LOG_TAG, \"Cannot unmark \" + perm + \" requested by \" + pkg.packageName\n                        + \" as review required\", e);\n            }\n        }\n    }\n\n    private void logReviewPermissionsFragmentResult(long changeId, AppPermissionGroup group) {\n        ArrayList<Permission> permissions = group.getPermissions();\n\n        int numPermissions = permissions.size();\n        for (int i = 0; i < numPermissions; i++) {\n            Permission permission = permissions.get(i);\n\n            PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                    changeId, group.getApp().applicationInfo.uid, group.getApp().packageName,\n                    permission.getName(), permission.isGrantedIncludingAppOp());\n            Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                    + group.getApp().applicationInfo.uid + \" packageName=\"\n                    + group.getApp().packageName + \" permission=\"\n                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n        }\n    }\n\n    private void bindUi() {\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n\n        // Set icon\n        Drawable icon = mAppPermissions.getPackageInfo().applicationInfo.loadIcon(\n                activity.getPackageManager());\n        ImageView iconView = activity.requireViewById(R.id.app_icon);\n        iconView.setImageDrawable(icon);\n\n        // Set message\n        final int labelTemplateResId = isPackageUpdated()\n                ? R.string.permission_review_title_template_update\n                : R.string.permission_review_title_template_install;\n        Spanned message = Html.fromHtml(getString(labelTemplateResId,\n                mAppPermissions.getAppLabel()), 0);\n\n        // Set the permission message as the title so it can be announced.\n        activity.setTitle(message.toString());\n\n        // Color the app name.\n        TextView permissionsMessageView = activity.requireViewById(\n                R.id.permissions_message);\n        permissionsMessageView.setText(message);\n\n        mContinueButton = getActivity().requireViewById(R.id.continue_button);\n        mContinueButton.setOnClickListener(this);\n\n        mCancelButton = getActivity().requireViewById(R.id.cancel_button);\n        mCancelButton.setOnClickListener(this);\n\n        if (activity.getPackageManager().arePermissionsIndividuallyControlled()) {\n            mMoreInfoButton = getActivity().requireViewById(\n                    R.id.permission_more_info_button);\n            mMoreInfoButton.setOnClickListener(this);\n            mMoreInfoButton.setVisibility(View.VISIBLE);\n        }\n    }\n\n    private PermissionReviewPreference getPreference(String key) {\n        if (mNewPermissionsCategory != null) {\n            PermissionReviewPreference pref =\n                    (PermissionReviewPreference) mNewPermissionsCategory.findPreference(key);\n\n            if (pref == null && mCurrentPermissionsCategory != null) {\n                return (PermissionReviewPreference) mCurrentPermissionsCategory.findPreference(key);\n            } else {\n                return pref;\n            }\n        } else {\n            return (PermissionReviewPreference) getPreferenceScreen().findPreference(key);\n        }\n    }\n\n    private void loadPreferences() {\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n\n        PreferenceScreen screen = getPreferenceScreen();\n        if (screen == null) {\n            screen = getPreferenceManager().createPreferenceScreen(getContext());\n            setPreferenceScreen(screen);\n        } else {\n            screen.removeAll();\n        }\n\n        mCurrentPermissionsCategory = null;\n        mNewPermissionsCategory = null;\n\n        final boolean isPackageUpdated = isPackageUpdated();\n\n        for (AppPermissionGroup group : mAppPermissions.getPermissionGroups()) {\n            if (!Utils.shouldShowPermission(getContext(), group)\n                    || !Utils.OS_PKG.equals(group.getDeclaringPackage())) {\n                continue;\n            }\n\n            PermissionReviewPreference preference = getPreference(group.getName());\n            if (preference == null) {\n                preference = new PermissionReviewPreference(this, group, this);\n\n                preference.setKey(group.getName());\n                Drawable icon = Utils.loadDrawable(activity.getPackageManager(),\n                        group.getIconPkg(), group.getIconResId());\n                preference.setIcon(Utils.applyTint(getContext(), icon,\n                        android.R.attr.colorControlNormal));\n                preference.setTitle(group.getLabel());\n            } else {\n                preference.updateUi();\n            }\n\n            if (group.isReviewRequired() || (group.getBackgroundPermissions() != null\n                    && group.getBackgroundPermissions().isReviewRequired())) {\n                if (!isPackageUpdated) {\n                    screen.addPreference(preference);\n                } else {\n                    if (mNewPermissionsCategory == null) {\n                        mNewPermissionsCategory = new PreferenceCategory(activity);\n                        mNewPermissionsCategory.setTitle(R.string.new_permissions_category);\n                        mNewPermissionsCategory.setOrder(1);\n                        screen.addPreference(mNewPermissionsCategory);\n                    }\n                    mNewPermissionsCategory.addPreference(preference);\n                }\n            } else {\n                if (mCurrentPermissionsCategory == null) {\n                    mCurrentPermissionsCategory = new PreferenceCategory(activity);\n                    mCurrentPermissionsCategory.setTitle(R.string.current_permissions_category);\n                    mCurrentPermissionsCategory.setOrder(2);\n                    screen.addPreference(mCurrentPermissionsCategory);\n                }\n                mCurrentPermissionsCategory.addPreference(preference);\n            }\n        }\n    }\n\n    private boolean isPackageUpdated() {\n        List<AppPermissionGroup> groups = mAppPermissions.getPermissionGroups();\n        final int groupCount = groups.size();\n        for (int i = 0; i < groupCount; i++) {\n            AppPermissionGroup group = groups.get(i);\n            if (!(group.isReviewRequired() || (group.getBackgroundPermissions() != null\n                    && group.getBackgroundPermissions().isReviewRequired()))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void executeCallback(boolean success) {\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n        if (success) {\n            IntentSender intent = activity.getIntent().getParcelableExtra(Intent.EXTRA_INTENT);\n            if (intent != null) {\n                try {\n                    int flagMask = 0;\n                    int flagValues = 0;\n                    if (activity.getIntent().getBooleanExtra(\n                            Intent.EXTRA_RESULT_NEEDED, false)) {\n                        flagMask = Intent.FLAG_ACTIVITY_FORWARD_RESULT;\n                        flagValues = Intent.FLAG_ACTIVITY_FORWARD_RESULT;\n                    }\n                    activity.startIntentSenderForResult(intent, -1, null,\n                            flagMask, flagValues, 0);\n                } catch (IntentSender.SendIntentException e) {\n                        /* ignore */\n                }\n                return;\n            }\n        }\n        RemoteCallback callback = activity.getIntent().getParcelableExtra(\n                Intent.EXTRA_REMOTE_CALLBACK);\n        if (callback != null) {\n            Bundle result = new Bundle();\n            result.putBoolean(Intent.EXTRA_RETURN_RESULT, success);\n            callback.sendResult(result);\n        }\n    }\n\n    @Override\n    public boolean shouldConfirmDefaultPermissionRevoke() {\n        return !mHasConfirmedRevoke;\n    }\n\n    @Override\n    public void hasConfirmDefaultPermissionRevoke() {\n        mHasConfirmedRevoke = true;\n    }\n\n    @Override\n    public void onPreferenceChanged(String key) {\n        getPreference(key).setChanged();\n    }\n\n    @Override\n    public void onDenyAnyWay(String key, int changeTarget) {\n        getPreference(key).onDenyAnyWay(changeTarget);\n    }\n\n    @Override\n    public void onBackgroundAccessChosen(String key, int chosenItem) {\n        getPreference(key).onBackgroundAccessChosen(chosenItem);\n    }\n\n    /**\n     * Extend the {@link PermissionPreference}:\n     * <ul>\n     *     <li>Show the description of the permission group</li>\n     *     <li>Show the permission group as granted if the user has not toggled it yet. This means\n     *     that if the user does not touch the preference, we will later grant the permission\n     *     in {@link #confirmPermissionsReview()}.</li>\n     * </ul>\n     */\n    private static class PermissionReviewPreference extends PermissionPreference {\n        private final AppPermissionGroup mGroup;\n        private boolean mWasChanged;\n\n        PermissionReviewPreference(PreferenceFragmentCompat fragment, AppPermissionGroup group,\n                PermissionPreferenceChangeListener callbacks) {\n            super(fragment, group, callbacks);\n\n            mGroup = group;\n            updateUi();\n        }\n\n        AppPermissionGroup getGroup() {\n            return mGroup;\n        }\n\n        /**\n         * Mark the permission as changed by the user\n         */\n        void setChanged() {\n            mWasChanged = true;\n            updateUi();\n        }\n\n        /**\n         * @return {@code true} iff the permission was changed by the user\n         */\n        boolean wasChanged() {\n            return mWasChanged;\n        }\n\n        @Override\n        void updateUi() {\n            // updateUi might be called in super-constructor before group is initialized\n            if (mGroup == null) {\n                return;\n            }\n\n            super.updateUi();\n\n            if (isEnabled()) {\n                if (mGroup.isReviewRequired() && !mWasChanged) {\n                    setSummary(mGroup.getDescription());\n                    setCheckedOverride(true);\n                } else if (TextUtils.isEmpty(getSummary())) {\n                    // Sometimes the summary is already used, e.g. when this for a\n                    // foreground/background group. In this case show leave the original summary.\n                    setSummary(mGroup.getDescription());\n                }\n            }\n        }\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 3612,
                                        "general": {
                                            "word_based": 1531,
                                            "char_based": 5161
                                        },
                                        "gemini": 4423
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "06e7a4b6dced97632ef42670539d71cb6c68785a",
                            "repo_path": "android_repos/Permission",
                            "result": "failure",
                            "downstream_patch_content": "commit 06e7a4b6dced97632ef42670539d71cb6c68785a\nAuthor: Yi-an Chen <theianchen@google.com>\nDate:   Thu Aug 8 01:15:57 2024 +0000\n\n    RESTRICT AUTOMERGE Fix Dynamic Permission group auto grant behaivor\n    \n    Fix the Dynamic Permission group auto grant behaivor so that a\n    permission group is only considered granted when (1) all permissions\n    were auto-granted or (2) a platform permission in the same group is\n    granted.\n    \n    Bug: 340480881\n    Test: DynamicPermissionsTest\n    Change-Id: I37b550f0c3933bc790c2917a14e917efbcccc4e8\n    Merged-In: I37b550f0c3933bc790c2917a14e917efbcccc4e8\n\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt b/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\nindex 97389b0984..bf43f15c3f 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\n@@ -66,7 +66,7 @@ class LightPermInfoLiveData private constructor(\n         }\n \n         val newValue = try {\n-            LightPermInfo(app.packageManager.getPermissionInfo(permissionName, 0))\n+            LightPermInfo(app.packageManager.getPermissionInfo(permissionName, 0), null)\n         } catch (e: PackageManager.NameNotFoundException) {\n             Log.w(LOG_TAG, \"Permission \\\"$permissionName\\\" not found\")\n             invalidateSingle(permissionName)\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt b/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\nindex 78f2f72c63..948815646a 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\n@@ -17,6 +17,7 @@\n package com.android.permissioncontroller.permission.data\n \n import android.app.Application\n+import android.content.pm.ApplicationInfo\n import android.content.pm.PackageItemInfo\n import android.content.pm.PackageManager\n import android.content.pm.PermissionGroupInfo\n@@ -68,32 +69,31 @@ class PermGroupLiveData private constructor(\n      */\n     override fun onUpdate() {\n         val permissionInfos = mutableMapOf<String, LightPermInfo>()\n-\n         groupInfo = Utils.getGroupInfo(groupName, context) ?: run {\n             Log.e(LOG_TAG, \"Invalid permission group $groupName\")\n             invalidateSingle(groupName)\n             value = null\n             return\n         }\n-\n+        val permInfos = mutableListOf<PermissionInfo>()\n         when (groupInfo) {\n             is PermissionGroupInfo -> {\n-                val permInfos = try {\n-                    Utils.getInstalledRuntimePermissionInfosForGroup(context.packageManager,\n-                        groupName)\n+                try {\n+                    permInfos.addAll(\n+                        Utils.getInstalledRuntimePermissionInfosForGroup(\n+                            context.packageManager,\n+                            groupName\n+                        )\n+                    )\n                 } catch (e: PackageManager.NameNotFoundException) {\n                     Log.e(LOG_TAG, \"Invalid permission group $groupName\")\n                     invalidateSingle(groupName)\n                     value = null\n                     return\n                 }\n-\n-                for (permInfo in permInfos) {\n-                    permissionInfos[permInfo.name] = LightPermInfo(permInfo)\n-                }\n             }\n             is PermissionInfo -> {\n-                permissionInfos[groupInfo.name] = LightPermInfo(groupInfo as PermissionInfo)\n+                permInfos.add(groupInfo as PermissionInfo)\n             }\n             else -> {\n                 value = null\n@@ -101,19 +101,25 @@ class PermGroupLiveData private constructor(\n             }\n         }\n \n-        val permGroup = PermGroup(LightPermGroupInfo(groupInfo), permissionInfos)\n-\n-        value = permGroup\n-\n-        val packageNames = permissionInfos.values.map { permInfo -> permInfo.packageName }\n-            .toMutableSet()\n+        val packageNames = permInfos.map { permInfo -> permInfo.packageName }.toMutableSet()\n         packageNames.add(groupInfo.packageName)\n-\n         // TODO ntmyren: What if the package isn't installed for the system user?\n         val getLiveData = { packageName: String ->\n             LightPackageInfoLiveData[packageName, UserHandle.SYSTEM]\n         }\n         setSourcesToDifference(packageNames, packageLiveDatas, getLiveData)\n+        if (!packageLiveDatas.all { it.value.isInitialized }) {\n+            return\n+        }\n+        for (permInfo in permInfos) {\n+            val lightPackageInfo = packageLiveDatas[permInfo.packageName]?.value\n+            val isSystem =\n+                lightPackageInfo?.let { it.appFlags and ApplicationInfo.FLAG_SYSTEM != 0 }\n+            permissionInfos[permInfo.name] = LightPermInfo(permInfo, isSystem)\n+        }\n+\n+        val permGroup = PermGroup(LightPermGroupInfo(groupInfo), permissionInfos)\n+        value = permGroup\n     }\n \n     override fun onInactive() {\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\nindex 64d63bd1ad..2e7d3b4a05 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\n@@ -20,6 +20,7 @@ import android.Manifest\n import android.Manifest.permission.ACCESS_COARSE_LOCATION\n import android.os.Build\n import android.os.UserHandle\n+import com.android.permissioncontroller.permission.utils.Utils\n \n /**\n  * A lightweight version of the AppPermissionGroup data structure. Represents information about a\n@@ -79,11 +80,13 @@ data class LightAppPermGroup(\n         if (name !in backgroundPermNames) name else null\n     }\n \n+    val isPlatformPermissionGroup = permGroupInfo.packageName == Utils.OS_PKG\n+\n     val foreground = AppPermSubGroup(permissions.filter { it.key in foregroundPermNames },\n-        packageInfo, specialLocationGrant)\n+        packageInfo, isPlatformPermissionGroup, specialLocationGrant)\n \n     val background = AppPermSubGroup(permissions.filter { it.key in backgroundPermNames },\n-        packageInfo, specialLocationGrant)\n+        packageInfo, isPlatformPermissionGroup, specialLocationGrant)\n \n     /**\n      * Whether or not this App Permission Group has a permission which has a background mode\n@@ -124,7 +127,7 @@ data class LightAppPermGroup(\n      */\n     val isOneTime = (permGroupName != Manifest.permission_group.LOCATION &&\n             permissions.any { it.value.isOneTime } &&\n-            permissions.none { !it.value.isOneTime && it.value.isGrantedIncludingAppOp }) ||\n+            permissions.none { !it.value.isOneTime && it.value.isGranted }) ||\n             (permGroupName == Manifest.permission_group.LOCATION &&\n                     permissions[ACCESS_COARSE_LOCATION]?.isOneTime == true)\n \n@@ -176,17 +179,23 @@ data class LightAppPermGroup(\n      *\n      * @param permissions The permissions contained within this subgroup, a subset of those contained\n      * in the full group\n+     * @param isPlatformPermissionGroup Whether this is a platform permission group\n      * @param specialLocationGrant Whether this is a special location package\n      */\n     data class AppPermSubGroup internal constructor(\n         private val permissions: Map<String, LightPermission>,\n         private val packageInfo: LightPackageInfo,\n+        private val isPlatformPermissionGroup: Boolean,\n         private val specialLocationGrant: Boolean?\n     ) {\n-        /**\n-         * Whether any of this App Permission SubGroup's permissions are granted\n-         */\n-        val isGranted = specialLocationGrant ?: permissions.any { it.value.isGrantedIncludingAppOp }\n+        /** Whether any of this App Permission SubGroup's permissions are granted */\n+        val isGranted =\n+            specialLocationGrant\n+                ?: permissions.any {\n+                    val mayGrantByPlatformOrSystem =\n+                        !isPlatformPermissionGroup || it.value.isPlatformOrSystem\n+                    it.value.isGranted && mayGrantByPlatformOrSystem\n+                }\n \n         /**\n          * Whether this App Permission SubGroup should be treated as granted. This means either:\n@@ -195,9 +204,15 @@ data class LightAppPermGroup(\n          * 2) All permissions were auto-granted (all permissions are all granted and all\n          * RevokeWhenRequested.)\n          */\n-        val isGrantedExcludingRWROrAllRWR = specialLocationGrant ?: (permissions\n-            .any { it.value.isGrantedIncludingAppOp && !it.value.isRevokeWhenRequested } ||\n-            permissions.all { it.value.isGrantedIncludingAppOp && it.value.isRevokeWhenRequested })\n+        val allowFullGroupGrant =\n+            specialLocationGrant\n+                ?: (permissions.any {\n+                    val mayGrantByPlatformOrSystem =\n+                        !isPlatformPermissionGroup || it.value.isPlatformOrSystem\n+                    it.value.allowFullGroupGrant && mayGrantByPlatformOrSystem\n+                } || permissions.all {\n+                    it.value.isGranted && it.value.isRevokeWhenRequested\n+                })\n \n         /**\n          * Whether any of this App Permission SubGroup's permissions are granted by default\n@@ -209,7 +224,7 @@ data class LightAppPermGroup(\n          * none of the granted permissions are not one-time.\n          */\n         val isOneTime = permissions.any { it.value.isOneTime } &&\n-                permissions.none { it.value.isGrantedIncludingAppOp && !it.value.isOneTime }\n+                permissions.none { it.value.isGranted && !it.value.isOneTime }\n \n         /**\n          * Whether any of this App Permission Subgroup's foreground permissions are fixed by policy\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\nindex 182de1a597..a37a47163f 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\n@@ -49,7 +49,9 @@ data class LightPackageInfo(\n     val firstInstallTime: Long\n ) {\n     constructor(pI: PackageInfo) : this(pI.packageName,\n-        pI.permissions?.map { perm -> LightPermInfo(perm) } ?: emptyList(),\n+        pI.permissions?.map { perm ->\n+            LightPermInfo(perm, pI.applicationInfo!!.flags and ApplicationInfo.FLAG_SYSTEM != 0)\n+        } ?: emptyList(),\n         pI.requestedPermissions?.toList() ?: emptyList(),\n         pI.requestedPermissionsFlags?.toList() ?: emptyList(),\n         pI.applicationInfo.uid, pI.applicationInfo.targetSdkVersion,\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\nindex 3954b74722..582742da43 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\n@@ -30,6 +30,7 @@ import android.content.pm.PermissionInfo\n  * @param protection The protection level of this permission\n  * @param protection Extra information about the protection of this permission\n  * @param flags The system flags of this permission\n+ * @param isSystem Whether this permission is defined by a system app\n  */\n data class LightPermInfo(\n     val name: String,\n@@ -38,11 +39,13 @@ data class LightPermInfo(\n     val backgroundPermission: String?,\n     val protection: Int,\n     val protectionFlags: Int,\n-    val flags: Int\n+    val flags: Int,\n+    val isSystem: Boolean?\n ) {\n-    constructor (permInfo: PermissionInfo): this(permInfo.name, permInfo.packageName,\n-        permInfo.group, permInfo.backgroundPermission, permInfo.protection,\n-        permInfo.protectionFlags, permInfo.flags)\n+    constructor (permInfo: PermissionInfo, isSystem: Boolean?) : this(\n+        permInfo.name, permInfo.packageName, permInfo.group, permInfo.backgroundPermission,\n+        permInfo.protection, permInfo.protectionFlags, permInfo.flags, isSystem\n+    )\n \n     /**\n      * Gets the PermissionInfo for this permission from the system.\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\nindex c3d087fd24..45c3b1e92a 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\n@@ -27,7 +27,7 @@ import com.android.permissioncontroller.permission.utils.Utils.isRuntimePlatform\n  *\n  * @param pkgInfo The package requesting the permission\n  * @param permInfo The permissionInfo this represents\n- * @param isGrantedIncludingAppOp Whether or not this permission is functionally granted.\n+ * @param isGranted Whether or not this permission is functionally granted.\n  * A non-granted app op but granted permission is counted as not granted\n  * @param flags The PermissionController flags for this permission\n  * @param foregroundPerms The foreground permission names corresponding to this permission, if this\n@@ -36,7 +36,7 @@ import com.android.permissioncontroller.permission.utils.Utils.isRuntimePlatform\n data class LightPermission(\n     val pkgInfo: LightPackageInfo,\n     val permInfo: LightPermInfo,\n-    val isGrantedIncludingAppOp: Boolean,\n+    val isGranted: Boolean,\n     val flags: Int,\n     val foregroundPerms: List<String>?\n ) {\n@@ -82,9 +82,9 @@ data class LightPermission(\n     val isRevokeWhenRequested = flags and PackageManager.FLAG_PERMISSION_REVOKE_WHEN_REQUESTED != 0\n     /** Whether this permission is user sensitive in its current grant state */\n     val isUserSensitive = !isRuntimePlatformPermission(permInfo.name) ||\n-            (isGrantedIncludingAppOp &&\n+            (isGranted &&\n                     (flags and PackageManager.FLAG_PERMISSION_USER_SENSITIVE_WHEN_GRANTED) != 0) ||\n-            (!isGrantedIncludingAppOp &&\n+            (!isGranted &&\n                     (flags and PackageManager.FLAG_PERMISSION_USER_SENSITIVE_WHEN_DENIED) != 0)\n     /** Whether the permission is restricted */\n     val isRestricted = when {\n@@ -105,10 +105,17 @@ data class LightPermission(\n      */\n     val isSelectedLocationAccuracy =\n         flags and PackageManager.FLAG_PERMISSION_SELECTED_LOCATION_ACCURACY != 0\n+    /** Whether this permission is defined by platform or a system app */\n+    val isPlatformOrSystem = permInfo.packageName == Utils.OS_PKG || permInfo.isSystem == true\n+    /**\n+     * Whether this permission is granted including app op and does not hold the\n+     * PackageManager.FLAG_PERMISSION_REVOKE_WHEN_REQUESTED flag.\n+     */\n+    val allowFullGroupGrant = isGranted && !isRevokeWhenRequested\n \n     override fun toString() = buildString {\n         append(name)\n-        if (isGrantedIncludingAppOp) append(\", Granted\") else append(\", NotGranted\")\n+        if (isGranted) append(\", Granted\") else append(\", NotGranted\")\n         if (isPolicyFixed) append(\", PolicyFixed\")\n         if (isSystemFixed) append(\", SystemFixed\")\n         if (isUserFixed) append(\", UserFixed\")\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt b/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\nindex aed275d8af..436612d585 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\n@@ -102,7 +102,7 @@ suspend fun revokeAppPermissions(\n                         .getInitializedValue() ?: continue\n                 val fixed = group.isBackgroundFixed || group.isForegroundFixed\n                 val granted = group.permissions.any { (_, perm) ->\n-                    perm.isGrantedIncludingAppOp && perm.name !in EXEMPT_PERMISSIONS\n+                    perm.isGranted && perm.name !in EXEMPT_PERMISSIONS\n                 }\n                 if (!fixed && granted &&\n                     !group.isGrantedByDefault &&\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt b/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\nindex e105a69bc3..12d7d45ba2 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\n@@ -389,7 +389,7 @@ internal object RuntimePermissionsUpgradeController {\n \n                 val allPermissionsWithxemption = bgApp.allPermissions.toMutableMap()\n                 allPermissionsWithxemption[permission.ACCESS_BACKGROUND_LOCATION] =\n-                        LightPermission(perm.pkgInfo, perm.permInfo, perm.isGrantedIncludingAppOp,\n+                        LightPermission(perm.pkgInfo, perm.permInfo, perm.isGranted,\n                         perm.flags or FLAG_PERMISSION_RESTRICTION_UPGRADE_EXEMPT,\n                         perm.foregroundPerms)\n \n@@ -451,7 +451,7 @@ internal object RuntimePermissionsUpgradeController {\n                             ?: continue\n \n                     if (!perm.isUserSet && !perm.isSystemFixed && !perm.isPolicyFixed &&\n-                            !perm.isGrantedIncludingAppOp) {\n+                            !perm.isGranted) {\n                         grants.add(Grant(false, appPermGroup,\n                                 listOf(permission.ACCESS_MEDIA_LOCATION)))\n                     }\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java b/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\nindex a6f74c822c..3bfe7ee691 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n@@ -257,11 +257,11 @@ public final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }\n \ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\nindex e743d7c814..d4d63e31f7 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\n@@ -868,7 +868,7 @@ class AppPermissionViewModel(\n \n     private fun getIndividualPermissionDetailResId(group: LightAppPermGroup): Pair<Int, Int> {\n         return when (val numRevoked =\n-            group.permissions.filter { !it.value.isGrantedIncludingAppOp }.size) {\n+            group.permissions.filter { !it.value.isGranted }.size) {\n             0 -> R.string.permission_revoked_none to numRevoked\n             group.permissions.size -> R.string.permission_revoked_all to numRevoked\n             else -> R.string.permission_revoked_count to numRevoked\n@@ -938,11 +938,11 @@ class AppPermissionViewModel(\n         for ((permName, permission) in oldGroup.permissions) {\n             val newPermission = newGroup.permissions[permName] ?: continue\n \n-            if (permission.isGrantedIncludingAppOp != newPermission.isGrantedIncludingAppOp ||\n+            if (permission.isGranted != newPermission.isGranted ||\n                 permission.flags != newPermission.flags) {\n                 logAppPermissionFragmentActionReported(changeId, newPermission, buttonPressed)\n                 PermissionDecisionStorageImpl.recordPermissionDecision(app.applicationContext,\n-                    packageName, permGroupName, newPermission.isGrantedIncludingAppOp)\n+                    packageName, permGroupName, newPermission.isGranted)\n             }\n         }\n     }\n@@ -955,10 +955,10 @@ class AppPermissionViewModel(\n         val uid = KotlinUtils.getPackageUid(app, packageName, user) ?: return\n         PermissionControllerStatsLog.write(APP_PERMISSION_FRAGMENT_ACTION_REPORTED, sessionId,\n             changeId, uid, packageName, permission.permInfo.name,\n-            permission.isGrantedIncludingAppOp, permission.flags, buttonPressed)\n+            permission.isGranted, permission.flags, buttonPressed)\n         Log.v(LOG_TAG, \"Permission changed via UI with sessionId=$sessionId changeId=\" +\n             \"$changeId uid=$uid packageName=$packageName permission=\" + permission.permInfo.name +\n-            \" isGranted=\" + permission.isGrantedIncludingAppOp + \" permissionFlags=\" +\n+            \" isGranted=\" + permission.isGranted + \" permissionFlags=\" +\n             permission.flags + \" buttonPressed=$buttonPressed\")\n     }\n \ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\nindex 71f729dc47..1fcd087ff6 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\n@@ -261,7 +261,7 @@ class GrantPermissionsViewModel(\n                     //  REVIEW_REQUIRED flag setting\n                     for ((key, state) in states) {\n                         val allAffectedGranted = state.affectedPermissions.all { perm ->\n-                            appPermGroup.permissions[perm]?.isGrantedIncludingAppOp == true &&\n+                            appPermGroup.permissions[perm]?.isGranted == true &&\n                                 appPermGroup.permissions[perm]?.isRevokeWhenRequested == false\n                         } && !appPermGroup.isRuntimePermReviewRequired\n                         if (allAffectedGranted) {\n@@ -300,7 +300,7 @@ class GrantPermissionsViewModel(\n                     for (perm in fgState.affectedPermissions) {\n                         minSdkForOrderedSplitPermissions = maxOf(minSdkForOrderedSplitPermissions,\n                                 splitPermissionTargetSdkMap.getOrDefault(perm, 0))\n-                        if (fgGroup.permissions[perm]?.isGrantedIncludingAppOp == false) {\n+                        if (fgGroup.permissions[perm]?.isGranted == false) {\n                             // If any of the requested permissions is not granted,\n                             // needFgPermissions = true\n                             needFgPermissions = true\n@@ -450,7 +450,7 @@ class GrantPermissionsViewModel(\n                                 fgState.affectedPermissions.contains(ACCESS_FINE_LOCATION)) {\n                             val coarseLocationPerm =\n                                 groupState.group.allPermissions[ACCESS_COARSE_LOCATION]\n-                            if (coarseLocationPerm?.isGrantedIncludingAppOp == true) {\n+                            if (coarseLocationPerm?.isGranted == true) {\n                                 // Upgrade flow\n                                 locationVisibilities[DIALOG_WITH_FINE_LOCATION_ONLY] = true\n                                 message = RequestMessage.FG_FINE_LOCATION_MESSAGE\n@@ -710,7 +710,7 @@ class GrantPermissionsViewModel(\n \n         // Do not attempt to grant background access if foreground access is not either already\n         // granted or requested\n-        if (isBackground && !group.foreground.isGrantedExcludingRWROrAllRWR &&\n+        if (isBackground && !group.foreground.allowFullGroupGrant &&\n             !hasForegroundRequest) {\n             Log.w(LOG_TAG, \"Cannot grant $perm as the matching foreground permission is not \" +\n                 \"already granted.\")\n@@ -724,18 +724,18 @@ class GrantPermissionsViewModel(\n \n         // TODO(b/205888750): remove isRuntimePermReview line once confident in\n         //  REVIEW_REQUIRED flag setting\n-        if ((isBackground && group.background.isGrantedExcludingRWROrAllRWR ||\n-            !isBackground && group.foreground.isGrantedExcludingRWROrAllRWR) &&\n+        if ((isBackground && group.background.allowFullGroupGrant ||\n+            !isBackground && group.foreground.allowFullGroupGrant) &&\n             !group.isRuntimePermReviewRequired) {\n             // If FINE location is not granted, do not grant it automatically when COARSE\n             // location is already granted.\n             if (group.permGroupName == LOCATION &&\n-                    group.allPermissions[ACCESS_FINE_LOCATION]?.isGrantedIncludingAppOp\n+                    group.allPermissions[ACCESS_FINE_LOCATION]?.isGranted\n                     == false) {\n                 return STATE_UNKNOWN\n             }\n \n-            if (group.permissions[perm]?.isGrantedIncludingAppOp == false) {\n+            if (group.permissions[perm]?.isGranted == false) {\n                 if (isBackground) {\n                     KotlinUtils.grantBackgroundRuntimePermissions(app, group, listOf(perm))\n                 } else {\n@@ -939,28 +939,40 @@ class GrantPermissionsViewModel(\n             } else {\n                 PERMISSION_GRANT_REQUEST_RESULT_REPORTED__RESULT__USER_GRANTED\n             }\n+            var affectedPermissions: List<String> = groupState.affectedPermissions\n             if (groupState.isBackground) {\n                 KotlinUtils.grantBackgroundRuntimePermissions(app, groupState.group,\n-                    groupState.affectedPermissions)\n+                    affectedPermissions)\n             } else {\n                 if (affectedForegroundPermissions == null) {\n                     KotlinUtils.grantForegroundRuntimePermissions(app, groupState.group,\n-                        groupState.affectedPermissions, isOneTime)\n+                        affectedPermissions, isOneTime)\n                     // This prevents weird flag state when app targetSDK switches from S+ to R-\n                     if (groupState.affectedPermissions.contains(ACCESS_FINE_LOCATION)) {\n                         KotlinUtils.setFlagsWhenLocationAccuracyChanged(\n                                 app, groupState.group, true)\n                     }\n                 } else {\n+                    affectedPermissions = affectedForegroundPermissions\n                     val newGroup = KotlinUtils.grantForegroundRuntimePermissions(app,\n-                            groupState.group, affectedForegroundPermissions, isOneTime)\n+                            groupState.group, affectedPermissions, isOneTime)\n                     if (!isOneTime || newGroup.isOneTime) {\n                         KotlinUtils.setFlagsWhenLocationAccuracyChanged(app, newGroup,\n                                 affectedForegroundPermissions.contains(ACCESS_FINE_LOCATION))\n                     }\n                 }\n             }\n-            groupState.state = STATE_ALLOWED\n+            val shouldDenyFullGroupGrant =\n+                groupState.group.isPlatformPermissionGroup &&\n+                        affectedPermissions.none {\n+                            groupState.group.permissions[it]?.isPlatformOrSystem == true\n+                        }\n+            groupState.state =\n+                if (shouldDenyFullGroupGrant) {\n+                    STATE_UNKNOWN\n+                } else {\n+                    STATE_ALLOWED\n+                }\n         } else {\n             if (groupState.isBackground) {\n                 KotlinUtils.revokeBackgroundRuntimePermissions(app, groupState.group,\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/ReviewPermissionsViewModel.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/ReviewPermissionsViewModel.kt\nindex 94d0df0d56..79b2c87d81 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/ReviewPermissionsViewModel.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/ReviewPermissionsViewModel.kt\n@@ -133,7 +133,7 @@ class ReviewPermissionsViewModel(\n         val lightPerms = permGroup.allPermissions.values.toList()\n         val permissionCount = lightPerms.size\n         for (i in 0 until permissionCount) {\n-            if (!lightPerms[i].isGrantedIncludingAppOp) {\n+            if (!lightPerms[i].isGranted) {\n                 revokedCount++\n             }\n         }\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt b/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\nindex 2216802f30..e7f4874e44 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\n@@ -470,7 +470,7 @@ object KotlinUtils {\n                     group.userHandle, *flags)\n             }\n             newPerms[permName] = LightPermission(group.packageInfo, perm.permInfo,\n-                perm.isGrantedIncludingAppOp, perm.flags or flagsToSet, perm.foregroundPerms)\n+                perm.isGranted, perm.flags or flagsToSet, perm.foregroundPerms)\n         }\n         return LightAppPermGroup(group.packageInfo, group.permGroupInfo, newPerms,\n             group.hasInstallToRuntimeSplit, group.specialLocationGrant)\n@@ -560,7 +560,7 @@ object KotlinUtils {\n         val newGroup = LightAppPermGroup(group.packageInfo, group.permGroupInfo, newPerms,\n             group.hasInstallToRuntimeSplit, group.specialLocationGrant)\n         // If any permission in the group is one time granted, start one time permission session.\n-        if (newGroup.permissions.any { it.value.isOneTime && it.value.isGrantedIncludingAppOp }) {\n+        if (newGroup.permissions.any { it.value.isOneTime && it.value.isGranted }) {\n             if (SdkLevel.isAtLeastT()) {\n                 app.getSystemService(PermissionManager::class.java)!!.startOneTimePermissionSession(\n                         group.packageName, Utils.getOneTimePermissionsTimeout(),\n@@ -605,11 +605,11 @@ object KotlinUtils {\n         }\n \n         var newFlags = perm.flags\n-        var isGranted = perm.isGrantedIncludingAppOp\n+        var isGranted = perm.isGranted\n         var shouldKill = false\n \n         // Grant the permission if needed.\n-        if (!perm.isGrantedIncludingAppOp) {\n+        if (!perm.isGranted) {\n             val affectsAppOp = permissionToOp(perm.name) != null || perm.isBackgroundPermission\n \n             // TODO 195016052: investigate adding split permission handling\n@@ -653,14 +653,14 @@ object KotlinUtils {\n \n         // If we newly grant background access to the fine location, double-guess the user some\n         // time later if this was really the right choice.\n-        if (!perm.isGrantedIncludingAppOp && isGranted) {\n+        if (!perm.isGranted && isGranted) {\n             var triggerLocationAccessCheck = false\n             if (perm.name == ACCESS_FINE_LOCATION) {\n                 val bgPerm = group.permissions[perm.backgroundPermission]\n-                triggerLocationAccessCheck = bgPerm?.isGrantedIncludingAppOp == true\n+                triggerLocationAccessCheck = bgPerm?.isGranted == true\n             } else if (perm.name == ACCESS_BACKGROUND_LOCATION) {\n                 val fgPerm = group.permissions[ACCESS_FINE_LOCATION]\n-                triggerLocationAccessCheck = fgPerm?.isGrantedIncludingAppOp == true\n+                triggerLocationAccessCheck = fgPerm?.isGranted == true\n             }\n             if (triggerLocationAccessCheck) {\n                 // trigger location access check\n@@ -825,13 +825,13 @@ object KotlinUtils {\n \n         val user = UserHandle.getUserHandleForUid(group.packageInfo.uid)\n         var newFlags = perm.flags\n-        var isGranted = perm.isGrantedIncludingAppOp\n+        var isGranted = perm.isGranted\n         val supportsRuntime = group.packageInfo.targetSdkVersion >= Build.VERSION_CODES.M\n         var shouldKill = false\n \n         val affectsAppOp = permissionToOp(perm.name) != null || perm.isBackgroundPermission\n \n-        if (perm.isGrantedIncludingAppOp) {\n+        if (perm.isGranted) {\n             if (supportsRuntime && !isPermissionSplitFromNonRuntime(app, perm.name,\n                             group.packageInfo.targetSdkVersion)) {\n                 // Revoke the permission if needed.\n@@ -926,7 +926,7 @@ object KotlinUtils {\n                 val fgPerm = group.permissions[foregroundPermName]\n                 val appOpName = permissionToOp(foregroundPermName) ?: continue\n \n-                if (fgPerm != null && fgPerm.isGrantedIncludingAppOp) {\n+                if (fgPerm != null && fgPerm.isGranted) {\n                     wasChanged = wasChanged || setOpMode(appOpName, uid, packageName, MODE_ALLOWED,\n                         appOpsManager)\n                 }\n@@ -936,7 +936,7 @@ object KotlinUtils {\n             if (perm.backgroundPermission != null) {\n                 wasChanged = if (group.permissions.containsKey(perm.backgroundPermission)) {\n                     val bgPerm = group.permissions[perm.backgroundPermission]\n-                    val mode = if (bgPerm != null && bgPerm.isGrantedIncludingAppOp) MODE_ALLOWED\n+                    val mode = if (bgPerm != null && bgPerm.isGranted) MODE_ALLOWED\n                     else MODE_FOREGROUND\n \n                     setOpMode(appOpName, uid, packageName, mode, appOpsManager)\n@@ -987,7 +987,7 @@ object KotlinUtils {\n         if (perm.isBackgroundPermission && perm.foregroundPerms != null) {\n             for (foregroundPermName in perm.foregroundPerms) {\n                 val fgPerm = group.permissions[foregroundPermName]\n-                if (fgPerm != null && fgPerm.isGrantedIncludingAppOp) {\n+                if (fgPerm != null && fgPerm.isGranted) {\n                     val appOpName = permissionToOp(foregroundPermName) ?: return false\n                     wasChanged = wasChanged || setOpMode(appOpName, uid, packageName,\n                         MODE_FOREGROUND, appOpsManager)\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java b/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\nindex f0227cad54..96eccd0a8d 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\n@@ -162,7 +162,7 @@ public final class SafetyNetLogger {\n             }\n \n             builder.append(permission.getName()).append('|');\n-            builder.append(permission.isGrantedIncludingAppOp()).append('|');\n+            builder.append(permission.isGranted()).append('|');\n             builder.append(permission.getFlags());\n         }\n     }\ndiff --git a/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/ui/model/ReviewPermissionsViewModelTest.kt b/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/ui/model/ReviewPermissionsViewModelTest.kt\nindex df6e921545..7e95fcef8a 100644\n--- a/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/ui/model/ReviewPermissionsViewModelTest.kt\n+++ b/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/ui/model/ReviewPermissionsViewModelTest.kt\n@@ -110,7 +110,7 @@ class ReviewPermissionsViewModelTest {\n         permissionsMap[\"mockedPermission1\"] = permission2\n \n         whenever(permGroup.allPermissions).thenReturn(permissionsMap)\n-        whenever(permission1.isGrantedIncludingAppOp).thenReturn(true)\n+        whenever(permission1.isGranted).thenReturn(true)\n \n         val summary = model.getSummaryForIndividuallyControlledPermGroup(permGroup)\n         assertEquals(\ndiff --git a/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/utils/GrantRevokeTests.kt b/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/utils/GrantRevokeTests.kt\nindex df4c4e80fa..0d0edc8669 100644\n--- a/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/utils/GrantRevokeTests.kt\n+++ b/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/utils/GrantRevokeTests.kt\n@@ -24,6 +24,7 @@ import android.app.AppOpsManager.MODE_FOREGROUND\n import android.app.AppOpsManager.MODE_IGNORED\n import android.app.AppOpsManager.permissionToOp\n import android.app.Application\n+import android.content.pm.ApplicationInfo\n import android.content.pm.PackageManager\n import android.content.pm.PackageManager.FLAG_PERMISSION_AUTO_REVOKED\n import android.content.pm.PackageManager.FLAG_PERMISSION_ONE_TIME\n@@ -181,7 +182,8 @@ class GrantRevokeTests {\n         permInfoProtectionFlags: Int = 0\n     ): LightPermission {\n         val permInfo = LightPermInfo(permName, TEST_PACKAGE_NAME, PERM_GROUP_NAME, backgroundPerm,\n-            PermissionInfo.PROTECTION_DANGEROUS, permInfoProtectionFlags, 0)\n+            PermissionInfo.PROTECTION_DANGEROUS, permInfoProtectionFlags, 0,\n+            pkgInfo.appFlags and ApplicationInfo.FLAG_SYSTEM != 0)\n         return LightPermission(pkgInfo, permInfo,\n                 pkgInfo.requestedPermissionsFlags[pkgInfo.requestedPermissions.indexOf(permName)]\n                         == PERMISSION_GRANTED, flags, foregroundPerms)\n@@ -252,7 +254,7 @@ class GrantRevokeTests {\n             val flags = state.second\n \n             assertWithMessage(\"permission $permName grant state incorrect\")\n-                .that(perms[permName]?.isGrantedIncludingAppOp).isEqualTo(granted)\n+                .that(perms[permName]?.isGranted).isEqualTo(granted)\n \n             val actualFlags = perms[permName]!!.flags\n             assertWithMessage(\"permission $permName flags incorrect, expected\" +\n",
                            "downstream_patch_tokens": {
                                "openai": 8373,
                                "general": {
                                    "word_based": 3321,
                                    "char_based": 9996
                                },
                                "gemini": 10140
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java",
                                    "total_hunks": 1,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [],
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    },
                                    "rej_file_content": "```diff\n--- PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n+++ PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n@@ -267,11 +267,11 @@ public final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.i(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }\n```",
                                    "rej_file_tokens": {
                                        "openai": 203,
                                        "general": {
                                            "word_based": 77,
                                            "char_based": 289
                                        },
                                        "gemini": 250
                                    },
                                    "patch_apply_output": "patching file PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\nHunk #1 FAILED at 267.\n1 out of 1 hunk FAILED -- saving rejects to file PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java.rej\npatching file PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\nHunk #1 succeeded at 162 (offset 67 lines).",
                                    "inline_merge_output": "patching file PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\nHunk #1 already applied at 270,274.",
                                    "upstream_file_tokens": {
                                        "openai": 3650,
                                        "general": {
                                            "word_based": 1580,
                                            "char_based": 5344
                                        },
                                        "gemini": 4529
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.permissioncontroller.permission.ui.handheld;\n\nimport static android.content.pm.PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED;\nimport static android.content.pm.PackageManager.FLAG_PERMISSION_USER_SET;\n\nimport static com.android.permissioncontroller.PermissionControllerStatsLog.REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED;\n\nimport android.app.Activity;\nimport android.app.Application;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentSender;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.graphics.drawable.Drawable;\nimport android.os.Bundle;\nimport android.os.RemoteCallback;\nimport android.os.UserHandle;\nimport android.text.Html;\nimport android.text.Spanned;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.Button;\nimport android.widget.ImageView;\nimport android.widget.TextView;\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\nimport androidx.lifecycle.ViewModelProvider;\nimport androidx.preference.Preference;\nimport androidx.preference.PreferenceCategory;\nimport androidx.preference.PreferenceFragmentCompat;\nimport androidx.preference.PreferenceGroup;\nimport androidx.preference.PreferenceScreen;\n\nimport com.android.permissioncontroller.PermissionControllerStatsLog;\nimport com.android.permissioncontroller.R;\nimport com.android.permissioncontroller.permission.model.livedatatypes.LightAppPermGroup;\nimport com.android.permissioncontroller.permission.model.livedatatypes.LightPermission;\nimport com.android.permissioncontroller.permission.ui.ManagePermissionsActivity;\nimport com.android.permissioncontroller.permission.ui.model.v33.ReviewPermissionViewModelFactory;\nimport com.android.permissioncontroller.permission.ui.model.v33.ReviewPermissionsViewModel;\nimport com.android.permissioncontroller.permission.ui.model.v33.ReviewPermissionsViewModel.PermissionTarget;\nimport com.android.permissioncontroller.permission.utils.KotlinUtils;\nimport com.android.permissioncontroller.permission.utils.Utils;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Random;\n\n/**\n * If an app does not support runtime permissions the user is prompted via this fragment to select\n * which permissions to grant to the app before first use and if an update changed the permissions.\n */\npublic final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n        implements View.OnClickListener, PermissionPreference.PermissionPreferenceChangeListener,\n        PermissionPreference.PermissionPreferenceOwnerFragment {\n\n    private static final String EXTRA_PACKAGE_INFO =\n            \"com.android.permissioncontroller.permission.ui.extra.PACKAGE_INFO\";\n    private static final String LOG_TAG = ReviewPermissionsFragment.class.getSimpleName();\n\n    private ReviewPermissionsViewModel mViewModel;\n    private View mView;\n    private Button mContinueButton;\n    private Button mCancelButton;\n    private Button mMoreInfoButton;\n    private PreferenceCategory mNewPermissionsCategory;\n    private PreferenceCategory mCurrentPermissionsCategory;\n\n    private boolean mHasConfirmedRevoke;\n\n    /**\n     * Creates bundle arguments for the navigation graph\n     * @param packageInfo packageInfo added to the bundle\n     * @return the bundle\n     */\n    public static Bundle getArgs(PackageInfo packageInfo) {\n        Bundle arguments = new Bundle();\n        arguments.putParcelable(EXTRA_PACKAGE_INFO, packageInfo);\n        return arguments;\n    }\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n\n        PackageInfo packageInfo = getArguments().getParcelable(EXTRA_PACKAGE_INFO);\n        if (packageInfo == null) {\n            activity.finishAfterTransition();\n            return;\n        }\n\n        ReviewPermissionViewModelFactory factory = new ReviewPermissionViewModelFactory(\n                getActivity().getApplication(), packageInfo);\n        mViewModel = new ViewModelProvider(this, factory).get(ReviewPermissionsViewModel.class);\n        mViewModel.getPermissionGroupsLiveData().observe(this,\n                (Map<String, LightAppPermGroup> permGroupsMap) -> {\n                    if (getActivity().isFinishing()) {\n                        return;\n                    }\n                    if (permGroupsMap.isEmpty()) {\n                        //If the system called for a review but no groups are found, this means\n                        // that all groups are restricted. Hence there is nothing to review\n                        // and instantly continue.\n                        confirmPermissionsReview();\n                        executeCallback(true);\n                        activity.finishAfterTransition();\n                    } else {\n                        bindUi(permGroupsMap);\n                        loadPreferences(permGroupsMap);\n                    }\n                });\n    }\n\n    @Override\n    public void onCreatePreferences(Bundle bundle, String s) {\n        // empty\n    }\n\n    @Override\n    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,\n            @Nullable Bundle savedInstanceState) {\n        mView = inflater.inflate(R.layout.review_permissions, container, false);\n        ViewGroup preferenceRootView = mView.requireViewById(R.id.preferences_frame);\n        View prefsContainer = super.onCreateView(inflater, preferenceRootView, savedInstanceState);\n        preferenceRootView.addView(prefsContainer);\n        return mView;\n    }\n\n    @Override\n    public void onClick(View view) {\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n        if (view == mContinueButton) {\n            confirmPermissionsReview();\n            executeCallback(true);\n        } else if (view == mCancelButton) {\n            executeCallback(false);\n            activity.setResult(Activity.RESULT_CANCELED);\n        } else if (view == mMoreInfoButton) {\n            Intent intent = new Intent(Intent.ACTION_MANAGE_APP_PERMISSIONS);\n            intent.putExtra(Intent.EXTRA_PACKAGE_NAME,\n                    mViewModel.getPackageInfo().packageName);\n            intent.putExtra(Intent.EXTRA_USER, UserHandle.getUserHandleForUid(\n                    mViewModel.getPackageInfo().applicationInfo.uid));\n            intent.putExtra(ManagePermissionsActivity.EXTRA_ALL_PERMISSIONS, true);\n            getActivity().startActivity(intent);\n        }\n        activity.finishAfterTransition();\n    }\n\n    private void confirmPermissionsReview() {\n        final List<PreferenceGroup> preferenceGroups = new ArrayList<>();\n        if (mNewPermissionsCategory != null) {\n            preferenceGroups.add(mNewPermissionsCategory);\n            preferenceGroups.add(mCurrentPermissionsCategory);\n        } else {\n            PreferenceScreen preferenceScreen = getPreferenceScreen();\n            if (preferenceScreen != null) {\n                preferenceGroups.add(preferenceScreen);\n            }\n        }\n\n        final int preferenceGroupCount = preferenceGroups.size();\n        long changeIdForLogging = new Random().nextLong();\n        Application app = getActivity().getApplication();\n        for (int groupNum = 0; groupNum < preferenceGroupCount; groupNum++) {\n            final PreferenceGroup preferenceGroup = preferenceGroups.get(groupNum);\n\n            final int preferenceCount = preferenceGroup.getPreferenceCount();\n            for (int prefNum = 0; prefNum < preferenceCount; prefNum++) {\n                Preference preference = preferenceGroup.getPreference(prefNum);\n                if (preference instanceof PermissionReviewPreference) {\n                    PermissionReviewPreference permPreference =\n                            (PermissionReviewPreference) preference;\n                    LightAppPermGroup group = permPreference.getGroup();\n\n\n                    if (permPreference.getState().and(\n                            PermissionTarget.PERMISSION_FOREGROUND)\n                            != PermissionTarget.PERMISSION_NONE.getValue()) {\n                        KotlinUtils.INSTANCE.grantForegroundRuntimePermissions(app, group);\n                    }\n                    if (permPreference.getState().and(\n                            PermissionTarget.PERMISSION_BACKGROUND)\n                            != PermissionTarget.PERMISSION_NONE.getValue()) {\n                        KotlinUtils.INSTANCE.grantBackgroundRuntimePermissions(app, group);\n                    }\n                    if (permPreference.getState() == PermissionTarget.PERMISSION_NONE) {\n                        KotlinUtils.INSTANCE.revokeForegroundRuntimePermissions(app, group);\n                        KotlinUtils.INSTANCE.revokeBackgroundRuntimePermissions(app, group);\n                    }\n                    logReviewPermissionsFragmentResult(changeIdForLogging, group);\n                }\n            }\n        }\n\n        // Some permission might be restricted and hence there is no AppPermissionGroup for it.\n        // Manually unset all review-required flags, regardless of restriction.\n        PackageManager pm = getContext().getPackageManager();\n        PackageInfo pkg = mViewModel.getPackageInfo();\n        UserHandle user = UserHandle.getUserHandleForUid(pkg.applicationInfo.uid);\n\n        if (pkg.requestedPermissions == null) {\n            // No flag updating to do\n            return;\n        }\n\n        for (String perm : pkg.requestedPermissions) {\n            try {\n                pm.updatePermissionFlags(perm, pkg.packageName,\n                        FLAG_PERMISSION_REVIEW_REQUIRED | FLAG_PERMISSION_USER_SET,\n                        FLAG_PERMISSION_USER_SET, user);\n            } catch (IllegalArgumentException e) {\n                Log.e(LOG_TAG, \"Cannot unmark \" + perm + \" requested by \" + pkg.packageName\n                        + \" as review required\", e);\n            }\n        }\n    }\n\n    private void logReviewPermissionsFragmentResult(long changeId, LightAppPermGroup group) {\n        ArrayList<LightPermission> permissions = new ArrayList<>(\n                group.getAllPermissions().values());\n\n        int numPermissions = permissions.size();\n        for (int i = 0; i < numPermissions; i++) {\n            LightPermission permission = permissions.get(i);\n\n            PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                    changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                    group.getPackageName(),\n                    permission.getName(), permission.isGrantedIncludingAppOp());\n            Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                    + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                    + group.getPackageName() + \" permission=\"\n                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n        }\n    }\n\n    private void bindUi(Map<String, LightAppPermGroup> permGroupsMap) {\n        Activity activity = getActivity();\n        if (activity == null || !mViewModel.isInitialized()) {\n            return;\n        }\n\n        Drawable icon = mViewModel.getPackageInfo().applicationInfo.loadIcon(\n                    getContext().getPackageManager());\n        ImageView iconView = mView.requireViewById(R.id.app_icon);\n        iconView.setImageDrawable(icon);\n\n        // Set message\n        final int labelTemplateResId = mViewModel.isPackageUpdated()\n                ? R.string.permission_review_title_template_update\n                : R.string.permission_review_title_template_install;\n        Spanned message = Html.fromHtml(getString(labelTemplateResId,\n                Utils.getAppLabel(mViewModel.getPackageInfo().applicationInfo,\n                        getActivity().getApplication())), 0);\n        // Set the permission message as the title so it can be announced.\n        activity.setTitle(message.toString());\n\n        // Color the app name.\n        TextView permissionsMessageView = mView.requireViewById(\n                R.id.permissions_message);\n        permissionsMessageView.setText(message);\n\n        mContinueButton = mView.requireViewById(R.id.continue_button);\n        mContinueButton.setOnClickListener(this);\n\n        mCancelButton = mView.requireViewById(R.id.cancel_button);\n        mCancelButton.setOnClickListener(this);\n\n        if (activity.getPackageManager().arePermissionsIndividuallyControlled()) {\n            mMoreInfoButton = mView.requireViewById(\n                    R.id.permission_more_info_button);\n            mMoreInfoButton.setOnClickListener(this);\n            mMoreInfoButton.setVisibility(View.VISIBLE);\n        }\n    }\n\n    private PermissionReviewPreference getPreference(String key) {\n        if (mNewPermissionsCategory != null) {\n            PermissionReviewPreference pref =\n                    mNewPermissionsCategory.findPreference(key);\n\n            if (pref == null && mCurrentPermissionsCategory != null) {\n                return mCurrentPermissionsCategory.findPreference(key);\n            } else {\n                return pref;\n            }\n        } else {\n            return getPreferenceScreen().findPreference(key);\n        }\n    }\n\n    private void loadPreferences(Map<String, LightAppPermGroup> permGroupsMap) {\n        Activity activity = getActivity();\n        if (activity == null || !mViewModel.isInitialized()) {\n            return;\n        }\n\n        PreferenceScreen screen = getPreferenceScreen();\n        if (screen == null) {\n            screen = getPreferenceManager().createPreferenceScreen(getContext());\n            setPreferenceScreen(screen);\n        } else {\n            screen.removeAll();\n        }\n\n        mCurrentPermissionsCategory = null;\n        mNewPermissionsCategory = null;\n\n        final boolean isPackageUpdated = mViewModel.isPackageUpdated();\n\n        for (LightAppPermGroup group : permGroupsMap.values()) {\n            PermissionReviewPreference preference = getPreference(group.getPermGroupName());\n            if (preference == null) {\n                preference = new PermissionReviewPreference(this,\n                        group, this, mViewModel);\n                preference.setKey(group.getPermGroupName());\n                Drawable icon = KotlinUtils.INSTANCE.getPermGroupIcon(getContext(),\n                        group.getPermGroupName());\n                preference.setIcon(icon);\n                preference.setTitle(KotlinUtils.INSTANCE.getPermGroupLabel(getContext(),\n                        group.getPermGroupName()));\n            } else {\n                preference.updateUi();\n            }\n\n            if (group.isReviewRequired()) {\n                if (!isPackageUpdated) {\n                    screen.addPreference(preference);\n                } else {\n                    if (mNewPermissionsCategory == null) {\n                        mNewPermissionsCategory = new PreferenceCategory(activity);\n                        mNewPermissionsCategory.setTitle(R.string.new_permissions_category);\n                        mNewPermissionsCategory.setOrder(1);\n                        screen.addPreference(mNewPermissionsCategory);\n                    }\n                    mNewPermissionsCategory.addPreference(preference);\n                }\n            } else {\n                if (mCurrentPermissionsCategory == null) {\n                    mCurrentPermissionsCategory = new PreferenceCategory(activity);\n                    mCurrentPermissionsCategory.setTitle(R.string.current_permissions_category);\n                    mCurrentPermissionsCategory.setOrder(2);\n                    screen.addPreference(mCurrentPermissionsCategory);\n                }\n                mCurrentPermissionsCategory.addPreference(preference);\n            }\n        }\n    }\n\n    private void executeCallback(boolean success) {\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n        if (success) {\n            IntentSender intent = activity.getIntent().getParcelableExtra(Intent.EXTRA_INTENT);\n            if (intent != null) {\n                try {\n                    int flagMask = 0;\n                    int flagValues = 0;\n                    if (activity.getIntent().getBooleanExtra(\n                            Intent.EXTRA_RESULT_NEEDED, false)) {\n                        flagMask = Intent.FLAG_ACTIVITY_FORWARD_RESULT;\n                        flagValues = Intent.FLAG_ACTIVITY_FORWARD_RESULT;\n                    }\n                    activity.startIntentSenderForResult(intent, -1, null,\n                            flagMask, flagValues, 0);\n                } catch (IntentSender.SendIntentException e) {\n                        /* ignore */\n                }\n                return;\n            }\n        }\n        RemoteCallback callback = activity.getIntent().getParcelableExtra(\n                Intent.EXTRA_REMOTE_CALLBACK);\n        if (callback != null) {\n            Bundle result = new Bundle();\n            result.putBoolean(Intent.EXTRA_RETURN_RESULT, success);\n            callback.sendResult(result);\n        }\n    }\n\n    @Override\n    public boolean shouldConfirmDefaultPermissionRevoke() {\n        return !mHasConfirmedRevoke;\n    }\n\n    @Override\n    public void hasConfirmDefaultPermissionRevoke() {\n        mHasConfirmedRevoke = true;\n    }\n\n    @Override\n    public void onPreferenceChanged(String key) {\n        getPreference(key).setChanged();\n    }\n\n    @Override\n    public void onDenyAnyWay(String key, PermissionTarget changeTarget) {\n        getPreference(key).onDenyAnyWay(changeTarget);\n    }\n\n    @Override\n    public void onBackgroundAccessChosen(String key, int chosenItem) {\n        getPreference(key).onBackgroundAccessChosen(chosenItem);\n    }\n\n    /**\n     * Extend the {@link PermissionPreference}:\n     * <ul>\n     *     <li>Show the description of the permission group</li>\n     *     <li>Show the permission group as granted if the user has not toggled it yet. This means\n     *     that if the user does not touch the preference, we will later grant the permission\n     *     in {@link #confirmPermissionsReview()}.</li>\n     * </ul>\n     */\n    private static class PermissionReviewPreference extends PermissionPreference {\n        private final LightAppPermGroup mGroup;\n        private final Context mContext;\n        private boolean mWasChanged;\n\n        PermissionReviewPreference(PreferenceFragmentCompat fragment, LightAppPermGroup group,\n                PermissionPreferenceChangeListener callbacks,\n                ReviewPermissionsViewModel reviewPermissionsViewModel) {\n            super(fragment, group, callbacks, reviewPermissionsViewModel);\n            mGroup = group;\n            mContext = fragment.getContext();\n            updateUi();\n        }\n\n        LightAppPermGroup getGroup() {\n            return mGroup;\n        }\n\n        /**\n         * Mark the permission as changed by the user\n         */\n        void setChanged() {\n            mWasChanged = true;\n            updateUi();\n        }\n\n        @Override\n        void updateUi() {\n            // updateUi might be called in super-constructor before group is initialized\n            if (mGroup == null) {\n                return;\n            }\n\n            super.updateUi();\n\n            if (isEnabled()) {\n                if (mGroup.isReviewRequired() && !mWasChanged) {\n                    setSummary(KotlinUtils.INSTANCE.getPermGroupDescription(mContext,\n                            mGroup.getPermGroupName()));\n                    setCheckedOverride(true);\n                } else if (TextUtils.isEmpty(getSummary())) {\n                    // Sometimes the summary is already used, e.g. when this for a\n                    // foreground/background group. In this case show leave the original summary.\n                    setSummary(KotlinUtils.INSTANCE.getPermGroupDescription(mContext,\n                            mGroup.getPermGroupName()));\n                }\n            }\n        }\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 3569,
                                        "general": {
                                            "word_based": 1538,
                                            "char_based": 5225
                                        },
                                        "gemini": 4420
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "89aedebdb811ada35a283455a1779026fd84772e",
                            "repo_path": "android_repos/Permission",
                            "result": "failure",
                            "downstream_patch_content": "commit 89aedebdb811ada35a283455a1779026fd84772e\nAuthor: Yi-an Chen <theianchen@google.com>\nDate:   Thu Aug 8 01:15:57 2024 +0000\n\n    Fix Dynamic Permission group auto grant behaivor\n    \n    Fix the Dynamic Permission group auto grant behaivor so that a\n    permission group is only considered granted when (1) all permissions\n    were auto-granted or (2) a platform permission in the same group is\n    granted.\n    \n    Bug: 340480881\n    Test: DynamicPermissionsTest\n    Change-Id: I37b550f0c3933bc790c2917a14e917efbcccc4e8\n    Merged-In: Ia0b5776ecc2110a09f4eeaf54dad82169296a100\n\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt b/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\nindex 6f33cb1993..5c559c0db6 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/data/LightPermInfoLiveData.kt\n@@ -68,7 +68,7 @@ class LightPermInfoLiveData private constructor(\n         }\n \n         val newValue = try {\n-            LightPermInfo(app.packageManager.getPermissionInfo(permissionName, 0))\n+            LightPermInfo(app.packageManager.getPermissionInfo(permissionName, 0), null)\n         } catch (e: PackageManager.NameNotFoundException) {\n             Log.w(LOG_TAG, \"Permission \\\"$permissionName\\\" not found\")\n             invalidateSingle(permissionName)\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt b/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\nindex 78f2f72c63..948815646a 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/data/PermGroupLiveData.kt\n@@ -17,6 +17,7 @@\n package com.android.permissioncontroller.permission.data\n \n import android.app.Application\n+import android.content.pm.ApplicationInfo\n import android.content.pm.PackageItemInfo\n import android.content.pm.PackageManager\n import android.content.pm.PermissionGroupInfo\n@@ -68,32 +69,31 @@ class PermGroupLiveData private constructor(\n      */\n     override fun onUpdate() {\n         val permissionInfos = mutableMapOf<String, LightPermInfo>()\n-\n         groupInfo = Utils.getGroupInfo(groupName, context) ?: run {\n             Log.e(LOG_TAG, \"Invalid permission group $groupName\")\n             invalidateSingle(groupName)\n             value = null\n             return\n         }\n-\n+        val permInfos = mutableListOf<PermissionInfo>()\n         when (groupInfo) {\n             is PermissionGroupInfo -> {\n-                val permInfos = try {\n-                    Utils.getInstalledRuntimePermissionInfosForGroup(context.packageManager,\n-                        groupName)\n+                try {\n+                    permInfos.addAll(\n+                        Utils.getInstalledRuntimePermissionInfosForGroup(\n+                            context.packageManager,\n+                            groupName\n+                        )\n+                    )\n                 } catch (e: PackageManager.NameNotFoundException) {\n                     Log.e(LOG_TAG, \"Invalid permission group $groupName\")\n                     invalidateSingle(groupName)\n                     value = null\n                     return\n                 }\n-\n-                for (permInfo in permInfos) {\n-                    permissionInfos[permInfo.name] = LightPermInfo(permInfo)\n-                }\n             }\n             is PermissionInfo -> {\n-                permissionInfos[groupInfo.name] = LightPermInfo(groupInfo as PermissionInfo)\n+                permInfos.add(groupInfo as PermissionInfo)\n             }\n             else -> {\n                 value = null\n@@ -101,19 +101,25 @@ class PermGroupLiveData private constructor(\n             }\n         }\n \n-        val permGroup = PermGroup(LightPermGroupInfo(groupInfo), permissionInfos)\n-\n-        value = permGroup\n-\n-        val packageNames = permissionInfos.values.map { permInfo -> permInfo.packageName }\n-            .toMutableSet()\n+        val packageNames = permInfos.map { permInfo -> permInfo.packageName }.toMutableSet()\n         packageNames.add(groupInfo.packageName)\n-\n         // TODO ntmyren: What if the package isn't installed for the system user?\n         val getLiveData = { packageName: String ->\n             LightPackageInfoLiveData[packageName, UserHandle.SYSTEM]\n         }\n         setSourcesToDifference(packageNames, packageLiveDatas, getLiveData)\n+        if (!packageLiveDatas.all { it.value.isInitialized }) {\n+            return\n+        }\n+        for (permInfo in permInfos) {\n+            val lightPackageInfo = packageLiveDatas[permInfo.packageName]?.value\n+            val isSystem =\n+                lightPackageInfo?.let { it.appFlags and ApplicationInfo.FLAG_SYSTEM != 0 }\n+            permissionInfos[permInfo.name] = LightPermInfo(permInfo, isSystem)\n+        }\n+\n+        val permGroup = PermGroup(LightPermGroupInfo(groupInfo), permissionInfos)\n+        value = permGroup\n     }\n \n     override fun onInactive() {\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\nindex 3c87f0b7af..e98f01e478 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightAppPermGroup.kt\n@@ -20,6 +20,7 @@ import android.Manifest\n import android.Manifest.permission.ACCESS_COARSE_LOCATION\n import android.os.Build\n import android.os.UserHandle\n+import com.android.permissioncontroller.permission.utils.Utils\n \n /**\n  * A lightweight version of the AppPermissionGroup data structure. Represents information about a\n@@ -82,11 +83,13 @@ data class LightAppPermGroup(\n         if (name !in backgroundPermNames) name else null\n     }\n \n+    val isPlatformPermissionGroup = permGroupInfo.packageName == Utils.OS_PKG\n+\n     val foreground = AppPermSubGroup(permissions.filter { it.key in foregroundPermNames },\n-        packageInfo, specialLocationGrant)\n+        packageInfo, isPlatformPermissionGroup, specialLocationGrant)\n \n     val background = AppPermSubGroup(permissions.filter { it.key in backgroundPermNames },\n-        packageInfo, specialLocationGrant)\n+        packageInfo, isPlatformPermissionGroup, specialLocationGrant)\n \n     /**\n      * Whether or not this App Permission Group has a permission which has a background mode\n@@ -127,7 +130,7 @@ data class LightAppPermGroup(\n      */\n     val isOneTime = (permGroupName != Manifest.permission_group.LOCATION &&\n             permissions.any { it.value.isOneTime } &&\n-            permissions.none { !it.value.isOneTime && it.value.isGrantedIncludingAppOp }) ||\n+            permissions.none { !it.value.isOneTime && it.value.isGranted }) ||\n             (permGroupName == Manifest.permission_group.LOCATION &&\n                     permissions[ACCESS_COARSE_LOCATION]?.isOneTime == true)\n \n@@ -182,17 +185,23 @@ data class LightAppPermGroup(\n      *\n      * @param permissions The permissions contained within this subgroup, a subset of those contained\n      * in the full group\n+     * @param isPlatformPermissionGroup Whether this is a platform permission group\n      * @param specialLocationGrant Whether this is a special location package\n      */\n     data class AppPermSubGroup internal constructor(\n         private val permissions: Map<String, LightPermission>,\n         private val packageInfo: LightPackageInfo,\n+        private val isPlatformPermissionGroup: Boolean,\n         private val specialLocationGrant: Boolean?\n     ) {\n-        /**\n-         * Whether any of this App Permission SubGroup's permissions are granted\n-         */\n-        val isGranted = specialLocationGrant ?: permissions.any { it.value.isGrantedIncludingAppOp }\n+        /** Whether any of this App Permission SubGroup's permissions are granted */\n+        val isGranted =\n+            specialLocationGrant\n+                ?: permissions.any {\n+                    val mayGrantByPlatformOrSystem =\n+                        !isPlatformPermissionGroup || it.value.isPlatformOrSystem\n+                    it.value.isGranted && mayGrantByPlatformOrSystem\n+                }\n \n         /**\n          * Whether this App Permission SubGroup should be treated as granted. This means either:\n@@ -201,9 +210,15 @@ data class LightAppPermGroup(\n          * 2) All permissions were auto-granted (all permissions are all granted and all\n          * RevokeWhenRequested.)\n          */\n-        val isGrantedExcludingRWROrAllRWR = specialLocationGrant ?: (permissions\n-            .any { it.value.isGrantedIncludingAppOp && !it.value.isRevokeWhenRequested } ||\n-            permissions.all { it.value.isGrantedIncludingAppOp && it.value.isRevokeWhenRequested })\n+        val allowFullGroupGrant =\n+            specialLocationGrant\n+                ?: (permissions.any {\n+                    val mayGrantByPlatformOrSystem =\n+                        !isPlatformPermissionGroup || it.value.isPlatformOrSystem\n+                    it.value.allowFullGroupGrant && mayGrantByPlatformOrSystem\n+                } || permissions.all {\n+                    it.value.isGranted && it.value.isRevokeWhenRequested\n+                })\n \n         /**\n          * Whether any of this App Permission SubGroup's permissions are granted by default\n@@ -215,7 +230,7 @@ data class LightAppPermGroup(\n          * none of the granted permissions are not one-time.\n          */\n         val isOneTime = permissions.any { it.value.isOneTime } &&\n-                permissions.none { it.value.isGrantedIncludingAppOp && !it.value.isOneTime }\n+                permissions.none { it.value.isGranted && !it.value.isOneTime }\n \n         /**\n          * Whether any of this App Permission Subgroup's foreground permissions are fixed by policy\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\nindex 0f6b6c000c..cb6c47c761 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPackageInfo.kt\n@@ -58,7 +58,9 @@ data class LightPackageInfo(\n         pI: PackageInfo\n     ) : this(\n         pI.packageName,\n-        pI.permissions?.map { perm -> LightPermInfo(perm) } ?: emptyList(),\n+        pI.permissions?.map { perm ->\n+            LightPermInfo(perm, pI.applicationInfo!!.flags and ApplicationInfo.FLAG_SYSTEM != 0)\n+        } ?: emptyList(),\n         pI.requestedPermissions?.toList() ?: emptyList(),\n         pI.requestedPermissionsFlags?.toList() ?: emptyList(),\n         pI.applicationInfo.uid,\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\nindex 3954b74722..582742da43 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermInfo.kt\n@@ -30,6 +30,7 @@ import android.content.pm.PermissionInfo\n  * @param protection The protection level of this permission\n  * @param protection Extra information about the protection of this permission\n  * @param flags The system flags of this permission\n+ * @param isSystem Whether this permission is defined by a system app\n  */\n data class LightPermInfo(\n     val name: String,\n@@ -38,11 +39,13 @@ data class LightPermInfo(\n     val backgroundPermission: String?,\n     val protection: Int,\n     val protectionFlags: Int,\n-    val flags: Int\n+    val flags: Int,\n+    val isSystem: Boolean?\n ) {\n-    constructor (permInfo: PermissionInfo): this(permInfo.name, permInfo.packageName,\n-        permInfo.group, permInfo.backgroundPermission, permInfo.protection,\n-        permInfo.protectionFlags, permInfo.flags)\n+    constructor (permInfo: PermissionInfo, isSystem: Boolean?) : this(\n+        permInfo.name, permInfo.packageName, permInfo.group, permInfo.backgroundPermission,\n+        permInfo.protection, permInfo.protectionFlags, permInfo.flags, isSystem\n+    )\n \n     /**\n      * Gets the PermissionInfo for this permission from the system.\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\nindex fd7d82dfcb..0ee60e5bff 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/model/livedatatypes/LightPermission.kt\n@@ -28,7 +28,7 @@ import com.android.permissioncontroller.permission.utils.Utils\n  *\n  * @param pkgInfo The package requesting the permission\n  * @param permInfo The permissionInfo this represents\n- * @param isGrantedIncludingAppOp Whether or not this permission is functionally granted.\n+ * @param isGranted Whether or not this permission is functionally granted.\n  * A non-granted app op but granted permission is counted as not granted\n  * @param flags The PermissionController flags for this permission\n  * @param foregroundPerms The foreground permission names corresponding to this permission, if this\n@@ -37,7 +37,7 @@ import com.android.permissioncontroller.permission.utils.Utils\n data class LightPermission(\n     val pkgInfo: LightPackageInfo,\n     val permInfo: LightPermInfo,\n-    val isGrantedIncludingAppOp: Boolean,\n+    val isGranted: Boolean,\n     val flags: Int,\n     val foregroundPerms: List<String>?\n ) {\n@@ -97,9 +97,9 @@ data class LightPermission(\n     val isRevokeWhenRequested = flags and PackageManager.FLAG_PERMISSION_REVOKE_WHEN_REQUESTED != 0\n     /** Whether this permission is user sensitive in its current grant state */\n     val isUserSensitive = !isRuntimePlatformPermission(permInfo.name) ||\n-            (isGrantedIncludingAppOp &&\n+            (isGranted &&\n                     (flags and PackageManager.FLAG_PERMISSION_USER_SENSITIVE_WHEN_GRANTED) != 0) ||\n-            (!isGrantedIncludingAppOp &&\n+            (!isGranted &&\n                     (flags and PackageManager.FLAG_PERMISSION_USER_SENSITIVE_WHEN_DENIED) != 0)\n     /** Whether the permission is restricted */\n     val isRestricted = when {\n@@ -120,10 +120,17 @@ data class LightPermission(\n      */\n     val isSelectedLocationAccuracy =\n         flags and PackageManager.FLAG_PERMISSION_SELECTED_LOCATION_ACCURACY != 0\n+    /** Whether this permission is defined by platform or a system app */\n+    val isPlatformOrSystem = permInfo.packageName == Utils.OS_PKG || permInfo.isSystem == true\n+    /**\n+     * Whether this permission is granted including app op and does not hold the\n+     * PackageManager.FLAG_PERMISSION_REVOKE_WHEN_REQUESTED flag.\n+     */\n+    val allowFullGroupGrant = isGranted && !isRevokeWhenRequested\n \n     override fun toString() = buildString {\n         append(name)\n-        if (isGrantedIncludingAppOp) append(\", Granted\") else append(\", NotGranted\")\n+        if (isGranted) append(\", Granted\") else append(\", NotGranted\")\n         if (isPolicyFixed) append(\", PolicyFixed\")\n         if (isSystemFixed) append(\", SystemFixed\")\n         if (isUserFixed) append(\", UserFixed\")\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt b/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\nindex ae9ccf19ed..3845a73dc3 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/service/AutoRevokePermissions.kt\n@@ -114,7 +114,7 @@ suspend fun revokeAppPermissions(\n                         .getInitializedValue() ?: continue\n                 val fixed = group.isBackgroundFixed || group.isForegroundFixed\n                 val granted = group.permissions.any { (_, perm) ->\n-                    perm.isGrantedIncludingAppOp && perm.name !in EXEMPT_PERMISSIONS\n+                    perm.isGranted && perm.name !in EXEMPT_PERMISSIONS\n                 }\n                 if (!fixed && granted &&\n                     !group.isGrantedByDefault &&\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt b/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\nindex 3405ab0144..19b2b4803e 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/service/RuntimePermissionsUpgradeController.kt\n@@ -412,7 +412,7 @@ internal object RuntimePermissionsUpgradeController {\n \n                 val allPermissionsWithxemption = bgApp.allPermissions.toMutableMap()\n                 allPermissionsWithxemption[permission.ACCESS_BACKGROUND_LOCATION] =\n-                        LightPermission(perm.pkgInfo, perm.permInfo, perm.isGrantedIncludingAppOp,\n+                        LightPermission(perm.pkgInfo, perm.permInfo, perm.isGranted,\n                         perm.flags or FLAG_PERMISSION_RESTRICTION_UPGRADE_EXEMPT,\n                         perm.foregroundPerms)\n \n@@ -474,7 +474,7 @@ internal object RuntimePermissionsUpgradeController {\n                             ?: continue\n \n                     if (!perm.isUserSet && !perm.isSystemFixed && !perm.isPolicyFixed &&\n-                            !perm.isGrantedIncludingAppOp) {\n+                            !perm.isGranted) {\n                         grants.add(Grant(false, appPermGroup,\n                                 listOf(permission.ACCESS_MEDIA_LOCATION)))\n                     }\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java b/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\nindex 5e5c221aec..74719ef9f5 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n@@ -257,11 +257,11 @@ public final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }\n \ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\nindex 99b40d8a79..169cc72227 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/AppPermissionViewModel.kt\n@@ -501,9 +501,9 @@ class AppPermissionViewModel(\n             // 2. Else if FINE or COARSE have the isSelectedLocationAccuracy flag set, then return\n             //    true if FINE isSelectedLocationAccuracy is set.\n             // 3. Else, return default precision from device config.\n-            return if (fineLocation.isGrantedIncludingAppOp ||\n-                            coarseLocation.isGrantedIncludingAppOp) {\n-                fineLocation.isGrantedIncludingAppOp\n+            return if (fineLocation.isGranted ||\n+                            coarseLocation.isGranted) {\n+                fineLocation.isGranted\n             } else if (fineLocation.isSelectedLocationAccuracy ||\n                             coarseLocation.isSelectedLocationAccuracy) {\n                 fineLocation.isSelectedLocationAccuracy\n@@ -1040,7 +1040,7 @@ class AppPermissionViewModel(\n \n     private fun getIndividualPermissionDetailResId(group: LightAppPermGroup): Pair<Int, Int> {\n         return when (val numRevoked =\n-            group.permissions.filter { !it.value.isGrantedIncludingAppOp }.size) {\n+            group.permissions.filter { !it.value.isGranted }.size) {\n             0 -> R.string.permission_revoked_none to numRevoked\n             group.permissions.size -> R.string.permission_revoked_all to numRevoked\n             else -> R.string.permission_revoked_count to numRevoked\n@@ -1110,11 +1110,11 @@ class AppPermissionViewModel(\n         for ((permName, permission) in oldGroup.permissions) {\n             val newPermission = newGroup.permissions[permName] ?: continue\n \n-            if (permission.isGrantedIncludingAppOp != newPermission.isGrantedIncludingAppOp ||\n+            if (permission.isGranted != newPermission.isGranted ||\n                 permission.flags != newPermission.flags) {\n                 logAppPermissionFragmentActionReported(changeId, newPermission, buttonPressed)\n                 PermissionDecisionStorageImpl.recordPermissionDecision(app.applicationContext,\n-                    packageName, permGroupName, newPermission.isGrantedIncludingAppOp)\n+                    packageName, permGroupName, newPermission.isGranted)\n                 PermissionChangeStorageImpl.recordPermissionChange(packageName)\n             }\n         }\n@@ -1138,10 +1138,10 @@ class AppPermissionViewModel(\n         val uid = KotlinUtils.getPackageUid(app, packageName, user) ?: return\n         PermissionControllerStatsLog.write(APP_PERMISSION_FRAGMENT_ACTION_REPORTED, sessionId,\n             changeId, uid, packageName, permission.permInfo.name,\n-            permission.isGrantedIncludingAppOp, permission.flags, buttonPressed)\n+            permission.isGranted, permission.flags, buttonPressed)\n         Log.v(LOG_TAG, \"Permission changed via UI with sessionId=$sessionId changeId=\" +\n             \"$changeId uid=$uid packageName=$packageName permission=\" + permission.permInfo.name +\n-            \" isGranted=\" + permission.isGrantedIncludingAppOp + \" permissionFlags=\" +\n+            \" isGranted=\" + permission.isGranted + \" permissionFlags=\" +\n             permission.flags + \" buttonPressed=$buttonPressed\")\n     }\n \n@@ -1178,7 +1178,7 @@ class AppPermissionViewModel(\n         val partialPerms = getPartialStorageGrantPermissionsForGroup(group)\n \n         return group.isGranted && group.permissions.values.all {\n-            it.name in partialPerms || (it.name !in partialPerms && !it.isGrantedIncludingAppOp)\n+            it.name in partialPerms || (it.name !in partialPerms && !it.isGranted)\n         }\n     }\n }\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\nindex 0680ffcd29..3891550f05 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/GrantPermissionsViewModel.kt\n@@ -301,7 +301,7 @@ class GrantPermissionsViewModel(\n                 if (states.isNotEmpty()) {\n                     for ((key, state) in states) {\n                         val allAffectedGranted = state.affectedPermissions.all { perm ->\n-                            appPermGroup.permissions[perm]?.isGrantedIncludingAppOp == true &&\n+                            appPermGroup.permissions[perm]?.isGranted == true &&\n                                 appPermGroup.permissions[perm]?.isRevokeWhenRequested == false\n                         }\n                         if (allAffectedGranted) {\n@@ -340,7 +340,7 @@ class GrantPermissionsViewModel(\n                     for (perm in fgState.affectedPermissions) {\n                         minSdkForOrderedSplitPermissions = maxOf(minSdkForOrderedSplitPermissions,\n                                 splitPermissionTargetSdkMap.getOrDefault(perm, 0))\n-                        if (fgGroup.permissions[perm]?.isGrantedIncludingAppOp == false) {\n+                        if (fgGroup.permissions[perm]?.isGranted == false) {\n                             // If any of the requested permissions is not granted,\n                             // needFgPermissions = true\n                             needFgPermissions = true\n@@ -373,7 +373,7 @@ class GrantPermissionsViewModel(\n                     // If the USER_SELECTED permission is user fixed and granted, or the app is only\n                     // requesting USER_SELECTED, direct straight to photo picker\n                     val userPerm = groupState.group.permissions[READ_MEDIA_VISUAL_USER_SELECTED]\n-                    if ((userPerm?.isUserFixed == true && userPerm.isGrantedIncludingAppOp) ||\n+                    if ((userPerm?.isUserFixed == true && userPerm.isGranted) ||\n                         groupState.affectedPermissions == listOf(READ_MEDIA_VISUAL_USER_SELECTED)) {\n                         requestInfos.add(RequestInfo(groupInfo, openPhotoPicker = true))\n                         continue\n@@ -524,7 +524,7 @@ class GrantPermissionsViewModel(\n                                 fgState.affectedPermissions.contains(ACCESS_FINE_LOCATION)) {\n                             val coarseLocationPerm =\n                                 groupState.group.allPermissions[ACCESS_COARSE_LOCATION]\n-                            if (coarseLocationPerm?.isGrantedIncludingAppOp == true) {\n+                            if (coarseLocationPerm?.isGranted == true) {\n                                 // Upgrade flow\n                                 locationVisibilities[DIALOG_WITH_FINE_LOCATION_ONLY] = true\n                                 message = RequestMessage.FG_FINE_LOCATION_MESSAGE\n@@ -773,7 +773,7 @@ class GrantPermissionsViewModel(\n                     return true\n                 }\n             } else if (perm in getPartialStorageGrantPermissionsForGroup(group) &&\n-                lightPermission.isGrantedIncludingAppOp) {\n+                lightPermission.isGranted) {\n                 // If a partial storage permission is granted as fixed, we should immediately show\n                 // the photo picker\n                 return true\n@@ -825,7 +825,7 @@ class GrantPermissionsViewModel(\n \n         // Do not attempt to grant background access if foreground access is not either already\n         // granted or requested\n-        if (isBackground && !group.foreground.isGrantedExcludingRWROrAllRWR &&\n+        if (isBackground && !group.foreground.allowFullGroupGrant &&\n             !hasForegroundRequest) {\n             Log.w(LOG_TAG, \"Cannot grant $perm as the matching foreground permission is not \" +\n                 \"already granted.\")\n@@ -837,10 +837,10 @@ class GrantPermissionsViewModel(\n             return STATE_SKIPPED\n         }\n \n-        if ((isBackground && group.background.isGrantedExcludingRWROrAllRWR ||\n-            !isBackground && group.foreground.isGrantedExcludingRWROrAllRWR) &&\n+        if ((isBackground && group.background.allowFullGroupGrant ||\n+            !isBackground && group.foreground.allowFullGroupGrant) &&\n             canAutoGrantWholeGroup(group)) {\n-            if (group.permissions[perm]?.isGrantedIncludingAppOp == false) {\n+            if (group.permissions[perm]?.isGranted == false) {\n                 if (isBackground) {\n                     grantBackgroundRuntimePermissions(app, group, listOf(perm))\n                 } else {\n@@ -869,7 +869,7 @@ class GrantPermissionsViewModel(\n         // If FINE location is not granted, do not grant it automatically when COARSE\n         // location is already granted.\n         if (group.permGroupName == LOCATION &&\n-            group.allPermissions[ACCESS_FINE_LOCATION]?.isGrantedIncludingAppOp == false) {\n+            group.allPermissions[ACCESS_FINE_LOCATION]?.isGranted == false) {\n             return false\n         }\n         // If READ_MEDIA_VISUAL_USER_SELECTED is the only permission in the group that is granted,\n@@ -893,7 +893,7 @@ class GrantPermissionsViewModel(\n \n         val partialPerms = getPartialStorageGrantPermissionsForGroup(group)\n         return group.isGranted && group.permissions.values.all {\n-            it.name in partialPerms || (it.name !in partialPerms && !it.isGrantedIncludingAppOp)\n+            it.name in partialPerms || (it.name !in partialPerms && !it.isGranted)\n         }\n     }\n \n@@ -1114,28 +1114,39 @@ class GrantPermissionsViewModel(\n             } else {\n                 PERMISSION_GRANT_REQUEST_RESULT_REPORTED__RESULT__USER_GRANTED\n             }\n+            var affectedPermissions: List<String> = groupState.affectedPermissions\n             if (groupState.isBackground) {\n-                grantBackgroundRuntimePermissions(app, groupState.group,\n-                    groupState.affectedPermissions)\n+                grantBackgroundRuntimePermissions(app, groupState.group, affectedPermissions)\n             } else {\n                 if (affectedForegroundPermissions == null) {\n                     grantForegroundRuntimePermissions(app, groupState.group,\n-                        groupState.affectedPermissions, isOneTime)\n+                        affectedPermissions, isOneTime)\n                     // This prevents weird flag state when app targetSDK switches from S+ to R-\n                     if (groupState.affectedPermissions.contains(ACCESS_FINE_LOCATION)) {\n                         KotlinUtils.setFlagsWhenLocationAccuracyChanged(\n                                 app, groupState.group, true)\n                     }\n                 } else {\n+                    affectedPermissions = affectedForegroundPermissions\n                     val newGroup = grantForegroundRuntimePermissions(app,\n-                            groupState.group, affectedForegroundPermissions, isOneTime)\n+                            groupState.group, affectedPermissions, isOneTime)\n                     if (!isOneTime || newGroup.isOneTime) {\n                         KotlinUtils.setFlagsWhenLocationAccuracyChanged(app, newGroup,\n                                 affectedForegroundPermissions.contains(ACCESS_FINE_LOCATION))\n                     }\n                 }\n             }\n-            groupState.state = STATE_ALLOWED\n+            val shouldDenyFullGroupGrant =\n+                groupState.group.isPlatformPermissionGroup &&\n+                        affectedPermissions.none {\n+                            groupState.group.permissions[it]?.isPlatformOrSystem == true\n+                        }\n+            groupState.state =\n+                if (shouldDenyFullGroupGrant) {\n+                    STATE_UNKNOWN\n+                } else {\n+                    STATE_ALLOWED\n+                }\n         } else {\n             if (groupState.isBackground) {\n                 revokeBackgroundRuntimePermissions(app, groupState.group,\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/ReviewPermissionsViewModel.kt b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/ReviewPermissionsViewModel.kt\nindex 4e1fc1861d..7431637a83 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/model/ReviewPermissionsViewModel.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/model/ReviewPermissionsViewModel.kt\n@@ -135,7 +135,7 @@ class ReviewPermissionsViewModel(\n         val lightPerms = permGroup.allPermissions.values.toList()\n         val permissionCount = lightPerms.size\n         for (i in 0 until permissionCount) {\n-            if (!lightPerms[i].isGrantedIncludingAppOp) {\n+            if (!lightPerms[i].isGranted) {\n                 revokedCount++\n             }\n         }\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt b/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\nindex f9345ef58f..fb188fca12 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/utils/KotlinUtils.kt\n@@ -694,7 +694,7 @@ object KotlinUtils {\n                     group.userHandle, *flags)\n             }\n             newPerms[permName] = LightPermission(group.packageInfo, perm.permInfo,\n-                perm.isGrantedIncludingAppOp, perm.flags or flagsToSet, perm.foregroundPerms)\n+                perm.isGranted, perm.flags or flagsToSet, perm.foregroundPerms)\n         }\n         return LightAppPermGroup(group.packageInfo, group.permGroupInfo, newPerms,\n             group.hasInstallToRuntimeSplit, group.specialLocationGrant)\n@@ -790,7 +790,7 @@ object KotlinUtils {\n         val newGroup = LightAppPermGroup(group.packageInfo, group.permGroupInfo, newPerms,\n             group.hasInstallToRuntimeSplit, group.specialLocationGrant)\n         // If any permission in the group is one time granted, start one time permission session.\n-        if (newGroup.permissions.any { it.value.isOneTime && it.value.isGrantedIncludingAppOp }) {\n+        if (newGroup.permissions.any { it.value.isOneTime && it.value.isGranted }) {\n             if (SdkLevel.isAtLeastT()) {\n                 app.getSystemService(PermissionManager::class.java)!!.startOneTimePermissionSession(\n                         group.packageName, Utils.getOneTimePermissionsTimeout(),\n@@ -842,11 +842,11 @@ object KotlinUtils {\n \n         var newFlags = perm.flags\n         var oldFlags = perm.flags\n-        var isGranted = perm.isGrantedIncludingAppOp\n+        var isGranted = perm.isGranted\n         var shouldKill = false\n \n         // Grant the permission if needed.\n-        if (!perm.isGrantedIncludingAppOp) {\n+        if (!perm.isGranted) {\n             val affectsAppOp = permissionToOp(perm.name) != null || perm.isBackgroundPermission\n \n             // TODO 195016052: investigate adding split permission handling\n@@ -906,14 +906,14 @@ object KotlinUtils {\n \n         // If we newly grant background access to the fine location, double-guess the user some\n         // time later if this was really the right choice.\n-        if (!perm.isGrantedIncludingAppOp && isGranted) {\n+        if (!perm.isGranted && isGranted) {\n             var triggerLocationAccessCheck = false\n             if (perm.name == ACCESS_FINE_LOCATION) {\n                 val bgPerm = group.permissions[perm.backgroundPermission]\n-                triggerLocationAccessCheck = bgPerm?.isGrantedIncludingAppOp == true\n+                triggerLocationAccessCheck = bgPerm?.isGranted == true\n             } else if (perm.name == ACCESS_BACKGROUND_LOCATION) {\n                 val fgPerm = group.permissions[ACCESS_FINE_LOCATION]\n-                triggerLocationAccessCheck = fgPerm?.isGrantedIncludingAppOp == true\n+                triggerLocationAccessCheck = fgPerm?.isGranted == true\n             }\n             if (triggerLocationAccessCheck) {\n                 // trigger location access check\n@@ -1113,13 +1113,13 @@ object KotlinUtils {\n \n         val user = UserHandle.getUserHandleForUid(group.packageInfo.uid)\n         var newFlags = perm.flags\n-        var isGranted = perm.isGrantedIncludingAppOp\n+        var isGranted = perm.isGranted\n         val supportsRuntime = group.packageInfo.targetSdkVersion >= Build.VERSION_CODES.M\n         var shouldKill = false\n \n         val affectsAppOp = permissionToOp(perm.name) != null || perm.isBackgroundPermission\n \n-        if (perm.isGrantedIncludingAppOp || (perm.isCompatRevoked && forceRemoveRevokedCompat)) {\n+        if (perm.isGranted || (perm.isCompatRevoked && forceRemoveRevokedCompat)) {\n             if (supportsRuntime && !isPermissionSplitFromNonRuntime(app, perm.name,\n                             group.packageInfo.targetSdkVersion)) {\n                 // Revoke the permission if needed.\n@@ -1165,14 +1165,14 @@ object KotlinUtils {\n \n         // If we revoke background access to the fine location, we trigger a check to remove\n         // notification warning about background location access\n-        if (perm.isGrantedIncludingAppOp && !isGranted) {\n+        if (perm.isGranted && !isGranted) {\n             var cancelLocationAccessWarning = false\n             if (perm.name == ACCESS_FINE_LOCATION) {\n                 val bgPerm = group.permissions[perm.backgroundPermission]\n-                cancelLocationAccessWarning = bgPerm?.isGrantedIncludingAppOp == true\n+                cancelLocationAccessWarning = bgPerm?.isGranted == true\n             } else if (perm.name == ACCESS_BACKGROUND_LOCATION) {\n                 val fgPerm = group.permissions[ACCESS_FINE_LOCATION]\n-                cancelLocationAccessWarning = fgPerm?.isGrantedIncludingAppOp == true\n+                cancelLocationAccessWarning = fgPerm?.isGranted == true\n             }\n             if (cancelLocationAccessWarning) {\n                 // cancel location access warning notification\n@@ -1238,7 +1238,7 @@ object KotlinUtils {\n                 val fgPerm = group.permissions[foregroundPermName]\n                 val appOpName = permissionToOp(foregroundPermName) ?: continue\n \n-                if (fgPerm != null && fgPerm.isGrantedIncludingAppOp) {\n+                if (fgPerm != null && fgPerm.isGranted) {\n                     wasChanged = setOpMode(appOpName, uid, packageName, MODE_ALLOWED,\n                         appOpsManager) || wasChanged\n                 }\n@@ -1248,7 +1248,7 @@ object KotlinUtils {\n             if (perm.backgroundPermission != null) {\n                 wasChanged = if (group.permissions.containsKey(perm.backgroundPermission)) {\n                     val bgPerm = group.permissions[perm.backgroundPermission]\n-                    val mode = if (bgPerm != null && bgPerm.isGrantedIncludingAppOp) MODE_ALLOWED\n+                    val mode = if (bgPerm != null && bgPerm.isGranted) MODE_ALLOWED\n                     else MODE_FOREGROUND\n \n                     setOpMode(appOpName, uid, packageName, mode, appOpsManager)\n@@ -1299,7 +1299,7 @@ object KotlinUtils {\n         if (perm.isBackgroundPermission && perm.foregroundPerms != null) {\n             for (foregroundPermName in perm.foregroundPerms) {\n                 val fgPerm = group.permissions[foregroundPermName]\n-                if (fgPerm != null && fgPerm.isGrantedIncludingAppOp) {\n+                if (fgPerm != null && fgPerm.isGranted) {\n                     val appOpName = permissionToOp(foregroundPermName) ?: return false\n                     wasChanged = wasChanged || setOpMode(appOpName, uid, packageName,\n                         MODE_FOREGROUND, appOpsManager)\ndiff --git a/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java b/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\nindex 828857cc6d..c9b023c443 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java\n@@ -95,7 +95,7 @@ public final class SafetyNetLogger {\n             }\n \n             builder.append(permission.getName()).append('|');\n-            builder.append(permission.isGrantedIncludingAppOp()).append('|');\n+            builder.append(permission.isGranted()).append('|');\n             builder.append(permission.getFlags());\n         }\n     }\ndiff --git a/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/ui/model/ReviewPermissionsViewModelTest.kt b/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/ui/model/ReviewPermissionsViewModelTest.kt\nindex 0f42160663..55aa40e50c 100644\n--- a/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/ui/model/ReviewPermissionsViewModelTest.kt\n+++ b/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/ui/model/ReviewPermissionsViewModelTest.kt\n@@ -110,7 +110,7 @@ class ReviewPermissionsViewModelTest {\n         permissionsMap[\"mockedPermission1\"] = permission2\n \n         whenever(permGroup.allPermissions).thenReturn(permissionsMap)\n-        whenever(permission1.isGrantedIncludingAppOp).thenReturn(true)\n+        whenever(permission1.isGranted).thenReturn(true)\n \n         val summary = model.getSummaryForIndividuallyControlledPermGroup(permGroup)\n         assertEquals(\ndiff --git a/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/utils/GrantRevokeTests.kt b/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/utils/GrantRevokeTests.kt\nindex be6518b235..c688273c6c 100644\n--- a/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/utils/GrantRevokeTests.kt\n+++ b/PermissionController/tests/mocking/src/com/android/permissioncontroller/tests/mocking/permission/utils/GrantRevokeTests.kt\n@@ -24,6 +24,7 @@ import android.app.AppOpsManager.MODE_FOREGROUND\n import android.app.AppOpsManager.MODE_IGNORED\n import android.app.AppOpsManager.permissionToOp\n import android.app.Application\n+import android.content.pm.ApplicationInfo\n import android.content.pm.PackageManager\n import android.content.pm.PackageManager.FLAG_PERMISSION_AUTO_REVOKED\n import android.content.pm.PackageManager.FLAG_PERMISSION_ONE_TIME\n@@ -180,7 +181,8 @@ class GrantRevokeTests {\n         permInfoProtectionFlags: Int = 0\n     ): LightPermission {\n         val permInfo = LightPermInfo(permName, TEST_PACKAGE_NAME, PERM_GROUP_NAME, backgroundPerm,\n-            PermissionInfo.PROTECTION_DANGEROUS, permInfoProtectionFlags, 0)\n+            PermissionInfo.PROTECTION_DANGEROUS, permInfoProtectionFlags, 0,\n+            pkgInfo.appFlags and ApplicationInfo.FLAG_SYSTEM != 0)\n         return LightPermission(pkgInfo, permInfo,\n                 pkgInfo.requestedPermissionsFlags[pkgInfo.requestedPermissions.indexOf(permName)]\n                         == PERMISSION_GRANTED, flags, foregroundPerms)\n@@ -251,7 +253,7 @@ class GrantRevokeTests {\n             val flags = state.second\n \n             assertWithMessage(\"permission $permName grant state incorrect\")\n-                .that(perms[permName]?.isGrantedIncludingAppOp).isEqualTo(granted)\n+                .that(perms[permName]?.isGranted).isEqualTo(granted)\n \n             val actualFlags = perms[permName]!!.flags\n             assertWithMessage(\"permission $permName flags incorrect, expected\" +\n",
                            "downstream_patch_tokens": {
                                "openai": 9173,
                                "general": {
                                    "word_based": 3633,
                                    "char_based": 10984
                                },
                                "gemini": 11084
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java",
                                    "total_hunks": 1,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [],
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    },
                                    "rej_file_content": "```diff\n--- PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n+++ PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n@@ -267,11 +267,11 @@ public final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.i(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }\n```",
                                    "rej_file_tokens": {
                                        "openai": 203,
                                        "general": {
                                            "word_based": 77,
                                            "char_based": 289
                                        },
                                        "gemini": 250
                                    },
                                    "patch_apply_output": "patching file PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\nHunk #1 FAILED at 267.\n1 out of 1 hunk FAILED -- saving rejects to file PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java.rej\npatching file PermissionController/src/com/android/permissioncontroller/permission/utils/SafetyNetLogger.java",
                                    "inline_merge_output": "patching file PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\nHunk #1 already applied at 270,274.",
                                    "upstream_file_tokens": {
                                        "openai": 3650,
                                        "general": {
                                            "word_based": 1580,
                                            "char_based": 5344
                                        },
                                        "gemini": 4529
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.permissioncontroller.permission.ui.handheld;\n\nimport static android.content.pm.PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED;\nimport static android.content.pm.PackageManager.FLAG_PERMISSION_USER_SET;\n\nimport static com.android.permissioncontroller.PermissionControllerStatsLog.REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED;\n\nimport android.app.Activity;\nimport android.app.Application;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentSender;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.graphics.drawable.Drawable;\nimport android.os.Bundle;\nimport android.os.RemoteCallback;\nimport android.os.UserHandle;\nimport android.text.Html;\nimport android.text.Spanned;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.Button;\nimport android.widget.ImageView;\nimport android.widget.TextView;\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\nimport androidx.lifecycle.ViewModelProvider;\nimport androidx.preference.Preference;\nimport androidx.preference.PreferenceCategory;\nimport androidx.preference.PreferenceFragmentCompat;\nimport androidx.preference.PreferenceGroup;\nimport androidx.preference.PreferenceScreen;\n\nimport com.android.permissioncontroller.PermissionControllerStatsLog;\nimport com.android.permissioncontroller.R;\nimport com.android.permissioncontroller.permission.model.livedatatypes.LightAppPermGroup;\nimport com.android.permissioncontroller.permission.model.livedatatypes.LightPermission;\nimport com.android.permissioncontroller.permission.ui.ManagePermissionsActivity;\nimport com.android.permissioncontroller.permission.ui.model.ReviewPermissionViewModelFactory;\nimport com.android.permissioncontroller.permission.ui.model.ReviewPermissionsViewModel;\nimport com.android.permissioncontroller.permission.ui.model.ReviewPermissionsViewModel.PermissionTarget;\nimport com.android.permissioncontroller.permission.utils.KotlinUtils;\nimport com.android.permissioncontroller.permission.utils.Utils;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Random;\n\n/**\n * If an app does not support runtime permissions the user is prompted via this fragment to select\n * which permissions to grant to the app before first use and if an update changed the permissions.\n */\npublic final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n        implements View.OnClickListener, PermissionPreference.PermissionPreferenceChangeListener,\n        PermissionPreference.PermissionPreferenceOwnerFragment {\n\n    private static final String EXTRA_PACKAGE_INFO =\n            \"com.android.permissioncontroller.permission.ui.extra.PACKAGE_INFO\";\n    private static final String LOG_TAG = ReviewPermissionsFragment.class.getSimpleName();\n\n    private ReviewPermissionsViewModel mViewModel;\n    private View mView;\n    private Button mContinueButton;\n    private Button mCancelButton;\n    private Button mMoreInfoButton;\n    private PreferenceCategory mNewPermissionsCategory;\n    private PreferenceCategory mCurrentPermissionsCategory;\n\n    private boolean mHasConfirmedRevoke;\n\n    /**\n     * Creates bundle arguments for the navigation graph\n     * @param packageInfo packageInfo added to the bundle\n     * @return the bundle\n     */\n    public static Bundle getArgs(PackageInfo packageInfo) {\n        Bundle arguments = new Bundle();\n        arguments.putParcelable(EXTRA_PACKAGE_INFO, packageInfo);\n        return arguments;\n    }\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n\n        PackageInfo packageInfo = getArguments().getParcelable(EXTRA_PACKAGE_INFO);\n        if (packageInfo == null) {\n            activity.finishAfterTransition();\n            return;\n        }\n\n        ReviewPermissionViewModelFactory factory = new ReviewPermissionViewModelFactory(\n                getActivity().getApplication(), packageInfo);\n        mViewModel = new ViewModelProvider(this, factory).get(ReviewPermissionsViewModel.class);\n        mViewModel.getPermissionGroupsLiveData().observe(this,\n                (Map<String, LightAppPermGroup> permGroupsMap) -> {\n                    if (getActivity().isFinishing()) {\n                        return;\n                    }\n                    if (permGroupsMap.isEmpty()) {\n                        //If the system called for a review but no groups are found, this means\n                        // that all groups are restricted. Hence there is nothing to review\n                        // and instantly continue.\n                        confirmPermissionsReview();\n                        executeCallback(true);\n                        activity.finishAfterTransition();\n                    } else {\n                        bindUi(permGroupsMap);\n                        loadPreferences(permGroupsMap);\n                    }\n                });\n    }\n\n    @Override\n    public void onCreatePreferences(Bundle bundle, String s) {\n        // empty\n    }\n\n    @Override\n    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,\n            @Nullable Bundle savedInstanceState) {\n        mView = inflater.inflate(R.layout.review_permissions, container, false);\n        ViewGroup preferenceRootView = mView.requireViewById(R.id.preferences_frame);\n        View prefsContainer = super.onCreateView(inflater, preferenceRootView, savedInstanceState);\n        preferenceRootView.addView(prefsContainer);\n        return mView;\n    }\n\n    @Override\n    public void onClick(View view) {\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n        if (view == mContinueButton) {\n            confirmPermissionsReview();\n            executeCallback(true);\n        } else if (view == mCancelButton) {\n            executeCallback(false);\n            activity.setResult(Activity.RESULT_CANCELED);\n        } else if (view == mMoreInfoButton) {\n            Intent intent = new Intent(Intent.ACTION_MANAGE_APP_PERMISSIONS);\n            intent.putExtra(Intent.EXTRA_PACKAGE_NAME,\n                    mViewModel.getPackageInfo().packageName);\n            intent.putExtra(Intent.EXTRA_USER, UserHandle.getUserHandleForUid(\n                    mViewModel.getPackageInfo().applicationInfo.uid));\n            intent.putExtra(ManagePermissionsActivity.EXTRA_ALL_PERMISSIONS, true);\n            getActivity().startActivity(intent);\n        }\n        activity.finishAfterTransition();\n    }\n\n    private void confirmPermissionsReview() {\n        final List<PreferenceGroup> preferenceGroups = new ArrayList<>();\n        if (mNewPermissionsCategory != null) {\n            preferenceGroups.add(mNewPermissionsCategory);\n            preferenceGroups.add(mCurrentPermissionsCategory);\n        } else {\n            PreferenceScreen preferenceScreen = getPreferenceScreen();\n            if (preferenceScreen != null) {\n                preferenceGroups.add(preferenceScreen);\n            }\n        }\n\n        final int preferenceGroupCount = preferenceGroups.size();\n        long changeIdForLogging = new Random().nextLong();\n        Application app = getActivity().getApplication();\n        for (int groupNum = 0; groupNum < preferenceGroupCount; groupNum++) {\n            final PreferenceGroup preferenceGroup = preferenceGroups.get(groupNum);\n\n            final int preferenceCount = preferenceGroup.getPreferenceCount();\n            for (int prefNum = 0; prefNum < preferenceCount; prefNum++) {\n                Preference preference = preferenceGroup.getPreference(prefNum);\n                if (preference instanceof PermissionReviewPreference) {\n                    PermissionReviewPreference permPreference =\n                            (PermissionReviewPreference) preference;\n                    LightAppPermGroup group = permPreference.getGroup();\n\n\n                    if (permPreference.getState().and(\n                            PermissionTarget.PERMISSION_FOREGROUND)\n                            != PermissionTarget.PERMISSION_NONE.getValue()) {\n                        KotlinUtils.INSTANCE.grantForegroundRuntimePermissions(app, group);\n                    }\n                    if (permPreference.getState().and(\n                            PermissionTarget.PERMISSION_BACKGROUND)\n                            != PermissionTarget.PERMISSION_NONE.getValue()) {\n                        KotlinUtils.INSTANCE.grantBackgroundRuntimePermissions(app, group);\n                    }\n                    if (permPreference.getState() == PermissionTarget.PERMISSION_NONE) {\n                        KotlinUtils.INSTANCE.revokeForegroundRuntimePermissions(app, group);\n                        KotlinUtils.INSTANCE.revokeBackgroundRuntimePermissions(app, group);\n                    }\n                    logReviewPermissionsFragmentResult(changeIdForLogging, group);\n                }\n            }\n        }\n\n        // Some permission might be restricted and hence there is no AppPermissionGroup for it.\n        // Manually unset all review-required flags, regardless of restriction.\n        PackageManager pm = getContext().getPackageManager();\n        PackageInfo pkg = mViewModel.getPackageInfo();\n        UserHandle user = UserHandle.getUserHandleForUid(pkg.applicationInfo.uid);\n\n        if (pkg.requestedPermissions == null) {\n            // No flag updating to do\n            return;\n        }\n\n        for (String perm : pkg.requestedPermissions) {\n            try {\n                pm.updatePermissionFlags(perm, pkg.packageName,\n                        FLAG_PERMISSION_REVIEW_REQUIRED | FLAG_PERMISSION_USER_SET,\n                        FLAG_PERMISSION_USER_SET, user);\n            } catch (IllegalArgumentException e) {\n                Log.e(LOG_TAG, \"Cannot unmark \" + perm + \" requested by \" + pkg.packageName\n                        + \" as review required\", e);\n            }\n        }\n    }\n\n    private void logReviewPermissionsFragmentResult(long changeId, LightAppPermGroup group) {\n        ArrayList<LightPermission> permissions = new ArrayList<>(\n                group.getAllPermissions().values());\n\n        int numPermissions = permissions.size();\n        for (int i = 0; i < numPermissions; i++) {\n            LightPermission permission = permissions.get(i);\n\n            PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                    changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                    group.getPackageName(),\n                    permission.getName(), permission.isGrantedIncludingAppOp());\n            Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                    + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                    + group.getPackageName() + \" permission=\"\n                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n        }\n    }\n\n    private void bindUi(Map<String, LightAppPermGroup> permGroupsMap) {\n        Activity activity = getActivity();\n        if (activity == null || !mViewModel.isInitialized()) {\n            return;\n        }\n\n        Drawable icon = mViewModel.getPackageInfo().applicationInfo.loadIcon(\n                    getContext().getPackageManager());\n        ImageView iconView = mView.requireViewById(R.id.app_icon);\n        iconView.setImageDrawable(icon);\n\n        // Set message\n        final int labelTemplateResId = mViewModel.isPackageUpdated()\n                ? R.string.permission_review_title_template_update\n                : R.string.permission_review_title_template_install;\n        Spanned message = Html.fromHtml(getString(labelTemplateResId,\n                Utils.getAppLabel(mViewModel.getPackageInfo().applicationInfo,\n                        getActivity().getApplication())), 0);\n        // Set the permission message as the title so it can be announced.\n        activity.setTitle(message.toString());\n\n        // Color the app name.\n        TextView permissionsMessageView = mView.requireViewById(\n                R.id.permissions_message);\n        permissionsMessageView.setText(message);\n\n        mContinueButton = mView.requireViewById(R.id.continue_button);\n        mContinueButton.setOnClickListener(this);\n\n        mCancelButton = mView.requireViewById(R.id.cancel_button);\n        mCancelButton.setOnClickListener(this);\n\n        if (activity.getPackageManager().arePermissionsIndividuallyControlled()) {\n            mMoreInfoButton = mView.requireViewById(\n                    R.id.permission_more_info_button);\n            mMoreInfoButton.setOnClickListener(this);\n            mMoreInfoButton.setVisibility(View.VISIBLE);\n        }\n    }\n\n    private PermissionReviewPreference getPreference(String key) {\n        if (mNewPermissionsCategory != null) {\n            PermissionReviewPreference pref =\n                    mNewPermissionsCategory.findPreference(key);\n\n            if (pref == null && mCurrentPermissionsCategory != null) {\n                return mCurrentPermissionsCategory.findPreference(key);\n            } else {\n                return pref;\n            }\n        } else {\n            return getPreferenceScreen().findPreference(key);\n        }\n    }\n\n    private void loadPreferences(Map<String, LightAppPermGroup> permGroupsMap) {\n        Activity activity = getActivity();\n        if (activity == null || !mViewModel.isInitialized()) {\n            return;\n        }\n\n        PreferenceScreen screen = getPreferenceScreen();\n        if (screen == null) {\n            screen = getPreferenceManager().createPreferenceScreen(getContext());\n            setPreferenceScreen(screen);\n        } else {\n            screen.removeAll();\n        }\n\n        mCurrentPermissionsCategory = null;\n        mNewPermissionsCategory = null;\n\n        final boolean isPackageUpdated = mViewModel.isPackageUpdated();\n\n        for (LightAppPermGroup group : permGroupsMap.values()) {\n            PermissionReviewPreference preference = getPreference(group.getPermGroupName());\n            if (preference == null) {\n                preference = new PermissionReviewPreference(this,\n                        group, this, mViewModel);\n                preference.setKey(group.getPermGroupName());\n                Drawable icon = KotlinUtils.INSTANCE.getPermGroupIcon(getContext(),\n                        group.getPermGroupName());\n                preference.setIcon(icon);\n                preference.setTitle(KotlinUtils.INSTANCE.getPermGroupLabel(getContext(),\n                        group.getPermGroupName()));\n            } else {\n                preference.updateUi();\n            }\n\n            if (group.isReviewRequired()) {\n                if (!isPackageUpdated) {\n                    screen.addPreference(preference);\n                } else {\n                    if (mNewPermissionsCategory == null) {\n                        mNewPermissionsCategory = new PreferenceCategory(activity);\n                        mNewPermissionsCategory.setTitle(R.string.new_permissions_category);\n                        mNewPermissionsCategory.setOrder(1);\n                        screen.addPreference(mNewPermissionsCategory);\n                    }\n                    mNewPermissionsCategory.addPreference(preference);\n                }\n            } else {\n                if (mCurrentPermissionsCategory == null) {\n                    mCurrentPermissionsCategory = new PreferenceCategory(activity);\n                    mCurrentPermissionsCategory.setTitle(R.string.current_permissions_category);\n                    mCurrentPermissionsCategory.setOrder(2);\n                    screen.addPreference(mCurrentPermissionsCategory);\n                }\n                mCurrentPermissionsCategory.addPreference(preference);\n            }\n        }\n    }\n\n    private void executeCallback(boolean success) {\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n        if (success) {\n            IntentSender intent = activity.getIntent().getParcelableExtra(Intent.EXTRA_INTENT);\n            if (intent != null) {\n                try {\n                    int flagMask = 0;\n                    int flagValues = 0;\n                    if (activity.getIntent().getBooleanExtra(\n                            Intent.EXTRA_RESULT_NEEDED, false)) {\n                        flagMask = Intent.FLAG_ACTIVITY_FORWARD_RESULT;\n                        flagValues = Intent.FLAG_ACTIVITY_FORWARD_RESULT;\n                    }\n                    activity.startIntentSenderForResult(intent, -1, null,\n                            flagMask, flagValues, 0);\n                } catch (IntentSender.SendIntentException e) {\n                        /* ignore */\n                }\n                return;\n            }\n        }\n        RemoteCallback callback = activity.getIntent().getParcelableExtra(\n                Intent.EXTRA_REMOTE_CALLBACK);\n        if (callback != null) {\n            Bundle result = new Bundle();\n            result.putBoolean(Intent.EXTRA_RETURN_RESULT, success);\n            callback.sendResult(result);\n        }\n    }\n\n    @Override\n    public boolean shouldConfirmDefaultPermissionRevoke() {\n        return !mHasConfirmedRevoke;\n    }\n\n    @Override\n    public void hasConfirmDefaultPermissionRevoke() {\n        mHasConfirmedRevoke = true;\n    }\n\n    @Override\n    public void onPreferenceChanged(String key) {\n        getPreference(key).setChanged();\n    }\n\n    @Override\n    public void onDenyAnyWay(String key, PermissionTarget changeTarget) {\n        getPreference(key).onDenyAnyWay(changeTarget);\n    }\n\n    @Override\n    public void onBackgroundAccessChosen(String key, int chosenItem) {\n        getPreference(key).onBackgroundAccessChosen(chosenItem);\n    }\n\n    /**\n     * Extend the {@link PermissionPreference}:\n     * <ul>\n     *     <li>Show the description of the permission group</li>\n     *     <li>Show the permission group as granted if the user has not toggled it yet. This means\n     *     that if the user does not touch the preference, we will later grant the permission\n     *     in {@link #confirmPermissionsReview()}.</li>\n     * </ul>\n     */\n    private static class PermissionReviewPreference extends PermissionPreference {\n        private final LightAppPermGroup mGroup;\n        private final Context mContext;\n        private boolean mWasChanged;\n\n        PermissionReviewPreference(PreferenceFragmentCompat fragment, LightAppPermGroup group,\n                PermissionPreferenceChangeListener callbacks,\n                ReviewPermissionsViewModel reviewPermissionsViewModel) {\n            super(fragment, group, callbacks, reviewPermissionsViewModel);\n            mGroup = group;\n            mContext = fragment.getContext();\n            updateUi();\n        }\n\n        LightAppPermGroup getGroup() {\n            return mGroup;\n        }\n\n        /**\n         * Mark the permission as changed by the user\n         */\n        void setChanged() {\n            mWasChanged = true;\n            updateUi();\n        }\n\n        @Override\n        void updateUi() {\n            // updateUi might be called in super-constructor before group is initialized\n            if (mGroup == null) {\n                return;\n            }\n\n            super.updateUi();\n\n            if (isEnabled()) {\n                if (mGroup.isReviewRequired() && !mWasChanged) {\n                    setSummary(KotlinUtils.INSTANCE.getPermGroupDescription(mContext,\n                            mGroup.getPermGroupName()));\n                    setCheckedOverride(true);\n                } else if (TextUtils.isEmpty(getSummary())) {\n                    // Sometimes the summary is already used, e.g. when this for a\n                    // foreground/background group. In this case show leave the original summary.\n                    setSummary(KotlinUtils.INSTANCE.getPermGroupDescription(mContext,\n                            mGroup.getPermGroupName()));\n                }\n            }\n        }\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 3563,
                                        "general": {
                                            "word_based": 1535,
                                            "char_based": 5222
                                        },
                                        "gemini": 4408
                                    }
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-375160214",
            "aliases": [
                "A-375160214",
                "CVE-2025-22406"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-375160214",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "00555617ddbbc1a19089104c084d14f465c971ce"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 00555617ddbbc1a19089104c084d14f465c971ce Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Sat, 2 Nov 2024 02:29:10 +0000\nSubject: [PATCH] Fix more memory-unsafe logging\n\nIn various locations around the stack, log statements use structures that\nmay, in exceptional cases, have been freed by preceding calls.  This can\nlead to use after free and potentially to security vulnerabilities.\n\nUse local variables instead, or store the length before the call if no\nlocal variable is already convenient.\n\nBug: 375404242\nBug: 375398779\nBug: 375397720\nBug: 375397164\nBug: 375397370\nBug: 375396810\nBug: 375159652\nBug: 375160214\nBug: 375159480\nTest: m libbluetooth\nTest: researcher POC\nFlag: EXEMPT trivial logic fix\nIgnore-AOSP-First: security\nTag: #security\nChange-Id: Ia50e074de751661a0e617bfffa17871497b8d1ea\n---\n system/stack/avct/avct_lcb_act.cc    | 5 ++++-\n system/stack/bnep/bnep_main.cc       | 4 +++-\n system/stack/bnep/bnep_utils.cc      | 3 ++-\n system/stack/hid/hidd_conn.cc        | 4 ++--\n system/stack/rfcomm/rfc_ts_frames.cc | 3 ++-\n system/stack/rfcomm/rfc_utils.cc     | 3 ++-\n system/stack/sdp/sdp_discovery.cc    | 2 +-\n system/stack/sdp/sdp_server.cc       | 4 ++--\n 8 files changed, 18 insertions(+), 10 deletions(-)\n\ndiff --git a/system/stack/avct/avct_lcb_act.cc b/system/stack/avct/avct_lcb_act.cc\nindex 986bce7d34..32da9d865b 100644\n--- a/system/stack/avct/avct_lcb_act.cc\n+++ b/system/stack/avct/avct_lcb_act.cc\n@@ -727,10 +727,13 @@ void avct_lcb_msg_ind(tAVCT_LCB* p_lcb, tAVCT_LCB_EVT* p_data) {\n     p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n     AVCT_BUILD_HDR(p, label, AVCT_PKT_TYPE_SINGLE, AVCT_REJ);\n     UINT16_TO_BE_STREAM(p, pid);\n+\n+    uint16_t len = p_buf->len;\n+\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_lcb->ch_lcid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} lcid:0x{:04x} len:{}\", p_lcb->peer_addr,\n-                p_lcb->ch_lcid, p_buf->len);\n+                p_lcb->ch_lcid, len);\n     }\n   }\n }\ndiff --git a/system/stack/bnep/bnep_main.cc b/system/stack/bnep/bnep_main.cc\nindex e0e3c4540c..adf3c8666e 100644\n--- a/system/stack/bnep/bnep_main.cc\n+++ b/system/stack/bnep/bnep_main.cc\n@@ -295,10 +295,12 @@ static void bnep_congestion_ind(uint16_t l2cap_cid, bool is_congested) {\n         break;\n       }\n \n+      uint16_t len = p_buf->len;\n+\n       if (stack::l2cap::get_interface().L2CA_DataWrite(l2cap_cid, p_buf) !=\n           tL2CAP_DW_RESULT::SUCCESS) {\n         log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_bcb->rem_bda, l2cap_cid,\n-                  p_buf->len);\n+                  len);\n       }\n     }\n   }\ndiff --git a/system/stack/bnep/bnep_utils.cc b/system/stack/bnep/bnep_utils.cc\nindex 252facf668..4092d9afee 100644\n--- a/system/stack/bnep/bnep_utils.cc\n+++ b/system/stack/bnep/bnep_utils.cc\n@@ -411,10 +411,11 @@ void bnepu_check_send_packet(tBNEP_CONN* p_bcb, BT_HDR* p_buf) {\n       fixed_queue_enqueue(p_bcb->xmit_q, p_buf);\n     }\n   } else {\n+    uint16_t len = p_buf->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_bcb->l2cap_cid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_bcb->rem_bda,\n-                p_bcb->l2cap_cid, p_buf->len);\n+                p_bcb->l2cap_cid, len);\n     }\n   }\n }\ndiff --git a/system/stack/hid/hidd_conn.cc b/system/stack/hid/hidd_conn.cc\nindex c64a7b9104..695e5d6c84 100644\n--- a/system/stack/hid/hidd_conn.cc\n+++ b/system/stack/hid/hidd_conn.cc\n@@ -88,10 +88,10 @@ static void hidd_check_config_done() {\n \n     // send outstanding data on intr\n     if (hd_cb.pending_data) {\n+      uint16_t len = hd_cb.pending_data->len;\n       if (stack::l2cap::get_interface().L2CA_DataWrite(p_hcon->intr_cid, hd_cb.pending_data) !=\n           tL2CAP_DW_RESULT::SUCCESS) {\n-        log::warn(\"Unable to write L2CAP data cid:{} len:{}\", p_hcon->intr_cid,\n-                  hd_cb.pending_data->len);\n+        log::warn(\"Unable to write L2CAP data cid:{} len:{}\", p_hcon->intr_cid, len);\n       }\n       hd_cb.pending_data = NULL;\n     }\ndiff --git a/system/stack/rfcomm/rfc_ts_frames.cc b/system/stack/rfcomm/rfc_ts_frames.cc\nindex ea57abf6dc..e93cfed9b8 100644\n--- a/system/stack/rfcomm/rfc_ts_frames.cc\n+++ b/system/stack/rfcomm/rfc_ts_frames.cc\n@@ -201,10 +201,11 @@ void rfc_send_buf_uih(tRFC_MCB* p_mcb, uint8_t dlci, BT_HDR* p_buf) {\n   if (dlci == RFCOMM_MX_DLCI) {\n     rfc_check_send_cmd(p_mcb, p_buf);\n   } else {\n+    uint16_t len = p_buf->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_mcb->lcid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_mcb->bd_addr, p_mcb->lcid,\n-                p_buf->len);\n+                len);\n     }\n   }\n }\ndiff --git a/system/stack/rfcomm/rfc_utils.cc b/system/stack/rfcomm/rfc_utils.cc\nindex 23420892cb..0c5074db76 100644\n--- a/system/stack/rfcomm/rfc_utils.cc\n+++ b/system/stack/rfcomm/rfc_utils.cc\n@@ -428,9 +428,10 @@ void rfc_check_send_cmd(tRFC_MCB* p_mcb, BT_HDR* p_buf) {\n     if (p == NULL) {\n       break;\n     }\n+    uint16_t len = p->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_mcb->lcid, p) != tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_mcb->bd_addr, p_mcb->lcid,\n-                p->len);\n+                len);\n     }\n   }\n }\ndiff --git a/system/stack/sdp/sdp_discovery.cc b/system/stack/sdp/sdp_discovery.cc\nindex 4fa484e14a..6aba1993af 100644\n--- a/system/stack/sdp/sdp_discovery.cc\n+++ b/system/stack/sdp/sdp_discovery.cc\n@@ -877,7 +877,7 @@ static void process_service_attr_rsp(tCONN_CB* p_ccb, uint8_t* p_reply, uint8_t*\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_msg) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-                p_ccb->connection_id, p_msg->len);\n+                p_ccb->connection_id, p - p_start);\n     }\n \n     /* Start inactivity timer */\ndiff --git a/system/stack/sdp/sdp_server.cc b/system/stack/sdp/sdp_server.cc\nindex abd70aedb1..0f379708e9 100644\n--- a/system/stack/sdp/sdp_server.cc\n+++ b/system/stack/sdp/sdp_server.cc\n@@ -300,7 +300,7 @@ static void process_service_search(tCONN_CB* p_ccb, uint16_t trans_num, uint16_t\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_buf) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_buf->len);\n+              p_ccb->connection_id, p_rsp - p_rsp_start);\n   }\n }\n \n@@ -564,7 +564,7 @@ static void process_service_attr_req(tCONN_CB* p_ccb, uint16_t trans_num, uint16\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_buf) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_buf->len);\n+              p_ccb->connection_id, p_rsp - p_rsp_start);\n   }\n }\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 2404,
                        "general": {
                            "word_based": 853,
                            "char_based": 1793
                        },
                        "gemini": 3096
                    },
                    "total_downstream_versions_tested": 0,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": []
                }
            ]
        },
        {
            "id": "ASB-A-375397164",
            "aliases": [
                "A-375397164",
                "CVE-2025-22408"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-375397164",
            "severity": "Critical",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "00555617ddbbc1a19089104c084d14f465c971ce"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 00555617ddbbc1a19089104c084d14f465c971ce Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Sat, 2 Nov 2024 02:29:10 +0000\nSubject: [PATCH] Fix more memory-unsafe logging\n\nIn various locations around the stack, log statements use structures that\nmay, in exceptional cases, have been freed by preceding calls.  This can\nlead to use after free and potentially to security vulnerabilities.\n\nUse local variables instead, or store the length before the call if no\nlocal variable is already convenient.\n\nBug: 375404242\nBug: 375398779\nBug: 375397720\nBug: 375397164\nBug: 375397370\nBug: 375396810\nBug: 375159652\nBug: 375160214\nBug: 375159480\nTest: m libbluetooth\nTest: researcher POC\nFlag: EXEMPT trivial logic fix\nIgnore-AOSP-First: security\nTag: #security\nChange-Id: Ia50e074de751661a0e617bfffa17871497b8d1ea\n---\n system/stack/avct/avct_lcb_act.cc    | 5 ++++-\n system/stack/bnep/bnep_main.cc       | 4 +++-\n system/stack/bnep/bnep_utils.cc      | 3 ++-\n system/stack/hid/hidd_conn.cc        | 4 ++--\n system/stack/rfcomm/rfc_ts_frames.cc | 3 ++-\n system/stack/rfcomm/rfc_utils.cc     | 3 ++-\n system/stack/sdp/sdp_discovery.cc    | 2 +-\n system/stack/sdp/sdp_server.cc       | 4 ++--\n 8 files changed, 18 insertions(+), 10 deletions(-)\n\ndiff --git a/system/stack/avct/avct_lcb_act.cc b/system/stack/avct/avct_lcb_act.cc\nindex 986bce7d34..32da9d865b 100644\n--- a/system/stack/avct/avct_lcb_act.cc\n+++ b/system/stack/avct/avct_lcb_act.cc\n@@ -727,10 +727,13 @@ void avct_lcb_msg_ind(tAVCT_LCB* p_lcb, tAVCT_LCB_EVT* p_data) {\n     p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n     AVCT_BUILD_HDR(p, label, AVCT_PKT_TYPE_SINGLE, AVCT_REJ);\n     UINT16_TO_BE_STREAM(p, pid);\n+\n+    uint16_t len = p_buf->len;\n+\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_lcb->ch_lcid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} lcid:0x{:04x} len:{}\", p_lcb->peer_addr,\n-                p_lcb->ch_lcid, p_buf->len);\n+                p_lcb->ch_lcid, len);\n     }\n   }\n }\ndiff --git a/system/stack/bnep/bnep_main.cc b/system/stack/bnep/bnep_main.cc\nindex e0e3c4540c..adf3c8666e 100644\n--- a/system/stack/bnep/bnep_main.cc\n+++ b/system/stack/bnep/bnep_main.cc\n@@ -295,10 +295,12 @@ static void bnep_congestion_ind(uint16_t l2cap_cid, bool is_congested) {\n         break;\n       }\n \n+      uint16_t len = p_buf->len;\n+\n       if (stack::l2cap::get_interface().L2CA_DataWrite(l2cap_cid, p_buf) !=\n           tL2CAP_DW_RESULT::SUCCESS) {\n         log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_bcb->rem_bda, l2cap_cid,\n-                  p_buf->len);\n+                  len);\n       }\n     }\n   }\ndiff --git a/system/stack/bnep/bnep_utils.cc b/system/stack/bnep/bnep_utils.cc\nindex 252facf668..4092d9afee 100644\n--- a/system/stack/bnep/bnep_utils.cc\n+++ b/system/stack/bnep/bnep_utils.cc\n@@ -411,10 +411,11 @@ void bnepu_check_send_packet(tBNEP_CONN* p_bcb, BT_HDR* p_buf) {\n       fixed_queue_enqueue(p_bcb->xmit_q, p_buf);\n     }\n   } else {\n+    uint16_t len = p_buf->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_bcb->l2cap_cid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_bcb->rem_bda,\n-                p_bcb->l2cap_cid, p_buf->len);\n+                p_bcb->l2cap_cid, len);\n     }\n   }\n }\ndiff --git a/system/stack/hid/hidd_conn.cc b/system/stack/hid/hidd_conn.cc\nindex c64a7b9104..695e5d6c84 100644\n--- a/system/stack/hid/hidd_conn.cc\n+++ b/system/stack/hid/hidd_conn.cc\n@@ -88,10 +88,10 @@ static void hidd_check_config_done() {\n \n     // send outstanding data on intr\n     if (hd_cb.pending_data) {\n+      uint16_t len = hd_cb.pending_data->len;\n       if (stack::l2cap::get_interface().L2CA_DataWrite(p_hcon->intr_cid, hd_cb.pending_data) !=\n           tL2CAP_DW_RESULT::SUCCESS) {\n-        log::warn(\"Unable to write L2CAP data cid:{} len:{}\", p_hcon->intr_cid,\n-                  hd_cb.pending_data->len);\n+        log::warn(\"Unable to write L2CAP data cid:{} len:{}\", p_hcon->intr_cid, len);\n       }\n       hd_cb.pending_data = NULL;\n     }\ndiff --git a/system/stack/rfcomm/rfc_ts_frames.cc b/system/stack/rfcomm/rfc_ts_frames.cc\nindex ea57abf6dc..e93cfed9b8 100644\n--- a/system/stack/rfcomm/rfc_ts_frames.cc\n+++ b/system/stack/rfcomm/rfc_ts_frames.cc\n@@ -201,10 +201,11 @@ void rfc_send_buf_uih(tRFC_MCB* p_mcb, uint8_t dlci, BT_HDR* p_buf) {\n   if (dlci == RFCOMM_MX_DLCI) {\n     rfc_check_send_cmd(p_mcb, p_buf);\n   } else {\n+    uint16_t len = p_buf->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_mcb->lcid, p_buf) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_mcb->bd_addr, p_mcb->lcid,\n-                p_buf->len);\n+                len);\n     }\n   }\n }\ndiff --git a/system/stack/rfcomm/rfc_utils.cc b/system/stack/rfcomm/rfc_utils.cc\nindex 23420892cb..0c5074db76 100644\n--- a/system/stack/rfcomm/rfc_utils.cc\n+++ b/system/stack/rfcomm/rfc_utils.cc\n@@ -428,9 +428,10 @@ void rfc_check_send_cmd(tRFC_MCB* p_mcb, BT_HDR* p_buf) {\n     if (p == NULL) {\n       break;\n     }\n+    uint16_t len = p->len;\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_mcb->lcid, p) != tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_mcb->bd_addr, p_mcb->lcid,\n-                p->len);\n+                len);\n     }\n   }\n }\ndiff --git a/system/stack/sdp/sdp_discovery.cc b/system/stack/sdp/sdp_discovery.cc\nindex 4fa484e14a..6aba1993af 100644\n--- a/system/stack/sdp/sdp_discovery.cc\n+++ b/system/stack/sdp/sdp_discovery.cc\n@@ -877,7 +877,7 @@ static void process_service_attr_rsp(tCONN_CB* p_ccb, uint8_t* p_reply, uint8_t*\n     if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_msg) !=\n         tL2CAP_DW_RESULT::SUCCESS) {\n       log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-                p_ccb->connection_id, p_msg->len);\n+                p_ccb->connection_id, p - p_start);\n     }\n \n     /* Start inactivity timer */\ndiff --git a/system/stack/sdp/sdp_server.cc b/system/stack/sdp/sdp_server.cc\nindex abd70aedb1..0f379708e9 100644\n--- a/system/stack/sdp/sdp_server.cc\n+++ b/system/stack/sdp/sdp_server.cc\n@@ -300,7 +300,7 @@ static void process_service_search(tCONN_CB* p_ccb, uint16_t trans_num, uint16_t\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_buf) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_buf->len);\n+              p_ccb->connection_id, p_rsp - p_rsp_start);\n   }\n }\n \n@@ -564,7 +564,7 @@ static void process_service_attr_req(tCONN_CB* p_ccb, uint16_t trans_num, uint16\n   if (stack::l2cap::get_interface().L2CA_DataWrite(p_ccb->connection_id, p_buf) !=\n       tL2CAP_DW_RESULT::SUCCESS) {\n     log::warn(\"Unable to write L2CAP data peer:{} cid:{} len:{}\", p_ccb->device_address,\n-              p_ccb->connection_id, p_buf->len);\n+              p_ccb->connection_id, p_rsp - p_rsp_start);\n   }\n }\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 2404,
                        "general": {
                            "word_based": 853,
                            "char_based": 1793
                        },
                        "gemini": 3096
                    },
                    "total_downstream_versions_tested": 0,
                    "successful_patches": 0,
                    "failed_patches": 0,
                    "patch_results": []
                }
            ]
        }
    ],
    "vulnerabilities_with_partial_failures": [
        {
            "id": "ASB-A-363248394",
            "aliases": [
                "A-363248394",
                "CVE-2024-49742"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-363248394",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "7ae59a42eb13f643d842525208619037c074371a"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 7ae59a42eb13f643d842525208619037c074371a Mon Sep 17 00:00:00 2001\nFrom: Guojing Yuan <guojing@google.com>\nDate: Tue, 1 Oct 2024 21:59:31 +0000\nSubject: [PATCH] [CDM][NLS] Check if the NLS service has an intent-filter\n\nBug: 363248394\nTest: CTS\nFlag: EXEMPT bugfix\nChange-Id: Ib79c219cde8d73a218ceb7911f4552d43e384d8e\n---\n ...otificationAccessConfirmationActivity.java | 50 +++++++++++--------\n ...icationAccessConfirmationActivityTest.java |  9 ++--\n 2 files changed, 33 insertions(+), 26 deletions(-)\n\ndiff --git a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nindex 3f300c0fce3..1adeb644155 100644\n--- a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n+++ b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n@@ -30,13 +30,15 @@ import android.app.admin.DevicePolicyManager;\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n import android.os.UserManager;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n import android.view.WindowManager;\n@@ -49,6 +51,8 @@ import com.android.internal.app.AlertActivity;\n import com.android.internal.app.AlertController;\n import com.android.settings.R;\n \n+import java.util.List;\n+\n /** @hide */\n public class NotificationAccessConfirmationActivity extends Activity\n         implements DialogInterface {\n@@ -113,6 +117,31 @@ public class NotificationAccessConfirmationActivity extends Activity\n             return;\n         }\n \n+        // Check NLS service info.\n+        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n+        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n+        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n+                NLSIntent, /* flags */ 0, mUserId);\n+        boolean hasNLSIntentFilter = false;\n+        for (ResolveInfo service : matchedServiceList) {\n+            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n+                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n+                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n+                            + requiredPermission);\n+                    finish();\n+                    return;\n+                }\n+                hasNLSIntentFilter = true;\n+                break;\n+            }\n+        }\n+        if (!hasNLSIntentFilter) {\n+            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n+                    + \"for android.service.notification.NotificationListenerService.\");\n+            finish();\n+            return;\n+        }\n+\n         AlertController.AlertParams p = new AlertController.AlertParams(this);\n         p.mTitle = getString(\n                 R.string.notification_listener_security_warning_title,\n@@ -147,19 +176,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n     }\n \n     private void onAllow() {\n-        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n-        try {\n-            ServiceInfo serviceInfo = getPackageManager().getServiceInfo(mComponentName, 0);\n-            if (!requiredPermission.equals(serviceInfo.permission)) {\n-                Slog.e(LOG_TAG,\n-                        \"Service \" + mComponentName + \" lacks permission \" + requiredPermission);\n-                return;\n-            }\n-        } catch (PackageManager.NameNotFoundException e) {\n-            Slog.e(LOG_TAG, \"Failed to get service info for \" + mComponentName, e);\n-            return;\n-        }\n-\n         mNm.setNotificationListenerAccessGranted(mComponentName, true);\n \n         finish();\n@@ -170,12 +186,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n         return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n     }\n \n-    @Override\n-    public void onBackPressed() {\n-        // Suppress finishing the activity on back button press,\n-        // consistently with the permission dialog behavior\n-    }\n-\n     @Override\n     public void cancel() {\n         finish();\ndiff --git a/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java b/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java\nindex 9b510fb43e3..0a953615abf 100644\n--- a/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java\n+++ b/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java\n@@ -31,8 +31,6 @@ import android.widget.TextView;\n \n import androidx.annotation.Nullable;\n \n-import com.android.settings.R;\n-\n import com.google.common.base.Strings;\n \n import org.junit.Test;\n@@ -45,15 +43,14 @@ import org.robolectric.RuntimeEnvironment;\n public class NotificationAccessConfirmationActivityTest {\n \n     @Test\n-    public void start_showsDialog() {\n+    public void start_withMissingIntentFilter_finishes() {\n         ComponentName cn = new ComponentName(\"com.example\", \"com.example.SomeService\");\n         installPackage(cn.getPackageName(), \"X\");\n \n         NotificationAccessConfirmationActivity activity = startActivityWithIntent(cn);\n \n-        assertThat(activity.isFinishing()).isFalse();\n-        assertThat(getDialogText(activity)).isEqualTo(\n-                activity.getString(R.string.notification_listener_security_warning_summary, \"X\"));\n+        assertThat(getDialogText(activity)).isNull();\n+        assertThat(activity.isFinishing()).isTrue();\n     }\n \n     @Test\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 1304,
                        "general": {
                            "word_based": 542,
                            "char_based": 1544
                        },
                        "gemini": 1697
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 2,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "59cdc3e20ca4ac198b1c27e6a5372ececd155b16",
                            "repo_path": "android_repos/Settings",
                            "result": "failure",
                            "downstream_patch_content": "commit 59cdc3e20ca4ac198b1c27e6a5372ececd155b16\nAuthor: Guojing Yuan <guojing@google.com>\nDate:   Tue Oct 1 21:59:31 2024 +0000\n\n    [CDM][NLS] Check if the NLS service has an intent-filter\n    \n    Bug: 363248394\n    Test: CTS\n    Flag: EXEMPT bugfix\n    Change-Id: Ib79c219cde8d73a218ceb7911f4552d43e384d8e\n    Merged-In: Ib79c219cde8d73a218ceb7911f4552d43e384d8e\n    (cherry picked from commit 7ae59a42eb13f643d842525208619037c074371a)\n\ndiff --git a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nindex a6b565ae6ba..f01e23a5e8f 100644\n--- a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n+++ b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n@@ -29,12 +29,14 @@ import android.app.NotificationManager;\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n import android.view.WindowManager;\n@@ -44,6 +46,8 @@ import com.android.internal.app.AlertActivity;\n import com.android.internal.app.AlertController;\n import com.android.settings.R;\n \n+import java.util.List;\n+\n /** @hide */\n public class NotificationAccessConfirmationActivity extends Activity\n         implements DialogInterface {\n@@ -92,6 +96,31 @@ public class NotificationAccessConfirmationActivity extends Activity\n             return;\n         }\n \n+        // Check NLS service info.\n+        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n+        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n+        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n+                NLSIntent, /* flags */ 0, mUserId);\n+        boolean hasNLSIntentFilter = false;\n+        for (ResolveInfo service : matchedServiceList) {\n+            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n+                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n+                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n+                            + requiredPermission);\n+                    finish();\n+                    return;\n+                }\n+                hasNLSIntentFilter = true;\n+                break;\n+            }\n+        }\n+        if (!hasNLSIntentFilter) {\n+            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n+                    + \"for android.service.notification.NotificationListenerService.\");\n+            finish();\n+            return;\n+        }\n+\n         AlertController.AlertParams p = new AlertController.AlertParams(this);\n         p.mTitle = getString(\n                 R.string.notification_listener_security_warning_title,\n@@ -126,19 +155,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n     }\n \n     private void onAllow() {\n-        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n-        try {\n-            ServiceInfo serviceInfo = getPackageManager().getServiceInfo(mComponentName, 0);\n-            if (!requiredPermission.equals(serviceInfo.permission)) {\n-                Slog.e(LOG_TAG,\n-                        \"Service \" + mComponentName + \" lacks permission \" + requiredPermission);\n-                return;\n-            }\n-        } catch (PackageManager.NameNotFoundException e) {\n-            Slog.e(LOG_TAG, \"Failed to get service info for \" + mComponentName, e);\n-            return;\n-        }\n-\n         mNm.setNotificationListenerAccessGranted(mComponentName, true);\n \n         finish();\n@@ -149,12 +165,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n         return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n     }\n \n-    @Override\n-    public void onBackPressed() {\n-        // Suppress finishing the activity on back button press,\n-        // consistently with the permission dialog behavior\n-    }\n-\n     @Override\n     public void cancel() {\n         finish();\n",
                            "downstream_patch_tokens": {
                                "openai": 992,
                                "general": {
                                    "word_based": 386,
                                    "char_based": 1143
                                },
                                "gemini": 1281
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "src/com/android/settings/notification/NotificationAccessConfirmationActivity.java",
                                    "total_hunks": 5,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12)\n\n=======\n    }\n\n    private void onAllow() {\n        mNm.setNotificationListenerAccessGranted(mComponentName, true);\n\n        finish();\n>>>>>>> UPSTREAM PATCH (commit 7ae59a42eb13f643d842525208619037c074371a)",
                                            "merge_conflict_tokens": {
                                                "openai": 62,
                                                "general": {
                                                    "word_based": 15,
                                                    "char_based": 60
                                                },
                                                "gemini": 89
                                            }
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12)\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n    }\n\n=======\n\n>>>>>>> UPSTREAM PATCH (commit 7ae59a42eb13f643d842525208619037c074371a)",
                                            "merge_conflict_tokens": {
                                                "openai": 71,
                                                "general": {
                                                    "word_based": 18,
                                                    "char_based": 73
                                                },
                                                "gemini": 94
                                            }
                                        }
                                    ],
                                    "inline_merge_token_summary": {
                                        "gemini": 8418,
                                        "openai": 6251,
                                        "general_word": 1551,
                                        "general_char": 6251
                                    },
                                    "rej_file_content": "```diff\n--- src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n+++ src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n@@ -30,13 +30,15 @@ import android.app.admin.DevicePolicyManager;\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n import android.os.UserManager;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n import android.view.WindowManager;\n```",
                                    "rej_file_tokens": {
                                        "openai": 144,
                                        "general": {
                                            "word_based": 93,
                                            "char_based": 211
                                        },
                                        "gemini": 214
                                    },
                                    "patch_apply_output": "patching file src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nHunk #1 FAILED at 30.\nHunk #2 succeeded at 44 (offset -5 lines).\nHunk #3 succeeded at 94 (offset -21 lines).\nHunk #4 succeeded at 153 (offset -21 lines).\nHunk #5 succeeded at 163 (offset -21 lines).\n1 out of 5 hunks FAILED -- saving rejects to file src/com/android/settings/notification/NotificationAccessConfirmationActivity.java.rej",
                                    "inline_merge_output": "patching file src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nHunk #1 already applied at 33,37,41.\nHunk #2 merged at 56-57.\nHunk #4 NOT MERGED at 203-211.\nHunk #5 NOT MERGED at 220-227.",
                                    "upstream_file_tokens": {
                                        "openai": 1382,
                                        "general": {
                                            "word_based": 625,
                                            "char_based": 1905
                                        },
                                        "gemini": 1759
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\npackage com.android.settings.notification;\n\nimport static android.view.WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS;\n\nimport static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_COMPONENT_NAME;\nimport static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_USER_ID;\n\nimport android.Manifest;\nimport android.annotation.Nullable;\nimport android.app.Activity;\nimport android.app.NotificationManager;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageItemInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ServiceInfo;\nimport android.os.Bundle;\nimport android.os.UserHandle;\nimport android.text.TextUtils;\nimport android.util.Slog;\nimport android.view.WindowManager;\nimport android.view.accessibility.AccessibilityEvent;\n\nimport com.android.internal.app.AlertActivity;\nimport com.android.internal.app.AlertController;\nimport com.android.settings.R;\n\nimport java.util.List;\n\n/** @hide */\npublic class NotificationAccessConfirmationActivity extends Activity\n        implements DialogInterface {\n\n    private static final boolean DEBUG = false;\n    private static final String LOG_TAG = \"NotificationAccessConfirmationActivity\";\n\n    private int mUserId;\n    private ComponentName mComponentName;\n    private NotificationManager mNm;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        getWindow().addSystemFlags(SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n\n        mNm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n\n        mComponentName = getIntent().getParcelableExtra(EXTRA_COMPONENT_NAME);\n        mUserId = getIntent().getIntExtra(EXTRA_USER_ID, UserHandle.USER_NULL);\n        CharSequence mAppLabel;\n\n        if (mComponentName == null || mComponentName.getPackageName() == null\n                || mComponentName.flattenToString().length()\n                > NotificationManager.MAX_SERVICE_COMPONENT_NAME_LENGTH) {\n            finish();\n            return;\n        }\n\n        try {\n            ApplicationInfo applicationInfo = getPackageManager().getApplicationInfo(\n                    mComponentName.getPackageName(), 0);\n            mAppLabel = applicationInfo.loadSafeLabel(getPackageManager(),\n                    PackageItemInfo.DEFAULT_MAX_LABEL_SIZE_PX,\n                    PackageItemInfo.SAFE_LABEL_FLAG_TRIM\n                            | PackageItemInfo.SAFE_LABEL_FLAG_FIRST_LINE);\n        } catch (PackageManager.NameNotFoundException e) {\n            Slog.e(LOG_TAG, \"Couldn't find app with package name for \" + mComponentName, e);\n            finish();\n            return;\n        }\n\n        if (TextUtils.isEmpty(mAppLabel)) {\n            finish();\n            return;\n        }\n\n        // Check NLS service info.\n        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n                NLSIntent, /* flags */ 0, mUserId);\n        boolean hasNLSIntentFilter = false;\n        for (ResolveInfo service : matchedServiceList) {\n            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n                            + requiredPermission);\n                    finish();\n                    return;\n                }\n                hasNLSIntentFilter = true;\n                break;\n            }\n        }\n        if (!hasNLSIntentFilter) {\n            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n                    + \"for android.service.notification.NotificationListenerService.\");\n            finish();\n            return;\n        }\n\n        AlertController.AlertParams p = new AlertController.AlertParams(this);\n        p.mTitle = getString(\n                R.string.notification_listener_security_warning_title,\n                mAppLabel);\n        p.mMessage = getString(\n                R.string.notification_listener_security_warning_summary,\n                mAppLabel);\n        p.mPositiveButtonText = getString(R.string.allow);\n        p.mPositiveButtonListener = (a, b) -> onAllow();\n        p.mNegativeButtonText = getString(R.string.deny);\n        p.mNegativeButtonListener = (a, b) -> cancel();\n        AlertController\n                .create(this, this, getWindow())\n                .installContent(p);\n        // Consistent with the permission dialog\n        // Used instead of p.mCancelable as that is only honored for AlertDialog\n        getWindow().setCloseOnTouchOutside(false); \n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        getWindow().addFlags(\n                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n    }\n\n    @Override\n    public void onPause() {\n        getWindow().clearFlags(\n                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n        super.onPause();\n    }\n\n    private void onAllow() {\n        mNm.setNotificationListenerAccessGranted(mComponentName, true);\n\n        finish();\n    }\n\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n    }\n\n    @Override\n    public void cancel() {\n        finish();\n    }\n\n    @Override\n    public void dismiss() {\n        // This is called after the click, since we finish when handling the\n        // click, don't do that again here.\n        if (!isFinishing()) {\n            finish();\n        }\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 1222,
                                        "general": {
                                            "word_based": 548,
                                            "char_based": 1666
                                        },
                                        "gemini": 1532
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "59cdc3e20ca4ac198b1c27e6a5372ececd155b16",
                            "repo_path": "android_repos/Settings",
                            "result": "failure",
                            "downstream_patch_content": "commit 59cdc3e20ca4ac198b1c27e6a5372ececd155b16\nAuthor: Guojing Yuan <guojing@google.com>\nDate:   Tue Oct 1 21:59:31 2024 +0000\n\n    [CDM][NLS] Check if the NLS service has an intent-filter\n    \n    Bug: 363248394\n    Test: CTS\n    Flag: EXEMPT bugfix\n    Change-Id: Ib79c219cde8d73a218ceb7911f4552d43e384d8e\n    Merged-In: Ib79c219cde8d73a218ceb7911f4552d43e384d8e\n    (cherry picked from commit 7ae59a42eb13f643d842525208619037c074371a)\n\ndiff --git a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nindex a6b565ae6ba..f01e23a5e8f 100644\n--- a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n+++ b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n@@ -29,12 +29,14 @@ import android.app.NotificationManager;\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n import android.view.WindowManager;\n@@ -44,6 +46,8 @@ import com.android.internal.app.AlertActivity;\n import com.android.internal.app.AlertController;\n import com.android.settings.R;\n \n+import java.util.List;\n+\n /** @hide */\n public class NotificationAccessConfirmationActivity extends Activity\n         implements DialogInterface {\n@@ -92,6 +96,31 @@ public class NotificationAccessConfirmationActivity extends Activity\n             return;\n         }\n \n+        // Check NLS service info.\n+        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n+        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n+        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n+                NLSIntent, /* flags */ 0, mUserId);\n+        boolean hasNLSIntentFilter = false;\n+        for (ResolveInfo service : matchedServiceList) {\n+            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n+                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n+                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n+                            + requiredPermission);\n+                    finish();\n+                    return;\n+                }\n+                hasNLSIntentFilter = true;\n+                break;\n+            }\n+        }\n+        if (!hasNLSIntentFilter) {\n+            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n+                    + \"for android.service.notification.NotificationListenerService.\");\n+            finish();\n+            return;\n+        }\n+\n         AlertController.AlertParams p = new AlertController.AlertParams(this);\n         p.mTitle = getString(\n                 R.string.notification_listener_security_warning_title,\n@@ -126,19 +155,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n     }\n \n     private void onAllow() {\n-        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n-        try {\n-            ServiceInfo serviceInfo = getPackageManager().getServiceInfo(mComponentName, 0);\n-            if (!requiredPermission.equals(serviceInfo.permission)) {\n-                Slog.e(LOG_TAG,\n-                        \"Service \" + mComponentName + \" lacks permission \" + requiredPermission);\n-                return;\n-            }\n-        } catch (PackageManager.NameNotFoundException e) {\n-            Slog.e(LOG_TAG, \"Failed to get service info for \" + mComponentName, e);\n-            return;\n-        }\n-\n         mNm.setNotificationListenerAccessGranted(mComponentName, true);\n \n         finish();\n@@ -149,12 +165,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n         return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n     }\n \n-    @Override\n-    public void onBackPressed() {\n-        // Suppress finishing the activity on back button press,\n-        // consistently with the permission dialog behavior\n-    }\n-\n     @Override\n     public void cancel() {\n         finish();\n",
                            "downstream_patch_tokens": {
                                "openai": 992,
                                "general": {
                                    "word_based": 386,
                                    "char_based": 1143
                                },
                                "gemini": 1281
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "src/com/android/settings/notification/NotificationAccessConfirmationActivity.java",
                                    "total_hunks": 5,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12L)\n\n=======\n    }\n\n    private void onAllow() {\n        mNm.setNotificationListenerAccessGranted(mComponentName, true);\n\n        finish();\n>>>>>>> UPSTREAM PATCH (commit 7ae59a42eb13f643d842525208619037c074371a)",
                                            "merge_conflict_tokens": {
                                                "openai": 63,
                                                "general": {
                                                    "word_based": 15,
                                                    "char_based": 60
                                                },
                                                "gemini": 90
                                            }
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12L)\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n    }\n\n=======\n\n>>>>>>> UPSTREAM PATCH (commit 7ae59a42eb13f643d842525208619037c074371a)",
                                            "merge_conflict_tokens": {
                                                "openai": 72,
                                                "general": {
                                                    "word_based": 18,
                                                    "char_based": 73
                                                },
                                                "gemini": 95
                                            }
                                        }
                                    ],
                                    "inline_merge_token_summary": {
                                        "gemini": 8510,
                                        "openai": 6345,
                                        "general_word": 1551,
                                        "general_char": 6251
                                    },
                                    "rej_file_content": "```diff\n--- src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n+++ src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n@@ -30,13 +30,15 @@ import android.app.admin.DevicePolicyManager;\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n import android.os.UserManager;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n import android.view.WindowManager;\n```",
                                    "rej_file_tokens": {
                                        "openai": 144,
                                        "general": {
                                            "word_based": 93,
                                            "char_based": 211
                                        },
                                        "gemini": 214
                                    },
                                    "patch_apply_output": "patching file src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nHunk #1 FAILED at 30.\nHunk #2 succeeded at 44 (offset -5 lines).\nHunk #3 succeeded at 94 (offset -21 lines).\nHunk #4 succeeded at 153 (offset -21 lines).\nHunk #5 succeeded at 163 (offset -21 lines).\n1 out of 5 hunks FAILED -- saving rejects to file src/com/android/settings/notification/NotificationAccessConfirmationActivity.java.rej",
                                    "inline_merge_output": "patching file src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nHunk #1 already applied at 33,37,41.\nHunk #2 merged at 56-57.\nHunk #4 NOT MERGED at 203-211.\nHunk #5 NOT MERGED at 220-227.",
                                    "upstream_file_tokens": {
                                        "openai": 1382,
                                        "general": {
                                            "word_based": 625,
                                            "char_based": 1905
                                        },
                                        "gemini": 1759
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\npackage com.android.settings.notification;\n\nimport static android.view.WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS;\n\nimport static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_COMPONENT_NAME;\nimport static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_USER_ID;\n\nimport android.Manifest;\nimport android.annotation.Nullable;\nimport android.app.Activity;\nimport android.app.NotificationManager;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageItemInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ServiceInfo;\nimport android.os.Bundle;\nimport android.os.UserHandle;\nimport android.text.TextUtils;\nimport android.util.Slog;\nimport android.view.WindowManager;\nimport android.view.accessibility.AccessibilityEvent;\n\nimport com.android.internal.app.AlertActivity;\nimport com.android.internal.app.AlertController;\nimport com.android.settings.R;\n\nimport java.util.List;\n\n/** @hide */\npublic class NotificationAccessConfirmationActivity extends Activity\n        implements DialogInterface {\n\n    private static final boolean DEBUG = false;\n    private static final String LOG_TAG = \"NotificationAccessConfirmationActivity\";\n\n    private int mUserId;\n    private ComponentName mComponentName;\n    private NotificationManager mNm;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        getWindow().addSystemFlags(SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n\n        mNm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n\n        mComponentName = getIntent().getParcelableExtra(EXTRA_COMPONENT_NAME);\n        mUserId = getIntent().getIntExtra(EXTRA_USER_ID, UserHandle.USER_NULL);\n        CharSequence mAppLabel;\n\n        if (mComponentName == null || mComponentName.getPackageName() == null\n                || mComponentName.flattenToString().length()\n                > NotificationManager.MAX_SERVICE_COMPONENT_NAME_LENGTH) {\n            finish();\n            return;\n        }\n\n        try {\n            ApplicationInfo applicationInfo = getPackageManager().getApplicationInfo(\n                    mComponentName.getPackageName(), 0);\n            mAppLabel = applicationInfo.loadSafeLabel(getPackageManager(),\n                    PackageItemInfo.DEFAULT_MAX_LABEL_SIZE_PX,\n                    PackageItemInfo.SAFE_LABEL_FLAG_TRIM\n                            | PackageItemInfo.SAFE_LABEL_FLAG_FIRST_LINE);\n        } catch (PackageManager.NameNotFoundException e) {\n            Slog.e(LOG_TAG, \"Couldn't find app with package name for \" + mComponentName, e);\n            finish();\n            return;\n        }\n\n        if (TextUtils.isEmpty(mAppLabel)) {\n            finish();\n            return;\n        }\n\n        // Check NLS service info.\n        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n                NLSIntent, /* flags */ 0, mUserId);\n        boolean hasNLSIntentFilter = false;\n        for (ResolveInfo service : matchedServiceList) {\n            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n                            + requiredPermission);\n                    finish();\n                    return;\n                }\n                hasNLSIntentFilter = true;\n                break;\n            }\n        }\n        if (!hasNLSIntentFilter) {\n            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n                    + \"for android.service.notification.NotificationListenerService.\");\n            finish();\n            return;\n        }\n\n        AlertController.AlertParams p = new AlertController.AlertParams(this);\n        p.mTitle = getString(\n                R.string.notification_listener_security_warning_title,\n                mAppLabel);\n        p.mMessage = getString(\n                R.string.notification_listener_security_warning_summary,\n                mAppLabel);\n        p.mPositiveButtonText = getString(R.string.allow);\n        p.mPositiveButtonListener = (a, b) -> onAllow();\n        p.mNegativeButtonText = getString(R.string.deny);\n        p.mNegativeButtonListener = (a, b) -> cancel();\n        AlertController\n                .create(this, this, getWindow())\n                .installContent(p);\n        // Consistent with the permission dialog\n        // Used instead of p.mCancelable as that is only honored for AlertDialog\n        getWindow().setCloseOnTouchOutside(false); \n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        getWindow().addFlags(\n                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n    }\n\n    @Override\n    public void onPause() {\n        getWindow().clearFlags(\n                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n        super.onPause();\n    }\n\n    private void onAllow() {\n        mNm.setNotificationListenerAccessGranted(mComponentName, true);\n\n        finish();\n    }\n\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n    }\n\n    @Override\n    public void cancel() {\n        finish();\n    }\n\n    @Override\n    public void dismiss() {\n        // This is called after the click, since we finish when handling the\n        // click, don't do that again here.\n        if (!isFinishing()) {\n            finish();\n        }\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 1222,
                                        "general": {
                                            "word_based": 548,
                                            "char_based": 1666
                                        },
                                        "gemini": 1532
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "d440f2ef05c20f81e1b1cad447cca427a25d77ec",
                            "repo_path": "android_repos/Settings",
                            "result": "success",
                            "downstream_patch_content": "commit d440f2ef05c20f81e1b1cad447cca427a25d77ec\nAuthor: Guojing Yuan <guojing@google.com>\nDate:   Tue Oct 1 21:59:31 2024 +0000\n\n    [CDM][NLS] Check if the NLS service has an intent-filter\n    \n    Bug: 363248394\n    Test: CTS\n    Flag: EXEMPT bugfix\n    Change-Id: Ib79c219cde8d73a218ceb7911f4552d43e384d8e\n    Merged-In: Ib79c219cde8d73a218ceb7911f4552d43e384d8e\n    (cherry picked from commit 7ae59a42eb13f643d842525208619037c074371a)\n\ndiff --git a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nindex 9ea8c58024f..74b8102ee2c 100644\n--- a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n+++ b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n@@ -31,13 +31,15 @@ import android.app.admin.DevicePolicyManager;\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n import android.os.UserManager;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n import android.view.WindowManager;\n@@ -48,6 +50,8 @@ import com.android.internal.app.AlertActivity;\n import com.android.internal.app.AlertController;\n import com.android.settings.R;\n \n+import java.util.List;\n+\n /** @hide */\n public class NotificationAccessConfirmationActivity extends Activity\n         implements DialogInterface {\n@@ -112,6 +116,31 @@ public class NotificationAccessConfirmationActivity extends Activity\n             return;\n         }\n \n+        // Check NLS service info.\n+        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n+        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n+        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n+                NLSIntent, /* flags */ 0, mUserId);\n+        boolean hasNLSIntentFilter = false;\n+        for (ResolveInfo service : matchedServiceList) {\n+            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n+                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n+                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n+                            + requiredPermission);\n+                    finish();\n+                    return;\n+                }\n+                hasNLSIntentFilter = true;\n+                break;\n+            }\n+        }\n+        if (!hasNLSIntentFilter) {\n+            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n+                    + \"for android.service.notification.NotificationListenerService.\");\n+            finish();\n+            return;\n+        }\n+\n         AlertController.AlertParams p = new AlertController.AlertParams(this);\n         p.mTitle = getString(\n                 R.string.notification_listener_security_warning_title,\n@@ -146,19 +175,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n     }\n \n     private void onAllow() {\n-        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n-        try {\n-            ServiceInfo serviceInfo = getPackageManager().getServiceInfo(mComponentName, 0);\n-            if (!requiredPermission.equals(serviceInfo.permission)) {\n-                Slog.e(LOG_TAG,\n-                        \"Service \" + mComponentName + \" lacks permission \" + requiredPermission);\n-                return;\n-            }\n-        } catch (PackageManager.NameNotFoundException e) {\n-            Slog.e(LOG_TAG, \"Failed to get service info for \" + mComponentName, e);\n-            return;\n-        }\n-\n         mNm.setNotificationListenerAccessGranted(mComponentName, true);\n \n         finish();\n@@ -169,12 +185,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n         return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n     }\n \n-    @Override\n-    public void onBackPressed() {\n-        // Suppress finishing the activity on back button press,\n-        // consistently with the permission dialog behavior\n-    }\n-\n     @Override\n     public void cancel() {\n         finish();\n",
                            "downstream_patch_tokens": {
                                "openai": 998,
                                "general": {
                                    "word_based": 391,
                                    "char_based": 1153
                                },
                                "gemini": 1295
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "e4fe2f5b8134c007e29345ae11a64d37e8ef214a",
                            "repo_path": "android_repos/Settings",
                            "result": "success",
                            "downstream_patch_content": "commit e4fe2f5b8134c007e29345ae11a64d37e8ef214a\nAuthor: Guojing Yuan <guojing@google.com>\nDate:   Tue Oct 1 21:59:31 2024 +0000\n\n    [CDM][NLS] Check if the NLS service has an intent-filter\n    \n    Bug: 363248394\n    Test: CTS\n    Flag: EXEMPT bugfix\n    Change-Id: Ib79c219cde8d73a218ceb7911f4552d43e384d8e\n    Merged-In: Ib79c219cde8d73a218ceb7911f4552d43e384d8e\n    (cherry picked from commit 7ae59a42eb13f643d842525208619037c074371a)\n\ndiff --git a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nindex 9ea8c58024f..74b8102ee2c 100644\n--- a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n+++ b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n@@ -31,13 +31,15 @@ import android.app.admin.DevicePolicyManager;\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n import android.os.UserManager;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n import android.view.WindowManager;\n@@ -48,6 +50,8 @@ import com.android.internal.app.AlertActivity;\n import com.android.internal.app.AlertController;\n import com.android.settings.R;\n \n+import java.util.List;\n+\n /** @hide */\n public class NotificationAccessConfirmationActivity extends Activity\n         implements DialogInterface {\n@@ -112,6 +116,31 @@ public class NotificationAccessConfirmationActivity extends Activity\n             return;\n         }\n \n+        // Check NLS service info.\n+        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n+        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n+        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n+                NLSIntent, /* flags */ 0, mUserId);\n+        boolean hasNLSIntentFilter = false;\n+        for (ResolveInfo service : matchedServiceList) {\n+            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n+                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n+                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n+                            + requiredPermission);\n+                    finish();\n+                    return;\n+                }\n+                hasNLSIntentFilter = true;\n+                break;\n+            }\n+        }\n+        if (!hasNLSIntentFilter) {\n+            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n+                    + \"for android.service.notification.NotificationListenerService.\");\n+            finish();\n+            return;\n+        }\n+\n         AlertController.AlertParams p = new AlertController.AlertParams(this);\n         p.mTitle = getString(\n                 R.string.notification_listener_security_warning_title,\n@@ -146,19 +175,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n     }\n \n     private void onAllow() {\n-        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n-        try {\n-            ServiceInfo serviceInfo = getPackageManager().getServiceInfo(mComponentName, 0);\n-            if (!requiredPermission.equals(serviceInfo.permission)) {\n-                Slog.e(LOG_TAG,\n-                        \"Service \" + mComponentName + \" lacks permission \" + requiredPermission);\n-                return;\n-            }\n-        } catch (PackageManager.NameNotFoundException e) {\n-            Slog.e(LOG_TAG, \"Failed to get service info for \" + mComponentName, e);\n-            return;\n-        }\n-\n         mNm.setNotificationListenerAccessGranted(mComponentName, true);\n \n         finish();\n@@ -169,12 +185,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n         return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n     }\n \n-    @Override\n-    public void onBackPressed() {\n-        // Suppress finishing the activity on back button press,\n-        // consistently with the permission dialog behavior\n-    }\n-\n     @Override\n     public void cancel() {\n         finish();\ndiff --git a/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java b/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java\nindex 86631ffb2d4..788f853e19b 100644\n--- a/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java\n+++ b/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java\n@@ -30,8 +30,6 @@ import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageInfo;\n import android.widget.TextView;\n \n-import com.android.settings.R;\n-\n import com.google.common.base.Strings;\n \n import org.junit.Test;\n@@ -44,15 +42,14 @@ import org.robolectric.RuntimeEnvironment;\n public class NotificationAccessConfirmationActivityTest {\n \n     @Test\n-    public void start_showsDialog() {\n+    public void start_withMissingIntentFilter_finishes() {\n         ComponentName cn = new ComponentName(\"com.example\", \"com.example.SomeService\");\n         installPackage(cn.getPackageName(), \"X\");\n \n         NotificationAccessConfirmationActivity activity = startActivityWithIntent(cn);\n \n-        assertThat(activity.isFinishing()).isFalse();\n-        assertThat(getDialogText(activity)).isEqualTo(\n-                activity.getString(R.string.notification_listener_security_warning_summary, \"X\"));\n+        assertThat(getDialogText(activity)).isNull();\n+        assertThat(activity.isFinishing()).isTrue();\n     }\n \n     @Test\n",
                            "downstream_patch_tokens": {
                                "openai": 1305,
                                "general": {
                                    "word_based": 528,
                                    "char_based": 1532
                                },
                                "gemini": 1713
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-277207798",
            "aliases": [
                "A-277207798",
                "CVE-2025-22416"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-277207798",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "bad47a2280c7107e1213f4adc5a3825a62698d00"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From bad47a2280c7107e1213f4adc5a3825a62698d00 Mon Sep 17 00:00:00 2001\nFrom: Andrey Yepin <ayepin@google.com>\nDate: Mon, 9 Dec 2024 21:34:17 -0800\nSubject: [PATCH] Verify that the caller has permissions for the icons it\n provided.\n\nBug: 277207798\nTest: manual testing: first reroduce the issue as described in the\n ticket then check that it is not reproduceable after the fix.\nChange-Id: I08992550507572a4878c501184360a58adef53ad\n---\n .../android/internal/app/ChooserActivity.java | 50 ++++++++++++++++++-\n 1 file changed, 49 insertions(+), 1 deletion(-)\n\ndiff --git a/core/java/com/android/internal/app/ChooserActivity.java b/core/java/com/android/internal/app/ChooserActivity.java\nindex f9d553ffc0c1..ebd015f1c429 100644\n--- a/core/java/com/android/internal/app/ChooserActivity.java\n+++ b/core/java/com/android/internal/app/ChooserActivity.java\n@@ -21,6 +21,7 @@ import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT\n import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT_SHARE_WITH_PERSONAL;\n import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT_SHARE_WITH_WORK;\n import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CROSS_PROFILE_BLOCKED_TITLE;\n+import static android.content.ContentProvider.getUriWithoutUserId;\n import static android.content.ContentProvider.getUserIdFromUri;\n import static android.stats.devicepolicy.DevicePolicyEnums.RESOLVER_EMPTY_STATE_NO_SHARING_TO_PERSONAL;\n import static android.stats.devicepolicy.DevicePolicyEnums.RESOLVER_EMPTY_STATE_NO_SHARING_TO_WORK;\n@@ -40,7 +41,9 @@ import android.annotation.Nullable;\n import android.app.Activity;\n import android.app.ActivityManager;\n import android.app.ActivityOptions;\n+import android.app.IUriGrantsManager;\n import android.app.SharedElementCallback;\n+import android.app.UriGrantsManager;\n import android.app.prediction.AppPredictionContext;\n import android.app.prediction.AppPredictionManager;\n import android.app.prediction.AppPredictor;\n@@ -77,6 +80,7 @@ import android.graphics.Paint;\n import android.graphics.Path;\n import android.graphics.drawable.AnimatedVectorDrawable;\n import android.graphics.drawable.Drawable;\n+import android.graphics.drawable.Icon;\n import android.metrics.LogMaker;\n import android.net.Uri;\n import android.os.AsyncTask;\n@@ -86,6 +90,7 @@ import android.os.Handler;\n import android.os.Message;\n import android.os.Parcelable;\n import android.os.PatternMatcher;\n+import android.os.RemoteException;\n import android.os.ResultReceiver;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -692,7 +697,11 @@ public class ChooserActivity extends ResolverActivity implements\n                     targets = null;\n                     break;\n                 }\n-                targets[i] = (ChooserTarget) pa[i];\n+                ChooserTarget chooserTarget = (ChooserTarget) pa[i];\n+                if (!hasValidIcon(chooserTarget)) {\n+                    chooserTarget = removeIcon(chooserTarget);\n+                }\n+                targets[i] = chooserTarget;\n             }\n             mCallerChooserTargets = targets;\n         }\n@@ -4313,4 +4322,43 @@ public class ChooserActivity extends ResolverActivity implements\n     private boolean shouldNearbyShareBeIncludedAsActionButton() {\n         return !shouldNearbyShareBeFirstInRankedRow();\n     }\n+\n+    private boolean hasValidIcon(ChooserTarget target) {\n+        Icon icon = target.getIcon();\n+        if (icon == null) {\n+            return true;\n+        }\n+        if (icon.getType() == Icon.TYPE_URI || icon.getType() == Icon.TYPE_URI_ADAPTIVE_BITMAP) {\n+            Uri uri = icon.getUri();\n+            try {\n+                getUriGrantsManager().checkGrantUriPermission_ignoreNonSystem(\n+                        getLaunchedFromUid(),\n+                        getPackageName(),\n+                        getUriWithoutUserId(uri),\n+                        Intent.FLAG_GRANT_READ_URI_PERMISSION,\n+                        getUserIdFromUri(uri)\n+                );\n+            } catch (SecurityException | RemoteException e) {\n+                Log.e(TAG, \"Failed to get URI permission for: \" + uri, e);\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private IUriGrantsManager getUriGrantsManager() {\n+        return UriGrantsManager.getService();\n+    }\n+\n+    private static ChooserTarget removeIcon(ChooserTarget target) {\n+        if (target == null) {\n+            return null;\n+        }\n+        return new ChooserTarget(\n+                target.getTitle(),\n+                null,\n+                target.getScore(),\n+                target.getComponentName(),\n+                target.getIntentExtras());\n+    }\n }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 1058,
                        "general": {
                            "word_based": 448,
                            "char_based": 1193
                        },
                        "gemini": 1391
                    },
                    "total_downstream_versions_tested": 2,
                    "successful_patches": 1,
                    "failed_patches": 1,
                    "patch_results": [
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "e73bb60fed12daa78ddad8308b31b0c78f1c3c66",
                            "repo_path": "android_repos/base",
                            "result": "failure",
                            "downstream_patch_content": "commit e73bb60fed12daa78ddad8308b31b0c78f1c3c66\nAuthor: Andrey Yepin <ayepin@google.com>\nDate:   Mon Dec 9 17:12:10 2024 -0800\n\n    Verify that the caller has permissions for the icons it provided.\n    \n    Bug: 277207798\n    Test: manual testing: first reroduce the issue as described in the\n     ticket then check that it is not reproduceable after the fix.\n    Merged-In: I08992550507572a4878c501184360a58adef53ad\n    Change-Id: Ic8cb75ed586e94c5895065f772bfb21013396dd0\n\ndiff --git a/core/java/com/android/internal/app/ChooserActivity.java b/core/java/com/android/internal/app/ChooserActivity.java\nindex 919c176b5841..4e4305aa73b1 100644\n--- a/core/java/com/android/internal/app/ChooserActivity.java\n+++ b/core/java/com/android/internal/app/ChooserActivity.java\n@@ -16,6 +16,7 @@\n \n package com.android.internal.app;\n \n+import static android.content.ContentProvider.getUriWithoutUserId;\n import static android.content.ContentProvider.getUserIdFromUri;\n \n import static com.android.internal.util.LatencyTracker.ACTION_LOAD_SHARE_SHEET;\n@@ -32,7 +33,9 @@ import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.Activity;\n import android.app.ActivityManager;\n+import android.app.IUriGrantsManager;\n import android.app.SharedElementCallback;\n+import android.app.UriGrantsManager;\n import android.app.prediction.AppPredictionContext;\n import android.app.prediction.AppPredictionManager;\n import android.app.prediction.AppPredictor;\n@@ -68,6 +71,7 @@ import android.graphics.Paint;\n import android.graphics.Path;\n import android.graphics.drawable.AnimatedVectorDrawable;\n import android.graphics.drawable.Drawable;\n+import android.graphics.drawable.Icon;\n import android.metrics.LogMaker;\n import android.net.Uri;\n import android.os.AsyncTask;\n@@ -77,6 +81,7 @@ import android.os.Handler;\n import android.os.Message;\n import android.os.Parcelable;\n import android.os.PatternMatcher;\n+import android.os.RemoteException;\n import android.os.ResultReceiver;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -663,7 +668,11 @@ public class ChooserActivity extends ResolverActivity implements\n                     targets = null;\n                     break;\n                 }\n-                targets[i] = (ChooserTarget) pa[i];\n+                ChooserTarget chooserTarget = (ChooserTarget) pa[i];\n+                if (!hasValidIcon(chooserTarget)) {\n+                    chooserTarget = removeIcon(chooserTarget);\n+                }\n+                targets[i] = chooserTarget;\n             }\n             mCallerChooserTargets = targets;\n         }\n@@ -4038,4 +4047,43 @@ public class ChooserActivity extends ResolverActivity implements\n     private boolean shouldNearbyShareBeIncludedAsActionButton() {\n         return !shouldNearbyShareBeFirstInRankedRow();\n     }\n+\n+    private boolean hasValidIcon(ChooserTarget target) {\n+        Icon icon = target.getIcon();\n+        if (icon == null) {\n+            return true;\n+        }\n+        if (icon.getType() == Icon.TYPE_URI || icon.getType() == Icon.TYPE_URI_ADAPTIVE_BITMAP) {\n+            Uri uri = icon.getUri();\n+            try {\n+                getUriGrantsManager().checkGrantUriPermission_ignoreNonSystem(\n+                        getLaunchedFromUid(),\n+                        getPackageName(),\n+                        getUriWithoutUserId(uri),\n+                        Intent.FLAG_GRANT_READ_URI_PERMISSION,\n+                        getUserIdFromUri(uri)\n+                );\n+            } catch (SecurityException | RemoteException e) {\n+                Log.e(TAG, \"Failed to get URI permission for: \" + uri, e);\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private IUriGrantsManager getUriGrantsManager() {\n+        return UriGrantsManager.getService();\n+    }\n+\n+    private static ChooserTarget removeIcon(ChooserTarget target) {\n+        if (target == null) {\n+            return null;\n+        }\n+        return new ChooserTarget(\n+                target.getTitle(),\n+                null,\n+                target.getScore(),\n+                target.getComponentName(),\n+                target.getIntentExtras());\n+    }\n }\n",
                            "downstream_patch_tokens": {
                                "openai": 937,
                                "general": {
                                    "word_based": 386,
                                    "char_based": 1047
                                },
                                "gemini": 1225
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "core/java/com/android/internal/app/ChooserActivity.java",
                                    "total_hunks": 6,
                                    "failed_hunks": [
                                        1,
                                        2
                                    ],
                                    "inline_merge_conflicts": [],
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    },
                                    "rej_file_content": "```diff\n--- core/java/com/android/internal/app/ChooserActivity.java\n+++ core/java/com/android/internal/app/ChooserActivity.java\n@@ -21,6 +21,7 @@ import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT\n import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT_SHARE_WITH_PERSONAL;\n import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT_SHARE_WITH_WORK;\n import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CROSS_PROFILE_BLOCKED_TITLE;\n+import static android.content.ContentProvider.getUriWithoutUserId;\n import static android.content.ContentProvider.getUserIdFromUri;\n import static android.stats.devicepolicy.DevicePolicyEnums.RESOLVER_EMPTY_STATE_NO_SHARING_TO_PERSONAL;\n import static android.stats.devicepolicy.DevicePolicyEnums.RESOLVER_EMPTY_STATE_NO_SHARING_TO_WORK;\n@@ -40,7 +41,9 @@ import android.annotation.Nullable;\n import android.app.Activity;\n import android.app.ActivityManager;\n import android.app.ActivityOptions;\n+import android.app.IUriGrantsManager;\n import android.app.SharedElementCallback;\n+import android.app.UriGrantsManager;\n import android.app.prediction.AppPredictionContext;\n import android.app.prediction.AppPredictionManager;\n import android.app.prediction.AppPredictor;\n```",
                                    "rej_file_tokens": {
                                        "openai": 257,
                                        "general": {
                                            "word_based": 129,
                                            "char_based": 323
                                        },
                                        "gemini": 365
                                    },
                                    "patch_apply_output": "patching file core/java/com/android/internal/app/ChooserActivity.java\nHunk #1 FAILED at 21.\nHunk #2 FAILED at 40.\nHunk #3 succeeded at 68 (offset -9 lines).\nHunk #4 succeeded at 78 (offset -9 lines).\nHunk #5 succeeded at 665 (offset -29 lines).\nHunk #6 succeeded at 4044 (offset -275 lines).\n2 out of 6 hunks FAILED -- saving rejects to file core/java/com/android/internal/app/ChooserActivity.java.rej",
                                    "inline_merge_output": "patching file core/java/com/android/internal/app/ChooserActivity.java\nHunk #1 already applied at 24.\nHunk #2 already applied at 44,46.\nHunk #3 already applied at 83.\nHunk #4 already applied at 93.\nHunk #5 already applied at 700-704.\nHunk #6 merged at 4364-4402.",
                                    "upstream_file_tokens": {
                                        "openai": 34446,
                                        "general": {
                                            "word_based": 13143,
                                            "char_based": 46127
                                        },
                                        "gemini": 40995
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.internal.app;\n\nimport static android.content.ContentProvider.getUserIdFromUri;\n\nimport static com.android.internal.util.LatencyTracker.ACTION_LOAD_SHARE_SHEET;\n\nimport static java.lang.annotation.RetentionPolicy.SOURCE;\n\nimport android.animation.Animator;\nimport android.animation.AnimatorListenerAdapter;\nimport android.animation.AnimatorSet;\nimport android.animation.ObjectAnimator;\nimport android.animation.ValueAnimator;\nimport android.annotation.IntDef;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.SharedElementCallback;\nimport android.app.prediction.AppPredictionContext;\nimport android.app.prediction.AppPredictionManager;\nimport android.app.prediction.AppPredictor;\nimport android.app.prediction.AppTarget;\nimport android.app.prediction.AppTargetEvent;\nimport android.app.prediction.AppTargetId;\nimport android.compat.annotation.UnsupportedAppUsage;\nimport android.content.ClipData;\nimport android.content.ClipboardManager;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.IntentSender.SendIntentException;\nimport android.content.SharedPreferences;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.ShortcutInfo;\nimport android.content.pm.ShortcutManager;\nimport android.content.res.Configuration;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.database.DataSetObserver;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.graphics.Path;\nimport android.graphics.drawable.AnimatedVectorDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.graphics.drawable.Icon;\nimport android.metrics.LogMaker;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Parcelable;\nimport android.os.PatternMatcher;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.storage.StorageManager;\nimport android.provider.DeviceConfig;\nimport android.provider.DocumentsContract;\nimport android.provider.Downloads;\nimport android.provider.OpenableColumns;\nimport android.provider.Settings;\nimport android.service.chooser.ChooserTarget;\nimport android.text.TextUtils;\nimport android.util.AttributeSet;\nimport android.util.HashedStringCache;\nimport android.util.Log;\nimport android.util.PluralsMessageFormatter;\nimport android.util.Size;\nimport android.util.Slog;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.View.MeasureSpec;\nimport android.view.View.OnClickListener;\nimport android.view.ViewGroup;\nimport android.view.ViewGroup.LayoutParams;\nimport android.view.ViewTreeObserver;\nimport android.view.WindowInsets;\nimport android.view.animation.AccelerateInterpolator;\nimport android.view.animation.DecelerateInterpolator;\nimport android.widget.Button;\nimport android.widget.ImageView;\nimport android.widget.Space;\nimport android.widget.TextView;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.app.ResolverListAdapter.ActivityInfoPresentationGetter;\nimport com.android.internal.app.ResolverListAdapter.ViewHolder;\nimport com.android.internal.app.chooser.ChooserTargetInfo;\nimport com.android.internal.app.chooser.DisplayResolveInfo;\nimport com.android.internal.app.chooser.MultiDisplayResolveInfo;\nimport com.android.internal.app.chooser.NotSelectableTargetInfo;\nimport com.android.internal.app.chooser.SelectableTargetInfo;\nimport com.android.internal.app.chooser.SelectableTargetInfo.SelectableTargetInfoCommunicator;\nimport com.android.internal.app.chooser.TargetInfo;\nimport com.android.internal.config.sysui.SystemUiDeviceConfigFlags;\nimport com.android.internal.content.PackageMonitor;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto.MetricsEvent;\nimport com.android.internal.util.FrameworkStatsLog;\nimport com.android.internal.widget.GridLayoutManager;\nimport com.android.internal.widget.RecyclerView;\nimport com.android.internal.widget.ResolverDrawerLayout;\nimport com.android.internal.widget.ViewPager;\n\nimport com.google.android.collect.Lists;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.net.URISyntaxException;\nimport java.text.Collator;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\n\n/**\n * The Chooser Activity handles intent resolution specifically for sharing intents -\n * for example, those generated by @see android.content.Intent#createChooser(Intent, CharSequence).\n *\n */\npublic class ChooserActivity extends ResolverActivity implements\n        ChooserListAdapter.ChooserListCommunicator,\n        SelectableTargetInfoCommunicator {\n    private static final String TAG = \"ChooserActivity\";\n\n    private AppPredictor mPersonalAppPredictor;\n    private AppPredictor mWorkAppPredictor;\n    private boolean mShouldDisplayLandscape;\n\n    @UnsupportedAppUsage\n    public ChooserActivity() {\n    }\n    /**\n     * Boolean extra to change the following behavior: Normally, ChooserActivity finishes itself\n     * in onStop when launched in a new task. If this extra is set to true, we do not finish\n     * ourselves when onStop gets called.\n     */\n    public static final String EXTRA_PRIVATE_RETAIN_IN_ON_STOP\n            = \"com.android.internal.app.ChooserActivity.EXTRA_PRIVATE_RETAIN_IN_ON_STOP\";\n\n\n    /**\n     * Transition name for the first image preview.\n     * To be used for shared element transition into this activity.\n     * @hide\n     */\n    public static final String FIRST_IMAGE_PREVIEW_TRANSITION_NAME = \"screenshot_preview_image\";\n\n    private static final String PREF_NUM_SHEET_EXPANSIONS = \"pref_num_sheet_expansions\";\n\n    private static final String CHIP_LABEL_METADATA_KEY = \"android.service.chooser.chip_label\";\n    private static final String CHIP_ICON_METADATA_KEY = \"android.service.chooser.chip_icon\";\n\n    private static final boolean DEBUG = true;\n\n    private static final boolean USE_PREDICTION_MANAGER_FOR_SHARE_ACTIVITIES = true;\n    // TODO(b/123088566) Share these in a better way.\n    private static final String APP_PREDICTION_SHARE_UI_SURFACE = \"share\";\n    public static final String LAUNCH_LOCATION_DIRECT_SHARE = \"direct_share\";\n    public static final String CHOOSER_TARGET = \"chooser_target\";\n    private static final String SHORTCUT_TARGET = \"shortcut_target\";\n    private static final int APP_PREDICTION_SHARE_TARGET_QUERY_PACKAGE_LIMIT = 20;\n    public static final String APP_PREDICTION_INTENT_FILTER_KEY = \"intent_filter\";\n    private static final String SHARED_TEXT_KEY = \"shared_text\";\n\n    private static final String PLURALS_COUNT = \"count\";\n    private static final String PLURALS_FILE_NAME = \"file_name\";\n\n    private boolean mIsAppPredictorComponentAvailable;\n    private Map<ChooserTarget, AppTarget> mDirectShareAppTargetCache;\n    private Map<ChooserTarget, ShortcutInfo> mDirectShareShortcutInfoCache;\n\n    public static final int TARGET_TYPE_DEFAULT = 0;\n    public static final int TARGET_TYPE_CHOOSER_TARGET = 1;\n    public static final int TARGET_TYPE_SHORTCUTS_FROM_SHORTCUT_MANAGER = 2;\n    public static final int TARGET_TYPE_SHORTCUTS_FROM_PREDICTION_SERVICE = 3;\n\n    public static final int SELECTION_TYPE_SERVICE = 1;\n    public static final int SELECTION_TYPE_APP = 2;\n    public static final int SELECTION_TYPE_STANDARD = 3;\n    public static final int SELECTION_TYPE_COPY = 4;\n    public static final int SELECTION_TYPE_NEARBY = 5;\n    public static final int SELECTION_TYPE_EDIT = 6;\n\n    private static final int SCROLL_STATUS_IDLE = 0;\n    private static final int SCROLL_STATUS_SCROLLING_VERTICAL = 1;\n    private static final int SCROLL_STATUS_SCROLLING_HORIZONTAL = 2;\n\n    // statsd logger wrapper\n    protected ChooserActivityLogger mChooserActivityLogger;\n\n    @IntDef(flag = false, prefix = { \"TARGET_TYPE_\" }, value = {\n            TARGET_TYPE_DEFAULT,\n            TARGET_TYPE_CHOOSER_TARGET,\n            TARGET_TYPE_SHORTCUTS_FROM_SHORTCUT_MANAGER,\n            TARGET_TYPE_SHORTCUTS_FROM_PREDICTION_SERVICE\n    })\n    @Retention(RetentionPolicy.SOURCE)\n    public @interface ShareTargetType {}\n\n    /**\n     * The transition time between placeholders for direct share to a message\n     * indicating that non are available.\n     */\n    private static final int NO_DIRECT_SHARE_ANIM_IN_MILLIS = 200;\n\n    private static final float DIRECT_SHARE_EXPANSION_RATE = 0.78f;\n\n    private static final int DEFAULT_SALT_EXPIRATION_DAYS = 7;\n    private int mMaxHashSaltDays = DeviceConfig.getInt(DeviceConfig.NAMESPACE_SYSTEMUI,\n            SystemUiDeviceConfigFlags.HASH_SALT_MAX_DAYS,\n            DEFAULT_SALT_EXPIRATION_DAYS);\n\n    private static final boolean DEFAULT_IS_NEARBY_SHARE_FIRST_TARGET_IN_RANKED_APP = false;\n    private boolean mIsNearbyShareFirstTargetInRankedApp =\n            DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_SYSTEMUI,\n                    SystemUiDeviceConfigFlags.IS_NEARBY_SHARE_FIRST_TARGET_IN_RANKED_APP,\n                    DEFAULT_IS_NEARBY_SHARE_FIRST_TARGET_IN_RANKED_APP);\n\n    private static final int DEFAULT_LIST_VIEW_UPDATE_DELAY_MS = 125;\n\n    @VisibleForTesting\n    int mListViewUpdateDelayMs = DeviceConfig.getInt(DeviceConfig.NAMESPACE_SYSTEMUI,\n            SystemUiDeviceConfigFlags.SHARESHEET_LIST_VIEW_UPDATE_DELAY,\n            DEFAULT_LIST_VIEW_UPDATE_DELAY_MS);\n\n    private Bundle mReplacementExtras;\n    private IntentSender mChosenComponentSender;\n    private IntentSender mRefinementIntentSender;\n    private RefinementResultReceiver mRefinementResultReceiver;\n    private ChooserTarget[] mCallerChooserTargets;\n    private ComponentName[] mFilteredComponentNames;\n\n    private Intent mReferrerFillInIntent;\n\n    private long mChooserShownTime;\n    protected boolean mIsSuccessfullySelected;\n\n    private long mQueriedSharingShortcutsTimeMs;\n\n    private int mCurrAvailableWidth = 0;\n    private int mLastNumberOfChildren = -1;\n    private int mMaxTargetsPerRow = 1;\n\n    private static final String TARGET_DETAILS_FRAGMENT_TAG = \"targetDetailsFragment\";\n\n    private static final int MAX_LOG_RANK_POSITION = 12;\n\n    private static final int MAX_EXTRA_INITIAL_INTENTS = 2;\n    private static final int MAX_EXTRA_CHOOSER_TARGETS = 2;\n\n    private SharedPreferences mPinnedSharedPrefs;\n    private static final String PINNED_SHARED_PREFS_NAME = \"chooser_pin_settings\";\n\n    @Retention(SOURCE)\n    @IntDef({CONTENT_PREVIEW_FILE, CONTENT_PREVIEW_IMAGE, CONTENT_PREVIEW_TEXT})\n    private @interface ContentPreviewType {\n    }\n\n    // Starting at 1 since 0 is considered \"undefined\" for some of the database transformations\n    // of tron logs.\n    protected static final int CONTENT_PREVIEW_IMAGE = 1;\n    protected static final int CONTENT_PREVIEW_FILE = 2;\n    protected static final int CONTENT_PREVIEW_TEXT = 3;\n    protected MetricsLogger mMetricsLogger;\n\n    private ContentPreviewCoordinator mPreviewCoord;\n    private int mScrollStatus = SCROLL_STATUS_IDLE;\n\n    @VisibleForTesting\n    protected ChooserMultiProfilePagerAdapter mChooserMultiProfilePagerAdapter;\n    private final EnterTransitionAnimationDelegate mEnterTransitionAnimationDelegate =\n            new EnterTransitionAnimationDelegate();\n\n    private boolean mRemoveSharedElements = false;\n\n    private class ContentPreviewCoordinator {\n        private static final int IMAGE_FADE_IN_MILLIS = 150;\n        private static final int IMAGE_LOAD_TIMEOUT = 1;\n        private static final int IMAGE_LOAD_INTO_VIEW = 2;\n\n        private final int mImageLoadTimeoutMillis =\n                getResources().getInteger(R.integer.config_shortAnimTime);\n\n        private final View mParentView;\n        private boolean mHideParentOnFail;\n        private boolean mAtLeastOneLoaded = false;\n\n        class LoadUriTask {\n            public final Uri mUri;\n            public final int mImageResourceId;\n            public final int mExtraCount;\n            public final Bitmap mBmp;\n\n            LoadUriTask(int imageResourceId, Uri uri, int extraCount, Bitmap bmp) {\n                this.mImageResourceId = imageResourceId;\n                this.mUri = uri;\n                this.mExtraCount = extraCount;\n                this.mBmp = bmp;\n            }\n        }\n\n        // If at least one image loads within the timeout period, allow other\n        // loads to continue. Otherwise terminate and optionally hide\n        // the parent area\n        private final Handler mHandler = new Handler() {\n            @Override\n            public void handleMessage(Message msg) {\n                switch (msg.what) {\n                    case IMAGE_LOAD_TIMEOUT:\n                        maybeHideContentPreview();\n                        break;\n\n                    case IMAGE_LOAD_INTO_VIEW:\n                        if (isFinishing()) break;\n\n                        LoadUriTask task = (LoadUriTask) msg.obj;\n                        RoundedRectImageView imageView = mParentView.findViewById(\n                                task.mImageResourceId);\n                        if (task.mBmp == null) {\n                            imageView.setVisibility(View.GONE);\n                            maybeHideContentPreview();\n                            return;\n                        }\n\n                        mAtLeastOneLoaded = true;\n                        imageView.setVisibility(View.VISIBLE);\n                        imageView.setAlpha(0.0f);\n                        imageView.setImageBitmap(task.mBmp);\n\n                        ValueAnimator fadeAnim = ObjectAnimator.ofFloat(imageView, \"alpha\", 0.0f,\n                                1.0f);\n                        fadeAnim.setInterpolator(new DecelerateInterpolator(1.0f));\n                        fadeAnim.setDuration(IMAGE_FADE_IN_MILLIS);\n                        fadeAnim.start();\n\n                        if (task.mExtraCount > 0) {\n                            imageView.setExtraImageCount(task.mExtraCount);\n                        }\n\n                        setupPreDrawForSharedElementTransition(imageView);\n                }\n            }\n        };\n\n        private void setupPreDrawForSharedElementTransition(View v) {\n            v.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n                @Override\n                public boolean onPreDraw() {\n                    v.getViewTreeObserver().removeOnPreDrawListener(this);\n\n                    if (!mRemoveSharedElements && isActivityTransitionRunning()) {\n                        // Disable the window animations as it interferes with the\n                        // transition animation.\n                        getWindow().setWindowAnimations(0);\n                    }\n                    mEnterTransitionAnimationDelegate.markImagePreviewReady();\n                    return true;\n                }\n            });\n        }\n\n        ContentPreviewCoordinator(View parentView, boolean hideParentOnFail) {\n            super();\n\n            this.mParentView = parentView;\n            this.mHideParentOnFail = hideParentOnFail;\n        }\n\n        private void loadUriIntoView(final int imageResourceId, final Uri uri,\n                final int extraImages) {\n            mHandler.sendEmptyMessageDelayed(IMAGE_LOAD_TIMEOUT, mImageLoadTimeoutMillis);\n\n            AsyncTask.THREAD_POOL_EXECUTOR.execute(() -> {\n                int size = getResources().getDimensionPixelSize(\n                        R.dimen.chooser_preview_image_max_dimen);\n                final Bitmap bmp = loadThumbnail(uri, new Size(size, size));\n                final Message msg = Message.obtain();\n                msg.what = IMAGE_LOAD_INTO_VIEW;\n                msg.obj = new LoadUriTask(imageResourceId, uri, extraImages, bmp);\n                mHandler.sendMessage(msg);\n            });\n        }\n\n        private void cancelLoads() {\n            mHandler.removeMessages(IMAGE_LOAD_INTO_VIEW);\n            mHandler.removeMessages(IMAGE_LOAD_TIMEOUT);\n        }\n\n        private void maybeHideContentPreview() {\n            if (!mAtLeastOneLoaded) {\n                if (mHideParentOnFail) {\n                    Log.i(TAG, \"Hiding image preview area. Timed out waiting for preview to load\"\n                            + \" within \" + mImageLoadTimeoutMillis + \"ms.\");\n                    collapseParentView();\n                    if (shouldShowTabs()) {\n                        hideStickyContentPreview();\n                    } else if (mChooserMultiProfilePagerAdapter.getCurrentRootAdapter() != null) {\n                        mChooserMultiProfilePagerAdapter.getCurrentRootAdapter()\n                                .hideContentPreview();\n                    }\n                    mHideParentOnFail = false;\n                }\n                mRemoveSharedElements = true;\n                mEnterTransitionAnimationDelegate.markImagePreviewReady();\n            }\n        }\n\n        private void collapseParentView() {\n            // This will effectively hide the content preview row by forcing the height\n            // to zero. It is faster than forcing a relayout of the listview\n            final View v = mParentView;\n            int widthSpec = MeasureSpec.makeMeasureSpec(v.getWidth(), MeasureSpec.EXACTLY);\n            int heightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.EXACTLY);\n            v.measure(widthSpec, heightSpec);\n            v.getLayoutParams().height = 0;\n            v.layout(v.getLeft(), v.getTop(), v.getRight(), v.getTop());\n            v.invalidate();\n        }\n    }\n\n    private final ChooserHandler mChooserHandler = new ChooserHandler();\n\n    private class ChooserHandler extends Handler {\n        private static final int LIST_VIEW_UPDATE_MESSAGE = 6;\n        private static final int SHORTCUT_MANAGER_ALL_SHARE_TARGET_RESULTS = 7;\n\n        private void removeAllMessages() {\n            removeMessages(LIST_VIEW_UPDATE_MESSAGE);\n            removeMessages(SHORTCUT_MANAGER_ALL_SHARE_TARGET_RESULTS);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            if (mChooserMultiProfilePagerAdapter.getActiveListAdapter() == null || isDestroyed()) {\n                return;\n            }\n\n            switch (msg.what) {\n                case LIST_VIEW_UPDATE_MESSAGE:\n                    if (DEBUG) {\n                        Log.d(TAG, \"LIST_VIEW_UPDATE_MESSAGE; \");\n                    }\n\n                    UserHandle userHandle = (UserHandle) msg.obj;\n                    mChooserMultiProfilePagerAdapter.getListAdapterForUserHandle(userHandle)\n                            .refreshListView();\n                    break;\n\n                case SHORTCUT_MANAGER_ALL_SHARE_TARGET_RESULTS:\n                    if (DEBUG) Log.d(TAG, \"SHORTCUT_MANAGER_ALL_SHARE_TARGET_RESULTS\");\n                    final ServiceResultInfo[] resultInfos = (ServiceResultInfo[]) msg.obj;\n                    for (ServiceResultInfo resultInfo : resultInfos) {\n                        if (resultInfo.resultTargets != null) {\n                            ChooserListAdapter adapterForUserHandle =\n                                    mChooserMultiProfilePagerAdapter.getListAdapterForUserHandle(\n                                            resultInfo.userHandle);\n                            if (adapterForUserHandle != null) {\n                                adapterForUserHandle.addServiceResults(\n                                        resultInfo.originalTarget,\n                                        resultInfo.resultTargets, msg.arg1,\n                                        mDirectShareShortcutInfoCache);\n                            }\n                        }\n                    }\n\n                    logDirectShareTargetReceived(\n                            MetricsEvent.ACTION_DIRECT_SHARE_TARGETS_LOADED_SHORTCUT_MANAGER);\n                    sendVoiceChoicesIfNeeded();\n                    getChooserActivityLogger().logSharesheetDirectLoadComplete();\n\n                    mChooserMultiProfilePagerAdapter.getActiveListAdapter()\n                            .completeServiceTargetLoading();\n                    break;\n\n                default:\n                    super.handleMessage(msg);\n            }\n        }\n    };\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        if (Settings.Secure.getIntForUser(getContentResolver(),\n                Settings.Secure.SECURE_FRP_MODE, 0,\n                getUserId()) == 1) {\n            Log.e(TAG, \"Sharing disabled due to active FRP lock.\");\n            super.onCreate(savedInstanceState);\n            finish();\n            return;\n        }\n        final long intentReceivedTime = System.currentTimeMillis();\n        mLatencyTracker.onActionStart(ACTION_LOAD_SHARE_SHEET);\n\n        getChooserActivityLogger().logSharesheetTriggered();\n        // This is the only place this value is being set. Effectively final.\n        mIsAppPredictorComponentAvailable = isAppPredictionServiceAvailable();\n\n        mIsSuccessfullySelected = false;\n        Intent intent = getIntent();\n        Parcelable targetParcelable = intent.getParcelableExtra(Intent.EXTRA_INTENT);\n        if (targetParcelable instanceof Uri) {\n            try {\n                targetParcelable = Intent.parseUri(targetParcelable.toString(),\n                        Intent.URI_INTENT_SCHEME);\n            } catch (URISyntaxException ex) {\n                // doesn't parse as an intent; let the next test fail and error out\n            }\n        }\n\n        if (!(targetParcelable instanceof Intent)) {\n            Log.w(\"ChooserActivity\", \"Target is not an intent: \" + targetParcelable);\n            finish();\n            super.onCreate(null);\n            return;\n        }\n        Intent target = (Intent) targetParcelable;\n        if (target != null) {\n            modifyTargetIntent(target);\n        }\n        Parcelable[] targetsParcelable\n                = intent.getParcelableArrayExtra(Intent.EXTRA_ALTERNATE_INTENTS);\n        if (targetsParcelable != null) {\n            final boolean offset = target == null;\n            Intent[] additionalTargets =\n                    new Intent[offset ? targetsParcelable.length - 1 : targetsParcelable.length];\n            for (int i = 0; i < targetsParcelable.length; i++) {\n                if (!(targetsParcelable[i] instanceof Intent)) {\n                    Log.w(TAG, \"EXTRA_ALTERNATE_INTENTS array entry #\" + i + \" is not an Intent: \"\n                            + targetsParcelable[i]);\n                    finish();\n                    super.onCreate(null);\n                    return;\n                }\n                final Intent additionalTarget = (Intent) targetsParcelable[i];\n                if (i == 0 && target == null) {\n                    target = additionalTarget;\n                    modifyTargetIntent(target);\n                } else {\n                    additionalTargets[offset ? i - 1 : i] = additionalTarget;\n                    modifyTargetIntent(additionalTarget);\n                }\n            }\n            setAdditionalTargets(additionalTargets);\n        }\n\n        mReplacementExtras = intent.getBundleExtra(Intent.EXTRA_REPLACEMENT_EXTRAS);\n\n        // Do not allow the title to be changed when sharing content\n        CharSequence title = null;\n        if (target != null) {\n            if (!isSendAction(target)) {\n                title = intent.getCharSequenceExtra(Intent.EXTRA_TITLE);\n            } else {\n                Log.w(TAG, \"Ignoring intent's EXTRA_TITLE, deprecated in P. You may wish to set a\"\n                        + \" preview title by using EXTRA_TITLE property of the wrapped\"\n                        + \" EXTRA_INTENT.\");\n            }\n        }\n\n        int defaultTitleRes = 0;\n        if (title == null) {\n            defaultTitleRes = com.android.internal.R.string.chooseActivity;\n        }\n\n        Parcelable[] pa = intent.getParcelableArrayExtra(Intent.EXTRA_INITIAL_INTENTS);\n        Intent[] initialIntents = null;\n        if (pa != null) {\n            int count = Math.min(pa.length, MAX_EXTRA_INITIAL_INTENTS);\n            initialIntents = new Intent[count];\n            for (int i = 0; i < count; i++) {\n                if (!(pa[i] instanceof Intent)) {\n                    Log.w(TAG, \"Initial intent #\" + i + \" not an Intent: \" + pa[i]);\n                    finish();\n                    super.onCreate(null);\n                    return;\n                }\n                final Intent in = (Intent) pa[i];\n                modifyTargetIntent(in);\n                initialIntents[i] = in;\n            }\n        }\n\n        mReferrerFillInIntent = new Intent().putExtra(Intent.EXTRA_REFERRER, getReferrer());\n\n        mChosenComponentSender = intent.getParcelableExtra(\n                Intent.EXTRA_CHOSEN_COMPONENT_INTENT_SENDER);\n        mRefinementIntentSender = intent.getParcelableExtra(\n                Intent.EXTRA_CHOOSER_REFINEMENT_INTENT_SENDER);\n        setSafeForwardingMode(true);\n\n        mPinnedSharedPrefs = getPinnedSharedPrefs(this);\n\n        pa = intent.getParcelableArrayExtra(Intent.EXTRA_EXCLUDE_COMPONENTS);\n\n\n        // Exclude out Nearby from main list if chip is present, to avoid duplication\n        ComponentName nearbySharingComponent = getNearbySharingComponent();\n        boolean shouldFilterNearby = !shouldNearbyShareBeFirstInRankedRow()\n                && nearbySharingComponent != null;\n\n        if (pa != null) {\n            ComponentName[] names = new ComponentName[pa.length + (shouldFilterNearby ? 1 : 0)];\n            for (int i = 0; i < pa.length; i++) {\n                if (!(pa[i] instanceof ComponentName)) {\n                    Log.w(TAG, \"Filtered component #\" + i + \" not a ComponentName: \" + pa[i]);\n                    names = null;\n                    break;\n                }\n                names[i] = (ComponentName) pa[i];\n            }\n            if (shouldFilterNearby) {\n                names[names.length - 1] = nearbySharingComponent;\n            }\n\n            mFilteredComponentNames = names;\n        } else if (shouldFilterNearby) {\n            mFilteredComponentNames = new ComponentName[1];\n            mFilteredComponentNames[0] = nearbySharingComponent;\n        }\n\n        pa = intent.getParcelableArrayExtra(Intent.EXTRA_CHOOSER_TARGETS);\n        if (pa != null) {\n            int count = Math.min(pa.length, MAX_EXTRA_CHOOSER_TARGETS);\n            ChooserTarget[] targets = new ChooserTarget[count];\n            for (int i = 0; i < count; i++) {\n                if (!(pa[i] instanceof ChooserTarget)) {\n                    Log.w(TAG, \"Chooser target #\" + i + \" not a ChooserTarget: \" + pa[i]);\n                    targets = null;\n                    break;\n                }\n                ChooserTarget chooserTarget = (ChooserTarget) pa[i];\n                if (!hasValidIcon(chooserTarget)) {\n                    chooserTarget = removeIcon(chooserTarget);\n                }\n                targets[i] = chooserTarget;\n            }\n            mCallerChooserTargets = targets;\n        }\n\n        mMaxTargetsPerRow = getResources().getInteger(R.integer.config_chooser_max_targets_per_row);\n        mShouldDisplayLandscape =\n                shouldDisplayLandscape(getResources().getConfiguration().orientation);\n        setRetainInOnStop(intent.getBooleanExtra(EXTRA_PRIVATE_RETAIN_IN_ON_STOP, false));\n        super.onCreate(savedInstanceState, target, title, defaultTitleRes, initialIntents,\n                null, false);\n\n        mChooserShownTime = System.currentTimeMillis();\n        final long systemCost = mChooserShownTime - intentReceivedTime;\n\n        getMetricsLogger().write(new LogMaker(MetricsEvent.ACTION_ACTIVITY_CHOOSER_SHOWN)\n                .setSubtype(isWorkProfile() ? MetricsEvent.MANAGED_PROFILE :\n                        MetricsEvent.PARENT_PROFILE)\n                .addTaggedData(MetricsEvent.FIELD_SHARESHEET_MIMETYPE, target.getType())\n                .addTaggedData(MetricsEvent.FIELD_TIME_TO_APP_TARGETS, systemCost));\n\n        if (mResolverDrawerLayout != null) {\n            mResolverDrawerLayout.addOnLayoutChangeListener(this::handleLayoutChange);\n\n            // expand/shrink direct share 4 -> 8 viewgroup\n            if (isSendAction(target)) {\n                mResolverDrawerLayout.setOnScrollChangeListener(this::handleScroll);\n            }\n\n            mResolverDrawerLayout.setOnCollapsedChangedListener(\n                    new ResolverDrawerLayout.OnCollapsedChangedListener() {\n\n                        // Only consider one expansion per activity creation\n                        private boolean mWrittenOnce = false;\n\n                        @Override\n                        public void onCollapsedChanged(boolean isCollapsed) {\n                            if (!isCollapsed && !mWrittenOnce) {\n                                incrementNumSheetExpansions();\n                                mWrittenOnce = true;\n                            }\n                            getChooserActivityLogger()\n                                    .logSharesheetExpansionChanged(isCollapsed);\n                        }\n                    });\n        }\n\n        if (DEBUG) {\n            Log.d(TAG, \"System Time Cost is \" + systemCost);\n        }\n\n        getChooserActivityLogger().logShareStarted(\n                FrameworkStatsLog.SHARESHEET_STARTED,\n                getReferrerPackageName(),\n                target.getType(),\n                mCallerChooserTargets == null ? 0 : mCallerChooserTargets.length,\n                initialIntents == null ? 0 : initialIntents.length,\n                isWorkProfile(),\n                findPreferredContentPreview(getTargetIntent(), getContentResolver()),\n                target.getAction()\n        );\n        mDirectShareShortcutInfoCache = new HashMap<>();\n\n        setEnterSharedElementCallback(new SharedElementCallback() {\n            @Override\n            public void onMapSharedElements(List<String> names, Map<String, View> sharedElements) {\n                if (mRemoveSharedElements) {\n                    names.remove(FIRST_IMAGE_PREVIEW_TRANSITION_NAME);\n                    sharedElements.remove(FIRST_IMAGE_PREVIEW_TRANSITION_NAME);\n                }\n                super.onMapSharedElements(names, sharedElements);\n                mRemoveSharedElements = false;\n            }\n        });\n        mEnterTransitionAnimationDelegate.postponeTransition();\n    }\n\n    @Override\n    protected int appliedThemeResId() {\n        return R.style.Theme_DeviceDefault_Chooser;\n    }\n\n    private AppPredictor setupAppPredictorForUser(UserHandle userHandle,\n            AppPredictor.Callback appPredictorCallback) {\n        AppPredictor appPredictor = getAppPredictorForDirectShareIfEnabled(userHandle);\n        if (appPredictor == null) {\n            return null;\n        }\n        mDirectShareAppTargetCache = new HashMap<>();\n        appPredictor.registerPredictionUpdates(this.getMainExecutor(), appPredictorCallback);\n        return appPredictor;\n    }\n\n    private AppPredictor.Callback createAppPredictorCallback(\n            ChooserListAdapter chooserListAdapter) {\n        return resultList -> {\n            if (isFinishing() || isDestroyed()) {\n                return;\n            }\n            if (chooserListAdapter.getCount() == 0) {\n                return;\n            }\n            if (resultList.isEmpty()\n                    && shouldQueryShortcutManager(chooserListAdapter.getUserHandle())) {\n                // APS may be disabled, so try querying targets ourselves.\n                queryDirectShareTargets(chooserListAdapter, true);\n                return;\n            }\n            final List<ShortcutManager.ShareShortcutInfo> shareShortcutInfos =\n                    new ArrayList<>();\n\n            List<AppTarget> shortcutResults = new ArrayList<>();\n            for (AppTarget appTarget : resultList) {\n                if (appTarget.getShortcutInfo() == null) {\n                    continue;\n                }\n                shortcutResults.add(appTarget);\n            }\n            resultList = shortcutResults;\n            for (AppTarget appTarget : resultList) {\n                shareShortcutInfos.add(new ShortcutManager.ShareShortcutInfo(\n                        appTarget.getShortcutInfo(),\n                        new ComponentName(\n                                appTarget.getPackageName(), appTarget.getClassName())));\n            }\n            sendShareShortcutInfoList(shareShortcutInfos, chooserListAdapter, resultList,\n                    chooserListAdapter.getUserHandle());\n        };\n    }\n\n    static SharedPreferences getPinnedSharedPrefs(Context context) {\n        // The code below is because in the android:ui process, no one can hear you scream.\n        // The package info in the context isn't initialized in the way it is for normal apps,\n        // so the standard, name-based context.getSharedPreferences doesn't work. Instead, we\n        // build the path manually below using the same policy that appears in ContextImpl.\n        // This fails silently under the hood if there's a problem, so if we find ourselves in\n        // the case where we don't have access to credential encrypted storage we just won't\n        // have our pinned target info.\n        final File prefsFile = new File(new File(\n                Environment.getDataUserCePackageDirectory(StorageManager.UUID_PRIVATE_INTERNAL,\n                        context.getUserId(), context.getPackageName()),\n                \"shared_prefs\"),\n                PINNED_SHARED_PREFS_NAME + \".xml\");\n        return context.getSharedPreferences(prefsFile, MODE_PRIVATE);\n    }\n\n    @Override\n    protected AbstractMultiProfilePagerAdapter createMultiProfilePagerAdapter(\n            Intent[] initialIntents,\n            List<ResolveInfo> rList,\n            boolean filterLastUsed) {\n        if (shouldShowTabs()) {\n            mChooserMultiProfilePagerAdapter = createChooserMultiProfilePagerAdapterForTwoProfiles(\n                    initialIntents, rList, filterLastUsed);\n        } else {\n            mChooserMultiProfilePagerAdapter = createChooserMultiProfilePagerAdapterForOneProfile(\n                    initialIntents, rList, filterLastUsed);\n        }\n        return mChooserMultiProfilePagerAdapter;\n    }\n\n    private ChooserMultiProfilePagerAdapter createChooserMultiProfilePagerAdapterForOneProfile(\n            Intent[] initialIntents,\n            List<ResolveInfo> rList,\n            boolean filterLastUsed) {\n        ChooserGridAdapter adapter = createChooserGridAdapter(\n                /* context */ this,\n                /* payloadIntents */ mIntents,\n                initialIntents,\n                rList,\n                filterLastUsed,\n                /* userHandle */ UserHandle.of(UserHandle.myUserId()));\n        return new ChooserMultiProfilePagerAdapter(\n                /* context */ this,\n                adapter,\n                getPersonalProfileUserHandle(),\n                /* workProfileUserHandle= */ null,\n                isSendAction(getTargetIntent()), mMaxTargetsPerRow);\n    }\n\n    private ChooserMultiProfilePagerAdapter createChooserMultiProfilePagerAdapterForTwoProfiles(\n            Intent[] initialIntents,\n            List<ResolveInfo> rList,\n            boolean filterLastUsed) {\n        int selectedProfile = findSelectedProfile();\n        ChooserGridAdapter personalAdapter = createChooserGridAdapter(\n                /* context */ this,\n                /* payloadIntents */ mIntents,\n                selectedProfile == PROFILE_PERSONAL ? initialIntents : null,\n                rList,\n                filterLastUsed,\n                /* userHandle */ getPersonalProfileUserHandle());\n        ChooserGridAdapter workAdapter = createChooserGridAdapter(\n                /* context */ this,\n                /* payloadIntents */ mIntents,\n                selectedProfile == PROFILE_WORK ? initialIntents : null,\n                rList,\n                filterLastUsed,\n                /* userHandle */ getWorkProfileUserHandle());\n        return new ChooserMultiProfilePagerAdapter(\n                /* context */ this,\n                personalAdapter,\n                workAdapter,\n                selectedProfile,\n                getPersonalProfileUserHandle(),\n                getWorkProfileUserHandle(),\n                isSendAction(getTargetIntent()), mMaxTargetsPerRow);\n    }\n\n    private int findSelectedProfile() {\n        int selectedProfile = getSelectedProfileExtra();\n        if (selectedProfile == -1) {\n            selectedProfile = getProfileForUser(getUser());\n        }\n        return selectedProfile;\n    }\n\n    @Override\n    protected boolean postRebuildList(boolean rebuildCompleted) {\n        updateStickyContentPreview();\n        if (shouldShowStickyContentPreview()\n                || mChooserMultiProfilePagerAdapter\n                        .getCurrentRootAdapter().getSystemRowCount() != 0) {\n            logActionShareWithPreview();\n        }\n        return postRebuildListInternal(rebuildCompleted);\n    }\n\n    /**\n     * Returns true if app prediction service is defined and the component exists on device.\n     */\n    private boolean isAppPredictionServiceAvailable() {\n        return getPackageManager().getAppPredictionServicePackageName() != null;\n    }\n\n    /**\n     * Check if the profile currently used is a work profile.\n     * @return true if it is work profile, false if it is parent profile (or no work profile is\n     * set up)\n     */\n    protected boolean isWorkProfile() {\n        return getSystemService(UserManager.class)\n                .getUserInfo(UserHandle.myUserId()).isManagedProfile();\n    }\n\n    @Override\n    protected PackageMonitor createPackageMonitor(ResolverListAdapter listAdapter) {\n        return new PackageMonitor() {\n            @Override\n            public void onSomePackagesChanged() {\n                handlePackagesChanged(listAdapter);\n            }\n        };\n    }\n\n    /**\n     * Update UI to reflect changes in data.\n     */\n    public void handlePackagesChanged() {\n        handlePackagesChanged(/* listAdapter */ null);\n    }\n\n    /**\n     * Update UI to reflect changes in data.\n     * <p>If {@code listAdapter} is {@code null}, both profile list adapters are updated if\n     * available.\n     */\n    private void handlePackagesChanged(@Nullable ResolverListAdapter listAdapter) {\n        // Refresh pinned items\n        mPinnedSharedPrefs = getPinnedSharedPrefs(this);\n        if (listAdapter == null) {\n            mChooserMultiProfilePagerAdapter.getActiveListAdapter().handlePackagesChanged();\n            if (mChooserMultiProfilePagerAdapter.getCount() > 1) {\n                mChooserMultiProfilePagerAdapter.getInactiveListAdapter().handlePackagesChanged();\n            }\n        } else {\n            listAdapter.handlePackagesChanged();\n        }\n        updateProfileViewButton();\n    }\n\n    private void onCopyButtonClicked(View v) {\n        Intent targetIntent = getTargetIntent();\n        if (targetIntent == null) {\n            finish();\n        } else {\n            final String action = targetIntent.getAction();\n\n            ClipData clipData = null;\n            if (Intent.ACTION_SEND.equals(action)) {\n                String extraText = targetIntent.getStringExtra(Intent.EXTRA_TEXT);\n                Uri extraStream = targetIntent.getParcelableExtra(Intent.EXTRA_STREAM);\n\n                if (extraText != null) {\n                    clipData = ClipData.newPlainText(null, extraText);\n                } else if (extraStream != null) {\n                    clipData = ClipData.newUri(getContentResolver(), null, extraStream);\n                } else {\n                    Log.w(TAG, \"No data available to copy to clipboard\");\n                    return;\n                }\n            } else if (Intent.ACTION_SEND_MULTIPLE.equals(action)) {\n                final ArrayList<Uri> streams = targetIntent.getParcelableArrayListExtra(\n                        Intent.EXTRA_STREAM);\n                clipData = ClipData.newUri(getContentResolver(), null, streams.get(0));\n                for (int i = 1; i < streams.size(); i++) {\n                    clipData.addItem(getContentResolver(), new ClipData.Item(streams.get(i)));\n                }\n            } else {\n                // expected to only be visible with ACTION_SEND or ACTION_SEND_MULTIPLE\n                // so warn about unexpected action\n                Log.w(TAG, \"Action (\" + action + \") not supported for copying to clipboard\");\n                return;\n            }\n\n            ClipboardManager clipboardManager = (ClipboardManager) getSystemService(\n                    Context.CLIPBOARD_SERVICE);\n            clipboardManager.setPrimaryClipAsPackage(clipData, getReferrerPackageName());\n\n            // Log share completion via copy\n            LogMaker targetLogMaker = new LogMaker(\n                    MetricsEvent.ACTION_ACTIVITY_CHOOSER_PICKED_SYSTEM_TARGET).setSubtype(1);\n            getMetricsLogger().write(targetLogMaker);\n            getChooserActivityLogger().logShareTargetSelected(\n                    SELECTION_TYPE_COPY,\n                    \"\",\n                    -1,\n                    false);\n\n            setResult(RESULT_OK);\n            finish();\n        }\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        Log.d(TAG, \"onResume: \" + getComponentName().flattenToShortString());\n    }\n\n    @Override\n    public void onConfigurationChanged(Configuration newConfig) {\n        super.onConfigurationChanged(newConfig);\n        ViewPager viewPager = findViewById(R.id.profile_pager);\n        if (viewPager.isLayoutRtl()) {\n            mMultiProfilePagerAdapter.setupViewPager(viewPager);\n        }\n\n        mShouldDisplayLandscape = shouldDisplayLandscape(newConfig.orientation);\n        mMaxTargetsPerRow = getResources().getInteger(R.integer.config_chooser_max_targets_per_row);\n        adjustPreviewWidth(newConfig.orientation, null);\n        updateStickyContentPreview();\n        updateTabPadding();\n    }\n\n    private boolean shouldDisplayLandscape(int orientation) {\n        // Sharesheet fixes the # of items per row and therefore can not correctly lay out\n        // when in the restricted size of multi-window mode. In the future, would be nice\n        // to use minimum dp size requirements instead\n        return orientation == Configuration.ORIENTATION_LANDSCAPE && !isInMultiWindowMode();\n    }\n\n    private void adjustPreviewWidth(int orientation, View parent) {\n        int width = -1;\n        if (mShouldDisplayLandscape) {\n            width = getResources().getDimensionPixelSize(R.dimen.chooser_preview_width);\n        }\n\n        parent = parent == null ? getWindow().getDecorView() : parent;\n\n        updateLayoutWidth(R.id.content_preview_text_layout, width, parent);\n        updateLayoutWidth(R.id.content_preview_title_layout, width, parent);\n        updateLayoutWidth(R.id.content_preview_file_layout, width, parent);\n    }\n\n    private void updateTabPadding() {\n        if (shouldShowTabs()) {\n            View tabs = findViewById(R.id.tabs);\n            float iconSize = getResources().getDimension(R.dimen.chooser_icon_size);\n            // The entire width consists of icons or padding. Divide the item padding in half to get\n            // paddingHorizontal.\n            float padding = (tabs.getWidth() - mMaxTargetsPerRow * iconSize)\n                    / mMaxTargetsPerRow / 2;\n            // Subtract the margin the buttons already have.\n            padding -= getResources().getDimension(R.dimen.resolver_profile_tab_margin);\n            tabs.setPadding((int) padding, 0, (int) padding, 0);\n        }\n    }\n\n    private void updateLayoutWidth(int layoutResourceId, int width, View parent) {\n        View view = parent.findViewById(layoutResourceId);\n        if (view != null && view.getLayoutParams() != null) {\n            LayoutParams params = view.getLayoutParams();\n            params.width = width;\n            view.setLayoutParams(params);\n        }\n    }\n\n    private ViewGroup createContentPreviewView(ViewGroup parent) {\n        Intent targetIntent = getTargetIntent();\n        int previewType = findPreferredContentPreview(targetIntent, getContentResolver());\n        return displayContentPreview(previewType, targetIntent, getLayoutInflater(), parent);\n    }\n\n    @VisibleForTesting\n    protected ComponentName getNearbySharingComponent() {\n        String nearbyComponent = Settings.Secure.getString(\n                getContentResolver(),\n                Settings.Secure.NEARBY_SHARING_COMPONENT);\n        if (TextUtils.isEmpty(nearbyComponent)) {\n            nearbyComponent = getString(R.string.config_defaultNearbySharingComponent);\n        }\n        if (TextUtils.isEmpty(nearbyComponent)) {\n            return null;\n        }\n        return ComponentName.unflattenFromString(nearbyComponent);\n    }\n\n    @VisibleForTesting\n    protected @Nullable ComponentName getEditSharingComponent() {\n        String editorPackage = getApplicationContext().getString(R.string.config_systemImageEditor);\n        if (editorPackage == null || TextUtils.isEmpty(editorPackage)) {\n            return null;\n        }\n        return ComponentName.unflattenFromString(editorPackage);\n    }\n\n    @VisibleForTesting\n    protected TargetInfo getEditSharingTarget(Intent originalIntent) {\n        final ComponentName cn = getEditSharingComponent();\n\n        final Intent resolveIntent = new Intent(originalIntent);\n        resolveIntent.setComponent(cn);\n        resolveIntent.setAction(Intent.ACTION_EDIT);\n        final ResolveInfo ri = getPackageManager().resolveActivity(\n                resolveIntent, PackageManager.GET_META_DATA);\n        if (ri == null || ri.activityInfo == null) {\n            Log.e(TAG, \"Device-specified image edit component (\" + cn\n                    + \") not available\");\n            return null;\n        }\n\n        final DisplayResolveInfo dri = new DisplayResolveInfo(\n                originalIntent, ri, getString(R.string.screenshot_edit), \"\", resolveIntent, null);\n        dri.setDisplayIcon(getDrawable(R.drawable.ic_screenshot_edit));\n        return dri;\n    }\n\n\n    @VisibleForTesting\n    protected TargetInfo getNearbySharingTarget(Intent originalIntent) {\n        final ComponentName cn = getNearbySharingComponent();\n        if (cn == null) return null;\n\n        final Intent resolveIntent = new Intent(originalIntent);\n        resolveIntent.setComponent(cn);\n        final ResolveInfo ri = getPackageManager().resolveActivity(\n                resolveIntent, PackageManager.GET_META_DATA);\n        if (ri == null || ri.activityInfo == null) {\n            Log.e(TAG, \"Device-specified nearby sharing component (\" + cn\n                    + \") not available\");\n            return null;\n        }\n\n        // Allow the nearby sharing component to provide a more appropriate icon and label\n        // for the chip.\n        CharSequence name = null;\n        Drawable icon = null;\n        final Bundle metaData = ri.activityInfo.metaData;\n        if (metaData != null) {\n            try {\n                final Resources pkgRes = getPackageManager().getResourcesForActivity(cn);\n                final int nameResId = metaData.getInt(CHIP_LABEL_METADATA_KEY);\n                name = pkgRes.getString(nameResId);\n                final int resId = metaData.getInt(CHIP_ICON_METADATA_KEY);\n                icon = pkgRes.getDrawable(resId);\n            } catch (Resources.NotFoundException ex) {\n            } catch (NameNotFoundException ex) {\n            }\n        }\n        if (TextUtils.isEmpty(name)) {\n            name = ri.loadLabel(getPackageManager());\n        }\n        if (icon == null) {\n            icon = ri.loadIcon(getPackageManager());\n        }\n\n        final DisplayResolveInfo dri = new DisplayResolveInfo(\n                originalIntent, ri, name, \"\", resolveIntent, null);\n        dri.setDisplayIcon(icon);\n        return dri;\n    }\n\n    private Button createActionButton(Drawable icon, CharSequence title, View.OnClickListener r) {\n        Button b = (Button) LayoutInflater.from(this).inflate(R.layout.chooser_action_button, null);\n        if (icon != null) {\n            final int size = getResources()\n                    .getDimensionPixelSize(R.dimen.chooser_action_button_icon_size);\n            icon.setBounds(0, 0, size, size);\n            b.setCompoundDrawablesRelative(icon, null, null, null);\n        }\n        b.setText(title);\n        b.setOnClickListener(r);\n        return b;\n    }\n\n    private Button createCopyButton() {\n        final Button b = createActionButton(\n                getDrawable(R.drawable.ic_menu_copy_material),\n                getString(R.string.copy), this::onCopyButtonClicked);\n        b.setId(R.id.chooser_copy_button);\n        return b;\n    }\n\n    private @Nullable Button createNearbyButton(Intent originalIntent) {\n        final TargetInfo ti = getNearbySharingTarget(originalIntent);\n        if (ti == null) return null;\n\n        final Button b = createActionButton(\n                ti.getDisplayIcon(this),\n                ti.getDisplayLabel(),\n                (View unused) -> {\n                    // Log share completion via nearby\n                    getChooserActivityLogger().logShareTargetSelected(\n                            SELECTION_TYPE_NEARBY,\n                            \"\",\n                            -1,\n                            false);\n                    // Action bar is user-independent, always start as primary\n                    safelyStartActivityAsUser(ti, getPersonalProfileUserHandle());\n                    finish();\n                }\n        );\n        b.setId(R.id.chooser_nearby_button);\n        return b;\n    }\n\n    private @Nullable Button createEditButton(Intent originalIntent) {\n        final TargetInfo ti = getEditSharingTarget(originalIntent);\n        if (ti == null) return null;\n\n        final Button b = createActionButton(\n                ti.getDisplayIcon(this),\n                ti.getDisplayLabel(),\n                (View unused) -> {\n                    // Log share completion via edit\n                    getChooserActivityLogger().logShareTargetSelected(\n                            SELECTION_TYPE_EDIT,\n                            \"\",\n                            -1,\n                            false);\n                    // Action bar is user-independent, always start as primary\n                    safelyStartActivityAsUser(ti, getPersonalProfileUserHandle());\n                    finish();\n                }\n        );\n        b.setId(R.id.chooser_edit_button);\n        return b;\n    }\n\n    private void addActionButton(ViewGroup parent, Button b) {\n        if (b == null) return;\n        final ViewGroup.MarginLayoutParams lp = new ViewGroup.MarginLayoutParams(\n                        LayoutParams.WRAP_CONTENT,\n                        LayoutParams.WRAP_CONTENT\n                );\n        final int gap = getResources().getDimensionPixelSize(R.dimen.resolver_icon_margin) / 2;\n        lp.setMarginsRelative(gap, 0, gap, 0);\n        parent.addView(b, lp);\n    }\n\n    private ViewGroup displayContentPreview(@ContentPreviewType int previewType,\n            Intent targetIntent, LayoutInflater layoutInflater, ViewGroup parent) {\n        ViewGroup layout = null;\n\n        switch (previewType) {\n            case CONTENT_PREVIEW_TEXT:\n                layout = displayTextContentPreview(targetIntent, layoutInflater, parent);\n                break;\n            case CONTENT_PREVIEW_IMAGE:\n                layout = displayImageContentPreview(targetIntent, layoutInflater, parent);\n                break;\n            case CONTENT_PREVIEW_FILE:\n                layout = displayFileContentPreview(targetIntent, layoutInflater, parent);\n                break;\n            default:\n                Log.e(TAG, \"Unexpected content preview type: \" + previewType);\n        }\n\n        if (layout != null) {\n            adjustPreviewWidth(getResources().getConfiguration().orientation, layout);\n        }\n        if (previewType != CONTENT_PREVIEW_IMAGE) {\n            mEnterTransitionAnimationDelegate.markImagePreviewReady();\n        }\n\n        return layout;\n    }\n\n    private ViewGroup displayTextContentPreview(Intent targetIntent, LayoutInflater layoutInflater,\n            ViewGroup parent) {\n        ViewGroup contentPreviewLayout = (ViewGroup) layoutInflater.inflate(\n                R.layout.chooser_grid_preview_text, parent, false);\n\n        final ViewGroup actionRow =\n                (ViewGroup) contentPreviewLayout.findViewById(R.id.chooser_action_row);\n        addActionButton(actionRow, createCopyButton());\n        if (shouldNearbyShareBeIncludedAsActionButton()) {\n            addActionButton(actionRow, createNearbyButton(targetIntent));\n        }\n\n        CharSequence sharingText = targetIntent.getCharSequenceExtra(Intent.EXTRA_TEXT);\n        if (sharingText == null) {\n            contentPreviewLayout.findViewById(R.id.content_preview_text_layout).setVisibility(\n                    View.GONE);\n        } else {\n            TextView textView = contentPreviewLayout.findViewById(R.id.content_preview_text);\n            textView.setText(sharingText);\n        }\n\n        String previewTitle = targetIntent.getStringExtra(Intent.EXTRA_TITLE);\n        if (TextUtils.isEmpty(previewTitle)) {\n            contentPreviewLayout.findViewById(R.id.content_preview_title_layout).setVisibility(\n                    View.GONE);\n        } else {\n            TextView previewTitleView = contentPreviewLayout.findViewById(\n                    R.id.content_preview_title);\n            previewTitleView.setText(previewTitle);\n\n            ClipData previewData = targetIntent.getClipData();\n            Uri previewThumbnail = null;\n            if (previewData != null) {\n                if (previewData.getItemCount() > 0) {\n                    ClipData.Item previewDataItem = previewData.getItemAt(0);\n                    previewThumbnail = previewDataItem.getUri();\n                }\n            }\n\n            ImageView previewThumbnailView = contentPreviewLayout.findViewById(\n                    R.id.content_preview_thumbnail);\n            if (!validForContentPreview(previewThumbnail)) {\n                previewThumbnailView.setVisibility(View.GONE);\n            } else {\n                mPreviewCoord = new ContentPreviewCoordinator(contentPreviewLayout, false);\n                mPreviewCoord.loadUriIntoView(R.id.content_preview_thumbnail, previewThumbnail, 0);\n            }\n        }\n\n        return contentPreviewLayout;\n    }\n\n    private ViewGroup displayImageContentPreview(Intent targetIntent, LayoutInflater layoutInflater,\n            ViewGroup parent) {\n        ViewGroup contentPreviewLayout = (ViewGroup) layoutInflater.inflate(\n                R.layout.chooser_grid_preview_image, parent, false);\n        ViewGroup imagePreview = contentPreviewLayout.findViewById(R.id.content_preview_image_area);\n\n        final ViewGroup actionRow =\n                (ViewGroup) contentPreviewLayout.findViewById(R.id.chooser_action_row);\n        //TODO: addActionButton(actionRow, createCopyButton());\n        if (shouldNearbyShareBeIncludedAsActionButton()) {\n            addActionButton(actionRow, createNearbyButton(targetIntent));\n        }\n        addActionButton(actionRow, createEditButton(targetIntent));\n\n        mPreviewCoord = new ContentPreviewCoordinator(contentPreviewLayout, false);\n\n        String action = targetIntent.getAction();\n        if (Intent.ACTION_SEND.equals(action)) {\n            Uri uri = targetIntent.getParcelableExtra(Intent.EXTRA_STREAM);\n            if (!validForContentPreview(uri)) {\n                contentPreviewLayout.setVisibility(View.GONE);\n                return contentPreviewLayout;\n            }\n            imagePreview.findViewById(R.id.content_preview_image_1_large)\n                    .setTransitionName(ChooserActivity.FIRST_IMAGE_PREVIEW_TRANSITION_NAME);\n            mPreviewCoord.loadUriIntoView(R.id.content_preview_image_1_large, uri, 0);\n        } else {\n            ContentResolver resolver = getContentResolver();\n\n            List<Uri> uris = targetIntent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);\n            List<Uri> imageUris = new ArrayList<>();\n            for (Uri uri : uris) {\n                if (validForContentPreview(uri) && isImageType(resolver.getType(uri))) {\n                    imageUris.add(uri);\n                }\n            }\n\n            if (imageUris.size() == 0) {\n                Log.i(TAG, \"Attempted to display image preview area with zero\"\n                        + \" available images detected in EXTRA_STREAM list\");\n                imagePreview.setVisibility(View.GONE);\n                return contentPreviewLayout;\n            }\n\n            imagePreview.findViewById(R.id.content_preview_image_1_large)\n                    .setTransitionName(ChooserActivity.FIRST_IMAGE_PREVIEW_TRANSITION_NAME);\n            mPreviewCoord.loadUriIntoView(R.id.content_preview_image_1_large, imageUris.get(0), 0);\n\n            if (imageUris.size() == 2) {\n                mPreviewCoord.loadUriIntoView(R.id.content_preview_image_2_large,\n                        imageUris.get(1), 0);\n            } else if (imageUris.size() > 2) {\n                mPreviewCoord.loadUriIntoView(R.id.content_preview_image_2_small,\n                        imageUris.get(1), 0);\n                mPreviewCoord.loadUriIntoView(R.id.content_preview_image_3_small,\n                        imageUris.get(2), imageUris.size() - 3);\n            }\n        }\n\n        return contentPreviewLayout;\n    }\n\n    private static class FileInfo {\n        public final String name;\n        public final boolean hasThumbnail;\n\n        FileInfo(String name, boolean hasThumbnail) {\n            this.name = name;\n            this.hasThumbnail = hasThumbnail;\n        }\n    }\n\n    /**\n     * Wrapping the ContentResolver call to expose for easier mocking,\n     * and to avoid mocking Android core classes.\n     */\n    @VisibleForTesting\n    public Cursor queryResolver(ContentResolver resolver, Uri uri) {\n        return resolver.query(uri, null, null, null, null);\n    }\n\n    private FileInfo extractFileInfo(Uri uri, ContentResolver resolver) {\n        String fileName = null;\n        boolean hasThumbnail = false;\n\n        try (Cursor cursor = queryResolver(resolver, uri)) {\n            if (cursor != null && cursor.getCount() > 0) {\n                int nameIndex = cursor.getColumnIndex(OpenableColumns.DISPLAY_NAME);\n                int titleIndex = cursor.getColumnIndex(Downloads.Impl.COLUMN_TITLE);\n                int flagsIndex = cursor.getColumnIndex(DocumentsContract.Document.COLUMN_FLAGS);\n\n                cursor.moveToFirst();\n                if (nameIndex != -1) {\n                    fileName = cursor.getString(nameIndex);\n                } else if (titleIndex != -1) {\n                    fileName = cursor.getString(titleIndex);\n                }\n\n                if (flagsIndex != -1) {\n                    hasThumbnail = (cursor.getInt(flagsIndex)\n                            & DocumentsContract.Document.FLAG_SUPPORTS_THUMBNAIL) != 0;\n                }\n            }\n        } catch (SecurityException | NullPointerException e) {\n            logContentPreviewWarning(uri);\n        }\n\n        if (TextUtils.isEmpty(fileName)) {\n            fileName = uri.getPath();\n            int index = fileName.lastIndexOf('/');\n            if (index != -1) {\n                fileName = fileName.substring(index + 1);\n            }\n        }\n\n        return new FileInfo(fileName, hasThumbnail);\n    }\n\n    private void logContentPreviewWarning(Uri uri) {\n        // The ContentResolver already logs the exception. Log something more informative.\n        Log.w(TAG, \"Could not load (\" + uri.toString() + \") thumbnail/name for preview. If \"\n                + \"desired, consider using Intent#createChooser to launch the ChooserActivity, \"\n                + \"and set your Intent's clipData and flags in accordance with that method's \"\n                + \"documentation\");\n    }\n\n    private ViewGroup displayFileContentPreview(Intent targetIntent, LayoutInflater layoutInflater,\n            ViewGroup parent) {\n\n        ViewGroup contentPreviewLayout = (ViewGroup) layoutInflater.inflate(\n                R.layout.chooser_grid_preview_file, parent, false);\n\n        final ViewGroup actionRow =\n                (ViewGroup) contentPreviewLayout.findViewById(R.id.chooser_action_row);\n        //TODO(b/120417119): addActionButton(actionRow, createCopyButton());\n        if (shouldNearbyShareBeIncludedAsActionButton()) {\n            addActionButton(actionRow, createNearbyButton(targetIntent));\n        }\n\n        String action = targetIntent.getAction();\n        if (Intent.ACTION_SEND.equals(action)) {\n            Uri uri = targetIntent.getParcelableExtra(Intent.EXTRA_STREAM);\n            if (!validForContentPreview(uri)) {\n                contentPreviewLayout.setVisibility(View.GONE);\n                return contentPreviewLayout;\n            }\n            loadFileUriIntoView(uri, contentPreviewLayout);\n        } else {\n            List<Uri> uris = targetIntent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);\n            uris = uris.stream()\n                    .filter(ChooserActivity::validForContentPreview)\n                    .collect(Collectors.toList());\n            int uriCount = uris.size();\n\n            if (uriCount == 0) {\n                contentPreviewLayout.setVisibility(View.GONE);\n                Log.i(TAG,\n                        \"Appears to be no uris available in EXTRA_STREAM, removing \"\n                                + \"preview area\");\n                return contentPreviewLayout;\n            } else if (uriCount == 1) {\n                loadFileUriIntoView(uris.get(0), contentPreviewLayout);\n            } else {\n                FileInfo fileInfo = extractFileInfo(uris.get(0), getContentResolver());\n                int remUriCount = uriCount - 1;\n                Map<String, Object> arguments = new HashMap<>();\n                arguments.put(PLURALS_COUNT, remUriCount);\n                arguments.put(PLURALS_FILE_NAME, fileInfo.name);\n                String fileName = PluralsMessageFormatter.format(\n                        getResources(),\n                        arguments,\n                        R.string.file_count);\n\n                TextView fileNameView = contentPreviewLayout.findViewById(\n                        R.id.content_preview_filename);\n                fileNameView.setText(fileName);\n\n                View thumbnailView = contentPreviewLayout.findViewById(\n                        R.id.content_preview_file_thumbnail);\n                thumbnailView.setVisibility(View.GONE);\n\n                ImageView fileIconView = contentPreviewLayout.findViewById(\n                        R.id.content_preview_file_icon);\n                fileIconView.setVisibility(View.VISIBLE);\n                fileIconView.setImageResource(R.drawable.ic_file_copy);\n            }\n        }\n\n        return contentPreviewLayout;\n    }\n\n    private void loadFileUriIntoView(final Uri uri, final View parent) {\n        FileInfo fileInfo = extractFileInfo(uri, getContentResolver());\n\n        TextView fileNameView = parent.findViewById(R.id.content_preview_filename);\n        fileNameView.setText(fileInfo.name);\n\n        if (fileInfo.hasThumbnail) {\n            mPreviewCoord = new ContentPreviewCoordinator(parent, false);\n            mPreviewCoord.loadUriIntoView(R.id.content_preview_file_thumbnail, uri, 0);\n        } else {\n            View thumbnailView = parent.findViewById(R.id.content_preview_file_thumbnail);\n            thumbnailView.setVisibility(View.GONE);\n\n            ImageView fileIconView = parent.findViewById(R.id.content_preview_file_icon);\n            fileIconView.setVisibility(View.VISIBLE);\n            fileIconView.setImageResource(R.drawable.chooser_file_generic);\n        }\n    }\n\n    /**\n     * Indicate if the incoming content URI should be allowed.\n     *\n     * @param uri the uri to test\n     * @return true if the URI is allowed for content preview\n     */\n    private static boolean validForContentPreview(Uri uri) throws SecurityException {\n        if (uri == null) {\n            return false;\n        }\n        int userId = getUserIdFromUri(uri, UserHandle.USER_CURRENT);\n        if (userId != UserHandle.USER_CURRENT && userId != UserHandle.myUserId()) {\n            Log.e(TAG, \"dropped invalid content URI belonging to user \" + userId);\n            return false;\n        }\n        return true;\n    }\n\n    @VisibleForTesting\n    protected boolean isImageType(String mimeType) {\n        return mimeType != null && mimeType.startsWith(\"image/\");\n    }\n\n    @ContentPreviewType\n    private int findPreferredContentPreview(Uri uri, ContentResolver resolver) {\n        if (uri == null) {\n            return CONTENT_PREVIEW_TEXT;\n        }\n\n        String mimeType = resolver.getType(uri);\n        return isImageType(mimeType) ? CONTENT_PREVIEW_IMAGE : CONTENT_PREVIEW_FILE;\n    }\n\n    /**\n     * In {@link android.content.Intent#getType}, the app may specify a very general\n     * mime-type that broadly covers all data being shared, such as {@literal *}/*\n     * when sending an image and text. We therefore should inspect each item for the\n     * the preferred type, in order of IMAGE, FILE, TEXT.\n     */\n    @ContentPreviewType\n    private int findPreferredContentPreview(Intent targetIntent, ContentResolver resolver) {\n        String action = targetIntent.getAction();\n        if (Intent.ACTION_SEND.equals(action)) {\n            Uri uri = targetIntent.getParcelableExtra(Intent.EXTRA_STREAM);\n            return findPreferredContentPreview(uri, resolver);\n        } else if (Intent.ACTION_SEND_MULTIPLE.equals(action)) {\n            List<Uri> uris = targetIntent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);\n            if (uris == null || uris.isEmpty()) {\n                return CONTENT_PREVIEW_TEXT;\n            }\n\n            for (Uri uri : uris) {\n                // Defaulting to file preview when there are mixed image/file types is\n                // preferable, as it shows the user the correct number of items being shared\n                if (findPreferredContentPreview(uri, resolver) == CONTENT_PREVIEW_FILE) {\n                    return CONTENT_PREVIEW_FILE;\n                }\n            }\n\n            return CONTENT_PREVIEW_IMAGE;\n        }\n\n        return CONTENT_PREVIEW_TEXT;\n    }\n\n    private int getNumSheetExpansions() {\n        return getPreferences(Context.MODE_PRIVATE).getInt(PREF_NUM_SHEET_EXPANSIONS, 0);\n    }\n\n    private void incrementNumSheetExpansions() {\n        getPreferences(Context.MODE_PRIVATE).edit().putInt(PREF_NUM_SHEET_EXPANSIONS,\n                getNumSheetExpansions() + 1).apply();\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n\n        if (isFinishing()) {\n            mLatencyTracker.onActionCancel(ACTION_LOAD_SHARE_SHEET);\n        }\n\n        if (mRefinementResultReceiver != null) {\n            mRefinementResultReceiver.destroy();\n            mRefinementResultReceiver = null;\n        }\n        mChooserHandler.removeAllMessages();\n\n        if (mPreviewCoord != null) mPreviewCoord.cancelLoads();\n\n        mChooserMultiProfilePagerAdapter.getActiveListAdapter().destroyAppPredictor();\n        if (mChooserMultiProfilePagerAdapter.getInactiveListAdapter() != null) {\n            mChooserMultiProfilePagerAdapter.getInactiveListAdapter().destroyAppPredictor();\n        }\n    }\n\n    @Override // ResolverListCommunicator\n    public Intent getReplacementIntent(ActivityInfo aInfo, Intent defIntent) {\n        Intent result = defIntent;\n        if (mReplacementExtras != null) {\n            final Bundle replExtras = mReplacementExtras.getBundle(aInfo.packageName);\n            if (replExtras != null) {\n                result = new Intent(defIntent);\n                result.putExtras(replExtras);\n            }\n        }\n        if (aInfo.name.equals(IntentForwarderActivity.FORWARD_INTENT_TO_PARENT)\n                || aInfo.name.equals(IntentForwarderActivity.FORWARD_INTENT_TO_MANAGED_PROFILE)) {\n            result = Intent.createChooser(result,\n                    getIntent().getCharSequenceExtra(Intent.EXTRA_TITLE));\n\n            // Don't auto-launch single intents if the intent is being forwarded. This is done\n            // because automatically launching a resolving application as a response to the user\n            // action of switching accounts is pretty unexpected.\n            result.putExtra(Intent.EXTRA_AUTO_LAUNCH_SINGLE_CHOICE, false);\n        }\n        return result;\n    }\n\n    @Override\n    public void onActivityStarted(TargetInfo cti) {\n        if (mChosenComponentSender != null) {\n            final ComponentName target = cti.getResolvedComponentName();\n            if (target != null) {\n                final Intent fillIn = new Intent().putExtra(Intent.EXTRA_CHOSEN_COMPONENT, target);\n                try {\n                    mChosenComponentSender.sendIntent(this, Activity.RESULT_OK, fillIn, null, null);\n                } catch (IntentSender.SendIntentException e) {\n                    Slog.e(TAG, \"Unable to launch supplied IntentSender to report \"\n                            + \"the chosen component: \" + e);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void addUseDifferentAppLabelIfNecessary(ResolverListAdapter adapter) {\n        if (mCallerChooserTargets != null && mCallerChooserTargets.length > 0) {\n            mChooserMultiProfilePagerAdapter.getActiveListAdapter().addServiceResults(\n                    /* origTarget */ null,\n                    Lists.newArrayList(mCallerChooserTargets),\n                    TARGET_TYPE_DEFAULT,\n                    /* directShareShortcutInfoCache */ null);\n        }\n    }\n\n    @Override\n    public int getLayoutResource() {\n        return R.layout.chooser_grid;\n    }\n\n    @Override // ResolverListCommunicator\n    public boolean shouldGetActivityMetadata() {\n        return true;\n    }\n\n    @Override\n    public boolean shouldAutoLaunchSingleChoice(TargetInfo target) {\n        // Note that this is only safe because the Intent handled by the ChooserActivity is\n        // guaranteed to contain no extras unknown to the local ClassLoader. That is why this\n        // method can not be replaced in the ResolverActivity whole hog.\n        if (!super.shouldAutoLaunchSingleChoice(target)) {\n            return false;\n        }\n\n        return getIntent().getBooleanExtra(Intent.EXTRA_AUTO_LAUNCH_SINGLE_CHOICE, true);\n    }\n\n    private void showTargetDetails(TargetInfo targetInfo) {\n        if (targetInfo == null) return;\n\n        ArrayList<DisplayResolveInfo> targetList;\n        ChooserTargetActionsDialogFragment fragment = new ChooserTargetActionsDialogFragment();\n        Bundle bundle = new Bundle();\n\n        if (targetInfo instanceof SelectableTargetInfo) {\n            SelectableTargetInfo selectableTargetInfo = (SelectableTargetInfo) targetInfo;\n            if (selectableTargetInfo.getDisplayResolveInfo() == null\n                    || selectableTargetInfo.getChooserTarget() == null) {\n                Log.e(TAG, \"displayResolveInfo or chooserTarget in selectableTargetInfo are null\");\n                return;\n            }\n            targetList = new ArrayList<>();\n            targetList.add(selectableTargetInfo.getDisplayResolveInfo());\n            bundle.putString(ChooserTargetActionsDialogFragment.SHORTCUT_ID_KEY,\n                    selectableTargetInfo.getChooserTarget().getIntentExtras().getString(\n                            Intent.EXTRA_SHORTCUT_ID));\n            bundle.putBoolean(ChooserTargetActionsDialogFragment.IS_SHORTCUT_PINNED_KEY,\n                    selectableTargetInfo.isPinned());\n            bundle.putParcelable(ChooserTargetActionsDialogFragment.INTENT_FILTER_KEY,\n                    getTargetIntentFilter());\n            if (selectableTargetInfo.getDisplayLabel() != null) {\n                bundle.putString(ChooserTargetActionsDialogFragment.SHORTCUT_TITLE_KEY,\n                        selectableTargetInfo.getDisplayLabel().toString());\n            }\n        } else if (targetInfo instanceof MultiDisplayResolveInfo) {\n            // For multiple targets, include info on all targets\n            MultiDisplayResolveInfo mti = (MultiDisplayResolveInfo) targetInfo;\n            targetList = mti.getTargets();\n        } else {\n            targetList = new ArrayList<DisplayResolveInfo>();\n            targetList.add((DisplayResolveInfo) targetInfo);\n        }\n        bundle.putParcelable(ChooserTargetActionsDialogFragment.USER_HANDLE_KEY,\n                mChooserMultiProfilePagerAdapter.getCurrentUserHandle());\n        bundle.putParcelableArrayList(ChooserTargetActionsDialogFragment.TARGET_INFOS_KEY,\n                targetList);\n        fragment.setArguments(bundle);\n\n        fragment.show(getFragmentManager(), TARGET_DETAILS_FRAGMENT_TAG);\n    }\n\n    private void modifyTargetIntent(Intent in) {\n        if (isSendAction(in)) {\n            in.addFlags(Intent.FLAG_ACTIVITY_NEW_DOCUMENT |\n                    Intent.FLAG_ACTIVITY_MULTIPLE_TASK);\n        }\n    }\n\n    @Override\n    protected boolean onTargetSelected(TargetInfo target, boolean alwaysCheck) {\n        if (mRefinementIntentSender != null) {\n            final Intent fillIn = new Intent();\n            final List<Intent> sourceIntents = target.getAllSourceIntents();\n            if (!sourceIntents.isEmpty()) {\n                fillIn.putExtra(Intent.EXTRA_INTENT, sourceIntents.get(0));\n                if (sourceIntents.size() > 1) {\n                    final Intent[] alts = new Intent[sourceIntents.size() - 1];\n                    for (int i = 1, N = sourceIntents.size(); i < N; i++) {\n                        alts[i - 1] = sourceIntents.get(i);\n                    }\n                    fillIn.putExtra(Intent.EXTRA_ALTERNATE_INTENTS, alts);\n                }\n                if (mRefinementResultReceiver != null) {\n                    mRefinementResultReceiver.destroy();\n                }\n                mRefinementResultReceiver = new RefinementResultReceiver(this, target, null);\n                fillIn.putExtra(Intent.EXTRA_RESULT_RECEIVER,\n                        mRefinementResultReceiver);\n                try {\n                    mRefinementIntentSender.sendIntent(this, 0, fillIn, null, null);\n                    return false;\n                } catch (SendIntentException e) {\n                    Log.e(TAG, \"Refinement IntentSender failed to send\", e);\n                }\n            }\n        }\n        updateModelAndChooserCounts(target);\n        return super.onTargetSelected(target, alwaysCheck);\n    }\n\n    @Override\n    public void startSelected(int which, boolean always, boolean filtered) {\n        ChooserListAdapter currentListAdapter =\n                mChooserMultiProfilePagerAdapter.getActiveListAdapter();\n        TargetInfo targetInfo = currentListAdapter\n                .targetInfoForPosition(which, filtered);\n        if (targetInfo != null && targetInfo instanceof NotSelectableTargetInfo) {\n            return;\n        }\n\n        final long selectionCost = System.currentTimeMillis() - mChooserShownTime;\n\n        if (targetInfo instanceof MultiDisplayResolveInfo) {\n            MultiDisplayResolveInfo mti = (MultiDisplayResolveInfo) targetInfo;\n            if (!mti.hasSelected()) {\n                ChooserStackedAppDialogFragment f = new ChooserStackedAppDialogFragment();\n                Bundle b = new Bundle();\n                b.putParcelable(ChooserTargetActionsDialogFragment.USER_HANDLE_KEY,\n                        mChooserMultiProfilePagerAdapter.getCurrentUserHandle());\n                b.putObject(ChooserStackedAppDialogFragment.MULTI_DRI_KEY,\n                        mti);\n                b.putInt(ChooserStackedAppDialogFragment.WHICH_KEY, which);\n                f.setArguments(b);\n\n                f.show(getFragmentManager(), TARGET_DETAILS_FRAGMENT_TAG);\n                return;\n            }\n        }\n\n        super.startSelected(which, always, filtered);\n\n        if (currentListAdapter.getCount() > 0) {\n            // Log the index of which type of target the user picked.\n            // Lower values mean the ranking was better.\n            int cat = 0;\n            int value = which;\n            int directTargetAlsoRanked = -1;\n            int numCallerProvided = 0;\n            HashedStringCache.HashResult directTargetHashed = null;\n            switch (currentListAdapter.getPositionTargetType(which)) {\n                case ChooserListAdapter.TARGET_SERVICE:\n                    cat = MetricsEvent.ACTION_ACTIVITY_CHOOSER_PICKED_SERVICE_TARGET;\n                    // Log the package name + target name to answer the question if most users\n                    // share to mostly the same person or to a bunch of different people.\n                    ChooserTarget target = currentListAdapter.getChooserTargetForValue(value);\n                    directTargetHashed = HashedStringCache.getInstance().hashString(\n                            this,\n                            TAG,\n                            target.getComponentName().getPackageName()\n                                    + target.getTitle().toString(),\n                            mMaxHashSaltDays);\n                    SelectableTargetInfo selectableTargetInfo = (SelectableTargetInfo) targetInfo;\n                    directTargetAlsoRanked = getRankedPosition(selectableTargetInfo);\n\n                    if (mCallerChooserTargets != null) {\n                        numCallerProvided = mCallerChooserTargets.length;\n                    }\n                    getChooserActivityLogger().logShareTargetSelected(\n                            SELECTION_TYPE_SERVICE,\n                            targetInfo.getResolveInfo().activityInfo.processName,\n                            value,\n                            selectableTargetInfo.isPinned()\n                    );\n                    break;\n                case ChooserListAdapter.TARGET_CALLER:\n                case ChooserListAdapter.TARGET_STANDARD:\n                    cat = MetricsEvent.ACTION_ACTIVITY_CHOOSER_PICKED_APP_TARGET;\n                    value -= currentListAdapter.getSurfacedTargetInfo().size();\n                    numCallerProvided = currentListAdapter.getCallerTargetCount();\n                    getChooserActivityLogger().logShareTargetSelected(\n                            SELECTION_TYPE_APP,\n                            targetInfo.getResolveInfo().activityInfo.processName,\n                            value,\n                            targetInfo.isPinned()\n                    );\n                    break;\n                case ChooserListAdapter.TARGET_STANDARD_AZ:\n                    // A-Z targets are unranked standard targets; we use -1 to mark that they\n                    // are from the alphabetical pool.\n                    value = -1;\n                    cat = MetricsEvent.ACTION_ACTIVITY_CHOOSER_PICKED_STANDARD_TARGET;\n                    getChooserActivityLogger().logShareTargetSelected(\n                            SELECTION_TYPE_STANDARD,\n                            targetInfo.getResolveInfo().activityInfo.processName,\n                            value,\n                            false\n                    );\n                    break;\n            }\n\n            if (cat != 0) {\n                LogMaker targetLogMaker = new LogMaker(cat).setSubtype(value);\n                if (directTargetHashed != null) {\n                    targetLogMaker.addTaggedData(\n                            MetricsEvent.FIELD_HASHED_TARGET_NAME, directTargetHashed.hashedString);\n                    targetLogMaker.addTaggedData(\n                                    MetricsEvent.FIELD_HASHED_TARGET_SALT_GEN,\n                                    directTargetHashed.saltGeneration);\n                    targetLogMaker.addTaggedData(MetricsEvent.FIELD_RANKED_POSITION,\n                                    directTargetAlsoRanked);\n                }\n                targetLogMaker.addTaggedData(MetricsEvent.FIELD_IS_CATEGORY_USED,\n                        numCallerProvided);\n                getMetricsLogger().write(targetLogMaker);\n            }\n\n            if (mIsSuccessfullySelected) {\n                if (DEBUG) {\n                    Log.d(TAG, \"User Selection Time Cost is \" + selectionCost);\n                    Log.d(TAG, \"position of selected app/service/caller is \" +\n                            Integer.toString(value));\n                }\n                MetricsLogger.histogram(null, \"user_selection_cost_for_smart_sharing\",\n                        (int) selectionCost);\n                MetricsLogger.histogram(null, \"app_position_for_smart_sharing\", value);\n            }\n        }\n    }\n\n    private int getRankedPosition(SelectableTargetInfo targetInfo) {\n        String targetPackageName =\n                targetInfo.getChooserTarget().getComponentName().getPackageName();\n        ChooserListAdapter currentListAdapter =\n                mChooserMultiProfilePagerAdapter.getActiveListAdapter();\n        int maxRankedResults = Math.min(currentListAdapter.mDisplayList.size(),\n                MAX_LOG_RANK_POSITION);\n\n        for (int i = 0; i < maxRankedResults; i++) {\n            if (currentListAdapter.mDisplayList.get(i)\n                    .getResolveInfo().activityInfo.packageName.equals(targetPackageName)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    @Override\n    protected boolean shouldAddFooterView() {\n        // To accommodate for window insets\n        return true;\n    }\n\n    @Override\n    protected void applyFooterView(int height) {\n        int count = mChooserMultiProfilePagerAdapter.getItemCount();\n\n        for (int i = 0; i < count; i++) {\n            mChooserMultiProfilePagerAdapter.getAdapterForIndex(i).setFooterHeight(height);\n        }\n    }\n\n    private IntentFilter getTargetIntentFilter() {\n        try {\n            final Intent intent = getTargetIntent();\n            String dataString = intent.getDataString();\n            if (intent.getType() == null) {\n                if (!TextUtils.isEmpty(dataString)) {\n                    return new IntentFilter(intent.getAction(), dataString);\n                }\n                Log.e(TAG, \"Failed to get target intent filter: intent data and type are null\");\n                return null;\n            }\n            IntentFilter intentFilter = new IntentFilter(intent.getAction(), intent.getType());\n            List<Uri> contentUris = new ArrayList<>();\n            if (Intent.ACTION_SEND.equals(intent.getAction())) {\n                Uri uri = (Uri) intent.getParcelableExtra(Intent.EXTRA_STREAM);\n                if (uri != null) {\n                    contentUris.add(uri);\n                }\n            } else {\n                List<Uri> uris = intent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);\n                if (uris != null) {\n                    contentUris.addAll(uris);\n                }\n            }\n            for (Uri uri : contentUris) {\n                intentFilter.addDataScheme(uri.getScheme());\n                intentFilter.addDataAuthority(uri.getAuthority(), null);\n                intentFilter.addDataPath(uri.getPath(), PatternMatcher.PATTERN_LITERAL);\n            }\n            return intentFilter;\n        } catch (Exception e) {\n            Log.e(TAG, \"Failed to get target intent filter\", e);\n            return null;\n        }\n    }\n\n    @VisibleForTesting\n    protected void queryDirectShareTargets(\n                ChooserListAdapter adapter, boolean skipAppPredictionService) {\n        mQueriedSharingShortcutsTimeMs = System.currentTimeMillis();\n        UserHandle userHandle = adapter.getUserHandle();\n        if (!skipAppPredictionService) {\n            AppPredictor appPredictor = getAppPredictorForDirectShareIfEnabled(userHandle);\n            if (appPredictor != null) {\n                appPredictor.requestPredictionUpdate();\n                return;\n            }\n        }\n        // Default to just querying ShortcutManager if AppPredictor not present.\n        final IntentFilter filter = getTargetIntentFilter();\n        if (filter == null) {\n            return;\n        }\n\n        AsyncTask.execute(() -> {\n            Context selectedProfileContext = createContextAsUser(userHandle, 0 /* flags */);\n            ShortcutManager sm = (ShortcutManager) selectedProfileContext\n                    .getSystemService(Context.SHORTCUT_SERVICE);\n            List<ShortcutManager.ShareShortcutInfo> resultList = sm.getShareTargets(filter);\n            sendShareShortcutInfoList(resultList, adapter, null, userHandle);\n        });\n    }\n\n    /**\n     * Returns {@code false} if {@code userHandle} is the work profile and it's either\n     * in quiet mode or not running.\n     */\n    private boolean shouldQueryShortcutManager(UserHandle userHandle) {\n        if (!shouldShowTabs()) {\n            return true;\n        }\n        if (!getWorkProfileUserHandle().equals(userHandle)) {\n            return true;\n        }\n        if (!isUserRunning(userHandle)) {\n            return false;\n        }\n        if (!isUserUnlocked(userHandle)) {\n            return false;\n        }\n        if (isQuietModeEnabled(userHandle)) {\n            return false;\n        }\n        return true;\n    }\n\n    private void sendShareShortcutInfoList(\n                List<ShortcutManager.ShareShortcutInfo> resultList,\n                ChooserListAdapter chooserListAdapter,\n                @Nullable List<AppTarget> appTargets, UserHandle userHandle) {\n        if (appTargets != null && appTargets.size() != resultList.size()) {\n            throw new RuntimeException(\"resultList and appTargets must have the same size.\"\n                    + \" resultList.size()=\" + resultList.size()\n                    + \" appTargets.size()=\" + appTargets.size());\n        }\n        Context selectedProfileContext = createContextAsUser(userHandle, 0 /* flags */);\n        for (int i = resultList.size() - 1; i >= 0; i--) {\n            final String packageName = resultList.get(i).getTargetComponent().getPackageName();\n            if (!isPackageEnabled(selectedProfileContext, packageName)) {\n                resultList.remove(i);\n                if (appTargets != null) {\n                    appTargets.remove(i);\n                }\n            }\n        }\n\n        // If |appTargets| is not null, results are from AppPredictionService and already sorted.\n        final int shortcutType = (appTargets == null ? TARGET_TYPE_SHORTCUTS_FROM_SHORTCUT_MANAGER :\n                TARGET_TYPE_SHORTCUTS_FROM_PREDICTION_SERVICE);\n\n        // Match ShareShortcutInfos with DisplayResolveInfos to be able to use the old code path\n        // for direct share targets. After ShareSheet is refactored we should use the\n        // ShareShortcutInfos directly.\n        List<ServiceResultInfo> resultRecords = new ArrayList<>();\n        for (int i = 0; i < chooserListAdapter.getDisplayResolveInfoCount(); i++) {\n            DisplayResolveInfo displayResolveInfo = chooserListAdapter.getDisplayResolveInfo(i);\n            List<ShortcutManager.ShareShortcutInfo> matchingShortcuts =\n                    filterShortcutsByTargetComponentName(\n                            resultList, displayResolveInfo.getResolvedComponentName());\n            if (matchingShortcuts.isEmpty()) {\n                continue;\n            }\n            List<ChooserTarget> chooserTargets = convertToChooserTarget(\n                    matchingShortcuts, resultList, appTargets, shortcutType);\n\n            ServiceResultInfo resultRecord = new ServiceResultInfo(\n                    displayResolveInfo, chooserTargets, userHandle);\n            resultRecords.add(resultRecord);\n        }\n\n        sendShortcutManagerShareTargetResults(\n                shortcutType, resultRecords.toArray(new ServiceResultInfo[0]));\n    }\n\n    private List<ShortcutManager.ShareShortcutInfo> filterShortcutsByTargetComponentName(\n            List<ShortcutManager.ShareShortcutInfo> allShortcuts, ComponentName requiredTarget) {\n        List<ShortcutManager.ShareShortcutInfo> matchingShortcuts = new ArrayList<>();\n        for (ShortcutManager.ShareShortcutInfo shortcut : allShortcuts) {\n            if (requiredTarget.equals(shortcut.getTargetComponent())) {\n                matchingShortcuts.add(shortcut);\n            }\n        }\n        return matchingShortcuts;\n    }\n\n    private void sendShortcutManagerShareTargetResults(\n            int shortcutType, ServiceResultInfo[] results) {\n        final Message msg = Message.obtain();\n        msg.what = ChooserHandler.SHORTCUT_MANAGER_ALL_SHARE_TARGET_RESULTS;\n        msg.obj = results;\n        msg.arg1 = shortcutType;\n        mChooserHandler.sendMessage(msg);\n    }\n\n    private boolean isPackageEnabled(Context context, String packageName) {\n        if (TextUtils.isEmpty(packageName)) {\n            return false;\n        }\n        ApplicationInfo appInfo;\n        try {\n            appInfo = context.getPackageManager().getApplicationInfo(packageName, 0);\n        } catch (NameNotFoundException e) {\n            return false;\n        }\n\n        if (appInfo != null && appInfo.enabled\n                && (appInfo.flags & ApplicationInfo.FLAG_SUSPENDED) == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Converts a list of ShareShortcutInfos to ChooserTargets.\n     * @param matchingShortcuts List of shortcuts, all from the same package, that match the current\n     *                         share intent filter.\n     * @param allShortcuts List of all the shortcuts from all the packages on the device that are\n     *                    returned for the current sharing action.\n     * @param allAppTargets List of AppTargets. Null if the results are not from prediction service.\n     * @param shortcutType One of the values TARGET_TYPE_SHORTCUTS_FROM_SHORTCUT_MANAGER or\n     *                    TARGET_TYPE_SHORTCUTS_FROM_PREDICTION_SERVICE\n     * @return A list of ChooserTargets sorted by score in descending order.\n     */\n    @VisibleForTesting\n    @NonNull\n    public List<ChooserTarget> convertToChooserTarget(\n            @NonNull List<ShortcutManager.ShareShortcutInfo> matchingShortcuts,\n            @NonNull List<ShortcutManager.ShareShortcutInfo> allShortcuts,\n            @Nullable List<AppTarget> allAppTargets, @ShareTargetType int shortcutType) {\n        // A set of distinct scores for the matched shortcuts. We use index of a rank in the sorted\n        // list instead of the actual rank value when converting a rank to a score.\n        List<Integer> scoreList = new ArrayList<>();\n        if (shortcutType == TARGET_TYPE_SHORTCUTS_FROM_SHORTCUT_MANAGER) {\n            for (int i = 0; i < matchingShortcuts.size(); i++) {\n                int shortcutRank = matchingShortcuts.get(i).getShortcutInfo().getRank();\n                if (!scoreList.contains(shortcutRank)) {\n                    scoreList.add(shortcutRank);\n                }\n            }\n            Collections.sort(scoreList);\n        }\n\n        List<ChooserTarget> chooserTargetList = new ArrayList<>(matchingShortcuts.size());\n        for (int i = 0; i < matchingShortcuts.size(); i++) {\n            ShortcutInfo shortcutInfo = matchingShortcuts.get(i).getShortcutInfo();\n            int indexInAllShortcuts = allShortcuts.indexOf(matchingShortcuts.get(i));\n\n            float score;\n            if (shortcutType == TARGET_TYPE_SHORTCUTS_FROM_PREDICTION_SERVICE) {\n                // Incoming results are ordered. Create a score based on index in the original list.\n                score = Math.max(1.0f - (0.01f * indexInAllShortcuts), 0.0f);\n            } else {\n                // Create a score based on the rank of the shortcut.\n                int rankIndex = scoreList.indexOf(shortcutInfo.getRank());\n                score = Math.max(1.0f - (0.01f * rankIndex), 0.0f);\n            }\n\n            Bundle extras = new Bundle();\n            extras.putString(Intent.EXTRA_SHORTCUT_ID, shortcutInfo.getId());\n\n            ChooserTarget chooserTarget = new ChooserTarget(\n                    shortcutInfo.getLabel(),\n                    null, // Icon will be loaded later if this target is selected to be shown.\n                    score, matchingShortcuts.get(i).getTargetComponent().clone(), extras);\n\n            chooserTargetList.add(chooserTarget);\n            if (mDirectShareAppTargetCache != null && allAppTargets != null) {\n                mDirectShareAppTargetCache.put(chooserTarget,\n                        allAppTargets.get(indexInAllShortcuts));\n            }\n            if (mDirectShareShortcutInfoCache != null) {\n                mDirectShareShortcutInfoCache.put(chooserTarget, shortcutInfo);\n            }\n        }\n        // Sort ChooserTargets by score in descending order\n        Comparator<ChooserTarget> byScore =\n                (ChooserTarget a, ChooserTarget b) -> -Float.compare(a.getScore(), b.getScore());\n        Collections.sort(chooserTargetList, byScore);\n        return chooserTargetList;\n    }\n\n    private void logDirectShareTargetReceived(int logCategory) {\n        final int apiLatency = (int) (System.currentTimeMillis() - mQueriedSharingShortcutsTimeMs);\n        getMetricsLogger().write(new LogMaker(logCategory).setSubtype(apiLatency));\n    }\n\n    void updateModelAndChooserCounts(TargetInfo info) {\n        if (info != null && info instanceof MultiDisplayResolveInfo) {\n            info = ((MultiDisplayResolveInfo) info).getSelectedTarget();\n        }\n        if (info != null) {\n            sendClickToAppPredictor(info);\n            final ResolveInfo ri = info.getResolveInfo();\n            Intent targetIntent = getTargetIntent();\n            if (ri != null && ri.activityInfo != null && targetIntent != null) {\n                ChooserListAdapter currentListAdapter =\n                        mChooserMultiProfilePagerAdapter.getActiveListAdapter();\n                if (currentListAdapter != null) {\n                    sendImpressionToAppPredictor(info, currentListAdapter);\n                    currentListAdapter.updateModel(info.getResolvedComponentName());\n                    currentListAdapter.updateChooserCounts(ri.activityInfo.packageName,\n                            targetIntent.getAction());\n                }\n                if (DEBUG) {\n                    Log.d(TAG, \"ResolveInfo Package is \" + ri.activityInfo.packageName);\n                    Log.d(TAG, \"Action to be updated is \" + targetIntent.getAction());\n                }\n            } else if (DEBUG) {\n                Log.d(TAG, \"Can not log Chooser Counts of null ResovleInfo\");\n            }\n        }\n        mIsSuccessfullySelected = true;\n    }\n\n    private void sendImpressionToAppPredictor(TargetInfo targetInfo, ChooserListAdapter adapter) {\n        AppPredictor directShareAppPredictor = getAppPredictorForDirectShareIfEnabled(\n                mChooserMultiProfilePagerAdapter.getCurrentUserHandle());\n        if (directShareAppPredictor == null) {\n            return;\n        }\n        // Send DS target impression info to AppPredictor, only when user chooses app share.\n        if (targetInfo instanceof ChooserTargetInfo) {\n            return;\n        }\n        List<ChooserTargetInfo> surfacedTargetInfo = adapter.getSurfacedTargetInfo();\n        List<AppTargetId> targetIds = new ArrayList<>();\n        for (ChooserTargetInfo chooserTargetInfo : surfacedTargetInfo) {\n            ChooserTarget chooserTarget = chooserTargetInfo.getChooserTarget();\n            ComponentName componentName = chooserTarget.getComponentName();\n            if (mDirectShareShortcutInfoCache.containsKey(chooserTarget)) {\n                String shortcutId = mDirectShareShortcutInfoCache.get(chooserTarget).getId();\n                targetIds.add(new AppTargetId(\n                        String.format(\"%s/%s/%s\", shortcutId, componentName.flattenToString(),\n                                SHORTCUT_TARGET)));\n            }\n        }\n        directShareAppPredictor.notifyLaunchLocationShown(LAUNCH_LOCATION_DIRECT_SHARE, targetIds);\n    }\n\n    private void sendClickToAppPredictor(TargetInfo targetInfo) {\n        AppPredictor directShareAppPredictor = getAppPredictorForDirectShareIfEnabled(\n                mChooserMultiProfilePagerAdapter.getCurrentUserHandle());\n        if (directShareAppPredictor == null) {\n            return;\n        }\n        if (!(targetInfo instanceof ChooserTargetInfo)) {\n            return;\n        }\n        ChooserTarget chooserTarget = ((ChooserTargetInfo) targetInfo).getChooserTarget();\n        AppTarget appTarget = null;\n        if (mDirectShareAppTargetCache != null) {\n            appTarget = mDirectShareAppTargetCache.get(chooserTarget);\n        }\n        // This is a direct share click that was provided by the APS\n        if (appTarget != null) {\n            directShareAppPredictor.notifyAppTargetEvent(\n                    new AppTargetEvent.Builder(appTarget, AppTargetEvent.ACTION_LAUNCH)\n                        .setLaunchLocation(LAUNCH_LOCATION_DIRECT_SHARE)\n                        .build());\n        }\n    }\n\n    @Nullable\n    private AppPredictor createAppPredictor(UserHandle userHandle) {\n        if (!mIsAppPredictorComponentAvailable) {\n            return null;\n        }\n\n        if (getPersonalProfileUserHandle().equals(userHandle)) {\n            if (mPersonalAppPredictor != null) {\n                return mPersonalAppPredictor;\n            }\n        } else {\n            if (mWorkAppPredictor != null) {\n                return mWorkAppPredictor;\n            }\n        }\n\n        // TODO(b/148230574): Currently AppPredictor fetches only the same-profile app targets.\n        // Make AppPredictor work cross-profile.\n        Context contextAsUser = createContextAsUser(userHandle, 0 /* flags */);\n        final IntentFilter filter = getTargetIntentFilter();\n        Bundle extras = new Bundle();\n        extras.putParcelable(APP_PREDICTION_INTENT_FILTER_KEY, filter);\n        populateTextContent(extras);\n        AppPredictionContext appPredictionContext = new AppPredictionContext.Builder(contextAsUser)\n            .setUiSurface(APP_PREDICTION_SHARE_UI_SURFACE)\n            .setPredictedTargetCount(APP_PREDICTION_SHARE_TARGET_QUERY_PACKAGE_LIMIT)\n            .setExtras(extras)\n            .build();\n        AppPredictionManager appPredictionManager =\n                contextAsUser\n                        .getSystemService(AppPredictionManager.class);\n        AppPredictor appPredictionSession = appPredictionManager.createAppPredictionSession(\n                appPredictionContext);\n        if (getPersonalProfileUserHandle().equals(userHandle)) {\n            mPersonalAppPredictor = appPredictionSession;\n        } else {\n            mWorkAppPredictor = appPredictionSession;\n        }\n        return appPredictionSession;\n    }\n\n    private void populateTextContent(Bundle extras) {\n        final Intent intent = getTargetIntent();\n        String sharedText = intent.getStringExtra(Intent.EXTRA_TEXT);\n        extras.putString(SHARED_TEXT_KEY, sharedText);\n    }\n\n    /**\n     * This will return an app predictor if it is enabled for direct share sorting\n     * and if one exists. Otherwise, it returns null.\n     * @param userHandle\n     */\n    @Nullable\n    private AppPredictor getAppPredictorForDirectShareIfEnabled(UserHandle userHandle) {\n        return ChooserFlags.USE_PREDICTION_MANAGER_FOR_DIRECT_TARGETS\n                && !ActivityManager.isLowRamDeviceStatic() ? createAppPredictor(userHandle) : null;\n    }\n\n    /**\n     * This will return an app predictor if it is enabled for share activity sorting\n     * and if one exists. Otherwise, it returns null.\n     */\n    @Nullable\n    private AppPredictor getAppPredictorForShareActivitiesIfEnabled(UserHandle userHandle) {\n        return USE_PREDICTION_MANAGER_FOR_SHARE_ACTIVITIES ? createAppPredictor(userHandle) : null;\n    }\n\n    void onRefinementResult(TargetInfo selectedTarget, Intent matchingIntent) {\n        if (mRefinementResultReceiver != null) {\n            mRefinementResultReceiver.destroy();\n            mRefinementResultReceiver = null;\n        }\n        if (selectedTarget == null) {\n            Log.e(TAG, \"Refinement result intent did not match any known targets; canceling\");\n        } else if (!checkTargetSourceIntent(selectedTarget, matchingIntent)) {\n            Log.e(TAG, \"onRefinementResult: Selected target \" + selectedTarget\n                    + \" cannot match refined source intent \" + matchingIntent);\n        } else {\n            TargetInfo clonedTarget = selectedTarget.cloneFilledIn(matchingIntent, 0);\n            if (super.onTargetSelected(clonedTarget, false)) {\n                updateModelAndChooserCounts(clonedTarget);\n                finish();\n                return;\n            }\n        }\n        onRefinementCanceled();\n    }\n\n    void onRefinementCanceled() {\n        if (mRefinementResultReceiver != null) {\n            mRefinementResultReceiver.destroy();\n            mRefinementResultReceiver = null;\n        }\n        finish();\n    }\n\n    boolean checkTargetSourceIntent(TargetInfo target, Intent matchingIntent) {\n        final List<Intent> targetIntents = target.getAllSourceIntents();\n        for (int i = 0, N = targetIntents.size(); i < N; i++) {\n            final Intent targetIntent = targetIntents.get(i);\n            if (targetIntent.filterEquals(matchingIntent)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Sort intents alphabetically based on display label.\n     */\n    static class AzInfoComparator implements Comparator<DisplayResolveInfo> {\n        Collator mCollator;\n        AzInfoComparator(Context context) {\n            mCollator = Collator.getInstance(context.getResources().getConfiguration().locale);\n        }\n\n        @Override\n        public int compare(\n                DisplayResolveInfo lhsp, DisplayResolveInfo rhsp) {\n            return mCollator.compare(lhsp.getDisplayLabel(), rhsp.getDisplayLabel());\n        }\n    }\n\n    protected MetricsLogger getMetricsLogger() {\n        if (mMetricsLogger == null) {\n            mMetricsLogger = new MetricsLogger();\n        }\n        return mMetricsLogger;\n    }\n\n    protected ChooserActivityLogger getChooserActivityLogger() {\n        if (mChooserActivityLogger == null) {\n            mChooserActivityLogger = new ChooserActivityLoggerImpl();\n        }\n        return mChooserActivityLogger;\n    }\n\n    public class ChooserListController extends ResolverListController {\n        public ChooserListController(Context context,\n                PackageManager pm,\n                Intent targetIntent,\n                String referrerPackageName,\n                int launchedFromUid,\n                UserHandle userId,\n                AbstractResolverComparator resolverComparator) {\n            super(context, pm, targetIntent, referrerPackageName, launchedFromUid, userId,\n                    resolverComparator);\n        }\n\n        @Override\n        boolean isComponentFiltered(ComponentName name) {\n            if (mFilteredComponentNames == null) {\n                return false;\n            }\n            for (ComponentName filteredComponentName : mFilteredComponentNames) {\n                if (name.equals(filteredComponentName)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public boolean isComponentPinned(ComponentName name) {\n            return mPinnedSharedPrefs.getBoolean(name.flattenToString(), false);\n        }\n\n        @Override\n        public boolean isFixedAtTop(ComponentName name) {\n            return name != null && name.equals(getNearbySharingComponent())\n                    && shouldNearbyShareBeFirstInRankedRow();\n        }\n    }\n\n    @VisibleForTesting\n    public ChooserGridAdapter createChooserGridAdapter(Context context,\n            List<Intent> payloadIntents, Intent[] initialIntents, List<ResolveInfo> rList,\n            boolean filterLastUsed, UserHandle userHandle) {\n        ChooserListAdapter chooserListAdapter = createChooserListAdapter(context, payloadIntents,\n                initialIntents, rList, filterLastUsed,\n                createListController(userHandle));\n        AppPredictor.Callback appPredictorCallback = createAppPredictorCallback(chooserListAdapter);\n        AppPredictor appPredictor = setupAppPredictorForUser(userHandle, appPredictorCallback);\n        chooserListAdapter.setAppPredictor(appPredictor);\n        chooserListAdapter.setAppPredictorCallback(appPredictorCallback);\n        return new ChooserGridAdapter(chooserListAdapter);\n    }\n\n    @VisibleForTesting\n    public ChooserListAdapter createChooserListAdapter(Context context,\n            List<Intent> payloadIntents, Intent[] initialIntents, List<ResolveInfo> rList,\n            boolean filterLastUsed, ResolverListController resolverListController) {\n        return new ChooserListAdapter(context, payloadIntents, initialIntents, rList,\n                filterLastUsed, resolverListController, this,\n                this, context.getPackageManager(),\n                getChooserActivityLogger());\n    }\n\n    @VisibleForTesting\n    protected ResolverListController createListController(UserHandle userHandle) {\n        AppPredictor appPredictor = getAppPredictorForShareActivitiesIfEnabled(userHandle);\n        AbstractResolverComparator resolverComparator;\n        if (appPredictor != null) {\n            resolverComparator = new AppPredictionServiceResolverComparator(this, getTargetIntent(),\n                    getReferrerPackageName(), appPredictor, userHandle, getChooserActivityLogger());\n        } else {\n            resolverComparator =\n                    new ResolverRankerServiceResolverComparator(this, getTargetIntent(),\n                        getReferrerPackageName(), null, getChooserActivityLogger());\n        }\n\n        return new ChooserListController(\n                this,\n                mPm,\n                getTargetIntent(),\n                getReferrerPackageName(),\n                mLaunchedFromUid,\n                userHandle,\n                resolverComparator);\n    }\n\n    @VisibleForTesting\n    protected Bitmap loadThumbnail(Uri uri, Size size) {\n        if (uri == null || size == null) {\n            return null;\n        }\n\n        try {\n            return getContentResolver().loadThumbnail(uri, size, null);\n        } catch (IOException | NullPointerException | SecurityException ex) {\n            logContentPreviewWarning(uri);\n        }\n        return null;\n    }\n\n    static final class PlaceHolderTargetInfo extends NotSelectableTargetInfo {\n        public Drawable getDisplayIcon(Context context) {\n            AnimatedVectorDrawable avd = (AnimatedVectorDrawable)\n                    context.getDrawable(R.drawable.chooser_direct_share_icon_placeholder);\n            avd.start(); // Start animation after generation\n            return avd;\n        }\n    }\n\n    protected static final class EmptyTargetInfo extends NotSelectableTargetInfo {\n        public EmptyTargetInfo() {}\n\n        public Drawable getDisplayIcon(Context context) {\n            return null;\n        }\n    }\n\n    private void handleScroll(View view, int x, int y, int oldx, int oldy) {\n        if (mChooserMultiProfilePagerAdapter.getCurrentRootAdapter() != null) {\n            mChooserMultiProfilePagerAdapter.getCurrentRootAdapter().handleScroll(view, y, oldy);\n        }\n    }\n\n    /*\n     * Need to dynamically adjust how many icons can fit per row before we add them,\n     * which also means setting the correct offset to initially show the content\n     * preview area + 2 rows of targets\n     */\n    private void handleLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft,\n            int oldTop, int oldRight, int oldBottom) {\n        if (mChooserMultiProfilePagerAdapter == null) {\n            return;\n        }\n        RecyclerView recyclerView = mChooserMultiProfilePagerAdapter.getActiveAdapterView();\n        ChooserGridAdapter gridAdapter = mChooserMultiProfilePagerAdapter.getCurrentRootAdapter();\n        // Skip height calculation if recycler view was scrolled to prevent it inaccurately\n        // calculating the height, as the logic below does not account for the scrolled offset.\n        if (gridAdapter == null || recyclerView == null\n                || recyclerView.computeVerticalScrollOffset() != 0) {\n            return;\n        }\n\n        final int availableWidth = right - left - v.getPaddingLeft() - v.getPaddingRight();\n        boolean isLayoutUpdated = gridAdapter.consumeLayoutRequest()\n                || gridAdapter.calculateChooserTargetWidth(availableWidth)\n                || recyclerView.getAdapter() == null\n                || availableWidth != mCurrAvailableWidth;\n        if (isLayoutUpdated\n                || mLastNumberOfChildren != recyclerView.getChildCount()) {\n            mCurrAvailableWidth = availableWidth;\n            if (isLayoutUpdated) {\n                // It is very important we call setAdapter from here. Otherwise in some cases\n                // the resolver list doesn't get populated, such as b/150922090, b/150918223\n                // and b/150936654\n                recyclerView.setAdapter(gridAdapter);\n                ((GridLayoutManager) recyclerView.getLayoutManager()).setSpanCount(\n                        mMaxTargetsPerRow);\n\n                updateTabPadding();\n            }\n\n            UserHandle currentUserHandle = mChooserMultiProfilePagerAdapter.getCurrentUserHandle();\n            int currentProfile = getProfileForUser(currentUserHandle);\n            int initialProfile = findSelectedProfile();\n            if (currentProfile != initialProfile) {\n                return;\n            }\n\n            if (mLastNumberOfChildren == recyclerView.getChildCount()) {\n                return;\n            }\n\n            getMainThreadHandler().post(() -> {\n                if (mResolverDrawerLayout == null || gridAdapter == null) {\n                    return;\n                }\n                int offset = calculateDrawerOffset(top, bottom, recyclerView, gridAdapter);\n                mResolverDrawerLayout.setCollapsibleHeightReserved(offset);\n                mEnterTransitionAnimationDelegate.markOffsetCalculated();\n            });\n        }\n    }\n\n    private int calculateDrawerOffset(\n            int top, int bottom, RecyclerView recyclerView, ChooserGridAdapter gridAdapter) {\n\n        final int bottomInset = mSystemWindowInsets != null\n                ? mSystemWindowInsets.bottom : 0;\n        int offset = bottomInset;\n        int rowsToShow = gridAdapter.getSystemRowCount()\n                + gridAdapter.getProfileRowCount()\n                + gridAdapter.getServiceTargetRowCount()\n                + gridAdapter.getCallerAndRankedTargetRowCount();\n\n        // then this is most likely not a SEND_* action, so check\n        // the app target count\n        if (rowsToShow == 0) {\n            rowsToShow = gridAdapter.getRowCount();\n        }\n\n        // still zero? then use a default height and leave, which\n        // can happen when there are no targets to show\n        if (rowsToShow == 0 && !shouldShowStickyContentPreview()) {\n            offset += getResources().getDimensionPixelSize(\n                    R.dimen.chooser_max_collapsed_height);\n            return offset;\n        }\n\n        View stickyContentPreview = findViewById(R.id.content_preview_container);\n        if (shouldShowStickyContentPreview() && isStickyContentPreviewShowing()) {\n            offset += stickyContentPreview.getHeight();\n        }\n\n        if (shouldShowTabs()) {\n            offset += findViewById(R.id.tabs).getHeight();\n        }\n\n        if (recyclerView.getVisibility() == View.VISIBLE) {\n            int directShareHeight = 0;\n            rowsToShow = Math.min(4, rowsToShow);\n            boolean shouldShowExtraRow = shouldShowExtraRow(rowsToShow);\n            mLastNumberOfChildren = recyclerView.getChildCount();\n            for (int i = 0, childCount = recyclerView.getChildCount();\n                    i < childCount && rowsToShow > 0; i++) {\n                View child = recyclerView.getChildAt(i);\n                if (((GridLayoutManager.LayoutParams)\n                        child.getLayoutParams()).getSpanIndex() != 0) {\n                    continue;\n                }\n                int height = child.getHeight();\n                offset += height;\n                if (shouldShowExtraRow) {\n                    offset += height;\n                }\n\n                if (gridAdapter.getTargetType(\n                        recyclerView.getChildAdapterPosition(child))\n                        == ChooserListAdapter.TARGET_SERVICE) {\n                    directShareHeight = height;\n                }\n                rowsToShow--;\n            }\n\n            boolean isExpandable = getResources().getConfiguration().orientation\n                    == Configuration.ORIENTATION_PORTRAIT && !isInMultiWindowMode();\n            if (directShareHeight != 0 && isSendAction(getTargetIntent())\n                    && isExpandable) {\n                // make sure to leave room for direct share 4->8 expansion\n                int requiredExpansionHeight =\n                        (int) (directShareHeight / DIRECT_SHARE_EXPANSION_RATE);\n                int topInset = mSystemWindowInsets != null ? mSystemWindowInsets.top : 0;\n                int minHeight = bottom - top - mResolverDrawerLayout.getAlwaysShowHeight()\n                        - requiredExpansionHeight - topInset - bottomInset;\n\n                offset = Math.min(offset, minHeight);\n            }\n        } else {\n            ViewGroup currentEmptyStateView = getActiveEmptyStateView();\n            if (currentEmptyStateView.getVisibility() == View.VISIBLE) {\n                offset += currentEmptyStateView.getHeight();\n            }\n        }\n\n        return Math.min(offset, bottom - top);\n    }\n\n    /**\n     * If we have a tabbed view and are showing 1 row in the current profile and an empty\n     * state screen in the other profile, to prevent cropping of the empty state screen we show\n     * a second row in the current profile.\n     */\n    private boolean shouldShowExtraRow(int rowsToShow) {\n        return shouldShowTabs()\n                && rowsToShow == 1\n                && mChooserMultiProfilePagerAdapter.shouldShowEmptyStateScreen(\n                        mChooserMultiProfilePagerAdapter.getInactiveListAdapter());\n    }\n\n    /**\n     * Returns {@link #PROFILE_PERSONAL}, {@link #PROFILE_WORK}, or -1 if the given user handle\n     * does not match either the personal or work user handle.\n     **/\n    private int getProfileForUser(UserHandle currentUserHandle) {\n        if (currentUserHandle.equals(getPersonalProfileUserHandle())) {\n            return PROFILE_PERSONAL;\n        } else if (currentUserHandle.equals(getWorkProfileUserHandle())) {\n            return PROFILE_WORK;\n        }\n        Log.e(TAG, \"User \" + currentUserHandle + \" does not belong to a personal or work profile.\");\n        return -1;\n    }\n\n    private ViewGroup getActiveEmptyStateView() {\n        int currentPage = mChooserMultiProfilePagerAdapter.getCurrentPage();\n        return mChooserMultiProfilePagerAdapter.getItem(currentPage).getEmptyStateView();\n    }\n\n    static class BaseChooserTargetComparator implements Comparator<ChooserTarget> {\n        @Override\n        public int compare(ChooserTarget lhs, ChooserTarget rhs) {\n            // Descending order\n            return (int) Math.signum(rhs.getScore() - lhs.getScore());\n        }\n    }\n\n    @Override // ResolverListCommunicator\n    public void onHandlePackagesChanged(ResolverListAdapter listAdapter) {\n        mChooserMultiProfilePagerAdapter.getActiveListAdapter().notifyDataSetChanged();\n        super.onHandlePackagesChanged(listAdapter);\n    }\n\n    @Override // SelectableTargetInfoCommunicator\n    public ActivityInfoPresentationGetter makePresentationGetter(ActivityInfo info) {\n        return mChooserMultiProfilePagerAdapter.getActiveListAdapter().makePresentationGetter(info);\n    }\n\n    @Override // SelectableTargetInfoCommunicator\n    public Intent getReferrerFillInIntent() {\n        return mReferrerFillInIntent;\n    }\n\n    @Override // ChooserListCommunicator\n    public int getMaxRankedTargets() {\n        return mMaxTargetsPerRow;\n    }\n\n    @Override // ChooserListCommunicator\n    public void sendListViewUpdateMessage(UserHandle userHandle) {\n        Message msg = Message.obtain();\n        msg.what = ChooserHandler.LIST_VIEW_UPDATE_MESSAGE;\n        msg.obj = userHandle;\n        mChooserHandler.sendMessageDelayed(msg, mListViewUpdateDelayMs);\n    }\n\n    @Override\n    public void onListRebuilt(ResolverListAdapter listAdapter, boolean rebuildComplete) {\n        setupScrollListener();\n        maybeSetupGlobalLayoutListener();\n\n        ChooserListAdapter chooserListAdapter = (ChooserListAdapter) listAdapter;\n        if (chooserListAdapter.getUserHandle()\n                .equals(mChooserMultiProfilePagerAdapter.getCurrentUserHandle())) {\n            mChooserMultiProfilePagerAdapter.getActiveAdapterView()\n                    .setAdapter(mChooserMultiProfilePagerAdapter.getCurrentRootAdapter());\n            mChooserMultiProfilePagerAdapter\n                    .setupListAdapter(mChooserMultiProfilePagerAdapter.getCurrentPage());\n        }\n\n        if (chooserListAdapter.mDisplayList == null\n                || chooserListAdapter.mDisplayList.isEmpty()) {\n            chooserListAdapter.notifyDataSetChanged();\n        } else {\n            chooserListAdapter.updateAlphabeticalList();\n        }\n\n        if (rebuildComplete) {\n            getChooserActivityLogger().logSharesheetAppLoadComplete();\n            maybeQueryAdditionalPostProcessingTargets(chooserListAdapter);\n            mLatencyTracker.onActionEnd(ACTION_LOAD_SHARE_SHEET);\n        }\n    }\n\n    private void maybeQueryAdditionalPostProcessingTargets(ChooserListAdapter chooserListAdapter) {\n        // don't support direct share on low ram devices\n        if (ActivityManager.isLowRamDeviceStatic()) {\n            return;\n        }\n\n        // no need to query direct share for work profile when its locked or disabled\n        if (!shouldQueryShortcutManager(chooserListAdapter.getUserHandle())) {\n            return;\n        }\n\n        if (ChooserFlags.USE_PREDICTION_MANAGER_FOR_DIRECT_TARGETS) {\n            if (DEBUG) {\n                Log.d(TAG, \"querying direct share targets from ShortcutManager\");\n            }\n\n            queryDirectShareTargets(chooserListAdapter, false);\n        }\n    }\n\n    @VisibleForTesting\n    protected boolean isUserRunning(UserHandle userHandle) {\n        UserManager userManager = getSystemService(UserManager.class);\n        return userManager.isUserRunning(userHandle);\n    }\n\n    @VisibleForTesting\n    protected boolean isUserUnlocked(UserHandle userHandle) {\n        UserManager userManager = getSystemService(UserManager.class);\n        return userManager.isUserUnlocked(userHandle);\n    }\n\n    @VisibleForTesting\n    protected boolean isQuietModeEnabled(UserHandle userHandle) {\n        UserManager userManager = getSystemService(UserManager.class);\n        return userManager.isQuietModeEnabled(userHandle);\n    }\n\n    private void setupScrollListener() {\n        if (mResolverDrawerLayout == null) {\n            return;\n        }\n        int elevatedViewResId = shouldShowTabs() ? R.id.tabs : R.id.chooser_header;\n        final View elevatedView = mResolverDrawerLayout.findViewById(elevatedViewResId);\n        final float defaultElevation = elevatedView.getElevation();\n        final float chooserHeaderScrollElevation =\n                getResources().getDimensionPixelSize(R.dimen.chooser_header_scroll_elevation);\n        mChooserMultiProfilePagerAdapter.getActiveAdapterView().addOnScrollListener(\n                new RecyclerView.OnScrollListener() {\n                    public void onScrollStateChanged(RecyclerView view, int scrollState) {\n                        if (scrollState == RecyclerView.SCROLL_STATE_IDLE) {\n                            if (mScrollStatus == SCROLL_STATUS_SCROLLING_VERTICAL) {\n                                mScrollStatus = SCROLL_STATUS_IDLE;\n                                setHorizontalScrollingEnabled(true);\n                            }\n                        } else if (scrollState == RecyclerView.SCROLL_STATE_DRAGGING) {\n                            if (mScrollStatus == SCROLL_STATUS_IDLE) {\n                                mScrollStatus = SCROLL_STATUS_SCROLLING_VERTICAL;\n                                setHorizontalScrollingEnabled(false);\n                            }\n                        }\n                    }\n\n                    public void onScrolled(RecyclerView view, int dx, int dy) {\n                        if (view.getChildCount() > 0) {\n                            View child = view.getLayoutManager().findViewByPosition(0);\n                            if (child == null || child.getTop() < 0) {\n                                elevatedView.setElevation(chooserHeaderScrollElevation);\n                                return;\n                            }\n                        }\n\n                        elevatedView.setElevation(defaultElevation);\n                    }\n                });\n    }\n\n    private void maybeSetupGlobalLayoutListener() {\n        if (shouldShowTabs()) {\n            return;\n        }\n        final View recyclerView = mChooserMultiProfilePagerAdapter.getActiveAdapterView();\n        recyclerView.getViewTreeObserver()\n                .addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {\n                    @Override\n                    public void onGlobalLayout() {\n                        // Fixes an issue were the accessibility border disappears on list creation.\n                        recyclerView.getViewTreeObserver().removeOnGlobalLayoutListener(this);\n                        final TextView titleView = findViewById(R.id.title);\n                        if (titleView != null) {\n                            titleView.setFocusable(true);\n                            titleView.setFocusableInTouchMode(true);\n                            titleView.requestFocus();\n                            titleView.requestAccessibilityFocus();\n                        }\n                    }\n                });\n    }\n\n    @Override // ChooserListCommunicator\n    public boolean isSendAction(Intent targetIntent) {\n        if (targetIntent == null) {\n            return false;\n        }\n\n        String action = targetIntent.getAction();\n        if (action == null) {\n            return false;\n        }\n\n        if (Intent.ACTION_SEND.equals(action) || Intent.ACTION_SEND_MULTIPLE.equals(action)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * The sticky content preview is shown only when we have a tabbed view. It's shown above\n     * the tabs so it is not part of the scrollable list. If we are not in tabbed view,\n     * we instead show the content preview as a regular list item.\n     */\n    private boolean shouldShowStickyContentPreview() {\n        return shouldShowStickyContentPreviewNoOrientationCheck()\n                && !getResources().getBoolean(R.bool.resolver_landscape_phone);\n    }\n\n    private boolean shouldShowStickyContentPreviewNoOrientationCheck() {\n        return shouldShowTabs()\n                && mMultiProfilePagerAdapter.getListAdapterForUserHandle(\n                UserHandle.of(UserHandle.myUserId())).getCount() > 0\n                && isSendAction(getTargetIntent());\n    }\n\n    private void updateStickyContentPreview() {\n        if (shouldShowStickyContentPreviewNoOrientationCheck()) {\n            // The sticky content preview is only shown when we show the work and personal tabs.\n            // We don't show it in landscape as otherwise there is no room for scrolling.\n            // If the sticky content preview will be shown at some point with orientation change,\n            // then always preload it to avoid subsequent resizing of the share sheet.\n            ViewGroup contentPreviewContainer = findViewById(R.id.content_preview_container);\n            if (contentPreviewContainer.getChildCount() == 0) {\n                ViewGroup contentPreviewView = createContentPreviewView(contentPreviewContainer);\n                contentPreviewContainer.addView(contentPreviewView);\n            }\n        }\n        if (shouldShowStickyContentPreview()) {\n            showStickyContentPreview();\n        } else {\n            hideStickyContentPreview();\n        }\n    }\n\n    private void showStickyContentPreview() {\n        if (isStickyContentPreviewShowing()) {\n            return;\n        }\n        ViewGroup contentPreviewContainer = findViewById(R.id.content_preview_container);\n        contentPreviewContainer.setVisibility(View.VISIBLE);\n    }\n\n    private boolean isStickyContentPreviewShowing() {\n        ViewGroup contentPreviewContainer = findViewById(R.id.content_preview_container);\n        return contentPreviewContainer.getVisibility() == View.VISIBLE;\n    }\n\n    private void hideStickyContentPreview() {\n        if (!isStickyContentPreviewShowing()) {\n            return;\n        }\n        ViewGroup contentPreviewContainer = findViewById(R.id.content_preview_container);\n        contentPreviewContainer.setVisibility(View.GONE);\n    }\n\n    private void logActionShareWithPreview() {\n        Intent targetIntent = getTargetIntent();\n        int previewType = findPreferredContentPreview(targetIntent, getContentResolver());\n        getMetricsLogger().write(new LogMaker(MetricsEvent.ACTION_SHARE_WITH_PREVIEW)\n                .setSubtype(previewType));\n    }\n\n    abstract static class ViewHolderBase extends RecyclerView.ViewHolder {\n        private int mViewType;\n\n        ViewHolderBase(View itemView, int viewType) {\n            super(itemView);\n            this.mViewType = viewType;\n        }\n\n        int getViewType() {\n            return mViewType;\n        }\n    }\n\n    /**\n     * Used to bind types of individual item including\n     * {@link ChooserGridAdapter#VIEW_TYPE_NORMAL},\n     * {@link ChooserGridAdapter#VIEW_TYPE_CONTENT_PREVIEW},\n     * {@link ChooserGridAdapter#VIEW_TYPE_PROFILE},\n     * and {@link ChooserGridAdapter#VIEW_TYPE_AZ_LABEL}.\n     */\n    final class ItemViewHolder extends ViewHolderBase {\n        ResolverListAdapter.ViewHolder mWrappedViewHolder;\n        int mListPosition = ChooserListAdapter.NO_POSITION;\n\n        ItemViewHolder(View itemView, boolean isClickable, int viewType) {\n            super(itemView, viewType);\n            mWrappedViewHolder = new ResolverListAdapter.ViewHolder(itemView);\n            if (isClickable) {\n                itemView.setOnClickListener(v -> startSelected(mListPosition,\n                        false/* always */, true/* filterd */));\n\n                itemView.setOnLongClickListener(v -> {\n                    final TargetInfo ti = mChooserMultiProfilePagerAdapter.getActiveListAdapter()\n                            .targetInfoForPosition(mListPosition, /* filtered */ true);\n\n                    // This should always be the case for ItemViewHolder, check for validity\n                    if (ti instanceof DisplayResolveInfo && shouldShowTargetDetails(ti)) {\n                        showTargetDetails((DisplayResolveInfo) ti);\n                    }\n                    return true;\n                });\n            }\n        }\n    }\n\n    private boolean shouldShowTargetDetails(TargetInfo ti) {\n        ComponentName nearbyShare = getNearbySharingComponent();\n        //  Suppress target details for nearby share to hide pin/unpin action\n        boolean isNearbyShare = nearbyShare != null && nearbyShare.equals(\n                ti.getResolvedComponentName()) && shouldNearbyShareBeFirstInRankedRow();\n        return ti instanceof SelectableTargetInfo\n                || (ti instanceof DisplayResolveInfo && !isNearbyShare);\n    }\n\n    /**\n     * Add a footer to the list, to support scrolling behavior below the navbar.\n     */\n    static final class FooterViewHolder extends ViewHolderBase {\n        FooterViewHolder(View itemView, int viewType) {\n            super(itemView, viewType);\n        }\n    }\n\n    /**\n     * Intentionally override the {@link ResolverActivity} implementation as we only need that\n     * implementation for the intent resolver case.\n     */\n    @Override\n    public void onButtonClick(View v) {}\n\n    /**\n     * Intentionally override the {@link ResolverActivity} implementation as we only need that\n     * implementation for the intent resolver case.\n     */\n    @Override\n    protected void resetButtonBar() {}\n\n    @Override\n    protected String getMetricsCategory() {\n        return METRICS_CATEGORY_CHOOSER;\n    }\n\n    @Override\n    protected void onProfileTabSelected() {\n        ChooserGridAdapter currentRootAdapter =\n                mChooserMultiProfilePagerAdapter.getCurrentRootAdapter();\n        currentRootAdapter.updateDirectShareExpansion();\n        // This fixes an edge case where after performing a variety of gestures, vertical scrolling\n        // ends up disabled. That's because at some point the old tab's vertical scrolling is\n        // disabled and the new tab's is enabled. For context, see b/159997845\n        setVerticalScrollEnabled(true);\n        if (mResolverDrawerLayout != null) {\n            mResolverDrawerLayout.scrollNestedScrollableChildBackToTop();\n        }\n    }\n\n    @Override\n    protected WindowInsets onApplyWindowInsets(View v, WindowInsets insets) {\n        if (shouldShowTabs()) {\n            mChooserMultiProfilePagerAdapter\n                    .setEmptyStateBottomOffset(insets.getSystemWindowInsetBottom());\n            mChooserMultiProfilePagerAdapter.setupContainerPadding(\n                    getActiveEmptyStateView().findViewById(R.id.resolver_empty_state_container));\n        }\n        return super.onApplyWindowInsets(v, insets);\n    }\n\n    private void setHorizontalScrollingEnabled(boolean enabled) {\n        ResolverViewPager viewPager = findViewById(R.id.profile_pager);\n        viewPager.setSwipingEnabled(enabled);\n    }\n\n    private void setVerticalScrollEnabled(boolean enabled) {\n        ChooserGridLayoutManager layoutManager =\n                (ChooserGridLayoutManager) mChooserMultiProfilePagerAdapter.getActiveAdapterView()\n                        .getLayoutManager();\n        layoutManager.setVerticalScrollEnabled(enabled);\n    }\n\n    @Override\n    void onHorizontalSwipeStateChanged(int state) {\n        if (state == ViewPager.SCROLL_STATE_DRAGGING) {\n            if (mScrollStatus == SCROLL_STATUS_IDLE) {\n                mScrollStatus = SCROLL_STATUS_SCROLLING_HORIZONTAL;\n                setVerticalScrollEnabled(false);\n            }\n        } else if (state == ViewPager.SCROLL_STATE_IDLE) {\n            if (mScrollStatus == SCROLL_STATUS_SCROLLING_HORIZONTAL) {\n                mScrollStatus = SCROLL_STATUS_IDLE;\n                setVerticalScrollEnabled(true);\n            }\n        }\n    }\n\n    /**\n     * Adapter for all types of items and targets in ShareSheet.\n     * Note that ranked sections like Direct Share - while appearing grid-like - are handled on the\n     * row level by this adapter but not on the item level. Individual targets within the row are\n     * handled by {@link ChooserListAdapter}\n     */\n    @VisibleForTesting\n    public final class ChooserGridAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolder> {\n        private ChooserListAdapter mChooserListAdapter;\n        private final LayoutInflater mLayoutInflater;\n\n        private DirectShareViewHolder mDirectShareViewHolder;\n        private int mChooserTargetWidth = 0;\n        private boolean mShowAzLabelIfPoss;\n        private boolean mLayoutRequested = false;\n\n        private int mFooterHeight = 0;\n\n        private static final int VIEW_TYPE_DIRECT_SHARE = 0;\n        private static final int VIEW_TYPE_NORMAL = 1;\n        private static final int VIEW_TYPE_CONTENT_PREVIEW = 2;\n        private static final int VIEW_TYPE_PROFILE = 3;\n        private static final int VIEW_TYPE_AZ_LABEL = 4;\n        private static final int VIEW_TYPE_CALLER_AND_RANK = 5;\n        private static final int VIEW_TYPE_FOOTER = 6;\n\n        private static final int NUM_EXPANSIONS_TO_HIDE_AZ_LABEL = 20;\n\n        ChooserGridAdapter(ChooserListAdapter wrappedAdapter) {\n            super();\n            mChooserListAdapter = wrappedAdapter;\n            mLayoutInflater = LayoutInflater.from(ChooserActivity.this);\n\n            mShowAzLabelIfPoss = getNumSheetExpansions() < NUM_EXPANSIONS_TO_HIDE_AZ_LABEL;\n\n            wrappedAdapter.registerDataSetObserver(new DataSetObserver() {\n                @Override\n                public void onChanged() {\n                    super.onChanged();\n                    notifyDataSetChanged();\n                }\n\n                @Override\n                public void onInvalidated() {\n                    super.onInvalidated();\n                    notifyDataSetChanged();\n                }\n            });\n        }\n\n        public void setFooterHeight(int height) {\n            mFooterHeight = height;\n        }\n\n        /**\n         * Calculate the chooser target width to maximize space per item\n         *\n         * @param width The new row width to use for recalculation\n         * @return true if the view width has changed\n         */\n        public boolean calculateChooserTargetWidth(int width) {\n            if (width == 0) {\n                return false;\n            }\n\n            // Limit width to the maximum width of the chooser activity\n            int maxWidth = getResources().getDimensionPixelSize(R.dimen.chooser_width);\n            width = Math.min(maxWidth, width);\n\n            int newWidth = width / mMaxTargetsPerRow;\n            if (newWidth != mChooserTargetWidth) {\n                mChooserTargetWidth = newWidth;\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Hides the list item content preview.\n         * <p>Not to be confused with the sticky content preview which is above the\n         * personal and work tabs.\n         */\n        public void hideContentPreview() {\n            mLayoutRequested = true;\n            notifyDataSetChanged();\n        }\n\n        public boolean consumeLayoutRequest() {\n            boolean oldValue = mLayoutRequested;\n            mLayoutRequested = false;\n            return oldValue;\n        }\n\n        public int getRowCount() {\n            return (int) (\n                    getSystemRowCount()\n                            + getProfileRowCount()\n                            + getServiceTargetRowCount()\n                            + getCallerAndRankedTargetRowCount()\n                            + getAzLabelRowCount()\n                            + Math.ceil(\n                            (float) mChooserListAdapter.getAlphaTargetCount()\n                                    / mMaxTargetsPerRow)\n            );\n        }\n\n        /**\n         * Whether the \"system\" row of targets is displayed.\n         * This area includes the content preview (if present) and action row.\n         */\n        public int getSystemRowCount() {\n            // For the tabbed case we show the sticky content preview above the tabs,\n            // please refer to shouldShowStickyContentPreview\n            if (shouldShowTabs()) {\n                return 0;\n            }\n\n            if (!isSendAction(getTargetIntent())) {\n                return 0;\n            }\n\n            if (mChooserListAdapter == null || mChooserListAdapter.getCount() == 0) {\n                return 0;\n            }\n\n            return 1;\n        }\n\n        public int getProfileRowCount() {\n            if (shouldShowTabs()) {\n                return 0;\n            }\n            return mChooserListAdapter.getOtherProfile() == null ? 0 : 1;\n        }\n\n        public int getFooterRowCount() {\n            return 1;\n        }\n\n        public int getCallerAndRankedTargetRowCount() {\n            return (int) Math.ceil(\n                    ((float) mChooserListAdapter.getCallerTargetCount()\n                            + mChooserListAdapter.getRankedTargetCount()) / mMaxTargetsPerRow);\n        }\n\n        // There can be at most one row in the listview, that is internally\n        // a ViewGroup with 2 rows\n        public int getServiceTargetRowCount() {\n            if (isSendAction(getTargetIntent())\n                    && !ActivityManager.isLowRamDeviceStatic()) {\n                return 1;\n            }\n            return 0;\n        }\n\n        public int getAzLabelRowCount() {\n            // Only show a label if the a-z list is showing\n            return (mShowAzLabelIfPoss && mChooserListAdapter.getAlphaTargetCount() > 0) ? 1 : 0;\n        }\n\n        @Override\n        public int getItemCount() {\n            return (int) (\n                    getSystemRowCount()\n                            + getProfileRowCount()\n                            + getServiceTargetRowCount()\n                            + getCallerAndRankedTargetRowCount()\n                            + getAzLabelRowCount()\n                            + mChooserListAdapter.getAlphaTargetCount()\n                            + getFooterRowCount()\n            );\n        }\n\n        @Override\n        public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n            switch (viewType) {\n                case VIEW_TYPE_CONTENT_PREVIEW:\n                    return new ItemViewHolder(createContentPreviewView(parent), false, viewType);\n                case VIEW_TYPE_PROFILE:\n                    return new ItemViewHolder(createProfileView(parent), false, viewType);\n                case VIEW_TYPE_AZ_LABEL:\n                    return new ItemViewHolder(createAzLabelView(parent), false, viewType);\n                case VIEW_TYPE_NORMAL:\n                    return new ItemViewHolder(\n                            mChooserListAdapter.createView(parent), true, viewType);\n                case VIEW_TYPE_DIRECT_SHARE:\n                case VIEW_TYPE_CALLER_AND_RANK:\n                    return createItemGroupViewHolder(viewType, parent);\n                case VIEW_TYPE_FOOTER:\n                    Space sp = new Space(parent.getContext());\n                    sp.setLayoutParams(new RecyclerView.LayoutParams(\n                            LayoutParams.MATCH_PARENT, mFooterHeight));\n                    return new FooterViewHolder(sp, viewType);\n                default:\n                    // Since we catch all possible viewTypes above, no chance this is being called.\n                    return null;\n            }\n        }\n\n        @Override\n        public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {\n            int viewType = ((ViewHolderBase) holder).getViewType();\n            switch (viewType) {\n                case VIEW_TYPE_DIRECT_SHARE:\n                case VIEW_TYPE_CALLER_AND_RANK:\n                    bindItemGroupViewHolder(position, (ItemGroupViewHolder) holder);\n                    break;\n                case VIEW_TYPE_NORMAL:\n                    bindItemViewHolder(position, (ItemViewHolder) holder);\n                    break;\n                default:\n            }\n        }\n\n        @Override\n        public int getItemViewType(int position) {\n            int count;\n\n            int countSum = (count = getSystemRowCount());\n            if (count > 0 && position < countSum) return VIEW_TYPE_CONTENT_PREVIEW;\n\n            countSum += (count = getProfileRowCount());\n            if (count > 0 && position < countSum) return VIEW_TYPE_PROFILE;\n\n            countSum += (count = getServiceTargetRowCount());\n            if (count > 0 && position < countSum) return VIEW_TYPE_DIRECT_SHARE;\n\n            countSum += (count = getCallerAndRankedTargetRowCount());\n            if (count > 0 && position < countSum) return VIEW_TYPE_CALLER_AND_RANK;\n\n            countSum += (count = getAzLabelRowCount());\n            if (count > 0 && position < countSum) return VIEW_TYPE_AZ_LABEL;\n\n            if (position == getItemCount() - 1) return VIEW_TYPE_FOOTER;\n\n            return VIEW_TYPE_NORMAL;\n        }\n\n        public int getTargetType(int position) {\n            return mChooserListAdapter.getPositionTargetType(getListPosition(position));\n        }\n\n        private View createProfileView(ViewGroup parent) {\n            View profileRow = mLayoutInflater.inflate(R.layout.chooser_profile_row, parent, false);\n            mProfileView = profileRow.findViewById(R.id.profile_button);\n            mProfileView.setOnClickListener(ChooserActivity.this::onProfileClick);\n            updateProfileViewButton();\n            return profileRow;\n        }\n\n        private View createAzLabelView(ViewGroup parent) {\n            return mLayoutInflater.inflate(R.layout.chooser_az_label_row, parent, false);\n        }\n\n        private ItemGroupViewHolder loadViewsIntoGroup(ItemGroupViewHolder holder) {\n            final int spec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);\n            final int exactSpec = MeasureSpec.makeMeasureSpec(mChooserTargetWidth,\n                    MeasureSpec.EXACTLY);\n            int columnCount = holder.getColumnCount();\n\n            final boolean isDirectShare = holder instanceof DirectShareViewHolder;\n\n            for (int i = 0; i < columnCount; i++) {\n                final View v = mChooserListAdapter.createView(holder.getRowByIndex(i));\n                final int column = i;\n                v.setOnClickListener(new OnClickListener() {\n                    @Override\n                    public void onClick(View v) {\n                        startSelected(holder.getItemIndex(column), false, true);\n                    }\n                });\n\n                // Show menu for both direct share and app share targets after long click.\n                v.setOnLongClickListener(v1 -> {\n                    TargetInfo ti = mChooserListAdapter.targetInfoForPosition(\n                            holder.getItemIndex(column), true);\n                    if (shouldShowTargetDetails(ti)) {\n                        showTargetDetails(ti);\n                    }\n                    return true;\n                });\n\n                holder.addView(i, v);\n\n                // Force Direct Share to be 2 lines and auto-wrap to second line via hoz scroll =\n                // false. TextView#setHorizontallyScrolling must be reset after #setLines. Must be\n                // done before measuring.\n                if (isDirectShare) {\n                    final ViewHolder vh = (ViewHolder) v.getTag();\n                    vh.text.setLines(2);\n                    vh.text.setHorizontallyScrolling(false);\n                    vh.text2.setVisibility(View.GONE);\n                }\n\n                // Force height to be a given so we don't have visual disruption during scaling.\n                v.measure(exactSpec, spec);\n                setViewBounds(v, v.getMeasuredWidth(), v.getMeasuredHeight());\n            }\n\n            final ViewGroup viewGroup = holder.getViewGroup();\n\n            // Pre-measure and fix height so we can scale later.\n            holder.measure();\n            setViewBounds(viewGroup, LayoutParams.MATCH_PARENT, holder.getMeasuredRowHeight());\n\n            if (isDirectShare) {\n                DirectShareViewHolder dsvh = (DirectShareViewHolder) holder;\n                setViewBounds(dsvh.getRow(0), LayoutParams.MATCH_PARENT, dsvh.getMinRowHeight());\n                setViewBounds(dsvh.getRow(1), LayoutParams.MATCH_PARENT, dsvh.getMinRowHeight());\n            }\n\n            viewGroup.setTag(holder);\n            return holder;\n        }\n\n        private void setViewBounds(View view, int widthPx, int heightPx) {\n            LayoutParams lp = view.getLayoutParams();\n            if (lp == null) {\n                lp = new LayoutParams(widthPx, heightPx);\n                view.setLayoutParams(lp);\n            } else {\n                lp.height = heightPx;\n                lp.width = widthPx;\n            }\n        }\n\n        ItemGroupViewHolder createItemGroupViewHolder(int viewType, ViewGroup parent) {\n            if (viewType == VIEW_TYPE_DIRECT_SHARE) {\n                ViewGroup parentGroup = (ViewGroup) mLayoutInflater.inflate(\n                        R.layout.chooser_row_direct_share, parent, false);\n                ViewGroup row1 = (ViewGroup) mLayoutInflater.inflate(R.layout.chooser_row,\n                        parentGroup, false);\n                ViewGroup row2 = (ViewGroup) mLayoutInflater.inflate(R.layout.chooser_row,\n                        parentGroup, false);\n                parentGroup.addView(row1);\n                parentGroup.addView(row2);\n\n                mDirectShareViewHolder = new DirectShareViewHolder(parentGroup,\n                        Lists.newArrayList(row1, row2), mMaxTargetsPerRow, viewType,\n                        mChooserMultiProfilePagerAdapter::getActiveListAdapter);\n                loadViewsIntoGroup(mDirectShareViewHolder);\n\n                return mDirectShareViewHolder;\n            } else {\n                ViewGroup row = (ViewGroup) mLayoutInflater.inflate(R.layout.chooser_row, parent,\n                        false);\n                ItemGroupViewHolder holder =\n                        new SingleRowViewHolder(row, mMaxTargetsPerRow, viewType);\n                loadViewsIntoGroup(holder);\n\n                return holder;\n            }\n        }\n\n        /**\n         * Need to merge CALLER + ranked STANDARD into a single row and prevent a separator from\n         * showing on top of the AZ list if the AZ label is visible. All other types are placed into\n         * their own row as determined by their target type, and dividers are added in the list to\n         * separate each type.\n         */\n        int getRowType(int rowPosition) {\n            // Merge caller and ranked standard into a single row\n            int positionType = mChooserListAdapter.getPositionTargetType(rowPosition);\n            if (positionType == ChooserListAdapter.TARGET_CALLER) {\n                return ChooserListAdapter.TARGET_STANDARD;\n            }\n\n            // If an the A-Z label is shown, prevent a separator from appearing by making the A-Z\n            // row type the same as the suggestion row type\n            if (getAzLabelRowCount() > 0 && positionType == ChooserListAdapter.TARGET_STANDARD_AZ) {\n                return ChooserListAdapter.TARGET_STANDARD;\n            }\n\n            return positionType;\n        }\n\n        void bindItemViewHolder(int position, ItemViewHolder holder) {\n            View v = holder.itemView;\n            int listPosition = getListPosition(position);\n            holder.mListPosition = listPosition;\n            mChooserListAdapter.bindView(listPosition, v);\n        }\n\n        void bindItemGroupViewHolder(int position, ItemGroupViewHolder holder) {\n            final ViewGroup viewGroup = (ViewGroup) holder.itemView;\n            int start = getListPosition(position);\n            int startType = getRowType(start);\n\n            int columnCount = holder.getColumnCount();\n            int end = start + columnCount - 1;\n            while (getRowType(end) != startType && end >= start) {\n                end--;\n            }\n\n            if (end == start && mChooserListAdapter.getItem(start) instanceof EmptyTargetInfo) {\n                final TextView textView = viewGroup.findViewById(R.id.chooser_row_text_option);\n\n                if (textView.getVisibility() != View.VISIBLE) {\n                    textView.setAlpha(0.0f);\n                    textView.setVisibility(View.VISIBLE);\n                    textView.setText(R.string.chooser_no_direct_share_targets);\n\n                    ValueAnimator fadeAnim = ObjectAnimator.ofFloat(textView, \"alpha\", 0.0f, 1.0f);\n                    fadeAnim.setInterpolator(new DecelerateInterpolator(1.0f));\n\n                    float translationInPx = getResources().getDimensionPixelSize(\n                            R.dimen.chooser_row_text_option_translate);\n                    textView.setTranslationY(translationInPx);\n                    ValueAnimator translateAnim = ObjectAnimator.ofFloat(textView, \"translationY\",\n                            0.0f);\n                    translateAnim.setInterpolator(new DecelerateInterpolator(1.0f));\n\n                    AnimatorSet animSet = new AnimatorSet();\n                    animSet.setDuration(NO_DIRECT_SHARE_ANIM_IN_MILLIS);\n                    animSet.setStartDelay(NO_DIRECT_SHARE_ANIM_IN_MILLIS);\n                    animSet.playTogether(fadeAnim, translateAnim);\n                    animSet.start();\n                }\n            }\n\n            for (int i = 0; i < columnCount; i++) {\n                final View v = holder.getView(i);\n\n                if (start + i <= end) {\n                    holder.setViewVisibility(i, View.VISIBLE);\n                    holder.setItemIndex(i, start + i);\n                    mChooserListAdapter.bindView(holder.getItemIndex(i), v);\n                } else {\n                    holder.setViewVisibility(i, View.INVISIBLE);\n                }\n            }\n        }\n\n        int getListPosition(int position) {\n            position -= getSystemRowCount() + getProfileRowCount();\n\n            final int serviceCount = mChooserListAdapter.getServiceTargetCount();\n            final int serviceRows = (int) Math.ceil((float) serviceCount / getMaxRankedTargets());\n            if (position < serviceRows) {\n                return position * mMaxTargetsPerRow;\n            }\n\n            position -= serviceRows;\n\n            final int callerAndRankedCount = mChooserListAdapter.getCallerTargetCount()\n                                                 + mChooserListAdapter.getRankedTargetCount();\n            final int callerAndRankedRows = getCallerAndRankedTargetRowCount();\n            if (position < callerAndRankedRows) {\n                return serviceCount + position * mMaxTargetsPerRow;\n            }\n\n            position -= getAzLabelRowCount() + callerAndRankedRows;\n\n            return callerAndRankedCount + serviceCount + position;\n        }\n\n        public void handleScroll(View v, int y, int oldy) {\n            boolean canExpandDirectShare = canExpandDirectShare();\n            if (mDirectShareViewHolder != null && canExpandDirectShare) {\n                mDirectShareViewHolder.handleScroll(\n                        mChooserMultiProfilePagerAdapter.getActiveAdapterView(), y, oldy,\n                        mMaxTargetsPerRow);\n            }\n        }\n\n        /**\n         * Only expand direct share area if there is a minimum number of targets.\n         */\n        private boolean canExpandDirectShare() {\n            // Do not enable until we have confirmed more apps are using sharing shortcuts\n            // Check git history for enablement logic\n            return false;\n        }\n\n        public ChooserListAdapter getListAdapter() {\n            return mChooserListAdapter;\n        }\n\n        boolean shouldCellSpan(int position) {\n            return getItemViewType(position) == VIEW_TYPE_NORMAL;\n        }\n\n        void updateDirectShareExpansion() {\n            if (mDirectShareViewHolder == null || !canExpandDirectShare()) {\n                return;\n            }\n            RecyclerView activeAdapterView =\n                    mChooserMultiProfilePagerAdapter.getActiveAdapterView();\n            if (mResolverDrawerLayout.isCollapsed()) {\n                mDirectShareViewHolder.collapse(activeAdapterView);\n            } else {\n                mDirectShareViewHolder.expand(activeAdapterView);\n            }\n        }\n    }\n\n    /**\n     * Used to bind types for group of items including:\n     * {@link ChooserGridAdapter#VIEW_TYPE_DIRECT_SHARE},\n     * and {@link ChooserGridAdapter#VIEW_TYPE_CALLER_AND_RANK}.\n     */\n    abstract static class ItemGroupViewHolder extends ViewHolderBase {\n        protected int mMeasuredRowHeight;\n        private int[] mItemIndices;\n        protected final View[] mCells;\n        private final int mColumnCount;\n\n        ItemGroupViewHolder(int cellCount, View itemView, int viewType) {\n            super(itemView, viewType);\n            this.mCells = new View[cellCount];\n            this.mItemIndices = new int[cellCount];\n            this.mColumnCount = cellCount;\n        }\n\n        abstract ViewGroup addView(int index, View v);\n\n        abstract ViewGroup getViewGroup();\n\n        abstract ViewGroup getRowByIndex(int index);\n\n        abstract ViewGroup getRow(int rowNumber);\n\n        abstract void setViewVisibility(int i, int visibility);\n\n        public int getColumnCount() {\n            return mColumnCount;\n        }\n\n        public void measure() {\n            final int spec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);\n            getViewGroup().measure(spec, spec);\n            mMeasuredRowHeight = getViewGroup().getMeasuredHeight();\n        }\n\n        public int getMeasuredRowHeight() {\n            return mMeasuredRowHeight;\n        }\n\n        public void setItemIndex(int itemIndex, int listIndex) {\n            mItemIndices[itemIndex] = listIndex;\n        }\n\n        public int getItemIndex(int itemIndex) {\n            return mItemIndices[itemIndex];\n        }\n\n        public View getView(int index) {\n            return mCells[index];\n        }\n    }\n\n    static class SingleRowViewHolder extends ItemGroupViewHolder {\n        private final ViewGroup mRow;\n\n        SingleRowViewHolder(ViewGroup row, int cellCount, int viewType) {\n            super(cellCount, row, viewType);\n\n            this.mRow = row;\n        }\n\n        public ViewGroup getViewGroup() {\n            return mRow;\n        }\n\n        public ViewGroup getRowByIndex(int index) {\n            return mRow;\n        }\n\n        public ViewGroup getRow(int rowNumber) {\n            if (rowNumber == 0) return mRow;\n            return null;\n        }\n\n        public ViewGroup addView(int index, View v) {\n            mRow.addView(v);\n            mCells[index] = v;\n\n            return mRow;\n        }\n\n        public void setViewVisibility(int i, int visibility) {\n            getView(i).setVisibility(visibility);\n        }\n    }\n\n    static class DirectShareViewHolder extends ItemGroupViewHolder {\n        private final ViewGroup mParent;\n        private final List<ViewGroup> mRows;\n        private int mCellCountPerRow;\n\n        private boolean mHideDirectShareExpansion = false;\n        private int mDirectShareMinHeight = 0;\n        private int mDirectShareCurrHeight = 0;\n        private int mDirectShareMaxHeight = 0;\n\n        private final boolean[] mCellVisibility;\n\n        private final Supplier<ChooserListAdapter> mListAdapterSupplier;\n\n        DirectShareViewHolder(ViewGroup parent, List<ViewGroup> rows, int cellCountPerRow,\n                int viewType, Supplier<ChooserListAdapter> listAdapterSupplier) {\n            super(rows.size() * cellCountPerRow, parent, viewType);\n\n            this.mParent = parent;\n            this.mRows = rows;\n            this.mCellCountPerRow = cellCountPerRow;\n            this.mCellVisibility = new boolean[rows.size() * cellCountPerRow];\n            this.mListAdapterSupplier = listAdapterSupplier;\n        }\n\n        public ViewGroup addView(int index, View v) {\n            ViewGroup row = getRowByIndex(index);\n            row.addView(v);\n            mCells[index] = v;\n\n            return row;\n        }\n\n        public ViewGroup getViewGroup() {\n            return mParent;\n        }\n\n        public ViewGroup getRowByIndex(int index) {\n            return mRows.get(index / mCellCountPerRow);\n        }\n\n        public ViewGroup getRow(int rowNumber) {\n            return mRows.get(rowNumber);\n        }\n\n        public void measure() {\n            final int spec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);\n            getRow(0).measure(spec, spec);\n            getRow(1).measure(spec, spec);\n\n            mDirectShareMinHeight = getRow(0).getMeasuredHeight();\n            mDirectShareCurrHeight = mDirectShareCurrHeight > 0\n                    ? mDirectShareCurrHeight : mDirectShareMinHeight;\n            mDirectShareMaxHeight = 2 * mDirectShareMinHeight;\n        }\n\n        public int getMeasuredRowHeight() {\n            return mDirectShareCurrHeight;\n        }\n\n        public int getMinRowHeight() {\n            return mDirectShareMinHeight;\n        }\n\n        public void setViewVisibility(int i, int visibility) {\n            final View v = getView(i);\n            if (visibility == View.VISIBLE) {\n                mCellVisibility[i] = true;\n                v.setVisibility(visibility);\n                v.setAlpha(1.0f);\n            } else if (visibility == View.INVISIBLE && mCellVisibility[i]) {\n                mCellVisibility[i] = false;\n\n                ValueAnimator fadeAnim = ObjectAnimator.ofFloat(v, \"alpha\", 1.0f, 0f);\n                fadeAnim.setDuration(NO_DIRECT_SHARE_ANIM_IN_MILLIS);\n                fadeAnim.setInterpolator(new AccelerateInterpolator(1.0f));\n                fadeAnim.addListener(new AnimatorListenerAdapter() {\n                    public void onAnimationEnd(Animator animation) {\n                        v.setVisibility(View.INVISIBLE);\n                    }\n                });\n                fadeAnim.start();\n            }\n        }\n\n        public void handleScroll(RecyclerView view, int y, int oldy, int maxTargetsPerRow) {\n            // only exit early if fully collapsed, otherwise onListRebuilt() with shifting\n            // targets can lock us into an expanded mode\n            boolean notExpanded = mDirectShareCurrHeight == mDirectShareMinHeight;\n            if (notExpanded) {\n                if (mHideDirectShareExpansion) {\n                    return;\n                }\n\n                // only expand if we have more than maxTargetsPerRow, and delay that decision\n                // until they start to scroll\n                ChooserListAdapter adapter = mListAdapterSupplier.get();\n                int validTargets = adapter.getSelectableServiceTargetCount();\n                if (validTargets <= maxTargetsPerRow) {\n                    mHideDirectShareExpansion = true;\n                    return;\n                }\n            }\n\n            int yDiff = (int) ((oldy - y) * DIRECT_SHARE_EXPANSION_RATE);\n\n            int prevHeight = mDirectShareCurrHeight;\n            int newHeight = Math.min(prevHeight + yDiff, mDirectShareMaxHeight);\n            newHeight = Math.max(newHeight, mDirectShareMinHeight);\n            yDiff = newHeight - prevHeight;\n\n            updateDirectShareRowHeight(view, yDiff, newHeight);\n        }\n\n        void expand(RecyclerView view) {\n            updateDirectShareRowHeight(view, mDirectShareMaxHeight - mDirectShareCurrHeight,\n                    mDirectShareMaxHeight);\n        }\n\n        void collapse(RecyclerView view) {\n            updateDirectShareRowHeight(view, mDirectShareMinHeight - mDirectShareCurrHeight,\n                    mDirectShareMinHeight);\n        }\n\n        private void updateDirectShareRowHeight(RecyclerView view, int yDiff, int newHeight) {\n            if (view == null || view.getChildCount() == 0 || yDiff == 0) {\n                return;\n            }\n\n            // locate the item to expand, and offset the rows below that one\n            boolean foundExpansion = false;\n            for (int i = 0; i < view.getChildCount(); i++) {\n                View child = view.getChildAt(i);\n\n                if (foundExpansion) {\n                    child.offsetTopAndBottom(yDiff);\n                } else {\n                    if (child.getTag() != null && child.getTag() instanceof DirectShareViewHolder) {\n                        int widthSpec = MeasureSpec.makeMeasureSpec(child.getWidth(),\n                                MeasureSpec.EXACTLY);\n                        int heightSpec = MeasureSpec.makeMeasureSpec(newHeight,\n                                MeasureSpec.EXACTLY);\n                        child.measure(widthSpec, heightSpec);\n                        child.getLayoutParams().height = child.getMeasuredHeight();\n                        child.layout(child.getLeft(), child.getTop(), child.getRight(),\n                                child.getTop() + child.getMeasuredHeight());\n\n                        foundExpansion = true;\n                    }\n                }\n            }\n\n            if (foundExpansion) {\n                mDirectShareCurrHeight = newHeight;\n            }\n        }\n    }\n\n    static class ServiceResultInfo {\n        public final DisplayResolveInfo originalTarget;\n        public final List<ChooserTarget> resultTargets;\n        public final UserHandle userHandle;\n\n        public ServiceResultInfo(DisplayResolveInfo ot, List<ChooserTarget> rt,\n                UserHandle userHandle) {\n            originalTarget = ot;\n            resultTargets = rt;\n            this.userHandle = userHandle;\n        }\n    }\n\n    static class ChooserTargetRankingInfo {\n        public final List<AppTarget> scores;\n        public final UserHandle userHandle;\n\n        ChooserTargetRankingInfo(List<AppTarget> chooserTargetScores,\n                UserHandle userHandle) {\n            this.scores = chooserTargetScores;\n            this.userHandle = userHandle;\n        }\n    }\n\n    static class RefinementResultReceiver extends ResultReceiver {\n        private ChooserActivity mChooserActivity;\n        private TargetInfo mSelectedTarget;\n\n        public RefinementResultReceiver(ChooserActivity host, TargetInfo target,\n                Handler handler) {\n            super(handler);\n            mChooserActivity = host;\n            mSelectedTarget = target;\n        }\n\n        @Override\n        protected void onReceiveResult(int resultCode, Bundle resultData) {\n            if (mChooserActivity == null) {\n                Log.e(TAG, \"Destroyed RefinementResultReceiver received a result\");\n                return;\n            }\n            if (resultData == null) {\n                Log.e(TAG, \"RefinementResultReceiver received null resultData\");\n                return;\n            }\n\n            switch (resultCode) {\n                case RESULT_CANCELED:\n                    mChooserActivity.onRefinementCanceled();\n                    break;\n                case RESULT_OK:\n                    Parcelable intentParcelable = resultData.getParcelable(Intent.EXTRA_INTENT);\n                    if (intentParcelable instanceof Intent) {\n                        mChooserActivity.onRefinementResult(mSelectedTarget,\n                                (Intent) intentParcelable);\n                    } else {\n                        Log.e(TAG, \"RefinementResultReceiver received RESULT_OK but no Intent\"\n                                + \" in resultData with key Intent.EXTRA_INTENT\");\n                    }\n                    break;\n                default:\n                    Log.w(TAG, \"Unknown result code \" + resultCode\n                            + \" sent to RefinementResultReceiver\");\n                    break;\n            }\n        }\n\n        public void destroy() {\n            mChooserActivity = null;\n            mSelectedTarget = null;\n        }\n    }\n\n    /**\n     * Used internally to round image corners while obeying view padding.\n     */\n    public static class RoundedRectImageView extends ImageView {\n        private int mRadius = 0;\n        private Path mPath = new Path();\n        private Paint mOverlayPaint = new Paint(0);\n        private Paint mRoundRectPaint = new Paint(0);\n        private Paint mTextPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        private String mExtraImageCount = null;\n\n        public RoundedRectImageView(Context context) {\n            super(context);\n        }\n\n        public RoundedRectImageView(Context context, AttributeSet attrs) {\n            this(context, attrs, 0);\n        }\n\n        public RoundedRectImageView(Context context, AttributeSet attrs, int defStyleAttr) {\n            this(context, attrs, defStyleAttr, 0);\n        }\n\n        public RoundedRectImageView(Context context, AttributeSet attrs, int defStyleAttr,\n                int defStyleRes) {\n            super(context, attrs, defStyleAttr, defStyleRes);\n            mRadius = context.getResources().getDimensionPixelSize(R.dimen.chooser_corner_radius);\n\n            mOverlayPaint.setColor(0x99000000);\n            mOverlayPaint.setStyle(Paint.Style.FILL);\n\n            mRoundRectPaint.setColor(context.getResources().getColor(R.color.chooser_row_divider));\n            mRoundRectPaint.setStyle(Paint.Style.STROKE);\n            mRoundRectPaint.setStrokeWidth(context.getResources()\n                    .getDimensionPixelSize(R.dimen.chooser_preview_image_border));\n\n            mTextPaint.setColor(Color.WHITE);\n            mTextPaint.setTextSize(context.getResources()\n                    .getDimensionPixelSize(R.dimen.chooser_preview_image_font_size));\n            mTextPaint.setTextAlign(Paint.Align.CENTER);\n        }\n\n        private void updatePath(int width, int height) {\n            mPath.reset();\n\n            int imageWidth = width - getPaddingRight() - getPaddingLeft();\n            int imageHeight = height - getPaddingBottom() - getPaddingTop();\n            mPath.addRoundRect(getPaddingLeft(), getPaddingTop(), imageWidth, imageHeight, mRadius,\n                    mRadius, Path.Direction.CW);\n        }\n\n        /**\n          * Sets the corner radius on all corners\n          *\n          * param radius 0 for no radius, &gt; 0 for a visible corner radius\n          */\n        public void setRadius(int radius) {\n            mRadius = radius;\n            updatePath(getWidth(), getHeight());\n        }\n\n        /**\n          * Display an overlay with extra image count on 3rd image\n          */\n        public void setExtraImageCount(int count) {\n            if (count > 0) {\n                this.mExtraImageCount = \"+\" + count;\n            } else {\n                this.mExtraImageCount = null;\n            }\n        }\n\n        @Override\n        protected void onSizeChanged(int width, int height, int oldWidth, int oldHeight) {\n            super.onSizeChanged(width, height, oldWidth, oldHeight);\n            updatePath(width, height);\n        }\n\n        @Override\n        protected void onDraw(Canvas canvas) {\n            if (mRadius != 0) {\n                canvas.clipPath(mPath);\n            }\n\n            super.onDraw(canvas);\n\n            int x = getPaddingLeft();\n            int y = getPaddingRight();\n            int width = getWidth() - getPaddingRight() - getPaddingLeft();\n            int height = getHeight() - getPaddingBottom() - getPaddingTop();\n            if (mExtraImageCount != null) {\n                canvas.drawRect(x, y, width, height, mOverlayPaint);\n\n                int xPos = canvas.getWidth() / 2;\n                int yPos = (int) ((canvas.getHeight() / 2.0f)\n                        - ((mTextPaint.descent() + mTextPaint.ascent()) / 2.0f));\n\n                canvas.drawText(mExtraImageCount, xPos, yPos, mTextPaint);\n            }\n\n            canvas.drawRoundRect(x, y, width, height, mRadius, mRadius, mRoundRectPaint);\n        }\n    }\n\n    /**\n     * A helper class to track app's readiness for the scene transition animation.\n     * The app is ready when both the image is laid out and the drawer offset is calculated.\n     */\n    private class EnterTransitionAnimationDelegate implements View.OnLayoutChangeListener {\n        private boolean mPreviewReady = false;\n        private boolean mOffsetCalculated = false;\n\n        void postponeTransition() {\n            postponeEnterTransition();\n        }\n\n        void markImagePreviewReady() {\n            if (!mPreviewReady) {\n                mPreviewReady = true;\n                maybeStartListenForLayout();\n            }\n        }\n\n        void markOffsetCalculated() {\n            if (!mOffsetCalculated) {\n                mOffsetCalculated = true;\n                maybeStartListenForLayout();\n            }\n        }\n\n        private void maybeStartListenForLayout() {\n            if (mPreviewReady && mOffsetCalculated && mResolverDrawerLayout != null) {\n                if (mResolverDrawerLayout.isInLayout()) {\n                    startPostponedEnterTransition();\n                } else {\n                    mResolverDrawerLayout.addOnLayoutChangeListener(this);\n                    mResolverDrawerLayout.requestLayout();\n                }\n            }\n        }\n\n        @Override\n        public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft,\n                int oldTop, int oldRight, int oldBottom) {\n            v.removeOnLayoutChangeListener(this);\n            startPostponedEnterTransition();\n        }\n    }\n\n    @Override\n    protected void maybeLogProfileChange() {\n        getChooserActivityLogger().logShareheetProfileChanged();\n    }\n\n    private boolean shouldNearbyShareBeFirstInRankedRow() {\n        return ActivityManager.isLowRamDeviceStatic() && mIsNearbyShareFirstTargetInRankedApp;\n    }\n\n    private boolean shouldNearbyShareBeIncludedAsActionButton() {\n        return !shouldNearbyShareBeFirstInRankedRow();\n    }\n\n    private boolean hasValidIcon(ChooserTarget target) {\n        Icon icon = target.getIcon();\n        if (icon == null) {\n            return true;\n        }\n        if (icon.getType() == Icon.TYPE_URI || icon.getType() == Icon.TYPE_URI_ADAPTIVE_BITMAP) {\n            Uri uri = icon.getUri();\n            try {\n                getUriGrantsManager().checkGrantUriPermission_ignoreNonSystem(\n                        getLaunchedFromUid(),\n                        getPackageName(),\n                        getUriWithoutUserId(uri),\n                        Intent.FLAG_GRANT_READ_URI_PERMISSION,\n                        getUserIdFromUri(uri)\n                );\n            } catch (SecurityException | RemoteException e) {\n                Log.e(TAG, \"Failed to get URI permission for: \" + uri, e);\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private IUriGrantsManager getUriGrantsManager() {\n        return UriGrantsManager.getService();\n    }\n\n    private static ChooserTarget removeIcon(ChooserTarget target) {\n        if (target == null) {\n            return null;\n        }\n        return new ChooserTarget(\n                target.getTitle(),\n                null,\n                target.getScore(),\n                target.getComponentName(),\n                target.getIntentExtras());\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 32083,
                                        "general": {
                                            "word_based": 12227,
                                            "char_based": 42917
                                        },
                                        "gemini": 38127
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "bad47a2280c7107e1213f4adc5a3825a62698d00",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit bad47a2280c7107e1213f4adc5a3825a62698d00\nAuthor: Andrey Yepin <ayepin@google.com>\nDate:   Mon Dec 9 21:34:17 2024 -0800\n\n    Verify that the caller has permissions for the icons it provided.\n    \n    Bug: 277207798\n    Test: manual testing: first reroduce the issue as described in the\n     ticket then check that it is not reproduceable after the fix.\n    Change-Id: I08992550507572a4878c501184360a58adef53ad\n\ndiff --git a/core/java/com/android/internal/app/ChooserActivity.java b/core/java/com/android/internal/app/ChooserActivity.java\nindex f9d553ffc0c1..ebd015f1c429 100644\n--- a/core/java/com/android/internal/app/ChooserActivity.java\n+++ b/core/java/com/android/internal/app/ChooserActivity.java\n@@ -21,6 +21,7 @@ import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT\n import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT_SHARE_WITH_PERSONAL;\n import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT_SHARE_WITH_WORK;\n import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CROSS_PROFILE_BLOCKED_TITLE;\n+import static android.content.ContentProvider.getUriWithoutUserId;\n import static android.content.ContentProvider.getUserIdFromUri;\n import static android.stats.devicepolicy.DevicePolicyEnums.RESOLVER_EMPTY_STATE_NO_SHARING_TO_PERSONAL;\n import static android.stats.devicepolicy.DevicePolicyEnums.RESOLVER_EMPTY_STATE_NO_SHARING_TO_WORK;\n@@ -40,7 +41,9 @@ import android.annotation.Nullable;\n import android.app.Activity;\n import android.app.ActivityManager;\n import android.app.ActivityOptions;\n+import android.app.IUriGrantsManager;\n import android.app.SharedElementCallback;\n+import android.app.UriGrantsManager;\n import android.app.prediction.AppPredictionContext;\n import android.app.prediction.AppPredictionManager;\n import android.app.prediction.AppPredictor;\n@@ -77,6 +80,7 @@ import android.graphics.Paint;\n import android.graphics.Path;\n import android.graphics.drawable.AnimatedVectorDrawable;\n import android.graphics.drawable.Drawable;\n+import android.graphics.drawable.Icon;\n import android.metrics.LogMaker;\n import android.net.Uri;\n import android.os.AsyncTask;\n@@ -86,6 +90,7 @@ import android.os.Handler;\n import android.os.Message;\n import android.os.Parcelable;\n import android.os.PatternMatcher;\n+import android.os.RemoteException;\n import android.os.ResultReceiver;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -692,7 +697,11 @@ public class ChooserActivity extends ResolverActivity implements\n                     targets = null;\n                     break;\n                 }\n-                targets[i] = (ChooserTarget) pa[i];\n+                ChooserTarget chooserTarget = (ChooserTarget) pa[i];\n+                if (!hasValidIcon(chooserTarget)) {\n+                    chooserTarget = removeIcon(chooserTarget);\n+                }\n+                targets[i] = chooserTarget;\n             }\n             mCallerChooserTargets = targets;\n         }\n@@ -4313,4 +4322,43 @@ public class ChooserActivity extends ResolverActivity implements\n     private boolean shouldNearbyShareBeIncludedAsActionButton() {\n         return !shouldNearbyShareBeFirstInRankedRow();\n     }\n+\n+    private boolean hasValidIcon(ChooserTarget target) {\n+        Icon icon = target.getIcon();\n+        if (icon == null) {\n+            return true;\n+        }\n+        if (icon.getType() == Icon.TYPE_URI || icon.getType() == Icon.TYPE_URI_ADAPTIVE_BITMAP) {\n+            Uri uri = icon.getUri();\n+            try {\n+                getUriGrantsManager().checkGrantUriPermission_ignoreNonSystem(\n+                        getLaunchedFromUid(),\n+                        getPackageName(),\n+                        getUriWithoutUserId(uri),\n+                        Intent.FLAG_GRANT_READ_URI_PERMISSION,\n+                        getUserIdFromUri(uri)\n+                );\n+            } catch (SecurityException | RemoteException e) {\n+                Log.e(TAG, \"Failed to get URI permission for: \" + uri, e);\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private IUriGrantsManager getUriGrantsManager() {\n+        return UriGrantsManager.getService();\n+    }\n+\n+    private static ChooserTarget removeIcon(ChooserTarget target) {\n+        if (target == null) {\n+            return null;\n+        }\n+        return new ChooserTarget(\n+                target.getTitle(),\n+                null,\n+                target.getScore(),\n+                target.getComponentName(),\n+                target.getIntentExtras());\n+    }\n }\n",
                            "downstream_patch_tokens": {
                                "openai": 999,
                                "general": {
                                    "word_based": 420,
                                    "char_based": 1152
                                },
                                "gemini": 1317
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-283101289",
            "aliases": [
                "A-283101289",
                "CVE-2023-40134"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-283101289",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "bf7fbbccd920596e514d1559fb3feaca70e55e78"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From bf7fbbccd920596e514d1559fb3feaca70e55e78 Mon Sep 17 00:00:00 2001\nFrom: Tim Yu <yunicorn@google.com>\nDate: Tue, 20 Jun 2023 21:24:36 +0000\nSubject: [PATCH] [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n\nCheck permissions of URI inside of FillResponse's RemoteViews. If the\ncurrent user does not have the required permissions to view the URI, the\nRemoteView is dropped from displaying.\n\nThis fixes a security spill in which a user can view content of another\nuser through a malicious Autofill provider.\n\nBug: 283137865\nFixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\nb/281534749 b/283101289\nTest: Verified by POC app attached in bugs\nTest: atest CtsAutoFillServiceTestCases (added new tests)\nChange-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n---\n .../com/android/server/autofill/Helper.java   | 43 +++++++++++++++++++\n .../server/autofill/ui/DialogFillUi.java      | 12 ++++--\n .../android/server/autofill/ui/FillUi.java    | 11 +++--\n .../android/server/autofill/ui/SaveUi.java    |  3 +-\n 4 files changed, 60 insertions(+), 9 deletions(-)\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex 82af38200166..ad8f5e1481e1 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -20,6 +20,8 @@ import static com.android.server.autofill.Helper.sDebug;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -40,6 +42,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -50,6 +53,8 @@ import java.lang.ref.WeakReference;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -83,6 +88,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed & permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\nindex dbeb624bd202..fa414e3b172b 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n@@ -53,6 +53,7 @@ import android.widget.TextView;\n \n import com.android.internal.R;\n import com.android.server.autofill.AutofillManagerService;\n+import com.android.server.autofill.Helper;\n \n import java.io.PrintWriter;\n import java.util.ArrayList;\n@@ -208,7 +209,8 @@ final class DialogFillUi {\n     }\n \n     private void setHeader(View decor, FillResponse response) {\n-        final RemoteViews presentation = response.getDialogHeader();\n+        final RemoteViews presentation =\n+                Helper.sanitizeRemoteView(response.getDialogHeader());\n         if (presentation == null) {\n             return;\n         }\n@@ -243,9 +245,10 @@ final class DialogFillUi {\n     }\n \n     private void initialAuthenticationLayout(View decor, FillResponse response) {\n-        RemoteViews presentation = response.getDialogPresentation();\n+        RemoteViews presentation = Helper.sanitizeRemoteView(\n+                response.getDialogPresentation());\n         if (presentation == null) {\n-            presentation = response.getPresentation();\n+            presentation = Helper.sanitizeRemoteView(response.getPresentation());\n         }\n         if (presentation == null) {\n             throw new RuntimeException(\"No presentation for fill dialog authentication\");\n@@ -289,7 +292,8 @@ final class DialogFillUi {\n             final Dataset dataset = response.getDatasets().get(i);\n             final int index = dataset.getFieldIds().indexOf(focusedViewId);\n             if (index >= 0) {\n-                RemoteViews presentation = dataset.getFieldDialogPresentation(index);\n+                RemoteViews presentation = Helper.sanitizeRemoteView(\n+                        dataset.getFieldDialogPresentation(index));\n                 if (presentation == null) {\n                     if (sDebug) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 129ce72e037d..cdfe7bb4f4a7 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -148,8 +148,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -227,6 +228,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -306,7 +310,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex f035d0764279..70382f1d5274 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -384,8 +384,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 2157,
                        "general": {
                            "word_based": 984,
                            "char_based": 2309
                        },
                        "gemini": 2698
                    },
                    "total_downstream_versions_tested": 3,
                    "successful_patches": 1,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "73fa082a7202100da107ae14dd7742ecd86da053",
                            "repo_path": "android_repos/base",
                            "result": "failure",
                            "downstream_patch_content": "commit 73fa082a7202100da107ae14dd7742ecd86da053\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 27ea3d618afa..af6e38b1d46c 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -141,8 +141,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -220,6 +221,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -299,7 +303,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 826a98afe2f8..49df4a8b66ed 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n",
                            "downstream_patch_tokens": {
                                "openai": 1561,
                                "general": {
                                    "word_based": 720,
                                    "char_based": 1666
                                },
                                "gemini": 1960
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
                                    "total_hunks": 0,
                                    "failed_hunks": [],
                                    "inline_merge_conflicts": [],
                                    "rej_file_content": "",
                                    "patch_apply_output": "patching file services/autofill/java/com/android/server/autofill/Helper.java\nHunk #1 succeeded at 18 (offset -2 lines).\nHunk #2 succeeded at 36 (offset -6 lines).\nHunk #3 succeeded at 45 (offset -8 lines).\nHunk #4 succeeded at 80 (offset -8 lines).\ncan't find file to patch at input line 80\nPerhaps you used the wrong -p or --strip option?\nThe text leading up to this was:\n--------------------------\n|diff --git a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n|index dbeb624bd202..fa414e3b172b 100644\n|--- a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n|+++ b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n--------------------------\nFile to patch: \nSkip this patch? [y] \nSkipping patch.\n4 out of 4 hunks ignored\npatching file services/autofill/java/com/android/server/autofill/ui/FillUi.java\nHunk #1 succeeded at 141 (offset -7 lines).\nHunk #2 succeeded at 221 (offset -7 lines).\nHunk #3 succeeded at 303 (offset -7 lines).\npatching file services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nHunk #1 succeeded at 368 (offset -16 lines).",
                                    "inline_merge_output": "",
                                    "reason": "File 'services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java' is missing in downstream repo",
                                    "downstream_file_content": "",
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "f7ca136c514dc975c3f46d95c53fd6b3752c577a",
                            "repo_path": "android_repos/base",
                            "result": "failure",
                            "downstream_patch_content": "commit f7ca136c514dc975c3f46d95c53fd6b3752c577a\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 27ea3d618afa..af6e38b1d46c 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -141,8 +141,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -220,6 +221,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -299,7 +303,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 826a98afe2f8..49df4a8b66ed 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n",
                            "downstream_patch_tokens": {
                                "openai": 1566,
                                "general": {
                                    "word_based": 720,
                                    "char_based": 1666
                                },
                                "gemini": 1963
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
                                    "total_hunks": 0,
                                    "failed_hunks": [],
                                    "inline_merge_conflicts": [],
                                    "rej_file_content": "",
                                    "patch_apply_output": "patching file services/autofill/java/com/android/server/autofill/Helper.java\nHunk #1 succeeded at 18 (offset -2 lines).\nHunk #2 succeeded at 36 (offset -6 lines).\nHunk #3 succeeded at 45 (offset -8 lines).\nHunk #4 succeeded at 80 (offset -8 lines).\ncan't find file to patch at input line 80\nPerhaps you used the wrong -p or --strip option?\nThe text leading up to this was:\n--------------------------\n|diff --git a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n|index dbeb624bd202..fa414e3b172b 100644\n|--- a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n|+++ b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n--------------------------\nFile to patch: \nSkip this patch? [y] \nSkipping patch.\n4 out of 4 hunks ignored\npatching file services/autofill/java/com/android/server/autofill/ui/FillUi.java\nHunk #1 succeeded at 141 (offset -7 lines).\nHunk #2 succeeded at 221 (offset -7 lines).\nHunk #3 succeeded at 303 (offset -7 lines).\npatching file services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nHunk #1 succeeded at 368 (offset -16 lines).",
                                    "inline_merge_output": "",
                                    "reason": "File 'services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java' is missing in downstream repo",
                                    "downstream_file_content": "",
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "93810ba1c0a4d31f49adbf9454731e2b7defdfc0",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 93810ba1c0a4d31f49adbf9454731e2b7defdfc0\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n    Merged-In: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\nindex c2c630e01bee..59184e9ed288 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n@@ -52,6 +52,7 @@ import android.widget.TextView;\n \n import com.android.internal.R;\n import com.android.server.autofill.AutofillManagerService;\n+import com.android.server.autofill.Helper;\n \n import java.io.PrintWriter;\n import java.util.ArrayList;\n@@ -197,7 +198,8 @@ final class DialogFillUi {\n     }\n \n     private void setHeader(View decor, FillResponse response) {\n-        final RemoteViews presentation = response.getDialogHeader();\n+        final RemoteViews presentation =\n+                Helper.sanitizeRemoteView(response.getDialogHeader());\n         if (presentation == null) {\n             return;\n         }\n@@ -232,9 +234,10 @@ final class DialogFillUi {\n     }\n \n     private void initialAuthenticationLayout(View decor, FillResponse response) {\n-        RemoteViews presentation = response.getDialogPresentation();\n+        RemoteViews presentation = Helper.sanitizeRemoteView(\n+                response.getDialogPresentation());\n         if (presentation == null) {\n-            presentation = response.getPresentation();\n+            presentation = Helper.sanitizeRemoteView(response.getPresentation());\n         }\n         if (presentation == null) {\n             throw new RuntimeException(\"No presentation for fill dialog authentication\");\n@@ -278,7 +281,8 @@ final class DialogFillUi {\n             final Dataset dataset = response.getDatasets().get(i);\n             final int index = dataset.getFieldIds().indexOf(focusedViewId);\n             if (index >= 0) {\n-                RemoteViews presentation = dataset.getFieldDialogPresentation(index);\n+                RemoteViews presentation = Helper.sanitizeRemoteView(\n+                        dataset.getFieldDialogPresentation(index));\n                 if (presentation == null) {\n                     if (sDebug) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 8fbdd81cc4cc..76fa258734cc 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -144,8 +144,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -223,6 +224,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -302,7 +306,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 677871f6c85f..533a7b69a650 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n",
                            "downstream_patch_tokens": {
                                "openai": 2075,
                                "general": {
                                    "word_based": 934,
                                    "char_based": 2241
                                },
                                "gemini": 2599
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-370840874",
            "aliases": [
                "A-370840874",
                "CVE-2024-49738"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-370840874",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "c54dad65317f851ce9d016bd90ec6a7a04da09fc"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From c54dad65317f851ce9d016bd90ec6a7a04da09fc Mon Sep 17 00:00:00 2001\nFrom: Steven Moreland <smoreland@google.com>\nDate: Wed, 2 Oct 2024 00:37:59 +0000\nSubject: [PATCH] libbinder: Parcel: validate read data before write\n\nThis is slow, but it's required to prevent memory\ncorruption.\n\nIgnore-AOSP-First: security\nBug: 370840874\nTest: fuzzer\nChange-Id: Ibc5566ade0389221690dc90324f93394cf7fc9a5\n---\n libs/binder/Parcel.cpp | 12 ++++++++++++\n 1 file changed, 12 insertions(+)\n\ndiff --git a/libs/binder/Parcel.cpp b/libs/binder/Parcel.cpp\nindex 3d36f2eed7..d346ad15d2 100644\n--- a/libs/binder/Parcel.cpp\n+++ b/libs/binder/Parcel.cpp\n@@ -1211,6 +1211,10 @@ restart_write:\n         //printf(\"Writing %ld bytes, padded to %ld\\n\", len, padded);\n         uint8_t* const data = mData+mDataPos;\n \n+        if (status_t status = validateReadData(mDataPos + padded); status != OK) {\n+            return nullptr; // drops status\n+        }\n+\n         // Need to pad at end?\n         if (padded != len) {\n #if BYTE_ORDER == BIG_ENDIAN\n@@ -1799,6 +1803,10 @@ status_t Parcel::writeObject(const flat_binder_object& val, bool nullMetaData)\n     const bool enoughObjects = kernelFields->mObjectsSize < kernelFields->mObjectsCapacity;\n     if (enoughData && enoughObjects) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         *reinterpret_cast<flat_binder_object*>(mData+mDataPos) = val;\n \n         // remember if it's a file descriptor\n@@ -2042,6 +2050,10 @@ status_t Parcel::writeAligned(T val) {\n \n     if ((mDataPos+sizeof(val)) <= mDataCapacity) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         memcpy(mData + mDataPos, &val, sizeof(val));\n         return finishWrite(sizeof(val));\n     }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 572,
                        "general": {
                            "word_based": 222,
                            "char_based": 478
                        },
                        "gemini": 708
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 2,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "2aec032c0826ad68cd94c100173b99167bfcb10d",
                            "repo_path": "android_repos/native",
                            "result": "failure",
                            "downstream_patch_content": "commit 2aec032c0826ad68cd94c100173b99167bfcb10d\nAuthor: Steven Moreland <smoreland@google.com>\nDate:   Wed Oct 2 00:37:59 2024 +0000\n\n    libbinder: Parcel: validate read data before write\n    \n    This is slow, but it's required to prevent memory\n    corruption.\n    \n    Ignore-AOSP-First: security\n    Bug: 370840874\n    Test: fuzzer\n    Merged-In: Ibc5566ade0389221690dc90324f93394cf7fc9a5\n    Change-Id: Ibc5566ade0389221690dc90324f93394cf7fc9a5\n    (cherry picked from commit c54dad65317f851ce9d016bd90ec6a7a04da09fc)\n\ndiff --git a/libs/binder/Parcel.cpp b/libs/binder/Parcel.cpp\nindex 617708f3d4..0670307e48 100644\n--- a/libs/binder/Parcel.cpp\n+++ b/libs/binder/Parcel.cpp\n@@ -796,6 +796,10 @@ restart_write:\n         //printf(\"Writing %ld bytes, padded to %ld\\n\", len, padded);\n         uint8_t* const data = mData+mDataPos;\n \n+        if (status_t status = validateReadData(mDataPos + padded); status != OK) {\n+            return nullptr; // drops status\n+        }\n+\n         // Need to pad at end?\n         if (padded != len) {\n #if BYTE_ORDER == BIG_ENDIAN\n@@ -1313,6 +1317,10 @@ status_t Parcel::writeObject(const flat_binder_object& val, bool nullMetaData)\n     const bool enoughObjects = mObjectsSize < mObjectsCapacity;\n     if (enoughData && enoughObjects) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         *reinterpret_cast<flat_binder_object*>(mData+mDataPos) = val;\n \n         // remember if it's a file descriptor\n@@ -1505,6 +1513,10 @@ status_t Parcel::writeAligned(T val) {\n \n     if ((mDataPos+sizeof(val)) <= mDataCapacity) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         *reinterpret_cast<T*>(mData+mDataPos) = val;\n         return finishWrite(sizeof(val));\n     }\n",
                            "downstream_patch_tokens": {
                                "openai": 570,
                                "general": {
                                    "word_based": 202,
                                    "char_based": 476
                                },
                                "gemini": 730
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "libs/binder/Parcel.cpp",
                                    "total_hunks": 3,
                                    "failed_hunks": [
                                        3
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12)\n\n=======\n    if ((mDataPos+sizeof(val)) <= mDataCapacity) {\nrestart_write:\n        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n            return status;\n        }\n\n>>>>>>> UPSTREAM PATCH (commit c54dad65317f851ce9d016bd90ec6a7a04da09fc)",
                                            "merge_conflict_tokens": {
                                                "openai": 84,
                                                "general": {
                                                    "word_based": 24,
                                                    "char_based": 76
                                                },
                                                "gemini": 106
                                            }
                                        }
                                    ],
                                    "inline_merge_token_summary": {
                                        "gemini": 2968,
                                        "openai": 2436,
                                        "general_word": 696,
                                        "general_char": 2204
                                    },
                                    "rej_file_content": "```diff\n--- libs/binder/Parcel.cpp\n+++ libs/binder/Parcel.cpp\n@@ -2050,6 +2058,10 @@ status_t Parcel::writeAligned(T val) {\n \n     if ((mDataPos+sizeof(val)) <= mDataCapacity) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         memcpy(mData + mDataPos, &val, sizeof(val));\n         return finishWrite(sizeof(val));\n     }\n```",
                                    "rej_file_tokens": {
                                        "openai": 112,
                                        "general": {
                                            "word_based": 44,
                                            "char_based": 104
                                        },
                                        "gemini": 138
                                    },
                                    "patch_apply_output": "patching file libs/binder/Parcel.cpp\nHunk #1 succeeded at 796 (offset -415 lines).\nHunk #2 succeeded at 1317 with fuzz 1 (offset -486 lines).\nHunk #3 FAILED at 2050.\n1 out of 3 hunks FAILED -- saving rejects to file libs/binder/Parcel.cpp.rej",
                                    "inline_merge_output": "patching file libs/binder/Parcel.cpp\nHunk #1 merged at 1218-1221.\nHunk #2 already applied at 1810-1813.\nHunk #3 NOT MERGED at 2061-2069.",
                                    "upstream_file_tokens": {
                                        "openai": 27268,
                                        "general": {
                                            "word_based": 10691,
                                            "char_based": 27877
                                        },
                                        "gemini": 32942
                                    },
                                    "downstream_file_content": "```cpp\n/*\n * Copyright (C) 2005 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"Parcel\"\n//#define LOG_NDEBUG 0\n\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <linux/sched.h>\n#include <pthread.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <unistd.h>\n\n#include <binder/Binder.h>\n#include <binder/BpBinder.h>\n#include <binder/IPCThreadState.h>\n#include <binder/Parcel.h>\n#include <binder/ProcessState.h>\n#include <binder/Stability.h>\n#include <binder/Status.h>\n#include <binder/TextOutput.h>\n\n#include <cutils/ashmem.h>\n#include <cutils/compiler.h>\n#include <utils/Flattenable.h>\n#include <utils/Log.h>\n#include <utils/String16.h>\n#include <utils/String8.h>\n#include <utils/misc.h>\n\n#include \"RpcState.h\"\n#include \"Static.h\"\n#include \"Utils.h\"\n#include \"binder_module.h\"\n\n#define LOG_REFS(...)\n//#define LOG_REFS(...) ALOG(LOG_DEBUG, LOG_TAG, __VA_ARGS__)\n#define LOG_ALLOC(...)\n//#define LOG_ALLOC(...) ALOG(LOG_DEBUG, LOG_TAG, __VA_ARGS__)\n\n// ---------------------------------------------------------------------------\n\n// This macro should never be used at runtime, as a too large value\n// of s could cause an integer overflow. Instead, you should always\n// use the wrapper function pad_size()\n#define PAD_SIZE_UNSAFE(s) (((s)+3)&~3)\n\nstatic size_t pad_size(size_t s) {\n    if (s > (std::numeric_limits<size_t>::max() - 3)) {\n        LOG_ALWAYS_FATAL(\"pad size too big %zu\", s);\n    }\n    return PAD_SIZE_UNSAFE(s);\n}\n\n// Note: must be kept in sync with android/os/StrictMode.java's PENALTY_GATHER\n#define STRICT_MODE_PENALTY_GATHER (1 << 31)\n\nnamespace android {\n\n// many things compile this into prebuilts on the stack\n#ifdef __LP64__\nstatic_assert(sizeof(Parcel) == 120);\n#else\nstatic_assert(sizeof(Parcel) == 60);\n#endif\n\nstatic std::atomic<size_t> gParcelGlobalAllocCount;\nstatic std::atomic<size_t> gParcelGlobalAllocSize;\n\nstatic size_t gMaxFds = 0;\n\n// Maximum size of a blob to transfer in-place.\nstatic const size_t BLOB_INPLACE_LIMIT = 16 * 1024;\n\nenum {\n    BLOB_INPLACE = 0,\n    BLOB_ASHMEM_IMMUTABLE = 1,\n    BLOB_ASHMEM_MUTABLE = 2,\n};\n\nstatic void acquire_object(const sp<ProcessState>& proc,\n    const flat_binder_object& obj, const void* who, size_t* outAshmemSize)\n{\n    switch (obj.hdr.type) {\n        case BINDER_TYPE_BINDER:\n            if (obj.binder) {\n                LOG_REFS(\"Parcel %p acquiring reference on local %p\", who, obj.cookie);\n                reinterpret_cast<IBinder*>(obj.cookie)->incStrong(who);\n            }\n            return;\n        case BINDER_TYPE_HANDLE: {\n            const sp<IBinder> b = proc->getStrongProxyForHandle(obj.handle);\n            if (b != nullptr) {\n                LOG_REFS(\"Parcel %p acquiring reference on remote %p\", who, b.get());\n                b->incStrong(who);\n            }\n            return;\n        }\n        case BINDER_TYPE_FD: {\n            if ((obj.cookie != 0) && (outAshmemSize != nullptr) && ashmem_valid(obj.handle)) {\n                // If we own an ashmem fd, keep track of how much memory it refers to.\n                int size = ashmem_get_size_region(obj.handle);\n                if (size > 0) {\n                    *outAshmemSize += size;\n                }\n            }\n            return;\n        }\n    }\n\n    ALOGD(\"Invalid object type 0x%08x\", obj.hdr.type);\n}\n\nstatic void release_object(const sp<ProcessState>& proc,\n    const flat_binder_object& obj, const void* who, size_t* outAshmemSize)\n{\n    switch (obj.hdr.type) {\n        case BINDER_TYPE_BINDER:\n            if (obj.binder) {\n                LOG_REFS(\"Parcel %p releasing reference on local %p\", who, obj.cookie);\n                reinterpret_cast<IBinder*>(obj.cookie)->decStrong(who);\n            }\n            return;\n        case BINDER_TYPE_HANDLE: {\n            const sp<IBinder> b = proc->getStrongProxyForHandle(obj.handle);\n            if (b != nullptr) {\n                LOG_REFS(\"Parcel %p releasing reference on remote %p\", who, b.get());\n                b->decStrong(who);\n            }\n            return;\n        }\n        case BINDER_TYPE_FD: {\n            if (obj.cookie != 0) { // owned\n                if ((outAshmemSize != nullptr) && ashmem_valid(obj.handle)) {\n                    int size = ashmem_get_size_region(obj.handle);\n                    if (size > 0) {\n                        // ashmem size might have changed since last time it was accounted for, e.g.\n                        // in acquire_object(). Value of *outAshmemSize is not critical since we are\n                        // releasing the object anyway. Check for integer overflow condition.\n                        *outAshmemSize -= std::min(*outAshmemSize, static_cast<size_t>(size));\n                    }\n                }\n\n                close(obj.handle);\n            }\n            return;\n        }\n    }\n\n    ALOGE(\"Invalid object type 0x%08x\", obj.hdr.type);\n}\n\nstatus_t Parcel::finishFlattenBinder(const sp<IBinder>& binder)\n{\n    internal::Stability::tryMarkCompilationUnit(binder.get());\n    auto category = internal::Stability::getCategory(binder.get());\n    return writeInt32(category.repr());\n}\n\nstatus_t Parcel::finishUnflattenBinder(\n    const sp<IBinder>& binder, sp<IBinder>* out) const\n{\n    int32_t stability;\n    status_t status = readInt32(&stability);\n    if (status != OK) return status;\n\n    status = internal::Stability::setRepr(binder.get(), stability, true /*log*/);\n    if (status != OK) return status;\n\n    *out = binder;\n    return OK;\n}\n\nstatic constexpr inline int schedPolicyMask(int policy, int priority) {\n    return (priority & FLAT_BINDER_FLAG_PRIORITY_MASK) | ((policy & 3) << FLAT_BINDER_FLAG_SCHED_POLICY_SHIFT);\n}\n\nstatus_t Parcel::flattenBinder(const sp<IBinder>& binder)\n{\n    if (isForRpc()) {\n        if (binder) {\n            status_t status = writeInt32(1); // non-null\n            if (status != OK) return status;\n            RpcAddress address = RpcAddress::zero();\n            status = mSession->state()->onBinderLeaving(mSession, binder, &address);\n            if (status != OK) return status;\n            status = address.writeToParcel(this);\n            if (status != OK) return status;\n        } else {\n            status_t status = writeInt32(0); // null\n            if (status != OK) return status;\n        }\n        return finishFlattenBinder(binder);\n    }\n\n    flat_binder_object obj;\n    obj.flags = FLAT_BINDER_FLAG_ACCEPTS_FDS;\n\n    int schedBits = 0;\n    if (!IPCThreadState::self()->backgroundSchedulingDisabled()) {\n        schedBits = schedPolicyMask(SCHED_NORMAL, 19);\n    }\n\n    if (binder != nullptr) {\n        BBinder *local = binder->localBinder();\n        if (!local) {\n            BpBinder *proxy = binder->remoteBinder();\n            if (proxy == nullptr) {\n                ALOGE(\"null proxy\");\n            } else {\n                if (proxy->isRpcBinder()) {\n                    ALOGE(\"Sending a socket binder over RPC is prohibited\");\n                    return INVALID_OPERATION;\n                }\n            }\n            const int32_t handle = proxy ? proxy->getPrivateAccessorForId().binderHandle() : 0;\n            obj.hdr.type = BINDER_TYPE_HANDLE;\n            obj.binder = 0; /* Don't pass uninitialized stack data to a remote process */\n            obj.handle = handle;\n            obj.cookie = 0;\n        } else {\n            int policy = local->getMinSchedulerPolicy();\n            int priority = local->getMinSchedulerPriority();\n\n            if (policy != 0 || priority != 0) {\n                // override value, since it is set explicitly\n                schedBits = schedPolicyMask(policy, priority);\n            }\n            if (local->isRequestingSid()) {\n                obj.flags |= FLAT_BINDER_FLAG_TXN_SECURITY_CTX;\n            }\n            if (local->isInheritRt()) {\n                obj.flags |= FLAT_BINDER_FLAG_INHERIT_RT;\n            }\n            obj.hdr.type = BINDER_TYPE_BINDER;\n            obj.binder = reinterpret_cast<uintptr_t>(local->getWeakRefs());\n            obj.cookie = reinterpret_cast<uintptr_t>(local);\n        }\n    } else {\n        obj.hdr.type = BINDER_TYPE_BINDER;\n        obj.binder = 0;\n        obj.cookie = 0;\n    }\n\n    obj.flags |= schedBits;\n\n    status_t status = writeObject(obj, false);\n    if (status != OK) return status;\n\n    return finishFlattenBinder(binder);\n}\n\nstatus_t Parcel::unflattenBinder(sp<IBinder>* out) const\n{\n    if (isForRpc()) {\n        LOG_ALWAYS_FATAL_IF(mSession == nullptr, \"RpcSession required to read from remote parcel\");\n\n        int32_t isNull;\n        status_t status = readInt32(&isNull);\n        if (status != OK) return status;\n\n        sp<IBinder> binder;\n\n        if (isNull & 1) {\n            auto addr = RpcAddress::zero();\n            status_t status = addr.readFromParcel(*this);\n            if (status != OK) return status;\n            binder = mSession->state()->onBinderEntering(mSession, addr);\n        }\n\n        return finishUnflattenBinder(binder, out);\n    }\n\n    const flat_binder_object* flat = readObject(false);\n\n    if (flat) {\n        switch (flat->hdr.type) {\n            case BINDER_TYPE_BINDER: {\n                sp<IBinder> binder =\n                        sp<IBinder>::fromExisting(reinterpret_cast<IBinder*>(flat->cookie));\n                return finishUnflattenBinder(binder, out);\n            }\n            case BINDER_TYPE_HANDLE: {\n                sp<IBinder> binder =\n                    ProcessState::self()->getStrongProxyForHandle(flat->handle);\n                return finishUnflattenBinder(binder, out);\n            }\n        }\n    }\n    return BAD_TYPE;\n}\n\n// ---------------------------------------------------------------------------\n\nParcel::Parcel()\n{\n    LOG_ALLOC(\"Parcel %p: constructing\", this);\n    initState();\n}\n\nParcel::~Parcel()\n{\n    freeDataNoInit();\n    LOG_ALLOC(\"Parcel %p: destroyed\", this);\n}\n\nsize_t Parcel::getGlobalAllocSize() {\n    return gParcelGlobalAllocSize.load();\n}\n\nsize_t Parcel::getGlobalAllocCount() {\n    return gParcelGlobalAllocCount.load();\n}\n\nconst uint8_t* Parcel::data() const\n{\n    return mData;\n}\n\nsize_t Parcel::dataSize() const\n{\n    return (mDataSize > mDataPos ? mDataSize : mDataPos);\n}\n\nsize_t Parcel::dataAvail() const\n{\n    size_t result = dataSize() - dataPosition();\n    if (result > INT32_MAX) {\n        LOG_ALWAYS_FATAL(\"result too big: %zu\", result);\n    }\n    return result;\n}\n\nsize_t Parcel::dataPosition() const\n{\n    return mDataPos;\n}\n\nsize_t Parcel::dataCapacity() const\n{\n    return mDataCapacity;\n}\n\nstatus_t Parcel::setDataSize(size_t size)\n{\n    if (size > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    status_t err;\n    err = continueWrite(size);\n    if (err == NO_ERROR) {\n        mDataSize = size;\n        ALOGV(\"setDataSize Setting data size of %p to %zu\", this, mDataSize);\n    }\n    return err;\n}\n\nvoid Parcel::setDataPosition(size_t pos) const\n{\n    if (pos > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        LOG_ALWAYS_FATAL(\"pos too big: %zu\", pos);\n    }\n\n    mDataPos = pos;\n    mNextObjectHint = 0;\n    mObjectsSorted = false;\n}\n\nstatus_t Parcel::setDataCapacity(size_t size)\n{\n    if (size > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    if (size > mDataCapacity) return continueWrite(size);\n    return NO_ERROR;\n}\n\nstatus_t Parcel::setData(const uint8_t* buffer, size_t len)\n{\n    if (len > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    status_t err = restartWrite(len);\n    if (err == NO_ERROR) {\n        memcpy(const_cast<uint8_t*>(data()), buffer, len);\n        mDataSize = len;\n        mFdsKnown = false;\n    }\n    return err;\n}\n\nstatus_t Parcel::appendFrom(const Parcel *parcel, size_t offset, size_t len)\n{\n    if (parcel->isForRpc() != isForRpc()) {\n        ALOGE(\"Cannot append Parcel of one format to another.\");\n        return BAD_TYPE;\n    }\n\n    status_t err;\n    const uint8_t *data = parcel->mData;\n    const binder_size_t *objects = parcel->mObjects;\n    size_t size = parcel->mObjectsSize;\n    int startPos = mDataPos;\n    int firstIndex = -1, lastIndex = -2;\n\n    if (len == 0) {\n        return NO_ERROR;\n    }\n\n    if (len > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    // range checks against the source parcel size\n    if ((offset > parcel->mDataSize)\n            || (len > parcel->mDataSize)\n            || (offset + len > parcel->mDataSize)) {\n        return BAD_VALUE;\n    }\n\n    // Count objects in range\n    for (int i = 0; i < (int) size; i++) {\n        size_t off = objects[i];\n        if ((off >= offset) && (off + sizeof(flat_binder_object) <= offset + len)) {\n            if (firstIndex == -1) {\n                firstIndex = i;\n            }\n            lastIndex = i;\n        }\n    }\n    int numObjects = lastIndex - firstIndex + 1;\n\n    if ((mDataSize+len) > mDataCapacity) {\n        // grow data\n        err = growData(len);\n        if (err != NO_ERROR) {\n            return err;\n        }\n    }\n\n    // append data\n    memcpy(mData + mDataPos, data + offset, len);\n    mDataPos += len;\n    mDataSize += len;\n\n    err = NO_ERROR;\n\n    if (numObjects > 0) {\n        const sp<ProcessState> proc(ProcessState::self());\n        // grow objects\n        if (mObjectsCapacity < mObjectsSize + numObjects) {\n            if ((size_t) numObjects > SIZE_MAX - mObjectsSize) return NO_MEMORY; // overflow\n            if (mObjectsSize + numObjects > SIZE_MAX / 3) return NO_MEMORY; // overflow\n            size_t newSize = ((mObjectsSize + numObjects)*3)/2;\n            if (newSize > SIZE_MAX / sizeof(binder_size_t)) return NO_MEMORY; // overflow\n            binder_size_t *objects =\n                (binder_size_t*)realloc(mObjects, newSize*sizeof(binder_size_t));\n            if (objects == (binder_size_t*)nullptr) {\n                return NO_MEMORY;\n            }\n            mObjects = objects;\n            mObjectsCapacity = newSize;\n        }\n\n        // append and acquire objects\n        int idx = mObjectsSize;\n        for (int i = firstIndex; i <= lastIndex; i++) {\n            size_t off = objects[i] - offset + startPos;\n            mObjects[idx++] = off;\n            mObjectsSize++;\n\n            flat_binder_object* flat\n                = reinterpret_cast<flat_binder_object*>(mData + off);\n            acquire_object(proc, *flat, this, &mOpenAshmemSize);\n\n            if (flat->hdr.type == BINDER_TYPE_FD) {\n                // If this is a file descriptor, we need to dup it so the\n                // new Parcel now owns its own fd, and can declare that we\n                // officially know we have fds.\n                flat->handle = fcntl(flat->handle, F_DUPFD_CLOEXEC, 0);\n                flat->cookie = 1;\n                mHasFds = mFdsKnown = true;\n                if (!mAllowFds) {\n                    err = FDS_NOT_ALLOWED;\n                }\n            }\n        }\n    }\n\n    return err;\n}\n\nint Parcel::compareData(const Parcel& other) {\n    size_t size = dataSize();\n    if (size != other.dataSize()) {\n        return size < other.dataSize() ? -1 : 1;\n    }\n    return memcmp(data(), other.data(), size);\n}\n\nbool Parcel::allowFds() const\n{\n    return mAllowFds;\n}\n\nbool Parcel::pushAllowFds(bool allowFds)\n{\n    const bool origValue = mAllowFds;\n    if (!allowFds) {\n        mAllowFds = false;\n    }\n    return origValue;\n}\n\nvoid Parcel::restoreAllowFds(bool lastValue)\n{\n    mAllowFds = lastValue;\n}\n\nbool Parcel::hasFileDescriptors() const\n{\n    if (!mFdsKnown) {\n        scanForFds();\n    }\n    return mHasFds;\n}\n\nvoid Parcel::markSensitive() const\n{\n    mDeallocZero = true;\n}\n\nvoid Parcel::markForBinder(const sp<IBinder>& binder) {\n    LOG_ALWAYS_FATAL_IF(mData != nullptr, \"format must be set before data is written\");\n\n    if (binder && binder->remoteBinder() && binder->remoteBinder()->isRpcBinder()) {\n        markForRpc(binder->remoteBinder()->getPrivateAccessorForId().rpcSession());\n    }\n}\n\nvoid Parcel::markForRpc(const sp<RpcSession>& session) {\n    LOG_ALWAYS_FATAL_IF(mData != nullptr && mOwner == nullptr,\n                        \"format must be set before data is written OR on IPC data\");\n\n    LOG_ALWAYS_FATAL_IF(session == nullptr, \"markForRpc requires session\");\n    mSession = session;\n}\n\nbool Parcel::isForRpc() const {\n    return mSession != nullptr;\n}\n\nvoid Parcel::updateWorkSourceRequestHeaderPosition() const {\n    // Only update the request headers once. We only want to point\n    // to the first headers read/written.\n    if (!mRequestHeaderPresent) {\n        mWorkSourceRequestHeaderPosition = dataPosition();\n        mRequestHeaderPresent = true;\n    }\n}\n\n#if defined(__ANDROID_VNDK__)\nconstexpr int32_t kHeader = B_PACK_CHARS('V', 'N', 'D', 'R');\n#else\nconstexpr int32_t kHeader = B_PACK_CHARS('S', 'Y', 'S', 'T');\n#endif\n\n// Write RPC headers.  (previously just the interface token)\nstatus_t Parcel::writeInterfaceToken(const String16& interface)\n{\n    return writeInterfaceToken(interface.string(), interface.size());\n}\n\nstatus_t Parcel::writeInterfaceToken(const char16_t* str, size_t len) {\n    if (CC_LIKELY(!isForRpc())) {\n        const IPCThreadState* threadState = IPCThreadState::self();\n        writeInt32(threadState->getStrictModePolicy() | STRICT_MODE_PENALTY_GATHER);\n        updateWorkSourceRequestHeaderPosition();\n        writeInt32(threadState->shouldPropagateWorkSource() ? threadState->getCallingWorkSourceUid()\n                                                            : IPCThreadState::kUnsetWorkSource);\n        writeInt32(kHeader);\n    }\n\n    // currently the interface identification token is just its name as a string\n    return writeString16(str, len);\n}\n\nbool Parcel::replaceCallingWorkSourceUid(uid_t uid)\n{\n    if (!mRequestHeaderPresent) {\n        return false;\n    }\n\n    const size_t initialPosition = dataPosition();\n    setDataPosition(mWorkSourceRequestHeaderPosition);\n    status_t err = writeInt32(uid);\n    setDataPosition(initialPosition);\n    return err == NO_ERROR;\n}\n\nuid_t Parcel::readCallingWorkSourceUid() const\n{\n    if (!mRequestHeaderPresent) {\n        return IPCThreadState::kUnsetWorkSource;\n    }\n\n    const size_t initialPosition = dataPosition();\n    setDataPosition(mWorkSourceRequestHeaderPosition);\n    uid_t uid = readInt32();\n    setDataPosition(initialPosition);\n    return uid;\n}\n\nbool Parcel::checkInterface(IBinder* binder) const\n{\n    return enforceInterface(binder->getInterfaceDescriptor());\n}\n\nbool Parcel::enforceInterface(const String16& interface,\n                              IPCThreadState* threadState) const\n{\n    return enforceInterface(interface.string(), interface.size(), threadState);\n}\n\nbool Parcel::enforceInterface(const char16_t* interface,\n                              size_t len,\n                              IPCThreadState* threadState) const\n{\n    if (CC_LIKELY(!isForRpc())) {\n        // StrictModePolicy.\n        int32_t strictPolicy = readInt32();\n        if (threadState == nullptr) {\n            threadState = IPCThreadState::self();\n        }\n        if ((threadState->getLastTransactionBinderFlags() & IBinder::FLAG_ONEWAY) != 0) {\n            // For one-way calls, the callee is running entirely\n            // disconnected from the caller, so disable StrictMode entirely.\n            // Not only does disk/network usage not impact the caller, but\n            // there's no way to communicate back violations anyway.\n            threadState->setStrictModePolicy(0);\n        } else {\n            threadState->setStrictModePolicy(strictPolicy);\n        }\n        // WorkSource.\n        updateWorkSourceRequestHeaderPosition();\n        int32_t workSource = readInt32();\n        threadState->setCallingWorkSourceUidWithoutPropagation(workSource);\n        // vendor header\n        int32_t header = readInt32();\n        if (header != kHeader) {\n            ALOGE(\"Expecting header 0x%x but found 0x%x. Mixing copies of libbinder?\", kHeader,\n                  header);\n            return false;\n        }\n    }\n\n    // Interface descriptor.\n    size_t parcel_interface_len;\n    const char16_t* parcel_interface = readString16Inplace(&parcel_interface_len);\n    if (len == parcel_interface_len &&\n            (!len || !memcmp(parcel_interface, interface, len * sizeof (char16_t)))) {\n        return true;\n    } else {\n        ALOGW(\"**** enforceInterface() expected '%s' but read '%s'\",\n              String8(interface, len).string(),\n              String8(parcel_interface, parcel_interface_len).string());\n        return false;\n    }\n}\n\nsize_t Parcel::objectsCount() const\n{\n    return mObjectsSize;\n}\n\nstatus_t Parcel::errorCheck() const\n{\n    return mError;\n}\n\nvoid Parcel::setError(status_t err)\n{\n    mError = err;\n}\n\nstatus_t Parcel::finishWrite(size_t len)\n{\n    if (len > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    //printf(\"Finish write of %d\\n\", len);\n    mDataPos += len;\n    ALOGV(\"finishWrite Setting data pos of %p to %zu\", this, mDataPos);\n    if (mDataPos > mDataSize) {\n        mDataSize = mDataPos;\n        ALOGV(\"finishWrite Setting data size of %p to %zu\", this, mDataSize);\n    }\n    //printf(\"New pos=%d, size=%d\\n\", mDataPos, mDataSize);\n    return NO_ERROR;\n}\n\nstatus_t Parcel::writeUnpadded(const void* data, size_t len)\n{\n    if (len > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    size_t end = mDataPos + len;\n    if (end < mDataPos) {\n        // integer overflow\n        return BAD_VALUE;\n    }\n\n    if (end <= mDataCapacity) {\nrestart_write:\n        memcpy(mData+mDataPos, data, len);\n        return finishWrite(len);\n    }\n\n    status_t err = growData(len);\n    if (err == NO_ERROR) goto restart_write;\n    return err;\n}\n\nstatus_t Parcel::write(const void* data, size_t len)\n{\n    if (len > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    void* const d = writeInplace(len);\n    if (d) {\n        memcpy(d, data, len);\n        return NO_ERROR;\n    }\n    return mError;\n}\n\nvoid* Parcel::writeInplace(size_t len)\n{\n    if (len > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return nullptr;\n    }\n\n    const size_t padded = pad_size(len);\n\n    // sanity check for integer overflow\n    if (mDataPos+padded < mDataPos) {\n        return nullptr;\n    }\n\n    if ((mDataPos+padded) <= mDataCapacity) {\nrestart_write:\n        //printf(\"Writing %ld bytes, padded to %ld\\n\", len, padded);\n        uint8_t* const data = mData+mDataPos;\n\n        if (status_t status = validateReadData(mDataPos + padded); status != OK) {\n            return nullptr; // drops status\n        }\n\n        // Need to pad at end?\n        if (padded != len) {\n#if BYTE_ORDER == BIG_ENDIAN\n            static const uint32_t mask[4] = {\n                0x00000000, 0xffffff00, 0xffff0000, 0xff000000\n            };\n#endif\n#if BYTE_ORDER == LITTLE_ENDIAN\n            static const uint32_t mask[4] = {\n                0x00000000, 0x00ffffff, 0x0000ffff, 0x000000ff\n            };\n#endif\n            //printf(\"Applying pad mask: %p to %p\\n\", (void*)mask[padded-len],\n            //    *reinterpret_cast<void**>(data+padded-4));\n            *reinterpret_cast<uint32_t*>(data+padded-4) &= mask[padded-len];\n        }\n\n        finishWrite(padded);\n        return data;\n    }\n\n    status_t err = growData(padded);\n    if (err == NO_ERROR) goto restart_write;\n    return nullptr;\n}\n\nstatus_t Parcel::writeUtf8AsUtf16(const std::string& str) {\n    const uint8_t* strData = (uint8_t*)str.data();\n    const size_t strLen= str.length();\n    const ssize_t utf16Len = utf8_to_utf16_length(strData, strLen);\n    if (utf16Len < 0 || utf16Len > std::numeric_limits<int32_t>::max()) {\n        return BAD_VALUE;\n    }\n\n    status_t err = writeInt32(utf16Len);\n    if (err) {\n        return err;\n    }\n\n    // Allocate enough bytes to hold our converted string and its terminating NULL.\n    void* dst = writeInplace((utf16Len + 1) * sizeof(char16_t));\n    if (!dst) {\n        return NO_MEMORY;\n    }\n\n    utf8_to_utf16(strData, strLen, (char16_t*)dst, (size_t) utf16Len + 1);\n\n    return NO_ERROR;\n}\n\n\nstatus_t Parcel::writeUtf8AsUtf16(const std::optional<std::string>& str) { return writeData(str); }\nstatus_t Parcel::writeUtf8AsUtf16(const std::unique_ptr<std::string>& str) { return writeData(str); }\n\nstatus_t Parcel::writeString16(const std::optional<String16>& str) { return writeData(str); }\nstatus_t Parcel::writeString16(const std::unique_ptr<String16>& str) { return writeData(str); }\n\nstatus_t Parcel::writeByteVector(const std::vector<int8_t>& val) { return writeData(val); }\nstatus_t Parcel::writeByteVector(const std::optional<std::vector<int8_t>>& val) { return writeData(val); }\nstatus_t Parcel::writeByteVector(const std::unique_ptr<std::vector<int8_t>>& val) { return writeData(val); }\nstatus_t Parcel::writeByteVector(const std::vector<uint8_t>& val) { return writeData(val); }\nstatus_t Parcel::writeByteVector(const std::optional<std::vector<uint8_t>>& val) { return writeData(val); }\nstatus_t Parcel::writeByteVector(const std::unique_ptr<std::vector<uint8_t>>& val){ return writeData(val); }\nstatus_t Parcel::writeInt32Vector(const std::vector<int32_t>& val) { return writeData(val); }\nstatus_t Parcel::writeInt32Vector(const std::optional<std::vector<int32_t>>& val) { return writeData(val); }\nstatus_t Parcel::writeInt32Vector(const std::unique_ptr<std::vector<int32_t>>& val) { return writeData(val); }\nstatus_t Parcel::writeInt64Vector(const std::vector<int64_t>& val) { return writeData(val); }\nstatus_t Parcel::writeInt64Vector(const std::optional<std::vector<int64_t>>& val) { return writeData(val); }\nstatus_t Parcel::writeInt64Vector(const std::unique_ptr<std::vector<int64_t>>& val) { return writeData(val); }\nstatus_t Parcel::writeUint64Vector(const std::vector<uint64_t>& val) { return writeData(val); }\nstatus_t Parcel::writeUint64Vector(const std::optional<std::vector<uint64_t>>& val) { return writeData(val); }\nstatus_t Parcel::writeUint64Vector(const std::unique_ptr<std::vector<uint64_t>>& val) { return writeData(val); }\nstatus_t Parcel::writeFloatVector(const std::vector<float>& val) { return writeData(val); }\nstatus_t Parcel::writeFloatVector(const std::optional<std::vector<float>>& val) { return writeData(val); }\nstatus_t Parcel::writeFloatVector(const std::unique_ptr<std::vector<float>>& val) { return writeData(val); }\nstatus_t Parcel::writeDoubleVector(const std::vector<double>& val) { return writeData(val); }\nstatus_t Parcel::writeDoubleVector(const std::optional<std::vector<double>>& val) { return writeData(val); }\nstatus_t Parcel::writeDoubleVector(const std::unique_ptr<std::vector<double>>& val) { return writeData(val); }\nstatus_t Parcel::writeBoolVector(const std::vector<bool>& val) { return writeData(val); }\nstatus_t Parcel::writeBoolVector(const std::optional<std::vector<bool>>& val) { return writeData(val); }\nstatus_t Parcel::writeBoolVector(const std::unique_ptr<std::vector<bool>>& val) { return writeData(val); }\nstatus_t Parcel::writeCharVector(const std::vector<char16_t>& val) { return writeData(val); }\nstatus_t Parcel::writeCharVector(const std::optional<std::vector<char16_t>>& val) { return writeData(val); }\nstatus_t Parcel::writeCharVector(const std::unique_ptr<std::vector<char16_t>>& val) { return writeData(val); }\n\nstatus_t Parcel::writeString16Vector(const std::vector<String16>& val) { return writeData(val); }\nstatus_t Parcel::writeString16Vector(\n        const std::optional<std::vector<std::optional<String16>>>& val) { return writeData(val); }\nstatus_t Parcel::writeString16Vector(\n        const std::unique_ptr<std::vector<std::unique_ptr<String16>>>& val) { return writeData(val); }\nstatus_t Parcel::writeUtf8VectorAsUtf16Vector(\n                        const std::optional<std::vector<std::optional<std::string>>>& val) { return writeData(val); }\nstatus_t Parcel::writeUtf8VectorAsUtf16Vector(\n                        const std::unique_ptr<std::vector<std::unique_ptr<std::string>>>& val) { return writeData(val); }\nstatus_t Parcel::writeUtf8VectorAsUtf16Vector(const std::vector<std::string>& val) { return writeData(val); }\n\nstatus_t Parcel::writeUniqueFileDescriptorVector(const std::vector<base::unique_fd>& val) { return writeData(val); }\nstatus_t Parcel::writeUniqueFileDescriptorVector(const std::optional<std::vector<base::unique_fd>>& val) { return writeData(val); }\nstatus_t Parcel::writeUniqueFileDescriptorVector(const std::unique_ptr<std::vector<base::unique_fd>>& val) { return writeData(val); }\n\nstatus_t Parcel::writeStrongBinderVector(const std::vector<sp<IBinder>>& val) { return writeData(val); }\nstatus_t Parcel::writeStrongBinderVector(const std::optional<std::vector<sp<IBinder>>>& val) { return writeData(val); }\nstatus_t Parcel::writeStrongBinderVector(const std::unique_ptr<std::vector<sp<IBinder>>>& val) { return writeData(val); }\n\nstatus_t Parcel::writeParcelable(const Parcelable& parcelable) { return writeData(parcelable); }\n\nstatus_t Parcel::readUtf8FromUtf16(std::optional<std::string>* str) const { return readData(str); }\nstatus_t Parcel::readUtf8FromUtf16(std::unique_ptr<std::string>* str) const { return readData(str); }\n\nstatus_t Parcel::readString16(std::optional<String16>* pArg) const { return readData(pArg); }\nstatus_t Parcel::readString16(std::unique_ptr<String16>* pArg) const { return readData(pArg); }\n\nstatus_t Parcel::readByteVector(std::vector<int8_t>* val) const { return readData(val); }\nstatus_t Parcel::readByteVector(std::vector<uint8_t>* val) const { return readData(val); }\nstatus_t Parcel::readByteVector(std::optional<std::vector<int8_t>>* val) const { return readData(val); }\nstatus_t Parcel::readByteVector(std::unique_ptr<std::vector<int8_t>>* val) const { return readData(val); }\nstatus_t Parcel::readByteVector(std::optional<std::vector<uint8_t>>* val) const { return readData(val); }\nstatus_t Parcel::readByteVector(std::unique_ptr<std::vector<uint8_t>>* val) const { return readData(val); }\nstatus_t Parcel::readInt32Vector(std::optional<std::vector<int32_t>>* val) const { return readData(val); }\nstatus_t Parcel::readInt32Vector(std::unique_ptr<std::vector<int32_t>>* val) const { return readData(val); }\nstatus_t Parcel::readInt32Vector(std::vector<int32_t>* val) const { return readData(val); }\nstatus_t Parcel::readInt64Vector(std::optional<std::vector<int64_t>>* val) const { return readData(val); }\nstatus_t Parcel::readInt64Vector(std::unique_ptr<std::vector<int64_t>>* val) const { return readData(val); }\nstatus_t Parcel::readInt64Vector(std::vector<int64_t>* val) const { return readData(val); }\nstatus_t Parcel::readUint64Vector(std::optional<std::vector<uint64_t>>* val) const { return readData(val); }\nstatus_t Parcel::readUint64Vector(std::unique_ptr<std::vector<uint64_t>>* val) const { return readData(val); }\nstatus_t Parcel::readUint64Vector(std::vector<uint64_t>* val) const { return readData(val); }\nstatus_t Parcel::readFloatVector(std::optional<std::vector<float>>* val) const { return readData(val); }\nstatus_t Parcel::readFloatVector(std::unique_ptr<std::vector<float>>* val) const { return readData(val); }\nstatus_t Parcel::readFloatVector(std::vector<float>* val) const { return readData(val); }\nstatus_t Parcel::readDoubleVector(std::optional<std::vector<double>>* val) const { return readData(val); }\nstatus_t Parcel::readDoubleVector(std::unique_ptr<std::vector<double>>* val) const { return readData(val); }\nstatus_t Parcel::readDoubleVector(std::vector<double>* val) const { return readData(val); }\nstatus_t Parcel::readBoolVector(std::optional<std::vector<bool>>* val) const { return readData(val); }\nstatus_t Parcel::readBoolVector(std::unique_ptr<std::vector<bool>>* val) const { return readData(val); }\nstatus_t Parcel::readBoolVector(std::vector<bool>* val) const { return readData(val); }\nstatus_t Parcel::readCharVector(std::optional<std::vector<char16_t>>* val) const { return readData(val); }\nstatus_t Parcel::readCharVector(std::unique_ptr<std::vector<char16_t>>* val) const { return readData(val); }\nstatus_t Parcel::readCharVector(std::vector<char16_t>* val) const { return readData(val); }\n\nstatus_t Parcel::readString16Vector(\n        std::optional<std::vector<std::optional<String16>>>* val) const { return readData(val); }\nstatus_t Parcel::readString16Vector(\n        std::unique_ptr<std::vector<std::unique_ptr<String16>>>* val) const { return readData(val); }\nstatus_t Parcel::readString16Vector(std::vector<String16>* val) const { return readData(val); }\nstatus_t Parcel::readUtf8VectorFromUtf16Vector(\n        std::optional<std::vector<std::optional<std::string>>>* val) const { return readData(val); }\nstatus_t Parcel::readUtf8VectorFromUtf16Vector(\n        std::unique_ptr<std::vector<std::unique_ptr<std::string>>>* val) const { return readData(val); }\nstatus_t Parcel::readUtf8VectorFromUtf16Vector(std::vector<std::string>* val) const { return readData(val); }\n\nstatus_t Parcel::readUniqueFileDescriptorVector(std::optional<std::vector<base::unique_fd>>* val) const { return readData(val); }\nstatus_t Parcel::readUniqueFileDescriptorVector(std::unique_ptr<std::vector<base::unique_fd>>* val) const { return readData(val); }\nstatus_t Parcel::readUniqueFileDescriptorVector(std::vector<base::unique_fd>* val) const { return readData(val); }\n\nstatus_t Parcel::readStrongBinderVector(std::optional<std::vector<sp<IBinder>>>* val) const { return readData(val); }\nstatus_t Parcel::readStrongBinderVector(std::unique_ptr<std::vector<sp<IBinder>>>* val) const { return readData(val); }\nstatus_t Parcel::readStrongBinderVector(std::vector<sp<IBinder>>* val) const { return readData(val); }\n\nstatus_t Parcel::readParcelable(Parcelable* parcelable) const { return readData(parcelable); }\n\nstatus_t Parcel::writeInt32(int32_t val)\n{\n    return writeAligned(val);\n}\n\nstatus_t Parcel::writeUint32(uint32_t val)\n{\n    return writeAligned(val);\n}\n\nstatus_t Parcel::writeInt32Array(size_t len, const int32_t *val) {\n    if (len > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    if (!val) {\n        return writeInt32(-1);\n    }\n    status_t ret = writeInt32(static_cast<uint32_t>(len));\n    if (ret == NO_ERROR) {\n        ret = write(val, len * sizeof(*val));\n    }\n    return ret;\n}\nstatus_t Parcel::writeByteArray(size_t len, const uint8_t *val) {\n    if (len > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    if (!val) {\n        return writeInt32(-1);\n    }\n    status_t ret = writeInt32(static_cast<uint32_t>(len));\n    if (ret == NO_ERROR) {\n        ret = write(val, len * sizeof(*val));\n    }\n    return ret;\n}\n\nstatus_t Parcel::writeBool(bool val)\n{\n    return writeInt32(int32_t(val));\n}\n\nstatus_t Parcel::writeChar(char16_t val)\n{\n    return writeInt32(int32_t(val));\n}\n\nstatus_t Parcel::writeByte(int8_t val)\n{\n    return writeInt32(int32_t(val));\n}\n\nstatus_t Parcel::writeInt64(int64_t val)\n{\n    return writeAligned(val);\n}\n\nstatus_t Parcel::writeUint64(uint64_t val)\n{\n    return writeAligned(val);\n}\n\nstatus_t Parcel::writePointer(uintptr_t val)\n{\n    return writeAligned<binder_uintptr_t>(val);\n}\n\nstatus_t Parcel::writeFloat(float val)\n{\n    return writeAligned(val);\n}\n\n#if defined(__mips__) && defined(__mips_hard_float)\n\nstatus_t Parcel::writeDouble(double val)\n{\n    union {\n        double d;\n        unsigned long long ll;\n    } u;\n    u.d = val;\n    return writeAligned(u.ll);\n}\n\n#else\n\nstatus_t Parcel::writeDouble(double val)\n{\n    return writeAligned(val);\n}\n\n#endif\n\nstatus_t Parcel::writeCString(const char* str)\n{\n    return write(str, strlen(str)+1);\n}\n\nstatus_t Parcel::writeString8(const String8& str)\n{\n    return writeString8(str.string(), str.size());\n}\n\nstatus_t Parcel::writeString8(const char* str, size_t len)\n{\n    if (str == nullptr) return writeInt32(-1);\n\n    // NOTE: Keep this logic in sync with android_os_Parcel.cpp\n    status_t err = writeInt32(len);\n    if (err == NO_ERROR) {\n        uint8_t* data = (uint8_t*)writeInplace(len+sizeof(char));\n        if (data) {\n            memcpy(data, str, len);\n            *reinterpret_cast<char*>(data+len) = 0;\n            return NO_ERROR;\n        }\n        err = mError;\n    }\n    return err;\n}\n\nstatus_t Parcel::writeString16(const String16& str)\n{\n    return writeString16(str.string(), str.size());\n}\n\nstatus_t Parcel::writeString16(const char16_t* str, size_t len)\n{\n    if (str == nullptr) return writeInt32(-1);\n\n    // NOTE: Keep this logic in sync with android_os_Parcel.cpp\n    status_t err = writeInt32(len);\n    if (err == NO_ERROR) {\n        len *= sizeof(char16_t);\n        uint8_t* data = (uint8_t*)writeInplace(len+sizeof(char16_t));\n        if (data) {\n            memcpy(data, str, len);\n            *reinterpret_cast<char16_t*>(data+len) = 0;\n            return NO_ERROR;\n        }\n        err = mError;\n    }\n    return err;\n}\n\nstatus_t Parcel::writeStrongBinder(const sp<IBinder>& val)\n{\n    return flattenBinder(val);\n}\n\n\nstatus_t Parcel::writeRawNullableParcelable(const Parcelable* parcelable) {\n    if (!parcelable) {\n        return writeInt32(0);\n    }\n\n    return writeParcelable(*parcelable);\n}\n\nstatus_t Parcel::writeNativeHandle(const native_handle* handle)\n{\n    if (!handle || handle->version != sizeof(native_handle))\n        return BAD_TYPE;\n\n    status_t err;\n    err = writeInt32(handle->numFds);\n    if (err != NO_ERROR) return err;\n\n    err = writeInt32(handle->numInts);\n    if (err != NO_ERROR) return err;\n\n    for (int i=0 ; err==NO_ERROR && i<handle->numFds ; i++)\n        err = writeDupFileDescriptor(handle->data[i]);\n\n    if (err != NO_ERROR) {\n        ALOGD(\"write native handle, write dup fd failed\");\n        return err;\n    }\n    err = write(handle->data + handle->numFds, sizeof(int)*handle->numInts);\n    return err;\n}\n\nstatus_t Parcel::writeFileDescriptor(int fd, bool takeOwnership)\n{\n    if (isForRpc()) {\n        ALOGE(\"Cannot write file descriptor to remote binder.\");\n        return BAD_TYPE;\n    }\n\n    flat_binder_object obj;\n    obj.hdr.type = BINDER_TYPE_FD;\n    obj.flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS;\n    obj.binder = 0; /* Don't pass uninitialized stack data to a remote process */\n    obj.handle = fd;\n    obj.cookie = takeOwnership ? 1 : 0;\n    return writeObject(obj, true);\n}\n\nstatus_t Parcel::writeDupFileDescriptor(int fd)\n{\n    int dupFd = fcntl(fd, F_DUPFD_CLOEXEC, 0);\n    if (dupFd < 0) {\n        return -errno;\n    }\n    status_t err = writeFileDescriptor(dupFd, true /*takeOwnership*/);\n    if (err != OK) {\n        close(dupFd);\n    }\n    return err;\n}\n\nstatus_t Parcel::writeParcelFileDescriptor(int fd, bool takeOwnership)\n{\n    writeInt32(0);\n    return writeFileDescriptor(fd, takeOwnership);\n}\n\nstatus_t Parcel::writeDupParcelFileDescriptor(int fd)\n{\n    int dupFd = fcntl(fd, F_DUPFD_CLOEXEC, 0);\n    if (dupFd < 0) {\n        return -errno;\n    }\n    status_t err = writeParcelFileDescriptor(dupFd, true /*takeOwnership*/);\n    if (err != OK) {\n        close(dupFd);\n    }\n    return err;\n}\n\nstatus_t Parcel::writeUniqueFileDescriptor(const base::unique_fd& fd) {\n    return writeDupFileDescriptor(fd.get());\n}\n\nstatus_t Parcel::writeBlob(size_t len, bool mutableCopy, WritableBlob* outBlob)\n{\n    if (len > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    status_t status;\n    if (!mAllowFds || len <= BLOB_INPLACE_LIMIT) {\n        ALOGV(\"writeBlob: write in place\");\n        status = writeInt32(BLOB_INPLACE);\n        if (status) return status;\n\n        void* ptr = writeInplace(len);\n        if (!ptr) return NO_MEMORY;\n\n        outBlob->init(-1, ptr, len, false);\n        return NO_ERROR;\n    }\n\n    ALOGV(\"writeBlob: write to ashmem\");\n    int fd = ashmem_create_region(\"Parcel Blob\", len);\n    if (fd < 0) return NO_MEMORY;\n\n    int result = ashmem_set_prot_region(fd, PROT_READ | PROT_WRITE);\n    if (result < 0) {\n        status = result;\n    } else {\n        void* ptr = ::mmap(nullptr, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n        if (ptr == MAP_FAILED) {\n            status = -errno;\n        } else {\n            if (!mutableCopy) {\n                result = ashmem_set_prot_region(fd, PROT_READ);\n            }\n            if (result < 0) {\n                status = result;\n            } else {\n                status = writeInt32(mutableCopy ? BLOB_ASHMEM_MUTABLE : BLOB_ASHMEM_IMMUTABLE);\n                if (!status) {\n                    status = writeFileDescriptor(fd, true /*takeOwnership*/);\n                    if (!status) {\n                        outBlob->init(fd, ptr, len, mutableCopy);\n                        return NO_ERROR;\n                    }\n                }\n            }\n        }\n        ::munmap(ptr, len);\n    }\n    ::close(fd);\n    return status;\n}\n\nstatus_t Parcel::writeDupImmutableBlobFileDescriptor(int fd)\n{\n    // Must match up with what's done in writeBlob.\n    if (!mAllowFds) return FDS_NOT_ALLOWED;\n    status_t status = writeInt32(BLOB_ASHMEM_IMMUTABLE);\n    if (status) return status;\n    return writeDupFileDescriptor(fd);\n}\n\nstatus_t Parcel::write(const FlattenableHelperInterface& val)\n{\n    status_t err;\n\n    // size if needed\n    const size_t len = val.getFlattenedSize();\n    const size_t fd_count = val.getFdCount();\n\n    if ((len > INT32_MAX) || (fd_count >= gMaxFds)) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    err = this->writeInt32(len);\n    if (err) return err;\n\n    err = this->writeInt32(fd_count);\n    if (err) return err;\n\n    // payload\n    void* const buf = this->writeInplace(len);\n    if (buf == nullptr)\n        return BAD_VALUE;\n\n    int* fds = nullptr;\n    if (fd_count) {\n        fds = new (std::nothrow) int[fd_count];\n        if (fds == nullptr) {\n            ALOGE(\"write: failed to allocate requested %zu fds\", fd_count);\n            return BAD_VALUE;\n        }\n    }\n\n    err = val.flatten(buf, len, fds, fd_count);\n    for (size_t i=0 ; i<fd_count && err==NO_ERROR ; i++) {\n        err = this->writeDupFileDescriptor( fds[i] );\n    }\n\n    if (fd_count) {\n        delete [] fds;\n    }\n\n    return err;\n}\n\nstatus_t Parcel::writeObject(const flat_binder_object& val, bool nullMetaData)\n{\n    const bool enoughData = (mDataPos+sizeof(val)) <= mDataCapacity;\n    const bool enoughObjects = mObjectsSize < mObjectsCapacity;\n    if (enoughData && enoughObjects) {\nrestart_write:\n        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n            return status;\n        }\n\n        *reinterpret_cast<flat_binder_object*>(mData+mDataPos) = val;\n\n        // remember if it's a file descriptor\n        if (val.hdr.type == BINDER_TYPE_FD) {\n            if (!mAllowFds) {\n                // fail before modifying our object index\n                return FDS_NOT_ALLOWED;\n            }\n            mHasFds = mFdsKnown = true;\n        }\n\n        // Need to write meta-data?\n        if (nullMetaData || val.binder != 0) {\n            mObjects[mObjectsSize] = mDataPos;\n            acquire_object(ProcessState::self(), val, this, &mOpenAshmemSize);\n            mObjectsSize++;\n        }\n\n        return finishWrite(sizeof(flat_binder_object));\n    }\n\n    if (!enoughData) {\n        const status_t err = growData(sizeof(val));\n        if (err != NO_ERROR) return err;\n    }\n    if (!enoughObjects) {\n        if (mObjectsSize > SIZE_MAX - 2) return NO_MEMORY; // overflow\n        if ((mObjectsSize + 2) > SIZE_MAX / 3) return NO_MEMORY; // overflow\n        size_t newSize = ((mObjectsSize+2)*3)/2;\n        if (newSize > SIZE_MAX / sizeof(binder_size_t)) return NO_MEMORY; // overflow\n        binder_size_t* objects = (binder_size_t*)realloc(mObjects, newSize*sizeof(binder_size_t));\n        if (objects == nullptr) return NO_MEMORY;\n        mObjects = objects;\n        mObjectsCapacity = newSize;\n    }\n\n    goto restart_write;\n}\n\nstatus_t Parcel::writeNoException()\n{\n    binder::Status status;\n    return status.writeToParcel(this);\n}\n\nstatus_t Parcel::validateReadData(size_t upperBound) const\n{\n    // Don't allow non-object reads on object data\n    if (mObjectsSorted || mObjectsSize <= 1) {\ndata_sorted:\n        // Expect to check only against the next object\n        if (mNextObjectHint < mObjectsSize && upperBound > mObjects[mNextObjectHint]) {\n            // For some reason the current read position is greater than the next object\n            // hint. Iterate until we find the right object\n            size_t nextObject = mNextObjectHint;\n            do {\n                if (mDataPos < mObjects[nextObject] + sizeof(flat_binder_object)) {\n                    // Requested info overlaps with an object\n                    ALOGE(\"Attempt to read from protected data in Parcel %p\", this);\n                    return PERMISSION_DENIED;\n                }\n                nextObject++;\n            } while (nextObject < mObjectsSize && upperBound > mObjects[nextObject]);\n            mNextObjectHint = nextObject;\n        }\n        return NO_ERROR;\n    }\n    // Quickly determine if mObjects is sorted.\n    binder_size_t* currObj = mObjects + mObjectsSize - 1;\n    binder_size_t* prevObj = currObj;\n    while (currObj > mObjects) {\n        prevObj--;\n        if(*prevObj > *currObj) {\n            goto data_unsorted;\n        }\n        currObj--;\n    }\n    mObjectsSorted = true;\n    goto data_sorted;\n\ndata_unsorted:\n    // Insertion Sort mObjects\n    // Great for mostly sorted lists. If randomly sorted or reverse ordered mObjects become common,\n    // switch to std::sort(mObjects, mObjects + mObjectsSize);\n    for (binder_size_t* iter0 = mObjects + 1; iter0 < mObjects + mObjectsSize; iter0++) {\n        binder_size_t temp = *iter0;\n        binder_size_t* iter1 = iter0 - 1;\n        while (iter1 >= mObjects && *iter1 > temp) {\n            *(iter1 + 1) = *iter1;\n            iter1--;\n        }\n        *(iter1 + 1) = temp;\n    }\n    mNextObjectHint = 0;\n    mObjectsSorted = true;\n    goto data_sorted;\n}\n\nstatus_t Parcel::read(void* outData, size_t len) const\n{\n    if (len > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    if ((mDataPos+pad_size(len)) >= mDataPos && (mDataPos+pad_size(len)) <= mDataSize\n            && len <= pad_size(len)) {\n        if (mObjectsSize > 0) {\n            status_t err = validateReadData(mDataPos + pad_size(len));\n            if(err != NO_ERROR) {\n                // Still increment the data position by the expected length\n                mDataPos += pad_size(len);\n                ALOGV(\"read Setting data pos of %p to %zu\", this, mDataPos);\n                return err;\n            }\n        }\n        memcpy(outData, mData+mDataPos, len);\n        mDataPos += pad_size(len);\n        ALOGV(\"read Setting data pos of %p to %zu\", this, mDataPos);\n        return NO_ERROR;\n    }\n    return NOT_ENOUGH_DATA;\n}\n\nconst void* Parcel::readInplace(size_t len) const\n{\n    if (len > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return nullptr;\n    }\n\n    if ((mDataPos+pad_size(len)) >= mDataPos && (mDataPos+pad_size(len)) <= mDataSize\n            && len <= pad_size(len)) {\n        if (mObjectsSize > 0) {\n            status_t err = validateReadData(mDataPos + pad_size(len));\n            if(err != NO_ERROR) {\n                // Still increment the data position by the expected length\n                mDataPos += pad_size(len);\n                ALOGV(\"readInplace Setting data pos of %p to %zu\", this, mDataPos);\n                return nullptr;\n            }\n        }\n\n        const void* data = mData+mDataPos;\n        mDataPos += pad_size(len);\n        ALOGV(\"readInplace Setting data pos of %p to %zu\", this, mDataPos);\n        return data;\n    }\n    return nullptr;\n}\n\ntemplate<class T>\nstatus_t Parcel::readAligned(T *pArg) const {\n    static_assert(PAD_SIZE_UNSAFE(sizeof(T)) == sizeof(T));\n\n    if ((mDataPos+sizeof(T)) <= mDataSize) {\n        if (mObjectsSize > 0) {\n            status_t err = validateReadData(mDataPos + sizeof(T));\n            if(err != NO_ERROR) {\n                // Still increment the data position by the expected length\n                mDataPos += sizeof(T);\n                return err;\n            }\n        }\n\n        const void* data = mData+mDataPos;\n        mDataPos += sizeof(T);\n        *pArg =  *reinterpret_cast<const T*>(data);\n        return NO_ERROR;\n    } else {\n        return NOT_ENOUGH_DATA;\n    }\n}\n\ntemplate<class T>\nT Parcel::readAligned() const {\n    T result;\n    if (readAligned(&result) != NO_ERROR) {\n        result = 0;\n    }\n\n    return result;\n}\n\ntemplate<class T>\nstatus_t Parcel::writeAligned(T val) {\n    static_assert(PAD_SIZE_UNSAFE(sizeof(T)) == sizeof(T));\n\n    if ((mDataPos+sizeof(val)) <= mDataCapacity) {\nrestart_write:\n        *reinterpret_cast<T*>(mData+mDataPos) = val;\n        return finishWrite(sizeof(val));\n    }\n\n    status_t err = growData(sizeof(val));\n    if (err == NO_ERROR) goto restart_write;\n    return err;\n}\n\nstatus_t Parcel::readInt32(int32_t *pArg) const\n{\n    return readAligned(pArg);\n}\n\nint32_t Parcel::readInt32() const\n{\n    return readAligned<int32_t>();\n}\n\nstatus_t Parcel::readUint32(uint32_t *pArg) const\n{\n    return readAligned(pArg);\n}\n\nuint32_t Parcel::readUint32() const\n{\n    return readAligned<uint32_t>();\n}\n\nstatus_t Parcel::readInt64(int64_t *pArg) const\n{\n    return readAligned(pArg);\n}\n\n\nint64_t Parcel::readInt64() const\n{\n    return readAligned<int64_t>();\n}\n\nstatus_t Parcel::readUint64(uint64_t *pArg) const\n{\n    return readAligned(pArg);\n}\n\nuint64_t Parcel::readUint64() const\n{\n    return readAligned<uint64_t>();\n}\n\nstatus_t Parcel::readPointer(uintptr_t *pArg) const\n{\n    status_t ret;\n    binder_uintptr_t ptr;\n    ret = readAligned(&ptr);\n    if (!ret)\n        *pArg = ptr;\n    return ret;\n}\n\nuintptr_t Parcel::readPointer() const\n{\n    return readAligned<binder_uintptr_t>();\n}\n\n\nstatus_t Parcel::readFloat(float *pArg) const\n{\n    return readAligned(pArg);\n}\n\n\nfloat Parcel::readFloat() const\n{\n    return readAligned<float>();\n}\n\n#if defined(__mips__) && defined(__mips_hard_float)\n\nstatus_t Parcel::readDouble(double *pArg) const\n{\n    union {\n      double d;\n      unsigned long long ll;\n    } u;\n    u.d = 0;\n    status_t status;\n    status = readAligned(&u.ll);\n    *pArg = u.d;\n    return status;\n}\n\ndouble Parcel::readDouble() const\n{\n    union {\n      double d;\n      unsigned long long ll;\n    } u;\n    u.ll = readAligned<unsigned long long>();\n    return u.d;\n}\n\n#else\n\nstatus_t Parcel::readDouble(double *pArg) const\n{\n    return readAligned(pArg);\n}\n\ndouble Parcel::readDouble() const\n{\n    return readAligned<double>();\n}\n\n#endif\n\nstatus_t Parcel::readBool(bool *pArg) const\n{\n    int32_t tmp = 0;\n    status_t ret = readInt32(&tmp);\n    *pArg = (tmp != 0);\n    return ret;\n}\n\nbool Parcel::readBool() const\n{\n    return readInt32() != 0;\n}\n\nstatus_t Parcel::readChar(char16_t *pArg) const\n{\n    int32_t tmp = 0;\n    status_t ret = readInt32(&tmp);\n    *pArg = char16_t(tmp);\n    return ret;\n}\n\nchar16_t Parcel::readChar() const\n{\n    return char16_t(readInt32());\n}\n\nstatus_t Parcel::readByte(int8_t *pArg) const\n{\n    int32_t tmp = 0;\n    status_t ret = readInt32(&tmp);\n    *pArg = int8_t(tmp);\n    return ret;\n}\n\nint8_t Parcel::readByte() const\n{\n    return int8_t(readInt32());\n}\n\nstatus_t Parcel::readUtf8FromUtf16(std::string* str) const {\n    size_t utf16Size = 0;\n    const char16_t* src = readString16Inplace(&utf16Size);\n    if (!src) {\n        return UNEXPECTED_NULL;\n    }\n\n    // Save ourselves the trouble, we're done.\n    if (utf16Size == 0u) {\n        str->clear();\n       return NO_ERROR;\n    }\n\n    // Allow for closing '\\0'\n    ssize_t utf8Size = utf16_to_utf8_length(src, utf16Size) + 1;\n    if (utf8Size < 1) {\n        return BAD_VALUE;\n    }\n    // Note that while it is probably safe to assume string::resize keeps a\n    // spare byte around for the trailing null, we still pass the size including the trailing null\n    str->resize(utf8Size);\n    utf16_to_utf8(src, utf16Size, &((*str)[0]), utf8Size);\n    str->resize(utf8Size - 1);\n    return NO_ERROR;\n}\n\nconst char* Parcel::readCString() const\n{\n    if (mDataPos < mDataSize) {\n        const size_t avail = mDataSize-mDataPos;\n        const char* str = reinterpret_cast<const char*>(mData+mDataPos);\n        // is the string's trailing NUL within the parcel's valid bounds?\n        const char* eos = reinterpret_cast<const char*>(memchr(str, 0, avail));\n        if (eos) {\n            const size_t len = eos - str;\n            mDataPos += pad_size(len+1);\n            ALOGV(\"readCString Setting data pos of %p to %zu\", this, mDataPos);\n            return str;\n        }\n    }\n    return nullptr;\n}\n\nString8 Parcel::readString8() const\n{\n    size_t len;\n    const char* str = readString8Inplace(&len);\n    if (str) return String8(str, len);\n    ALOGE(\"Reading a NULL string not supported here.\");\n    return String8();\n}\n\nstatus_t Parcel::readString8(String8* pArg) const\n{\n    size_t len;\n    const char* str = readString8Inplace(&len);\n    if (str) {\n        pArg->setTo(str, len);\n        return 0;\n    } else {\n        *pArg = String8();\n        return UNEXPECTED_NULL;\n    }\n}\n\nconst char* Parcel::readString8Inplace(size_t* outLen) const\n{\n    int32_t size = readInt32();\n    // watch for potential int overflow from size+1\n    if (size >= 0 && size < INT32_MAX) {\n        *outLen = size;\n        const char* str = (const char*)readInplace(size+1);\n        if (str != nullptr) {\n            if (str[size] == '\\0') {\n                return str;\n            }\n            android_errorWriteLog(0x534e4554, \"172655291\");\n        }\n    }\n    *outLen = 0;\n    return nullptr;\n}\n\nString16 Parcel::readString16() const\n{\n    size_t len;\n    const char16_t* str = readString16Inplace(&len);\n    if (str) return String16(str, len);\n    ALOGE(\"Reading a NULL string not supported here.\");\n    return String16();\n}\n\n\nstatus_t Parcel::readString16(String16* pArg) const\n{\n    size_t len;\n    const char16_t* str = readString16Inplace(&len);\n    if (str) {\n        pArg->setTo(str, len);\n        return 0;\n    } else {\n        *pArg = String16();\n        return UNEXPECTED_NULL;\n    }\n}\n\nconst char16_t* Parcel::readString16Inplace(size_t* outLen) const\n{\n    int32_t size = readInt32();\n    // watch for potential int overflow from size+1\n    if (size >= 0 && size < INT32_MAX) {\n        *outLen = size;\n        const char16_t* str = (const char16_t*)readInplace((size+1)*sizeof(char16_t));\n        if (str != nullptr) {\n            if (str[size] == u'\\0') {\n                return str;\n            }\n            android_errorWriteLog(0x534e4554, \"172655291\");\n        }\n    }\n    *outLen = 0;\n    return nullptr;\n}\n\nstatus_t Parcel::readStrongBinder(sp<IBinder>* val) const\n{\n    status_t status = readNullableStrongBinder(val);\n    if (status == OK && !val->get()) {\n        status = UNEXPECTED_NULL;\n    }\n    return status;\n}\n\nstatus_t Parcel::readNullableStrongBinder(sp<IBinder>* val) const\n{\n    return unflattenBinder(val);\n}\n\nsp<IBinder> Parcel::readStrongBinder() const\n{\n    sp<IBinder> val;\n    // Note that a lot of code in Android reads binders by hand with this\n    // method, and that code has historically been ok with getting nullptr\n    // back (while ignoring error codes).\n    readNullableStrongBinder(&val);\n    return val;\n}\n\nint32_t Parcel::readExceptionCode() const\n{\n    binder::Status status;\n    status.readFromParcel(*this);\n    return status.exceptionCode();\n}\n\nnative_handle* Parcel::readNativeHandle() const\n{\n    int numFds, numInts;\n    status_t err;\n    err = readInt32(&numFds);\n    if (err != NO_ERROR) return nullptr;\n    err = readInt32(&numInts);\n    if (err != NO_ERROR) return nullptr;\n\n    native_handle* h = native_handle_create(numFds, numInts);\n    if (!h) {\n        return nullptr;\n    }\n\n    for (int i=0 ; err==NO_ERROR && i<numFds ; i++) {\n        h->data[i] = fcntl(readFileDescriptor(), F_DUPFD_CLOEXEC, 0);\n        if (h->data[i] < 0) {\n            for (int j = 0; j < i; j++) {\n                close(h->data[j]);\n            }\n            native_handle_delete(h);\n            return nullptr;\n        }\n    }\n    err = read(h->data + numFds, sizeof(int)*numInts);\n    if (err != NO_ERROR) {\n        native_handle_close(h);\n        native_handle_delete(h);\n        h = nullptr;\n    }\n    return h;\n}\n\nint Parcel::readFileDescriptor() const\n{\n    const flat_binder_object* flat = readObject(true);\n\n    if (flat && flat->hdr.type == BINDER_TYPE_FD) {\n        return flat->handle;\n    }\n\n    return BAD_TYPE;\n}\n\nint Parcel::readParcelFileDescriptor() const\n{\n    int32_t hasComm = readInt32();\n    int fd = readFileDescriptor();\n    if (hasComm != 0) {\n        // detach (owned by the binder driver)\n        int comm = readFileDescriptor();\n\n        // warning: this must be kept in sync with:\n        // frameworks/base/core/java/android/os/ParcelFileDescriptor.java\n        enum ParcelFileDescriptorStatus {\n            DETACHED = 2,\n        };\n\n#if BYTE_ORDER == BIG_ENDIAN\n        const int32_t message = ParcelFileDescriptorStatus::DETACHED;\n#endif\n#if BYTE_ORDER == LITTLE_ENDIAN\n        const int32_t message = __builtin_bswap32(ParcelFileDescriptorStatus::DETACHED);\n#endif\n\n        ssize_t written = TEMP_FAILURE_RETRY(\n            ::write(comm, &message, sizeof(message)));\n\n        if (written != sizeof(message)) {\n            ALOGW(\"Failed to detach ParcelFileDescriptor written: %zd err: %s\",\n                written, strerror(errno));\n            return BAD_TYPE;\n        }\n    }\n    return fd;\n}\n\nstatus_t Parcel::readUniqueFileDescriptor(base::unique_fd* val) const\n{\n    int got = readFileDescriptor();\n\n    if (got == BAD_TYPE) {\n        return BAD_TYPE;\n    }\n\n    val->reset(fcntl(got, F_DUPFD_CLOEXEC, 0));\n\n    if (val->get() < 0) {\n        return BAD_VALUE;\n    }\n\n    return OK;\n}\n\nstatus_t Parcel::readUniqueParcelFileDescriptor(base::unique_fd* val) const\n{\n    int got = readParcelFileDescriptor();\n\n    if (got == BAD_TYPE) {\n        return BAD_TYPE;\n    }\n\n    val->reset(fcntl(got, F_DUPFD_CLOEXEC, 0));\n\n    if (val->get() < 0) {\n        return BAD_VALUE;\n    }\n\n    return OK;\n}\n\nstatus_t Parcel::readBlob(size_t len, ReadableBlob* outBlob) const\n{\n    int32_t blobType;\n    status_t status = readInt32(&blobType);\n    if (status) return status;\n\n    if (blobType == BLOB_INPLACE) {\n        ALOGV(\"readBlob: read in place\");\n        const void* ptr = readInplace(len);\n        if (!ptr) return BAD_VALUE;\n\n        outBlob->init(-1, const_cast<void*>(ptr), len, false);\n        return NO_ERROR;\n    }\n\n    ALOGV(\"readBlob: read from ashmem\");\n    bool isMutable = (blobType == BLOB_ASHMEM_MUTABLE);\n    int fd = readFileDescriptor();\n    if (fd == int(BAD_TYPE)) return BAD_VALUE;\n\n    if (!ashmem_valid(fd)) {\n        ALOGE(\"invalid fd\");\n        return BAD_VALUE;\n    }\n    int size = ashmem_get_size_region(fd);\n    if (size < 0 || size_t(size) < len) {\n        ALOGE(\"request size %zu does not match fd size %d\", len, size);\n        return BAD_VALUE;\n    }\n    void* ptr = ::mmap(nullptr, len, isMutable ? PROT_READ | PROT_WRITE : PROT_READ,\n            MAP_SHARED, fd, 0);\n    if (ptr == MAP_FAILED) return NO_MEMORY;\n\n    outBlob->init(fd, ptr, len, isMutable);\n    return NO_ERROR;\n}\n\nstatus_t Parcel::read(FlattenableHelperInterface& val) const\n{\n    // size\n    const size_t len = this->readInt32();\n    const size_t fd_count = this->readInt32();\n\n    if ((len > INT32_MAX) || (fd_count >= gMaxFds)) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    // payload\n    void const* const buf = this->readInplace(pad_size(len));\n    if (buf == nullptr)\n        return BAD_VALUE;\n\n    int* fds = nullptr;\n    if (fd_count) {\n        fds = new (std::nothrow) int[fd_count];\n        if (fds == nullptr) {\n            ALOGE(\"read: failed to allocate requested %zu fds\", fd_count);\n            return BAD_VALUE;\n        }\n    }\n\n    status_t err = NO_ERROR;\n    for (size_t i=0 ; i<fd_count && err==NO_ERROR ; i++) {\n        int fd = this->readFileDescriptor();\n        if (fd < 0 || ((fds[i] = fcntl(fd, F_DUPFD_CLOEXEC, 0)) < 0)) {\n            err = BAD_VALUE;\n            ALOGE(\"fcntl(F_DUPFD_CLOEXEC) failed in Parcel::read, i is %zu, fds[i] is %d, fd_count is %zu, error: %s\",\n                  i, fds[i], fd_count, strerror(fd < 0 ? -fd : errno));\n            // Close all the file descriptors that were dup-ed.\n            for (size_t j=0; j<i ;j++) {\n                close(fds[j]);\n            }\n        }\n    }\n\n    if (err == NO_ERROR) {\n        err = val.unflatten(buf, len, fds, fd_count);\n    }\n\n    if (fd_count) {\n        delete [] fds;\n    }\n\n    return err;\n}\nconst flat_binder_object* Parcel::readObject(bool nullMetaData) const\n{\n    const size_t DPOS = mDataPos;\n    if ((DPOS+sizeof(flat_binder_object)) <= mDataSize) {\n        const flat_binder_object* obj\n                = reinterpret_cast<const flat_binder_object*>(mData+DPOS);\n        mDataPos = DPOS + sizeof(flat_binder_object);\n        if (!nullMetaData && (obj->cookie == 0 && obj->binder == 0)) {\n            // When transferring a NULL object, we don't write it into\n            // the object list, so we don't want to check for it when\n            // reading.\n            ALOGV(\"readObject Setting data pos of %p to %zu\", this, mDataPos);\n            return obj;\n        }\n\n        // Ensure that this object is valid...\n        binder_size_t* const OBJS = mObjects;\n        const size_t N = mObjectsSize;\n        size_t opos = mNextObjectHint;\n\n        if (N > 0) {\n            ALOGV(\"Parcel %p looking for obj at %zu, hint=%zu\",\n                 this, DPOS, opos);\n\n            // Start at the current hint position, looking for an object at\n            // the current data position.\n            if (opos < N) {\n                while (opos < (N-1) && OBJS[opos] < DPOS) {\n                    opos++;\n                }\n            } else {\n                opos = N-1;\n            }\n            if (OBJS[opos] == DPOS) {\n                // Found it!\n                ALOGV(\"Parcel %p found obj %zu at index %zu with forward search\",\n                     this, DPOS, opos);\n                mNextObjectHint = opos+1;\n                ALOGV(\"readObject Setting data pos of %p to %zu\", this, mDataPos);\n                return obj;\n            }\n\n            // Look backwards for it...\n            while (opos > 0 && OBJS[opos] > DPOS) {\n                opos--;\n            }\n            if (OBJS[opos] == DPOS) {\n                // Found it!\n                ALOGV(\"Parcel %p found obj %zu at index %zu with backward search\",\n                     this, DPOS, opos);\n                mNextObjectHint = opos+1;\n                ALOGV(\"readObject Setting data pos of %p to %zu\", this, mDataPos);\n                return obj;\n            }\n        }\n        ALOGW(\"Attempt to read object from Parcel %p at offset %zu that is not in the object list\",\n             this, DPOS);\n    }\n    return nullptr;\n}\n\nvoid Parcel::closeFileDescriptors()\n{\n    size_t i = mObjectsSize;\n    if (i > 0) {\n        //ALOGI(\"Closing file descriptors for %zu objects...\", i);\n    }\n    while (i > 0) {\n        i--;\n        const flat_binder_object* flat\n            = reinterpret_cast<flat_binder_object*>(mData+mObjects[i]);\n        if (flat->hdr.type == BINDER_TYPE_FD) {\n            //ALOGI(\"Closing fd: %ld\", flat->handle);\n            close(flat->handle);\n        }\n    }\n}\n\nuintptr_t Parcel::ipcData() const\n{\n    return reinterpret_cast<uintptr_t>(mData);\n}\n\nsize_t Parcel::ipcDataSize() const\n{\n    return (mDataSize > mDataPos ? mDataSize : mDataPos);\n}\n\nuintptr_t Parcel::ipcObjects() const\n{\n    return reinterpret_cast<uintptr_t>(mObjects);\n}\n\nsize_t Parcel::ipcObjectsCount() const\n{\n    return mObjectsSize;\n}\n\nvoid Parcel::ipcSetDataReference(const uint8_t* data, size_t dataSize,\n    const binder_size_t* objects, size_t objectsCount, release_func relFunc)\n{\n    // this code uses 'mOwner == nullptr' to understand whether it owns memory\n    LOG_ALWAYS_FATAL_IF(relFunc == nullptr, \"must provide cleanup function\");\n\n    freeData();\n\n    mData = const_cast<uint8_t*>(data);\n    mDataSize = mDataCapacity = dataSize;\n    mObjects = const_cast<binder_size_t*>(objects);\n    mObjectsSize = mObjectsCapacity = objectsCount;\n    mOwner = relFunc;\n\n    binder_size_t minOffset = 0;\n    for (size_t i = 0; i < mObjectsSize; i++) {\n        binder_size_t offset = mObjects[i];\n        if (offset < minOffset) {\n            ALOGE(\"%s: bad object offset %\" PRIu64 \" < %\" PRIu64 \"\\n\",\n                  __func__, (uint64_t)offset, (uint64_t)minOffset);\n            mObjectsSize = 0;\n            break;\n        }\n        const flat_binder_object* flat\n            = reinterpret_cast<const flat_binder_object*>(mData + offset);\n        uint32_t type = flat->hdr.type;\n        if (!(type == BINDER_TYPE_BINDER || type == BINDER_TYPE_HANDLE ||\n              type == BINDER_TYPE_FD)) {\n            // We should never receive other types (eg BINDER_TYPE_FDA) as long as we don't support\n            // them in libbinder. If we do receive them, it probably means a kernel bug; try to\n            // recover gracefully by clearing out the objects.\n            android_errorWriteLog(0x534e4554, \"135930648\");\n            android_errorWriteLog(0x534e4554, \"203847542\");\n            ALOGE(\"%s: unsupported type object (%\" PRIu32 \") at offset %\" PRIu64 \"\\n\",\n                  __func__, type, (uint64_t)offset);\n\n            // WARNING: callers of ipcSetDataReference need to make sure they\n            // don't rely on mObjectsSize in their release_func.\n            mObjectsSize = 0;\n            break;\n        }\n        minOffset = offset + sizeof(flat_binder_object);\n    }\n    scanForFds();\n}\n\nvoid Parcel::print(TextOutput& to, uint32_t /*flags*/) const\n{\n    to << \"Parcel(\";\n\n    if (errorCheck() != NO_ERROR) {\n        const status_t err = errorCheck();\n        to << \"Error: \" << (void*)(intptr_t)err << \" \\\"\" << strerror(-err) << \"\\\"\";\n    } else if (dataSize() > 0) {\n        const uint8_t* DATA = data();\n        to << indent << HexDump(DATA, dataSize()) << dedent;\n        const binder_size_t* OBJS = mObjects;\n        const size_t N = objectsCount();\n        for (size_t i=0; i<N; i++) {\n            const flat_binder_object* flat\n                = reinterpret_cast<const flat_binder_object*>(DATA+OBJS[i]);\n            to << endl << \"Object #\" << i << \" @ \" << (void*)OBJS[i] << \": \"\n                << TypeCode(flat->hdr.type & 0x7f7f7f00)\n                << \" = \" << flat->binder;\n        }\n    } else {\n        to << \"NULL\";\n    }\n\n    to << \")\";\n}\n\nvoid Parcel::releaseObjects()\n{\n    size_t i = mObjectsSize;\n    if (i == 0) {\n        return;\n    }\n    sp<ProcessState> proc(ProcessState::self());\n    uint8_t* const data = mData;\n    binder_size_t* const objects = mObjects;\n    while (i > 0) {\n        i--;\n        const flat_binder_object* flat\n            = reinterpret_cast<flat_binder_object*>(data+objects[i]);\n        release_object(proc, *flat, this, &mOpenAshmemSize);\n    }\n}\n\nvoid Parcel::acquireObjects()\n{\n    size_t i = mObjectsSize;\n    if (i == 0) {\n        return;\n    }\n    const sp<ProcessState> proc(ProcessState::self());\n    uint8_t* const data = mData;\n    binder_size_t* const objects = mObjects;\n    while (i > 0) {\n        i--;\n        const flat_binder_object* flat\n            = reinterpret_cast<flat_binder_object*>(data+objects[i]);\n        acquire_object(proc, *flat, this, &mOpenAshmemSize);\n    }\n}\n\nvoid Parcel::freeData()\n{\n    freeDataNoInit();\n    initState();\n}\n\nvoid Parcel::freeDataNoInit()\n{\n    if (mOwner) {\n        LOG_ALLOC(\"Parcel %p: freeing other owner data\", this);\n        //ALOGI(\"Freeing data ref of %p (pid=%d)\", this, getpid());\n        mOwner(this, mData, mDataSize, mObjects, mObjectsSize);\n    } else {\n        LOG_ALLOC(\"Parcel %p: freeing allocated data\", this);\n        releaseObjects();\n        if (mData) {\n            LOG_ALLOC(\"Parcel %p: freeing with %zu capacity\", this, mDataCapacity);\n            gParcelGlobalAllocSize -= mDataCapacity;\n            gParcelGlobalAllocCount--;\n            if (mDeallocZero) {\n                zeroMemory(mData, mDataSize);\n            }\n            free(mData);\n        }\n        if (mObjects) free(mObjects);\n    }\n}\n\nstatus_t Parcel::growData(size_t len)\n{\n    if (len > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    if (len > SIZE_MAX - mDataSize) return NO_MEMORY; // overflow\n    if (mDataSize + len > SIZE_MAX / 3) return NO_MEMORY; // overflow\n    size_t newSize = ((mDataSize+len)*3)/2;\n    return (newSize <= mDataSize)\n            ? (status_t) NO_MEMORY\n            : continueWrite(std::max(newSize, (size_t) 128));\n}\n\nstatic uint8_t* reallocZeroFree(uint8_t* data, size_t oldCapacity, size_t newCapacity, bool zero) {\n    if (!zero) {\n        return (uint8_t*)realloc(data, newCapacity);\n    }\n    uint8_t* newData = (uint8_t*)malloc(newCapacity);\n    if (!newData) {\n        return nullptr;\n    }\n\n    memcpy(newData, data, std::min(oldCapacity, newCapacity));\n    zeroMemory(data, oldCapacity);\n    free(data);\n    return newData;\n}\n\nstatus_t Parcel::restartWrite(size_t desired)\n{\n    if (desired > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    if (mOwner) {\n        freeData();\n        return continueWrite(desired);\n    }\n\n    uint8_t* data = reallocZeroFree(mData, mDataCapacity, desired, mDeallocZero);\n    if (!data && desired > mDataCapacity) {\n        mError = NO_MEMORY;\n        return NO_MEMORY;\n    }\n\n    releaseObjects();\n\n    if (data || desired == 0) {\n        LOG_ALLOC(\"Parcel %p: restart from %zu to %zu capacity\", this, mDataCapacity, desired);\n        if (mDataCapacity > desired) {\n            gParcelGlobalAllocSize -= (mDataCapacity - desired);\n        } else {\n            gParcelGlobalAllocSize += (desired - mDataCapacity);\n        }\n\n        if (!mData) {\n            gParcelGlobalAllocCount++;\n        }\n        mData = data;\n        mDataCapacity = desired;\n    }\n\n    mDataSize = mDataPos = 0;\n    ALOGV(\"restartWrite Setting data size of %p to %zu\", this, mDataSize);\n    ALOGV(\"restartWrite Setting data pos of %p to %zu\", this, mDataPos);\n\n    free(mObjects);\n    mObjects = nullptr;\n    mObjectsSize = mObjectsCapacity = 0;\n    mNextObjectHint = 0;\n    mObjectsSorted = false;\n    mHasFds = false;\n    mFdsKnown = true;\n    mAllowFds = true;\n\n    return NO_ERROR;\n}\n\nstatus_t Parcel::continueWrite(size_t desired)\n{\n    if (desired > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    // If shrinking, first adjust for any objects that appear\n    // after the new data size.\n    size_t objectsSize = mObjectsSize;\n    if (desired < mDataSize) {\n        if (desired == 0) {\n            objectsSize = 0;\n        } else {\n            while (objectsSize > 0) {\n                if (mObjects[objectsSize-1] < desired)\n                    break;\n                objectsSize--;\n            }\n        }\n    }\n\n    if (mOwner) {\n        // If the size is going to zero, just release the owner's data.\n        if (desired == 0) {\n            freeData();\n            return NO_ERROR;\n        }\n\n        // If there is a different owner, we need to take\n        // posession.\n        uint8_t* data = (uint8_t*)malloc(desired);\n        if (!data) {\n            mError = NO_MEMORY;\n            return NO_MEMORY;\n        }\n        binder_size_t* objects = nullptr;\n\n        if (objectsSize) {\n            objects = (binder_size_t*)calloc(objectsSize, sizeof(binder_size_t));\n            if (!objects) {\n                free(data);\n\n                mError = NO_MEMORY;\n                return NO_MEMORY;\n            }\n\n            // Little hack to only acquire references on objects\n            // we will be keeping.\n            size_t oldObjectsSize = mObjectsSize;\n            mObjectsSize = objectsSize;\n            acquireObjects();\n            mObjectsSize = oldObjectsSize;\n        }\n\n        if (mData) {\n            memcpy(data, mData, mDataSize < desired ? mDataSize : desired);\n        }\n        if (objects && mObjects) {\n            memcpy(objects, mObjects, objectsSize*sizeof(binder_size_t));\n        }\n        //ALOGI(\"Freeing data ref of %p (pid=%d)\", this, getpid());\n        mOwner(this, mData, mDataSize, mObjects, mObjectsSize);\n        mOwner = nullptr;\n\n        LOG_ALLOC(\"Parcel %p: taking ownership of %zu capacity\", this, desired);\n        gParcelGlobalAllocSize += desired;\n        gParcelGlobalAllocCount++;\n\n        mData = data;\n        mObjects = objects;\n        mDataSize = (mDataSize < desired) ? mDataSize : desired;\n        ALOGV(\"continueWrite Setting data size of %p to %zu\", this, mDataSize);\n        mDataCapacity = desired;\n        mObjectsSize = mObjectsCapacity = objectsSize;\n        mNextObjectHint = 0;\n        mObjectsSorted = false;\n\n    } else if (mData) {\n        if (objectsSize < mObjectsSize) {\n            // Need to release refs on any objects we are dropping.\n            const sp<ProcessState> proc(ProcessState::self());\n            for (size_t i=objectsSize; i<mObjectsSize; i++) {\n                const flat_binder_object* flat\n                    = reinterpret_cast<flat_binder_object*>(mData+mObjects[i]);\n                if (flat->hdr.type == BINDER_TYPE_FD) {\n                    // will need to rescan because we may have lopped off the only FDs\n                    mFdsKnown = false;\n                }\n                release_object(proc, *flat, this, &mOpenAshmemSize);\n            }\n\n            if (objectsSize == 0) {\n                free(mObjects);\n                mObjects = nullptr;\n                mObjectsCapacity = 0;\n            } else {\n                binder_size_t* objects =\n                    (binder_size_t*)realloc(mObjects, objectsSize*sizeof(binder_size_t));\n                if (objects) {\n                    mObjects = objects;\n                    mObjectsCapacity = objectsSize;\n                }\n            }\n            mObjectsSize = objectsSize;\n            mNextObjectHint = 0;\n            mObjectsSorted = false;\n        }\n\n        // We own the data, so we can just do a realloc().\n        if (desired > mDataCapacity) {\n            uint8_t* data = reallocZeroFree(mData, mDataCapacity, desired, mDeallocZero);\n            if (data) {\n                LOG_ALLOC(\"Parcel %p: continue from %zu to %zu capacity\", this, mDataCapacity,\n                        desired);\n                gParcelGlobalAllocSize += desired;\n                gParcelGlobalAllocSize -= mDataCapacity;\n                mData = data;\n                mDataCapacity = desired;\n            } else {\n                mError = NO_MEMORY;\n                return NO_MEMORY;\n            }\n        } else {\n            if (mDataSize > desired) {\n                mDataSize = desired;\n                ALOGV(\"continueWrite Setting data size of %p to %zu\", this, mDataSize);\n            }\n            if (mDataPos > desired) {\n                mDataPos = desired;\n                ALOGV(\"continueWrite Setting data pos of %p to %zu\", this, mDataPos);\n            }\n        }\n\n    } else {\n        // This is the first data.  Easy!\n        uint8_t* data = (uint8_t*)malloc(desired);\n        if (!data) {\n            mError = NO_MEMORY;\n            return NO_MEMORY;\n        }\n\n        if(!(mDataCapacity == 0 && mObjects == nullptr\n             && mObjectsCapacity == 0)) {\n            ALOGE(\"continueWrite: %zu/%p/%zu/%zu\", mDataCapacity, mObjects, mObjectsCapacity, desired);\n        }\n\n        LOG_ALLOC(\"Parcel %p: allocating with %zu capacity\", this, desired);\n        gParcelGlobalAllocSize += desired;\n        gParcelGlobalAllocCount++;\n\n        mData = data;\n        mDataSize = mDataPos = 0;\n        ALOGV(\"continueWrite Setting data size of %p to %zu\", this, mDataSize);\n        ALOGV(\"continueWrite Setting data pos of %p to %zu\", this, mDataPos);\n        mDataCapacity = desired;\n    }\n\n    return NO_ERROR;\n}\n\nvoid Parcel::initState()\n{\n    LOG_ALLOC(\"Parcel %p: initState\", this);\n    mError = NO_ERROR;\n    mData = nullptr;\n    mDataSize = 0;\n    mDataCapacity = 0;\n    mDataPos = 0;\n    ALOGV(\"initState Setting data size of %p to %zu\", this, mDataSize);\n    ALOGV(\"initState Setting data pos of %p to %zu\", this, mDataPos);\n    mSession = nullptr;\n    mObjects = nullptr;\n    mObjectsSize = 0;\n    mObjectsCapacity = 0;\n    mNextObjectHint = 0;\n    mObjectsSorted = false;\n    mHasFds = false;\n    mFdsKnown = true;\n    mAllowFds = true;\n    mDeallocZero = false;\n    mOwner = nullptr;\n    mOpenAshmemSize = 0;\n    mWorkSourceRequestHeaderPosition = 0;\n    mRequestHeaderPresent = false;\n\n    // racing multiple init leads only to multiple identical write\n    if (gMaxFds == 0) {\n        struct rlimit result;\n        if (!getrlimit(RLIMIT_NOFILE, &result)) {\n            gMaxFds = (size_t)result.rlim_cur;\n            //ALOGI(\"parcel fd limit set to %zu\", gMaxFds);\n        } else {\n            ALOGW(\"Unable to getrlimit: %s\", strerror(errno));\n            gMaxFds = 1024;\n        }\n    }\n}\n\nvoid Parcel::scanForFds() const\n{\n    bool hasFds = false;\n    for (size_t i=0; i<mObjectsSize; i++) {\n        const flat_binder_object* flat\n            = reinterpret_cast<const flat_binder_object*>(mData + mObjects[i]);\n        if (flat->hdr.type == BINDER_TYPE_FD) {\n            hasFds = true;\n            break;\n        }\n    }\n    mHasFds = hasFds;\n    mFdsKnown = true;\n}\n\nsize_t Parcel::getBlobAshmemSize() const\n{\n    // This used to return the size of all blobs that were written to ashmem, now we're returning\n    // the ashmem currently referenced by this Parcel, which should be equivalent.\n    // TODO: Remove method once ABI can be changed.\n    return mOpenAshmemSize;\n}\n\nsize_t Parcel::getOpenAshmemSize() const\n{\n    return mOpenAshmemSize;\n}\n\n// --- Parcel::Blob ---\n\nParcel::Blob::Blob() :\n        mFd(-1), mData(nullptr), mSize(0), mMutable(false) {\n}\n\nParcel::Blob::~Blob() {\n    release();\n}\n\nvoid Parcel::Blob::release() {\n    if (mFd != -1 && mData) {\n        ::munmap(mData, mSize);\n    }\n    clear();\n}\n\nvoid Parcel::Blob::init(int fd, void* data, size_t size, bool isMutable) {\n    mFd = fd;\n    mData = data;\n    mSize = size;\n    mMutable = isMutable;\n}\n\nvoid Parcel::Blob::clear() {\n    mFd = -1;\n    mData = nullptr;\n    mSize = 0;\n    mMutable = false;\n}\n\n} // namespace android\n```",
                                    "downstream_file_tokens": {
                                        "openai": 20268,
                                        "general": {
                                            "word_based": 8099,
                                            "char_based": 20103
                                        },
                                        "gemini": 24555
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "2aec032c0826ad68cd94c100173b99167bfcb10d",
                            "repo_path": "android_repos/native",
                            "result": "failure",
                            "downstream_patch_content": "commit 2aec032c0826ad68cd94c100173b99167bfcb10d\nAuthor: Steven Moreland <smoreland@google.com>\nDate:   Wed Oct 2 00:37:59 2024 +0000\n\n    libbinder: Parcel: validate read data before write\n    \n    This is slow, but it's required to prevent memory\n    corruption.\n    \n    Ignore-AOSP-First: security\n    Bug: 370840874\n    Test: fuzzer\n    Merged-In: Ibc5566ade0389221690dc90324f93394cf7fc9a5\n    Change-Id: Ibc5566ade0389221690dc90324f93394cf7fc9a5\n    (cherry picked from commit c54dad65317f851ce9d016bd90ec6a7a04da09fc)\n\ndiff --git a/libs/binder/Parcel.cpp b/libs/binder/Parcel.cpp\nindex 617708f3d4..0670307e48 100644\n--- a/libs/binder/Parcel.cpp\n+++ b/libs/binder/Parcel.cpp\n@@ -796,6 +796,10 @@ restart_write:\n         //printf(\"Writing %ld bytes, padded to %ld\\n\", len, padded);\n         uint8_t* const data = mData+mDataPos;\n \n+        if (status_t status = validateReadData(mDataPos + padded); status != OK) {\n+            return nullptr; // drops status\n+        }\n+\n         // Need to pad at end?\n         if (padded != len) {\n #if BYTE_ORDER == BIG_ENDIAN\n@@ -1313,6 +1317,10 @@ status_t Parcel::writeObject(const flat_binder_object& val, bool nullMetaData)\n     const bool enoughObjects = mObjectsSize < mObjectsCapacity;\n     if (enoughData && enoughObjects) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         *reinterpret_cast<flat_binder_object*>(mData+mDataPos) = val;\n \n         // remember if it's a file descriptor\n@@ -1505,6 +1513,10 @@ status_t Parcel::writeAligned(T val) {\n \n     if ((mDataPos+sizeof(val)) <= mDataCapacity) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         *reinterpret_cast<T*>(mData+mDataPos) = val;\n         return finishWrite(sizeof(val));\n     }\n",
                            "downstream_patch_tokens": {
                                "openai": 570,
                                "general": {
                                    "word_based": 202,
                                    "char_based": 476
                                },
                                "gemini": 730
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "libs/binder/Parcel.cpp",
                                    "total_hunks": 3,
                                    "failed_hunks": [
                                        3
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 12L)\n\n=======\n    if ((mDataPos+sizeof(val)) <= mDataCapacity) {\nrestart_write:\n        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n            return status;\n        }\n\n>>>>>>> UPSTREAM PATCH (commit c54dad65317f851ce9d016bd90ec6a7a04da09fc)",
                                            "merge_conflict_tokens": {
                                                "openai": 85,
                                                "general": {
                                                    "word_based": 24,
                                                    "char_based": 76
                                                },
                                                "gemini": 107
                                            }
                                        }
                                    ],
                                    "inline_merge_token_summary": {
                                        "gemini": 2996,
                                        "openai": 2465,
                                        "general_word": 696,
                                        "general_char": 2204
                                    },
                                    "rej_file_content": "```diff\n--- libs/binder/Parcel.cpp\n+++ libs/binder/Parcel.cpp\n@@ -2050,6 +2058,10 @@ status_t Parcel::writeAligned(T val) {\n \n     if ((mDataPos+sizeof(val)) <= mDataCapacity) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         memcpy(mData + mDataPos, &val, sizeof(val));\n         return finishWrite(sizeof(val));\n     }\n```",
                                    "rej_file_tokens": {
                                        "openai": 112,
                                        "general": {
                                            "word_based": 44,
                                            "char_based": 104
                                        },
                                        "gemini": 138
                                    },
                                    "patch_apply_output": "patching file libs/binder/Parcel.cpp\nHunk #1 succeeded at 796 (offset -415 lines).\nHunk #2 succeeded at 1317 with fuzz 1 (offset -486 lines).\nHunk #3 FAILED at 2050.\n1 out of 3 hunks FAILED -- saving rejects to file libs/binder/Parcel.cpp.rej",
                                    "inline_merge_output": "patching file libs/binder/Parcel.cpp\nHunk #1 merged at 1218-1221.\nHunk #2 already applied at 1810-1813.\nHunk #3 NOT MERGED at 2061-2069.",
                                    "upstream_file_tokens": {
                                        "openai": 27268,
                                        "general": {
                                            "word_based": 10691,
                                            "char_based": 27877
                                        },
                                        "gemini": 32942
                                    },
                                    "downstream_file_content": "```cpp\n/*\n * Copyright (C) 2005 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"Parcel\"\n//#define LOG_NDEBUG 0\n\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <linux/sched.h>\n#include <pthread.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <unistd.h>\n\n#include <binder/Binder.h>\n#include <binder/BpBinder.h>\n#include <binder/IPCThreadState.h>\n#include <binder/Parcel.h>\n#include <binder/ProcessState.h>\n#include <binder/Stability.h>\n#include <binder/Status.h>\n#include <binder/TextOutput.h>\n\n#include <cutils/ashmem.h>\n#include <cutils/compiler.h>\n#include <utils/Flattenable.h>\n#include <utils/Log.h>\n#include <utils/String16.h>\n#include <utils/String8.h>\n#include <utils/misc.h>\n\n#include \"RpcState.h\"\n#include \"Static.h\"\n#include \"Utils.h\"\n#include \"binder_module.h\"\n\n#define LOG_REFS(...)\n//#define LOG_REFS(...) ALOG(LOG_DEBUG, LOG_TAG, __VA_ARGS__)\n#define LOG_ALLOC(...)\n//#define LOG_ALLOC(...) ALOG(LOG_DEBUG, LOG_TAG, __VA_ARGS__)\n\n// ---------------------------------------------------------------------------\n\n// This macro should never be used at runtime, as a too large value\n// of s could cause an integer overflow. Instead, you should always\n// use the wrapper function pad_size()\n#define PAD_SIZE_UNSAFE(s) (((s)+3)&~3)\n\nstatic size_t pad_size(size_t s) {\n    if (s > (std::numeric_limits<size_t>::max() - 3)) {\n        LOG_ALWAYS_FATAL(\"pad size too big %zu\", s);\n    }\n    return PAD_SIZE_UNSAFE(s);\n}\n\n// Note: must be kept in sync with android/os/StrictMode.java's PENALTY_GATHER\n#define STRICT_MODE_PENALTY_GATHER (1 << 31)\n\nnamespace android {\n\n// many things compile this into prebuilts on the stack\n#ifdef __LP64__\nstatic_assert(sizeof(Parcel) == 120);\n#else\nstatic_assert(sizeof(Parcel) == 60);\n#endif\n\nstatic std::atomic<size_t> gParcelGlobalAllocCount;\nstatic std::atomic<size_t> gParcelGlobalAllocSize;\n\nstatic size_t gMaxFds = 0;\n\n// Maximum size of a blob to transfer in-place.\nstatic const size_t BLOB_INPLACE_LIMIT = 16 * 1024;\n\nenum {\n    BLOB_INPLACE = 0,\n    BLOB_ASHMEM_IMMUTABLE = 1,\n    BLOB_ASHMEM_MUTABLE = 2,\n};\n\nstatic void acquire_object(const sp<ProcessState>& proc,\n    const flat_binder_object& obj, const void* who, size_t* outAshmemSize)\n{\n    switch (obj.hdr.type) {\n        case BINDER_TYPE_BINDER:\n            if (obj.binder) {\n                LOG_REFS(\"Parcel %p acquiring reference on local %p\", who, obj.cookie);\n                reinterpret_cast<IBinder*>(obj.cookie)->incStrong(who);\n            }\n            return;\n        case BINDER_TYPE_HANDLE: {\n            const sp<IBinder> b = proc->getStrongProxyForHandle(obj.handle);\n            if (b != nullptr) {\n                LOG_REFS(\"Parcel %p acquiring reference on remote %p\", who, b.get());\n                b->incStrong(who);\n            }\n            return;\n        }\n        case BINDER_TYPE_FD: {\n            if ((obj.cookie != 0) && (outAshmemSize != nullptr) && ashmem_valid(obj.handle)) {\n                // If we own an ashmem fd, keep track of how much memory it refers to.\n                int size = ashmem_get_size_region(obj.handle);\n                if (size > 0) {\n                    *outAshmemSize += size;\n                }\n            }\n            return;\n        }\n    }\n\n    ALOGD(\"Invalid object type 0x%08x\", obj.hdr.type);\n}\n\nstatic void release_object(const sp<ProcessState>& proc,\n    const flat_binder_object& obj, const void* who, size_t* outAshmemSize)\n{\n    switch (obj.hdr.type) {\n        case BINDER_TYPE_BINDER:\n            if (obj.binder) {\n                LOG_REFS(\"Parcel %p releasing reference on local %p\", who, obj.cookie);\n                reinterpret_cast<IBinder*>(obj.cookie)->decStrong(who);\n            }\n            return;\n        case BINDER_TYPE_HANDLE: {\n            const sp<IBinder> b = proc->getStrongProxyForHandle(obj.handle);\n            if (b != nullptr) {\n                LOG_REFS(\"Parcel %p releasing reference on remote %p\", who, b.get());\n                b->decStrong(who);\n            }\n            return;\n        }\n        case BINDER_TYPE_FD: {\n            if (obj.cookie != 0) { // owned\n                if ((outAshmemSize != nullptr) && ashmem_valid(obj.handle)) {\n                    int size = ashmem_get_size_region(obj.handle);\n                    if (size > 0) {\n                        // ashmem size might have changed since last time it was accounted for, e.g.\n                        // in acquire_object(). Value of *outAshmemSize is not critical since we are\n                        // releasing the object anyway. Check for integer overflow condition.\n                        *outAshmemSize -= std::min(*outAshmemSize, static_cast<size_t>(size));\n                    }\n                }\n\n                close(obj.handle);\n            }\n            return;\n        }\n    }\n\n    ALOGE(\"Invalid object type 0x%08x\", obj.hdr.type);\n}\n\nstatus_t Parcel::finishFlattenBinder(const sp<IBinder>& binder)\n{\n    internal::Stability::tryMarkCompilationUnit(binder.get());\n    auto category = internal::Stability::getCategory(binder.get());\n    return writeInt32(category.repr());\n}\n\nstatus_t Parcel::finishUnflattenBinder(\n    const sp<IBinder>& binder, sp<IBinder>* out) const\n{\n    int32_t stability;\n    status_t status = readInt32(&stability);\n    if (status != OK) return status;\n\n    status = internal::Stability::setRepr(binder.get(), stability, true /*log*/);\n    if (status != OK) return status;\n\n    *out = binder;\n    return OK;\n}\n\nstatic constexpr inline int schedPolicyMask(int policy, int priority) {\n    return (priority & FLAT_BINDER_FLAG_PRIORITY_MASK) | ((policy & 3) << FLAT_BINDER_FLAG_SCHED_POLICY_SHIFT);\n}\n\nstatus_t Parcel::flattenBinder(const sp<IBinder>& binder)\n{\n    if (isForRpc()) {\n        if (binder) {\n            status_t status = writeInt32(1); // non-null\n            if (status != OK) return status;\n            RpcAddress address = RpcAddress::zero();\n            status = mSession->state()->onBinderLeaving(mSession, binder, &address);\n            if (status != OK) return status;\n            status = address.writeToParcel(this);\n            if (status != OK) return status;\n        } else {\n            status_t status = writeInt32(0); // null\n            if (status != OK) return status;\n        }\n        return finishFlattenBinder(binder);\n    }\n\n    flat_binder_object obj;\n    obj.flags = FLAT_BINDER_FLAG_ACCEPTS_FDS;\n\n    int schedBits = 0;\n    if (!IPCThreadState::self()->backgroundSchedulingDisabled()) {\n        schedBits = schedPolicyMask(SCHED_NORMAL, 19);\n    }\n\n    if (binder != nullptr) {\n        BBinder *local = binder->localBinder();\n        if (!local) {\n            BpBinder *proxy = binder->remoteBinder();\n            if (proxy == nullptr) {\n                ALOGE(\"null proxy\");\n            } else {\n                if (proxy->isRpcBinder()) {\n                    ALOGE(\"Sending a socket binder over RPC is prohibited\");\n                    return INVALID_OPERATION;\n                }\n            }\n            const int32_t handle = proxy ? proxy->getPrivateAccessorForId().binderHandle() : 0;\n            obj.hdr.type = BINDER_TYPE_HANDLE;\n            obj.binder = 0; /* Don't pass uninitialized stack data to a remote process */\n            obj.handle = handle;\n            obj.cookie = 0;\n        } else {\n            int policy = local->getMinSchedulerPolicy();\n            int priority = local->getMinSchedulerPriority();\n\n            if (policy != 0 || priority != 0) {\n                // override value, since it is set explicitly\n                schedBits = schedPolicyMask(policy, priority);\n            }\n            if (local->isRequestingSid()) {\n                obj.flags |= FLAT_BINDER_FLAG_TXN_SECURITY_CTX;\n            }\n            if (local->isInheritRt()) {\n                obj.flags |= FLAT_BINDER_FLAG_INHERIT_RT;\n            }\n            obj.hdr.type = BINDER_TYPE_BINDER;\n            obj.binder = reinterpret_cast<uintptr_t>(local->getWeakRefs());\n            obj.cookie = reinterpret_cast<uintptr_t>(local);\n        }\n    } else {\n        obj.hdr.type = BINDER_TYPE_BINDER;\n        obj.binder = 0;\n        obj.cookie = 0;\n    }\n\n    obj.flags |= schedBits;\n\n    status_t status = writeObject(obj, false);\n    if (status != OK) return status;\n\n    return finishFlattenBinder(binder);\n}\n\nstatus_t Parcel::unflattenBinder(sp<IBinder>* out) const\n{\n    if (isForRpc()) {\n        LOG_ALWAYS_FATAL_IF(mSession == nullptr, \"RpcSession required to read from remote parcel\");\n\n        int32_t isNull;\n        status_t status = readInt32(&isNull);\n        if (status != OK) return status;\n\n        sp<IBinder> binder;\n\n        if (isNull & 1) {\n            auto addr = RpcAddress::zero();\n            status_t status = addr.readFromParcel(*this);\n            if (status != OK) return status;\n            binder = mSession->state()->onBinderEntering(mSession, addr);\n        }\n\n        return finishUnflattenBinder(binder, out);\n    }\n\n    const flat_binder_object* flat = readObject(false);\n\n    if (flat) {\n        switch (flat->hdr.type) {\n            case BINDER_TYPE_BINDER: {\n                sp<IBinder> binder =\n                        sp<IBinder>::fromExisting(reinterpret_cast<IBinder*>(flat->cookie));\n                return finishUnflattenBinder(binder, out);\n            }\n            case BINDER_TYPE_HANDLE: {\n                sp<IBinder> binder =\n                    ProcessState::self()->getStrongProxyForHandle(flat->handle);\n                return finishUnflattenBinder(binder, out);\n            }\n        }\n    }\n    return BAD_TYPE;\n}\n\n// ---------------------------------------------------------------------------\n\nParcel::Parcel()\n{\n    LOG_ALLOC(\"Parcel %p: constructing\", this);\n    initState();\n}\n\nParcel::~Parcel()\n{\n    freeDataNoInit();\n    LOG_ALLOC(\"Parcel %p: destroyed\", this);\n}\n\nsize_t Parcel::getGlobalAllocSize() {\n    return gParcelGlobalAllocSize.load();\n}\n\nsize_t Parcel::getGlobalAllocCount() {\n    return gParcelGlobalAllocCount.load();\n}\n\nconst uint8_t* Parcel::data() const\n{\n    return mData;\n}\n\nsize_t Parcel::dataSize() const\n{\n    return (mDataSize > mDataPos ? mDataSize : mDataPos);\n}\n\nsize_t Parcel::dataAvail() const\n{\n    size_t result = dataSize() - dataPosition();\n    if (result > INT32_MAX) {\n        LOG_ALWAYS_FATAL(\"result too big: %zu\", result);\n    }\n    return result;\n}\n\nsize_t Parcel::dataPosition() const\n{\n    return mDataPos;\n}\n\nsize_t Parcel::dataCapacity() const\n{\n    return mDataCapacity;\n}\n\nstatus_t Parcel::setDataSize(size_t size)\n{\n    if (size > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    status_t err;\n    err = continueWrite(size);\n    if (err == NO_ERROR) {\n        mDataSize = size;\n        ALOGV(\"setDataSize Setting data size of %p to %zu\", this, mDataSize);\n    }\n    return err;\n}\n\nvoid Parcel::setDataPosition(size_t pos) const\n{\n    if (pos > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        LOG_ALWAYS_FATAL(\"pos too big: %zu\", pos);\n    }\n\n    mDataPos = pos;\n    mNextObjectHint = 0;\n    mObjectsSorted = false;\n}\n\nstatus_t Parcel::setDataCapacity(size_t size)\n{\n    if (size > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    if (size > mDataCapacity) return continueWrite(size);\n    return NO_ERROR;\n}\n\nstatus_t Parcel::setData(const uint8_t* buffer, size_t len)\n{\n    if (len > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    status_t err = restartWrite(len);\n    if (err == NO_ERROR) {\n        memcpy(const_cast<uint8_t*>(data()), buffer, len);\n        mDataSize = len;\n        mFdsKnown = false;\n    }\n    return err;\n}\n\nstatus_t Parcel::appendFrom(const Parcel *parcel, size_t offset, size_t len)\n{\n    if (parcel->isForRpc() != isForRpc()) {\n        ALOGE(\"Cannot append Parcel of one format to another.\");\n        return BAD_TYPE;\n    }\n\n    status_t err;\n    const uint8_t *data = parcel->mData;\n    const binder_size_t *objects = parcel->mObjects;\n    size_t size = parcel->mObjectsSize;\n    int startPos = mDataPos;\n    int firstIndex = -1, lastIndex = -2;\n\n    if (len == 0) {\n        return NO_ERROR;\n    }\n\n    if (len > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    // range checks against the source parcel size\n    if ((offset > parcel->mDataSize)\n            || (len > parcel->mDataSize)\n            || (offset + len > parcel->mDataSize)) {\n        return BAD_VALUE;\n    }\n\n    // Count objects in range\n    for (int i = 0; i < (int) size; i++) {\n        size_t off = objects[i];\n        if ((off >= offset) && (off + sizeof(flat_binder_object) <= offset + len)) {\n            if (firstIndex == -1) {\n                firstIndex = i;\n            }\n            lastIndex = i;\n        }\n    }\n    int numObjects = lastIndex - firstIndex + 1;\n\n    if ((mDataSize+len) > mDataCapacity) {\n        // grow data\n        err = growData(len);\n        if (err != NO_ERROR) {\n            return err;\n        }\n    }\n\n    // append data\n    memcpy(mData + mDataPos, data + offset, len);\n    mDataPos += len;\n    mDataSize += len;\n\n    err = NO_ERROR;\n\n    if (numObjects > 0) {\n        const sp<ProcessState> proc(ProcessState::self());\n        // grow objects\n        if (mObjectsCapacity < mObjectsSize + numObjects) {\n            if ((size_t) numObjects > SIZE_MAX - mObjectsSize) return NO_MEMORY; // overflow\n            if (mObjectsSize + numObjects > SIZE_MAX / 3) return NO_MEMORY; // overflow\n            size_t newSize = ((mObjectsSize + numObjects)*3)/2;\n            if (newSize > SIZE_MAX / sizeof(binder_size_t)) return NO_MEMORY; // overflow\n            binder_size_t *objects =\n                (binder_size_t*)realloc(mObjects, newSize*sizeof(binder_size_t));\n            if (objects == (binder_size_t*)nullptr) {\n                return NO_MEMORY;\n            }\n            mObjects = objects;\n            mObjectsCapacity = newSize;\n        }\n\n        // append and acquire objects\n        int idx = mObjectsSize;\n        for (int i = firstIndex; i <= lastIndex; i++) {\n            size_t off = objects[i] - offset + startPos;\n            mObjects[idx++] = off;\n            mObjectsSize++;\n\n            flat_binder_object* flat\n                = reinterpret_cast<flat_binder_object*>(mData + off);\n            acquire_object(proc, *flat, this, &mOpenAshmemSize);\n\n            if (flat->hdr.type == BINDER_TYPE_FD) {\n                // If this is a file descriptor, we need to dup it so the\n                // new Parcel now owns its own fd, and can declare that we\n                // officially know we have fds.\n                flat->handle = fcntl(flat->handle, F_DUPFD_CLOEXEC, 0);\n                flat->cookie = 1;\n                mHasFds = mFdsKnown = true;\n                if (!mAllowFds) {\n                    err = FDS_NOT_ALLOWED;\n                }\n            }\n        }\n    }\n\n    return err;\n}\n\nint Parcel::compareData(const Parcel& other) {\n    size_t size = dataSize();\n    if (size != other.dataSize()) {\n        return size < other.dataSize() ? -1 : 1;\n    }\n    return memcmp(data(), other.data(), size);\n}\n\nbool Parcel::allowFds() const\n{\n    return mAllowFds;\n}\n\nbool Parcel::pushAllowFds(bool allowFds)\n{\n    const bool origValue = mAllowFds;\n    if (!allowFds) {\n        mAllowFds = false;\n    }\n    return origValue;\n}\n\nvoid Parcel::restoreAllowFds(bool lastValue)\n{\n    mAllowFds = lastValue;\n}\n\nbool Parcel::hasFileDescriptors() const\n{\n    if (!mFdsKnown) {\n        scanForFds();\n    }\n    return mHasFds;\n}\n\nvoid Parcel::markSensitive() const\n{\n    mDeallocZero = true;\n}\n\nvoid Parcel::markForBinder(const sp<IBinder>& binder) {\n    LOG_ALWAYS_FATAL_IF(mData != nullptr, \"format must be set before data is written\");\n\n    if (binder && binder->remoteBinder() && binder->remoteBinder()->isRpcBinder()) {\n        markForRpc(binder->remoteBinder()->getPrivateAccessorForId().rpcSession());\n    }\n}\n\nvoid Parcel::markForRpc(const sp<RpcSession>& session) {\n    LOG_ALWAYS_FATAL_IF(mData != nullptr && mOwner == nullptr,\n                        \"format must be set before data is written OR on IPC data\");\n\n    LOG_ALWAYS_FATAL_IF(session == nullptr, \"markForRpc requires session\");\n    mSession = session;\n}\n\nbool Parcel::isForRpc() const {\n    return mSession != nullptr;\n}\n\nvoid Parcel::updateWorkSourceRequestHeaderPosition() const {\n    // Only update the request headers once. We only want to point\n    // to the first headers read/written.\n    if (!mRequestHeaderPresent) {\n        mWorkSourceRequestHeaderPosition = dataPosition();\n        mRequestHeaderPresent = true;\n    }\n}\n\n#if defined(__ANDROID_VNDK__)\nconstexpr int32_t kHeader = B_PACK_CHARS('V', 'N', 'D', 'R');\n#else\nconstexpr int32_t kHeader = B_PACK_CHARS('S', 'Y', 'S', 'T');\n#endif\n\n// Write RPC headers.  (previously just the interface token)\nstatus_t Parcel::writeInterfaceToken(const String16& interface)\n{\n    return writeInterfaceToken(interface.string(), interface.size());\n}\n\nstatus_t Parcel::writeInterfaceToken(const char16_t* str, size_t len) {\n    if (CC_LIKELY(!isForRpc())) {\n        const IPCThreadState* threadState = IPCThreadState::self();\n        writeInt32(threadState->getStrictModePolicy() | STRICT_MODE_PENALTY_GATHER);\n        updateWorkSourceRequestHeaderPosition();\n        writeInt32(threadState->shouldPropagateWorkSource() ? threadState->getCallingWorkSourceUid()\n                                                            : IPCThreadState::kUnsetWorkSource);\n        writeInt32(kHeader);\n    }\n\n    // currently the interface identification token is just its name as a string\n    return writeString16(str, len);\n}\n\nbool Parcel::replaceCallingWorkSourceUid(uid_t uid)\n{\n    if (!mRequestHeaderPresent) {\n        return false;\n    }\n\n    const size_t initialPosition = dataPosition();\n    setDataPosition(mWorkSourceRequestHeaderPosition);\n    status_t err = writeInt32(uid);\n    setDataPosition(initialPosition);\n    return err == NO_ERROR;\n}\n\nuid_t Parcel::readCallingWorkSourceUid() const\n{\n    if (!mRequestHeaderPresent) {\n        return IPCThreadState::kUnsetWorkSource;\n    }\n\n    const size_t initialPosition = dataPosition();\n    setDataPosition(mWorkSourceRequestHeaderPosition);\n    uid_t uid = readInt32();\n    setDataPosition(initialPosition);\n    return uid;\n}\n\nbool Parcel::checkInterface(IBinder* binder) const\n{\n    return enforceInterface(binder->getInterfaceDescriptor());\n}\n\nbool Parcel::enforceInterface(const String16& interface,\n                              IPCThreadState* threadState) const\n{\n    return enforceInterface(interface.string(), interface.size(), threadState);\n}\n\nbool Parcel::enforceInterface(const char16_t* interface,\n                              size_t len,\n                              IPCThreadState* threadState) const\n{\n    if (CC_LIKELY(!isForRpc())) {\n        // StrictModePolicy.\n        int32_t strictPolicy = readInt32();\n        if (threadState == nullptr) {\n            threadState = IPCThreadState::self();\n        }\n        if ((threadState->getLastTransactionBinderFlags() & IBinder::FLAG_ONEWAY) != 0) {\n            // For one-way calls, the callee is running entirely\n            // disconnected from the caller, so disable StrictMode entirely.\n            // Not only does disk/network usage not impact the caller, but\n            // there's no way to communicate back violations anyway.\n            threadState->setStrictModePolicy(0);\n        } else {\n            threadState->setStrictModePolicy(strictPolicy);\n        }\n        // WorkSource.\n        updateWorkSourceRequestHeaderPosition();\n        int32_t workSource = readInt32();\n        threadState->setCallingWorkSourceUidWithoutPropagation(workSource);\n        // vendor header\n        int32_t header = readInt32();\n        if (header != kHeader) {\n            ALOGE(\"Expecting header 0x%x but found 0x%x. Mixing copies of libbinder?\", kHeader,\n                  header);\n            return false;\n        }\n    }\n\n    // Interface descriptor.\n    size_t parcel_interface_len;\n    const char16_t* parcel_interface = readString16Inplace(&parcel_interface_len);\n    if (len == parcel_interface_len &&\n            (!len || !memcmp(parcel_interface, interface, len * sizeof (char16_t)))) {\n        return true;\n    } else {\n        ALOGW(\"**** enforceInterface() expected '%s' but read '%s'\",\n              String8(interface, len).string(),\n              String8(parcel_interface, parcel_interface_len).string());\n        return false;\n    }\n}\n\nsize_t Parcel::objectsCount() const\n{\n    return mObjectsSize;\n}\n\nstatus_t Parcel::errorCheck() const\n{\n    return mError;\n}\n\nvoid Parcel::setError(status_t err)\n{\n    mError = err;\n}\n\nstatus_t Parcel::finishWrite(size_t len)\n{\n    if (len > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    //printf(\"Finish write of %d\\n\", len);\n    mDataPos += len;\n    ALOGV(\"finishWrite Setting data pos of %p to %zu\", this, mDataPos);\n    if (mDataPos > mDataSize) {\n        mDataSize = mDataPos;\n        ALOGV(\"finishWrite Setting data size of %p to %zu\", this, mDataSize);\n    }\n    //printf(\"New pos=%d, size=%d\\n\", mDataPos, mDataSize);\n    return NO_ERROR;\n}\n\nstatus_t Parcel::writeUnpadded(const void* data, size_t len)\n{\n    if (len > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    size_t end = mDataPos + len;\n    if (end < mDataPos) {\n        // integer overflow\n        return BAD_VALUE;\n    }\n\n    if (end <= mDataCapacity) {\nrestart_write:\n        memcpy(mData+mDataPos, data, len);\n        return finishWrite(len);\n    }\n\n    status_t err = growData(len);\n    if (err == NO_ERROR) goto restart_write;\n    return err;\n}\n\nstatus_t Parcel::write(const void* data, size_t len)\n{\n    if (len > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    void* const d = writeInplace(len);\n    if (d) {\n        memcpy(d, data, len);\n        return NO_ERROR;\n    }\n    return mError;\n}\n\nvoid* Parcel::writeInplace(size_t len)\n{\n    if (len > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return nullptr;\n    }\n\n    const size_t padded = pad_size(len);\n\n    // sanity check for integer overflow\n    if (mDataPos+padded < mDataPos) {\n        return nullptr;\n    }\n\n    if ((mDataPos+padded) <= mDataCapacity) {\nrestart_write:\n        //printf(\"Writing %ld bytes, padded to %ld\\n\", len, padded);\n        uint8_t* const data = mData+mDataPos;\n\n        if (status_t status = validateReadData(mDataPos + padded); status != OK) {\n            return nullptr; // drops status\n        }\n\n        // Need to pad at end?\n        if (padded != len) {\n#if BYTE_ORDER == BIG_ENDIAN\n            static const uint32_t mask[4] = {\n                0x00000000, 0xffffff00, 0xffff0000, 0xff000000\n            };\n#endif\n#if BYTE_ORDER == LITTLE_ENDIAN\n            static const uint32_t mask[4] = {\n                0x00000000, 0x00ffffff, 0x0000ffff, 0x000000ff\n            };\n#endif\n            //printf(\"Applying pad mask: %p to %p\\n\", (void*)mask[padded-len],\n            //    *reinterpret_cast<void**>(data+padded-4));\n            *reinterpret_cast<uint32_t*>(data+padded-4) &= mask[padded-len];\n        }\n\n        finishWrite(padded);\n        return data;\n    }\n\n    status_t err = growData(padded);\n    if (err == NO_ERROR) goto restart_write;\n    return nullptr;\n}\n\nstatus_t Parcel::writeUtf8AsUtf16(const std::string& str) {\n    const uint8_t* strData = (uint8_t*)str.data();\n    const size_t strLen= str.length();\n    const ssize_t utf16Len = utf8_to_utf16_length(strData, strLen);\n    if (utf16Len < 0 || utf16Len > std::numeric_limits<int32_t>::max()) {\n        return BAD_VALUE;\n    }\n\n    status_t err = writeInt32(utf16Len);\n    if (err) {\n        return err;\n    }\n\n    // Allocate enough bytes to hold our converted string and its terminating NULL.\n    void* dst = writeInplace((utf16Len + 1) * sizeof(char16_t));\n    if (!dst) {\n        return NO_MEMORY;\n    }\n\n    utf8_to_utf16(strData, strLen, (char16_t*)dst, (size_t) utf16Len + 1);\n\n    return NO_ERROR;\n}\n\n\nstatus_t Parcel::writeUtf8AsUtf16(const std::optional<std::string>& str) { return writeData(str); }\nstatus_t Parcel::writeUtf8AsUtf16(const std::unique_ptr<std::string>& str) { return writeData(str); }\n\nstatus_t Parcel::writeString16(const std::optional<String16>& str) { return writeData(str); }\nstatus_t Parcel::writeString16(const std::unique_ptr<String16>& str) { return writeData(str); }\n\nstatus_t Parcel::writeByteVector(const std::vector<int8_t>& val) { return writeData(val); }\nstatus_t Parcel::writeByteVector(const std::optional<std::vector<int8_t>>& val) { return writeData(val); }\nstatus_t Parcel::writeByteVector(const std::unique_ptr<std::vector<int8_t>>& val) { return writeData(val); }\nstatus_t Parcel::writeByteVector(const std::vector<uint8_t>& val) { return writeData(val); }\nstatus_t Parcel::writeByteVector(const std::optional<std::vector<uint8_t>>& val) { return writeData(val); }\nstatus_t Parcel::writeByteVector(const std::unique_ptr<std::vector<uint8_t>>& val){ return writeData(val); }\nstatus_t Parcel::writeInt32Vector(const std::vector<int32_t>& val) { return writeData(val); }\nstatus_t Parcel::writeInt32Vector(const std::optional<std::vector<int32_t>>& val) { return writeData(val); }\nstatus_t Parcel::writeInt32Vector(const std::unique_ptr<std::vector<int32_t>>& val) { return writeData(val); }\nstatus_t Parcel::writeInt64Vector(const std::vector<int64_t>& val) { return writeData(val); }\nstatus_t Parcel::writeInt64Vector(const std::optional<std::vector<int64_t>>& val) { return writeData(val); }\nstatus_t Parcel::writeInt64Vector(const std::unique_ptr<std::vector<int64_t>>& val) { return writeData(val); }\nstatus_t Parcel::writeUint64Vector(const std::vector<uint64_t>& val) { return writeData(val); }\nstatus_t Parcel::writeUint64Vector(const std::optional<std::vector<uint64_t>>& val) { return writeData(val); }\nstatus_t Parcel::writeUint64Vector(const std::unique_ptr<std::vector<uint64_t>>& val) { return writeData(val); }\nstatus_t Parcel::writeFloatVector(const std::vector<float>& val) { return writeData(val); }\nstatus_t Parcel::writeFloatVector(const std::optional<std::vector<float>>& val) { return writeData(val); }\nstatus_t Parcel::writeFloatVector(const std::unique_ptr<std::vector<float>>& val) { return writeData(val); }\nstatus_t Parcel::writeDoubleVector(const std::vector<double>& val) { return writeData(val); }\nstatus_t Parcel::writeDoubleVector(const std::optional<std::vector<double>>& val) { return writeData(val); }\nstatus_t Parcel::writeDoubleVector(const std::unique_ptr<std::vector<double>>& val) { return writeData(val); }\nstatus_t Parcel::writeBoolVector(const std::vector<bool>& val) { return writeData(val); }\nstatus_t Parcel::writeBoolVector(const std::optional<std::vector<bool>>& val) { return writeData(val); }\nstatus_t Parcel::writeBoolVector(const std::unique_ptr<std::vector<bool>>& val) { return writeData(val); }\nstatus_t Parcel::writeCharVector(const std::vector<char16_t>& val) { return writeData(val); }\nstatus_t Parcel::writeCharVector(const std::optional<std::vector<char16_t>>& val) { return writeData(val); }\nstatus_t Parcel::writeCharVector(const std::unique_ptr<std::vector<char16_t>>& val) { return writeData(val); }\n\nstatus_t Parcel::writeString16Vector(const std::vector<String16>& val) { return writeData(val); }\nstatus_t Parcel::writeString16Vector(\n        const std::optional<std::vector<std::optional<String16>>>& val) { return writeData(val); }\nstatus_t Parcel::writeString16Vector(\n        const std::unique_ptr<std::vector<std::unique_ptr<String16>>>& val) { return writeData(val); }\nstatus_t Parcel::writeUtf8VectorAsUtf16Vector(\n                        const std::optional<std::vector<std::optional<std::string>>>& val) { return writeData(val); }\nstatus_t Parcel::writeUtf8VectorAsUtf16Vector(\n                        const std::unique_ptr<std::vector<std::unique_ptr<std::string>>>& val) { return writeData(val); }\nstatus_t Parcel::writeUtf8VectorAsUtf16Vector(const std::vector<std::string>& val) { return writeData(val); }\n\nstatus_t Parcel::writeUniqueFileDescriptorVector(const std::vector<base::unique_fd>& val) { return writeData(val); }\nstatus_t Parcel::writeUniqueFileDescriptorVector(const std::optional<std::vector<base::unique_fd>>& val) { return writeData(val); }\nstatus_t Parcel::writeUniqueFileDescriptorVector(const std::unique_ptr<std::vector<base::unique_fd>>& val) { return writeData(val); }\n\nstatus_t Parcel::writeStrongBinderVector(const std::vector<sp<IBinder>>& val) { return writeData(val); }\nstatus_t Parcel::writeStrongBinderVector(const std::optional<std::vector<sp<IBinder>>>& val) { return writeData(val); }\nstatus_t Parcel::writeStrongBinderVector(const std::unique_ptr<std::vector<sp<IBinder>>>& val) { return writeData(val); }\n\nstatus_t Parcel::writeParcelable(const Parcelable& parcelable) { return writeData(parcelable); }\n\nstatus_t Parcel::readUtf8FromUtf16(std::optional<std::string>* str) const { return readData(str); }\nstatus_t Parcel::readUtf8FromUtf16(std::unique_ptr<std::string>* str) const { return readData(str); }\n\nstatus_t Parcel::readString16(std::optional<String16>* pArg) const { return readData(pArg); }\nstatus_t Parcel::readString16(std::unique_ptr<String16>* pArg) const { return readData(pArg); }\n\nstatus_t Parcel::readByteVector(std::vector<int8_t>* val) const { return readData(val); }\nstatus_t Parcel::readByteVector(std::vector<uint8_t>* val) const { return readData(val); }\nstatus_t Parcel::readByteVector(std::optional<std::vector<int8_t>>* val) const { return readData(val); }\nstatus_t Parcel::readByteVector(std::unique_ptr<std::vector<int8_t>>* val) const { return readData(val); }\nstatus_t Parcel::readByteVector(std::optional<std::vector<uint8_t>>* val) const { return readData(val); }\nstatus_t Parcel::readByteVector(std::unique_ptr<std::vector<uint8_t>>* val) const { return readData(val); }\nstatus_t Parcel::readInt32Vector(std::optional<std::vector<int32_t>>* val) const { return readData(val); }\nstatus_t Parcel::readInt32Vector(std::unique_ptr<std::vector<int32_t>>* val) const { return readData(val); }\nstatus_t Parcel::readInt32Vector(std::vector<int32_t>* val) const { return readData(val); }\nstatus_t Parcel::readInt64Vector(std::optional<std::vector<int64_t>>* val) const { return readData(val); }\nstatus_t Parcel::readInt64Vector(std::unique_ptr<std::vector<int64_t>>* val) const { return readData(val); }\nstatus_t Parcel::readInt64Vector(std::vector<int64_t>* val) const { return readData(val); }\nstatus_t Parcel::readUint64Vector(std::optional<std::vector<uint64_t>>* val) const { return readData(val); }\nstatus_t Parcel::readUint64Vector(std::unique_ptr<std::vector<uint64_t>>* val) const { return readData(val); }\nstatus_t Parcel::readUint64Vector(std::vector<uint64_t>* val) const { return readData(val); }\nstatus_t Parcel::readFloatVector(std::optional<std::vector<float>>* val) const { return readData(val); }\nstatus_t Parcel::readFloatVector(std::unique_ptr<std::vector<float>>* val) const { return readData(val); }\nstatus_t Parcel::readFloatVector(std::vector<float>* val) const { return readData(val); }\nstatus_t Parcel::readDoubleVector(std::optional<std::vector<double>>* val) const { return readData(val); }\nstatus_t Parcel::readDoubleVector(std::unique_ptr<std::vector<double>>* val) const { return readData(val); }\nstatus_t Parcel::readDoubleVector(std::vector<double>* val) const { return readData(val); }\nstatus_t Parcel::readBoolVector(std::optional<std::vector<bool>>* val) const { return readData(val); }\nstatus_t Parcel::readBoolVector(std::unique_ptr<std::vector<bool>>* val) const { return readData(val); }\nstatus_t Parcel::readBoolVector(std::vector<bool>* val) const { return readData(val); }\nstatus_t Parcel::readCharVector(std::optional<std::vector<char16_t>>* val) const { return readData(val); }\nstatus_t Parcel::readCharVector(std::unique_ptr<std::vector<char16_t>>* val) const { return readData(val); }\nstatus_t Parcel::readCharVector(std::vector<char16_t>* val) const { return readData(val); }\n\nstatus_t Parcel::readString16Vector(\n        std::optional<std::vector<std::optional<String16>>>* val) const { return readData(val); }\nstatus_t Parcel::readString16Vector(\n        std::unique_ptr<std::vector<std::unique_ptr<String16>>>* val) const { return readData(val); }\nstatus_t Parcel::readString16Vector(std::vector<String16>* val) const { return readData(val); }\nstatus_t Parcel::readUtf8VectorFromUtf16Vector(\n        std::optional<std::vector<std::optional<std::string>>>* val) const { return readData(val); }\nstatus_t Parcel::readUtf8VectorFromUtf16Vector(\n        std::unique_ptr<std::vector<std::unique_ptr<std::string>>>* val) const { return readData(val); }\nstatus_t Parcel::readUtf8VectorFromUtf16Vector(std::vector<std::string>* val) const { return readData(val); }\n\nstatus_t Parcel::readUniqueFileDescriptorVector(std::optional<std::vector<base::unique_fd>>* val) const { return readData(val); }\nstatus_t Parcel::readUniqueFileDescriptorVector(std::unique_ptr<std::vector<base::unique_fd>>* val) const { return readData(val); }\nstatus_t Parcel::readUniqueFileDescriptorVector(std::vector<base::unique_fd>* val) const { return readData(val); }\n\nstatus_t Parcel::readStrongBinderVector(std::optional<std::vector<sp<IBinder>>>* val) const { return readData(val); }\nstatus_t Parcel::readStrongBinderVector(std::unique_ptr<std::vector<sp<IBinder>>>* val) const { return readData(val); }\nstatus_t Parcel::readStrongBinderVector(std::vector<sp<IBinder>>* val) const { return readData(val); }\n\nstatus_t Parcel::readParcelable(Parcelable* parcelable) const { return readData(parcelable); }\n\nstatus_t Parcel::writeInt32(int32_t val)\n{\n    return writeAligned(val);\n}\n\nstatus_t Parcel::writeUint32(uint32_t val)\n{\n    return writeAligned(val);\n}\n\nstatus_t Parcel::writeInt32Array(size_t len, const int32_t *val) {\n    if (len > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    if (!val) {\n        return writeInt32(-1);\n    }\n    status_t ret = writeInt32(static_cast<uint32_t>(len));\n    if (ret == NO_ERROR) {\n        ret = write(val, len * sizeof(*val));\n    }\n    return ret;\n}\nstatus_t Parcel::writeByteArray(size_t len, const uint8_t *val) {\n    if (len > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    if (!val) {\n        return writeInt32(-1);\n    }\n    status_t ret = writeInt32(static_cast<uint32_t>(len));\n    if (ret == NO_ERROR) {\n        ret = write(val, len * sizeof(*val));\n    }\n    return ret;\n}\n\nstatus_t Parcel::writeBool(bool val)\n{\n    return writeInt32(int32_t(val));\n}\n\nstatus_t Parcel::writeChar(char16_t val)\n{\n    return writeInt32(int32_t(val));\n}\n\nstatus_t Parcel::writeByte(int8_t val)\n{\n    return writeInt32(int32_t(val));\n}\n\nstatus_t Parcel::writeInt64(int64_t val)\n{\n    return writeAligned(val);\n}\n\nstatus_t Parcel::writeUint64(uint64_t val)\n{\n    return writeAligned(val);\n}\n\nstatus_t Parcel::writePointer(uintptr_t val)\n{\n    return writeAligned<binder_uintptr_t>(val);\n}\n\nstatus_t Parcel::writeFloat(float val)\n{\n    return writeAligned(val);\n}\n\n#if defined(__mips__) && defined(__mips_hard_float)\n\nstatus_t Parcel::writeDouble(double val)\n{\n    union {\n        double d;\n        unsigned long long ll;\n    } u;\n    u.d = val;\n    return writeAligned(u.ll);\n}\n\n#else\n\nstatus_t Parcel::writeDouble(double val)\n{\n    return writeAligned(val);\n}\n\n#endif\n\nstatus_t Parcel::writeCString(const char* str)\n{\n    return write(str, strlen(str)+1);\n}\n\nstatus_t Parcel::writeString8(const String8& str)\n{\n    return writeString8(str.string(), str.size());\n}\n\nstatus_t Parcel::writeString8(const char* str, size_t len)\n{\n    if (str == nullptr) return writeInt32(-1);\n\n    // NOTE: Keep this logic in sync with android_os_Parcel.cpp\n    status_t err = writeInt32(len);\n    if (err == NO_ERROR) {\n        uint8_t* data = (uint8_t*)writeInplace(len+sizeof(char));\n        if (data) {\n            memcpy(data, str, len);\n            *reinterpret_cast<char*>(data+len) = 0;\n            return NO_ERROR;\n        }\n        err = mError;\n    }\n    return err;\n}\n\nstatus_t Parcel::writeString16(const String16& str)\n{\n    return writeString16(str.string(), str.size());\n}\n\nstatus_t Parcel::writeString16(const char16_t* str, size_t len)\n{\n    if (str == nullptr) return writeInt32(-1);\n\n    // NOTE: Keep this logic in sync with android_os_Parcel.cpp\n    status_t err = writeInt32(len);\n    if (err == NO_ERROR) {\n        len *= sizeof(char16_t);\n        uint8_t* data = (uint8_t*)writeInplace(len+sizeof(char16_t));\n        if (data) {\n            memcpy(data, str, len);\n            *reinterpret_cast<char16_t*>(data+len) = 0;\n            return NO_ERROR;\n        }\n        err = mError;\n    }\n    return err;\n}\n\nstatus_t Parcel::writeStrongBinder(const sp<IBinder>& val)\n{\n    return flattenBinder(val);\n}\n\n\nstatus_t Parcel::writeRawNullableParcelable(const Parcelable* parcelable) {\n    if (!parcelable) {\n        return writeInt32(0);\n    }\n\n    return writeParcelable(*parcelable);\n}\n\nstatus_t Parcel::writeNativeHandle(const native_handle* handle)\n{\n    if (!handle || handle->version != sizeof(native_handle))\n        return BAD_TYPE;\n\n    status_t err;\n    err = writeInt32(handle->numFds);\n    if (err != NO_ERROR) return err;\n\n    err = writeInt32(handle->numInts);\n    if (err != NO_ERROR) return err;\n\n    for (int i=0 ; err==NO_ERROR && i<handle->numFds ; i++)\n        err = writeDupFileDescriptor(handle->data[i]);\n\n    if (err != NO_ERROR) {\n        ALOGD(\"write native handle, write dup fd failed\");\n        return err;\n    }\n    err = write(handle->data + handle->numFds, sizeof(int)*handle->numInts);\n    return err;\n}\n\nstatus_t Parcel::writeFileDescriptor(int fd, bool takeOwnership)\n{\n    if (isForRpc()) {\n        ALOGE(\"Cannot write file descriptor to remote binder.\");\n        return BAD_TYPE;\n    }\n\n    flat_binder_object obj;\n    obj.hdr.type = BINDER_TYPE_FD;\n    obj.flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS;\n    obj.binder = 0; /* Don't pass uninitialized stack data to a remote process */\n    obj.handle = fd;\n    obj.cookie = takeOwnership ? 1 : 0;\n    return writeObject(obj, true);\n}\n\nstatus_t Parcel::writeDupFileDescriptor(int fd)\n{\n    int dupFd = fcntl(fd, F_DUPFD_CLOEXEC, 0);\n    if (dupFd < 0) {\n        return -errno;\n    }\n    status_t err = writeFileDescriptor(dupFd, true /*takeOwnership*/);\n    if (err != OK) {\n        close(dupFd);\n    }\n    return err;\n}\n\nstatus_t Parcel::writeParcelFileDescriptor(int fd, bool takeOwnership)\n{\n    writeInt32(0);\n    return writeFileDescriptor(fd, takeOwnership);\n}\n\nstatus_t Parcel::writeDupParcelFileDescriptor(int fd)\n{\n    int dupFd = fcntl(fd, F_DUPFD_CLOEXEC, 0);\n    if (dupFd < 0) {\n        return -errno;\n    }\n    status_t err = writeParcelFileDescriptor(dupFd, true /*takeOwnership*/);\n    if (err != OK) {\n        close(dupFd);\n    }\n    return err;\n}\n\nstatus_t Parcel::writeUniqueFileDescriptor(const base::unique_fd& fd) {\n    return writeDupFileDescriptor(fd.get());\n}\n\nstatus_t Parcel::writeBlob(size_t len, bool mutableCopy, WritableBlob* outBlob)\n{\n    if (len > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    status_t status;\n    if (!mAllowFds || len <= BLOB_INPLACE_LIMIT) {\n        ALOGV(\"writeBlob: write in place\");\n        status = writeInt32(BLOB_INPLACE);\n        if (status) return status;\n\n        void* ptr = writeInplace(len);\n        if (!ptr) return NO_MEMORY;\n\n        outBlob->init(-1, ptr, len, false);\n        return NO_ERROR;\n    }\n\n    ALOGV(\"writeBlob: write to ashmem\");\n    int fd = ashmem_create_region(\"Parcel Blob\", len);\n    if (fd < 0) return NO_MEMORY;\n\n    int result = ashmem_set_prot_region(fd, PROT_READ | PROT_WRITE);\n    if (result < 0) {\n        status = result;\n    } else {\n        void* ptr = ::mmap(nullptr, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n        if (ptr == MAP_FAILED) {\n            status = -errno;\n        } else {\n            if (!mutableCopy) {\n                result = ashmem_set_prot_region(fd, PROT_READ);\n            }\n            if (result < 0) {\n                status = result;\n            } else {\n                status = writeInt32(mutableCopy ? BLOB_ASHMEM_MUTABLE : BLOB_ASHMEM_IMMUTABLE);\n                if (!status) {\n                    status = writeFileDescriptor(fd, true /*takeOwnership*/);\n                    if (!status) {\n                        outBlob->init(fd, ptr, len, mutableCopy);\n                        return NO_ERROR;\n                    }\n                }\n            }\n        }\n        ::munmap(ptr, len);\n    }\n    ::close(fd);\n    return status;\n}\n\nstatus_t Parcel::writeDupImmutableBlobFileDescriptor(int fd)\n{\n    // Must match up with what's done in writeBlob.\n    if (!mAllowFds) return FDS_NOT_ALLOWED;\n    status_t status = writeInt32(BLOB_ASHMEM_IMMUTABLE);\n    if (status) return status;\n    return writeDupFileDescriptor(fd);\n}\n\nstatus_t Parcel::write(const FlattenableHelperInterface& val)\n{\n    status_t err;\n\n    // size if needed\n    const size_t len = val.getFlattenedSize();\n    const size_t fd_count = val.getFdCount();\n\n    if ((len > INT32_MAX) || (fd_count >= gMaxFds)) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    err = this->writeInt32(len);\n    if (err) return err;\n\n    err = this->writeInt32(fd_count);\n    if (err) return err;\n\n    // payload\n    void* const buf = this->writeInplace(len);\n    if (buf == nullptr)\n        return BAD_VALUE;\n\n    int* fds = nullptr;\n    if (fd_count) {\n        fds = new (std::nothrow) int[fd_count];\n        if (fds == nullptr) {\n            ALOGE(\"write: failed to allocate requested %zu fds\", fd_count);\n            return BAD_VALUE;\n        }\n    }\n\n    err = val.flatten(buf, len, fds, fd_count);\n    for (size_t i=0 ; i<fd_count && err==NO_ERROR ; i++) {\n        err = this->writeDupFileDescriptor( fds[i] );\n    }\n\n    if (fd_count) {\n        delete [] fds;\n    }\n\n    return err;\n}\n\nstatus_t Parcel::writeObject(const flat_binder_object& val, bool nullMetaData)\n{\n    const bool enoughData = (mDataPos+sizeof(val)) <= mDataCapacity;\n    const bool enoughObjects = mObjectsSize < mObjectsCapacity;\n    if (enoughData && enoughObjects) {\nrestart_write:\n        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n            return status;\n        }\n\n        *reinterpret_cast<flat_binder_object*>(mData+mDataPos) = val;\n\n        // remember if it's a file descriptor\n        if (val.hdr.type == BINDER_TYPE_FD) {\n            if (!mAllowFds) {\n                // fail before modifying our object index\n                return FDS_NOT_ALLOWED;\n            }\n            mHasFds = mFdsKnown = true;\n        }\n\n        // Need to write meta-data?\n        if (nullMetaData || val.binder != 0) {\n            mObjects[mObjectsSize] = mDataPos;\n            acquire_object(ProcessState::self(), val, this, &mOpenAshmemSize);\n            mObjectsSize++;\n        }\n\n        return finishWrite(sizeof(flat_binder_object));\n    }\n\n    if (!enoughData) {\n        const status_t err = growData(sizeof(val));\n        if (err != NO_ERROR) return err;\n    }\n    if (!enoughObjects) {\n        if (mObjectsSize > SIZE_MAX - 2) return NO_MEMORY; // overflow\n        if ((mObjectsSize + 2) > SIZE_MAX / 3) return NO_MEMORY; // overflow\n        size_t newSize = ((mObjectsSize+2)*3)/2;\n        if (newSize > SIZE_MAX / sizeof(binder_size_t)) return NO_MEMORY; // overflow\n        binder_size_t* objects = (binder_size_t*)realloc(mObjects, newSize*sizeof(binder_size_t));\n        if (objects == nullptr) return NO_MEMORY;\n        mObjects = objects;\n        mObjectsCapacity = newSize;\n    }\n\n    goto restart_write;\n}\n\nstatus_t Parcel::writeNoException()\n{\n    binder::Status status;\n    return status.writeToParcel(this);\n}\n\nstatus_t Parcel::validateReadData(size_t upperBound) const\n{\n    // Don't allow non-object reads on object data\n    if (mObjectsSorted || mObjectsSize <= 1) {\ndata_sorted:\n        // Expect to check only against the next object\n        if (mNextObjectHint < mObjectsSize && upperBound > mObjects[mNextObjectHint]) {\n            // For some reason the current read position is greater than the next object\n            // hint. Iterate until we find the right object\n            size_t nextObject = mNextObjectHint;\n            do {\n                if (mDataPos < mObjects[nextObject] + sizeof(flat_binder_object)) {\n                    // Requested info overlaps with an object\n                    ALOGE(\"Attempt to read from protected data in Parcel %p\", this);\n                    return PERMISSION_DENIED;\n                }\n                nextObject++;\n            } while (nextObject < mObjectsSize && upperBound > mObjects[nextObject]);\n            mNextObjectHint = nextObject;\n        }\n        return NO_ERROR;\n    }\n    // Quickly determine if mObjects is sorted.\n    binder_size_t* currObj = mObjects + mObjectsSize - 1;\n    binder_size_t* prevObj = currObj;\n    while (currObj > mObjects) {\n        prevObj--;\n        if(*prevObj > *currObj) {\n            goto data_unsorted;\n        }\n        currObj--;\n    }\n    mObjectsSorted = true;\n    goto data_sorted;\n\ndata_unsorted:\n    // Insertion Sort mObjects\n    // Great for mostly sorted lists. If randomly sorted or reverse ordered mObjects become common,\n    // switch to std::sort(mObjects, mObjects + mObjectsSize);\n    for (binder_size_t* iter0 = mObjects + 1; iter0 < mObjects + mObjectsSize; iter0++) {\n        binder_size_t temp = *iter0;\n        binder_size_t* iter1 = iter0 - 1;\n        while (iter1 >= mObjects && *iter1 > temp) {\n            *(iter1 + 1) = *iter1;\n            iter1--;\n        }\n        *(iter1 + 1) = temp;\n    }\n    mNextObjectHint = 0;\n    mObjectsSorted = true;\n    goto data_sorted;\n}\n\nstatus_t Parcel::read(void* outData, size_t len) const\n{\n    if (len > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    if ((mDataPos+pad_size(len)) >= mDataPos && (mDataPos+pad_size(len)) <= mDataSize\n            && len <= pad_size(len)) {\n        if (mObjectsSize > 0) {\n            status_t err = validateReadData(mDataPos + pad_size(len));\n            if(err != NO_ERROR) {\n                // Still increment the data position by the expected length\n                mDataPos += pad_size(len);\n                ALOGV(\"read Setting data pos of %p to %zu\", this, mDataPos);\n                return err;\n            }\n        }\n        memcpy(outData, mData+mDataPos, len);\n        mDataPos += pad_size(len);\n        ALOGV(\"read Setting data pos of %p to %zu\", this, mDataPos);\n        return NO_ERROR;\n    }\n    return NOT_ENOUGH_DATA;\n}\n\nconst void* Parcel::readInplace(size_t len) const\n{\n    if (len > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return nullptr;\n    }\n\n    if ((mDataPos+pad_size(len)) >= mDataPos && (mDataPos+pad_size(len)) <= mDataSize\n            && len <= pad_size(len)) {\n        if (mObjectsSize > 0) {\n            status_t err = validateReadData(mDataPos + pad_size(len));\n            if(err != NO_ERROR) {\n                // Still increment the data position by the expected length\n                mDataPos += pad_size(len);\n                ALOGV(\"readInplace Setting data pos of %p to %zu\", this, mDataPos);\n                return nullptr;\n            }\n        }\n\n        const void* data = mData+mDataPos;\n        mDataPos += pad_size(len);\n        ALOGV(\"readInplace Setting data pos of %p to %zu\", this, mDataPos);\n        return data;\n    }\n    return nullptr;\n}\n\ntemplate<class T>\nstatus_t Parcel::readAligned(T *pArg) const {\n    static_assert(PAD_SIZE_UNSAFE(sizeof(T)) == sizeof(T));\n\n    if ((mDataPos+sizeof(T)) <= mDataSize) {\n        if (mObjectsSize > 0) {\n            status_t err = validateReadData(mDataPos + sizeof(T));\n            if(err != NO_ERROR) {\n                // Still increment the data position by the expected length\n                mDataPos += sizeof(T);\n                return err;\n            }\n        }\n\n        const void* data = mData+mDataPos;\n        mDataPos += sizeof(T);\n        *pArg =  *reinterpret_cast<const T*>(data);\n        return NO_ERROR;\n    } else {\n        return NOT_ENOUGH_DATA;\n    }\n}\n\ntemplate<class T>\nT Parcel::readAligned() const {\n    T result;\n    if (readAligned(&result) != NO_ERROR) {\n        result = 0;\n    }\n\n    return result;\n}\n\ntemplate<class T>\nstatus_t Parcel::writeAligned(T val) {\n    static_assert(PAD_SIZE_UNSAFE(sizeof(T)) == sizeof(T));\n\n    if ((mDataPos+sizeof(val)) <= mDataCapacity) {\nrestart_write:\n        *reinterpret_cast<T*>(mData+mDataPos) = val;\n        return finishWrite(sizeof(val));\n    }\n\n    status_t err = growData(sizeof(val));\n    if (err == NO_ERROR) goto restart_write;\n    return err;\n}\n\nstatus_t Parcel::readInt32(int32_t *pArg) const\n{\n    return readAligned(pArg);\n}\n\nint32_t Parcel::readInt32() const\n{\n    return readAligned<int32_t>();\n}\n\nstatus_t Parcel::readUint32(uint32_t *pArg) const\n{\n    return readAligned(pArg);\n}\n\nuint32_t Parcel::readUint32() const\n{\n    return readAligned<uint32_t>();\n}\n\nstatus_t Parcel::readInt64(int64_t *pArg) const\n{\n    return readAligned(pArg);\n}\n\n\nint64_t Parcel::readInt64() const\n{\n    return readAligned<int64_t>();\n}\n\nstatus_t Parcel::readUint64(uint64_t *pArg) const\n{\n    return readAligned(pArg);\n}\n\nuint64_t Parcel::readUint64() const\n{\n    return readAligned<uint64_t>();\n}\n\nstatus_t Parcel::readPointer(uintptr_t *pArg) const\n{\n    status_t ret;\n    binder_uintptr_t ptr;\n    ret = readAligned(&ptr);\n    if (!ret)\n        *pArg = ptr;\n    return ret;\n}\n\nuintptr_t Parcel::readPointer() const\n{\n    return readAligned<binder_uintptr_t>();\n}\n\n\nstatus_t Parcel::readFloat(float *pArg) const\n{\n    return readAligned(pArg);\n}\n\n\nfloat Parcel::readFloat() const\n{\n    return readAligned<float>();\n}\n\n#if defined(__mips__) && defined(__mips_hard_float)\n\nstatus_t Parcel::readDouble(double *pArg) const\n{\n    union {\n      double d;\n      unsigned long long ll;\n    } u;\n    u.d = 0;\n    status_t status;\n    status = readAligned(&u.ll);\n    *pArg = u.d;\n    return status;\n}\n\ndouble Parcel::readDouble() const\n{\n    union {\n      double d;\n      unsigned long long ll;\n    } u;\n    u.ll = readAligned<unsigned long long>();\n    return u.d;\n}\n\n#else\n\nstatus_t Parcel::readDouble(double *pArg) const\n{\n    return readAligned(pArg);\n}\n\ndouble Parcel::readDouble() const\n{\n    return readAligned<double>();\n}\n\n#endif\n\nstatus_t Parcel::readBool(bool *pArg) const\n{\n    int32_t tmp = 0;\n    status_t ret = readInt32(&tmp);\n    *pArg = (tmp != 0);\n    return ret;\n}\n\nbool Parcel::readBool() const\n{\n    return readInt32() != 0;\n}\n\nstatus_t Parcel::readChar(char16_t *pArg) const\n{\n    int32_t tmp = 0;\n    status_t ret = readInt32(&tmp);\n    *pArg = char16_t(tmp);\n    return ret;\n}\n\nchar16_t Parcel::readChar() const\n{\n    return char16_t(readInt32());\n}\n\nstatus_t Parcel::readByte(int8_t *pArg) const\n{\n    int32_t tmp = 0;\n    status_t ret = readInt32(&tmp);\n    *pArg = int8_t(tmp);\n    return ret;\n}\n\nint8_t Parcel::readByte() const\n{\n    return int8_t(readInt32());\n}\n\nstatus_t Parcel::readUtf8FromUtf16(std::string* str) const {\n    size_t utf16Size = 0;\n    const char16_t* src = readString16Inplace(&utf16Size);\n    if (!src) {\n        return UNEXPECTED_NULL;\n    }\n\n    // Save ourselves the trouble, we're done.\n    if (utf16Size == 0u) {\n        str->clear();\n       return NO_ERROR;\n    }\n\n    // Allow for closing '\\0'\n    ssize_t utf8Size = utf16_to_utf8_length(src, utf16Size) + 1;\n    if (utf8Size < 1) {\n        return BAD_VALUE;\n    }\n    // Note that while it is probably safe to assume string::resize keeps a\n    // spare byte around for the trailing null, we still pass the size including the trailing null\n    str->resize(utf8Size);\n    utf16_to_utf8(src, utf16Size, &((*str)[0]), utf8Size);\n    str->resize(utf8Size - 1);\n    return NO_ERROR;\n}\n\nconst char* Parcel::readCString() const\n{\n    if (mDataPos < mDataSize) {\n        const size_t avail = mDataSize-mDataPos;\n        const char* str = reinterpret_cast<const char*>(mData+mDataPos);\n        // is the string's trailing NUL within the parcel's valid bounds?\n        const char* eos = reinterpret_cast<const char*>(memchr(str, 0, avail));\n        if (eos) {\n            const size_t len = eos - str;\n            mDataPos += pad_size(len+1);\n            ALOGV(\"readCString Setting data pos of %p to %zu\", this, mDataPos);\n            return str;\n        }\n    }\n    return nullptr;\n}\n\nString8 Parcel::readString8() const\n{\n    size_t len;\n    const char* str = readString8Inplace(&len);\n    if (str) return String8(str, len);\n    ALOGE(\"Reading a NULL string not supported here.\");\n    return String8();\n}\n\nstatus_t Parcel::readString8(String8* pArg) const\n{\n    size_t len;\n    const char* str = readString8Inplace(&len);\n    if (str) {\n        pArg->setTo(str, len);\n        return 0;\n    } else {\n        *pArg = String8();\n        return UNEXPECTED_NULL;\n    }\n}\n\nconst char* Parcel::readString8Inplace(size_t* outLen) const\n{\n    int32_t size = readInt32();\n    // watch for potential int overflow from size+1\n    if (size >= 0 && size < INT32_MAX) {\n        *outLen = size;\n        const char* str = (const char*)readInplace(size+1);\n        if (str != nullptr) {\n            if (str[size] == '\\0') {\n                return str;\n            }\n            android_errorWriteLog(0x534e4554, \"172655291\");\n        }\n    }\n    *outLen = 0;\n    return nullptr;\n}\n\nString16 Parcel::readString16() const\n{\n    size_t len;\n    const char16_t* str = readString16Inplace(&len);\n    if (str) return String16(str, len);\n    ALOGE(\"Reading a NULL string not supported here.\");\n    return String16();\n}\n\n\nstatus_t Parcel::readString16(String16* pArg) const\n{\n    size_t len;\n    const char16_t* str = readString16Inplace(&len);\n    if (str) {\n        pArg->setTo(str, len);\n        return 0;\n    } else {\n        *pArg = String16();\n        return UNEXPECTED_NULL;\n    }\n}\n\nconst char16_t* Parcel::readString16Inplace(size_t* outLen) const\n{\n    int32_t size = readInt32();\n    // watch for potential int overflow from size+1\n    if (size >= 0 && size < INT32_MAX) {\n        *outLen = size;\n        const char16_t* str = (const char16_t*)readInplace((size+1)*sizeof(char16_t));\n        if (str != nullptr) {\n            if (str[size] == u'\\0') {\n                return str;\n            }\n            android_errorWriteLog(0x534e4554, \"172655291\");\n        }\n    }\n    *outLen = 0;\n    return nullptr;\n}\n\nstatus_t Parcel::readStrongBinder(sp<IBinder>* val) const\n{\n    status_t status = readNullableStrongBinder(val);\n    if (status == OK && !val->get()) {\n        status = UNEXPECTED_NULL;\n    }\n    return status;\n}\n\nstatus_t Parcel::readNullableStrongBinder(sp<IBinder>* val) const\n{\n    return unflattenBinder(val);\n}\n\nsp<IBinder> Parcel::readStrongBinder() const\n{\n    sp<IBinder> val;\n    // Note that a lot of code in Android reads binders by hand with this\n    // method, and that code has historically been ok with getting nullptr\n    // back (while ignoring error codes).\n    readNullableStrongBinder(&val);\n    return val;\n}\n\nint32_t Parcel::readExceptionCode() const\n{\n    binder::Status status;\n    status.readFromParcel(*this);\n    return status.exceptionCode();\n}\n\nnative_handle* Parcel::readNativeHandle() const\n{\n    int numFds, numInts;\n    status_t err;\n    err = readInt32(&numFds);\n    if (err != NO_ERROR) return nullptr;\n    err = readInt32(&numInts);\n    if (err != NO_ERROR) return nullptr;\n\n    native_handle* h = native_handle_create(numFds, numInts);\n    if (!h) {\n        return nullptr;\n    }\n\n    for (int i=0 ; err==NO_ERROR && i<numFds ; i++) {\n        h->data[i] = fcntl(readFileDescriptor(), F_DUPFD_CLOEXEC, 0);\n        if (h->data[i] < 0) {\n            for (int j = 0; j < i; j++) {\n                close(h->data[j]);\n            }\n            native_handle_delete(h);\n            return nullptr;\n        }\n    }\n    err = read(h->data + numFds, sizeof(int)*numInts);\n    if (err != NO_ERROR) {\n        native_handle_close(h);\n        native_handle_delete(h);\n        h = nullptr;\n    }\n    return h;\n}\n\nint Parcel::readFileDescriptor() const\n{\n    const flat_binder_object* flat = readObject(true);\n\n    if (flat && flat->hdr.type == BINDER_TYPE_FD) {\n        return flat->handle;\n    }\n\n    return BAD_TYPE;\n}\n\nint Parcel::readParcelFileDescriptor() const\n{\n    int32_t hasComm = readInt32();\n    int fd = readFileDescriptor();\n    if (hasComm != 0) {\n        // detach (owned by the binder driver)\n        int comm = readFileDescriptor();\n\n        // warning: this must be kept in sync with:\n        // frameworks/base/core/java/android/os/ParcelFileDescriptor.java\n        enum ParcelFileDescriptorStatus {\n            DETACHED = 2,\n        };\n\n#if BYTE_ORDER == BIG_ENDIAN\n        const int32_t message = ParcelFileDescriptorStatus::DETACHED;\n#endif\n#if BYTE_ORDER == LITTLE_ENDIAN\n        const int32_t message = __builtin_bswap32(ParcelFileDescriptorStatus::DETACHED);\n#endif\n\n        ssize_t written = TEMP_FAILURE_RETRY(\n            ::write(comm, &message, sizeof(message)));\n\n        if (written != sizeof(message)) {\n            ALOGW(\"Failed to detach ParcelFileDescriptor written: %zd err: %s\",\n                written, strerror(errno));\n            return BAD_TYPE;\n        }\n    }\n    return fd;\n}\n\nstatus_t Parcel::readUniqueFileDescriptor(base::unique_fd* val) const\n{\n    int got = readFileDescriptor();\n\n    if (got == BAD_TYPE) {\n        return BAD_TYPE;\n    }\n\n    val->reset(fcntl(got, F_DUPFD_CLOEXEC, 0));\n\n    if (val->get() < 0) {\n        return BAD_VALUE;\n    }\n\n    return OK;\n}\n\nstatus_t Parcel::readUniqueParcelFileDescriptor(base::unique_fd* val) const\n{\n    int got = readParcelFileDescriptor();\n\n    if (got == BAD_TYPE) {\n        return BAD_TYPE;\n    }\n\n    val->reset(fcntl(got, F_DUPFD_CLOEXEC, 0));\n\n    if (val->get() < 0) {\n        return BAD_VALUE;\n    }\n\n    return OK;\n}\n\nstatus_t Parcel::readBlob(size_t len, ReadableBlob* outBlob) const\n{\n    int32_t blobType;\n    status_t status = readInt32(&blobType);\n    if (status) return status;\n\n    if (blobType == BLOB_INPLACE) {\n        ALOGV(\"readBlob: read in place\");\n        const void* ptr = readInplace(len);\n        if (!ptr) return BAD_VALUE;\n\n        outBlob->init(-1, const_cast<void*>(ptr), len, false);\n        return NO_ERROR;\n    }\n\n    ALOGV(\"readBlob: read from ashmem\");\n    bool isMutable = (blobType == BLOB_ASHMEM_MUTABLE);\n    int fd = readFileDescriptor();\n    if (fd == int(BAD_TYPE)) return BAD_VALUE;\n\n    if (!ashmem_valid(fd)) {\n        ALOGE(\"invalid fd\");\n        return BAD_VALUE;\n    }\n    int size = ashmem_get_size_region(fd);\n    if (size < 0 || size_t(size) < len) {\n        ALOGE(\"request size %zu does not match fd size %d\", len, size);\n        return BAD_VALUE;\n    }\n    void* ptr = ::mmap(nullptr, len, isMutable ? PROT_READ | PROT_WRITE : PROT_READ,\n            MAP_SHARED, fd, 0);\n    if (ptr == MAP_FAILED) return NO_MEMORY;\n\n    outBlob->init(fd, ptr, len, isMutable);\n    return NO_ERROR;\n}\n\nstatus_t Parcel::read(FlattenableHelperInterface& val) const\n{\n    // size\n    const size_t len = this->readInt32();\n    const size_t fd_count = this->readInt32();\n\n    if ((len > INT32_MAX) || (fd_count >= gMaxFds)) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    // payload\n    void const* const buf = this->readInplace(pad_size(len));\n    if (buf == nullptr)\n        return BAD_VALUE;\n\n    int* fds = nullptr;\n    if (fd_count) {\n        fds = new (std::nothrow) int[fd_count];\n        if (fds == nullptr) {\n            ALOGE(\"read: failed to allocate requested %zu fds\", fd_count);\n            return BAD_VALUE;\n        }\n    }\n\n    status_t err = NO_ERROR;\n    for (size_t i=0 ; i<fd_count && err==NO_ERROR ; i++) {\n        int fd = this->readFileDescriptor();\n        if (fd < 0 || ((fds[i] = fcntl(fd, F_DUPFD_CLOEXEC, 0)) < 0)) {\n            err = BAD_VALUE;\n            ALOGE(\"fcntl(F_DUPFD_CLOEXEC) failed in Parcel::read, i is %zu, fds[i] is %d, fd_count is %zu, error: %s\",\n                  i, fds[i], fd_count, strerror(fd < 0 ? -fd : errno));\n            // Close all the file descriptors that were dup-ed.\n            for (size_t j=0; j<i ;j++) {\n                close(fds[j]);\n            }\n        }\n    }\n\n    if (err == NO_ERROR) {\n        err = val.unflatten(buf, len, fds, fd_count);\n    }\n\n    if (fd_count) {\n        delete [] fds;\n    }\n\n    return err;\n}\nconst flat_binder_object* Parcel::readObject(bool nullMetaData) const\n{\n    const size_t DPOS = mDataPos;\n    if ((DPOS+sizeof(flat_binder_object)) <= mDataSize) {\n        const flat_binder_object* obj\n                = reinterpret_cast<const flat_binder_object*>(mData+DPOS);\n        mDataPos = DPOS + sizeof(flat_binder_object);\n        if (!nullMetaData && (obj->cookie == 0 && obj->binder == 0)) {\n            // When transferring a NULL object, we don't write it into\n            // the object list, so we don't want to check for it when\n            // reading.\n            ALOGV(\"readObject Setting data pos of %p to %zu\", this, mDataPos);\n            return obj;\n        }\n\n        // Ensure that this object is valid...\n        binder_size_t* const OBJS = mObjects;\n        const size_t N = mObjectsSize;\n        size_t opos = mNextObjectHint;\n\n        if (N > 0) {\n            ALOGV(\"Parcel %p looking for obj at %zu, hint=%zu\",\n                 this, DPOS, opos);\n\n            // Start at the current hint position, looking for an object at\n            // the current data position.\n            if (opos < N) {\n                while (opos < (N-1) && OBJS[opos] < DPOS) {\n                    opos++;\n                }\n            } else {\n                opos = N-1;\n            }\n            if (OBJS[opos] == DPOS) {\n                // Found it!\n                ALOGV(\"Parcel %p found obj %zu at index %zu with forward search\",\n                     this, DPOS, opos);\n                mNextObjectHint = opos+1;\n                ALOGV(\"readObject Setting data pos of %p to %zu\", this, mDataPos);\n                return obj;\n            }\n\n            // Look backwards for it...\n            while (opos > 0 && OBJS[opos] > DPOS) {\n                opos--;\n            }\n            if (OBJS[opos] == DPOS) {\n                // Found it!\n                ALOGV(\"Parcel %p found obj %zu at index %zu with backward search\",\n                     this, DPOS, opos);\n                mNextObjectHint = opos+1;\n                ALOGV(\"readObject Setting data pos of %p to %zu\", this, mDataPos);\n                return obj;\n            }\n        }\n        ALOGW(\"Attempt to read object from Parcel %p at offset %zu that is not in the object list\",\n             this, DPOS);\n    }\n    return nullptr;\n}\n\nvoid Parcel::closeFileDescriptors()\n{\n    size_t i = mObjectsSize;\n    if (i > 0) {\n        //ALOGI(\"Closing file descriptors for %zu objects...\", i);\n    }\n    while (i > 0) {\n        i--;\n        const flat_binder_object* flat\n            = reinterpret_cast<flat_binder_object*>(mData+mObjects[i]);\n        if (flat->hdr.type == BINDER_TYPE_FD) {\n            //ALOGI(\"Closing fd: %ld\", flat->handle);\n            close(flat->handle);\n        }\n    }\n}\n\nuintptr_t Parcel::ipcData() const\n{\n    return reinterpret_cast<uintptr_t>(mData);\n}\n\nsize_t Parcel::ipcDataSize() const\n{\n    return (mDataSize > mDataPos ? mDataSize : mDataPos);\n}\n\nuintptr_t Parcel::ipcObjects() const\n{\n    return reinterpret_cast<uintptr_t>(mObjects);\n}\n\nsize_t Parcel::ipcObjectsCount() const\n{\n    return mObjectsSize;\n}\n\nvoid Parcel::ipcSetDataReference(const uint8_t* data, size_t dataSize,\n    const binder_size_t* objects, size_t objectsCount, release_func relFunc)\n{\n    // this code uses 'mOwner == nullptr' to understand whether it owns memory\n    LOG_ALWAYS_FATAL_IF(relFunc == nullptr, \"must provide cleanup function\");\n\n    freeData();\n\n    mData = const_cast<uint8_t*>(data);\n    mDataSize = mDataCapacity = dataSize;\n    mObjects = const_cast<binder_size_t*>(objects);\n    mObjectsSize = mObjectsCapacity = objectsCount;\n    mOwner = relFunc;\n\n    binder_size_t minOffset = 0;\n    for (size_t i = 0; i < mObjectsSize; i++) {\n        binder_size_t offset = mObjects[i];\n        if (offset < minOffset) {\n            ALOGE(\"%s: bad object offset %\" PRIu64 \" < %\" PRIu64 \"\\n\",\n                  __func__, (uint64_t)offset, (uint64_t)minOffset);\n            mObjectsSize = 0;\n            break;\n        }\n        const flat_binder_object* flat\n            = reinterpret_cast<const flat_binder_object*>(mData + offset);\n        uint32_t type = flat->hdr.type;\n        if (!(type == BINDER_TYPE_BINDER || type == BINDER_TYPE_HANDLE ||\n              type == BINDER_TYPE_FD)) {\n            // We should never receive other types (eg BINDER_TYPE_FDA) as long as we don't support\n            // them in libbinder. If we do receive them, it probably means a kernel bug; try to\n            // recover gracefully by clearing out the objects.\n            android_errorWriteLog(0x534e4554, \"135930648\");\n            android_errorWriteLog(0x534e4554, \"203847542\");\n            ALOGE(\"%s: unsupported type object (%\" PRIu32 \") at offset %\" PRIu64 \"\\n\",\n                  __func__, type, (uint64_t)offset);\n\n            // WARNING: callers of ipcSetDataReference need to make sure they\n            // don't rely on mObjectsSize in their release_func.\n            mObjectsSize = 0;\n            break;\n        }\n        minOffset = offset + sizeof(flat_binder_object);\n    }\n    scanForFds();\n}\n\nvoid Parcel::print(TextOutput& to, uint32_t /*flags*/) const\n{\n    to << \"Parcel(\";\n\n    if (errorCheck() != NO_ERROR) {\n        const status_t err = errorCheck();\n        to << \"Error: \" << (void*)(intptr_t)err << \" \\\"\" << strerror(-err) << \"\\\"\";\n    } else if (dataSize() > 0) {\n        const uint8_t* DATA = data();\n        to << indent << HexDump(DATA, dataSize()) << dedent;\n        const binder_size_t* OBJS = mObjects;\n        const size_t N = objectsCount();\n        for (size_t i=0; i<N; i++) {\n            const flat_binder_object* flat\n                = reinterpret_cast<const flat_binder_object*>(DATA+OBJS[i]);\n            to << endl << \"Object #\" << i << \" @ \" << (void*)OBJS[i] << \": \"\n                << TypeCode(flat->hdr.type & 0x7f7f7f00)\n                << \" = \" << flat->binder;\n        }\n    } else {\n        to << \"NULL\";\n    }\n\n    to << \")\";\n}\n\nvoid Parcel::releaseObjects()\n{\n    size_t i = mObjectsSize;\n    if (i == 0) {\n        return;\n    }\n    sp<ProcessState> proc(ProcessState::self());\n    uint8_t* const data = mData;\n    binder_size_t* const objects = mObjects;\n    while (i > 0) {\n        i--;\n        const flat_binder_object* flat\n            = reinterpret_cast<flat_binder_object*>(data+objects[i]);\n        release_object(proc, *flat, this, &mOpenAshmemSize);\n    }\n}\n\nvoid Parcel::acquireObjects()\n{\n    size_t i = mObjectsSize;\n    if (i == 0) {\n        return;\n    }\n    const sp<ProcessState> proc(ProcessState::self());\n    uint8_t* const data = mData;\n    binder_size_t* const objects = mObjects;\n    while (i > 0) {\n        i--;\n        const flat_binder_object* flat\n            = reinterpret_cast<flat_binder_object*>(data+objects[i]);\n        acquire_object(proc, *flat, this, &mOpenAshmemSize);\n    }\n}\n\nvoid Parcel::freeData()\n{\n    freeDataNoInit();\n    initState();\n}\n\nvoid Parcel::freeDataNoInit()\n{\n    if (mOwner) {\n        LOG_ALLOC(\"Parcel %p: freeing other owner data\", this);\n        //ALOGI(\"Freeing data ref of %p (pid=%d)\", this, getpid());\n        mOwner(this, mData, mDataSize, mObjects, mObjectsSize);\n    } else {\n        LOG_ALLOC(\"Parcel %p: freeing allocated data\", this);\n        releaseObjects();\n        if (mData) {\n            LOG_ALLOC(\"Parcel %p: freeing with %zu capacity\", this, mDataCapacity);\n            gParcelGlobalAllocSize -= mDataCapacity;\n            gParcelGlobalAllocCount--;\n            if (mDeallocZero) {\n                zeroMemory(mData, mDataSize);\n            }\n            free(mData);\n        }\n        if (mObjects) free(mObjects);\n    }\n}\n\nstatus_t Parcel::growData(size_t len)\n{\n    if (len > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    if (len > SIZE_MAX - mDataSize) return NO_MEMORY; // overflow\n    if (mDataSize + len > SIZE_MAX / 3) return NO_MEMORY; // overflow\n    size_t newSize = ((mDataSize+len)*3)/2;\n    return (newSize <= mDataSize)\n            ? (status_t) NO_MEMORY\n            : continueWrite(std::max(newSize, (size_t) 128));\n}\n\nstatic uint8_t* reallocZeroFree(uint8_t* data, size_t oldCapacity, size_t newCapacity, bool zero) {\n    if (!zero) {\n        return (uint8_t*)realloc(data, newCapacity);\n    }\n    uint8_t* newData = (uint8_t*)malloc(newCapacity);\n    if (!newData) {\n        return nullptr;\n    }\n\n    memcpy(newData, data, std::min(oldCapacity, newCapacity));\n    zeroMemory(data, oldCapacity);\n    free(data);\n    return newData;\n}\n\nstatus_t Parcel::restartWrite(size_t desired)\n{\n    if (desired > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    if (mOwner) {\n        freeData();\n        return continueWrite(desired);\n    }\n\n    uint8_t* data = reallocZeroFree(mData, mDataCapacity, desired, mDeallocZero);\n    if (!data && desired > mDataCapacity) {\n        mError = NO_MEMORY;\n        return NO_MEMORY;\n    }\n\n    releaseObjects();\n\n    if (data || desired == 0) {\n        LOG_ALLOC(\"Parcel %p: restart from %zu to %zu capacity\", this, mDataCapacity, desired);\n        if (mDataCapacity > desired) {\n            gParcelGlobalAllocSize -= (mDataCapacity - desired);\n        } else {\n            gParcelGlobalAllocSize += (desired - mDataCapacity);\n        }\n\n        if (!mData) {\n            gParcelGlobalAllocCount++;\n        }\n        mData = data;\n        mDataCapacity = desired;\n    }\n\n    mDataSize = mDataPos = 0;\n    ALOGV(\"restartWrite Setting data size of %p to %zu\", this, mDataSize);\n    ALOGV(\"restartWrite Setting data pos of %p to %zu\", this, mDataPos);\n\n    free(mObjects);\n    mObjects = nullptr;\n    mObjectsSize = mObjectsCapacity = 0;\n    mNextObjectHint = 0;\n    mObjectsSorted = false;\n    mHasFds = false;\n    mFdsKnown = true;\n    mAllowFds = true;\n\n    return NO_ERROR;\n}\n\nstatus_t Parcel::continueWrite(size_t desired)\n{\n    if (desired > INT32_MAX) {\n        // don't accept size_t values which may have come from an\n        // inadvertent conversion from a negative int.\n        return BAD_VALUE;\n    }\n\n    // If shrinking, first adjust for any objects that appear\n    // after the new data size.\n    size_t objectsSize = mObjectsSize;\n    if (desired < mDataSize) {\n        if (desired == 0) {\n            objectsSize = 0;\n        } else {\n            while (objectsSize > 0) {\n                if (mObjects[objectsSize-1] < desired)\n                    break;\n                objectsSize--;\n            }\n        }\n    }\n\n    if (mOwner) {\n        // If the size is going to zero, just release the owner's data.\n        if (desired == 0) {\n            freeData();\n            return NO_ERROR;\n        }\n\n        // If there is a different owner, we need to take\n        // posession.\n        uint8_t* data = (uint8_t*)malloc(desired);\n        if (!data) {\n            mError = NO_MEMORY;\n            return NO_MEMORY;\n        }\n        binder_size_t* objects = nullptr;\n\n        if (objectsSize) {\n            objects = (binder_size_t*)calloc(objectsSize, sizeof(binder_size_t));\n            if (!objects) {\n                free(data);\n\n                mError = NO_MEMORY;\n                return NO_MEMORY;\n            }\n\n            // Little hack to only acquire references on objects\n            // we will be keeping.\n            size_t oldObjectsSize = mObjectsSize;\n            mObjectsSize = objectsSize;\n            acquireObjects();\n            mObjectsSize = oldObjectsSize;\n        }\n\n        if (mData) {\n            memcpy(data, mData, mDataSize < desired ? mDataSize : desired);\n        }\n        if (objects && mObjects) {\n            memcpy(objects, mObjects, objectsSize*sizeof(binder_size_t));\n        }\n        //ALOGI(\"Freeing data ref of %p (pid=%d)\", this, getpid());\n        mOwner(this, mData, mDataSize, mObjects, mObjectsSize);\n        mOwner = nullptr;\n\n        LOG_ALLOC(\"Parcel %p: taking ownership of %zu capacity\", this, desired);\n        gParcelGlobalAllocSize += desired;\n        gParcelGlobalAllocCount++;\n\n        mData = data;\n        mObjects = objects;\n        mDataSize = (mDataSize < desired) ? mDataSize : desired;\n        ALOGV(\"continueWrite Setting data size of %p to %zu\", this, mDataSize);\n        mDataCapacity = desired;\n        mObjectsSize = mObjectsCapacity = objectsSize;\n        mNextObjectHint = 0;\n        mObjectsSorted = false;\n\n    } else if (mData) {\n        if (objectsSize < mObjectsSize) {\n            // Need to release refs on any objects we are dropping.\n            const sp<ProcessState> proc(ProcessState::self());\n            for (size_t i=objectsSize; i<mObjectsSize; i++) {\n                const flat_binder_object* flat\n                    = reinterpret_cast<flat_binder_object*>(mData+mObjects[i]);\n                if (flat->hdr.type == BINDER_TYPE_FD) {\n                    // will need to rescan because we may have lopped off the only FDs\n                    mFdsKnown = false;\n                }\n                release_object(proc, *flat, this, &mOpenAshmemSize);\n            }\n\n            if (objectsSize == 0) {\n                free(mObjects);\n                mObjects = nullptr;\n                mObjectsCapacity = 0;\n            } else {\n                binder_size_t* objects =\n                    (binder_size_t*)realloc(mObjects, objectsSize*sizeof(binder_size_t));\n                if (objects) {\n                    mObjects = objects;\n                    mObjectsCapacity = objectsSize;\n                }\n            }\n            mObjectsSize = objectsSize;\n            mNextObjectHint = 0;\n            mObjectsSorted = false;\n        }\n\n        // We own the data, so we can just do a realloc().\n        if (desired > mDataCapacity) {\n            uint8_t* data = reallocZeroFree(mData, mDataCapacity, desired, mDeallocZero);\n            if (data) {\n                LOG_ALLOC(\"Parcel %p: continue from %zu to %zu capacity\", this, mDataCapacity,\n                        desired);\n                gParcelGlobalAllocSize += desired;\n                gParcelGlobalAllocSize -= mDataCapacity;\n                mData = data;\n                mDataCapacity = desired;\n            } else {\n                mError = NO_MEMORY;\n                return NO_MEMORY;\n            }\n        } else {\n            if (mDataSize > desired) {\n                mDataSize = desired;\n                ALOGV(\"continueWrite Setting data size of %p to %zu\", this, mDataSize);\n            }\n            if (mDataPos > desired) {\n                mDataPos = desired;\n                ALOGV(\"continueWrite Setting data pos of %p to %zu\", this, mDataPos);\n            }\n        }\n\n    } else {\n        // This is the first data.  Easy!\n        uint8_t* data = (uint8_t*)malloc(desired);\n        if (!data) {\n            mError = NO_MEMORY;\n            return NO_MEMORY;\n        }\n\n        if(!(mDataCapacity == 0 && mObjects == nullptr\n             && mObjectsCapacity == 0)) {\n            ALOGE(\"continueWrite: %zu/%p/%zu/%zu\", mDataCapacity, mObjects, mObjectsCapacity, desired);\n        }\n\n        LOG_ALLOC(\"Parcel %p: allocating with %zu capacity\", this, desired);\n        gParcelGlobalAllocSize += desired;\n        gParcelGlobalAllocCount++;\n\n        mData = data;\n        mDataSize = mDataPos = 0;\n        ALOGV(\"continueWrite Setting data size of %p to %zu\", this, mDataSize);\n        ALOGV(\"continueWrite Setting data pos of %p to %zu\", this, mDataPos);\n        mDataCapacity = desired;\n    }\n\n    return NO_ERROR;\n}\n\nvoid Parcel::initState()\n{\n    LOG_ALLOC(\"Parcel %p: initState\", this);\n    mError = NO_ERROR;\n    mData = nullptr;\n    mDataSize = 0;\n    mDataCapacity = 0;\n    mDataPos = 0;\n    ALOGV(\"initState Setting data size of %p to %zu\", this, mDataSize);\n    ALOGV(\"initState Setting data pos of %p to %zu\", this, mDataPos);\n    mSession = nullptr;\n    mObjects = nullptr;\n    mObjectsSize = 0;\n    mObjectsCapacity = 0;\n    mNextObjectHint = 0;\n    mObjectsSorted = false;\n    mHasFds = false;\n    mFdsKnown = true;\n    mAllowFds = true;\n    mDeallocZero = false;\n    mOwner = nullptr;\n    mOpenAshmemSize = 0;\n    mWorkSourceRequestHeaderPosition = 0;\n    mRequestHeaderPresent = false;\n\n    // racing multiple init leads only to multiple identical write\n    if (gMaxFds == 0) {\n        struct rlimit result;\n        if (!getrlimit(RLIMIT_NOFILE, &result)) {\n            gMaxFds = (size_t)result.rlim_cur;\n            //ALOGI(\"parcel fd limit set to %zu\", gMaxFds);\n        } else {\n            ALOGW(\"Unable to getrlimit: %s\", strerror(errno));\n            gMaxFds = 1024;\n        }\n    }\n}\n\nvoid Parcel::scanForFds() const\n{\n    bool hasFds = false;\n    for (size_t i=0; i<mObjectsSize; i++) {\n        const flat_binder_object* flat\n            = reinterpret_cast<const flat_binder_object*>(mData + mObjects[i]);\n        if (flat->hdr.type == BINDER_TYPE_FD) {\n            hasFds = true;\n            break;\n        }\n    }\n    mHasFds = hasFds;\n    mFdsKnown = true;\n}\n\nsize_t Parcel::getBlobAshmemSize() const\n{\n    // This used to return the size of all blobs that were written to ashmem, now we're returning\n    // the ashmem currently referenced by this Parcel, which should be equivalent.\n    // TODO: Remove method once ABI can be changed.\n    return mOpenAshmemSize;\n}\n\nsize_t Parcel::getOpenAshmemSize() const\n{\n    return mOpenAshmemSize;\n}\n\n// --- Parcel::Blob ---\n\nParcel::Blob::Blob() :\n        mFd(-1), mData(nullptr), mSize(0), mMutable(false) {\n}\n\nParcel::Blob::~Blob() {\n    release();\n}\n\nvoid Parcel::Blob::release() {\n    if (mFd != -1 && mData) {\n        ::munmap(mData, mSize);\n    }\n    clear();\n}\n\nvoid Parcel::Blob::init(int fd, void* data, size_t size, bool isMutable) {\n    mFd = fd;\n    mData = data;\n    mSize = size;\n    mMutable = isMutable;\n}\n\nvoid Parcel::Blob::clear() {\n    mFd = -1;\n    mData = nullptr;\n    mSize = 0;\n    mMutable = false;\n}\n\n} // namespace android\n```",
                                    "downstream_file_tokens": {
                                        "openai": 20268,
                                        "general": {
                                            "word_based": 8099,
                                            "char_based": 20103
                                        },
                                        "gemini": 24555
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "4e76d6907ec1e8f065f7af3e4032e4b8cee6b2c1",
                            "repo_path": "android_repos/native",
                            "result": "success",
                            "downstream_patch_content": "commit 4e76d6907ec1e8f065f7af3e4032e4b8cee6b2c1\nAuthor: Steven Moreland <smoreland@google.com>\nDate:   Wed Oct 2 00:37:59 2024 +0000\n\n    libbinder: Parcel: validate read data before write\n    \n    This is slow, but it's required to prevent memory\n    corruption.\n    \n    Ignore-AOSP-First: security\n    Bug: 370840874\n    Test: fuzzer\n    Merged-In: Ibc5566ade0389221690dc90324f93394cf7fc9a5\n    Change-Id: Ibc5566ade0389221690dc90324f93394cf7fc9a5\n    (cherry picked from commit c54dad65317f851ce9d016bd90ec6a7a04da09fc)\n\ndiff --git a/libs/binder/Parcel.cpp b/libs/binder/Parcel.cpp\nindex 58b0b35323..2ddfdd727d 100644\n--- a/libs/binder/Parcel.cpp\n+++ b/libs/binder/Parcel.cpp\n@@ -888,6 +888,10 @@ restart_write:\n         //printf(\"Writing %ld bytes, padded to %ld\\n\", len, padded);\n         uint8_t* const data = mData+mDataPos;\n \n+        if (status_t status = validateReadData(mDataPos + padded); status != OK) {\n+            return nullptr; // drops status\n+        }\n+\n         // Need to pad at end?\n         if (padded != len) {\n #if BYTE_ORDER == BIG_ENDIAN\n@@ -1405,6 +1409,10 @@ status_t Parcel::writeObject(const flat_binder_object& val, bool nullMetaData)\n     const bool enoughObjects = mObjectsSize < mObjectsCapacity;\n     if (enoughData && enoughObjects) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         *reinterpret_cast<flat_binder_object*>(mData+mDataPos) = val;\n \n         // remember if it's a file descriptor\n@@ -1621,6 +1629,10 @@ status_t Parcel::writeAligned(T val) {\n \n     if ((mDataPos+sizeof(val)) <= mDataCapacity) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         memcpy(mData + mDataPos, &val, sizeof(val));\n         return finishWrite(sizeof(val));\n     }\n",
                            "downstream_patch_tokens": {
                                "openai": 578,
                                "general": {
                                    "word_based": 203,
                                    "char_based": 476
                                },
                                "gemini": 727
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "4e76d6907ec1e8f065f7af3e4032e4b8cee6b2c1",
                            "repo_path": "android_repos/native",
                            "result": "success",
                            "downstream_patch_content": "commit 4e76d6907ec1e8f065f7af3e4032e4b8cee6b2c1\nAuthor: Steven Moreland <smoreland@google.com>\nDate:   Wed Oct 2 00:37:59 2024 +0000\n\n    libbinder: Parcel: validate read data before write\n    \n    This is slow, but it's required to prevent memory\n    corruption.\n    \n    Ignore-AOSP-First: security\n    Bug: 370840874\n    Test: fuzzer\n    Merged-In: Ibc5566ade0389221690dc90324f93394cf7fc9a5\n    Change-Id: Ibc5566ade0389221690dc90324f93394cf7fc9a5\n    (cherry picked from commit c54dad65317f851ce9d016bd90ec6a7a04da09fc)\n\ndiff --git a/libs/binder/Parcel.cpp b/libs/binder/Parcel.cpp\nindex 58b0b35323..2ddfdd727d 100644\n--- a/libs/binder/Parcel.cpp\n+++ b/libs/binder/Parcel.cpp\n@@ -888,6 +888,10 @@ restart_write:\n         //printf(\"Writing %ld bytes, padded to %ld\\n\", len, padded);\n         uint8_t* const data = mData+mDataPos;\n \n+        if (status_t status = validateReadData(mDataPos + padded); status != OK) {\n+            return nullptr; // drops status\n+        }\n+\n         // Need to pad at end?\n         if (padded != len) {\n #if BYTE_ORDER == BIG_ENDIAN\n@@ -1405,6 +1409,10 @@ status_t Parcel::writeObject(const flat_binder_object& val, bool nullMetaData)\n     const bool enoughObjects = mObjectsSize < mObjectsCapacity;\n     if (enoughData && enoughObjects) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         *reinterpret_cast<flat_binder_object*>(mData+mDataPos) = val;\n \n         // remember if it's a file descriptor\n@@ -1621,6 +1629,10 @@ status_t Parcel::writeAligned(T val) {\n \n     if ((mDataPos+sizeof(val)) <= mDataCapacity) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         memcpy(mData + mDataPos, &val, sizeof(val));\n         return finishWrite(sizeof(val));\n     }\n",
                            "downstream_patch_tokens": {
                                "openai": 578,
                                "general": {
                                    "word_based": 203,
                                    "char_based": 476
                                },
                                "gemini": 727
                            }
                        }
                    ]
                }
            ]
        }
    ],
    "vulnerabilities_with_all_successful_patches": [
        {
            "id": "ASB-A-365738306",
            "aliases": [
                "A-365738306",
                "CVE-2024-49733"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-365738306",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "234c5e843ca427b1dd47e91e3969f3309dd787bf"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 234c5e843ca427b1dd47e91e3969f3309dd787bf Mon Sep 17 00:00:00 2001\nFrom: Julia Reynolds <juliacr@google.com>\nDate: Mon, 7 Oct 2024 11:10:31 -0400\nSubject: [PATCH] Always show all approved apps\n\nRegardless of what the current criteria is in order to be approved,\nshow everything that's currently approved, since the criteria might\nhave been more lax when it was approved\n\nTest: manual\nTest: ServiceListingTest\nFlag: EXEMPT bug fix\nBug: 365738306\nChange-Id: I6c19d3dbff6ecabc74729a7f021f293e26601944\n---\n .../applications/ServiceListing.java          | 32 ++++++---\n .../applications/ServiceListingTest.java      | 66 ++++++++++++++++++-\n 2 files changed, 88 insertions(+), 10 deletions(-)\n\ndiff --git a/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java b/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\nindex c8bcabff1094..261c722e517c 100644\n--- a/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\n+++ b/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\n@@ -138,23 +138,37 @@ public class ServiceListing {\n         }\n \n         final PackageManager pmWrapper = mContext.getPackageManager();\n+        // Add requesting apps, with full validation\n         List<ResolveInfo> installedServices = pmWrapper.queryIntentServicesAsUser(\n                 new Intent(mIntentAction), flags, user);\n         for (ResolveInfo resolveInfo : installedServices) {\n             ServiceInfo info = resolveInfo.serviceInfo;\n \n-            if (!mPermission.equals(info.permission)) {\n-                Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n-                        + info.packageName + \"/\" + info.name\n-                        + \": it does not require the permission \"\n-                        + mPermission);\n-                continue;\n+            if (!mEnabledServices.contains(info.getComponentName())) {\n+                if (!mPermission.equals(info.permission)) {\n+                    Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n+                            + info.packageName + \"/\" + info.name\n+                            + \": it does not require the permission \"\n+                            + mPermission);\n+                    continue;\n+                }\n+                if (mValidator != null && !mValidator.test(info)) {\n+                    continue;\n+                }\n+                mServices.add(info);\n             }\n-            if (mValidator != null && !mValidator.test(info)) {\n-                continue;\n+        }\n+\n+        // Add all apps with access, in case prior approval was granted without full validation\n+        for (ComponentName cn : mEnabledServices) {\n+            List<ResolveInfo> enabledServices = pmWrapper.queryIntentServicesAsUser(\n+                    new Intent().setComponent(cn), flags, user);\n+            for (ResolveInfo resolveInfo : enabledServices) {\n+                ServiceInfo info = resolveInfo.serviceInfo;\n+                mServices.add(info);\n             }\n-            mServices.add(info);\n         }\n+\n         for (Callback callback : mCallbacks) {\n             callback.onServicesReloaded(mServices);\n         }\ndiff --git a/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java b/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\nindex 7ff0988c494d..feef559dfe26 100644\n--- a/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\n+++ b/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\n@@ -21,6 +21,7 @@ import static com.google.common.truth.Truth.assertThat;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyInt;\n import static org.mockito.ArgumentMatchers.anyList;\n+import static org.mockito.ArgumentMatchers.argThat;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.spy;\n import static org.mockito.Mockito.times;\n@@ -29,6 +30,7 @@ import static org.mockito.Mockito.when;\n \n import android.content.ComponentName;\n import android.content.Context;\n+import android.content.Intent;\n import android.content.pm.PackageManager;\n import android.content.pm.ResolveInfo;\n import android.content.pm.ServiceInfo;\n@@ -42,6 +44,7 @@ import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatcher;\n import org.robolectric.RobolectricTestRunner;\n import org.robolectric.RuntimeEnvironment;\n \n@@ -72,19 +75,26 @@ public class ServiceListingTest {\n                 .build();\n     }\n \n+    private ArgumentMatcher<Intent> filterEquals(Intent intent) {\n+        return (test) -> {\n+            return intent.filterEquals(test);\n+        };\n+    }\n+\n     @Test\n     public void testValidator() {\n         ServiceInfo s1 = new ServiceInfo();\n         s1.permission = \"testPermission\";\n         s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n         ServiceInfo s2 = new ServiceInfo();\n         s2.permission = \"testPermission\";\n         s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n         ResolveInfo r1 = new ResolveInfo();\n         r1.serviceInfo = s1;\n         ResolveInfo r2 = new ResolveInfo();\n         r2.serviceInfo = s2;\n-\n         when(mPm.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(\n                 ImmutableList.of(r1, r2));\n \n@@ -118,9 +128,11 @@ public class ServiceListingTest {\n         ServiceInfo s1 = new ServiceInfo();\n         s1.permission = \"testPermission\";\n         s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n         ServiceInfo s2 = new ServiceInfo();\n         s2.permission = \"testPermission\";\n         s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n         ResolveInfo r1 = new ResolveInfo();\n         r1.serviceInfo = s1;\n         ResolveInfo r2 = new ResolveInfo();\n@@ -193,4 +205,56 @@ public class ServiceListingTest {\n         assertThat(Settings.Secure.getString(RuntimeEnvironment.application.getContentResolver(),\n                 TEST_SETTING)).contains(testComponent2.flattenToString());\n     }\n+\n+    @Test\n+    public void testHasPermissionWithoutMeetingCurrentRegs() {\n+        ServiceInfo s1 = new ServiceInfo();\n+        s1.permission = \"testPermission\";\n+        s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n+        ServiceInfo s2 = new ServiceInfo();\n+        s2.permission = \"testPermission\";\n+        s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n+        ResolveInfo r1 = new ResolveInfo();\n+        r1.serviceInfo = s1;\n+        ResolveInfo r2 = new ResolveInfo();\n+        r2.serviceInfo = s2;\n+\n+        ComponentName approvedComponent = new ComponentName(s2.packageName, s2.name);\n+\n+        Settings.Secure.putString(\n+                mContext.getContentResolver(), TEST_SETTING, approvedComponent.flattenToString());\n+\n+        when(mPm.queryIntentServicesAsUser(argThat(\n+                filterEquals(new Intent(TEST_INTENT))), anyInt(), anyInt()))\n+                .thenReturn(ImmutableList.of(r1));\n+        when(mPm.queryIntentServicesAsUser(argThat(\n+                filterEquals(new Intent().setComponent(approvedComponent))),\n+                anyInt(), anyInt()))\n+                .thenReturn(ImmutableList.of(r2));\n+\n+        mServiceListing = new ServiceListing.Builder(mContext)\n+                .setTag(\"testTag\")\n+                .setSetting(TEST_SETTING)\n+                .setNoun(\"testNoun\")\n+                .setIntentAction(TEST_INTENT)\n+                .setValidator(info -> {\n+                    if (info.packageName.equals(\"pkg\")) {\n+                        return true;\n+                    }\n+                    return false;\n+                })\n+                .setPermission(\"testPermission\")\n+                .build();\n+        ServiceListing.Callback callback = mock(ServiceListing.Callback.class);\n+        mServiceListing.addCallback(callback);\n+        mServiceListing.reload();\n+\n+        verify(mPm, times(2)).queryIntentServicesAsUser(any(), anyInt(), anyInt());\n+        ArgumentCaptor<List<ServiceInfo>> captor = ArgumentCaptor.forClass(List.class);\n+        verify(callback, times(1)).onServicesReloaded(captor.capture());\n+\n+        assertThat(captor.getValue()).containsExactlyElementsIn(ImmutableList.of(s2, s1));\n+    }\n }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 1914,
                        "general": {
                            "word_based": 769,
                            "char_based": 2119
                        },
                        "gemini": 2388
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "e81fa0c19c07a5b6509c3f844b69847a96c7a815",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit e81fa0c19c07a5b6509c3f844b69847a96c7a815\nAuthor: Julia Reynolds <juliacr@google.com>\nDate:   Mon Oct 7 11:10:31 2024 -0400\n\n    Always show all approved apps\n    \n    Regardless of what the current criteria is in order to be approved,\n    show everything that's currently approved, since the criteria might\n    have been more lax when it was approved\n    \n    Test: manual\n    Test: ServiceListingTest\n    Flag: EXEMPT bug fix\n    Bug: 365738306\n    Change-Id: I6c19d3dbff6ecabc74729a7f021f293e26601944\n    (cherry picked from commit 234c5e843ca427b1dd47e91e3969f3309dd787bf)\n\ndiff --git a/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java b/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\nindex c8bcabff1094..261c722e517c 100644\n--- a/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\n+++ b/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\n@@ -138,23 +138,37 @@ public class ServiceListing {\n         }\n \n         final PackageManager pmWrapper = mContext.getPackageManager();\n+        // Add requesting apps, with full validation\n         List<ResolveInfo> installedServices = pmWrapper.queryIntentServicesAsUser(\n                 new Intent(mIntentAction), flags, user);\n         for (ResolveInfo resolveInfo : installedServices) {\n             ServiceInfo info = resolveInfo.serviceInfo;\n \n-            if (!mPermission.equals(info.permission)) {\n-                Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n-                        + info.packageName + \"/\" + info.name\n-                        + \": it does not require the permission \"\n-                        + mPermission);\n-                continue;\n+            if (!mEnabledServices.contains(info.getComponentName())) {\n+                if (!mPermission.equals(info.permission)) {\n+                    Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n+                            + info.packageName + \"/\" + info.name\n+                            + \": it does not require the permission \"\n+                            + mPermission);\n+                    continue;\n+                }\n+                if (mValidator != null && !mValidator.test(info)) {\n+                    continue;\n+                }\n+                mServices.add(info);\n             }\n-            if (mValidator != null && !mValidator.test(info)) {\n-                continue;\n+        }\n+\n+        // Add all apps with access, in case prior approval was granted without full validation\n+        for (ComponentName cn : mEnabledServices) {\n+            List<ResolveInfo> enabledServices = pmWrapper.queryIntentServicesAsUser(\n+                    new Intent().setComponent(cn), flags, user);\n+            for (ResolveInfo resolveInfo : enabledServices) {\n+                ServiceInfo info = resolveInfo.serviceInfo;\n+                mServices.add(info);\n             }\n-            mServices.add(info);\n         }\n+\n         for (Callback callback : mCallbacks) {\n             callback.onServicesReloaded(mServices);\n         }\ndiff --git a/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java b/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\nindex 7ff0988c494d..feef559dfe26 100644\n--- a/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\n+++ b/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\n@@ -21,6 +21,7 @@ import static com.google.common.truth.Truth.assertThat;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyInt;\n import static org.mockito.ArgumentMatchers.anyList;\n+import static org.mockito.ArgumentMatchers.argThat;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.spy;\n import static org.mockito.Mockito.times;\n@@ -29,6 +30,7 @@ import static org.mockito.Mockito.when;\n \n import android.content.ComponentName;\n import android.content.Context;\n+import android.content.Intent;\n import android.content.pm.PackageManager;\n import android.content.pm.ResolveInfo;\n import android.content.pm.ServiceInfo;\n@@ -42,6 +44,7 @@ import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatcher;\n import org.robolectric.RobolectricTestRunner;\n import org.robolectric.RuntimeEnvironment;\n \n@@ -72,19 +75,26 @@ public class ServiceListingTest {\n                 .build();\n     }\n \n+    private ArgumentMatcher<Intent> filterEquals(Intent intent) {\n+        return (test) -> {\n+            return intent.filterEquals(test);\n+        };\n+    }\n+\n     @Test\n     public void testValidator() {\n         ServiceInfo s1 = new ServiceInfo();\n         s1.permission = \"testPermission\";\n         s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n         ServiceInfo s2 = new ServiceInfo();\n         s2.permission = \"testPermission\";\n         s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n         ResolveInfo r1 = new ResolveInfo();\n         r1.serviceInfo = s1;\n         ResolveInfo r2 = new ResolveInfo();\n         r2.serviceInfo = s2;\n-\n         when(mPm.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(\n                 ImmutableList.of(r1, r2));\n \n@@ -118,9 +128,11 @@ public class ServiceListingTest {\n         ServiceInfo s1 = new ServiceInfo();\n         s1.permission = \"testPermission\";\n         s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n         ServiceInfo s2 = new ServiceInfo();\n         s2.permission = \"testPermission\";\n         s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n         ResolveInfo r1 = new ResolveInfo();\n         r1.serviceInfo = s1;\n         ResolveInfo r2 = new ResolveInfo();\n@@ -193,4 +205,56 @@ public class ServiceListingTest {\n         assertThat(Settings.Secure.getString(RuntimeEnvironment.application.getContentResolver(),\n                 TEST_SETTING)).contains(testComponent2.flattenToString());\n     }\n+\n+    @Test\n+    public void testHasPermissionWithoutMeetingCurrentRegs() {\n+        ServiceInfo s1 = new ServiceInfo();\n+        s1.permission = \"testPermission\";\n+        s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n+        ServiceInfo s2 = new ServiceInfo();\n+        s2.permission = \"testPermission\";\n+        s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n+        ResolveInfo r1 = new ResolveInfo();\n+        r1.serviceInfo = s1;\n+        ResolveInfo r2 = new ResolveInfo();\n+        r2.serviceInfo = s2;\n+\n+        ComponentName approvedComponent = new ComponentName(s2.packageName, s2.name);\n+\n+        Settings.Secure.putString(\n+                mContext.getContentResolver(), TEST_SETTING, approvedComponent.flattenToString());\n+\n+        when(mPm.queryIntentServicesAsUser(argThat(\n+                filterEquals(new Intent(TEST_INTENT))), anyInt(), anyInt()))\n+                .thenReturn(ImmutableList.of(r1));\n+        when(mPm.queryIntentServicesAsUser(argThat(\n+                filterEquals(new Intent().setComponent(approvedComponent))),\n+                anyInt(), anyInt()))\n+                .thenReturn(ImmutableList.of(r2));\n+\n+        mServiceListing = new ServiceListing.Builder(mContext)\n+                .setTag(\"testTag\")\n+                .setSetting(TEST_SETTING)\n+                .setNoun(\"testNoun\")\n+                .setIntentAction(TEST_INTENT)\n+                .setValidator(info -> {\n+                    if (info.packageName.equals(\"pkg\")) {\n+                        return true;\n+                    }\n+                    return false;\n+                })\n+                .setPermission(\"testPermission\")\n+                .build();\n+        ServiceListing.Callback callback = mock(ServiceListing.Callback.class);\n+        mServiceListing.addCallback(callback);\n+        mServiceListing.reload();\n+\n+        verify(mPm, times(2)).queryIntentServicesAsUser(any(), anyInt(), anyInt());\n+        ArgumentCaptor<List<ServiceInfo>> captor = ArgumentCaptor.forClass(List.class);\n+        verify(callback, times(1)).onServicesReloaded(captor.capture());\n+\n+        assertThat(captor.getValue()).containsExactlyElementsIn(ImmutableList.of(s2, s1));\n+    }\n }\n",
                            "downstream_patch_tokens": {
                                "openai": 1877,
                                "general": {
                                    "word_based": 744,
                                    "char_based": 2085
                                },
                                "gemini": 2352
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "e81fa0c19c07a5b6509c3f844b69847a96c7a815",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit e81fa0c19c07a5b6509c3f844b69847a96c7a815\nAuthor: Julia Reynolds <juliacr@google.com>\nDate:   Mon Oct 7 11:10:31 2024 -0400\n\n    Always show all approved apps\n    \n    Regardless of what the current criteria is in order to be approved,\n    show everything that's currently approved, since the criteria might\n    have been more lax when it was approved\n    \n    Test: manual\n    Test: ServiceListingTest\n    Flag: EXEMPT bug fix\n    Bug: 365738306\n    Change-Id: I6c19d3dbff6ecabc74729a7f021f293e26601944\n    (cherry picked from commit 234c5e843ca427b1dd47e91e3969f3309dd787bf)\n\ndiff --git a/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java b/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\nindex c8bcabff1094..261c722e517c 100644\n--- a/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\n+++ b/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\n@@ -138,23 +138,37 @@ public class ServiceListing {\n         }\n \n         final PackageManager pmWrapper = mContext.getPackageManager();\n+        // Add requesting apps, with full validation\n         List<ResolveInfo> installedServices = pmWrapper.queryIntentServicesAsUser(\n                 new Intent(mIntentAction), flags, user);\n         for (ResolveInfo resolveInfo : installedServices) {\n             ServiceInfo info = resolveInfo.serviceInfo;\n \n-            if (!mPermission.equals(info.permission)) {\n-                Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n-                        + info.packageName + \"/\" + info.name\n-                        + \": it does not require the permission \"\n-                        + mPermission);\n-                continue;\n+            if (!mEnabledServices.contains(info.getComponentName())) {\n+                if (!mPermission.equals(info.permission)) {\n+                    Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n+                            + info.packageName + \"/\" + info.name\n+                            + \": it does not require the permission \"\n+                            + mPermission);\n+                    continue;\n+                }\n+                if (mValidator != null && !mValidator.test(info)) {\n+                    continue;\n+                }\n+                mServices.add(info);\n             }\n-            if (mValidator != null && !mValidator.test(info)) {\n-                continue;\n+        }\n+\n+        // Add all apps with access, in case prior approval was granted without full validation\n+        for (ComponentName cn : mEnabledServices) {\n+            List<ResolveInfo> enabledServices = pmWrapper.queryIntentServicesAsUser(\n+                    new Intent().setComponent(cn), flags, user);\n+            for (ResolveInfo resolveInfo : enabledServices) {\n+                ServiceInfo info = resolveInfo.serviceInfo;\n+                mServices.add(info);\n             }\n-            mServices.add(info);\n         }\n+\n         for (Callback callback : mCallbacks) {\n             callback.onServicesReloaded(mServices);\n         }\ndiff --git a/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java b/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\nindex 7ff0988c494d..feef559dfe26 100644\n--- a/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\n+++ b/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\n@@ -21,6 +21,7 @@ import static com.google.common.truth.Truth.assertThat;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyInt;\n import static org.mockito.ArgumentMatchers.anyList;\n+import static org.mockito.ArgumentMatchers.argThat;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.spy;\n import static org.mockito.Mockito.times;\n@@ -29,6 +30,7 @@ import static org.mockito.Mockito.when;\n \n import android.content.ComponentName;\n import android.content.Context;\n+import android.content.Intent;\n import android.content.pm.PackageManager;\n import android.content.pm.ResolveInfo;\n import android.content.pm.ServiceInfo;\n@@ -42,6 +44,7 @@ import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatcher;\n import org.robolectric.RobolectricTestRunner;\n import org.robolectric.RuntimeEnvironment;\n \n@@ -72,19 +75,26 @@ public class ServiceListingTest {\n                 .build();\n     }\n \n+    private ArgumentMatcher<Intent> filterEquals(Intent intent) {\n+        return (test) -> {\n+            return intent.filterEquals(test);\n+        };\n+    }\n+\n     @Test\n     public void testValidator() {\n         ServiceInfo s1 = new ServiceInfo();\n         s1.permission = \"testPermission\";\n         s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n         ServiceInfo s2 = new ServiceInfo();\n         s2.permission = \"testPermission\";\n         s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n         ResolveInfo r1 = new ResolveInfo();\n         r1.serviceInfo = s1;\n         ResolveInfo r2 = new ResolveInfo();\n         r2.serviceInfo = s2;\n-\n         when(mPm.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(\n                 ImmutableList.of(r1, r2));\n \n@@ -118,9 +128,11 @@ public class ServiceListingTest {\n         ServiceInfo s1 = new ServiceInfo();\n         s1.permission = \"testPermission\";\n         s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n         ServiceInfo s2 = new ServiceInfo();\n         s2.permission = \"testPermission\";\n         s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n         ResolveInfo r1 = new ResolveInfo();\n         r1.serviceInfo = s1;\n         ResolveInfo r2 = new ResolveInfo();\n@@ -193,4 +205,56 @@ public class ServiceListingTest {\n         assertThat(Settings.Secure.getString(RuntimeEnvironment.application.getContentResolver(),\n                 TEST_SETTING)).contains(testComponent2.flattenToString());\n     }\n+\n+    @Test\n+    public void testHasPermissionWithoutMeetingCurrentRegs() {\n+        ServiceInfo s1 = new ServiceInfo();\n+        s1.permission = \"testPermission\";\n+        s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n+        ServiceInfo s2 = new ServiceInfo();\n+        s2.permission = \"testPermission\";\n+        s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n+        ResolveInfo r1 = new ResolveInfo();\n+        r1.serviceInfo = s1;\n+        ResolveInfo r2 = new ResolveInfo();\n+        r2.serviceInfo = s2;\n+\n+        ComponentName approvedComponent = new ComponentName(s2.packageName, s2.name);\n+\n+        Settings.Secure.putString(\n+                mContext.getContentResolver(), TEST_SETTING, approvedComponent.flattenToString());\n+\n+        when(mPm.queryIntentServicesAsUser(argThat(\n+                filterEquals(new Intent(TEST_INTENT))), anyInt(), anyInt()))\n+                .thenReturn(ImmutableList.of(r1));\n+        when(mPm.queryIntentServicesAsUser(argThat(\n+                filterEquals(new Intent().setComponent(approvedComponent))),\n+                anyInt(), anyInt()))\n+                .thenReturn(ImmutableList.of(r2));\n+\n+        mServiceListing = new ServiceListing.Builder(mContext)\n+                .setTag(\"testTag\")\n+                .setSetting(TEST_SETTING)\n+                .setNoun(\"testNoun\")\n+                .setIntentAction(TEST_INTENT)\n+                .setValidator(info -> {\n+                    if (info.packageName.equals(\"pkg\")) {\n+                        return true;\n+                    }\n+                    return false;\n+                })\n+                .setPermission(\"testPermission\")\n+                .build();\n+        ServiceListing.Callback callback = mock(ServiceListing.Callback.class);\n+        mServiceListing.addCallback(callback);\n+        mServiceListing.reload();\n+\n+        verify(mPm, times(2)).queryIntentServicesAsUser(any(), anyInt(), anyInt());\n+        ArgumentCaptor<List<ServiceInfo>> captor = ArgumentCaptor.forClass(List.class);\n+        verify(callback, times(1)).onServicesReloaded(captor.capture());\n+\n+        assertThat(captor.getValue()).containsExactlyElementsIn(ImmutableList.of(s2, s1));\n+    }\n }\n",
                            "downstream_patch_tokens": {
                                "openai": 1877,
                                "general": {
                                    "word_based": 744,
                                    "char_based": 2085
                                },
                                "gemini": 2352
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "e81fa0c19c07a5b6509c3f844b69847a96c7a815",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit e81fa0c19c07a5b6509c3f844b69847a96c7a815\nAuthor: Julia Reynolds <juliacr@google.com>\nDate:   Mon Oct 7 11:10:31 2024 -0400\n\n    Always show all approved apps\n    \n    Regardless of what the current criteria is in order to be approved,\n    show everything that's currently approved, since the criteria might\n    have been more lax when it was approved\n    \n    Test: manual\n    Test: ServiceListingTest\n    Flag: EXEMPT bug fix\n    Bug: 365738306\n    Change-Id: I6c19d3dbff6ecabc74729a7f021f293e26601944\n    (cherry picked from commit 234c5e843ca427b1dd47e91e3969f3309dd787bf)\n\ndiff --git a/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java b/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\nindex c8bcabff1094..261c722e517c 100644\n--- a/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\n+++ b/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\n@@ -138,23 +138,37 @@ public class ServiceListing {\n         }\n \n         final PackageManager pmWrapper = mContext.getPackageManager();\n+        // Add requesting apps, with full validation\n         List<ResolveInfo> installedServices = pmWrapper.queryIntentServicesAsUser(\n                 new Intent(mIntentAction), flags, user);\n         for (ResolveInfo resolveInfo : installedServices) {\n             ServiceInfo info = resolveInfo.serviceInfo;\n \n-            if (!mPermission.equals(info.permission)) {\n-                Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n-                        + info.packageName + \"/\" + info.name\n-                        + \": it does not require the permission \"\n-                        + mPermission);\n-                continue;\n+            if (!mEnabledServices.contains(info.getComponentName())) {\n+                if (!mPermission.equals(info.permission)) {\n+                    Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n+                            + info.packageName + \"/\" + info.name\n+                            + \": it does not require the permission \"\n+                            + mPermission);\n+                    continue;\n+                }\n+                if (mValidator != null && !mValidator.test(info)) {\n+                    continue;\n+                }\n+                mServices.add(info);\n             }\n-            if (mValidator != null && !mValidator.test(info)) {\n-                continue;\n+        }\n+\n+        // Add all apps with access, in case prior approval was granted without full validation\n+        for (ComponentName cn : mEnabledServices) {\n+            List<ResolveInfo> enabledServices = pmWrapper.queryIntentServicesAsUser(\n+                    new Intent().setComponent(cn), flags, user);\n+            for (ResolveInfo resolveInfo : enabledServices) {\n+                ServiceInfo info = resolveInfo.serviceInfo;\n+                mServices.add(info);\n             }\n-            mServices.add(info);\n         }\n+\n         for (Callback callback : mCallbacks) {\n             callback.onServicesReloaded(mServices);\n         }\ndiff --git a/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java b/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\nindex 7ff0988c494d..feef559dfe26 100644\n--- a/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\n+++ b/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\n@@ -21,6 +21,7 @@ import static com.google.common.truth.Truth.assertThat;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyInt;\n import static org.mockito.ArgumentMatchers.anyList;\n+import static org.mockito.ArgumentMatchers.argThat;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.spy;\n import static org.mockito.Mockito.times;\n@@ -29,6 +30,7 @@ import static org.mockito.Mockito.when;\n \n import android.content.ComponentName;\n import android.content.Context;\n+import android.content.Intent;\n import android.content.pm.PackageManager;\n import android.content.pm.ResolveInfo;\n import android.content.pm.ServiceInfo;\n@@ -42,6 +44,7 @@ import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatcher;\n import org.robolectric.RobolectricTestRunner;\n import org.robolectric.RuntimeEnvironment;\n \n@@ -72,19 +75,26 @@ public class ServiceListingTest {\n                 .build();\n     }\n \n+    private ArgumentMatcher<Intent> filterEquals(Intent intent) {\n+        return (test) -> {\n+            return intent.filterEquals(test);\n+        };\n+    }\n+\n     @Test\n     public void testValidator() {\n         ServiceInfo s1 = new ServiceInfo();\n         s1.permission = \"testPermission\";\n         s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n         ServiceInfo s2 = new ServiceInfo();\n         s2.permission = \"testPermission\";\n         s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n         ResolveInfo r1 = new ResolveInfo();\n         r1.serviceInfo = s1;\n         ResolveInfo r2 = new ResolveInfo();\n         r2.serviceInfo = s2;\n-\n         when(mPm.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(\n                 ImmutableList.of(r1, r2));\n \n@@ -118,9 +128,11 @@ public class ServiceListingTest {\n         ServiceInfo s1 = new ServiceInfo();\n         s1.permission = \"testPermission\";\n         s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n         ServiceInfo s2 = new ServiceInfo();\n         s2.permission = \"testPermission\";\n         s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n         ResolveInfo r1 = new ResolveInfo();\n         r1.serviceInfo = s1;\n         ResolveInfo r2 = new ResolveInfo();\n@@ -193,4 +205,56 @@ public class ServiceListingTest {\n         assertThat(Settings.Secure.getString(RuntimeEnvironment.application.getContentResolver(),\n                 TEST_SETTING)).contains(testComponent2.flattenToString());\n     }\n+\n+    @Test\n+    public void testHasPermissionWithoutMeetingCurrentRegs() {\n+        ServiceInfo s1 = new ServiceInfo();\n+        s1.permission = \"testPermission\";\n+        s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n+        ServiceInfo s2 = new ServiceInfo();\n+        s2.permission = \"testPermission\";\n+        s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n+        ResolveInfo r1 = new ResolveInfo();\n+        r1.serviceInfo = s1;\n+        ResolveInfo r2 = new ResolveInfo();\n+        r2.serviceInfo = s2;\n+\n+        ComponentName approvedComponent = new ComponentName(s2.packageName, s2.name);\n+\n+        Settings.Secure.putString(\n+                mContext.getContentResolver(), TEST_SETTING, approvedComponent.flattenToString());\n+\n+        when(mPm.queryIntentServicesAsUser(argThat(\n+                filterEquals(new Intent(TEST_INTENT))), anyInt(), anyInt()))\n+                .thenReturn(ImmutableList.of(r1));\n+        when(mPm.queryIntentServicesAsUser(argThat(\n+                filterEquals(new Intent().setComponent(approvedComponent))),\n+                anyInt(), anyInt()))\n+                .thenReturn(ImmutableList.of(r2));\n+\n+        mServiceListing = new ServiceListing.Builder(mContext)\n+                .setTag(\"testTag\")\n+                .setSetting(TEST_SETTING)\n+                .setNoun(\"testNoun\")\n+                .setIntentAction(TEST_INTENT)\n+                .setValidator(info -> {\n+                    if (info.packageName.equals(\"pkg\")) {\n+                        return true;\n+                    }\n+                    return false;\n+                })\n+                .setPermission(\"testPermission\")\n+                .build();\n+        ServiceListing.Callback callback = mock(ServiceListing.Callback.class);\n+        mServiceListing.addCallback(callback);\n+        mServiceListing.reload();\n+\n+        verify(mPm, times(2)).queryIntentServicesAsUser(any(), anyInt(), anyInt());\n+        ArgumentCaptor<List<ServiceInfo>> captor = ArgumentCaptor.forClass(List.class);\n+        verify(callback, times(1)).onServicesReloaded(captor.capture());\n+\n+        assertThat(captor.getValue()).containsExactlyElementsIn(ImmutableList.of(s2, s1));\n+    }\n }\n",
                            "downstream_patch_tokens": {
                                "openai": 1877,
                                "general": {
                                    "word_based": 744,
                                    "char_based": 2085
                                },
                                "gemini": 2352
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "e81fa0c19c07a5b6509c3f844b69847a96c7a815",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit e81fa0c19c07a5b6509c3f844b69847a96c7a815\nAuthor: Julia Reynolds <juliacr@google.com>\nDate:   Mon Oct 7 11:10:31 2024 -0400\n\n    Always show all approved apps\n    \n    Regardless of what the current criteria is in order to be approved,\n    show everything that's currently approved, since the criteria might\n    have been more lax when it was approved\n    \n    Test: manual\n    Test: ServiceListingTest\n    Flag: EXEMPT bug fix\n    Bug: 365738306\n    Change-Id: I6c19d3dbff6ecabc74729a7f021f293e26601944\n    (cherry picked from commit 234c5e843ca427b1dd47e91e3969f3309dd787bf)\n\ndiff --git a/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java b/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\nindex c8bcabff1094..261c722e517c 100644\n--- a/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\n+++ b/packages/SettingsLib/src/com/android/settingslib/applications/ServiceListing.java\n@@ -138,23 +138,37 @@ public class ServiceListing {\n         }\n \n         final PackageManager pmWrapper = mContext.getPackageManager();\n+        // Add requesting apps, with full validation\n         List<ResolveInfo> installedServices = pmWrapper.queryIntentServicesAsUser(\n                 new Intent(mIntentAction), flags, user);\n         for (ResolveInfo resolveInfo : installedServices) {\n             ServiceInfo info = resolveInfo.serviceInfo;\n \n-            if (!mPermission.equals(info.permission)) {\n-                Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n-                        + info.packageName + \"/\" + info.name\n-                        + \": it does not require the permission \"\n-                        + mPermission);\n-                continue;\n+            if (!mEnabledServices.contains(info.getComponentName())) {\n+                if (!mPermission.equals(info.permission)) {\n+                    Slog.w(mTag, \"Skipping \" + mNoun + \" service \"\n+                            + info.packageName + \"/\" + info.name\n+                            + \": it does not require the permission \"\n+                            + mPermission);\n+                    continue;\n+                }\n+                if (mValidator != null && !mValidator.test(info)) {\n+                    continue;\n+                }\n+                mServices.add(info);\n             }\n-            if (mValidator != null && !mValidator.test(info)) {\n-                continue;\n+        }\n+\n+        // Add all apps with access, in case prior approval was granted without full validation\n+        for (ComponentName cn : mEnabledServices) {\n+            List<ResolveInfo> enabledServices = pmWrapper.queryIntentServicesAsUser(\n+                    new Intent().setComponent(cn), flags, user);\n+            for (ResolveInfo resolveInfo : enabledServices) {\n+                ServiceInfo info = resolveInfo.serviceInfo;\n+                mServices.add(info);\n             }\n-            mServices.add(info);\n         }\n+\n         for (Callback callback : mCallbacks) {\n             callback.onServicesReloaded(mServices);\n         }\ndiff --git a/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java b/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\nindex 7ff0988c494d..feef559dfe26 100644\n--- a/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\n+++ b/packages/SettingsLib/tests/robotests/src/com/android/settingslib/applications/ServiceListingTest.java\n@@ -21,6 +21,7 @@ import static com.google.common.truth.Truth.assertThat;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyInt;\n import static org.mockito.ArgumentMatchers.anyList;\n+import static org.mockito.ArgumentMatchers.argThat;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.spy;\n import static org.mockito.Mockito.times;\n@@ -29,6 +30,7 @@ import static org.mockito.Mockito.when;\n \n import android.content.ComponentName;\n import android.content.Context;\n+import android.content.Intent;\n import android.content.pm.PackageManager;\n import android.content.pm.ResolveInfo;\n import android.content.pm.ServiceInfo;\n@@ -42,6 +44,7 @@ import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatcher;\n import org.robolectric.RobolectricTestRunner;\n import org.robolectric.RuntimeEnvironment;\n \n@@ -72,19 +75,26 @@ public class ServiceListingTest {\n                 .build();\n     }\n \n+    private ArgumentMatcher<Intent> filterEquals(Intent intent) {\n+        return (test) -> {\n+            return intent.filterEquals(test);\n+        };\n+    }\n+\n     @Test\n     public void testValidator() {\n         ServiceInfo s1 = new ServiceInfo();\n         s1.permission = \"testPermission\";\n         s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n         ServiceInfo s2 = new ServiceInfo();\n         s2.permission = \"testPermission\";\n         s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n         ResolveInfo r1 = new ResolveInfo();\n         r1.serviceInfo = s1;\n         ResolveInfo r2 = new ResolveInfo();\n         r2.serviceInfo = s2;\n-\n         when(mPm.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(\n                 ImmutableList.of(r1, r2));\n \n@@ -118,9 +128,11 @@ public class ServiceListingTest {\n         ServiceInfo s1 = new ServiceInfo();\n         s1.permission = \"testPermission\";\n         s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n         ServiceInfo s2 = new ServiceInfo();\n         s2.permission = \"testPermission\";\n         s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n         ResolveInfo r1 = new ResolveInfo();\n         r1.serviceInfo = s1;\n         ResolveInfo r2 = new ResolveInfo();\n@@ -193,4 +205,56 @@ public class ServiceListingTest {\n         assertThat(Settings.Secure.getString(RuntimeEnvironment.application.getContentResolver(),\n                 TEST_SETTING)).contains(testComponent2.flattenToString());\n     }\n+\n+    @Test\n+    public void testHasPermissionWithoutMeetingCurrentRegs() {\n+        ServiceInfo s1 = new ServiceInfo();\n+        s1.permission = \"testPermission\";\n+        s1.packageName = \"pkg\";\n+        s1.name = \"Service1\";\n+        ServiceInfo s2 = new ServiceInfo();\n+        s2.permission = \"testPermission\";\n+        s2.packageName = \"pkg2\";\n+        s2.name = \"service2\";\n+        ResolveInfo r1 = new ResolveInfo();\n+        r1.serviceInfo = s1;\n+        ResolveInfo r2 = new ResolveInfo();\n+        r2.serviceInfo = s2;\n+\n+        ComponentName approvedComponent = new ComponentName(s2.packageName, s2.name);\n+\n+        Settings.Secure.putString(\n+                mContext.getContentResolver(), TEST_SETTING, approvedComponent.flattenToString());\n+\n+        when(mPm.queryIntentServicesAsUser(argThat(\n+                filterEquals(new Intent(TEST_INTENT))), anyInt(), anyInt()))\n+                .thenReturn(ImmutableList.of(r1));\n+        when(mPm.queryIntentServicesAsUser(argThat(\n+                filterEquals(new Intent().setComponent(approvedComponent))),\n+                anyInt(), anyInt()))\n+                .thenReturn(ImmutableList.of(r2));\n+\n+        mServiceListing = new ServiceListing.Builder(mContext)\n+                .setTag(\"testTag\")\n+                .setSetting(TEST_SETTING)\n+                .setNoun(\"testNoun\")\n+                .setIntentAction(TEST_INTENT)\n+                .setValidator(info -> {\n+                    if (info.packageName.equals(\"pkg\")) {\n+                        return true;\n+                    }\n+                    return false;\n+                })\n+                .setPermission(\"testPermission\")\n+                .build();\n+        ServiceListing.Callback callback = mock(ServiceListing.Callback.class);\n+        mServiceListing.addCallback(callback);\n+        mServiceListing.reload();\n+\n+        verify(mPm, times(2)).queryIntentServicesAsUser(any(), anyInt(), anyInt());\n+        ArgumentCaptor<List<ServiceInfo>> captor = ArgumentCaptor.forClass(List.class);\n+        verify(callback, times(1)).onServicesReloaded(captor.capture());\n+\n+        assertThat(captor.getValue()).containsExactlyElementsIn(ImmutableList.of(s2, s1));\n+    }\n }\n",
                            "downstream_patch_tokens": {
                                "openai": 1877,
                                "general": {
                                    "word_based": 744,
                                    "char_based": 2085
                                },
                                "gemini": 2352
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-354682735",
            "aliases": [
                "A-354682735",
                "CVE-2024-49721"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-354682735",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "bc2fbfc0b73535ce9d0c9f73b5130cfffaf4daee"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From bc2fbfc0b73535ce9d0c9f73b5130cfffaf4daee Mon Sep 17 00:00:00 2001\nFrom: Adrian Roos <roosa@google.com>\nDate: Fri, 2 Jun 2023 13:57:57 +0000\nSubject: [PATCH] InputMethodSubtypeArray: prevent negative count injection\n\nFixes an issue where negative counts could be injected\nvia the Parcel constructor. The writeToParcel method\nin that case would write data that a subsequent read would\nnot consume.\n\nFixes: 277916797\nTest: atest InputMethodSubtypeArrayTest\nChange-Id: I7e881d82415051179c59bf5df97f8ba0a41e693e\n---\n .../inputmethod/InputMethodSubtypeArray.java  |  4 +++\n .../InputMethodSubtypeArrayTest.java          | 36 +++++++++++++++++++\n 2 files changed, 40 insertions(+)\n\ndiff --git a/core/java/android/view/inputmethod/InputMethodSubtypeArray.java b/core/java/android/view/inputmethod/InputMethodSubtypeArray.java\nindex 50e95c80cfed..ee36dc72e346 100644\n--- a/core/java/android/view/inputmethod/InputMethodSubtypeArray.java\n+++ b/core/java/android/view/inputmethod/InputMethodSubtypeArray.java\n@@ -17,6 +17,7 @@\n package android.view.inputmethod;\n \n import android.compat.annotation.UnsupportedAppUsage;\n+import android.os.BadParcelableException;\n import android.os.Parcel;\n import android.util.Slog;\n \n@@ -69,6 +70,9 @@ public class InputMethodSubtypeArray {\n      */\n     public InputMethodSubtypeArray(final Parcel source) {\n         mCount = source.readInt();\n+        if (mCount < 0) {\n+            throw new BadParcelableException(\"mCount must be non-negative.\");\n+        }\n         if (mCount > 0) {\n             mDecompressedSize = source.readInt();\n             mCompressedData = source.createByteArray();\ndiff --git a/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java b/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java\nindex e2fb46af5b64..e7b1110f898a 100644\n--- a/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java\n+++ b/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java\n@@ -16,9 +16,14 @@\n \n package android.view.inputmethod;\n \n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n+\n import static org.junit.Assert.assertEquals;\n \n+import android.os.BadParcelableException;\n import android.os.Parcel;\n+import android.platform.test.annotations.Presubmit;\n import android.view.inputmethod.InputMethodSubtype.InputMethodSubtypeBuilder;\n \n import androidx.test.filters.SmallTest;\n@@ -31,6 +36,7 @@ import java.util.ArrayList;\n \n @SmallTest\n @RunWith(AndroidJUnit4.class)\n+@Presubmit\n public class InputMethodSubtypeArrayTest {\n \n     @Test\n@@ -59,6 +65,36 @@ public class InputMethodSubtypeArrayTest {\n         assertEquals(clonedArray.get(2), clonedClonedArray.get(2));\n     }\n \n+    @Test\n+    public void testNegativeCount() throws Exception {\n+        InputMethodSubtypeArray negativeCountArray;\n+        try {\n+            // Construct a InputMethodSubtypeArray with: mCount = -1\n+            var p = Parcel.obtain();\n+            p.writeInt(-1);\n+            p.setDataPosition(0);\n+            negativeCountArray = new InputMethodSubtypeArray(p);\n+        } catch (BadParcelableException e) {\n+            // Expected with fix: Prevent negative mCount\n+            assertThat(e).hasMessageThat().contains(\"mCount\");\n+            return;\n+        }\n+        assertWithMessage(\"Test set-up failed\")\n+                .that(negativeCountArray.getCount()).isEqualTo(-1);\n+\n+        var p = Parcel.obtain();\n+        // Writes: int (mCount), int (mDecompressedSize), byte[] (mCompressedData)\n+        negativeCountArray.writeToParcel(p);\n+        p.setDataPosition(0);\n+        // Reads: int (mCount)\n+        // Leaves: int (mDecompressedSize), byte[] (mCompressedData)\n+        new InputMethodSubtypeArray(p);\n+\n+        assertWithMessage(\"Didn't read all data that was previously written\")\n+                .that(p.dataPosition())\n+                .isEqualTo(p.dataSize());\n+    }\n+\n     InputMethodSubtypeArray cloneViaParcel(final InputMethodSubtypeArray original) {\n         Parcel parcel = null;\n         try {\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 1048,
                        "general": {
                            "word_based": 423,
                            "char_based": 1041
                        },
                        "gemini": 1303
                    },
                    "total_downstream_versions_tested": 3,
                    "successful_patches": 3,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "1e973616542153aaed999c4f1c292ce493f40049",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 1e973616542153aaed999c4f1c292ce493f40049\nAuthor: Adrian Roos <roosa@google.com>\nDate:   Fri Jun 2 13:57:57 2023 +0000\n\n    InputMethodSubtypeArray: prevent negative count injection\n    \n    Fixes an issue where negative counts could be injected\n    via the Parcel constructor. The writeToParcel method\n    in that case would write data that a subsequent read would\n    not consume.\n    \n    Fixes: 277916797\n    Fixes: 354682735\n    Test: atest InputMethodSubtypeArrayTest\n    Merged-In: I7e881d82415051179c59bf5df97f8ba0a41e693e\n    Change-Id: I7e881d82415051179c59bf5df97f8ba0a41e693e\n\ndiff --git a/core/java/android/view/inputmethod/InputMethodSubtypeArray.java b/core/java/android/view/inputmethod/InputMethodSubtypeArray.java\nindex 50e95c80cfed..ee36dc72e346 100644\n--- a/core/java/android/view/inputmethod/InputMethodSubtypeArray.java\n+++ b/core/java/android/view/inputmethod/InputMethodSubtypeArray.java\n@@ -17,6 +17,7 @@\n package android.view.inputmethod;\n \n import android.compat.annotation.UnsupportedAppUsage;\n+import android.os.BadParcelableException;\n import android.os.Parcel;\n import android.util.Slog;\n \n@@ -69,6 +70,9 @@ public class InputMethodSubtypeArray {\n      */\n     public InputMethodSubtypeArray(final Parcel source) {\n         mCount = source.readInt();\n+        if (mCount < 0) {\n+            throw new BadParcelableException(\"mCount must be non-negative.\");\n+        }\n         if (mCount > 0) {\n             mDecompressedSize = source.readInt();\n             mCompressedData = source.createByteArray();\ndiff --git a/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java b/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java\nindex e2fb46af5b64..5af8558ccde9 100644\n--- a/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java\n+++ b/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java\n@@ -16,9 +16,14 @@\n \n package android.view.inputmethod;\n \n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n+\n import static org.junit.Assert.assertEquals;\n \n+import android.os.BadParcelableException;\n import android.os.Parcel;\n+import android.platform.test.annotations.Presubmit;\n import android.view.inputmethod.InputMethodSubtype.InputMethodSubtypeBuilder;\n \n import androidx.test.filters.SmallTest;\n@@ -31,6 +36,7 @@ import java.util.ArrayList;\n \n @SmallTest\n @RunWith(AndroidJUnit4.class)\n+@Presubmit\n public class InputMethodSubtypeArrayTest {\n \n     @Test\n@@ -59,6 +65,36 @@ public class InputMethodSubtypeArrayTest {\n         assertEquals(clonedArray.get(2), clonedClonedArray.get(2));\n     }\n \n+    @Test\n+    public void testNegativeCount() throws Exception {\n+        InputMethodSubtypeArray negativeCountArray;\n+        try {\n+            // Construct a InputMethodSubtypeArray with: mCount = -1\n+            Parcel p = Parcel.obtain();\n+            p.writeInt(-1);\n+            p.setDataPosition(0);\n+            negativeCountArray = new InputMethodSubtypeArray(p);\n+        } catch (BadParcelableException e) {\n+            // Expected with fix: Prevent negative mCount\n+            assertThat(e).hasMessageThat().contains(\"mCount\");\n+            return;\n+        }\n+        assertWithMessage(\"Test set-up failed\")\n+                .that(negativeCountArray.getCount()).isEqualTo(-1);\n+\n+        Parcel p = Parcel.obtain();\n+        // Writes: int (mCount), int (mDecompressedSize), byte[] (mCompressedData)\n+        negativeCountArray.writeToParcel(p);\n+        p.setDataPosition(0);\n+        // Reads: int (mCount)\n+        // Leaves: int (mDecompressedSize), byte[] (mCompressedData)\n+        new InputMethodSubtypeArray(p);\n+\n+        assertWithMessage(\"Didn't read all data that was previously written\")\n+                .that(p.dataPosition())\n+                .isEqualTo(p.dataSize());\n+    }\n+\n     InputMethodSubtypeArray cloneViaParcel(final InputMethodSubtypeArray original) {\n         Parcel parcel = null;\n         try {\n",
                            "downstream_patch_tokens": {
                                "openai": 1012,
                                "general": {
                                    "word_based": 401,
                                    "char_based": 1014
                                },
                                "gemini": 1287
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "b7acc399ad02f3c2faa6cdb61a86a3c642418208",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit b7acc399ad02f3c2faa6cdb61a86a3c642418208\nAuthor: Adrian Roos <roosa@google.com>\nDate:   Fri Jun 2 13:57:57 2023 +0000\n\n    InputMethodSubtypeArray: prevent negative count injection\n    \n    Fixes an issue where negative counts could be injected\n    via the Parcel constructor. The writeToParcel method\n    in that case would write data that a subsequent read would\n    not consume.\n    \n    Fixes: 277916797\n    Fixes: 354682735\n    Test: atest InputMethodSubtypeArrayTest\n    Merged-In: I7e881d82415051179c59bf5df97f8ba0a41e693e\n    Change-Id: I7e881d82415051179c59bf5df97f8ba0a41e693e\n\ndiff --git a/core/java/android/view/inputmethod/InputMethodSubtypeArray.java b/core/java/android/view/inputmethod/InputMethodSubtypeArray.java\nindex 50e95c80cfed..ee36dc72e346 100644\n--- a/core/java/android/view/inputmethod/InputMethodSubtypeArray.java\n+++ b/core/java/android/view/inputmethod/InputMethodSubtypeArray.java\n@@ -17,6 +17,7 @@\n package android.view.inputmethod;\n \n import android.compat.annotation.UnsupportedAppUsage;\n+import android.os.BadParcelableException;\n import android.os.Parcel;\n import android.util.Slog;\n \n@@ -69,6 +70,9 @@ public class InputMethodSubtypeArray {\n      */\n     public InputMethodSubtypeArray(final Parcel source) {\n         mCount = source.readInt();\n+        if (mCount < 0) {\n+            throw new BadParcelableException(\"mCount must be non-negative.\");\n+        }\n         if (mCount > 0) {\n             mDecompressedSize = source.readInt();\n             mCompressedData = source.createByteArray();\ndiff --git a/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java b/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java\nindex e2fb46af5b64..5af8558ccde9 100644\n--- a/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java\n+++ b/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java\n@@ -16,9 +16,14 @@\n \n package android.view.inputmethod;\n \n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n+\n import static org.junit.Assert.assertEquals;\n \n+import android.os.BadParcelableException;\n import android.os.Parcel;\n+import android.platform.test.annotations.Presubmit;\n import android.view.inputmethod.InputMethodSubtype.InputMethodSubtypeBuilder;\n \n import androidx.test.filters.SmallTest;\n@@ -31,6 +36,7 @@ import java.util.ArrayList;\n \n @SmallTest\n @RunWith(AndroidJUnit4.class)\n+@Presubmit\n public class InputMethodSubtypeArrayTest {\n \n     @Test\n@@ -59,6 +65,36 @@ public class InputMethodSubtypeArrayTest {\n         assertEquals(clonedArray.get(2), clonedClonedArray.get(2));\n     }\n \n+    @Test\n+    public void testNegativeCount() throws Exception {\n+        InputMethodSubtypeArray negativeCountArray;\n+        try {\n+            // Construct a InputMethodSubtypeArray with: mCount = -1\n+            Parcel p = Parcel.obtain();\n+            p.writeInt(-1);\n+            p.setDataPosition(0);\n+            negativeCountArray = new InputMethodSubtypeArray(p);\n+        } catch (BadParcelableException e) {\n+            // Expected with fix: Prevent negative mCount\n+            assertThat(e).hasMessageThat().contains(\"mCount\");\n+            return;\n+        }\n+        assertWithMessage(\"Test set-up failed\")\n+                .that(negativeCountArray.getCount()).isEqualTo(-1);\n+\n+        Parcel p = Parcel.obtain();\n+        // Writes: int (mCount), int (mDecompressedSize), byte[] (mCompressedData)\n+        negativeCountArray.writeToParcel(p);\n+        p.setDataPosition(0);\n+        // Reads: int (mCount)\n+        // Leaves: int (mDecompressedSize), byte[] (mCompressedData)\n+        new InputMethodSubtypeArray(p);\n+\n+        assertWithMessage(\"Didn't read all data that was previously written\")\n+                .that(p.dataPosition())\n+                .isEqualTo(p.dataSize());\n+    }\n+\n     InputMethodSubtypeArray cloneViaParcel(final InputMethodSubtypeArray original) {\n         Parcel parcel = null;\n         try {\n",
                            "downstream_patch_tokens": {
                                "openai": 1014,
                                "general": {
                                    "word_based": 401,
                                    "char_based": 1014
                                },
                                "gemini": 1282
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "e863b7b8285f122fafbab5439ad3c337172bff6c",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit e863b7b8285f122fafbab5439ad3c337172bff6c\nAuthor: Adrian Roos <roosa@google.com>\nDate:   Fri Jun 2 13:57:57 2023 +0000\n\n    InputMethodSubtypeArray: prevent negative count injection\n    \n    Fixes an issue where negative counts could be injected\n    via the Parcel constructor. The writeToParcel method\n    in that case would write data that a subsequent read would\n    not consume.\n    \n    Fixes: 277916797\n    Fixes: 354682735\n    Test: atest InputMethodSubtypeArrayTest\n    Merged-In: I7e881d82415051179c59bf5df97f8ba0a41e693e\n    Change-Id: I7e881d82415051179c59bf5df97f8ba0a41e693e\n\ndiff --git a/core/java/android/view/inputmethod/InputMethodSubtypeArray.java b/core/java/android/view/inputmethod/InputMethodSubtypeArray.java\nindex 50e95c80cfed..ee36dc72e346 100644\n--- a/core/java/android/view/inputmethod/InputMethodSubtypeArray.java\n+++ b/core/java/android/view/inputmethod/InputMethodSubtypeArray.java\n@@ -17,6 +17,7 @@\n package android.view.inputmethod;\n \n import android.compat.annotation.UnsupportedAppUsage;\n+import android.os.BadParcelableException;\n import android.os.Parcel;\n import android.util.Slog;\n \n@@ -69,6 +70,9 @@ public class InputMethodSubtypeArray {\n      */\n     public InputMethodSubtypeArray(final Parcel source) {\n         mCount = source.readInt();\n+        if (mCount < 0) {\n+            throw new BadParcelableException(\"mCount must be non-negative.\");\n+        }\n         if (mCount > 0) {\n             mDecompressedSize = source.readInt();\n             mCompressedData = source.createByteArray();\ndiff --git a/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java b/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java\nindex e2fb46af5b64..5af8558ccde9 100644\n--- a/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java\n+++ b/core/tests/coretests/src/android/view/inputmethod/InputMethodSubtypeArrayTest.java\n@@ -16,9 +16,14 @@\n \n package android.view.inputmethod;\n \n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n+\n import static org.junit.Assert.assertEquals;\n \n+import android.os.BadParcelableException;\n import android.os.Parcel;\n+import android.platform.test.annotations.Presubmit;\n import android.view.inputmethod.InputMethodSubtype.InputMethodSubtypeBuilder;\n \n import androidx.test.filters.SmallTest;\n@@ -31,6 +36,7 @@ import java.util.ArrayList;\n \n @SmallTest\n @RunWith(AndroidJUnit4.class)\n+@Presubmit\n public class InputMethodSubtypeArrayTest {\n \n     @Test\n@@ -59,6 +65,36 @@ public class InputMethodSubtypeArrayTest {\n         assertEquals(clonedArray.get(2), clonedClonedArray.get(2));\n     }\n \n+    @Test\n+    public void testNegativeCount() throws Exception {\n+        InputMethodSubtypeArray negativeCountArray;\n+        try {\n+            // Construct a InputMethodSubtypeArray with: mCount = -1\n+            Parcel p = Parcel.obtain();\n+            p.writeInt(-1);\n+            p.setDataPosition(0);\n+            negativeCountArray = new InputMethodSubtypeArray(p);\n+        } catch (BadParcelableException e) {\n+            // Expected with fix: Prevent negative mCount\n+            assertThat(e).hasMessageThat().contains(\"mCount\");\n+            return;\n+        }\n+        assertWithMessage(\"Test set-up failed\")\n+                .that(negativeCountArray.getCount()).isEqualTo(-1);\n+\n+        Parcel p = Parcel.obtain();\n+        // Writes: int (mCount), int (mDecompressedSize), byte[] (mCompressedData)\n+        negativeCountArray.writeToParcel(p);\n+        p.setDataPosition(0);\n+        // Reads: int (mCount)\n+        // Leaves: int (mDecompressedSize), byte[] (mCompressedData)\n+        new InputMethodSubtypeArray(p);\n+\n+        assertWithMessage(\"Didn't read all data that was previously written\")\n+                .that(p.dataPosition())\n+                .isEqualTo(p.dataSize());\n+    }\n+\n     InputMethodSubtypeArray cloneViaParcel(final InputMethodSubtypeArray original) {\n         Parcel parcel = null;\n         try {\n",
                            "downstream_patch_tokens": {
                                "openai": 1012,
                                "general": {
                                    "word_based": 401,
                                    "char_based": 1014
                                },
                                "gemini": 1282
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-368579654",
            "aliases": [
                "A-368579654",
                "CVE-2025-22427"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-368579654",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "e0510a62eba04140e459cdd8232f35087aa3073b"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From e0510a62eba04140e459cdd8232f35087aa3073b Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Mat=C3=ADas=20Hern=C3=A1ndez?= <matiashe@google.com>\nDate: Fri, 3 Jan 2025 13:38:10 +0100\nSubject: [PATCH] Remove incorrect call to Window.addFlags with a system flag\n\nThe same flag is being (correctly) added in onCreate, so on top of being wrong this was also completely unnecessary.\n\nBug: 368579654\nTest: atest NotificationAccessConfirmationActivityTest\nFlag: EXEMPT bugfix\n\nChange-Id: I539fca77a1d136bdd0e4892993020884430b8a4e\n---\n .../NotificationAccessConfirmationActivity.java   | 15 ---------------\n ...otificationAccessConfirmationActivityTest.java | 15 +++++++++++++++\n 2 files changed, 15 insertions(+), 15 deletions(-)\n\ndiff --git a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nindex 1adeb644155..8448a8e752a 100644\n--- a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n+++ b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n@@ -41,7 +41,6 @@ import android.os.UserManager;\n import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n-import android.view.WindowManager;\n import android.view.accessibility.AccessibilityEvent;\n import android.widget.Toast;\n \n@@ -161,20 +160,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n         getWindow().setCloseOnTouchOutside(false); \n     }\n \n-    @Override\n-    public void onResume() {\n-        super.onResume();\n-        getWindow().addFlags(\n-                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n-    }\n-\n-    @Override\n-    public void onPause() {\n-        getWindow().clearFlags(\n-                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n-        super.onPause();\n-    }\n-\n     private void onAllow() {\n         mNm.setNotificationListenerAccessGranted(mComponentName, true);\n \ndiff --git a/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java b/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java\nindex 0a953615abf..8ae242f0869 100644\n--- a/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java\n+++ b/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java\n@@ -16,6 +16,8 @@\n \n package com.android.settings.notification;\n \n+import static android.view.WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS;\n+\n import static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_COMPONENT_NAME;\n \n import static com.google.common.truth.Truth.assertThat;\n@@ -42,6 +44,19 @@ import org.robolectric.RuntimeEnvironment;\n @RunWith(RobolectricTestRunner.class)\n public class NotificationAccessConfirmationActivityTest {\n \n+    @Test\n+    public void onCreate_setsWindowFlags() {\n+        ComponentName cn = new ComponentName(\"com.example\", \"com.example.SomeService\");\n+        installPackage(cn.getPackageName(), \"Example\");\n+\n+        NotificationAccessConfirmationActivity activity = startActivityWithIntent(cn);\n+\n+        assertThat(activity.getWindow().getAttributes().privateFlags\n+                & SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS).isNotEqualTo(0);\n+        assertThat(activity.getWindow().getAttributes().flags\n+                & SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS).isEqualTo(0);\n+    }\n+\n     @Test\n     public void start_withMissingIntentFilter_finishes() {\n         ComponentName cn = new ComponentName(\"com.example\", \"com.example.SomeService\");\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 858,
                        "general": {
                            "word_based": 348,
                            "char_based": 958
                        },
                        "gemini": 1140
                    },
                    "total_downstream_versions_tested": 2,
                    "successful_patches": 2,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "2a6672dd33d6430da0f240fd600f7379ac301588",
                            "repo_path": "android_repos/Settings",
                            "result": "success",
                            "downstream_patch_content": "commit 2a6672dd33d6430da0f240fd600f7379ac301588\nAuthor: Mat\u00edas Hern\u00e1ndez <matiashe@google.com>\nDate:   Fri Jan 3 13:38:10 2025 +0100\n\n    Remove incorrect call to Window.addFlags with a system flag\n    \n    The same flag is being (correctly) added in onCreate, so on top of being wrong this was also completely unnecessary.\n    \n    Bug: 368579654\n    Test: manual\n    Flag: EXEMPT bugfix\n    \n    Change-Id: I539fca77a1d136bdd0e4892993020884430b8a4e\n    Merged-In: I539fca77a1d136bdd0e4892993020884430b8a4e\n    (cherry picked from commit e0510a62eba04140e459cdd8232f35087aa3073b)\n\ndiff --git a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nindex 74b8102ee2c..253ae88e4b3 100644\n--- a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n+++ b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n@@ -42,7 +42,6 @@ import android.os.UserManager;\n import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n-import android.view.WindowManager;\n import android.view.accessibility.AccessibilityEvent;\n import android.widget.Toast;\n \n@@ -160,20 +159,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n         getWindow().setCloseOnTouchOutside(false); \n     }\n \n-    @Override\n-    public void onResume() {\n-        super.onResume();\n-        getWindow().addFlags(\n-                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n-    }\n-\n-    @Override\n-    public void onPause() {\n-        getWindow().clearFlags(\n-                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n-        super.onPause();\n-    }\n-\n     private void onAllow() {\n         mNm.setNotificationListenerAccessGranted(mComponentName, true);\n \n",
                            "downstream_patch_tokens": {
                                "openai": 476,
                                "general": {
                                    "word_based": 178,
                                    "char_based": 483
                                },
                                "gemini": 653
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "c97cd9e805f9c347db5152553fdd1c4004a558b3",
                            "repo_path": "android_repos/Settings",
                            "result": "success",
                            "downstream_patch_content": "commit c97cd9e805f9c347db5152553fdd1c4004a558b3\nAuthor: Mat\u00edas Hern\u00e1ndez <matiashe@google.com>\nDate:   Fri Jan 3 13:38:10 2025 +0100\n\n    Remove incorrect call to Window.addFlags with a system flag\n    \n    The same flag is being (correctly) added in onCreate, so on top of being wrong this was also completely unnecessary.\n    \n    Bug: 368579654\n    Test: atest NotificationAccessConfirmationActivityTest\n    Flag: EXEMPT bugfix\n    \n    Change-Id: I539fca77a1d136bdd0e4892993020884430b8a4e\n    Merged-In: I539fca77a1d136bdd0e4892993020884430b8a4e\n    (cherry picked from commit e0510a62eba04140e459cdd8232f35087aa3073b)\n\ndiff --git a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nindex 74b8102ee2c..253ae88e4b3 100644\n--- a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n+++ b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n@@ -42,7 +42,6 @@ import android.os.UserManager;\n import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n-import android.view.WindowManager;\n import android.view.accessibility.AccessibilityEvent;\n import android.widget.Toast;\n \n@@ -160,20 +159,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n         getWindow().setCloseOnTouchOutside(false); \n     }\n \n-    @Override\n-    public void onResume() {\n-        super.onResume();\n-        getWindow().addFlags(\n-                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n-    }\n-\n-    @Override\n-    public void onPause() {\n-        getWindow().clearFlags(\n-                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n-        super.onPause();\n-    }\n-\n     private void onAllow() {\n         mNm.setNotificationListenerAccessGranted(mComponentName, true);\n \ndiff --git a/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java b/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java\nindex 788f853e19b..1f5640285c6 100644\n--- a/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java\n+++ b/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java\n@@ -16,6 +16,8 @@\n \n package com.android.settings.notification;\n \n+import static android.view.WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS;\n+\n import static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_COMPONENT_NAME;\n \n import static com.google.common.truth.Truth.assertThat;\n@@ -41,6 +43,19 @@ import org.robolectric.RuntimeEnvironment;\n @RunWith(RobolectricTestRunner.class)\n public class NotificationAccessConfirmationActivityTest {\n \n+    @Test\n+    public void onCreate_setsWindowFlags() {\n+        ComponentName cn = new ComponentName(\"com.example\", \"com.example.SomeService\");\n+        installPackage(cn.getPackageName(), \"Example\");\n+\n+        NotificationAccessConfirmationActivity activity = startActivityWithIntent(cn);\n+\n+        assertThat(activity.getWindow().getAttributes().privateFlags\n+                & SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS).isNotEqualTo(0);\n+        assertThat(activity.getWindow().getAttributes().flags\n+                & SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS).isEqualTo(0);\n+    }\n+\n     @Test\n     public void start_withMissingIntentFilter_finishes() {\n         ComponentName cn = new ComponentName(\"com.example\", \"com.example.SomeService\");\n",
                            "downstream_patch_tokens": {
                                "openai": 832,
                                "general": {
                                    "word_based": 321,
                                    "char_based": 927
                                },
                                "gemini": 1125
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-376461726",
            "aliases": [
                "A-376461726",
                "CVE-2025-22432"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-376461726",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "4a358cfd8e403597651a6962e8e43c11ea906a59"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 4a358cfd8e403597651a6962e8e43c11ea906a59 Mon Sep 17 00:00:00 2001\nFrom: Grant Menke <grantmenke@google.com>\nDate: Fri, 3 Jan 2025 10:37:09 -0800\nSubject: [PATCH] Ensure connection is unbound on call redirection timeout.\n\nThis CL ensures that the connection is unbound when the call redirection timeout is hit in CallRedirectionProcessor. This resolves a reported security vulnerability.\n\nTest: manual using the provided APK + updated CallRedirectionProcessorTest\nFlag: EXEMPT Security High/Critical Severity CVE\nBug: 376461726\nChange-Id: I76a65c3993f5107652f98bbe0283043ecff27a7c\n---\n .../callredirection/CallRedirectionProcessor.java    |  8 ++++++++\n .../telecom/tests/CallRedirectionProcessorTest.java  | 12 ++++++++++++\n 2 files changed, 20 insertions(+)\n\ndiff --git a/src/com/android/server/telecom/callredirection/CallRedirectionProcessor.java b/src/com/android/server/telecom/callredirection/CallRedirectionProcessor.java\nindex 05e73d544..15b8aa942 100644\n--- a/src/com/android/server/telecom/callredirection/CallRedirectionProcessor.java\n+++ b/src/com/android/server/telecom/callredirection/CallRedirectionProcessor.java\n@@ -133,6 +133,14 @@ public class CallRedirectionProcessor implements CallRedirectionCallback {\n                             + mServiceType + \" call redirection service\");\n                 }\n             }\n+            Log.i(this, \"notifyTimeout: call redirection has timed out so \"\n+                    + \"unbinding the connection\");\n+            if (mConnection != null) {\n+                // We still need to call unbind even if the service disconnected.\n+                mContext.unbindService(mConnection);\n+                mConnection = null;\n+            }\n+            mService = null;\n         }\n \n         private class CallRedirectionServiceConnection implements ServiceConnection {\ndiff --git a/tests/src/com/android/server/telecom/tests/CallRedirectionProcessorTest.java b/tests/src/com/android/server/telecom/tests/CallRedirectionProcessorTest.java\nindex 241216aa2..185c08f42 100644\n--- a/tests/src/com/android/server/telecom/tests/CallRedirectionProcessorTest.java\n+++ b/tests/src/com/android/server/telecom/tests/CallRedirectionProcessorTest.java\n@@ -221,6 +221,9 @@ public class CallRedirectionProcessorTest extends TelecomTestCase {\n         verify(mCallsManager, times(1)).onCallRedirectionComplete(eq(mCall), any(),\n                 eq(mPhoneAccountHandle), eq(null), eq(SPEAKER_PHONE_ON), eq(VIDEO_STATE),\n                 eq(false), eq(CallRedirectionProcessor.UI_TYPE_NO_ACTION));\n+        // Verify service was unbound\n+        verify(mContext, times(1)).\n+                unbindService(any(ServiceConnection.class));\n     }\n \n     @Test\n@@ -249,6 +252,9 @@ public class CallRedirectionProcessorTest extends TelecomTestCase {\n         verify(mCallsManager, times(1)).onCallRedirectionComplete(eq(mCall), any(),\n                 eq(mPhoneAccountHandle), eq(null), eq(SPEAKER_PHONE_ON), eq(VIDEO_STATE),\n                 eq(true), eq(CallRedirectionProcessor.UI_TYPE_USER_DEFINED_TIMEOUT));\n+        // Verify service was unbound\n+        verify(mContext, times(1)).\n+                unbindService(any(ServiceConnection.class));\n     }\n \n     @Test\n@@ -280,6 +286,9 @@ public class CallRedirectionProcessorTest extends TelecomTestCase {\n         verify(mCallsManager, times(1)).onCallRedirectionComplete(eq(mCall), any(),\n                 eq(mPhoneAccountHandle), eq(null), eq(SPEAKER_PHONE_ON), eq(VIDEO_STATE),\n                 eq(true), eq(CallRedirectionProcessor.UI_TYPE_USER_DEFINED_TIMEOUT));\n+        // Verify service was unbound\n+        verify(mContext, times(1)).\n+                unbindService(any(ServiceConnection.class));\n \n         // Wait for another carrier timeout time, but should not expect any carrier service request\n         // is triggered.\n@@ -289,6 +298,9 @@ public class CallRedirectionProcessorTest extends TelecomTestCase {\n         verify(mCallsManager, times(1)).onCallRedirectionComplete(eq(mCall), any(),\n                 eq(mPhoneAccountHandle), eq(null), eq(SPEAKER_PHONE_ON), eq(VIDEO_STATE),\n                 eq(true), eq(CallRedirectionProcessor.UI_TYPE_USER_DEFINED_TIMEOUT));\n+        // Verify service was unbound\n+        verify(mContext, times(1)).\n+                unbindService(any(ServiceConnection.class));\n     }\n \n     @Test\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 1033,
                        "general": {
                            "word_based": 424,
                            "char_based": 1090
                        },
                        "gemini": 1263
                    },
                    "total_downstream_versions_tested": 2,
                    "successful_patches": 2,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "425b355b0e845595c0e1d698ff2f533a46f58830",
                            "repo_path": "android_repos/Telecomm",
                            "result": "success",
                            "downstream_patch_content": "commit 425b355b0e845595c0e1d698ff2f533a46f58830\nAuthor: Grant Menke <grantmenke@google.com>\nDate:   Fri Jan 3 10:37:09 2025 -0800\n\n    Ensure connection is unbound on call redirection timeout.\n    \n    This CL ensures that the connection is unbound when the call redirection timeout is hit in CallRedirectionProcessor. This resolves a reported security vulnerability.\n    \n    Test: manual using the provided APK + updated CallRedirectionProcessorTest\n    Flag: EXEMPT Security High/Critical Severity CVE\n    Bug: 376461726\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:4a358cfd8e403597651a6962e8e43c11ea906a59)\n    Merged-In: I76a65c3993f5107652f98bbe0283043ecff27a7c\n    Change-Id: I76a65c3993f5107652f98bbe0283043ecff27a7c\n\ndiff --git a/src/com/android/server/telecom/callredirection/CallRedirectionProcessor.java b/src/com/android/server/telecom/callredirection/CallRedirectionProcessor.java\nindex 02debcd6c..1b25441cb 100644\n--- a/src/com/android/server/telecom/callredirection/CallRedirectionProcessor.java\n+++ b/src/com/android/server/telecom/callredirection/CallRedirectionProcessor.java\n@@ -133,6 +133,14 @@ public class CallRedirectionProcessor implements CallRedirectionCallback {\n                             + mServiceType + \" call redirection service\");\n                 }\n             }\n+            Log.i(this, \"notifyTimeout: call redirection has timed out so \"\n+                    + \"unbinding the connection\");\n+            if (mConnection != null) {\n+                // We still need to call unbind even if the service disconnected.\n+                mContext.unbindService(mConnection);\n+                mConnection = null;\n+            }\n+            mService = null;\n         }\n \n         private class CallRedirectionServiceConnection implements ServiceConnection {\ndiff --git a/tests/src/com/android/server/telecom/tests/CallRedirectionProcessorTest.java b/tests/src/com/android/server/telecom/tests/CallRedirectionProcessorTest.java\nindex f2fe045ef..9826f68b5 100644\n--- a/tests/src/com/android/server/telecom/tests/CallRedirectionProcessorTest.java\n+++ b/tests/src/com/android/server/telecom/tests/CallRedirectionProcessorTest.java\n@@ -219,6 +219,9 @@ public class CallRedirectionProcessorTest extends TelecomTestCase {\n         verify(mCallsManager, times(1)).onCallRedirectionComplete(eq(mCall), any(),\n                 eq(mPhoneAccountHandle), eq(null), eq(SPEAKER_PHONE_ON), eq(VIDEO_STATE),\n                 eq(false), eq(CallRedirectionProcessor.UI_TYPE_NO_ACTION));\n+        // Verify service was unbound\n+        verify(mContext, times(1)).\n+                unbindService(any(ServiceConnection.class));\n     }\n \n     @Test\n@@ -247,6 +250,9 @@ public class CallRedirectionProcessorTest extends TelecomTestCase {\n         verify(mCallsManager, times(1)).onCallRedirectionComplete(eq(mCall), any(),\n                 eq(mPhoneAccountHandle), eq(null), eq(SPEAKER_PHONE_ON), eq(VIDEO_STATE),\n                 eq(true), eq(CallRedirectionProcessor.UI_TYPE_USER_DEFINED_TIMEOUT));\n+        // Verify service was unbound\n+        verify(mContext, times(1)).\n+                unbindService(any(ServiceConnection.class));\n     }\n \n     @Test\n@@ -278,6 +284,9 @@ public class CallRedirectionProcessorTest extends TelecomTestCase {\n         verify(mCallsManager, times(1)).onCallRedirectionComplete(eq(mCall), any(),\n                 eq(mPhoneAccountHandle), eq(null), eq(SPEAKER_PHONE_ON), eq(VIDEO_STATE),\n                 eq(true), eq(CallRedirectionProcessor.UI_TYPE_USER_DEFINED_TIMEOUT));\n+        // Verify service was unbound\n+        verify(mContext, times(1)).\n+                unbindService(any(ServiceConnection.class));\n \n         // Wait for another carrier timeout time, but should not expect any carrier service request\n         // is triggered.\n@@ -287,6 +296,9 @@ public class CallRedirectionProcessorTest extends TelecomTestCase {\n         verify(mCallsManager, times(1)).onCallRedirectionComplete(eq(mCall), any(),\n                 eq(mPhoneAccountHandle), eq(null), eq(SPEAKER_PHONE_ON), eq(VIDEO_STATE),\n                 eq(true), eq(CallRedirectionProcessor.UI_TYPE_USER_DEFINED_TIMEOUT));\n+        // Verify service was unbound\n+        verify(mContext, times(1)).\n+                unbindService(any(ServiceConnection.class));\n     }\n \n     @Test\n",
                            "downstream_patch_tokens": {
                                "openai": 1033,
                                "general": {
                                    "word_based": 410,
                                    "char_based": 1083
                                },
                                "gemini": 1281
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "9733de498bc44d9865b0061564ac3344426f4da9",
                            "repo_path": "android_repos/Telecomm",
                            "result": "success",
                            "downstream_patch_content": "commit 9733de498bc44d9865b0061564ac3344426f4da9\nAuthor: Grant Menke <grantmenke@google.com>\nDate:   Fri Jan 3 10:37:09 2025 -0800\n\n    Ensure connection is unbound on call redirection timeout.\n    \n    This CL ensures that the connection is unbound when the call redirection timeout is hit in CallRedirectionProcessor. This resolves a reported security vulnerability.\n    \n    Test: manual using the provided APK + updated CallRedirectionProcessorTest\n    Flag: EXEMPT Security High/Critical Severity CVE\n    Bug: 376461726\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:4a358cfd8e403597651a6962e8e43c11ea906a59)\n    Merged-In: I76a65c3993f5107652f98bbe0283043ecff27a7c\n    Change-Id: I76a65c3993f5107652f98bbe0283043ecff27a7c\n\ndiff --git a/src/com/android/server/telecom/callredirection/CallRedirectionProcessor.java b/src/com/android/server/telecom/callredirection/CallRedirectionProcessor.java\nindex 05e73d544..15b8aa942 100644\n--- a/src/com/android/server/telecom/callredirection/CallRedirectionProcessor.java\n+++ b/src/com/android/server/telecom/callredirection/CallRedirectionProcessor.java\n@@ -133,6 +133,14 @@ public class CallRedirectionProcessor implements CallRedirectionCallback {\n                             + mServiceType + \" call redirection service\");\n                 }\n             }\n+            Log.i(this, \"notifyTimeout: call redirection has timed out so \"\n+                    + \"unbinding the connection\");\n+            if (mConnection != null) {\n+                // We still need to call unbind even if the service disconnected.\n+                mContext.unbindService(mConnection);\n+                mConnection = null;\n+            }\n+            mService = null;\n         }\n \n         private class CallRedirectionServiceConnection implements ServiceConnection {\ndiff --git a/tests/src/com/android/server/telecom/tests/CallRedirectionProcessorTest.java b/tests/src/com/android/server/telecom/tests/CallRedirectionProcessorTest.java\nindex 01446d158..a302420a0 100644\n--- a/tests/src/com/android/server/telecom/tests/CallRedirectionProcessorTest.java\n+++ b/tests/src/com/android/server/telecom/tests/CallRedirectionProcessorTest.java\n@@ -221,6 +221,9 @@ public class CallRedirectionProcessorTest extends TelecomTestCase {\n         verify(mCallsManager, times(1)).onCallRedirectionComplete(eq(mCall), any(),\n                 eq(mPhoneAccountHandle), eq(null), eq(SPEAKER_PHONE_ON), eq(VIDEO_STATE),\n                 eq(false), eq(CallRedirectionProcessor.UI_TYPE_NO_ACTION));\n+        // Verify service was unbound\n+        verify(mContext, times(1)).\n+                unbindService(any(ServiceConnection.class));\n     }\n \n     @Test\n@@ -249,6 +252,9 @@ public class CallRedirectionProcessorTest extends TelecomTestCase {\n         verify(mCallsManager, times(1)).onCallRedirectionComplete(eq(mCall), any(),\n                 eq(mPhoneAccountHandle), eq(null), eq(SPEAKER_PHONE_ON), eq(VIDEO_STATE),\n                 eq(true), eq(CallRedirectionProcessor.UI_TYPE_USER_DEFINED_TIMEOUT));\n+        // Verify service was unbound\n+        verify(mContext, times(1)).\n+                unbindService(any(ServiceConnection.class));\n     }\n \n     @Test\n@@ -280,6 +286,9 @@ public class CallRedirectionProcessorTest extends TelecomTestCase {\n         verify(mCallsManager, times(1)).onCallRedirectionComplete(eq(mCall), any(),\n                 eq(mPhoneAccountHandle), eq(null), eq(SPEAKER_PHONE_ON), eq(VIDEO_STATE),\n                 eq(true), eq(CallRedirectionProcessor.UI_TYPE_USER_DEFINED_TIMEOUT));\n+        // Verify service was unbound\n+        verify(mContext, times(1)).\n+                unbindService(any(ServiceConnection.class));\n \n         // Wait for another carrier timeout time, but should not expect any carrier service request\n         // is triggered.\n@@ -289,6 +298,9 @@ public class CallRedirectionProcessorTest extends TelecomTestCase {\n         verify(mCallsManager, times(1)).onCallRedirectionComplete(eq(mCall), any(),\n                 eq(mPhoneAccountHandle), eq(null), eq(SPEAKER_PHONE_ON), eq(VIDEO_STATE),\n                 eq(true), eq(CallRedirectionProcessor.UI_TYPE_USER_DEFINED_TIMEOUT));\n+        // Verify service was unbound\n+        verify(mContext, times(1)).\n+                unbindService(any(ServiceConnection.class));\n     }\n \n     @Test\n",
                            "downstream_patch_tokens": {
                                "openai": 1030,
                                "general": {
                                    "word_based": 410,
                                    "char_based": 1083
                                },
                                "gemini": 1284
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-341680936",
            "aliases": [
                "A-341680936",
                "CVE-2024-43093"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-341680936",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "b91437020051b4f7fb78dbe14b40dd2f7c754f48"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From b91437020051b4f7fb78dbe14b40dd2f7c754f48 Mon Sep 17 00:00:00 2001\nFrom: Dipankar Bhardwaj <dipankarb@google.com>\nDate: Wed, 21 Aug 2024 14:26:50 +0000\nSubject: [PATCH] Restrict access to directories\n\nRestricted access to Android/data, Android/obb and Android/sandbox\ndirectories and its sub-directories. Replacing path's pattern match\ncheck with file equality check.\n\nTest: atest DocumentsClientTest\nBug: 341680936\nFlag: EXEMPT bug fix\nChange-Id: I8879900e57e1702d11797b81e86d0cc3f55bac22\n---\n .../ExternalStorageProvider.java              | 79 ++++++++++++++++---\n 1 file changed, 68 insertions(+), 11 deletions(-)\n\ndiff --git a/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java b/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\nindex 3409c29d3c2c..defbc1142adb 100644\n--- a/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\n+++ b/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\n@@ -16,8 +16,6 @@\n \n package com.android.externalstorage;\n \n-import static java.util.regex.Pattern.CASE_INSENSITIVE;\n-\n import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.usage.StorageStatsManager;\n@@ -61,12 +59,15 @@ import java.io.FileDescriptor;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Locale;\n import java.util.Objects;\n import java.util.UUID;\n-import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n \n /**\n  * Presents content of the shared (a.k.a. \"external\") storage.\n@@ -89,12 +90,9 @@ public class ExternalStorageProvider extends FileSystemProvider {\n     private static final Uri BASE_URI =\n             new Uri.Builder().scheme(ContentResolver.SCHEME_CONTENT).authority(AUTHORITY).build();\n \n-    /**\n-     * Regex for detecting {@code /Android/data/}, {@code /Android/obb/} and\n-     * {@code /Android/sandbox/} along with all their subdirectories and content.\n-     */\n-    private static final Pattern PATTERN_RESTRICTED_ANDROID_SUBTREES =\n-            Pattern.compile(\"^Android/(?:data|obb|sandbox)(?:/.+)?\", CASE_INSENSITIVE);\n+    private static final String PRIMARY_EMULATED_STORAGE_PATH = \"/storage/emulated/\";\n+\n+    private static final String STORAGE_PATH = \"/storage/\";\n \n     private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n             Root.COLUMN_ROOT_ID, Root.COLUMN_FLAGS, Root.COLUMN_ICON, Root.COLUMN_TITLE,\n@@ -309,10 +307,69 @@ public class ExternalStorageProvider extends FileSystemProvider {\n             return false;\n         }\n \n-        final String path = getPathFromDocId(documentId);\n-        return PATTERN_RESTRICTED_ANDROID_SUBTREES.matcher(path).matches();\n+        try {\n+            final RootInfo root = getRootFromDocId(documentId);\n+            final String canonicalPath = getPathFromDocId(documentId);\n+            return isRestrictedPath(root.rootId, canonicalPath);\n+        } catch (Exception e) {\n+            return true;\n+        }\n     }\n \n+    /**\n+     * Based on the given root id and path, we restrict path access if file is Android/data or\n+     * Android/obb or Android/sandbox or one of their subdirectories.\n+     *\n+     * @param canonicalPath of the file\n+     * @return true if path is restricted\n+     */\n+    private boolean isRestrictedPath(String rootId, String canonicalPath) {\n+        if (rootId == null || canonicalPath == null) {\n+            return true;\n+        }\n+\n+        final String rootPath;\n+        if (rootId.equalsIgnoreCase(ROOT_ID_PRIMARY_EMULATED)) {\n+            // Creates \"/storage/emulated/<user-id>\"\n+            rootPath = PRIMARY_EMULATED_STORAGE_PATH + UserHandle.myUserId();\n+        } else {\n+            // Creates \"/storage/<volume-uuid>\"\n+            rootPath = STORAGE_PATH + rootId;\n+        }\n+        List<java.nio.file.Path> restrictedPathList = Arrays.asList(\n+                Paths.get(rootPath, \"Android\", \"data\"),\n+                Paths.get(rootPath, \"Android\", \"obb\"),\n+                Paths.get(rootPath, \"Android\", \"sandbox\"));\n+        // We need to identify restricted parent paths which actually exist on the device\n+        List<java.nio.file.Path> validRestrictedPathsToCheck = restrictedPathList.stream().filter(\n+                Files::exists).collect(Collectors.toList());\n+\n+        boolean isRestricted = false;\n+        java.nio.file.Path filePathToCheck = Paths.get(rootPath, canonicalPath);\n+        try {\n+            while (filePathToCheck != null) {\n+                for (java.nio.file.Path restrictedPath : validRestrictedPathsToCheck) {\n+                    if (Files.isSameFile(restrictedPath, filePathToCheck)) {\n+                        isRestricted = true;\n+                        Log.v(TAG, \"Restricting access for path: \" + filePathToCheck);\n+                        break;\n+                    }\n+                }\n+                if (isRestricted) {\n+                    break;\n+                }\n+\n+                filePathToCheck = filePathToCheck.getParent();\n+            }\n+        } catch (Exception e) {\n+            Log.w(TAG, \"Error in checking file equality check.\", e);\n+            isRestricted = true;\n+        }\n+\n+        return isRestricted;\n+    }\n+\n+\n     /**\n      * Check that the directory is the root of storage or blocked file from tree.\n      * <p>\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 1309,
                        "general": {
                            "word_based": 556,
                            "char_based": 1401
                        },
                        "gemini": 1627
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "01006f7f97083ae49a546f9e0a94db7bdfd2a152",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 01006f7f97083ae49a546f9e0a94db7bdfd2a152\nAuthor: Dipankar Bhardwaj <dipankarb@google.com>\nDate:   Wed Aug 21 14:26:50 2024 +0000\n\n    DO NOT MERGE Restrict access to directories\n    \n    Restricted access to Android/data, Android/obb and Android/sandbox\n    directories and its sub-directories. Replacing path's pattern match\n    check with file equality check.\n    \n    Test: atest DocumentsClientTest\n    Bug: 341680936\n    Flag: EXEMPT bug fix\n    Change-Id: I8879900e57e1702d11797b81e86d0cc3f55bac22\n    Merged-In: I8879900e57e1702d11797b81e86d0cc3f55bac22\n\ndiff --git a/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java b/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\nindex 992de22f4265..fdeccfa7b9d0 100644\n--- a/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\n+++ b/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\n@@ -16,8 +16,6 @@\n \n package com.android.externalstorage;\n \n-import static java.util.regex.Pattern.CASE_INSENSITIVE;\n-\n import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.usage.StorageStatsManager;\n@@ -61,12 +59,15 @@ import java.io.FileDescriptor;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Locale;\n import java.util.Objects;\n import java.util.UUID;\n-import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n \n /**\n  * Presents content of the shared (a.k.a. \"external\") storage.\n@@ -89,12 +90,9 @@ public class ExternalStorageProvider extends FileSystemProvider {\n     private static final Uri BASE_URI =\n             new Uri.Builder().scheme(ContentResolver.SCHEME_CONTENT).authority(AUTHORITY).build();\n \n-    /**\n-     * Regex for detecting {@code /Android/data/}, {@code /Android/obb/} and\n-     * {@code /Android/sandbox/} along with all their subdirectories and content.\n-     */\n-    private static final Pattern PATTERN_RESTRICTED_ANDROID_SUBTREES =\n-            Pattern.compile(\"^Android/(?:data|obb|sandbox)(?:/.+)?\", CASE_INSENSITIVE);\n+    private static final String PRIMARY_EMULATED_STORAGE_PATH = \"/storage/emulated/\";\n+\n+    private static final String STORAGE_PATH = \"/storage/\";\n \n     private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n             Root.COLUMN_ROOT_ID, Root.COLUMN_FLAGS, Root.COLUMN_ICON, Root.COLUMN_TITLE,\n@@ -308,10 +306,69 @@ public class ExternalStorageProvider extends FileSystemProvider {\n             return false;\n         }\n \n-        final String path = getPathFromDocId(documentId);\n-        return PATTERN_RESTRICTED_ANDROID_SUBTREES.matcher(path).matches();\n+        try {\n+            final RootInfo root = getRootFromDocId(documentId);\n+            final String canonicalPath = getPathFromDocId(documentId);\n+            return isRestrictedPath(root.rootId, canonicalPath);\n+        } catch (Exception e) {\n+            return true;\n+        }\n     }\n \n+    /**\n+     * Based on the given root id and path, we restrict path access if file is Android/data or\n+     * Android/obb or Android/sandbox or one of their subdirectories.\n+     *\n+     * @param canonicalPath of the file\n+     * @return true if path is restricted\n+     */\n+    private boolean isRestrictedPath(String rootId, String canonicalPath) {\n+        if (rootId == null || canonicalPath == null) {\n+            return true;\n+        }\n+\n+        final String rootPath;\n+        if (rootId.equalsIgnoreCase(ROOT_ID_PRIMARY_EMULATED)) {\n+            // Creates \"/storage/emulated/<user-id>\"\n+            rootPath = PRIMARY_EMULATED_STORAGE_PATH + UserHandle.myUserId();\n+        } else {\n+            // Creates \"/storage/<volume-uuid>\"\n+            rootPath = STORAGE_PATH + rootId;\n+        }\n+        List<java.nio.file.Path> restrictedPathList = Arrays.asList(\n+                Paths.get(rootPath, \"Android\", \"data\"),\n+                Paths.get(rootPath, \"Android\", \"obb\"),\n+                Paths.get(rootPath, \"Android\", \"sandbox\"));\n+        // We need to identify restricted parent paths which actually exist on the device\n+        List<java.nio.file.Path> validRestrictedPathsToCheck = restrictedPathList.stream().filter(\n+                Files::exists).collect(Collectors.toList());\n+\n+        boolean isRestricted = false;\n+        java.nio.file.Path filePathToCheck = Paths.get(rootPath, canonicalPath);\n+        try {\n+            while (filePathToCheck != null) {\n+                for (java.nio.file.Path restrictedPath : validRestrictedPathsToCheck) {\n+                    if (Files.isSameFile(restrictedPath, filePathToCheck)) {\n+                        isRestricted = true;\n+                        Log.v(TAG, \"Restricting access for path: \" + filePathToCheck);\n+                        break;\n+                    }\n+                }\n+                if (isRestricted) {\n+                    break;\n+                }\n+\n+                filePathToCheck = filePathToCheck.getParent();\n+            }\n+        } catch (Exception e) {\n+            Log.w(TAG, \"Error in checking file equality check.\", e);\n+            isRestricted = true;\n+        }\n+\n+        return isRestricted;\n+    }\n+\n+\n     /**\n      * Check that the directory is the root of storage or blocked file from tree.\n      * <p>\n",
                            "downstream_patch_tokens": {
                                "openai": 1291,
                                "general": {
                                    "word_based": 537,
                                    "char_based": 1381
                                },
                                "gemini": 1608
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "da4b7509afc15cda9195501b41ecc6c5a0670c19",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit da4b7509afc15cda9195501b41ecc6c5a0670c19\nAuthor: Dipankar Bhardwaj <dipankarb@google.com>\nDate:   Wed Aug 21 14:26:50 2024 +0000\n\n    DO NOT MERGE Restrict access to directories\n    \n    Restricted access to Android/data, Android/obb and Android/sandbox\n    directories and its sub-directories. Replacing path's pattern match\n    check with file equality check.\n    \n    Test: atest DocumentsClientTest\n    Bug: 341680936\n    Flag: EXEMPT bug fix\n    Change-Id: I8879900e57e1702d11797b81e86d0cc3f55bac22\n\ndiff --git a/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java b/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\nindex 992de22f4265..fdeccfa7b9d0 100644\n--- a/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\n+++ b/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\n@@ -16,8 +16,6 @@\n \n package com.android.externalstorage;\n \n-import static java.util.regex.Pattern.CASE_INSENSITIVE;\n-\n import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.usage.StorageStatsManager;\n@@ -61,12 +59,15 @@ import java.io.FileDescriptor;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Locale;\n import java.util.Objects;\n import java.util.UUID;\n-import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n \n /**\n  * Presents content of the shared (a.k.a. \"external\") storage.\n@@ -89,12 +90,9 @@ public class ExternalStorageProvider extends FileSystemProvider {\n     private static final Uri BASE_URI =\n             new Uri.Builder().scheme(ContentResolver.SCHEME_CONTENT).authority(AUTHORITY).build();\n \n-    /**\n-     * Regex for detecting {@code /Android/data/}, {@code /Android/obb/} and\n-     * {@code /Android/sandbox/} along with all their subdirectories and content.\n-     */\n-    private static final Pattern PATTERN_RESTRICTED_ANDROID_SUBTREES =\n-            Pattern.compile(\"^Android/(?:data|obb|sandbox)(?:/.+)?\", CASE_INSENSITIVE);\n+    private static final String PRIMARY_EMULATED_STORAGE_PATH = \"/storage/emulated/\";\n+\n+    private static final String STORAGE_PATH = \"/storage/\";\n \n     private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n             Root.COLUMN_ROOT_ID, Root.COLUMN_FLAGS, Root.COLUMN_ICON, Root.COLUMN_TITLE,\n@@ -308,10 +306,69 @@ public class ExternalStorageProvider extends FileSystemProvider {\n             return false;\n         }\n \n-        final String path = getPathFromDocId(documentId);\n-        return PATTERN_RESTRICTED_ANDROID_SUBTREES.matcher(path).matches();\n+        try {\n+            final RootInfo root = getRootFromDocId(documentId);\n+            final String canonicalPath = getPathFromDocId(documentId);\n+            return isRestrictedPath(root.rootId, canonicalPath);\n+        } catch (Exception e) {\n+            return true;\n+        }\n     }\n \n+    /**\n+     * Based on the given root id and path, we restrict path access if file is Android/data or\n+     * Android/obb or Android/sandbox or one of their subdirectories.\n+     *\n+     * @param canonicalPath of the file\n+     * @return true if path is restricted\n+     */\n+    private boolean isRestrictedPath(String rootId, String canonicalPath) {\n+        if (rootId == null || canonicalPath == null) {\n+            return true;\n+        }\n+\n+        final String rootPath;\n+        if (rootId.equalsIgnoreCase(ROOT_ID_PRIMARY_EMULATED)) {\n+            // Creates \"/storage/emulated/<user-id>\"\n+            rootPath = PRIMARY_EMULATED_STORAGE_PATH + UserHandle.myUserId();\n+        } else {\n+            // Creates \"/storage/<volume-uuid>\"\n+            rootPath = STORAGE_PATH + rootId;\n+        }\n+        List<java.nio.file.Path> restrictedPathList = Arrays.asList(\n+                Paths.get(rootPath, \"Android\", \"data\"),\n+                Paths.get(rootPath, \"Android\", \"obb\"),\n+                Paths.get(rootPath, \"Android\", \"sandbox\"));\n+        // We need to identify restricted parent paths which actually exist on the device\n+        List<java.nio.file.Path> validRestrictedPathsToCheck = restrictedPathList.stream().filter(\n+                Files::exists).collect(Collectors.toList());\n+\n+        boolean isRestricted = false;\n+        java.nio.file.Path filePathToCheck = Paths.get(rootPath, canonicalPath);\n+        try {\n+            while (filePathToCheck != null) {\n+                for (java.nio.file.Path restrictedPath : validRestrictedPathsToCheck) {\n+                    if (Files.isSameFile(restrictedPath, filePathToCheck)) {\n+                        isRestricted = true;\n+                        Log.v(TAG, \"Restricting access for path: \" + filePathToCheck);\n+                        break;\n+                    }\n+                }\n+                if (isRestricted) {\n+                    break;\n+                }\n+\n+                filePathToCheck = filePathToCheck.getParent();\n+            }\n+        } catch (Exception e) {\n+            Log.w(TAG, \"Error in checking file equality check.\", e);\n+            isRestricted = true;\n+        }\n+\n+        return isRestricted;\n+    }\n+\n+\n     /**\n      * Check that the directory is the root of storage or blocked file from tree.\n      * <p>\n",
                            "downstream_patch_tokens": {
                                "openai": 1259,
                                "general": {
                                    "word_based": 534,
                                    "char_based": 1367
                                },
                                "gemini": 1560
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "7f1bc271379d97bed56e33f8470992d38bce5531",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 7f1bc271379d97bed56e33f8470992d38bce5531\nAuthor: Dipankar Bhardwaj <dipankarb@google.com>\nDate:   Wed Aug 21 14:26:50 2024 +0000\n\n    Restrict access to directories\n    \n    Restricted access to Android/data, Android/obb and Android/sandbox\n    directories and its sub-directories. Replacing path's pattern match\n    check with file equality check.\n    \n    Test: atest DocumentsClientTest\n    Bug: 341680936\n    Flag: EXEMPT bug fix\n    Change-Id: I8879900e57e1702d11797b81e86d0cc3f55bac22\n    Merged-In: I8879900e57e1702d11797b81e86d0cc3f55bac22\n\ndiff --git a/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java b/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\nindex 3409c29d3c2c..defbc1142adb 100644\n--- a/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\n+++ b/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\n@@ -16,8 +16,6 @@\n \n package com.android.externalstorage;\n \n-import static java.util.regex.Pattern.CASE_INSENSITIVE;\n-\n import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.usage.StorageStatsManager;\n@@ -61,12 +59,15 @@ import java.io.FileDescriptor;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Locale;\n import java.util.Objects;\n import java.util.UUID;\n-import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n \n /**\n  * Presents content of the shared (a.k.a. \"external\") storage.\n@@ -89,12 +90,9 @@ public class ExternalStorageProvider extends FileSystemProvider {\n     private static final Uri BASE_URI =\n             new Uri.Builder().scheme(ContentResolver.SCHEME_CONTENT).authority(AUTHORITY).build();\n \n-    /**\n-     * Regex for detecting {@code /Android/data/}, {@code /Android/obb/} and\n-     * {@code /Android/sandbox/} along with all their subdirectories and content.\n-     */\n-    private static final Pattern PATTERN_RESTRICTED_ANDROID_SUBTREES =\n-            Pattern.compile(\"^Android/(?:data|obb|sandbox)(?:/.+)?\", CASE_INSENSITIVE);\n+    private static final String PRIMARY_EMULATED_STORAGE_PATH = \"/storage/emulated/\";\n+\n+    private static final String STORAGE_PATH = \"/storage/\";\n \n     private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n             Root.COLUMN_ROOT_ID, Root.COLUMN_FLAGS, Root.COLUMN_ICON, Root.COLUMN_TITLE,\n@@ -309,10 +307,69 @@ public class ExternalStorageProvider extends FileSystemProvider {\n             return false;\n         }\n \n-        final String path = getPathFromDocId(documentId);\n-        return PATTERN_RESTRICTED_ANDROID_SUBTREES.matcher(path).matches();\n+        try {\n+            final RootInfo root = getRootFromDocId(documentId);\n+            final String canonicalPath = getPathFromDocId(documentId);\n+            return isRestrictedPath(root.rootId, canonicalPath);\n+        } catch (Exception e) {\n+            return true;\n+        }\n     }\n \n+    /**\n+     * Based on the given root id and path, we restrict path access if file is Android/data or\n+     * Android/obb or Android/sandbox or one of their subdirectories.\n+     *\n+     * @param canonicalPath of the file\n+     * @return true if path is restricted\n+     */\n+    private boolean isRestrictedPath(String rootId, String canonicalPath) {\n+        if (rootId == null || canonicalPath == null) {\n+            return true;\n+        }\n+\n+        final String rootPath;\n+        if (rootId.equalsIgnoreCase(ROOT_ID_PRIMARY_EMULATED)) {\n+            // Creates \"/storage/emulated/<user-id>\"\n+            rootPath = PRIMARY_EMULATED_STORAGE_PATH + UserHandle.myUserId();\n+        } else {\n+            // Creates \"/storage/<volume-uuid>\"\n+            rootPath = STORAGE_PATH + rootId;\n+        }\n+        List<java.nio.file.Path> restrictedPathList = Arrays.asList(\n+                Paths.get(rootPath, \"Android\", \"data\"),\n+                Paths.get(rootPath, \"Android\", \"obb\"),\n+                Paths.get(rootPath, \"Android\", \"sandbox\"));\n+        // We need to identify restricted parent paths which actually exist on the device\n+        List<java.nio.file.Path> validRestrictedPathsToCheck = restrictedPathList.stream().filter(\n+                Files::exists).collect(Collectors.toList());\n+\n+        boolean isRestricted = false;\n+        java.nio.file.Path filePathToCheck = Paths.get(rootPath, canonicalPath);\n+        try {\n+            while (filePathToCheck != null) {\n+                for (java.nio.file.Path restrictedPath : validRestrictedPathsToCheck) {\n+                    if (Files.isSameFile(restrictedPath, filePathToCheck)) {\n+                        isRestricted = true;\n+                        Log.v(TAG, \"Restricting access for path: \" + filePathToCheck);\n+                        break;\n+                    }\n+                }\n+                if (isRestricted) {\n+                    break;\n+                }\n+\n+                filePathToCheck = filePathToCheck.getParent();\n+            }\n+        } catch (Exception e) {\n+            Log.w(TAG, \"Error in checking file equality check.\", e);\n+            isRestricted = true;\n+        }\n+\n+        return isRestricted;\n+    }\n+\n+\n     /**\n      * Check that the directory is the root of storage or blocked file from tree.\n      * <p>\n",
                            "downstream_patch_tokens": {
                                "openai": 1284,
                                "general": {
                                    "word_based": 534,
                                    "char_based": 1378
                                },
                                "gemini": 1603
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "c984c3b842c2b458db2f1a29574af1d137f28143",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit c984c3b842c2b458db2f1a29574af1d137f28143\nAuthor: Dipankar Bhardwaj <dipankarb@google.com>\nDate:   Wed Aug 21 14:26:50 2024 +0000\n\n    Restrict access to directories\n    \n    Restricted access to Android/data, Android/obb and Android/sandbox\n    directories and its sub-directories. Replacing path's pattern match\n    check with file equality check.\n    \n    Test: atest DocumentsClientTest\n    Bug: 341680936\n    Flag: EXEMPT bug fix\n    Change-Id: I8879900e57e1702d11797b81e86d0cc3f55bac22\n    Merged-In: I8879900e57e1702d11797b81e86d0cc3f55bac22\n\ndiff --git a/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java b/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\nindex 3409c29d3c2c..defbc1142adb 100644\n--- a/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\n+++ b/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java\n@@ -16,8 +16,6 @@\n \n package com.android.externalstorage;\n \n-import static java.util.regex.Pattern.CASE_INSENSITIVE;\n-\n import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.usage.StorageStatsManager;\n@@ -61,12 +59,15 @@ import java.io.FileDescriptor;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Locale;\n import java.util.Objects;\n import java.util.UUID;\n-import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n \n /**\n  * Presents content of the shared (a.k.a. \"external\") storage.\n@@ -89,12 +90,9 @@ public class ExternalStorageProvider extends FileSystemProvider {\n     private static final Uri BASE_URI =\n             new Uri.Builder().scheme(ContentResolver.SCHEME_CONTENT).authority(AUTHORITY).build();\n \n-    /**\n-     * Regex for detecting {@code /Android/data/}, {@code /Android/obb/} and\n-     * {@code /Android/sandbox/} along with all their subdirectories and content.\n-     */\n-    private static final Pattern PATTERN_RESTRICTED_ANDROID_SUBTREES =\n-            Pattern.compile(\"^Android/(?:data|obb|sandbox)(?:/.+)?\", CASE_INSENSITIVE);\n+    private static final String PRIMARY_EMULATED_STORAGE_PATH = \"/storage/emulated/\";\n+\n+    private static final String STORAGE_PATH = \"/storage/\";\n \n     private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n             Root.COLUMN_ROOT_ID, Root.COLUMN_FLAGS, Root.COLUMN_ICON, Root.COLUMN_TITLE,\n@@ -309,10 +307,69 @@ public class ExternalStorageProvider extends FileSystemProvider {\n             return false;\n         }\n \n-        final String path = getPathFromDocId(documentId);\n-        return PATTERN_RESTRICTED_ANDROID_SUBTREES.matcher(path).matches();\n+        try {\n+            final RootInfo root = getRootFromDocId(documentId);\n+            final String canonicalPath = getPathFromDocId(documentId);\n+            return isRestrictedPath(root.rootId, canonicalPath);\n+        } catch (Exception e) {\n+            return true;\n+        }\n     }\n \n+    /**\n+     * Based on the given root id and path, we restrict path access if file is Android/data or\n+     * Android/obb or Android/sandbox or one of their subdirectories.\n+     *\n+     * @param canonicalPath of the file\n+     * @return true if path is restricted\n+     */\n+    private boolean isRestrictedPath(String rootId, String canonicalPath) {\n+        if (rootId == null || canonicalPath == null) {\n+            return true;\n+        }\n+\n+        final String rootPath;\n+        if (rootId.equalsIgnoreCase(ROOT_ID_PRIMARY_EMULATED)) {\n+            // Creates \"/storage/emulated/<user-id>\"\n+            rootPath = PRIMARY_EMULATED_STORAGE_PATH + UserHandle.myUserId();\n+        } else {\n+            // Creates \"/storage/<volume-uuid>\"\n+            rootPath = STORAGE_PATH + rootId;\n+        }\n+        List<java.nio.file.Path> restrictedPathList = Arrays.asList(\n+                Paths.get(rootPath, \"Android\", \"data\"),\n+                Paths.get(rootPath, \"Android\", \"obb\"),\n+                Paths.get(rootPath, \"Android\", \"sandbox\"));\n+        // We need to identify restricted parent paths which actually exist on the device\n+        List<java.nio.file.Path> validRestrictedPathsToCheck = restrictedPathList.stream().filter(\n+                Files::exists).collect(Collectors.toList());\n+\n+        boolean isRestricted = false;\n+        java.nio.file.Path filePathToCheck = Paths.get(rootPath, canonicalPath);\n+        try {\n+            while (filePathToCheck != null) {\n+                for (java.nio.file.Path restrictedPath : validRestrictedPathsToCheck) {\n+                    if (Files.isSameFile(restrictedPath, filePathToCheck)) {\n+                        isRestricted = true;\n+                        Log.v(TAG, \"Restricting access for path: \" + filePathToCheck);\n+                        break;\n+                    }\n+                }\n+                if (isRestricted) {\n+                    break;\n+                }\n+\n+                filePathToCheck = filePathToCheck.getParent();\n+            }\n+        } catch (Exception e) {\n+            Log.w(TAG, \"Error in checking file equality check.\", e);\n+            isRestricted = true;\n+        }\n+\n+        return isRestricted;\n+    }\n+\n+\n     /**\n      * Check that the directory is the root of storage or blocked file from tree.\n      * <p>\n",
                            "downstream_patch_tokens": {
                                "openai": 1285,
                                "general": {
                                    "word_based": 534,
                                    "char_based": 1378
                                },
                                "gemini": 1604
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-364027038",
            "aliases": [
                "A-364027038",
                "CVE-2024-49747"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-364027038",
            "severity": "Critical",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "7de5617f7d5266fe57c990c428621b5d4e92728a"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 7de5617f7d5266fe57c990c428621b5d4e92728a Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Thu, 12 Sep 2024 17:26:55 +0000\nSubject: [PATCH] Fix OOB writes in gatt_sr.cc\n\nAt various points in gatt_sr.cc, the output of the\ngatt_tcb_get_payload_size function is used without checking for a\npositive length.  However, in exceptional cases it is possible for the\nchannel to be closed at the time the function is called, which will lead\nto a zero length and cause an OOB write in subsequent processing.\n\nFix all of these.\n\nBug: 364026473\nBug: 364027038\nBug: 364027949\nBug: 364025411\nTest: m libbluetooth\nTest: researcher POC\nFlag: EXEMPT trivial validity checks\nTag: #security\nIgnore-AOSP-First: Security\nChange-Id: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n---\n system/stack/gatt/gatt_sr.cc | 21 +++++++++++++++++++++\n 1 file changed, 21 insertions(+)\n\ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 995ea810cb..0235ba964e 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -772,6 +772,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_cod\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n@@ -949,6 +960,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid, uint8_t\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1096,6 +1112,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid, tGATT_SRV_LIST_\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 941,
                        "general": {
                            "word_based": 349,
                            "char_based": 720
                        },
                        "gemini": 1252
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 0,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "result": "skipped",
                            "reason": "\u274c Failed to checkout branch android12-release: Command '['git', 'checkout', 'android12-release']' returned non-zero exit status 1.",
                            "downstream_patch": "7e5f45df8880293e1ab40367670d1a8959a542f9"
                        },
                        {
                            "downstream_version": "12L",
                            "result": "skipped",
                            "reason": "\u274c Failed to checkout branch android12L-release: Command '['git', 'checkout', 'android12L-release']' returned non-zero exit status 1.",
                            "downstream_patch": "7e5f45df8880293e1ab40367670d1a8959a542f9"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "2fc3087b9ac3019518c6ceb8a64d181d6bb04907",
                            "repo_path": "android_repos/Bluetooth",
                            "result": "failure",
                            "downstream_patch_content": "commit 2fc3087b9ac3019518c6ceb8a64d181d6bb04907\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Fri Oct 4 18:23:45 2024 +0000\n\n    Fix OOB writes in gatt_sr.cc\n    \n    At various points in gatt_sr.cc, the output of the\n    gatt_tcb_get_payload_size function is used without checking for a\n    positive length.  However, in exceptional cases it is possible for the\n    channel to be closed at the time the function is called, which will lead\n    to a zero length and cause an OOB write in subsequent processing.\n    \n    Fix all of these.\n    \n    Bug: 364026473\n    Bug: 364027038\n    Bug: 364027949\n    Bug: 364025411\n    Test: m libbluetooth\n    Test: researcher POC\n    Flag: EXEMPT trivial validity checks\n    Tag: #security\n    Ignore-AOSP-First: Security\n    Merged-In: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n    Change-Id: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n\ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 6f81b90514..c61df52bc8 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;\n \n",
                            "downstream_patch_tokens": {
                                "openai": 874,
                                "general": {
                                    "word_based": 305,
                                    "char_based": 671
                                },
                                "gemini": 1160
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "system/stack/gatt/gatt_sr.cc",
                                    "total_hunks": 4,
                                    "failed_hunks": [
                                        1,
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)",
                                            "merge_conflict_tokens": {
                                                "openai": 86,
                                                "general": {
                                                    "word_based": 25,
                                                    "char_based": 69
                                                },
                                                "gemini": 116
                                            }
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)",
                                            "merge_conflict_tokens": {
                                                "openai": 86,
                                                "general": {
                                                    "word_based": 25,
                                                    "char_based": 69
                                                },
                                                "gemini": 116
                                            }
                                        }
                                    ],
                                    "inline_merge_token_summary": {
                                        "gemini": 5104,
                                        "openai": 3956,
                                        "general_word": 1150,
                                        "general_char": 3174
                                    },
                                    "rej_file_content": "```diff\n--- system/stack/gatt/gatt_sr.cc\n+++ system/stack/gatt/gatt_sr.cc\n@@ -772,6 +772,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_cod\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n```",
                                    "rej_file_tokens": {
                                        "openai": 318,
                                        "general": {
                                            "word_based": 105,
                                            "char_based": 246
                                        },
                                        "gemini": 431
                                    },
                                    "patch_apply_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 FAILED at 772.\nHunk #2 FAILED at 804.\nHunk #3 succeeded at 902 with fuzz 2 (offset -47 lines).\nHunk #4 succeeded at 1054 with fuzz 2 (offset -47 lines).\n2 out of 4 hunks FAILED -- saving rejects to file system/stack/gatt/gatt_sr.cc.rej",
                                    "inline_merge_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 NOT MERGED at 780-789.\nHunk #2 NOT MERGED at 828-837.\nHunk #3 merged at 988-992.\nHunk #4 merged at 1145-1149.",
                                    "upstream_file_content": "```cc\n/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n\n#include <bluetooth/log.h>\n#include <com_android_bluetooth_flags.h>\n#include <string.h>\n\n#include <algorithm>\n\n#include \"gatt_int.h\"\n#include \"hardware/bt_gatt_types.h\"\n#include \"internal_include/bt_target.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"stack/arbiter/acl_arbiter.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/include/btm_client_interface.h\"\n#include \"stack/include/l2cdefs.h\"\n#include \"types/bluetooth/uuid.h\"\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattChannel;\nusing bluetooth::eatt::EattExtension;\nusing namespace bluetooth;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel = EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    if (channel == nullptr) {\n      log::warn(\"{}, cid 0x{:02x} already disconnected\", tcb.peer_bda, cid);\n      return 0;\n    }\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) || (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE || op_code == GATT_REQ_MTU ||\n        op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) {\n    return tcb.sr_cmd.op_code == 0;\n  }\n\n  EattChannel* channel = EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n  if (channel == nullptr) {\n    log::warn(\"{}, cid 0x{:02x} already disconnected\", tcb.peer_bda, cid);\n    return false;\n  }\n\n  return channel->server_outstanding_cmd_.op_code == 0;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel = EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    if (channel == nullptr) {\n      log::warn(\"{}, cid 0x{:02x} already disconnected\", tcb.peer_bda, cid);\n      return;\n    }\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  log::verbose(\"gatt_dequeue_sr_cmd cid: 0x{:x}\", cid);\n  if (p_cmd->p_rsp_msg) {\n    log::error(\"free tcb.sr_cmd.p_rsp_msg = {}\", fmt::ptr(p_cmd->p_rsp_msg));\n  }\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q)) {\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  }\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    log::error(\"Invalid MTU\");\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len) {\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  } else {\n    *p++ = GATT_RSP_READ_MULTI;\n  }\n\n  p_buf->len = 1;\n\n  // Now walk through the buffers putting the data into the response in order\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q)) {\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  }\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0) {\n        node = list_begin(list);\n      } else {\n        node = list_next(node);\n      }\n      if (node != list_end(list)) {\n        p_rsp = (tGATTS_RSP*)list_node(node);\n      }\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        log::verbose(\"Buffer space not enough for this data item, skipping\");\n        break;\n      }\n\n      len = std::min((size_t)p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        log::verbose(\"Buffer space not enough for this data item, skipping\");\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        log::verbose(\"multi read overflow available len={} val_len={}\", len, p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t)len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t)len);\n        p_buf->len += (uint16_t)len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) {\n        break;\n      }\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    log::error(\"nothing found!!\");\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    log::verbose(\"osi_free(p_buf)\");\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status, tGATTS_RSP* p_msg,\n                                   uint16_t mtu) {\n  log::verbose(\"status={} mtu={}\", status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL) {\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n  }\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    log::verbose(\"Multi read count={} num_hdls={} variable={}\",\n                 fixed_queue_length(p_cmd->multi_rsp_q), p_cmd->multi_req.num_handles,\n                 p_cmd->multi_req.variable_len);\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) == p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return true;\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return true;\n  }\n\n  /* If here, still waiting */\n  return false;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if, uint32_t /* trans_id */,\n                                     uint8_t op_code, tGATT_STATUS status, tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, sr_res_p->cid);\n\n  log::verbose(\"gatt_if={}\", gatt_if);\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) || (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size)) {\n      return GATT_SUCCESS;\n    }\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS) {\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n    }\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS) {\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n    }\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg =\n                attp_build_sr_msg(tcb, (uint8_t)(op_code + 1), (tGATT_SR_MSG*)p_msg, payload_size);\n      } else {\n        log::error(\"Exception!!! already has respond message\");\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code, sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  log::verbose(\"ret_code={}\", ret_code);\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                 uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rspv for Execute Write: error status={}\",\n                 gatt_cb.err_status);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code, gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    log::error(\"invalid length\");\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0, false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    if (com::android::bluetooth::flags::gatt_client_dynamic_allocation()) {\n      auto prep_cnt_it = tcb.prep_cnt_map.begin();\n      while (prep_cnt_it != tcb.prep_cnt_map.end()) {\n        gatt_if = i;\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC, &gatts_data);\n        prep_cnt_it = tcb.prep_cnt_map.erase(prep_cnt_it);\n      }\n    } else {\n      for (i = 0; i < GATT_MAX_APPS; i++) {\n        if (tcb.prep_cnt[i]) {\n          gatt_if = (tGATT_IF)(i + 1);\n          conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n          tGATTS_DATA gatts_data;\n          gatts_data.exec_write = flag;\n          gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC, &gatts_data);\n          tcb.prep_cnt[i] = 0;\n        }\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    log::error(\"gatt_process_exec_write_req: no prepare write pending\");\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                 uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  log::verbose(\"\");\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  if (multi_req == nullptr) {\n    log::error(\"Could not proceed request. {}, 0x{:02x}\", tcb.peer_bda, cid);\n    return;\n  }\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rspvofr ReadMultiple: error status={}\",\n                 gatt_cb.err_status);\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code, handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag, key_size);\n      if (err != GATT_SUCCESS) {\n        log::verbose(\"read permission denied : 0x{:02x}\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    log::error(\"max attribute handle reached in ReadMultiple Request.\");\n  }\n\n  if (multi_req->num_handles == 0) {\n    err = GATT_INVALID_HANDLE;\n  }\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n      if (sr_cmd_p == nullptr) {\n        log::error(\"Could not send response on CID were request arrived. {}, 0x{:02x}\",\n                   tcb.peer_bda, cid);\n        return;\n      }\n      gatt_sr_reset_cback_cnt(tcb, cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(tcb, cid, it->p_db, op_code, handle, 0,\n                                              p_msg->attr_value.value, &p_msg->attr_value.len,\n                                              GATT_MAX_ATTR_LEN, sec_flag, key_size, trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code, GATT_SUCCESS, p_msg,\n                                  sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else {\n      err = GATT_NO_RESOURCES;\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY) {\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeValue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid,\n                                                   uint8_t op_code, uint16_t s_hdl, uint16_t e_hdl,\n                                                   uint8_t* /* p_data */, const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl || el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) {\n      continue;\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n    }\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size || handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) {\n      continue;\n    }\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle && gatt_cb.last_service_handle == el.s_hdl) {\n      log::verbose(\"Use 0xFFFF for the last primary attribute\");\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n    }\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el, BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) {\n    return GATT_NOT_FOUND;\n  }\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) {\n      break;\n    }\n\n    if (attr.handle < s_hdl) {\n      continue;\n    }\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0) {\n      p_msg->offset =\n              (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16 : GATT_INFO_TYPE_PAIR_128;\n    }\n\n    if (len < info_pair_len[p_msg->offset - 1]) {\n      return GATT_NO_RESOURCES;\n    }\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 && uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 && uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 && uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      log::error(\"format mismatch\");\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    status = GATT_SUCCESS;\n  }\n\n  return status;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl, uint16_t& e_hdl) {\n  if (len < 4) {\n    return GATT_INVALID_PDU;\n  }\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) || !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len, uint8_t*& p,\n                                                 Uuid* p_uuid, uint16_t& s_hdl, uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) {\n    return ret;\n  }\n\n  if (len < 2) {\n    return GATT_INVALID_PDU;\n  }\n\n  /* parse uuid now */\n  log::assert_that(p_uuid != nullptr, \"assert failed: p_uuid != nullptr\");\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    log::verbose(\"Bad UUID\");\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason = gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl, false);\n      log::verbose(\"unexpected ReadByGrpType Group: {}\", uuid.ToString());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    log::verbose(\"unexpected ReadByTypeValue type: {}\", uuid.ToString());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else {\n    attp_send_sr_msg(tcb, cid, p_msg);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len, uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    log::error(\"invalid MTU request PDU received.\");\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  tGATT_SR_MSG gatt_sr_msg;\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE) {\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  } else {\n    tcb.payload_size = std::min(mtu, (uint16_t)(gatt_get_local_mtu()));\n  }\n\n  /* Always say to remote our default MTU. */\n  gatt_sr_msg.mtu = gatt_get_local_mtu();\n\n  log::info(\"MTU {} request from remote ({}), resulted MTU {}\", mtu, tcb.peer_bda,\n            tcb.payload_size);\n\n  if (get_btm_client_interface().ble.BTM_SetBleDataLength(\n              tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD) != tBTM_STATUS::BTM_SUCCESS) {\n    log::warn(\"Unable to set BLE data length peer:{} mtu:{}\", tcb.peer_bda,\n              tcb.payload_size + L2CAP_PKT_OVERHEAD);\n  }\n\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg, GATT_DEF_BLE_MTU_SIZE);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  bluetooth::shim::arbiter::GetArbiter().OnIncomingMtuReq(tcb.tcb_idx, tcb.payload_size);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered application with new MTU size. Use a transaction ID */\n  /* of 0, as no response is allowed from applications */\n  if (com::android::bluetooth::flags::gatt_client_dynamic_allocation()) {\n    for (auto& [i, p_reg] : gatt_cb.cl_rcb_map) {\n      if (p_reg->in_use) {\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, p_reg->gatt_if);\n        gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n      }\n    }\n  } else {\n    for (int i = 0; i < GATT_MAX_APPS; i++) {\n      if (gatt_cb.cl_rcb[i].in_use) {\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n        gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n      }\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                           uint16_t len, uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rsp for ReadByType: error status={}\",\n                 gatt_cb.err_status);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code, s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret =\n              gatts_db_read_attr_value_by_type(tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl,\n                                               uuid, &buf_len, sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) {\n          reason = GATT_SUCCESS;\n        }\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY) {\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    }\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid, tGATT_SRV_LIST_ELEM& el,\n                                    uint16_t handle, uint8_t op_code, uint16_t len, uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        log::error(\"Prepare write request was invalid - missing offset, sending error response\");\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        log::verbose(\"Write CMD with data sigining\");\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE) {\n        sr_data.write_req.need_rsp = true;\n      }\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) {\n        len = GATT_MAX_ATTR_LEN;\n      }\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle, sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        log::error(\n                \"Attempt to write attribute that's not tied with \"\n                \"characteristic or descriptor value.\");\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      log::error(\"max pending command, send error\");\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid, tGATT_SRV_LIST_ELEM& el,\n                                   uint8_t op_code, uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    log::error(\"packet length={} too short. min={}\", len, sizeof(uint16_t));\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) {\n    STREAM_TO_UINT16(offset, p_data);\n  }\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason =\n          gatts_read_attr_value_by_handle(tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n                                          (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY) {\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n    }\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                 uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    log::error(\"Illegal PDU length, discard request\");\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rsp: error status={}\", gatt_cb.err_status);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code, handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p, attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  log::verbose(\"\");\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    log::verbose(\"NV update set srv chg = false\");\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback) {\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT, &req, NULL);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  log::verbose(\"\");\n\n  tGATT_VALUE* p_buf = (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    if (GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len, p_buf->value) !=\n        GATT_SUCCESS) {\n      log::warn(\"Unable to send GATT server handle value conn_id:{}\", p_buf->conn_id);\n    }\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  log::verbose(\"ack handle={}\", ack_handle);\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    log::error(\"unexpected handle value confirmation\");\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF, &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                         uint16_t len, uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) {\n    return false;\n  }\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS && (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH))) {\n        should_ignore = false;\n      }\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash) {\n        should_ignore = false;\n      }\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000, false);\n    }\n    log::info(\"database out of sync, device={}, op_code=0x{:x}, should_rsp={}\", tcb.peer_bda,\n              (uint16_t)op_code, should_rsp);\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) {\n    return;\n  }\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n  if (len >= payload_size) {\n    log::error(\"server receive invalid PDU size:{} pdu size:{}\", len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) {\n      return;\n    }\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}\n```",
                                    "upstream_file_tokens": {
                                        "openai": 12881,
                                        "general": {
                                            "word_based": 4299,
                                            "char_based": 12227
                                        },
                                        "gemini": 16790
                                    },
                                    "downstream_file_content": "```cc\n/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    VLOG(1) << StringPrintf(\"unexpected ReadByTypeValue type: %s\",\n                            uuid.ToString().c_str());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  uint16_t msg_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl,\n                                          e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n  uint16_t buf_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else\n    attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len,\n                                  uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0,\n                        false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    LOG(ERROR) << \"invalid MTU request PDU received.\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE)\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  else if (mtu > GATT_MAX_MTU_SIZE)\n    tcb.payload_size = GATT_MAX_MTU_SIZE;\n  else\n    tcb.payload_size = mtu;\n\n  LOG(INFO) << \"MTU request PDU with MTU size \" << +tcb.payload_size;\n\n  BTM_SetBleDataLength(tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD);\n\n  tGATT_SR_MSG gatt_sr_msg;\n  gatt_sr_msg.mtu = tcb.payload_size;\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered applicaiton with new MTU size. Us a transaction ID */\n  /* of 0, as no response is allowed from applcations                    */\n  for (int i = 0; i < GATT_MAX_APPS; i++) {\n    if (gatt_cb.cl_rcb[i].in_use) {\n      uint16_t conn_id =\n          GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n      gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n                                           uint8_t op_code, uint16_t len,\n                                           uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp for ReadByType: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret = gatts_db_read_attr_value_by_type(\n          tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl, uuid, &buf_len,\n          sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) reason = GATT_SUCCESS;\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid,\n                                    tGATT_SRV_LIST_ELEM& el, uint16_t handle,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        LOG(ERROR) << __func__\n                   << \": Prepare write request was invalid - missing offset, \"\n                      \"sending error response\";\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        VLOG(1) << \"Write CMD with data sigining\";\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE)\n        sr_data.write_req.need_rsp = true;\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) len = GATT_MAX_ATTR_LEN;\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle,\n                                       sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        LOG(ERROR) << __func__\n                   << \"%s: Attempt to write attribute that's not tied with\"\n                      \" characteristic or descriptor value.\";\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      LOG(ERROR) << \"max pending command, send error\";\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                   tGATT_SRV_LIST_ELEM& el, uint8_t op_code,\n                                   uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    LOG(ERROR) << __func__ << \": packet length=\" << len\n               << \" too short. min=\" << sizeof(uint16_t);\n    android_errorWriteWithInfoLog(0x534e4554, \"73172115\", -1, NULL, 0);\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) STREAM_TO_UINT16(offset, p_data);\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason = gatts_read_attr_value_by_handle(\n      tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n      (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    LOG(ERROR) << \"Illegal PDU length, discard request\";\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p,\n                                        attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE &&\n      op_code != GATT_SIGN_CMD_WRITE)\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  VLOG(1) << __func__;\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    VLOG(1) << \"NV update set srv chg = false\";\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback)\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT,\n                                            &req, NULL);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  VLOG(1) << __func__;\n\n  tGATT_VALUE* p_buf =\n      (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len,\n                                p_buf->value);\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  VLOG(1) << __func__ << \" ack handle=%d\" << ack_handle;\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    LOG(ERROR) << \"unexpected handle value confirmation\";\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF,\n                                  &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid,\n                                         uint8_t op_code, uint16_t len,\n                                         uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) return false;\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data,\n                                                         &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS &&\n          (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH)))\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash)\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000,\n                          false);\n    }\n    LOG(INFO) << __func__ << \": database out of sync, device=\" << tcb.peer_bda\n              << \", op_code=\" << loghex((uint16_t)op_code)\n              << \", should_rsp=\" << should_rsp;\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid,\n                                   uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) return;\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, cid);\n  if (len >= payload_size) {\n    LOG(ERROR) << StringPrintf(\"server receive invalid PDU size:%d pdu size:%d\",\n                               len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) return;\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 12368,
                                        "general": {
                                            "word_based": 4099,
                                            "char_based": 11966
                                        },
                                        "gemini": 16171
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "2fc3087b9ac3019518c6ceb8a64d181d6bb04907",
                            "repo_path": "android_repos/Bluetooth",
                            "result": "failure",
                            "downstream_patch_content": "commit 2fc3087b9ac3019518c6ceb8a64d181d6bb04907\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Fri Oct 4 18:23:45 2024 +0000\n\n    Fix OOB writes in gatt_sr.cc\n    \n    At various points in gatt_sr.cc, the output of the\n    gatt_tcb_get_payload_size function is used without checking for a\n    positive length.  However, in exceptional cases it is possible for the\n    channel to be closed at the time the function is called, which will lead\n    to a zero length and cause an OOB write in subsequent processing.\n    \n    Fix all of these.\n    \n    Bug: 364026473\n    Bug: 364027038\n    Bug: 364027949\n    Bug: 364025411\n    Test: m libbluetooth\n    Test: researcher POC\n    Flag: EXEMPT trivial validity checks\n    Tag: #security\n    Ignore-AOSP-First: Security\n    Merged-In: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n    Change-Id: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n\ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 6f81b90514..c61df52bc8 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;\n \n",
                            "downstream_patch_tokens": {
                                "openai": 874,
                                "general": {
                                    "word_based": 305,
                                    "char_based": 671
                                },
                                "gemini": 1160
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "system/stack/gatt/gatt_sr.cc",
                                    "total_hunks": 4,
                                    "failed_hunks": [
                                        1,
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)",
                                            "merge_conflict_tokens": {
                                                "openai": 86,
                                                "general": {
                                                    "word_based": 25,
                                                    "char_based": 69
                                                },
                                                "gemini": 116
                                            }
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)",
                                            "merge_conflict_tokens": {
                                                "openai": 86,
                                                "general": {
                                                    "word_based": 25,
                                                    "char_based": 69
                                                },
                                                "gemini": 116
                                            }
                                        }
                                    ],
                                    "inline_merge_token_summary": {
                                        "gemini": 5104,
                                        "openai": 3956,
                                        "general_word": 1150,
                                        "general_char": 3174
                                    },
                                    "rej_file_content": "```diff\n--- system/stack/gatt/gatt_sr.cc\n+++ system/stack/gatt/gatt_sr.cc\n@@ -772,6 +772,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_cod\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n```",
                                    "rej_file_tokens": {
                                        "openai": 318,
                                        "general": {
                                            "word_based": 105,
                                            "char_based": 246
                                        },
                                        "gemini": 431
                                    },
                                    "patch_apply_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 FAILED at 772.\nHunk #2 FAILED at 804.\nHunk #3 succeeded at 902 with fuzz 2 (offset -47 lines).\nHunk #4 succeeded at 1054 with fuzz 2 (offset -47 lines).\n2 out of 4 hunks FAILED -- saving rejects to file system/stack/gatt/gatt_sr.cc.rej",
                                    "inline_merge_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 NOT MERGED at 780-789.\nHunk #2 NOT MERGED at 828-837.\nHunk #3 merged at 988-992.\nHunk #4 merged at 1145-1149.",
                                    "upstream_file_content": "```cc\n/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n\n#include <bluetooth/log.h>\n#include <com_android_bluetooth_flags.h>\n#include <string.h>\n\n#include <algorithm>\n\n#include \"gatt_int.h\"\n#include \"hardware/bt_gatt_types.h\"\n#include \"internal_include/bt_target.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"stack/arbiter/acl_arbiter.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/include/btm_client_interface.h\"\n#include \"stack/include/l2cdefs.h\"\n#include \"types/bluetooth/uuid.h\"\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattChannel;\nusing bluetooth::eatt::EattExtension;\nusing namespace bluetooth;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel = EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    if (channel == nullptr) {\n      log::warn(\"{}, cid 0x{:02x} already disconnected\", tcb.peer_bda, cid);\n      return 0;\n    }\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) || (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE || op_code == GATT_REQ_MTU ||\n        op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) {\n    return tcb.sr_cmd.op_code == 0;\n  }\n\n  EattChannel* channel = EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n  if (channel == nullptr) {\n    log::warn(\"{}, cid 0x{:02x} already disconnected\", tcb.peer_bda, cid);\n    return false;\n  }\n\n  return channel->server_outstanding_cmd_.op_code == 0;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel = EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    if (channel == nullptr) {\n      log::warn(\"{}, cid 0x{:02x} already disconnected\", tcb.peer_bda, cid);\n      return;\n    }\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  log::verbose(\"gatt_dequeue_sr_cmd cid: 0x{:x}\", cid);\n  if (p_cmd->p_rsp_msg) {\n    log::error(\"free tcb.sr_cmd.p_rsp_msg = {}\", fmt::ptr(p_cmd->p_rsp_msg));\n  }\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q)) {\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  }\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    log::error(\"Invalid MTU\");\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len) {\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  } else {\n    *p++ = GATT_RSP_READ_MULTI;\n  }\n\n  p_buf->len = 1;\n\n  // Now walk through the buffers putting the data into the response in order\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q)) {\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  }\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0) {\n        node = list_begin(list);\n      } else {\n        node = list_next(node);\n      }\n      if (node != list_end(list)) {\n        p_rsp = (tGATTS_RSP*)list_node(node);\n      }\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        log::verbose(\"Buffer space not enough for this data item, skipping\");\n        break;\n      }\n\n      len = std::min((size_t)p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        log::verbose(\"Buffer space not enough for this data item, skipping\");\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        log::verbose(\"multi read overflow available len={} val_len={}\", len, p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t)len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t)len);\n        p_buf->len += (uint16_t)len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) {\n        break;\n      }\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    log::error(\"nothing found!!\");\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    log::verbose(\"osi_free(p_buf)\");\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status, tGATTS_RSP* p_msg,\n                                   uint16_t mtu) {\n  log::verbose(\"status={} mtu={}\", status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL) {\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n  }\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    log::verbose(\"Multi read count={} num_hdls={} variable={}\",\n                 fixed_queue_length(p_cmd->multi_rsp_q), p_cmd->multi_req.num_handles,\n                 p_cmd->multi_req.variable_len);\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) == p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return true;\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return true;\n  }\n\n  /* If here, still waiting */\n  return false;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if, uint32_t /* trans_id */,\n                                     uint8_t op_code, tGATT_STATUS status, tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, sr_res_p->cid);\n\n  log::verbose(\"gatt_if={}\", gatt_if);\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) || (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size)) {\n      return GATT_SUCCESS;\n    }\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS) {\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n    }\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS) {\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n    }\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg =\n                attp_build_sr_msg(tcb, (uint8_t)(op_code + 1), (tGATT_SR_MSG*)p_msg, payload_size);\n      } else {\n        log::error(\"Exception!!! already has respond message\");\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code, sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  log::verbose(\"ret_code={}\", ret_code);\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                 uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rspv for Execute Write: error status={}\",\n                 gatt_cb.err_status);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code, gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    log::error(\"invalid length\");\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0, false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    if (com::android::bluetooth::flags::gatt_client_dynamic_allocation()) {\n      auto prep_cnt_it = tcb.prep_cnt_map.begin();\n      while (prep_cnt_it != tcb.prep_cnt_map.end()) {\n        gatt_if = i;\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC, &gatts_data);\n        prep_cnt_it = tcb.prep_cnt_map.erase(prep_cnt_it);\n      }\n    } else {\n      for (i = 0; i < GATT_MAX_APPS; i++) {\n        if (tcb.prep_cnt[i]) {\n          gatt_if = (tGATT_IF)(i + 1);\n          conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n          tGATTS_DATA gatts_data;\n          gatts_data.exec_write = flag;\n          gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC, &gatts_data);\n          tcb.prep_cnt[i] = 0;\n        }\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    log::error(\"gatt_process_exec_write_req: no prepare write pending\");\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                 uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  log::verbose(\"\");\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  if (multi_req == nullptr) {\n    log::error(\"Could not proceed request. {}, 0x{:02x}\", tcb.peer_bda, cid);\n    return;\n  }\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rspvofr ReadMultiple: error status={}\",\n                 gatt_cb.err_status);\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code, handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag, key_size);\n      if (err != GATT_SUCCESS) {\n        log::verbose(\"read permission denied : 0x{:02x}\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    log::error(\"max attribute handle reached in ReadMultiple Request.\");\n  }\n\n  if (multi_req->num_handles == 0) {\n    err = GATT_INVALID_HANDLE;\n  }\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n      if (sr_cmd_p == nullptr) {\n        log::error(\"Could not send response on CID were request arrived. {}, 0x{:02x}\",\n                   tcb.peer_bda, cid);\n        return;\n      }\n      gatt_sr_reset_cback_cnt(tcb, cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(tcb, cid, it->p_db, op_code, handle, 0,\n                                              p_msg->attr_value.value, &p_msg->attr_value.len,\n                                              GATT_MAX_ATTR_LEN, sec_flag, key_size, trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code, GATT_SUCCESS, p_msg,\n                                  sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else {\n      err = GATT_NO_RESOURCES;\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY) {\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeValue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid,\n                                                   uint8_t op_code, uint16_t s_hdl, uint16_t e_hdl,\n                                                   uint8_t* /* p_data */, const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl || el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) {\n      continue;\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n    }\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size || handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) {\n      continue;\n    }\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle && gatt_cb.last_service_handle == el.s_hdl) {\n      log::verbose(\"Use 0xFFFF for the last primary attribute\");\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n    }\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el, BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) {\n    return GATT_NOT_FOUND;\n  }\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) {\n      break;\n    }\n\n    if (attr.handle < s_hdl) {\n      continue;\n    }\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0) {\n      p_msg->offset =\n              (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16 : GATT_INFO_TYPE_PAIR_128;\n    }\n\n    if (len < info_pair_len[p_msg->offset - 1]) {\n      return GATT_NO_RESOURCES;\n    }\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 && uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 && uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 && uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      log::error(\"format mismatch\");\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    status = GATT_SUCCESS;\n  }\n\n  return status;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl, uint16_t& e_hdl) {\n  if (len < 4) {\n    return GATT_INVALID_PDU;\n  }\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) || !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len, uint8_t*& p,\n                                                 Uuid* p_uuid, uint16_t& s_hdl, uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) {\n    return ret;\n  }\n\n  if (len < 2) {\n    return GATT_INVALID_PDU;\n  }\n\n  /* parse uuid now */\n  log::assert_that(p_uuid != nullptr, \"assert failed: p_uuid != nullptr\");\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    log::verbose(\"Bad UUID\");\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason = gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl, false);\n      log::verbose(\"unexpected ReadByGrpType Group: {}\", uuid.ToString());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    log::verbose(\"unexpected ReadByTypeValue type: {}\", uuid.ToString());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else {\n    attp_send_sr_msg(tcb, cid, p_msg);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len, uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    log::error(\"invalid MTU request PDU received.\");\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  tGATT_SR_MSG gatt_sr_msg;\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE) {\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  } else {\n    tcb.payload_size = std::min(mtu, (uint16_t)(gatt_get_local_mtu()));\n  }\n\n  /* Always say to remote our default MTU. */\n  gatt_sr_msg.mtu = gatt_get_local_mtu();\n\n  log::info(\"MTU {} request from remote ({}), resulted MTU {}\", mtu, tcb.peer_bda,\n            tcb.payload_size);\n\n  if (get_btm_client_interface().ble.BTM_SetBleDataLength(\n              tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD) != tBTM_STATUS::BTM_SUCCESS) {\n    log::warn(\"Unable to set BLE data length peer:{} mtu:{}\", tcb.peer_bda,\n              tcb.payload_size + L2CAP_PKT_OVERHEAD);\n  }\n\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg, GATT_DEF_BLE_MTU_SIZE);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  bluetooth::shim::arbiter::GetArbiter().OnIncomingMtuReq(tcb.tcb_idx, tcb.payload_size);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered application with new MTU size. Use a transaction ID */\n  /* of 0, as no response is allowed from applications */\n  if (com::android::bluetooth::flags::gatt_client_dynamic_allocation()) {\n    for (auto& [i, p_reg] : gatt_cb.cl_rcb_map) {\n      if (p_reg->in_use) {\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, p_reg->gatt_if);\n        gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n      }\n    }\n  } else {\n    for (int i = 0; i < GATT_MAX_APPS; i++) {\n      if (gatt_cb.cl_rcb[i].in_use) {\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n        gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n      }\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                           uint16_t len, uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rsp for ReadByType: error status={}\",\n                 gatt_cb.err_status);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code, s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret =\n              gatts_db_read_attr_value_by_type(tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl,\n                                               uuid, &buf_len, sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) {\n          reason = GATT_SUCCESS;\n        }\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY) {\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    }\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid, tGATT_SRV_LIST_ELEM& el,\n                                    uint16_t handle, uint8_t op_code, uint16_t len, uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        log::error(\"Prepare write request was invalid - missing offset, sending error response\");\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        log::verbose(\"Write CMD with data sigining\");\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE) {\n        sr_data.write_req.need_rsp = true;\n      }\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) {\n        len = GATT_MAX_ATTR_LEN;\n      }\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle, sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        log::error(\n                \"Attempt to write attribute that's not tied with \"\n                \"characteristic or descriptor value.\");\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      log::error(\"max pending command, send error\");\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid, tGATT_SRV_LIST_ELEM& el,\n                                   uint8_t op_code, uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    log::error(\"packet length={} too short. min={}\", len, sizeof(uint16_t));\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) {\n    STREAM_TO_UINT16(offset, p_data);\n  }\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason =\n          gatts_read_attr_value_by_handle(tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n                                          (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY) {\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n    }\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                 uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    log::error(\"Illegal PDU length, discard request\");\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rsp: error status={}\", gatt_cb.err_status);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code, handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p, attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  log::verbose(\"\");\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    log::verbose(\"NV update set srv chg = false\");\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback) {\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT, &req, NULL);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  log::verbose(\"\");\n\n  tGATT_VALUE* p_buf = (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    if (GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len, p_buf->value) !=\n        GATT_SUCCESS) {\n      log::warn(\"Unable to send GATT server handle value conn_id:{}\", p_buf->conn_id);\n    }\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  log::verbose(\"ack handle={}\", ack_handle);\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    log::error(\"unexpected handle value confirmation\");\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF, &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                         uint16_t len, uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) {\n    return false;\n  }\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS && (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH))) {\n        should_ignore = false;\n      }\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash) {\n        should_ignore = false;\n      }\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000, false);\n    }\n    log::info(\"database out of sync, device={}, op_code=0x{:x}, should_rsp={}\", tcb.peer_bda,\n              (uint16_t)op_code, should_rsp);\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) {\n    return;\n  }\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n  if (len >= payload_size) {\n    log::error(\"server receive invalid PDU size:{} pdu size:{}\", len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) {\n      return;\n    }\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}\n```",
                                    "upstream_file_tokens": {
                                        "openai": 12881,
                                        "general": {
                                            "word_based": 4299,
                                            "char_based": 12227
                                        },
                                        "gemini": 16790
                                    },
                                    "downstream_file_content": "```cc\n/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    VLOG(1) << StringPrintf(\"unexpected ReadByTypeValue type: %s\",\n                            uuid.ToString().c_str());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  uint16_t msg_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl,\n                                          e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n  uint16_t buf_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else\n    attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len,\n                                  uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0,\n                        false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    LOG(ERROR) << \"invalid MTU request PDU received.\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE)\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  else if (mtu > GATT_MAX_MTU_SIZE)\n    tcb.payload_size = GATT_MAX_MTU_SIZE;\n  else\n    tcb.payload_size = mtu;\n\n  LOG(INFO) << \"MTU request PDU with MTU size \" << +tcb.payload_size;\n\n  BTM_SetBleDataLength(tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD);\n\n  tGATT_SR_MSG gatt_sr_msg;\n  gatt_sr_msg.mtu = tcb.payload_size;\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered applicaiton with new MTU size. Us a transaction ID */\n  /* of 0, as no response is allowed from applcations                    */\n  for (int i = 0; i < GATT_MAX_APPS; i++) {\n    if (gatt_cb.cl_rcb[i].in_use) {\n      uint16_t conn_id =\n          GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n      gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n                                           uint8_t op_code, uint16_t len,\n                                           uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp for ReadByType: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret = gatts_db_read_attr_value_by_type(\n          tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl, uuid, &buf_len,\n          sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) reason = GATT_SUCCESS;\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid,\n                                    tGATT_SRV_LIST_ELEM& el, uint16_t handle,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        LOG(ERROR) << __func__\n                   << \": Prepare write request was invalid - missing offset, \"\n                      \"sending error response\";\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        VLOG(1) << \"Write CMD with data sigining\";\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE)\n        sr_data.write_req.need_rsp = true;\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) len = GATT_MAX_ATTR_LEN;\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle,\n                                       sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        LOG(ERROR) << __func__\n                   << \"%s: Attempt to write attribute that's not tied with\"\n                      \" characteristic or descriptor value.\";\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      LOG(ERROR) << \"max pending command, send error\";\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                   tGATT_SRV_LIST_ELEM& el, uint8_t op_code,\n                                   uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    LOG(ERROR) << __func__ << \": packet length=\" << len\n               << \" too short. min=\" << sizeof(uint16_t);\n    android_errorWriteWithInfoLog(0x534e4554, \"73172115\", -1, NULL, 0);\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) STREAM_TO_UINT16(offset, p_data);\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason = gatts_read_attr_value_by_handle(\n      tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n      (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    LOG(ERROR) << \"Illegal PDU length, discard request\";\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p,\n                                        attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE &&\n      op_code != GATT_SIGN_CMD_WRITE)\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  VLOG(1) << __func__;\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    VLOG(1) << \"NV update set srv chg = false\";\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback)\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT,\n                                            &req, NULL);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  VLOG(1) << __func__;\n\n  tGATT_VALUE* p_buf =\n      (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len,\n                                p_buf->value);\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  VLOG(1) << __func__ << \" ack handle=%d\" << ack_handle;\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    LOG(ERROR) << \"unexpected handle value confirmation\";\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF,\n                                  &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid,\n                                         uint8_t op_code, uint16_t len,\n                                         uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) return false;\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data,\n                                                         &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS &&\n          (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH)))\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash)\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000,\n                          false);\n    }\n    LOG(INFO) << __func__ << \": database out of sync, device=\" << tcb.peer_bda\n              << \", op_code=\" << loghex((uint16_t)op_code)\n              << \", should_rsp=\" << should_rsp;\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid,\n                                   uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) return;\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, cid);\n  if (len >= payload_size) {\n    LOG(ERROR) << StringPrintf(\"server receive invalid PDU size:%d pdu size:%d\",\n                               len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) return;\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 12368,
                                        "general": {
                                            "word_based": 4099,
                                            "char_based": 11966
                                        },
                                        "gemini": 16171
                                    }
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-323850943",
            "aliases": [
                "A-323850943",
                "CVE-2024-43096"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-323850943",
            "severity": "Critical",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "cad927034a371b82a4a07a16ec442eb261f6153f"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From cad927034a371b82a4a07a16ec442eb261f6153f Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Thu, 16 May 2024 20:47:44 +0000\nSubject: [PATCH] Fix OOB write in build_read_multi_rsp of gatt_sr.cc\n\nbuild_read_multi_rsp is missing a bounds check, which can lead to an\nOOB write when the mtu parameter is set to zero.\n\nAdd that bounds check.\n\nBug: 323850943\nTest: atest GattSrTest\nTest: researcher POC\nTag: #security\nFlag: EXEMPT trivial validity checks\nIgnore-AOSP-First: Security\nChange-Id: I18e4325dbc9d6814220332288c85b114d0415c2f\n---\n system/stack/eatt/eatt.h     | 1 +\n system/stack/gatt/gatt_sr.cc | 7 +++++++\n 2 files changed, 8 insertions(+)\n\ndiff --git a/system/stack/eatt/eatt.h b/system/stack/eatt/eatt.h\nindex 62bf248206..0a1a591a54 100644\n--- a/system/stack/eatt/eatt.h\n+++ b/system/stack/eatt/eatt.h\n@@ -100,6 +100,7 @@ class EattChannel {\n \n   void EattChannelSetTxMTU(uint16_t tx_mtu) {\n     this->tx_mtu_ = std::min<uint16_t>(tx_mtu, EATT_MAX_TX_MTU);\n+    this->tx_mtu_ = std::max<uint16_t>(tx_mtu, EATT_MIN_MTU_MPS);\n   }\n };\n \ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 9c40fedb7d..1785372507 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -162,6 +162,13 @@ static void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n   uint8_t* p;\n   bool is_overflow = false;\n \n+  // We need at least one extra byte for the opcode\n+  if (mtu == 0) {\n+    log::error(\"Invalid MTU\");\n+    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n+    return;\n+  }\n+\n   len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n   BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n   p_buf->offset = L2CAP_MIN_OFFSET;\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 617,
                        "general": {
                            "word_based": 238,
                            "char_based": 428
                        },
                        "gemini": 804
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 2,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "result": "skipped",
                            "reason": "\u274c Failed to checkout branch android12-release: Command '['git', 'checkout', 'android12-release']' returned non-zero exit status 1.",
                            "downstream_patch": "c177fdbd6189a114239e11e2713740b5a50624e1"
                        },
                        {
                            "downstream_version": "12L",
                            "result": "skipped",
                            "reason": "\u274c Failed to checkout branch android12L-release: Command '['git', 'checkout', 'android12L-release']' returned non-zero exit status 1.",
                            "downstream_patch": "c177fdbd6189a114239e11e2713740b5a50624e1"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "e5ab6c617683a00c4e2996f1bc15c4c6e7f70f48",
                            "repo_path": "android_repos/Bluetooth",
                            "result": "success",
                            "downstream_patch_content": "commit e5ab6c617683a00c4e2996f1bc15c4c6e7f70f48\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Thu May 16 20:47:44 2024 +0000\n\n    Fix OOB write in build_read_multi_rsp of gatt_sr.cc\n    \n    build_read_multi_rsp is missing a bounds check, which can lead to an\n    OOB write when the mtu parameter is set to zero.\n    \n    Add that bounds check.\n    \n    Bug: 323850943\n    Test: atest GattSrTest\n    Test: researcher POC\n    Tag: #security\n    Flag: EXEMPT trivial validity checks\n    Ignore-AOSP-First: Security\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:cad927034a371b82a4a07a16ec442eb261f6153f)\n    Merged-In: I18e4325dbc9d6814220332288c85b114d0415c2f\n    Change-Id: I18e4325dbc9d6814220332288c85b114d0415c2f\n\ndiff --git a/system/stack/eatt/eatt.h b/system/stack/eatt/eatt.h\nindex 92b61c533e..69e3e32257 100644\n--- a/system/stack/eatt/eatt.h\n+++ b/system/stack/eatt/eatt.h\n@@ -98,6 +98,7 @@ class EattChannel {\n \n   void EattChannelSetTxMTU(uint16_t tx_mtu) {\n     this->tx_mtu_ = std::min<uint16_t>(tx_mtu, EATT_MAX_TX_MTU);\n+    this->tx_mtu_ = std::max<uint16_t>(this->tx_mtu_, EATT_MIN_MTU_MPS);\n   }\n };\n \ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 4c00743228..3ab333d167 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -148,6 +148,13 @@ static void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n   uint8_t* p;\n   bool is_overflow = false;\n \n+  // We need at least one extra byte for the opcode\n+  if (mtu == 0) {\n+    LOG(ERROR) << \"Invalid MTU\";\n+    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n+    return;\n+  }\n+\n   len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n   BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n   p_buf->offset = L2CAP_MIN_OFFSET;\n",
                            "downstream_patch_tokens": {
                                "openai": 641,
                                "general": {
                                    "word_based": 222,
                                    "char_based": 445
                                },
                                "gemini": 845
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "e5ab6c617683a00c4e2996f1bc15c4c6e7f70f48",
                            "repo_path": "android_repos/Bluetooth",
                            "result": "success",
                            "downstream_patch_content": "commit e5ab6c617683a00c4e2996f1bc15c4c6e7f70f48\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Thu May 16 20:47:44 2024 +0000\n\n    Fix OOB write in build_read_multi_rsp of gatt_sr.cc\n    \n    build_read_multi_rsp is missing a bounds check, which can lead to an\n    OOB write when the mtu parameter is set to zero.\n    \n    Add that bounds check.\n    \n    Bug: 323850943\n    Test: atest GattSrTest\n    Test: researcher POC\n    Tag: #security\n    Flag: EXEMPT trivial validity checks\n    Ignore-AOSP-First: Security\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:cad927034a371b82a4a07a16ec442eb261f6153f)\n    Merged-In: I18e4325dbc9d6814220332288c85b114d0415c2f\n    Change-Id: I18e4325dbc9d6814220332288c85b114d0415c2f\n\ndiff --git a/system/stack/eatt/eatt.h b/system/stack/eatt/eatt.h\nindex 92b61c533e..69e3e32257 100644\n--- a/system/stack/eatt/eatt.h\n+++ b/system/stack/eatt/eatt.h\n@@ -98,6 +98,7 @@ class EattChannel {\n \n   void EattChannelSetTxMTU(uint16_t tx_mtu) {\n     this->tx_mtu_ = std::min<uint16_t>(tx_mtu, EATT_MAX_TX_MTU);\n+    this->tx_mtu_ = std::max<uint16_t>(this->tx_mtu_, EATT_MIN_MTU_MPS);\n   }\n };\n \ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 4c00743228..3ab333d167 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -148,6 +148,13 @@ static void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n   uint8_t* p;\n   bool is_overflow = false;\n \n+  // We need at least one extra byte for the opcode\n+  if (mtu == 0) {\n+    LOG(ERROR) << \"Invalid MTU\";\n+    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n+    return;\n+  }\n+\n   len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n   BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n   p_buf->offset = L2CAP_MIN_OFFSET;\n",
                            "downstream_patch_tokens": {
                                "openai": 641,
                                "general": {
                                    "word_based": 222,
                                    "char_based": 445
                                },
                                "gemini": 845
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-364026473",
            "aliases": [
                "A-364026473",
                "CVE-2024-43770"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-364026473",
            "severity": "Critical",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "7de5617f7d5266fe57c990c428621b5d4e92728a"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 7de5617f7d5266fe57c990c428621b5d4e92728a Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Thu, 12 Sep 2024 17:26:55 +0000\nSubject: [PATCH] Fix OOB writes in gatt_sr.cc\n\nAt various points in gatt_sr.cc, the output of the\ngatt_tcb_get_payload_size function is used without checking for a\npositive length.  However, in exceptional cases it is possible for the\nchannel to be closed at the time the function is called, which will lead\nto a zero length and cause an OOB write in subsequent processing.\n\nFix all of these.\n\nBug: 364026473\nBug: 364027038\nBug: 364027949\nBug: 364025411\nTest: m libbluetooth\nTest: researcher POC\nFlag: EXEMPT trivial validity checks\nTag: #security\nIgnore-AOSP-First: Security\nChange-Id: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n---\n system/stack/gatt/gatt_sr.cc | 21 +++++++++++++++++++++\n 1 file changed, 21 insertions(+)\n\ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 995ea810cb..0235ba964e 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -772,6 +772,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_cod\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n@@ -949,6 +960,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid, uint8_t\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1096,6 +1112,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid, tGATT_SRV_LIST_\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 941,
                        "general": {
                            "word_based": 349,
                            "char_based": 720
                        },
                        "gemini": 1252
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 0,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "result": "skipped",
                            "reason": "\u274c Failed to checkout branch android12-release: Command '['git', 'checkout', 'android12-release']' returned non-zero exit status 1.",
                            "downstream_patch": "7e5f45df8880293e1ab40367670d1a8959a542f9"
                        },
                        {
                            "downstream_version": "12L",
                            "result": "skipped",
                            "reason": "\u274c Failed to checkout branch android12L-release: Command '['git', 'checkout', 'android12L-release']' returned non-zero exit status 1.",
                            "downstream_patch": "7e5f45df8880293e1ab40367670d1a8959a542f9"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "2fc3087b9ac3019518c6ceb8a64d181d6bb04907",
                            "repo_path": "android_repos/Bluetooth",
                            "result": "failure",
                            "downstream_patch_content": "commit 2fc3087b9ac3019518c6ceb8a64d181d6bb04907\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Fri Oct 4 18:23:45 2024 +0000\n\n    Fix OOB writes in gatt_sr.cc\n    \n    At various points in gatt_sr.cc, the output of the\n    gatt_tcb_get_payload_size function is used without checking for a\n    positive length.  However, in exceptional cases it is possible for the\n    channel to be closed at the time the function is called, which will lead\n    to a zero length and cause an OOB write in subsequent processing.\n    \n    Fix all of these.\n    \n    Bug: 364026473\n    Bug: 364027038\n    Bug: 364027949\n    Bug: 364025411\n    Test: m libbluetooth\n    Test: researcher POC\n    Flag: EXEMPT trivial validity checks\n    Tag: #security\n    Ignore-AOSP-First: Security\n    Merged-In: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n    Change-Id: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n\ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 6f81b90514..c61df52bc8 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;\n \n",
                            "downstream_patch_tokens": {
                                "openai": 874,
                                "general": {
                                    "word_based": 305,
                                    "char_based": 671
                                },
                                "gemini": 1160
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "system/stack/gatt/gatt_sr.cc",
                                    "total_hunks": 4,
                                    "failed_hunks": [
                                        1,
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)",
                                            "merge_conflict_tokens": {
                                                "openai": 86,
                                                "general": {
                                                    "word_based": 25,
                                                    "char_based": 69
                                                },
                                                "gemini": 116
                                            }
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)",
                                            "merge_conflict_tokens": {
                                                "openai": 86,
                                                "general": {
                                                    "word_based": 25,
                                                    "char_based": 69
                                                },
                                                "gemini": 116
                                            }
                                        }
                                    ],
                                    "inline_merge_token_summary": {
                                        "gemini": 4176,
                                        "openai": 3268,
                                        "general_word": 950,
                                        "general_char": 2622
                                    },
                                    "rej_file_content": "```diff\n--- system/stack/gatt/gatt_sr.cc\n+++ system/stack/gatt/gatt_sr.cc\n@@ -772,6 +772,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_cod\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n```",
                                    "rej_file_tokens": {
                                        "openai": 318,
                                        "general": {
                                            "word_based": 105,
                                            "char_based": 246
                                        },
                                        "gemini": 431
                                    },
                                    "patch_apply_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 FAILED at 772.\nHunk #2 FAILED at 804.\nHunk #3 succeeded at 902 with fuzz 2 (offset -47 lines).\nHunk #4 succeeded at 1054 with fuzz 2 (offset -47 lines).\n2 out of 4 hunks FAILED -- saving rejects to file system/stack/gatt/gatt_sr.cc.rej",
                                    "inline_merge_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 NOT MERGED at 780-789.\nHunk #2 NOT MERGED at 828-837.\nHunk #3 merged at 988-992.\nHunk #4 merged at 1145-1149.",
                                    "upstream_file_content": "```cc\n/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n\n#include <bluetooth/log.h>\n#include <com_android_bluetooth_flags.h>\n#include <string.h>\n\n#include <algorithm>\n\n#include \"gatt_int.h\"\n#include \"hardware/bt_gatt_types.h\"\n#include \"internal_include/bt_target.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"stack/arbiter/acl_arbiter.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/include/btm_client_interface.h\"\n#include \"stack/include/l2cdefs.h\"\n#include \"types/bluetooth/uuid.h\"\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattChannel;\nusing bluetooth::eatt::EattExtension;\nusing namespace bluetooth;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel = EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    if (channel == nullptr) {\n      log::warn(\"{}, cid 0x{:02x} already disconnected\", tcb.peer_bda, cid);\n      return 0;\n    }\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) || (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE || op_code == GATT_REQ_MTU ||\n        op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) {\n    return tcb.sr_cmd.op_code == 0;\n  }\n\n  EattChannel* channel = EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n  if (channel == nullptr) {\n    log::warn(\"{}, cid 0x{:02x} already disconnected\", tcb.peer_bda, cid);\n    return false;\n  }\n\n  return channel->server_outstanding_cmd_.op_code == 0;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel = EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    if (channel == nullptr) {\n      log::warn(\"{}, cid 0x{:02x} already disconnected\", tcb.peer_bda, cid);\n      return;\n    }\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  log::verbose(\"gatt_dequeue_sr_cmd cid: 0x{:x}\", cid);\n  if (p_cmd->p_rsp_msg) {\n    log::error(\"free tcb.sr_cmd.p_rsp_msg = {}\", fmt::ptr(p_cmd->p_rsp_msg));\n  }\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q)) {\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  }\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    log::error(\"Invalid MTU\");\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len) {\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  } else {\n    *p++ = GATT_RSP_READ_MULTI;\n  }\n\n  p_buf->len = 1;\n\n  // Now walk through the buffers putting the data into the response in order\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q)) {\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  }\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0) {\n        node = list_begin(list);\n      } else {\n        node = list_next(node);\n      }\n      if (node != list_end(list)) {\n        p_rsp = (tGATTS_RSP*)list_node(node);\n      }\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        log::verbose(\"Buffer space not enough for this data item, skipping\");\n        break;\n      }\n\n      len = std::min((size_t)p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        log::verbose(\"Buffer space not enough for this data item, skipping\");\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        log::verbose(\"multi read overflow available len={} val_len={}\", len, p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t)len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t)len);\n        p_buf->len += (uint16_t)len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) {\n        break;\n      }\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    log::error(\"nothing found!!\");\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    log::verbose(\"osi_free(p_buf)\");\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status, tGATTS_RSP* p_msg,\n                                   uint16_t mtu) {\n  log::verbose(\"status={} mtu={}\", status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL) {\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n  }\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    log::verbose(\"Multi read count={} num_hdls={} variable={}\",\n                 fixed_queue_length(p_cmd->multi_rsp_q), p_cmd->multi_req.num_handles,\n                 p_cmd->multi_req.variable_len);\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) == p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return true;\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return true;\n  }\n\n  /* If here, still waiting */\n  return false;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if, uint32_t /* trans_id */,\n                                     uint8_t op_code, tGATT_STATUS status, tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, sr_res_p->cid);\n\n  log::verbose(\"gatt_if={}\", gatt_if);\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) || (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size)) {\n      return GATT_SUCCESS;\n    }\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS) {\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n    }\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS) {\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n    }\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg =\n                attp_build_sr_msg(tcb, (uint8_t)(op_code + 1), (tGATT_SR_MSG*)p_msg, payload_size);\n      } else {\n        log::error(\"Exception!!! already has respond message\");\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code, sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  log::verbose(\"ret_code={}\", ret_code);\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                 uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rspv for Execute Write: error status={}\",\n                 gatt_cb.err_status);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code, gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    log::error(\"invalid length\");\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0, false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    if (com::android::bluetooth::flags::gatt_client_dynamic_allocation()) {\n      auto prep_cnt_it = tcb.prep_cnt_map.begin();\n      while (prep_cnt_it != tcb.prep_cnt_map.end()) {\n        gatt_if = i;\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC, &gatts_data);\n        prep_cnt_it = tcb.prep_cnt_map.erase(prep_cnt_it);\n      }\n    } else {\n      for (i = 0; i < GATT_MAX_APPS; i++) {\n        if (tcb.prep_cnt[i]) {\n          gatt_if = (tGATT_IF)(i + 1);\n          conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n          tGATTS_DATA gatts_data;\n          gatts_data.exec_write = flag;\n          gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC, &gatts_data);\n          tcb.prep_cnt[i] = 0;\n        }\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    log::error(\"gatt_process_exec_write_req: no prepare write pending\");\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                 uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  log::verbose(\"\");\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  if (multi_req == nullptr) {\n    log::error(\"Could not proceed request. {}, 0x{:02x}\", tcb.peer_bda, cid);\n    return;\n  }\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rspvofr ReadMultiple: error status={}\",\n                 gatt_cb.err_status);\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code, handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag, key_size);\n      if (err != GATT_SUCCESS) {\n        log::verbose(\"read permission denied : 0x{:02x}\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    log::error(\"max attribute handle reached in ReadMultiple Request.\");\n  }\n\n  if (multi_req->num_handles == 0) {\n    err = GATT_INVALID_HANDLE;\n  }\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n      if (sr_cmd_p == nullptr) {\n        log::error(\"Could not send response on CID were request arrived. {}, 0x{:02x}\",\n                   tcb.peer_bda, cid);\n        return;\n      }\n      gatt_sr_reset_cback_cnt(tcb, cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(tcb, cid, it->p_db, op_code, handle, 0,\n                                              p_msg->attr_value.value, &p_msg->attr_value.len,\n                                              GATT_MAX_ATTR_LEN, sec_flag, key_size, trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code, GATT_SUCCESS, p_msg,\n                                  sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else {\n      err = GATT_NO_RESOURCES;\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY) {\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeValue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid,\n                                                   uint8_t op_code, uint16_t s_hdl, uint16_t e_hdl,\n                                                   uint8_t* /* p_data */, const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl || el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) {\n      continue;\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n    }\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size || handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) {\n      continue;\n    }\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle && gatt_cb.last_service_handle == el.s_hdl) {\n      log::verbose(\"Use 0xFFFF for the last primary attribute\");\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n    }\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el, BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) {\n    return GATT_NOT_FOUND;\n  }\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) {\n      break;\n    }\n\n    if (attr.handle < s_hdl) {\n      continue;\n    }\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0) {\n      p_msg->offset =\n              (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16 : GATT_INFO_TYPE_PAIR_128;\n    }\n\n    if (len < info_pair_len[p_msg->offset - 1]) {\n      return GATT_NO_RESOURCES;\n    }\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 && uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 && uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 && uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      log::error(\"format mismatch\");\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    status = GATT_SUCCESS;\n  }\n\n  return status;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl, uint16_t& e_hdl) {\n  if (len < 4) {\n    return GATT_INVALID_PDU;\n  }\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) || !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len, uint8_t*& p,\n                                                 Uuid* p_uuid, uint16_t& s_hdl, uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) {\n    return ret;\n  }\n\n  if (len < 2) {\n    return GATT_INVALID_PDU;\n  }\n\n  /* parse uuid now */\n  log::assert_that(p_uuid != nullptr, \"assert failed: p_uuid != nullptr\");\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    log::verbose(\"Bad UUID\");\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason = gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl, false);\n      log::verbose(\"unexpected ReadByGrpType Group: {}\", uuid.ToString());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    log::verbose(\"unexpected ReadByTypeValue type: {}\", uuid.ToString());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else {\n    attp_send_sr_msg(tcb, cid, p_msg);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len, uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    log::error(\"invalid MTU request PDU received.\");\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  tGATT_SR_MSG gatt_sr_msg;\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE) {\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  } else {\n    tcb.payload_size = std::min(mtu, (uint16_t)(gatt_get_local_mtu()));\n  }\n\n  /* Always say to remote our default MTU. */\n  gatt_sr_msg.mtu = gatt_get_local_mtu();\n\n  log::info(\"MTU {} request from remote ({}), resulted MTU {}\", mtu, tcb.peer_bda,\n            tcb.payload_size);\n\n  if (get_btm_client_interface().ble.BTM_SetBleDataLength(\n              tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD) != tBTM_STATUS::BTM_SUCCESS) {\n    log::warn(\"Unable to set BLE data length peer:{} mtu:{}\", tcb.peer_bda,\n              tcb.payload_size + L2CAP_PKT_OVERHEAD);\n  }\n\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg, GATT_DEF_BLE_MTU_SIZE);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  bluetooth::shim::arbiter::GetArbiter().OnIncomingMtuReq(tcb.tcb_idx, tcb.payload_size);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered application with new MTU size. Use a transaction ID */\n  /* of 0, as no response is allowed from applications */\n  if (com::android::bluetooth::flags::gatt_client_dynamic_allocation()) {\n    for (auto& [i, p_reg] : gatt_cb.cl_rcb_map) {\n      if (p_reg->in_use) {\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, p_reg->gatt_if);\n        gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n      }\n    }\n  } else {\n    for (int i = 0; i < GATT_MAX_APPS; i++) {\n      if (gatt_cb.cl_rcb[i].in_use) {\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n        gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n      }\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                           uint16_t len, uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rsp for ReadByType: error status={}\",\n                 gatt_cb.err_status);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code, s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret =\n              gatts_db_read_attr_value_by_type(tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl,\n                                               uuid, &buf_len, sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) {\n          reason = GATT_SUCCESS;\n        }\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY) {\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    }\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid, tGATT_SRV_LIST_ELEM& el,\n                                    uint16_t handle, uint8_t op_code, uint16_t len, uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        log::error(\"Prepare write request was invalid - missing offset, sending error response\");\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        log::verbose(\"Write CMD with data sigining\");\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE) {\n        sr_data.write_req.need_rsp = true;\n      }\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) {\n        len = GATT_MAX_ATTR_LEN;\n      }\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle, sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        log::error(\n                \"Attempt to write attribute that's not tied with \"\n                \"characteristic or descriptor value.\");\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      log::error(\"max pending command, send error\");\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid, tGATT_SRV_LIST_ELEM& el,\n                                   uint8_t op_code, uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    log::error(\"packet length={} too short. min={}\", len, sizeof(uint16_t));\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) {\n    STREAM_TO_UINT16(offset, p_data);\n  }\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason =\n          gatts_read_attr_value_by_handle(tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n                                          (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY) {\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n    }\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                 uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    log::error(\"Illegal PDU length, discard request\");\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rsp: error status={}\", gatt_cb.err_status);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code, handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p, attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  log::verbose(\"\");\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    log::verbose(\"NV update set srv chg = false\");\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback) {\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT, &req, NULL);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  log::verbose(\"\");\n\n  tGATT_VALUE* p_buf = (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    if (GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len, p_buf->value) !=\n        GATT_SUCCESS) {\n      log::warn(\"Unable to send GATT server handle value conn_id:{}\", p_buf->conn_id);\n    }\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  log::verbose(\"ack handle={}\", ack_handle);\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    log::error(\"unexpected handle value confirmation\");\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF, &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                         uint16_t len, uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) {\n    return false;\n  }\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS && (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH))) {\n        should_ignore = false;\n      }\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash) {\n        should_ignore = false;\n      }\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000, false);\n    }\n    log::info(\"database out of sync, device={}, op_code=0x{:x}, should_rsp={}\", tcb.peer_bda,\n              (uint16_t)op_code, should_rsp);\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) {\n    return;\n  }\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n  if (len >= payload_size) {\n    log::error(\"server receive invalid PDU size:{} pdu size:{}\", len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) {\n      return;\n    }\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}\n```",
                                    "upstream_file_tokens": {
                                        "openai": 12881,
                                        "general": {
                                            "word_based": 4299,
                                            "char_based": 12227
                                        },
                                        "gemini": 16790
                                    },
                                    "downstream_file_content": "```cc\n/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    VLOG(1) << StringPrintf(\"unexpected ReadByTypeValue type: %s\",\n                            uuid.ToString().c_str());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  uint16_t msg_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl,\n                                          e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n  uint16_t buf_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else\n    attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len,\n                                  uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0,\n                        false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    LOG(ERROR) << \"invalid MTU request PDU received.\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE)\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  else if (mtu > GATT_MAX_MTU_SIZE)\n    tcb.payload_size = GATT_MAX_MTU_SIZE;\n  else\n    tcb.payload_size = mtu;\n\n  LOG(INFO) << \"MTU request PDU with MTU size \" << +tcb.payload_size;\n\n  BTM_SetBleDataLength(tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD);\n\n  tGATT_SR_MSG gatt_sr_msg;\n  gatt_sr_msg.mtu = tcb.payload_size;\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered applicaiton with new MTU size. Us a transaction ID */\n  /* of 0, as no response is allowed from applcations                    */\n  for (int i = 0; i < GATT_MAX_APPS; i++) {\n    if (gatt_cb.cl_rcb[i].in_use) {\n      uint16_t conn_id =\n          GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n      gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n                                           uint8_t op_code, uint16_t len,\n                                           uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp for ReadByType: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret = gatts_db_read_attr_value_by_type(\n          tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl, uuid, &buf_len,\n          sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) reason = GATT_SUCCESS;\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid,\n                                    tGATT_SRV_LIST_ELEM& el, uint16_t handle,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        LOG(ERROR) << __func__\n                   << \": Prepare write request was invalid - missing offset, \"\n                      \"sending error response\";\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        VLOG(1) << \"Write CMD with data sigining\";\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE)\n        sr_data.write_req.need_rsp = true;\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) len = GATT_MAX_ATTR_LEN;\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle,\n                                       sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        LOG(ERROR) << __func__\n                   << \"%s: Attempt to write attribute that's not tied with\"\n                      \" characteristic or descriptor value.\";\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      LOG(ERROR) << \"max pending command, send error\";\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                   tGATT_SRV_LIST_ELEM& el, uint8_t op_code,\n                                   uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    LOG(ERROR) << __func__ << \": packet length=\" << len\n               << \" too short. min=\" << sizeof(uint16_t);\n    android_errorWriteWithInfoLog(0x534e4554, \"73172115\", -1, NULL, 0);\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) STREAM_TO_UINT16(offset, p_data);\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason = gatts_read_attr_value_by_handle(\n      tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n      (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    LOG(ERROR) << \"Illegal PDU length, discard request\";\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p,\n                                        attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE &&\n      op_code != GATT_SIGN_CMD_WRITE)\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  VLOG(1) << __func__;\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    VLOG(1) << \"NV update set srv chg = false\";\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback)\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT,\n                                            &req, NULL);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  VLOG(1) << __func__;\n\n  tGATT_VALUE* p_buf =\n      (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len,\n                                p_buf->value);\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  VLOG(1) << __func__ << \" ack handle=%d\" << ack_handle;\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    LOG(ERROR) << \"unexpected handle value confirmation\";\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF,\n                                  &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid,\n                                         uint8_t op_code, uint16_t len,\n                                         uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) return false;\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data,\n                                                         &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS &&\n          (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH)))\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash)\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000,\n                          false);\n    }\n    LOG(INFO) << __func__ << \": database out of sync, device=\" << tcb.peer_bda\n              << \", op_code=\" << loghex((uint16_t)op_code)\n              << \", should_rsp=\" << should_rsp;\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid,\n                                   uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) return;\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, cid);\n  if (len >= payload_size) {\n    LOG(ERROR) << StringPrintf(\"server receive invalid PDU size:%d pdu size:%d\",\n                               len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) return;\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 12368,
                                        "general": {
                                            "word_based": 4099,
                                            "char_based": 11966
                                        },
                                        "gemini": 16171
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "2fc3087b9ac3019518c6ceb8a64d181d6bb04907",
                            "repo_path": "android_repos/Bluetooth",
                            "result": "failure",
                            "downstream_patch_content": "commit 2fc3087b9ac3019518c6ceb8a64d181d6bb04907\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Fri Oct 4 18:23:45 2024 +0000\n\n    Fix OOB writes in gatt_sr.cc\n    \n    At various points in gatt_sr.cc, the output of the\n    gatt_tcb_get_payload_size function is used without checking for a\n    positive length.  However, in exceptional cases it is possible for the\n    channel to be closed at the time the function is called, which will lead\n    to a zero length and cause an OOB write in subsequent processing.\n    \n    Fix all of these.\n    \n    Bug: 364026473\n    Bug: 364027038\n    Bug: 364027949\n    Bug: 364025411\n    Test: m libbluetooth\n    Test: researcher POC\n    Flag: EXEMPT trivial validity checks\n    Tag: #security\n    Ignore-AOSP-First: Security\n    Merged-In: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n    Change-Id: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n\ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 6f81b90514..c61df52bc8 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;\n \n",
                            "downstream_patch_tokens": {
                                "openai": 874,
                                "general": {
                                    "word_based": 305,
                                    "char_based": 671
                                },
                                "gemini": 1160
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "system/stack/gatt/gatt_sr.cc",
                                    "total_hunks": 4,
                                    "failed_hunks": [
                                        1,
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)",
                                            "merge_conflict_tokens": {
                                                "openai": 86,
                                                "general": {
                                                    "word_based": 25,
                                                    "char_based": 69
                                                },
                                                "gemini": 116
                                            }
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)",
                                            "merge_conflict_tokens": {
                                                "openai": 86,
                                                "general": {
                                                    "word_based": 25,
                                                    "char_based": 69
                                                },
                                                "gemini": 116
                                            }
                                        }
                                    ],
                                    "inline_merge_token_summary": {
                                        "gemini": 4176,
                                        "openai": 3268,
                                        "general_word": 950,
                                        "general_char": 2622
                                    },
                                    "rej_file_content": "```diff\n--- system/stack/gatt/gatt_sr.cc\n+++ system/stack/gatt/gatt_sr.cc\n@@ -772,6 +772,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_cod\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n```",
                                    "rej_file_tokens": {
                                        "openai": 318,
                                        "general": {
                                            "word_based": 105,
                                            "char_based": 246
                                        },
                                        "gemini": 431
                                    },
                                    "patch_apply_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 FAILED at 772.\nHunk #2 FAILED at 804.\nHunk #3 succeeded at 902 with fuzz 2 (offset -47 lines).\nHunk #4 succeeded at 1054 with fuzz 2 (offset -47 lines).\n2 out of 4 hunks FAILED -- saving rejects to file system/stack/gatt/gatt_sr.cc.rej",
                                    "inline_merge_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 NOT MERGED at 780-789.\nHunk #2 NOT MERGED at 828-837.\nHunk #3 merged at 988-992.\nHunk #4 merged at 1145-1149.",
                                    "upstream_file_content": "```cc\n/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n\n#include <bluetooth/log.h>\n#include <com_android_bluetooth_flags.h>\n#include <string.h>\n\n#include <algorithm>\n\n#include \"gatt_int.h\"\n#include \"hardware/bt_gatt_types.h\"\n#include \"internal_include/bt_target.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"stack/arbiter/acl_arbiter.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/include/btm_client_interface.h\"\n#include \"stack/include/l2cdefs.h\"\n#include \"types/bluetooth/uuid.h\"\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattChannel;\nusing bluetooth::eatt::EattExtension;\nusing namespace bluetooth;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel = EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    if (channel == nullptr) {\n      log::warn(\"{}, cid 0x{:02x} already disconnected\", tcb.peer_bda, cid);\n      return 0;\n    }\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) || (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE || op_code == GATT_REQ_MTU ||\n        op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) {\n    return tcb.sr_cmd.op_code == 0;\n  }\n\n  EattChannel* channel = EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n  if (channel == nullptr) {\n    log::warn(\"{}, cid 0x{:02x} already disconnected\", tcb.peer_bda, cid);\n    return false;\n  }\n\n  return channel->server_outstanding_cmd_.op_code == 0;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel = EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    if (channel == nullptr) {\n      log::warn(\"{}, cid 0x{:02x} already disconnected\", tcb.peer_bda, cid);\n      return;\n    }\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  log::verbose(\"gatt_dequeue_sr_cmd cid: 0x{:x}\", cid);\n  if (p_cmd->p_rsp_msg) {\n    log::error(\"free tcb.sr_cmd.p_rsp_msg = {}\", fmt::ptr(p_cmd->p_rsp_msg));\n  }\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q)) {\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  }\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    log::error(\"Invalid MTU\");\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len) {\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  } else {\n    *p++ = GATT_RSP_READ_MULTI;\n  }\n\n  p_buf->len = 1;\n\n  // Now walk through the buffers putting the data into the response in order\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q)) {\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  }\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0) {\n        node = list_begin(list);\n      } else {\n        node = list_next(node);\n      }\n      if (node != list_end(list)) {\n        p_rsp = (tGATTS_RSP*)list_node(node);\n      }\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        log::verbose(\"Buffer space not enough for this data item, skipping\");\n        break;\n      }\n\n      len = std::min((size_t)p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        log::verbose(\"Buffer space not enough for this data item, skipping\");\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        log::verbose(\"multi read overflow available len={} val_len={}\", len, p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t)len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t)len);\n        p_buf->len += (uint16_t)len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) {\n        break;\n      }\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    log::error(\"nothing found!!\");\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    log::verbose(\"osi_free(p_buf)\");\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status, tGATTS_RSP* p_msg,\n                                   uint16_t mtu) {\n  log::verbose(\"status={} mtu={}\", status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL) {\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n  }\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    log::verbose(\"Multi read count={} num_hdls={} variable={}\",\n                 fixed_queue_length(p_cmd->multi_rsp_q), p_cmd->multi_req.num_handles,\n                 p_cmd->multi_req.variable_len);\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) == p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return true;\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return true;\n  }\n\n  /* If here, still waiting */\n  return false;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if, uint32_t /* trans_id */,\n                                     uint8_t op_code, tGATT_STATUS status, tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, sr_res_p->cid);\n\n  log::verbose(\"gatt_if={}\", gatt_if);\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) || (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size)) {\n      return GATT_SUCCESS;\n    }\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS) {\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n    }\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS) {\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n    }\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg =\n                attp_build_sr_msg(tcb, (uint8_t)(op_code + 1), (tGATT_SR_MSG*)p_msg, payload_size);\n      } else {\n        log::error(\"Exception!!! already has respond message\");\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code, sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  log::verbose(\"ret_code={}\", ret_code);\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                 uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rspv for Execute Write: error status={}\",\n                 gatt_cb.err_status);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code, gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    log::error(\"invalid length\");\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0, false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    if (com::android::bluetooth::flags::gatt_client_dynamic_allocation()) {\n      auto prep_cnt_it = tcb.prep_cnt_map.begin();\n      while (prep_cnt_it != tcb.prep_cnt_map.end()) {\n        gatt_if = i;\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC, &gatts_data);\n        prep_cnt_it = tcb.prep_cnt_map.erase(prep_cnt_it);\n      }\n    } else {\n      for (i = 0; i < GATT_MAX_APPS; i++) {\n        if (tcb.prep_cnt[i]) {\n          gatt_if = (tGATT_IF)(i + 1);\n          conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n          tGATTS_DATA gatts_data;\n          gatts_data.exec_write = flag;\n          gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC, &gatts_data);\n          tcb.prep_cnt[i] = 0;\n        }\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    log::error(\"gatt_process_exec_write_req: no prepare write pending\");\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                 uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  log::verbose(\"\");\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  if (multi_req == nullptr) {\n    log::error(\"Could not proceed request. {}, 0x{:02x}\", tcb.peer_bda, cid);\n    return;\n  }\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rspvofr ReadMultiple: error status={}\",\n                 gatt_cb.err_status);\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code, handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag, key_size);\n      if (err != GATT_SUCCESS) {\n        log::verbose(\"read permission denied : 0x{:02x}\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    log::error(\"max attribute handle reached in ReadMultiple Request.\");\n  }\n\n  if (multi_req->num_handles == 0) {\n    err = GATT_INVALID_HANDLE;\n  }\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n      if (sr_cmd_p == nullptr) {\n        log::error(\"Could not send response on CID were request arrived. {}, 0x{:02x}\",\n                   tcb.peer_bda, cid);\n        return;\n      }\n      gatt_sr_reset_cback_cnt(tcb, cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(tcb, cid, it->p_db, op_code, handle, 0,\n                                              p_msg->attr_value.value, &p_msg->attr_value.len,\n                                              GATT_MAX_ATTR_LEN, sec_flag, key_size, trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code, GATT_SUCCESS, p_msg,\n                                  sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else {\n      err = GATT_NO_RESOURCES;\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY) {\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeValue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid,\n                                                   uint8_t op_code, uint16_t s_hdl, uint16_t e_hdl,\n                                                   uint8_t* /* p_data */, const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl || el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) {\n      continue;\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n    }\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size || handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) {\n      continue;\n    }\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle && gatt_cb.last_service_handle == el.s_hdl) {\n      log::verbose(\"Use 0xFFFF for the last primary attribute\");\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n    }\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el, BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) {\n    return GATT_NOT_FOUND;\n  }\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) {\n      break;\n    }\n\n    if (attr.handle < s_hdl) {\n      continue;\n    }\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0) {\n      p_msg->offset =\n              (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16 : GATT_INFO_TYPE_PAIR_128;\n    }\n\n    if (len < info_pair_len[p_msg->offset - 1]) {\n      return GATT_NO_RESOURCES;\n    }\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 && uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 && uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 && uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      log::error(\"format mismatch\");\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    status = GATT_SUCCESS;\n  }\n\n  return status;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl, uint16_t& e_hdl) {\n  if (len < 4) {\n    return GATT_INVALID_PDU;\n  }\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) || !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len, uint8_t*& p,\n                                                 Uuid* p_uuid, uint16_t& s_hdl, uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) {\n    return ret;\n  }\n\n  if (len < 2) {\n    return GATT_INVALID_PDU;\n  }\n\n  /* parse uuid now */\n  log::assert_that(p_uuid != nullptr, \"assert failed: p_uuid != nullptr\");\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    log::verbose(\"Bad UUID\");\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason = gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl, false);\n      log::verbose(\"unexpected ReadByGrpType Group: {}\", uuid.ToString());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    log::verbose(\"unexpected ReadByTypeValue type: {}\", uuid.ToString());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else {\n    attp_send_sr_msg(tcb, cid, p_msg);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len, uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    log::error(\"invalid MTU request PDU received.\");\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  tGATT_SR_MSG gatt_sr_msg;\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE) {\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  } else {\n    tcb.payload_size = std::min(mtu, (uint16_t)(gatt_get_local_mtu()));\n  }\n\n  /* Always say to remote our default MTU. */\n  gatt_sr_msg.mtu = gatt_get_local_mtu();\n\n  log::info(\"MTU {} request from remote ({}), resulted MTU {}\", mtu, tcb.peer_bda,\n            tcb.payload_size);\n\n  if (get_btm_client_interface().ble.BTM_SetBleDataLength(\n              tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD) != tBTM_STATUS::BTM_SUCCESS) {\n    log::warn(\"Unable to set BLE data length peer:{} mtu:{}\", tcb.peer_bda,\n              tcb.payload_size + L2CAP_PKT_OVERHEAD);\n  }\n\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg, GATT_DEF_BLE_MTU_SIZE);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  bluetooth::shim::arbiter::GetArbiter().OnIncomingMtuReq(tcb.tcb_idx, tcb.payload_size);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered application with new MTU size. Use a transaction ID */\n  /* of 0, as no response is allowed from applications */\n  if (com::android::bluetooth::flags::gatt_client_dynamic_allocation()) {\n    for (auto& [i, p_reg] : gatt_cb.cl_rcb_map) {\n      if (p_reg->in_use) {\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, p_reg->gatt_if);\n        gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n      }\n    }\n  } else {\n    for (int i = 0; i < GATT_MAX_APPS; i++) {\n      if (gatt_cb.cl_rcb[i].in_use) {\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n        gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n      }\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                           uint16_t len, uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rsp for ReadByType: error status={}\",\n                 gatt_cb.err_status);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code, s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret =\n              gatts_db_read_attr_value_by_type(tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl,\n                                               uuid, &buf_len, sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) {\n          reason = GATT_SUCCESS;\n        }\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY) {\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    }\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid, tGATT_SRV_LIST_ELEM& el,\n                                    uint16_t handle, uint8_t op_code, uint16_t len, uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        log::error(\"Prepare write request was invalid - missing offset, sending error response\");\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        log::verbose(\"Write CMD with data sigining\");\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE) {\n        sr_data.write_req.need_rsp = true;\n      }\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) {\n        len = GATT_MAX_ATTR_LEN;\n      }\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle, sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        log::error(\n                \"Attempt to write attribute that's not tied with \"\n                \"characteristic or descriptor value.\");\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      log::error(\"max pending command, send error\");\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid, tGATT_SRV_LIST_ELEM& el,\n                                   uint8_t op_code, uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    log::error(\"packet length={} too short. min={}\", len, sizeof(uint16_t));\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) {\n    STREAM_TO_UINT16(offset, p_data);\n  }\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason =\n          gatts_read_attr_value_by_handle(tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n                                          (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY) {\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n    }\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                 uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    log::error(\"Illegal PDU length, discard request\");\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rsp: error status={}\", gatt_cb.err_status);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code, handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p, attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  log::verbose(\"\");\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    log::verbose(\"NV update set srv chg = false\");\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback) {\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT, &req, NULL);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  log::verbose(\"\");\n\n  tGATT_VALUE* p_buf = (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    if (GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len, p_buf->value) !=\n        GATT_SUCCESS) {\n      log::warn(\"Unable to send GATT server handle value conn_id:{}\", p_buf->conn_id);\n    }\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  log::verbose(\"ack handle={}\", ack_handle);\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    log::error(\"unexpected handle value confirmation\");\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF, &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                         uint16_t len, uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) {\n    return false;\n  }\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS && (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH))) {\n        should_ignore = false;\n      }\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash) {\n        should_ignore = false;\n      }\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000, false);\n    }\n    log::info(\"database out of sync, device={}, op_code=0x{:x}, should_rsp={}\", tcb.peer_bda,\n              (uint16_t)op_code, should_rsp);\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) {\n    return;\n  }\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n  if (len >= payload_size) {\n    log::error(\"server receive invalid PDU size:{} pdu size:{}\", len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) {\n      return;\n    }\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}\n```",
                                    "upstream_file_tokens": {
                                        "openai": 12881,
                                        "general": {
                                            "word_based": 4299,
                                            "char_based": 12227
                                        },
                                        "gemini": 16790
                                    },
                                    "downstream_file_content": "```cc\n/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    VLOG(1) << StringPrintf(\"unexpected ReadByTypeValue type: %s\",\n                            uuid.ToString().c_str());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  uint16_t msg_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl,\n                                          e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n  uint16_t buf_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else\n    attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len,\n                                  uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0,\n                        false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    LOG(ERROR) << \"invalid MTU request PDU received.\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE)\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  else if (mtu > GATT_MAX_MTU_SIZE)\n    tcb.payload_size = GATT_MAX_MTU_SIZE;\n  else\n    tcb.payload_size = mtu;\n\n  LOG(INFO) << \"MTU request PDU with MTU size \" << +tcb.payload_size;\n\n  BTM_SetBleDataLength(tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD);\n\n  tGATT_SR_MSG gatt_sr_msg;\n  gatt_sr_msg.mtu = tcb.payload_size;\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered applicaiton with new MTU size. Us a transaction ID */\n  /* of 0, as no response is allowed from applcations                    */\n  for (int i = 0; i < GATT_MAX_APPS; i++) {\n    if (gatt_cb.cl_rcb[i].in_use) {\n      uint16_t conn_id =\n          GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n      gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n                                           uint8_t op_code, uint16_t len,\n                                           uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp for ReadByType: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret = gatts_db_read_attr_value_by_type(\n          tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl, uuid, &buf_len,\n          sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) reason = GATT_SUCCESS;\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid,\n                                    tGATT_SRV_LIST_ELEM& el, uint16_t handle,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        LOG(ERROR) << __func__\n                   << \": Prepare write request was invalid - missing offset, \"\n                      \"sending error response\";\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        VLOG(1) << \"Write CMD with data sigining\";\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE)\n        sr_data.write_req.need_rsp = true;\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) len = GATT_MAX_ATTR_LEN;\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle,\n                                       sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        LOG(ERROR) << __func__\n                   << \"%s: Attempt to write attribute that's not tied with\"\n                      \" characteristic or descriptor value.\";\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      LOG(ERROR) << \"max pending command, send error\";\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                   tGATT_SRV_LIST_ELEM& el, uint8_t op_code,\n                                   uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    LOG(ERROR) << __func__ << \": packet length=\" << len\n               << \" too short. min=\" << sizeof(uint16_t);\n    android_errorWriteWithInfoLog(0x534e4554, \"73172115\", -1, NULL, 0);\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) STREAM_TO_UINT16(offset, p_data);\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason = gatts_read_attr_value_by_handle(\n      tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n      (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    LOG(ERROR) << \"Illegal PDU length, discard request\";\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p,\n                                        attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE &&\n      op_code != GATT_SIGN_CMD_WRITE)\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  VLOG(1) << __func__;\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    VLOG(1) << \"NV update set srv chg = false\";\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback)\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT,\n                                            &req, NULL);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  VLOG(1) << __func__;\n\n  tGATT_VALUE* p_buf =\n      (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len,\n                                p_buf->value);\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  VLOG(1) << __func__ << \" ack handle=%d\" << ack_handle;\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    LOG(ERROR) << \"unexpected handle value confirmation\";\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF,\n                                  &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid,\n                                         uint8_t op_code, uint16_t len,\n                                         uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) return false;\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data,\n                                                         &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS &&\n          (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH)))\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash)\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000,\n                          false);\n    }\n    LOG(INFO) << __func__ << \": database out of sync, device=\" << tcb.peer_bda\n              << \", op_code=\" << loghex((uint16_t)op_code)\n              << \", should_rsp=\" << should_rsp;\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid,\n                                   uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) return;\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, cid);\n  if (len >= payload_size) {\n    LOG(ERROR) << StringPrintf(\"server receive invalid PDU size:%d pdu size:%d\",\n                               len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) return;\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 12368,
                                        "general": {
                                            "word_based": 4099,
                                            "char_based": 11966
                                        },
                                        "gemini": 16171
                                    }
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-347735428",
            "aliases": [
                "A-347735428",
                "CVE-2025-0081"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-347735428",
            "severity": "Critical",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "a22d1f0f07d998a53dd49a941d3a588f55b36399"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From a22d1f0f07d998a53dd49a941d3a588f55b36399 Mon Sep 17 00:00:00 2001\nFrom: Nick Chusid <nchusid@google.com>\nDate: Tue, 10 Dec 2024 22:46:28 +0000\nSubject: [PATCH] Catch null HuffmanTables when decoding jpeg\n\nBug: 347735428\nTest: TreeHugger\nChange-Id: Iaf36c076467d18e4e31d8436a6d199c3276a8786\n---\n source/dng_lossless_jpeg.cpp | 4 ++++\n 1 file changed, 4 insertions(+)\n\ndiff --git a/source/dng_lossless_jpeg.cpp b/source/dng_lossless_jpeg.cpp\nindex 9d0d01a..8802f32 100644\n--- a/source/dng_lossless_jpeg.cpp\n+++ b/source/dng_lossless_jpeg.cpp\n@@ -1616,6 +1616,10 @@ inline int32 dng_lossless_decoder::get_bit ()\n inline int32 dng_lossless_decoder::HuffDecode (HuffmanTable *htbl)\n \t{\n \t\n+\tif (htbl == nullptr) {\n+\t\tThrowBadFormat ();\n+\t}\n+\n     // If the huffman code is less than 8 bits, we can use the fast\n     // table lookup to get its value.  It's more than 8 bits about\n     // 3-4% of the time.\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 349,
                        "general": {
                            "word_based": 126,
                            "char_based": 233
                        },
                        "gemini": 453
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "ef6549c8eb3b202e8b47c41ba39d7957274aa12b",
                            "repo_path": "android_repos/dng_sdk",
                            "result": "success",
                            "downstream_patch_content": "commit ef6549c8eb3b202e8b47c41ba39d7957274aa12b\nAuthor: Nick Chusid <nchusid@google.com>\nDate:   Tue Dec 10 22:46:28 2024 +0000\n\n    Catch null HuffmanTables when decoding jpeg\n    \n    Bug: 347735428\n    Test: TreeHugger\n    Change-Id: Iaf36c076467d18e4e31d8436a6d199c3276a8786\n\ndiff --git a/source/dng_lossless_jpeg.cpp b/source/dng_lossless_jpeg.cpp\nindex 9d0d01a..8802f32 100644\n--- a/source/dng_lossless_jpeg.cpp\n+++ b/source/dng_lossless_jpeg.cpp\n@@ -1616,6 +1616,10 @@ inline int32 dng_lossless_decoder::get_bit ()\n inline int32 dng_lossless_decoder::HuffDecode (HuffmanTable *htbl)\n \t{\n \t\n+\tif (htbl == nullptr) {\n+\t\tThrowBadFormat ();\n+\t}\n+\n     // If the huffman code is less than 8 bits, we can use the fast\n     // table lookup to get its value.  It's more than 8 bits about\n     // 3-4% of the time.\n",
                            "downstream_patch_tokens": {
                                "openai": 296,
                                "general": {
                                    "word_based": 102,
                                    "char_based": 203
                                },
                                "gemini": 385
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "97cbb86f575c92ccd097407bb1fe5ad9bb532944",
                            "repo_path": "android_repos/dng_sdk",
                            "result": "success",
                            "downstream_patch_content": "commit 97cbb86f575c92ccd097407bb1fe5ad9bb532944\nAuthor: Nick Chusid <nchusid@google.com>\nDate:   Tue Dec 10 22:46:28 2024 +0000\n\n    Catch null HuffmanTables when decoding jpeg\n    \n    Bug: 347735428\n    Test: TreeHugger\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:a22d1f0f07d998a53dd49a941d3a588f55b36399)\n    Merged-In: Iaf36c076467d18e4e31d8436a6d199c3276a8786\n    Change-Id: Iaf36c076467d18e4e31d8436a6d199c3276a8786\n\ndiff --git a/source/dng_lossless_jpeg.cpp b/source/dng_lossless_jpeg.cpp\nindex 9d0d01a..8802f32 100644\n--- a/source/dng_lossless_jpeg.cpp\n+++ b/source/dng_lossless_jpeg.cpp\n@@ -1616,6 +1616,10 @@ inline int32 dng_lossless_decoder::get_bit ()\n inline int32 dng_lossless_decoder::HuffDecode (HuffmanTable *htbl)\n \t{\n \t\n+\tif (htbl == nullptr) {\n+\t\tThrowBadFormat ();\n+\t}\n+\n     // If the huffman code is less than 8 bits, we can use the fast\n     // table lookup to get its value.  It's more than 8 bits about\n     // 3-4% of the time.\n",
                            "downstream_patch_tokens": {
                                "openai": 370,
                                "general": {
                                    "word_based": 117,
                                    "char_based": 249
                                },
                                "gemini": 493
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "d125388473163ed70452c6e615b3c788805e0168",
                            "repo_path": "android_repos/dng_sdk",
                            "result": "success",
                            "downstream_patch_content": "commit d125388473163ed70452c6e615b3c788805e0168\nAuthor: Nick Chusid <nchusid@google.com>\nDate:   Tue Dec 10 22:46:28 2024 +0000\n\n    Catch null HuffmanTables when decoding jpeg\n    \n    Bug: 347735428\n    Test: TreeHugger\n    Change-Id: Iaf36c076467d18e4e31d8436a6d199c3276a8786\n\ndiff --git a/source/dng_lossless_jpeg.cpp b/source/dng_lossless_jpeg.cpp\nindex 9d0d01a..8802f32 100644\n--- a/source/dng_lossless_jpeg.cpp\n+++ b/source/dng_lossless_jpeg.cpp\n@@ -1616,6 +1616,10 @@ inline int32 dng_lossless_decoder::get_bit ()\n inline int32 dng_lossless_decoder::HuffDecode (HuffmanTable *htbl)\n \t{\n \t\n+\tif (htbl == nullptr) {\n+\t\tThrowBadFormat ();\n+\t}\n+\n     // If the huffman code is less than 8 bits, we can use the fast\n     // table lookup to get its value.  It's more than 8 bits about\n     // 3-4% of the time.\n",
                            "downstream_patch_tokens": {
                                "openai": 292,
                                "general": {
                                    "word_based": 102,
                                    "char_based": 203
                                },
                                "gemini": 388
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "89f7028f91aa2979fa88f51cdd37b6444b5cd9d9",
                            "repo_path": "android_repos/dng_sdk",
                            "result": "success",
                            "downstream_patch_content": "commit 89f7028f91aa2979fa88f51cdd37b6444b5cd9d9\nAuthor: Nick Chusid <nchusid@google.com>\nDate:   Tue Dec 10 22:46:28 2024 +0000\n\n    Catch null HuffmanTables when decoding jpeg\n    \n    Bug: 347735428\n    Test: TreeHugger\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:a22d1f0f07d998a53dd49a941d3a588f55b36399)\n    Merged-In: Iaf36c076467d18e4e31d8436a6d199c3276a8786\n    Change-Id: Iaf36c076467d18e4e31d8436a6d199c3276a8786\n\ndiff --git a/source/dng_lossless_jpeg.cpp b/source/dng_lossless_jpeg.cpp\nindex 9d0d01a..8802f32 100644\n--- a/source/dng_lossless_jpeg.cpp\n+++ b/source/dng_lossless_jpeg.cpp\n@@ -1616,6 +1616,10 @@ inline int32 dng_lossless_decoder::get_bit ()\n inline int32 dng_lossless_decoder::HuffDecode (HuffmanTable *htbl)\n \t{\n \t\n+\tif (htbl == nullptr) {\n+\t\tThrowBadFormat ();\n+\t}\n+\n     // If the huffman code is less than 8 bits, we can use the fast\n     // table lookup to get its value.  It's more than 8 bits about\n     // 3-4% of the time.\n",
                            "downstream_patch_tokens": {
                                "openai": 375,
                                "general": {
                                    "word_based": 117,
                                    "char_based": 249
                                },
                                "gemini": 497
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-368069390",
            "aliases": [
                "A-368069390",
                "CVE-2024-49729"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-368069390",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "bc067ef9f0408f3b7c4f5dcae3b6aec51f386e4d"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From bc067ef9f0408f3b7c4f5dcae3b6aec51f386e4d Mon Sep 17 00:00:00 2001\nFrom: David Anderson <dvander@google.com>\nDate: Tue, 1 Oct 2024 11:01:08 -0700\nSubject: [PATCH] libdm: Redact keys from dm-crypt targets when calling\n GetTable.\n\nIgnore-AOSP-First: security fix\nBug: 368069390\nTest: libdm_test\nChange-Id: I40b9a0129e58b1a0f116ca29f0ee66f91a27a73d\n---\n fs_mgr/libdm/dm.cpp      | 14 ++++++++++++++\n fs_mgr/libdm/dm_test.cpp | 28 ++++++++++++++++++++++++++++\n 2 files changed, 42 insertions(+)\n\ndiff --git a/fs_mgr/libdm/dm.cpp b/fs_mgr/libdm/dm.cpp\nindex a9633226f..94c320ac4 100644\n--- a/fs_mgr/libdm/dm.cpp\n+++ b/fs_mgr/libdm/dm.cpp\n@@ -551,6 +551,17 @@ bool DeviceMapper::GetTableInfo(const std::string& name, std::vector<TargetInfo>\n     return GetTable(name, DM_STATUS_TABLE_FLAG, table);\n }\n \n+void RedactTableInfo(const struct dm_target_spec& spec, std::string* data) {\n+    if (DeviceMapper::GetTargetType(spec) == \"crypt\") {\n+        auto parts = android::base::Split(*data, \" \");\n+        if (parts.size() < 2) {\n+            return;\n+        }\n+        parts[1] = \"redacted\";\n+        *data = android::base::Join(parts, \" \");\n+    }\n+}\n+\n // private methods of DeviceMapper\n bool DeviceMapper::GetTable(const std::string& name, uint32_t flags,\n                             std::vector<TargetInfo>* table) {\n@@ -589,6 +600,9 @@ bool DeviceMapper::GetTable(const std::string& name, uint32_t flags,\n             // Note: we use c_str() to eliminate any extra trailing 0s.\n             data = std::string(&buffer[data_offset], next_cursor - data_offset).c_str();\n         }\n+        if (flags & DM_STATUS_TABLE_FLAG) {\n+            RedactTableInfo(*spec, &data);\n+        }\n         table->emplace_back(*spec, data);\n         cursor = next_cursor;\n     }\ndiff --git a/fs_mgr/libdm/dm_test.cpp b/fs_mgr/libdm/dm_test.cpp\nindex b890f4715..5eddb513c 100644\n--- a/fs_mgr/libdm/dm_test.cpp\n+++ b/fs_mgr/libdm/dm_test.cpp\n@@ -814,3 +814,31 @@ TEST_F(DmTest, ThinProvisioning) {\n     TempDevice thin(\"thin\", thinTable);\n     ASSERT_TRUE(thin.valid());\n }\n+\n+TEST_F(DmTest, RedactDmCrypt) {\n+    static constexpr uint64_t kImageSize = 65536;\n+    unique_fd temp_file(CreateTempFile(\"file_1\", kImageSize));\n+    ASSERT_GE(temp_file, 0);\n+\n+    LoopDevice loop(temp_file, 10s);\n+    ASSERT_TRUE(loop.valid());\n+\n+    static constexpr const char* kAlgorithm = \"aes-cbc-essiv:sha256\";\n+    static constexpr const char* kKey = \"0e64ef514e6a1315b1f6390cb57c9e6a\";\n+\n+    auto target = std::make_unique<DmTargetCrypt>(0, kImageSize / 512, kAlgorithm, kKey, 0,\n+                                                  loop.device(), 0);\n+    target->AllowDiscards();\n+\n+    DmTable table;\n+    table.AddTarget(std::move(target));\n+\n+    auto& dm = DeviceMapper::Instance();\n+    std::string crypt_path;\n+    ASSERT_TRUE(dm.CreateDevice(test_name_, table, &crypt_path, 10s));\n+\n+    std::vector<DeviceMapper::TargetInfo> targets;\n+    ASSERT_TRUE(dm.GetTableInfo(test_name_, &targets));\n+    ASSERT_EQ(targets.size(), 1);\n+    EXPECT_EQ(targets[0].data.find(kKey), std::string::npos);\n+}\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 961,
                        "general": {
                            "word_based": 345,
                            "char_based": 775
                        },
                        "gemini": 1230
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "c434d801d65372dd12d9bc8bd7717ef08f3fa984",
                            "repo_path": "android_repos/core",
                            "result": "success",
                            "downstream_patch_content": "commit c434d801d65372dd12d9bc8bd7717ef08f3fa984\nAuthor: David Anderson <dvander@google.com>\nDate:   Tue Oct 1 11:01:08 2024 -0700\n\n    libdm: Redact keys from dm-crypt targets when calling GetTable.\n    \n    Ignore-AOSP-First: security fix\n    Bug: 368069390\n    Test: libdm_test\n    Change-Id: I40b9a0129e58b1a0f116ca29f0ee66f91a27a73d\n    Merged-In: I40b9a0129e58b1a0f116ca29f0ee66f91a27a73d\n\ndiff --git a/fs_mgr/libdm/dm.cpp b/fs_mgr/libdm/dm.cpp\nindex e43c00b44..dbee8a377 100644\n--- a/fs_mgr/libdm/dm.cpp\n+++ b/fs_mgr/libdm/dm.cpp\n@@ -494,6 +494,17 @@ bool DeviceMapper::GetTableInfo(const std::string& name, std::vector<TargetInfo>\n     return GetTable(name, DM_STATUS_TABLE_FLAG, table);\n }\n \n+void RedactTableInfo(const struct dm_target_spec& spec, std::string* data) {\n+    if (DeviceMapper::GetTargetType(spec) == \"crypt\") {\n+        auto parts = android::base::Split(*data, \" \");\n+        if (parts.size() < 2) {\n+            return;\n+        }\n+        parts[1] = \"redacted\";\n+        *data = android::base::Join(parts, \" \");\n+    }\n+}\n+\n // private methods of DeviceMapper\n bool DeviceMapper::GetTable(const std::string& name, uint32_t flags,\n                             std::vector<TargetInfo>* table) {\n@@ -532,6 +543,9 @@ bool DeviceMapper::GetTable(const std::string& name, uint32_t flags,\n             // Note: we use c_str() to eliminate any extra trailing 0s.\n             data = std::string(&buffer[data_offset], next_cursor - data_offset).c_str();\n         }\n+        if (flags & DM_STATUS_TABLE_FLAG) {\n+            RedactTableInfo(*spec, &data);\n+        }\n         table->emplace_back(*spec, data);\n         cursor = next_cursor;\n     }\n",
                            "downstream_patch_tokens": {
                                "openai": 521,
                                "general": {
                                    "word_based": 180,
                                    "char_based": 415
                                },
                                "gemini": 662
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "e68f6cd6c0a925fea1bbe7537f6029ef9b0e142c",
                            "repo_path": "android_repos/core",
                            "result": "success",
                            "downstream_patch_content": "commit e68f6cd6c0a925fea1bbe7537f6029ef9b0e142c\nAuthor: David Anderson <dvander@google.com>\nDate:   Tue Oct 1 11:01:08 2024 -0700\n\n    libdm: Redact keys from dm-crypt targets when calling GetTable.\n    \n    Ignore-AOSP-First: security fix\n    Bug: 368069390\n    Test: libdm_test\n    Change-Id: I40b9a0129e58b1a0f116ca29f0ee66f91a27a73d\n    Merged-In: I40b9a0129e58b1a0f116ca29f0ee66f91a27a73d\n\ndiff --git a/fs_mgr/libdm/dm.cpp b/fs_mgr/libdm/dm.cpp\nindex b1d5b397a..762e83c30 100644\n--- a/fs_mgr/libdm/dm.cpp\n+++ b/fs_mgr/libdm/dm.cpp\n@@ -512,6 +512,17 @@ bool DeviceMapper::GetTableInfo(const std::string& name, std::vector<TargetInfo>\n     return GetTable(name, DM_STATUS_TABLE_FLAG, table);\n }\n \n+void RedactTableInfo(const struct dm_target_spec& spec, std::string* data) {\n+    if (DeviceMapper::GetTargetType(spec) == \"crypt\") {\n+        auto parts = android::base::Split(*data, \" \");\n+        if (parts.size() < 2) {\n+            return;\n+        }\n+        parts[1] = \"redacted\";\n+        *data = android::base::Join(parts, \" \");\n+    }\n+}\n+\n // private methods of DeviceMapper\n bool DeviceMapper::GetTable(const std::string& name, uint32_t flags,\n                             std::vector<TargetInfo>* table) {\n@@ -550,6 +561,9 @@ bool DeviceMapper::GetTable(const std::string& name, uint32_t flags,\n             // Note: we use c_str() to eliminate any extra trailing 0s.\n             data = std::string(&buffer[data_offset], next_cursor - data_offset).c_str();\n         }\n+        if (flags & DM_STATUS_TABLE_FLAG) {\n+            RedactTableInfo(*spec, &data);\n+        }\n         table->emplace_back(*spec, data);\n         cursor = next_cursor;\n     }\ndiff --git a/fs_mgr/libdm/dm_test.cpp b/fs_mgr/libdm/dm_test.cpp\nindex 541f254cb..f4c9784da 100644\n--- a/fs_mgr/libdm/dm_test.cpp\n+++ b/fs_mgr/libdm/dm_test.cpp\n@@ -690,3 +690,32 @@ TEST(libdm, CreateEmptyDevice) {\n     // Empty device should be in suspended state.\n     ASSERT_EQ(DmDeviceState::SUSPENDED, dm.GetState(\"empty-device\"));\n }\n+\n+TEST(libdm, RedactDmCrypt) {\n+    static constexpr uint64_t kImageSize = 65536;\n+    static constexpr const char* kTestName = \"RedactDmCrypt\";\n+    unique_fd temp_file(CreateTempFile(\"file_1\", kImageSize));\n+    ASSERT_GE(temp_file, 0);\n+\n+    LoopDevice loop(temp_file, 10s);\n+    ASSERT_TRUE(loop.valid());\n+\n+    static constexpr const char* kAlgorithm = \"aes-cbc-essiv:sha256\";\n+    static constexpr const char* kKey = \"0e64ef514e6a1315b1f6390cb57c9e6a\";\n+\n+    auto target = std::make_unique<DmTargetCrypt>(0, kImageSize / 512, kAlgorithm, kKey, 0,\n+                                                  loop.device(), 0);\n+    target->AllowDiscards();\n+\n+    DmTable table;\n+    table.AddTarget(std::move(target));\n+\n+    auto& dm = DeviceMapper::Instance();\n+    std::string crypt_path;\n+    ASSERT_TRUE(dm.CreateDevice(kTestName, table, &crypt_path, 10s));\n+\n+    std::vector<DeviceMapper::TargetInfo> targets;\n+    ASSERT_TRUE(dm.GetTableInfo(kTestName, &targets));\n+    ASSERT_EQ(targets.size(), 1);\n+    EXPECT_EQ(targets[0].data.find(kKey), std::string::npos);\n+}\n",
                            "downstream_patch_tokens": {
                                "openai": 955,
                                "general": {
                                    "word_based": 331,
                                    "char_based": 769
                                },
                                "gemini": 1214
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "d94e6c537fd8283a33d899d627ff154cc2af2d10",
                            "repo_path": "android_repos/core",
                            "result": "success",
                            "downstream_patch_content": "commit d94e6c537fd8283a33d899d627ff154cc2af2d10\nAuthor: David Anderson <dvander@google.com>\nDate:   Tue Oct 1 11:01:08 2024 -0700\n\n    libdm: Redact keys from dm-crypt targets when calling GetTable.\n    \n    Ignore-AOSP-First: security fix\n    Bug: 368069390\n    Test: libdm_test\n    Change-Id: I40b9a0129e58b1a0f116ca29f0ee66f91a27a73d\n    Merged-In: I40b9a0129e58b1a0f116ca29f0ee66f91a27a73d\n\ndiff --git a/fs_mgr/libdm/dm.cpp b/fs_mgr/libdm/dm.cpp\nindex 4034e30ab..6da7b48b6 100644\n--- a/fs_mgr/libdm/dm.cpp\n+++ b/fs_mgr/libdm/dm.cpp\n@@ -512,6 +512,17 @@ bool DeviceMapper::GetTableInfo(const std::string& name, std::vector<TargetInfo>\n     return GetTable(name, DM_STATUS_TABLE_FLAG, table);\n }\n \n+void RedactTableInfo(const struct dm_target_spec& spec, std::string* data) {\n+    if (DeviceMapper::GetTargetType(spec) == \"crypt\") {\n+        auto parts = android::base::Split(*data, \" \");\n+        if (parts.size() < 2) {\n+            return;\n+        }\n+        parts[1] = \"redacted\";\n+        *data = android::base::Join(parts, \" \");\n+    }\n+}\n+\n // private methods of DeviceMapper\n bool DeviceMapper::GetTable(const std::string& name, uint32_t flags,\n                             std::vector<TargetInfo>* table) {\n@@ -550,6 +561,9 @@ bool DeviceMapper::GetTable(const std::string& name, uint32_t flags,\n             // Note: we use c_str() to eliminate any extra trailing 0s.\n             data = std::string(&buffer[data_offset], next_cursor - data_offset).c_str();\n         }\n+        if (flags & DM_STATUS_TABLE_FLAG) {\n+            RedactTableInfo(*spec, &data);\n+        }\n         table->emplace_back(*spec, data);\n         cursor = next_cursor;\n     }\ndiff --git a/fs_mgr/libdm/dm_test.cpp b/fs_mgr/libdm/dm_test.cpp\nindex 541f254cb..f4c9784da 100644\n--- a/fs_mgr/libdm/dm_test.cpp\n+++ b/fs_mgr/libdm/dm_test.cpp\n@@ -690,3 +690,32 @@ TEST(libdm, CreateEmptyDevice) {\n     // Empty device should be in suspended state.\n     ASSERT_EQ(DmDeviceState::SUSPENDED, dm.GetState(\"empty-device\"));\n }\n+\n+TEST(libdm, RedactDmCrypt) {\n+    static constexpr uint64_t kImageSize = 65536;\n+    static constexpr const char* kTestName = \"RedactDmCrypt\";\n+    unique_fd temp_file(CreateTempFile(\"file_1\", kImageSize));\n+    ASSERT_GE(temp_file, 0);\n+\n+    LoopDevice loop(temp_file, 10s);\n+    ASSERT_TRUE(loop.valid());\n+\n+    static constexpr const char* kAlgorithm = \"aes-cbc-essiv:sha256\";\n+    static constexpr const char* kKey = \"0e64ef514e6a1315b1f6390cb57c9e6a\";\n+\n+    auto target = std::make_unique<DmTargetCrypt>(0, kImageSize / 512, kAlgorithm, kKey, 0,\n+                                                  loop.device(), 0);\n+    target->AllowDiscards();\n+\n+    DmTable table;\n+    table.AddTarget(std::move(target));\n+\n+    auto& dm = DeviceMapper::Instance();\n+    std::string crypt_path;\n+    ASSERT_TRUE(dm.CreateDevice(kTestName, table, &crypt_path, 10s));\n+\n+    std::vector<DeviceMapper::TargetInfo> targets;\n+    ASSERT_TRUE(dm.GetTableInfo(kTestName, &targets));\n+    ASSERT_EQ(targets.size(), 1);\n+    EXPECT_EQ(targets[0].data.find(kKey), std::string::npos);\n+}\n",
                            "downstream_patch_tokens": {
                                "openai": 954,
                                "general": {
                                    "word_based": 331,
                                    "char_based": 769
                                },
                                "gemini": 1215
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "9b9233f4c1c31819fcd0fbc761f3b7ba6bd94344",
                            "repo_path": "android_repos/core",
                            "result": "success",
                            "downstream_patch_content": "commit 9b9233f4c1c31819fcd0fbc761f3b7ba6bd94344\nAuthor: David Anderson <dvander@google.com>\nDate:   Tue Oct 1 11:01:08 2024 -0700\n\n    libdm: Redact keys from dm-crypt targets when calling GetTable.\n    \n    Ignore-AOSP-First: security fix\n    Bug: 368069390\n    Test: libdm_test\n    Change-Id: I40b9a0129e58b1a0f116ca29f0ee66f91a27a73d\n    Merged-In: I40b9a0129e58b1a0f116ca29f0ee66f91a27a73d\n    (cherry picked from commit bc067ef9f0408f3b7c4f5dcae3b6aec51f386e4d)\n\ndiff --git a/fs_mgr/libdm/dm.cpp b/fs_mgr/libdm/dm.cpp\nindex 1e8c14fe2..c6f9192ae 100644\n--- a/fs_mgr/libdm/dm.cpp\n+++ b/fs_mgr/libdm/dm.cpp\n@@ -540,6 +540,17 @@ bool DeviceMapper::GetTableInfo(const std::string& name, std::vector<TargetInfo>\n     return GetTable(name, DM_STATUS_TABLE_FLAG, table);\n }\n \n+void RedactTableInfo(const struct dm_target_spec& spec, std::string* data) {\n+    if (DeviceMapper::GetTargetType(spec) == \"crypt\") {\n+        auto parts = android::base::Split(*data, \" \");\n+        if (parts.size() < 2) {\n+            return;\n+        }\n+        parts[1] = \"redacted\";\n+        *data = android::base::Join(parts, \" \");\n+    }\n+}\n+\n // private methods of DeviceMapper\n bool DeviceMapper::GetTable(const std::string& name, uint32_t flags,\n                             std::vector<TargetInfo>* table) {\n@@ -578,6 +589,9 @@ bool DeviceMapper::GetTable(const std::string& name, uint32_t flags,\n             // Note: we use c_str() to eliminate any extra trailing 0s.\n             data = std::string(&buffer[data_offset], next_cursor - data_offset).c_str();\n         }\n+        if (flags & DM_STATUS_TABLE_FLAG) {\n+            RedactTableInfo(*spec, &data);\n+        }\n         table->emplace_back(*spec, data);\n         cursor = next_cursor;\n     }\ndiff --git a/fs_mgr/libdm/dm_test.cpp b/fs_mgr/libdm/dm_test.cpp\nindex c522eafae..08edbe832 100644\n--- a/fs_mgr/libdm/dm_test.cpp\n+++ b/fs_mgr/libdm/dm_test.cpp\n@@ -757,3 +757,31 @@ TEST_F(DmTest, GetNameAndUuid) {\n     ASSERT_EQ(name, test_name_);\n     ASSERT_FALSE(uuid.empty());\n }\n+\n+TEST_F(DmTest, RedactDmCrypt) {\n+    static constexpr uint64_t kImageSize = 65536;\n+    unique_fd temp_file(CreateTempFile(\"file_1\", kImageSize));\n+    ASSERT_GE(temp_file, 0);\n+\n+    LoopDevice loop(temp_file, 10s);\n+    ASSERT_TRUE(loop.valid());\n+\n+    static constexpr const char* kAlgorithm = \"aes-cbc-essiv:sha256\";\n+    static constexpr const char* kKey = \"0e64ef514e6a1315b1f6390cb57c9e6a\";\n+\n+    auto target = std::make_unique<DmTargetCrypt>(0, kImageSize / 512, kAlgorithm, kKey, 0,\n+                                                  loop.device(), 0);\n+    target->AllowDiscards();\n+\n+    DmTable table;\n+    table.AddTarget(std::move(target));\n+\n+    auto& dm = DeviceMapper::Instance();\n+    std::string crypt_path;\n+    ASSERT_TRUE(dm.CreateDevice(test_name_, table, &crypt_path, 10s));\n+\n+    std::vector<DeviceMapper::TargetInfo> targets;\n+    ASSERT_TRUE(dm.GetTableInfo(test_name_, &targets));\n+    ASSERT_EQ(targets.size(), 1);\n+    EXPECT_EQ(targets[0].data.find(kKey), std::string::npos);\n+}\n",
                            "downstream_patch_tokens": {
                                "openai": 960,
                                "general": {
                                    "word_based": 322,
                                    "char_based": 759
                                },
                                "gemini": 1229
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-289811388",
            "aliases": [
                "A-289811388",
                "CVE-2025-0093"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-289811388",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "771aed3ea225d9ca2ef91e88f45f330ced952772"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 771aed3ea225d9ca2ef91e88f45f330ced952772 Mon Sep 17 00:00:00 2001\nFrom: Kyunglyul Hyun <klhyun@google.com>\nDate: Wed, 2 Oct 2024 03:50:00 +0000\nSubject: [PATCH] Reset permissions for not bonded device\n\nAccording to the PBAP specification,\nThe PSE user shall have to confirm at least the first Phone Book Access\nProfile connection from each new PCE.\n\nAccording to the MAP specification,\nThe MCE and MSE shall be bonded before setting up a Message Access Profile\nconnection.\n\nLet's remove the permissions when the device is unbonded.\n\nFlag: EXEMPT, security fix\nBug: 289375038\nBug: 289811388\nTest: atest BluetoothInstrumentationTests\nIgnore-AOSP-First: security fix\n\nChange-Id: I94478a4a45a434732d4bc4810da31ef45ef891af\n---\n .../com/android/bluetooth/btservice/AdapterService.java   | 8 ++++++++\n 1 file changed, 8 insertions(+)\n\ndiff --git a/android/app/src/com/android/bluetooth/btservice/AdapterService.java b/android/app/src/com/android/bluetooth/btservice/AdapterService.java\nindex 19c8aee207..3937a8e881 100644\n--- a/android/app/src/com/android/bluetooth/btservice/AdapterService.java\n+++ b/android/app/src/com/android/bluetooth/btservice/AdapterService.java\n@@ -27,6 +27,7 @@ import static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE;\n import static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n import static android.bluetooth.BluetoothAdapter.SCAN_MODE_NONE;\n import static android.bluetooth.BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n+import static android.bluetooth.BluetoothDevice.BOND_NONE;\n import static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\n import static android.bluetooth.IBluetoothLeAudio.LE_AUDIO_GROUP_ID_INVALID;\n import static android.text.format.DateUtils.MINUTE_IN_MILLIS;\n@@ -6121,6 +6122,13 @@ public class AdapterService extends Service {\n             mCsipSetCoordinatorService.handleBondStateChanged(device, fromState, toState);\n         }\n         mDatabaseManager.handleBondStateChanged(device, fromState, toState);\n+\n+        if (toState == BOND_NONE) {\n+            // Remove the permissions for unbonded devices\n+            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+        }\n     }\n \n     static int convertScanModeToHal(int mode) {\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 603,
                        "general": {
                            "word_based": 268,
                            "char_based": 608
                        },
                        "gemini": 765
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 0,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "result": "skipped",
                            "reason": "\u274c Failed to checkout branch android12-release: Command '['git', 'checkout', 'android12-release']' returned non-zero exit status 1.",
                            "downstream_patch": "e3be5a26db30094f034a543ac60e6ff5da497bd7"
                        },
                        {
                            "downstream_version": "12L",
                            "result": "skipped",
                            "reason": "\u274c Failed to checkout branch android12L-release: Command '['git', 'checkout', 'android12L-release']' returned non-zero exit status 1.",
                            "downstream_patch": "e3be5a26db30094f034a543ac60e6ff5da497bd7"
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "038b1e8626399ff3f374d5af987e3efd64a19321",
                            "repo_path": "android_repos/Bluetooth",
                            "result": "failure",
                            "downstream_patch_content": "commit 038b1e8626399ff3f374d5af987e3efd64a19321\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Thu Nov 14 00:35:48 2024 +0000\n\n    Reset permissions for not bonded device\n    \n    According to the PBAP specification,\n    The PSE user shall have to confirm at least the first Phone Book Access\n    Profile connection from each new PCE.\n    \n    According to the MAP specification,\n    The MCE and MSE shall be bonded before setting up a Message Access Profile\n    connection.\n    \n    Let's remove the permissions when the device is unbonded.\n    \n    This is a backport of change ag/30386015 but requires minor changes to\n    logic.\n    \n    Flag: EXEMPT, security fix\n    Bug: 289375038\n    Bug: 289811388\n    Test: atest BluetoothInstrumentationTests\n    Ignore-AOSP-First: security fix\n    Merged-In: I94478a4a45a434732d4bc4810da31ef45ef891af\n    Change-Id: I8b9b29310db2d14e5dfaddc81a682366fbef42d3\n\ndiff --git a/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java b/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java\nindex d62d7ba06d..1a1c912f3f 100644\n--- a/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java\n+++ b/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java\n@@ -439,6 +439,13 @@ final class BondStateMachine extends StateMachine {\n             }\n         }\n \n+        if (newState == BluetoothDevice.BOND_NONE) {\n+            // Remove the permissions for unbonded devices\n+            mAdapterService.setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            mAdapterService.setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            mAdapterService.setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+        }\n+\n         Intent intent = new Intent(BluetoothDevice.ACTION_BOND_STATE_CHANGED);\n         intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);\n         intent.putExtra(BluetoothDevice.EXTRA_BOND_STATE, newState);\n",
                            "downstream_patch_tokens": {
                                "openai": 499,
                                "general": {
                                    "word_based": 210,
                                    "char_based": 496
                                },
                                "gemini": 644
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "android/app/src/com/android/bluetooth/btservice/AdapterService.java",
                                    "total_hunks": 2,
                                    "failed_hunks": [
                                        1,
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n\n        if (toState == BOND_NONE) {\n            // Remove the permissions for unbonded devices\n            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n        }\n    }\n>>>>>>> UPSTREAM PATCH (commit 771aed3ea225d9ca2ef91e88f45f330ced952772)",
                                            "merge_conflict_tokens": {
                                                "openai": 100,
                                                "general": {
                                                    "word_based": 28,
                                                    "char_based": 115
                                                },
                                                "gemini": 129
                                            }
                                        }
                                    ],
                                    "inline_merge_token_summary": {
                                        "gemini": 1419,
                                        "openai": 1200,
                                        "general_word": 336,
                                        "general_char": 1380
                                    },
                                    "rej_file_content": "```diff\n--- android/app/src/com/android/bluetooth/btservice/AdapterService.java\n+++ android/app/src/com/android/bluetooth/btservice/AdapterService.java\n@@ -27,6 +27,7 @@ import static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE;\n import static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n import static android.bluetooth.BluetoothAdapter.SCAN_MODE_NONE;\n import static android.bluetooth.BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n+import static android.bluetooth.BluetoothDevice.BOND_NONE;\n import static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\n import static android.bluetooth.IBluetoothLeAudio.LE_AUDIO_GROUP_ID_INVALID;\n import static android.text.format.DateUtils.MINUTE_IN_MILLIS;\n@@ -6121,6 +6122,13 @@ public class AdapterService extends Service {\n             mCsipSetCoordinatorService.handleBondStateChanged(device, fromState, toState);\n         }\n         mDatabaseManager.handleBondStateChanged(device, fromState, toState);\n+\n+        if (toState == BOND_NONE) {\n+            // Remove the permissions for unbonded devices\n+            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+        }\n     }\n \n     static int convertScanModeToHal(int mode) {\n```",
                                    "rej_file_tokens": {
                                        "openai": 282,
                                        "general": {
                                            "word_based": 116,
                                            "char_based": 345
                                        },
                                        "gemini": 358
                                    },
                                    "patch_apply_output": "patching file android/app/src/com/android/bluetooth/btservice/AdapterService.java\nHunk #1 FAILED at 27.\nHunk #2 FAILED at 6121.\n2 out of 2 hunks FAILED -- saving rejects to file android/app/src/com/android/bluetooth/btservice/AdapterService.java.rej",
                                    "inline_merge_output": "patching file android/app/src/com/android/bluetooth/btservice/AdapterService.java\nHunk #1 already applied at 30.\nHunk #2 NOT MERGED at 6125-6135.",
                                    "upstream_file_content": "```java\n/*\n * Copyright (C) 2012 The Android Open Source Project\n * Copyright (C) 2016-2017 The Linux Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.bluetooth.btservice;\n\nimport static android.Manifest.permission.BLUETOOTH_CONNECT;\nimport static android.Manifest.permission.BLUETOOTH_PRIVILEGED;\nimport static android.Manifest.permission.BLUETOOTH_SCAN;\nimport static android.Manifest.permission.DUMP;\nimport static android.Manifest.permission.LOCAL_MAC_ADDRESS;\nimport static android.Manifest.permission.MODIFY_PHONE_STATE;\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE;\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_NONE;\nimport static android.bluetooth.BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\nimport static android.bluetooth.BluetoothDevice.BOND_NONE;\nimport static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\nimport static android.bluetooth.IBluetoothLeAudio.LE_AUDIO_GROUP_ID_INVALID;\nimport static android.text.format.DateUtils.MINUTE_IN_MILLIS;\nimport static android.text.format.DateUtils.SECOND_IN_MILLIS;\n\nimport static com.android.bluetooth.ChangeIds.ENFORCE_CONNECT;\nimport static com.android.bluetooth.Utils.callerIsSystem;\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveOrManagedUser;\nimport static com.android.bluetooth.Utils.getBytesFromAddress;\nimport static com.android.bluetooth.Utils.isDualModeAudioEnabled;\nimport static com.android.bluetooth.Utils.isPackageNameAccurate;\n\nimport static java.util.Objects.requireNonNull;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.RequiresPermission;\nimport android.annotation.SuppressLint;\nimport android.app.AppOpsManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.compat.CompatChanges;\nimport android.bluetooth.BluetoothA2dp;\nimport android.bluetooth.BluetoothActivityEnergyInfo;\nimport android.bluetooth.BluetoothAdapter;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceProfile;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceUse;\nimport android.bluetooth.BluetoothDevice;\nimport android.bluetooth.BluetoothFrameworkInitializer;\nimport android.bluetooth.BluetoothMap;\nimport android.bluetooth.BluetoothProfile;\nimport android.bluetooth.BluetoothProtoEnums;\nimport android.bluetooth.BluetoothQualityReport;\nimport android.bluetooth.BluetoothSap;\nimport android.bluetooth.BluetoothServerSocket;\nimport android.bluetooth.BluetoothSinkAudioPolicy;\nimport android.bluetooth.BluetoothSocket;\nimport android.bluetooth.BluetoothStatusCodes;\nimport android.bluetooth.BluetoothUtils;\nimport android.bluetooth.BluetoothUuid;\nimport android.bluetooth.BufferConstraints;\nimport android.bluetooth.IBluetooth;\nimport android.bluetooth.IBluetoothActivityEnergyInfoListener;\nimport android.bluetooth.IBluetoothCallback;\nimport android.bluetooth.IBluetoothConnectionCallback;\nimport android.bluetooth.IBluetoothMetadataListener;\nimport android.bluetooth.IBluetoothOobDataCallback;\nimport android.bluetooth.IBluetoothPreferredAudioProfilesCallback;\nimport android.bluetooth.IBluetoothQualityReportReadyCallback;\nimport android.bluetooth.IBluetoothSocketManager;\nimport android.bluetooth.IncomingRfcommSocketInfo;\nimport android.bluetooth.OobData;\nimport android.bluetooth.UidTraffic;\nimport android.bluetooth.rfcomm.BluetoothRfcommProtoEnums;\nimport android.companion.CompanionDeviceManager;\nimport android.content.AttributionSource;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.hardware.display.DisplayManager;\nimport android.os.AsyncTask;\nimport android.os.BatteryStatsManager;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelUuid;\nimport android.os.Parcelable;\nimport android.os.PowerManager;\nimport android.os.Process;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.DeviceConfig;\nimport android.provider.Settings;\nimport android.sysprop.BluetoothProperties;\nimport android.text.TextUtils;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.util.SparseArray;\n\nimport com.android.bluetooth.BluetoothMetricsProto;\nimport com.android.bluetooth.BluetoothStatsLog;\nimport com.android.bluetooth.R;\nimport com.android.bluetooth.Utils;\nimport com.android.bluetooth.a2dp.A2dpService;\nimport com.android.bluetooth.a2dpsink.A2dpSinkService;\nimport com.android.bluetooth.avrcp.AvrcpTargetService;\nimport com.android.bluetooth.avrcpcontroller.AvrcpControllerService;\nimport com.android.bluetooth.bas.BatteryService;\nimport com.android.bluetooth.bass_client.BassClientService;\nimport com.android.bluetooth.btservice.InteropUtil.InteropFeature;\nimport com.android.bluetooth.btservice.RemoteDevices.DeviceProperties;\nimport com.android.bluetooth.btservice.bluetoothkeystore.BluetoothKeystoreNativeInterface;\nimport com.android.bluetooth.btservice.bluetoothkeystore.BluetoothKeystoreService;\nimport com.android.bluetooth.btservice.storage.DatabaseManager;\nimport com.android.bluetooth.btservice.storage.MetadataDatabase;\nimport com.android.bluetooth.csip.CsipSetCoordinatorService;\nimport com.android.bluetooth.flags.Flags;\nimport com.android.bluetooth.gatt.GattService;\nimport com.android.bluetooth.hap.HapClientService;\nimport com.android.bluetooth.hearingaid.HearingAidService;\nimport com.android.bluetooth.hfp.HeadsetService;\nimport com.android.bluetooth.hfpclient.HeadsetClientService;\nimport com.android.bluetooth.hid.HidDeviceService;\nimport com.android.bluetooth.hid.HidHostService;\nimport com.android.bluetooth.le_audio.LeAudioService;\nimport com.android.bluetooth.le_scan.ScanController;\nimport com.android.bluetooth.le_scan.ScanManager;\nimport com.android.bluetooth.map.BluetoothMapService;\nimport com.android.bluetooth.mapclient.MapClientService;\nimport com.android.bluetooth.mcp.McpService;\nimport com.android.bluetooth.opp.BluetoothOppService;\nimport com.android.bluetooth.pan.PanService;\nimport com.android.bluetooth.pbap.BluetoothPbapService;\nimport com.android.bluetooth.pbapclient.PbapClientService;\nimport com.android.bluetooth.sap.SapService;\nimport com.android.bluetooth.sdp.SdpManager;\nimport com.android.bluetooth.tbs.TbsService;\nimport com.android.bluetooth.telephony.BluetoothInCallService;\nimport com.android.bluetooth.vc.VolumeControlService;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.modules.expresslog.Counter;\nimport com.android.modules.utils.BackgroundThread;\nimport com.android.modules.utils.BytesMatcher;\n\nimport libcore.util.SneakyThrow;\n\nimport com.google.common.base.Ascii;\nimport com.google.common.collect.EvictingQueue;\nimport com.google.protobuf.InvalidProtocolBufferException;\n\nimport java.io.FileDescriptor;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.time.Duration;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\npublic class AdapterService extends Service {\n    private static final String TAG = \"BluetoothAdapterService\";\n\n    private static final int MESSAGE_PROFILE_SERVICE_STATE_CHANGED = 1;\n    private static final int MESSAGE_PROFILE_SERVICE_REGISTERED = 2;\n    private static final int MESSAGE_PROFILE_SERVICE_UNREGISTERED = 3;\n    private static final int MESSAGE_PREFERRED_AUDIO_PROFILES_AUDIO_FRAMEWORK_TIMEOUT = 4;\n\n    private static final int CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS = 100;\n    private static final int MIN_ADVT_INSTANCES_FOR_MA = 5;\n    private static final int MIN_OFFLOADED_FILTERS = 10;\n    private static final int MIN_OFFLOADED_SCAN_STORAGE_BYTES = 1024;\n\n    private static final Duration PENDING_SOCKET_HANDOFF_TIMEOUT = Duration.ofMinutes(1);\n    private static final Duration GENERATE_LOCAL_OOB_DATA_TIMEOUT = Duration.ofSeconds(2);\n    private static final Duration PREFERRED_AUDIO_PROFILE_CHANGE_TIMEOUT = Duration.ofSeconds(10);\n\n    static final String PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE = \"phonebook_access_permission\";\n    static final String MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE = \"message_access_permission\";\n    static final String SIM_ACCESS_PERMISSION_PREFERENCE_FILE = \"sim_access_permission\";\n\n    private static BluetoothProperties.snoop_log_mode_values sSnoopLogSettingAtEnable =\n            BluetoothProperties.snoop_log_mode_values.EMPTY;\n    private static String sDefaultSnoopLogSettingAtEnable = \"empty\";\n    private static boolean sSnoopLogFilterHeadersSettingAtEnable = false;\n    private static boolean sSnoopLogFilterProfileA2dpSettingAtEnable = false;\n    private static boolean sSnoopLogFilterProfileRfcommSettingAtEnable = false;\n\n    private static BluetoothProperties.snoop_log_filter_profile_pbap_values\n            sSnoopLogFilterProfilePbapModeSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_pbap_values.EMPTY;\n    private static BluetoothProperties.snoop_log_filter_profile_map_values\n            sSnoopLogFilterProfileMapModeSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_map_values.EMPTY;\n\n    private static AdapterService sAdapterService;\n\n    private final Object mEnergyInfoLock = new Object();\n    private final SparseArray<UidTraffic> mUidTraffic = new SparseArray<>();\n\n    private final Map<Integer, ProfileService> mStartedProfiles = new HashMap<>();\n    private final List<ProfileService> mRegisteredProfiles = new ArrayList<>();\n    private final List<ProfileService> mRunningProfiles = new ArrayList<>();\n\n    private final List<DiscoveringPackage> mDiscoveringPackages = new ArrayList<>();\n\n    private final AdapterNativeInterface mNativeInterface = AdapterNativeInterface.getInstance();\n\n    private final Map<BluetoothDevice, RemoteCallbackList<IBluetoothMetadataListener>>\n            mMetadataListeners = new HashMap<>();\n\n    // Map<groupId, PendingAudioProfilePreferenceRequest>\n    @GuardedBy(\"mCsipGroupsPendingAudioProfileChanges\")\n    private final Map<Integer, PendingAudioProfilePreferenceRequest>\n            mCsipGroupsPendingAudioProfileChanges = new HashMap<>();\n\n    private final Map<BluetoothStateCallback, Executor> mLocalCallbacks = new ConcurrentHashMap<>();\n    private final Map<UUID, RfcommListenerData> mBluetoothServerSockets = new ConcurrentHashMap<>();\n    private final ArrayDeque<IBluetoothOobDataCallback> mOobDataCallbackQueue = new ArrayDeque<>();\n\n    private final RemoteCallbackList<IBluetoothPreferredAudioProfilesCallback>\n            mPreferredAudioProfilesCallbacks = new RemoteCallbackList<>();\n    private final RemoteCallbackList<IBluetoothQualityReportReadyCallback>\n            mBluetoothQualityReportReadyCallbacks = new RemoteCallbackList<>();\n    private final RemoteCallbackList<IBluetoothCallback> mRemoteCallbacks =\n            new RemoteCallbackList<>();\n    private final RemoteCallbackList<IBluetoothConnectionCallback> mBluetoothConnectionCallbacks =\n            new RemoteCallbackList<>();\n\n    private final EvictingQueue<String> mScanModeChanges = EvictingQueue.create(10);\n\n    private final DeviceConfigListener mDeviceConfigListener = new DeviceConfigListener();\n\n    private final Looper mLooper;\n    private final AdapterServiceHandler mHandler;\n\n    private int mStackReportedState;\n    private long mTxTimeTotalMs;\n    private long mRxTimeTotalMs;\n    private long mIdleTimeTotalMs;\n    private long mEnergyUsedTotalVoltAmpSecMicro;\n    private HashSet<String> mLeAudioAllowDevices = new HashSet<>();\n\n    private BluetoothAdapter mAdapter;\n    @VisibleForTesting AdapterProperties mAdapterProperties;\n    private AdapterState mAdapterStateMachine;\n    private BondStateMachine mBondStateMachine;\n    private RemoteDevices mRemoteDevices;\n    private AdapterSuspend mAdapterSuspend;\n\n    /* TODO: Consider to remove the search API from this class, if changed to use call-back */\n    private SdpManager mSdpManager = null;\n\n    private boolean mNativeAvailable;\n    private boolean mCleaningUp;\n    private boolean mQuietmode = false;\n    private Map<String, CallerInfo> mBondAttemptCallerInfo = new HashMap<>();\n\n    private BatteryStatsManager mBatteryStatsManager;\n    private PowerManager mPowerManager;\n    private PowerManager.WakeLock mWakeLock;\n    private UserManager mUserManager;\n    private CompanionDeviceManager mCompanionDeviceManager;\n\n    // Phone Policy is not used on all devices. Ensure you null check before using it\n    @Nullable private PhonePolicy mPhonePolicy;\n\n    private ActiveDeviceManager mActiveDeviceManager;\n    private final DatabaseManager mDatabaseManager;\n    private final SilenceDeviceManager mSilenceDeviceManager;\n    private CompanionManager mBtCompanionManager;\n    private AppOpsManager mAppOps;\n\n    private BluetoothSocketManagerBinder mBluetoothSocketManagerBinder;\n\n    private BluetoothKeystoreService mBluetoothKeystoreService;\n    private A2dpService mA2dpService;\n    private A2dpSinkService mA2dpSinkService;\n    private HeadsetService mHeadsetService;\n    private HeadsetClientService mHeadsetClientService;\n    private BluetoothMapService mMapService;\n    private MapClientService mMapClientService;\n    private HidDeviceService mHidDeviceService;\n    private HidHostService mHidHostService;\n    private PanService mPanService;\n    private BluetoothPbapService mPbapService;\n    private PbapClientService mPbapClientService;\n    private HearingAidService mHearingAidService;\n    private HapClientService mHapClientService;\n    private SapService mSapService;\n    private VolumeControlService mVolumeControlService;\n    private CsipSetCoordinatorService mCsipSetCoordinatorService;\n    private LeAudioService mLeAudioService;\n    private BassClientService mBassClientService;\n    private BatteryService mBatteryService;\n    private BluetoothQualityReportNativeInterface mBluetoothQualityReportNativeInterface;\n    private GattService mGattService;\n    private ScanController mScanController;\n\n    private volatile boolean mTestModeEnabled = false;\n\n    private MetricsLogger mMetricsLogger;\n\n    /** Handlers for incoming service calls */\n    private AdapterServiceBinder mBinder;\n\n    private volatile int mScanMode;\n\n    // Report ID definition\n    public enum BqrQualityReportId {\n        QUALITY_REPORT_ID_MONITOR_MODE(0x01),\n        QUALITY_REPORT_ID_APPROACH_LSTO(0x02),\n        QUALITY_REPORT_ID_A2DP_AUDIO_CHOPPY(0x03),\n        QUALITY_REPORT_ID_SCO_VOICE_CHOPPY(0x04),\n        QUALITY_REPORT_ID_ROOT_INFLAMMATION(0x05),\n        QUALITY_REPORT_ID_CONNECT_FAIL(0x08),\n        QUALITY_REPORT_ID_LMP_LL_MESSAGE_TRACE(0x11),\n        QUALITY_REPORT_ID_BT_SCHEDULING_TRACE(0x12),\n        QUALITY_REPORT_ID_CONTROLLER_DBG_INFO(0x13);\n\n        private final int mValue;\n\n        BqrQualityReportId(int value) {\n            mValue = value;\n        }\n\n        public int getValue() {\n            return mValue;\n        }\n    };\n\n    static {\n        if (!Flags.avoidStaticLoadingOfNative()) {\n            Log.d(TAG, \"Loading JNI Library\");\n            if (Utils.isInstrumentationTestMode()) {\n                Log.w(TAG, \"App is instrumented. Skip loading the native\");\n            } else {\n                System.loadLibrary(\"bluetooth_jni\");\n            }\n        }\n    }\n\n    // Keep a constructor for ActivityThread.handleCreateService\n    AdapterService() {\n        this(Looper.getMainLooper());\n    }\n\n    @VisibleForTesting\n    AdapterService(Looper looper) {\n        mLooper = requireNonNull(looper);\n        mHandler = new AdapterServiceHandler(mLooper);\n        mSilenceDeviceManager = new SilenceDeviceManager(this, new ServiceFactory(), mLooper);\n        mDatabaseManager = new DatabaseManager(this);\n    }\n\n    @VisibleForTesting\n    public AdapterService(Context ctx) {\n        this(Looper.getMainLooper());\n        attachBaseContext(ctx);\n    }\n\n    public static synchronized AdapterService getAdapterService() {\n        return sAdapterService;\n    }\n\n    AdapterNativeInterface getNative() {\n        return mNativeInterface;\n    }\n\n    /** Allow test to set an AdapterService to be return by AdapterService.getAdapterService() */\n    @VisibleForTesting\n    public static synchronized void setAdapterService(AdapterService instance) {\n        if (instance == null) {\n            Log.e(TAG, \"setAdapterService() - instance is null\");\n            return;\n        }\n        Log.d(TAG, \"setAdapterService() - set service to \" + instance);\n        sAdapterService = instance;\n    }\n\n    /** Clear test Adapter service. See {@code setAdapterService} */\n    @VisibleForTesting\n    public static synchronized void clearAdapterService(AdapterService instance) {\n        if (sAdapterService == instance) {\n            Log.d(TAG, \"clearAdapterService() - This adapter was cleared \" + instance);\n            sAdapterService = null;\n        } else {\n            Log.d(\n                    TAG,\n                    \"clearAdapterService() - incorrect cleared adapter.\"\n                            + (\" Instance=\" + instance)\n                            + (\" vs sAdapterService=\" + sAdapterService));\n        }\n    }\n\n    /**\n     * Register a {@link ProfileService} with AdapterService.\n     *\n     * @param profile the service being added.\n     */\n    public void addProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_REGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Unregister a ProfileService with AdapterService.\n     *\n     * @param profile the service being removed.\n     */\n    public void removeProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_UNREGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Notify AdapterService that a ProfileService has started or stopped.\n     *\n     * @param profile the service being removed.\n     * @param state {@link BluetoothAdapter#STATE_ON} or {@link BluetoothAdapter#STATE_OFF}\n     */\n    public void onProfileServiceStateChanged(ProfileService profile, int state) {\n        if (state != BluetoothAdapter.STATE_ON && state != BluetoothAdapter.STATE_OFF) {\n            throw new IllegalArgumentException(BluetoothAdapter.nameForState(state));\n        }\n        Message m = mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_STATE_CHANGED);\n        m.obj = profile;\n        m.arg1 = state;\n        mHandler.sendMessage(m);\n    }\n\n    class AdapterServiceHandler extends Handler {\n        AdapterServiceHandler(Looper looper) {\n            super(looper);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            Log.v(TAG, \"handleMessage() - Message: \" + msg.what);\n\n            switch (msg.what) {\n                case MESSAGE_PROFILE_SERVICE_STATE_CHANGED:\n                    Log.v(TAG, \"handleMessage() - MESSAGE_PROFILE_SERVICE_STATE_CHANGED\");\n                    processProfileServiceStateChanged((ProfileService) msg.obj, msg.arg1);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_REGISTERED:\n                    Log.v(TAG, \"handleMessage() - MESSAGE_PROFILE_SERVICE_REGISTERED\");\n                    registerProfileService((ProfileService) msg.obj);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_UNREGISTERED:\n                    Log.v(TAG, \"handleMessage() - MESSAGE_PROFILE_SERVICE_UNREGISTERED\");\n                    unregisterProfileService((ProfileService) msg.obj);\n                    break;\n                case MESSAGE_PREFERRED_AUDIO_PROFILES_AUDIO_FRAMEWORK_TIMEOUT:\n                    Log.e(\n                            TAG,\n                            \"handleMessage() - \"\n                                    + \"MESSAGE_PREFERRED_PROFILE_CHANGE_AUDIO_FRAMEWORK_TIMEOUT\");\n                    int groupId = (int) msg.obj;\n\n                    synchronized (mCsipGroupsPendingAudioProfileChanges) {\n                        removeFromPendingAudioProfileChanges(groupId);\n                        PendingAudioProfilePreferenceRequest request =\n                                mCsipGroupsPendingAudioProfileChanges.remove(groupId);\n                        Log.e(\n                                TAG,\n                                \"Preferred audio profiles change audio framework timeout for \"\n                                        + (\"device \" + request.mDeviceRequested));\n                        sendPreferredAudioProfilesCallbackToApps(\n                                request.mDeviceRequested,\n                                request.mRequestedPreferences,\n                                BluetoothStatusCodes.ERROR_TIMEOUT);\n                    }\n                    break;\n            }\n        }\n\n        private void registerProfileService(ProfileService profile) {\n            if (mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" already registered.\");\n                return;\n            }\n            mRegisteredProfiles.add(profile);\n        }\n\n        private void unregisterProfileService(ProfileService profile) {\n            if (!mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" not registered (UNREGISTER).\");\n                return;\n            }\n            mRegisteredProfiles.remove(profile);\n        }\n\n        private void processProfileServiceStateChanged(ProfileService profile, int state) {\n            switch (state) {\n                case BluetoothAdapter.STATE_ON:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_ON).\");\n                        return;\n                    }\n                    if (mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" already running.\");\n                        return;\n                    }\n                    mRunningProfiles.add(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT starting triggers hardware\n                    // initialization. Configuring a device without GATT causes start up failures.\n                    if (GattService.class.getSimpleName().equals(profile.getName())\n                            && !Flags.scanManagerRefactor()) {\n                        mNativeInterface.enable();\n                    } else if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                            && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n                        mAdapterProperties.onBluetoothReady();\n                        setScanMode(SCAN_MODE_CONNECTABLE, \"processProfileServiceStateChanged\");\n                        updateUuids();\n                        initProfileServices();\n                        mNativeInterface.getAdapterProperty(\n                                AbstractionLayer.BT_PROPERTY_DYNAMIC_AUDIO_BUFFER);\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n                        mBtCompanionManager.loadCompanionInfo();\n                    }\n                    break;\n                case BluetoothAdapter.STATE_OFF:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_OFF).\");\n                        return;\n                    }\n                    if (!mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not running.\");\n                        return;\n                    }\n                    mRunningProfiles.remove(profile);\n\n                    if (Flags.scanManagerRefactor()) {\n                        if (mRunningProfiles.size() == 0) {\n                            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n                        }\n                    } else {\n                        // TODO(b/228875190): GATT is assumed supported. GATT is expected to be the\n                        // only profile available in the \"BLE ON\" state. If only GATT is left, send\n                        // BREDR_STOPPED. If GATT is stopped, deinitialize the hardware.\n                        if ((mRunningProfiles.size() == 1\n                                && (GattService.class\n                                        .getSimpleName()\n                                        .equals(mRunningProfiles.get(0).getName())))) {\n                            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n                        } else if (mRunningProfiles.size() == 0) {\n                            mNativeInterface.disable();\n                        }\n                    }\n                    break;\n                default:\n                    Log.e(TAG, \"Unhandled profile state: \" + state);\n            }\n        }\n    }\n\n    /**\n     * Stores information about requests made to the audio framework arising from calls to {@link\n     * BluetoothAdapter#setPreferredAudioProfiles(BluetoothDevice, Bundle)}.\n     */\n    private static class PendingAudioProfilePreferenceRequest {\n        // The newly requested preferences\n        final Bundle mRequestedPreferences;\n        // Reference counter for how many calls are pending completion in the audio framework\n        int mRemainingRequestsToAudioFramework;\n        // The device with which the request was made. Used for sending the callback.\n        final BluetoothDevice mDeviceRequested;\n\n        /**\n         * Constructs an entity to store information about pending preferred audio profile changes.\n         *\n         * @param preferences newly requested preferences\n         * @param numRequestsToAudioFramework how many active device changed requests are sent to\n         *     the audio framework\n         * @param device the device with which the request was made\n         */\n        PendingAudioProfilePreferenceRequest(\n                Bundle preferences, int numRequestsToAudioFramework, BluetoothDevice device) {\n            mRequestedPreferences = preferences;\n            mRemainingRequestsToAudioFramework = numRequestsToAudioFramework;\n            mDeviceRequested = device;\n        }\n    }\n\n    final @NonNull <T> T getNonNullSystemService(@NonNull Class<T> clazz) {\n        return requireNonNull(getSystemService(clazz));\n    }\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        Log.d(TAG, \"onCreate()\");\n        if (!Flags.fastBindToApp()) {\n            init();\n            return;\n        }\n        // OnCreate must perform the minimum of infaillible and mandatory initialization\n        mRemoteDevices = new RemoteDevices(this, mLooper);\n        mAdapterProperties = new AdapterProperties(this);\n        mAdapterStateMachine = new AdapterState(this, mLooper);\n        mBinder = new AdapterServiceBinder(this);\n        mUserManager = getNonNullSystemService(UserManager.class);\n        mAppOps = getNonNullSystemService(AppOpsManager.class);\n        mPowerManager = getNonNullSystemService(PowerManager.class);\n        mBatteryStatsManager = getNonNullSystemService(BatteryStatsManager.class);\n        mCompanionDeviceManager = getNonNullSystemService(CompanionDeviceManager.class);\n        setAdapterService(this);\n    }\n\n    @SuppressLint(\"AndroidFrameworkRequiresPermission\")\n    private void init() {\n        Log.d(TAG, \"init()\");\n        Config.init(this);\n        initMetricsLogger();\n        mDeviceConfigListener.start();\n\n        if (!Flags.fastBindToApp()) {\n            // Moved to OnCreate\n            mUserManager = getNonNullSystemService(UserManager.class);\n            mAppOps = getNonNullSystemService(AppOpsManager.class);\n            mPowerManager = getNonNullSystemService(PowerManager.class);\n            mBatteryStatsManager = getNonNullSystemService(BatteryStatsManager.class);\n            mCompanionDeviceManager = getNonNullSystemService(CompanionDeviceManager.class);\n            mRemoteDevices = new RemoteDevices(this, mLooper);\n        }\n\n        clearDiscoveringPackages();\n        if (!Flags.fastBindToApp()) {\n            mBinder = new AdapterServiceBinder(this);\n        }\n        mAdapter = BluetoothAdapter.getDefaultAdapter();\n        if (!Flags.fastBindToApp()) {\n            // Moved to OnCreate\n            mAdapterProperties = new AdapterProperties(this);\n            mAdapterStateMachine = new AdapterState(this, mLooper);\n        }\n        boolean isCommonCriteriaMode =\n                getNonNullSystemService(DevicePolicyManager.class)\n                        .isCommonCriteriaModeEnabled(null);\n        mBluetoothKeystoreService =\n                new BluetoothKeystoreService(\n                        BluetoothKeystoreNativeInterface.getInstance(), isCommonCriteriaMode);\n        mBluetoothKeystoreService.start();\n        int configCompareResult = mBluetoothKeystoreService.getCompareResult();\n\n        // Start tracking Binder latency for the bluetooth process.\n        BluetoothFrameworkInitializer.initializeBinderCallsStats(getApplicationContext());\n\n        // Android TV doesn't show consent dialogs for just works and encryption only le pairing\n        boolean isAtvDevice =\n                getApplicationContext()\n                        .getPackageManager()\n                        .hasSystemFeature(PackageManager.FEATURE_LEANBACK_ONLY);\n        if (Flags.avoidStaticLoadingOfNative()) {\n            if (Utils.isInstrumentationTestMode()) {\n                Log.w(TAG, \"This Bluetooth App is instrumented. ** Skip loading the native **\");\n            } else {\n                Log.d(TAG, \"Loading JNI Library\");\n                System.loadLibrary(\"bluetooth_jni\");\n            }\n        }\n        mNativeInterface.init(\n                this,\n                mAdapterProperties,\n                mUserManager.isGuestUser(),\n                isCommonCriteriaMode,\n                configCompareResult,\n                isAtvDevice,\n                getApplicationInfo().dataDir);\n        mNativeAvailable = true;\n        // Load the name and address\n        mNativeInterface.getAdapterProperty(AbstractionLayer.BT_PROPERTY_BDADDR);\n        mNativeInterface.getAdapterProperty(AbstractionLayer.BT_PROPERTY_BDNAME);\n        mNativeInterface.getAdapterProperty(AbstractionLayer.BT_PROPERTY_CLASS_OF_DEVICE);\n\n        mBluetoothKeystoreService.initJni();\n\n        mBluetoothQualityReportNativeInterface =\n                requireNonNull(\n                        BluetoothQualityReportNativeInterface.getInstance(),\n                        \"BluetoothQualityReportNativeInterface cannot be null when BQR starts\");\n        mBluetoothQualityReportNativeInterface.init();\n\n        if (Flags.fastBindToApp()) {\n            mSdpManager = new SdpManager(this, mLooper);\n        } else {\n            mSdpManager = new SdpManager(this);\n        }\n\n        mDatabaseManager.start(MetadataDatabase.createDatabase(this));\n\n        boolean isAutomotiveDevice =\n                getApplicationContext()\n                        .getPackageManager()\n                        .hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);\n\n        /*\n         * Phone policy is specific to phone implementations and hence if a device wants to exclude\n         * it out then it can be disabled by using the flag below. Phone policy is never used on\n         * Android Automotive OS builds, in favor of a policy currently located in\n         * CarBluetoothService.\n         */\n        if (!isAutomotiveDevice && getResources().getBoolean(R.bool.enable_phone_policy)) {\n            Log.i(TAG, \"Phone policy enabled\");\n            mPhonePolicy = new PhonePolicy(this, new ServiceFactory());\n            mPhonePolicy.start();\n        } else {\n            Log.i(TAG, \"Phone policy disabled\");\n        }\n\n        if (Flags.audioRoutingCentralization()) {\n            mActiveDeviceManager = new AudioRoutingManager(this, new ServiceFactory());\n        } else {\n            mActiveDeviceManager = new ActiveDeviceManager(this, new ServiceFactory());\n        }\n        mActiveDeviceManager.start();\n\n        mSilenceDeviceManager.start();\n\n        mBtCompanionManager = new CompanionManager(this, new ServiceFactory());\n\n        mBluetoothSocketManagerBinder = new BluetoothSocketManagerBinder(this);\n\n        if (Flags.adapterSuspendMgmt()) {\n            mAdapterSuspend =\n                    new AdapterSuspend(\n                            mNativeInterface, mLooper, getSystemService(DisplayManager.class));\n        }\n\n        if (!Flags.fastBindToApp()) {\n            setAdapterService(this);\n        }\n\n        invalidateBluetoothCaches();\n\n        // First call to getSharedPreferences will result in a file read into\n        // memory cache. Call it here asynchronously to avoid potential ANR\n        // in the future\n        new AsyncTask<Void, Void, Void>() {\n            @Override\n            protected Void doInBackground(Void... params) {\n                getSharedPreferences(\n                        PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE, Context.MODE_PRIVATE);\n                getSharedPreferences(\n                        MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE, Context.MODE_PRIVATE);\n                getSharedPreferences(SIM_ACCESS_PERMISSION_PREFERENCE_FILE, Context.MODE_PRIVATE);\n                return null;\n            }\n        }.execute();\n\n        try {\n            int systemUiUid =\n                    getApplicationContext()\n                            .createContextAsUser(UserHandle.SYSTEM, /* flags= */ 0)\n                            .getPackageManager()\n                            .getPackageUid(\n                                    \"com.android.systemui\", PackageManager.MATCH_SYSTEM_ONLY);\n\n            Utils.setSystemUiUid(systemUiUid);\n        } catch (PackageManager.NameNotFoundException e) {\n            // Some platforms, such as wearables do not have a system ui.\n            Log.w(TAG, \"Unable to resolve SystemUI's UID.\", e);\n        }\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        Log.d(TAG, \"onBind()\");\n        return mBinder;\n    }\n\n    @Override\n    public boolean onUnbind(Intent intent) {\n        Log.d(TAG, \"onUnbind()\");\n        return super.onUnbind(intent);\n    }\n\n    @Override\n    public void onDestroy() {\n        Log.d(TAG, \"onDestroy()\");\n    }\n\n    public ActiveDeviceManager getActiveDeviceManager() {\n        return mActiveDeviceManager;\n    }\n\n    public SilenceDeviceManager getSilenceDeviceManager() {\n        return mSilenceDeviceManager;\n    }\n\n    private boolean initMetricsLogger() {\n        if (mMetricsLogger != null) {\n            return false;\n        }\n        mMetricsLogger = MetricsLogger.getInstance();\n        return mMetricsLogger.init(this);\n    }\n\n    private boolean closeMetricsLogger() {\n        if (mMetricsLogger == null) {\n            return false;\n        }\n        boolean result = mMetricsLogger.close();\n        mMetricsLogger = null;\n        return result;\n    }\n\n    /**\n     * Log L2CAP CoC Server Connection Metrics\n     *\n     * @param port port of socket\n     * @param isSecured if secured API is called\n     * @param result transaction result of the connection\n     * @param socketCreationLatencyMillis latency of the connection\n     * @param timeoutMillis timeout set by the app\n     */\n    public void logL2capcocServerConnection(\n            BluetoothDevice device,\n            int port,\n            boolean isSecured,\n            int result,\n            long socketCreationTimeMillis,\n            long socketCreationLatencyMillis,\n            long socketConnectionTimeMillis,\n            long timeoutMillis,\n            int appUid) {\n\n        int metricId = 0;\n        if (device != null) {\n            metricId = getMetricId(device);\n        }\n        long currentTime = System.currentTimeMillis();\n        long endToEndLatencyMillis = currentTime - socketCreationTimeMillis;\n        long socketAcceptanceLatencyMillis = currentTime - socketConnectionTimeMillis;\n        Log.i(\n                TAG,\n                \"Statslog L2capcoc server connection.\"\n                        + (\" metricId \" + metricId)\n                        + (\" port \" + port)\n                        + (\" isSecured \" + isSecured)\n                        + (\" result \" + result)\n                        + (\" endToEndLatencyMillis \" + endToEndLatencyMillis)\n                        + (\" socketCreationLatencyMillis \" + socketCreationLatencyMillis)\n                        + (\" socketAcceptanceLatencyMillis \" + socketAcceptanceLatencyMillis)\n                        + (\" timeout set by app \" + timeoutMillis)\n                        + (\" appUid \" + appUid));\n        BluetoothStatsLog.write(\n                BluetoothStatsLog.BLUETOOTH_L2CAP_COC_SERVER_CONNECTION,\n                metricId,\n                port,\n                isSecured,\n                result,\n                endToEndLatencyMillis,\n                timeoutMillis,\n                appUid,\n                socketCreationLatencyMillis,\n                socketAcceptanceLatencyMillis);\n    }\n\n    public void setMetricsLogger(MetricsLogger metricsLogger) {\n        mMetricsLogger = metricsLogger;\n    }\n\n    /**\n     * Log L2CAP CoC Client Connection Metrics\n     *\n     * @param device Bluetooth device\n     * @param port port of socket\n     * @param isSecured if secured API is called\n     * @param result transaction result of the connection\n     * @param socketCreationLatencyNanos latency of the connection\n     */\n    public void logL2capcocClientConnection(\n            BluetoothDevice device,\n            int port,\n            boolean isSecured,\n            int result,\n            long socketCreationTimeNanos,\n            long socketCreationLatencyNanos,\n            long socketConnectionTimeNanos,\n            int appUid) {\n\n        int metricId = getMetricId(device);\n        long currentTime = System.nanoTime();\n        long endToEndLatencyMillis = (currentTime - socketCreationTimeNanos) / 1000000;\n        long socketCreationLatencyMillis = socketCreationLatencyNanos / 1000000;\n        long socketConnectionLatencyMillis = (currentTime - socketConnectionTimeNanos) / 1000000;\n        Log.i(\n                TAG,\n                \"Statslog L2capcoc client connection.\"\n                        + (\" metricId \" + metricId)\n                        + (\" port \" + port)\n                        + (\" isSecured \" + isSecured)\n                        + (\" result \" + result)\n                        + (\" endToEndLatencyMillis \" + endToEndLatencyMillis)\n                        + (\" socketCreationLatencyMillis \" + socketCreationLatencyMillis)\n                        + (\" socketConnectionLatencyMillis \" + socketConnectionLatencyMillis)\n                        + (\" appUid \" + appUid));\n        BluetoothStatsLog.write(\n                BluetoothStatsLog.BLUETOOTH_L2CAP_COC_CLIENT_CONNECTION,\n                metricId,\n                port,\n                isSecured,\n                result,\n                endToEndLatencyMillis,\n                appUid,\n                socketCreationLatencyMillis,\n                socketConnectionLatencyMillis);\n    }\n\n    /**\n     * Log RFCOMM Connection Metrics\n     *\n     * @param device Bluetooth device\n     * @param isSecured if secured API is called\n     * @param resultCode transaction result of the connection\n     * @param isSerialPort true if service class UUID is 0x1101\n     */\n    public void logRfcommConnectionAttempt(\n            BluetoothDevice device,\n            boolean isSecured,\n            int resultCode,\n            long socketCreationTimeNanos,\n            boolean isSerialPort,\n            int appUid) {\n        int metricId = getMetricId(device);\n        long currentTime = System.nanoTime();\n        long endToEndLatencyNanos = currentTime - socketCreationTimeNanos;\n        byte[] remoteDeviceInfoBytes = MetricsLogger.getInstance().getRemoteDeviceInfoProto(device);\n        BluetoothStatsLog.write(\n                BluetoothStatsLog.BLUETOOTH_RFCOMM_CONNECTION_ATTEMPTED,\n                metricId,\n                endToEndLatencyNanos,\n                isSecured\n                        ? BluetoothRfcommProtoEnums.SOCKET_SECURITY_SECURE\n                        : BluetoothRfcommProtoEnums.SOCKET_SECURITY_INSECURE,\n                resultCode,\n                isSerialPort,\n                appUid,\n                remoteDeviceInfoBytes);\n    }\n\n    public boolean sdpSearch(BluetoothDevice device, ParcelUuid uuid) {\n        if (mSdpManager == null) {\n            return false;\n        }\n        mSdpManager.sdpSearch(device, uuid);\n        return true;\n    }\n\n    @RequiresPermission(BLUETOOTH_CONNECT)\n    void bringUpBle() {\n        Log.d(TAG, \"bleOnProcessStart()\");\n\n        if (getResources()\n                .getBoolean(R.bool.config_bluetooth_reload_supported_profiles_when_enabled)) {\n            Config.init(getApplicationContext());\n        }\n\n        // Reset |mRemoteDevices| whenever BLE is turned off then on\n        // This is to replace the fact that |mRemoteDevices| was\n        // reinitialized in previous code.\n        //\n        // TODO(apanicke): The reason is unclear but\n        // I believe it is to clear the variable every time BLE was\n        // turned off then on. The same effect can be achieved by\n        // calling cleanup but this may not be necessary at all\n        // We should figure out why this is needed later\n        mRemoteDevices.reset();\n        mAdapterProperties.init(mRemoteDevices);\n\n        Log.d(TAG, \"bleOnProcessStart() - Make Bond State Machine\");\n        mBondStateMachine = BondStateMachine.make(this, mAdapterProperties, mRemoteDevices);\n\n        mNativeInterface.getCallbacks().init(mBondStateMachine, mRemoteDevices);\n\n        mBatteryStatsManager.reportBleScanReset();\n        BluetoothStatsLog.write_non_chained(\n                BluetoothStatsLog.BLE_SCAN_STATE_CHANGED,\n                -1,\n                null,\n                BluetoothStatsLog.BLE_SCAN_STATE_CHANGED__STATE__RESET,\n                false,\n                false,\n                false);\n\n        // TODO(b/228875190): GATT is assumed supported. As a result, we don't respect the\n        // configuration sysprop. Configuring a device without GATT, although rare, will cause stack\n        // start up errors yielding init loops.\n        if (!GattService.isEnabled()) {\n            Log.w(\n                    TAG,\n                    \"GATT is configured off but the stack assumes it to be enabled. Start anyway.\");\n        }\n        if (Flags.scanManagerRefactor()) {\n            startScanController();\n        } else {\n            startGattProfileService();\n        }\n    }\n\n    void bringDownBle() {\n        if (Flags.scanManagerRefactor()) {\n            stopScanController();\n        } else {\n            stopGattProfileService();\n        }\n    }\n\n    void stateChangeCallback(int status) {\n        if (status == AbstractionLayer.BT_STATE_OFF) {\n            Log.d(TAG, \"stateChangeCallback: disableNative() completed\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        } else if (status == AbstractionLayer.BT_STATE_ON) {\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STARTED);\n        } else {\n            Log.e(TAG, \"Incorrect status \" + status + \" in stateChangeCallback\");\n        }\n    }\n\n    void startProfileServices() {\n        Log.d(TAG, \"startCoreServices()\");\n        int[] supportedProfileServices = Config.getSupportedProfiles();\n        if (Flags.scanManagerRefactor()) {\n            // Scanning is always supported, started separately, and is not a profile service.\n            // This will check other profile services.\n            if (supportedProfileServices.length == 0) {\n                mAdapterProperties.onBluetoothReady();\n                setScanMode(SCAN_MODE_CONNECTABLE, \"startProfileServices\");\n                updateUuids();\n                mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n            } else {\n                setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_ON);\n            }\n        } else {\n            // TODO(b/228875190): GATT is assumed supported. If we support no other profiles then\n            // just move on to BREDR_STARTED. Note that configuring GATT to NOT supported will cause\n            // adapter initialization failures\n            if (supportedProfileServices.length == 1\n                    && supportedProfileServices[0] == BluetoothProfile.GATT) {\n                mAdapterProperties.onBluetoothReady();\n                setScanMode(SCAN_MODE_CONNECTABLE, \"startProfileServices\");\n                updateUuids();\n                mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n            } else {\n                setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_ON);\n            }\n        }\n    }\n\n    void stopProfileServices() {\n        // Make sure to stop classic background tasks now\n        mNativeInterface.cancelDiscovery();\n        setScanMode(SCAN_MODE_NONE, \"StopProfileServices\");\n\n        int[] supportedProfileServices = Config.getSupportedProfiles();\n        if (Flags.scanManagerRefactor()) {\n            // Scanning is always supported, started separately, and is not a profile service.\n            // This will check other profile services.\n            if (supportedProfileServices.length == 0) {\n                mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n            } else {\n                setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_OFF);\n            }\n        } else {\n            // TODO(b/228875190): GATT is assumed supported. If we support no profiles then just\n            // move on to BREDR_STOPPED\n            if (supportedProfileServices.length == 1\n                    && (mRunningProfiles.size() == 1\n                            && GattService.class\n                                    .getSimpleName()\n                                    .equals(mRunningProfiles.get(0).getName()))) {\n                Log.d(\n                        TAG,\n                        \"stopProfileServices() - No profiles services to stop or already stopped.\");\n                mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n            } else {\n                setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_OFF);\n            }\n        }\n    }\n\n    private void startGattProfileService() {\n        Log.d(TAG, \"startGattProfileService() called\");\n        mGattService = new GattService(this);\n\n        mStartedProfiles.put(BluetoothProfile.GATT, mGattService);\n        addProfile(mGattService);\n        mGattService.start();\n        mGattService.setAvailable(true);\n        onProfileServiceStateChanged(mGattService, BluetoothAdapter.STATE_ON);\n    }\n\n    private void startScanController() {\n        Log.d(TAG, \"startScanController() called\");\n        mScanController = new ScanController(this);\n        mNativeInterface.enable();\n    }\n\n    private void stopGattProfileService() {\n        Log.d(TAG, \"stopGattProfileService() called\");\n        setScanMode(SCAN_MODE_NONE, \"stopGattProfileService\");\n\n        if (mRunningProfiles.size() == 0) {\n            Log.d(TAG, \"stopGattProfileService() - No profiles services to stop.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        }\n\n        mStartedProfiles.remove(BluetoothProfile.GATT);\n        if (mGattService != null) {\n            mGattService.setAvailable(false);\n            onProfileServiceStateChanged(mGattService, BluetoothAdapter.STATE_OFF);\n            mGattService.stop();\n            removeProfile(mGattService);\n            mGattService.cleanup();\n            mGattService.getBinder().cleanup();\n            mGattService = null;\n        }\n    }\n\n    private void stopScanController() {\n        Log.d(TAG, \"stopScanController() called\");\n        setScanMode(SCAN_MODE_NONE, \"stopScanController\");\n\n        if (mScanController == null) {\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        } else {\n            mScanController.stop();\n            mScanController = null;\n            mNativeInterface.disable();\n        }\n    }\n\n    private void invalidateBluetoothGetStateCache() {\n        if (Flags.getStateFromSystemServer()) {\n            // State is managed by the system server\n            return;\n        }\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n    }\n\n    void updateLeAudioProfileServiceState() {\n        Set<Integer> nonSupportedProfiles = new HashSet<>();\n\n        if (!isLeConnectedIsochronousStreamCentralSupported()) {\n            for (int profileId : Config.getLeAudioUnicastProfiles()) {\n                nonSupportedProfiles.add(profileId);\n            }\n        }\n\n        if (!isLeAudioBroadcastAssistantSupported()) {\n            nonSupportedProfiles.add(BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT);\n        }\n\n        if (!isLeAudioBroadcastSourceSupported()) {\n            Config.setProfileEnabled(BluetoothProfile.LE_AUDIO_BROADCAST, false);\n        }\n\n        // Disable the non-supported profiles service\n        for (int profileId : nonSupportedProfiles) {\n            Config.setProfileEnabled(profileId, false);\n            if (mStartedProfiles.containsKey(profileId)) {\n                setProfileServiceState(profileId, BluetoothAdapter.STATE_OFF);\n            }\n        }\n    }\n\n    void updateAdapterName(String name) {\n        int n = mRemoteCallbacks.beginBroadcast();\n        Log.d(TAG, \"updateAdapterName(\" + name + \")\");\n        for (int i = 0; i < n; i++) {\n            try {\n                mRemoteCallbacks.getBroadcastItem(i).onAdapterNameChange(name);\n            } catch (RemoteException e) {\n                Log.d(TAG, \"updateAdapterName() - Callback #\" + i + \" failed (\" + e + \")\");\n            }\n        }\n        mRemoteCallbacks.finishBroadcast();\n    }\n\n    void updateAdapterAddress(String address) {\n        int n = mRemoteCallbacks.beginBroadcast();\n        Log.d(TAG, \"updateAdapterAddress(\" + BluetoothUtils.toAnonymizedAddress(address) + \")\");\n        for (int i = 0; i < n; i++) {\n            try {\n                mRemoteCallbacks.getBroadcastItem(i).onAdapterAddressChange(address);\n            } catch (RemoteException e) {\n                Log.d(TAG, \"updateAdapterAddress() - Callback #\" + i + \" failed (\" + e + \")\");\n            }\n        }\n        mRemoteCallbacks.finishBroadcast();\n    }\n\n    void updateAdapterState(int prevState, int newState) {\n        mAdapterProperties.setState(newState);\n        invalidateBluetoothGetStateCache();\n\n        // Only BluetoothManagerService should be registered\n        int n = mRemoteCallbacks.beginBroadcast();\n        Log.d(\n                TAG,\n                \"updateAdapterState() - Broadcasting state \"\n                        + BluetoothAdapter.nameForState(newState)\n                        + \" to \"\n                        + n\n                        + \" receivers.\");\n        for (int i = 0; i < n; i++) {\n            try {\n                mRemoteCallbacks.getBroadcastItem(i).onBluetoothStateChange(prevState, newState);\n            } catch (RemoteException e) {\n                Log.d(TAG, \"updateAdapterState() - Callback #\" + i + \" failed (\" + e + \")\");\n            }\n        }\n        mRemoteCallbacks.finishBroadcast();\n\n        for (Map.Entry<BluetoothStateCallback, Executor> e : mLocalCallbacks.entrySet()) {\n            e.getValue().execute(() -> e.getKey().onBluetoothStateChange(prevState, newState));\n        }\n\n        // Turn the Adapter all the way off if we are disabling and the snoop log setting changed.\n        if (newState == BluetoothAdapter.STATE_BLE_TURNING_ON) {\n            sSnoopLogSettingAtEnable =\n                    BluetoothProperties.snoop_log_mode()\n                            .orElse(BluetoothProperties.snoop_log_mode_values.EMPTY);\n            sDefaultSnoopLogSettingAtEnable =\n                    Settings.Global.getString(\n                            getContentResolver(), Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n\n            sSnoopLogFilterHeadersSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_snoop_headers_enabled().orElse(false);\n            sSnoopLogFilterProfileA2dpSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_a2dp_enabled().orElse(false);\n            sSnoopLogFilterProfileRfcommSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_rfcomm_enabled().orElse(false);\n            sSnoopLogFilterProfilePbapModeSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_pbap()\n                            .orElse(BluetoothProperties.snoop_log_filter_profile_pbap_values.EMPTY);\n            sSnoopLogFilterProfileMapModeSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_map()\n                            .orElse(BluetoothProperties.snoop_log_filter_profile_map_values.EMPTY);\n\n            BluetoothProperties.snoop_default_mode(\n                    BluetoothProperties.snoop_default_mode_values.DISABLED);\n            for (BluetoothProperties.snoop_default_mode_values value :\n                    BluetoothProperties.snoop_default_mode_values.values()) {\n                if (value.getPropValue().equals(sDefaultSnoopLogSettingAtEnable)) {\n                    BluetoothProperties.snoop_default_mode(value);\n                }\n            }\n        } else if (newState == BluetoothAdapter.STATE_BLE_ON\n                && prevState != BluetoothAdapter.STATE_OFF) {\n            var snoopLogSetting =\n                    BluetoothProperties.snoop_log_mode()\n                            .orElse(BluetoothProperties.snoop_log_mode_values.EMPTY);\n            var snoopDefaultModeSetting =\n                    Settings.Global.getString(\n                            getContentResolver(), Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n\n            var snoopLogFilterHeadersSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_snoop_headers_enabled().orElse(false);\n            var snoopLogFilterProfileA2dpSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_a2dp_enabled().orElse(false);\n            var snoopLogFilterProfileRfcommSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_rfcomm_enabled().orElse(false);\n\n            var snoopLogFilterProfilePbapModeSetting =\n                    BluetoothProperties.snoop_log_filter_profile_pbap()\n                            .orElse(BluetoothProperties.snoop_log_filter_profile_pbap_values.EMPTY);\n            var snoopLogFilterProfileMapModeSetting =\n                    BluetoothProperties.snoop_log_filter_profile_map()\n                            .orElse(BluetoothProperties.snoop_log_filter_profile_map_values.EMPTY);\n\n            if (!(sSnoopLogSettingAtEnable == snoopLogSetting)\n                    || !(Objects.equals(sDefaultSnoopLogSettingAtEnable, snoopDefaultModeSetting))\n                    || !(sSnoopLogFilterHeadersSettingAtEnable\n                            == snoopLogFilterHeadersSettingAtEnable)\n                    || !(sSnoopLogFilterProfileA2dpSettingAtEnable\n                            == snoopLogFilterProfileA2dpSettingAtEnable)\n                    || !(sSnoopLogFilterProfileRfcommSettingAtEnable\n                            == snoopLogFilterProfileRfcommSettingAtEnable)\n                    || !(sSnoopLogFilterProfilePbapModeSettingAtEnable\n                            == snoopLogFilterProfilePbapModeSetting)\n                    || !(sSnoopLogFilterProfileMapModeSettingAtEnable\n                            == snoopLogFilterProfileMapModeSetting)) {\n                mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n            }\n        }\n    }\n\n    void linkQualityReportCallback(\n            long timestamp,\n            int reportId,\n            int rssi,\n            int snr,\n            int retransmissionCount,\n            int packetsNotReceiveCount,\n            int negativeAcknowledgementCount) {\n        BluetoothInCallService bluetoothInCallService = BluetoothInCallService.getInstance();\n\n        if (reportId == BqrQualityReportId.QUALITY_REPORT_ID_SCO_VOICE_CHOPPY.getValue()) {\n            if (bluetoothInCallService == null) {\n                Log.w(\n                        TAG,\n                        \"No BluetoothInCallService while trying to send BQR.\"\n                                + (\" timestamp: \" + timestamp)\n                                + (\" reportId: \" + reportId)\n                                + (\" rssi: \" + rssi)\n                                + (\" snr: \" + snr)\n                                + (\" retransmissionCount: \" + retransmissionCount)\n                                + (\" packetsNotReceiveCount: \" + packetsNotReceiveCount)\n                                + (\" negativeAcknowledgementCount: \"\n                                        + negativeAcknowledgementCount));\n                return;\n            }\n            bluetoothInCallService.sendBluetoothCallQualityReport(\n                    timestamp,\n                    rssi,\n                    snr,\n                    retransmissionCount,\n                    packetsNotReceiveCount,\n                    negativeAcknowledgementCount);\n        }\n    }\n\n    /**\n     * Callback from Bluetooth Quality Report Native Interface to inform the listeners about\n     * Bluetooth Quality.\n     *\n     * @param device is the BluetoothDevice which connection quality is being reported\n     * @param bluetoothQualityReport a Parcel that contains information about Bluetooth Quality\n     * @return whether the Bluetooth stack acknowledged the change successfully\n     */\n    public int bluetoothQualityReportReadyCallback(\n            BluetoothDevice device, BluetoothQualityReport bluetoothQualityReport) {\n        synchronized (mBluetoothQualityReportReadyCallbacks) {\n            int n = mBluetoothQualityReportReadyCallbacks.beginBroadcast();\n            Log.d(\n                    TAG,\n                    \"bluetoothQualityReportReadyCallback() - \"\n                            + \"Broadcasting Bluetooth Quality Report to \"\n                            + n\n                            + \" receivers.\");\n            for (int i = 0; i < n; i++) {\n                try {\n                    mBluetoothQualityReportReadyCallbacks\n                            .getBroadcastItem(i)\n                            .onBluetoothQualityReportReady(\n                                    device, bluetoothQualityReport, BluetoothStatusCodes.SUCCESS);\n                } catch (RemoteException e) {\n                    Log.d(\n                            TAG,\n                            \"bluetoothQualityReportReadyCallback() - Callback #\"\n                                    + i\n                                    + \" failed (\"\n                                    + e\n                                    + \")\");\n                }\n            }\n            mBluetoothQualityReportReadyCallbacks.finishBroadcast();\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    void switchBufferSizeCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            Log.e(\n                    TAG,\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n            return;\n        }\n\n        // Send intent to fastpair\n        Intent switchBufferSizeIntent = new Intent(BluetoothDevice.ACTION_SWITCH_BUFFER_SIZE);\n        switchBufferSizeIntent.setClassName(\n                getString(com.android.bluetooth.R.string.peripheral_link_package),\n                getString(com.android.bluetooth.R.string.peripheral_link_package)\n                        + getString(com.android.bluetooth.R.string.peripheral_link_service));\n        switchBufferSizeIntent.putExtra(BluetoothDevice.EXTRA_DEVICE, activeDevices.get(0));\n        switchBufferSizeIntent.putExtra(\n                BluetoothDevice.EXTRA_LOW_LATENCY_BUFFER_SIZE, isLowLatencyBufferSize);\n        sendBroadcastMultiplePermissions(\n                switchBufferSizeIntent,\n                new String[] {BLUETOOTH_CONNECT, BLUETOOTH_PRIVILEGED},\n                null);\n    }\n\n    void switchCodecCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            Log.e(\n                    TAG,\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n            return;\n        }\n        mA2dpService.switchCodecByBufferSize(activeDevices.get(0), isLowLatencyBufferSize);\n    }\n\n    @RequiresPermission(BLUETOOTH_CONNECT)\n    void cleanup() {\n        Log.d(TAG, \"cleanup()\");\n        if (mCleaningUp) {\n            Log.e(TAG, \"cleanup() - Service already starting to cleanup, ignoring request...\");\n            return;\n        }\n\n        closeMetricsLogger();\n\n        clearAdapterService(this);\n\n        mCleaningUp = true;\n        invalidateBluetoothCaches();\n\n        stopRfcommServerSockets();\n\n        // This wake lock release may also be called concurrently by\n        // {@link #releaseWakeLock(String lockName)}, so a synchronization is needed here.\n        synchronized (this) {\n            if (mWakeLock != null) {\n                if (mWakeLock.isHeld()) {\n                    mWakeLock.release();\n                }\n                mWakeLock = null;\n            }\n        }\n\n        mDatabaseManager.cleanup();\n\n        if (mAdapterStateMachine != null) {\n            mAdapterStateMachine.doQuit();\n        }\n\n        if (mBondStateMachine != null) {\n            mBondStateMachine.doQuit();\n        }\n\n        if (mRemoteDevices != null) {\n            mRemoteDevices.reset();\n        }\n\n        if (mSdpManager != null) {\n            mSdpManager.cleanup();\n            mSdpManager = null;\n        }\n\n        if (mNativeAvailable) {\n            Log.d(TAG, \"cleanup() - Cleaning up adapter native\");\n            mNativeInterface.cleanup();\n            mNativeAvailable = false;\n        }\n\n        if (mAdapterProperties != null) {\n            mAdapterProperties.cleanup();\n        }\n\n        if (mNativeInterface.getCallbacks() != null) {\n            mNativeInterface.getCallbacks().cleanup();\n        }\n\n        if (mBluetoothKeystoreService != null) {\n            Log.d(TAG, \"cleanup(): mBluetoothKeystoreService.cleanup()\");\n            mBluetoothKeystoreService.cleanup();\n        }\n\n        if (mPhonePolicy != null) {\n            mPhonePolicy.cleanup();\n        }\n\n        mSilenceDeviceManager.cleanup();\n\n        if (mActiveDeviceManager != null) {\n            mActiveDeviceManager.cleanup();\n        }\n\n        if (mBluetoothSocketManagerBinder != null) {\n            mBluetoothSocketManagerBinder.cleanUp();\n            mBluetoothSocketManagerBinder = null;\n        }\n\n        if (mAdapterSuspend != null) {\n            mAdapterSuspend.cleanup();\n            mAdapterSuspend = null;\n        }\n\n        mPreferredAudioProfilesCallbacks.kill();\n\n        mBluetoothQualityReportReadyCallbacks.kill();\n\n        mBluetoothConnectionCallbacks.kill();\n\n        mRemoteCallbacks.kill();\n\n        mMetadataListeners.values().forEach(v -> v.kill());\n    }\n\n    private void invalidateBluetoothCaches() {\n        BluetoothAdapter.invalidateGetProfileConnectionStateCache();\n        BluetoothAdapter.invalidateIsOffloadedFilteringSupportedCache();\n        BluetoothDevice.invalidateBluetoothGetBondStateCache();\n        if (!Flags.getStateFromSystemServer()) {\n            BluetoothAdapter.invalidateBluetoothGetStateCache();\n        }\n        BluetoothAdapter.invalidateGetAdapterConnectionStateCache();\n        BluetoothMap.invalidateBluetoothGetConnectionStateCache();\n        BluetoothSap.invalidateBluetoothGetConnectionStateCache();\n    }\n\n    private static final Map<Integer, Function<AdapterService, ProfileService>>\n            PROFILE_CONSTRUCTORS =\n                    Map.ofEntries(\n                            Map.entry(BluetoothProfile.A2DP, A2dpService::new),\n                            Map.entry(BluetoothProfile.A2DP_SINK, A2dpSinkService::new),\n                            Map.entry(BluetoothProfile.AVRCP, AvrcpTargetService::new),\n                            Map.entry(\n                                    BluetoothProfile.AVRCP_CONTROLLER, AvrcpControllerService::new),\n                            Map.entry(\n                                    BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT,\n                                    BassClientService::new),\n                            Map.entry(BluetoothProfile.BATTERY, BatteryService::new),\n                            Map.entry(\n                                    BluetoothProfile.CSIP_SET_COORDINATOR,\n                                    CsipSetCoordinatorService::new),\n                            Map.entry(BluetoothProfile.HAP_CLIENT, HapClientService::new),\n                            Map.entry(BluetoothProfile.HEADSET, HeadsetService::new),\n                            Map.entry(BluetoothProfile.HEADSET_CLIENT, HeadsetClientService::new),\n                            Map.entry(BluetoothProfile.HEARING_AID, HearingAidService::new),\n                            Map.entry(BluetoothProfile.HID_DEVICE, HidDeviceService::new),\n                            Map.entry(BluetoothProfile.HID_HOST, HidHostService::new),\n                            Map.entry(BluetoothProfile.GATT, GattService::new),\n                            Map.entry(BluetoothProfile.LE_AUDIO, LeAudioService::new),\n                            Map.entry(BluetoothProfile.LE_CALL_CONTROL, TbsService::new),\n                            Map.entry(BluetoothProfile.MAP, BluetoothMapService::new),\n                            Map.entry(BluetoothProfile.MAP_CLIENT, MapClientService::new),\n                            Map.entry(BluetoothProfile.MCP_SERVER, McpService::new),\n                            Map.entry(BluetoothProfile.OPP, BluetoothOppService::new),\n                            Map.entry(BluetoothProfile.PAN, PanService::new),\n                            Map.entry(BluetoothProfile.PBAP, BluetoothPbapService::new),\n                            Map.entry(BluetoothProfile.PBAP_CLIENT, PbapClientService::new),\n                            Map.entry(BluetoothProfile.SAP, SapService::new),\n                            Map.entry(BluetoothProfile.VOLUME_CONTROL, VolumeControlService::new));\n\n    @VisibleForTesting\n    void setProfileServiceState(int profileId, int state) {\n        if (state == BluetoothAdapter.STATE_ON) {\n            if (!mStartedProfiles.containsKey(profileId)) {\n                ProfileService profileService = PROFILE_CONSTRUCTORS.get(profileId).apply(this);\n                mStartedProfiles.put(profileId, profileService);\n                addProfile(profileService);\n                profileService.start();\n                profileService.setAvailable(true);\n                // With `Flags.scanManagerRefactor()` GattService initialization is pushed back to\n                // `ON` state instead of `BLE_ON`. Here we ensure mGattService is set prior\n                // to other Profiles using it.\n                if (profileId == BluetoothProfile.GATT && Flags.scanManagerRefactor()) {\n                    mGattService = GattService.getGattService();\n                }\n                onProfileServiceStateChanged(profileService, BluetoothAdapter.STATE_ON);\n            } else {\n                Log.e(\n                        TAG,\n                        \"setProfileServiceState(\"\n                                + BluetoothProfile.getProfileName(profileId)\n                                + \", STATE_ON): profile is already started\");\n            }\n        } else if (state == BluetoothAdapter.STATE_OFF) {\n            ProfileService profileService = mStartedProfiles.remove(profileId);\n            if (profileService != null) {\n                profileService.setAvailable(false);\n                onProfileServiceStateChanged(profileService, BluetoothAdapter.STATE_OFF);\n                profileService.stop();\n                removeProfile(profileService);\n                profileService.cleanup();\n                if (profileService.getBinder() != null) {\n                    profileService.getBinder().cleanup();\n                }\n            } else {\n                Log.e(\n                        TAG,\n                        \"setProfileServiceState(\"\n                                + BluetoothProfile.getProfileName(profileId)\n                                + \", STATE_OFF): profile is already stopped\");\n            }\n        }\n    }\n\n    private void setAllProfileServiceStates(int[] profileIds, int state) {\n        for (int profileId : profileIds) {\n            if (!Flags.scanManagerRefactor()) {\n                // TODO(b/228875190): GATT is assumed supported and treated differently as part of\n                //  the \"BLE ON\" state, despite GATT not being BLE specific.\n                if (profileId == BluetoothProfile.GATT) {\n                    continue;\n                }\n            }\n            setProfileServiceState(profileId, state);\n        }\n    }\n\n    /**\n     * Checks whether the remote device is a dual mode audio sink device (supports both classic and\n     * LE Audio sink roles.\n     *\n     * @param device the remote device\n     * @return {@code true} if it's a dual mode audio device, {@code false} otherwise\n     */\n    public boolean isDualModeAudioSinkDevice(BluetoothDevice device) {\n        if (mLeAudioService == null\n                || mLeAudioService.getGroupId(device) == LE_AUDIO_GROUP_ID_INVALID) {\n            return false;\n        }\n\n        // Check if any device in the CSIP group is a dual mode audio sink device\n        for (BluetoothDevice groupDevice :\n                mLeAudioService.getGroupDevices(mLeAudioService.getGroupId(device))) {\n            if (isProfileSupported(groupDevice, BluetoothProfile.LE_AUDIO)\n                    && (isProfileSupported(groupDevice, BluetoothProfile.HEADSET)\n                            || isProfileSupported(groupDevice, BluetoothProfile.A2DP))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the local and remote device support a connection for duplex audio (input and\n     * output) over HFP or LE Audio.\n     *\n     * @param groupDevices the devices in the CSIP group\n     * @return {@code true} if duplex is supported on the remote device, {@code false} otherwise\n     */\n    private boolean isDuplexAudioSupported(List<BluetoothDevice> groupDevices) {\n        for (BluetoothDevice device : groupDevices) {\n            if (isProfileSupported(device, BluetoothProfile.HEADSET)\n                    || (isProfileSupported(device, BluetoothProfile.LE_AUDIO)\n                            && mLeAudioService != null\n                            && mLeAudioService.isLeAudioDuplexSupported(device))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the local and remote device support a connection for output only audio over\n     * A2DP or LE Audio.\n     *\n     * @param groupDevices the devices in the CSIP group\n     * @return {@code true} if output only is supported, {@code false} otherwise\n     */\n    private boolean isOutputOnlyAudioSupported(List<BluetoothDevice> groupDevices) {\n        for (BluetoothDevice device : groupDevices) {\n            if (isProfileSupported(device, BluetoothProfile.A2DP)\n                    || (isProfileSupported(device, BluetoothProfile.LE_AUDIO)\n                            && mLeAudioService != null\n                            && mLeAudioService.isLeAudioOutputSupported(device))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Verifies whether the profile is supported by the local bluetooth adapter by checking a\n     * bitmask of its supported profiles\n     *\n     * @param device is the remote device we wish to connect to\n     * @param profile is the profile we are checking for support\n     * @return true if the profile is supported by both the local and remote device, false otherwise\n     */\n    @VisibleForTesting\n    boolean isProfileSupported(BluetoothDevice device, int profile) {\n        final ParcelUuid[] remoteDeviceUuids = getRemoteUuids(device);\n        final ParcelUuid[] localDeviceUuids = mAdapterProperties.getUuids();\n        if (remoteDeviceUuids == null || remoteDeviceUuids.length == 0) {\n            Log.e(\n                    TAG,\n                    \"isProfileSupported(\"\n                            + (\"device=\" + device)\n                            + (\", profile=\" + BluetoothProfile.getProfileName(profile) + \"):\")\n                            + \" remote device Uuids Empty\");\n        }\n\n        Log.v(\n                TAG,\n                \"isProfileSupported(\"\n                        + (\"device=\" + device)\n                        + (\", profile=\" + BluetoothProfile.getProfileName(profile) + \"):\")\n                        + (\" local_uuids=\" + Arrays.toString(localDeviceUuids))\n                        + (\", remote_uuids=\" + Arrays.toString(remoteDeviceUuids)));\n\n        if (profile == BluetoothProfile.HEADSET) {\n            return (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HSP_AG)\n                            && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HSP))\n                    || (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP_AG)\n                            && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP));\n        }\n        if (profile == BluetoothProfile.HEADSET_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP_AG)\n                    && Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP);\n        }\n        if (profile == BluetoothProfile.A2DP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SINK);\n        }\n        if (profile == BluetoothProfile.A2DP_SINK) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SOURCE);\n        }\n        if (profile == BluetoothProfile.OPP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.OBEX_OBJECT_PUSH);\n        }\n        if (profile == BluetoothProfile.HID_HOST) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HID)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HOGP)\n                    || (Flags.androidHeadtrackerService()\n                            && Utils.arrayContains(\n                                    remoteDeviceUuids, HidHostService.ANDROID_HEADTRACKER_UUID));\n        }\n        if (profile == BluetoothProfile.HID_DEVICE) {\n            return mHidDeviceService.getConnectionState(device)\n                    == BluetoothProfile.STATE_DISCONNECTED;\n        }\n        if (profile == BluetoothProfile.PAN) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.NAP);\n        }\n        if (profile == BluetoothProfile.MAP) {\n            return mMapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.PBAP) {\n            return mPbapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.MAP_CLIENT) {\n            return Utils.arrayContains(localDeviceUuids, BluetoothUuid.MNS)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.MAS);\n        }\n        if (profile == BluetoothProfile.PBAP_CLIENT) {\n            return Utils.arrayContains(localDeviceUuids, BluetoothUuid.PBAP_PCE)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.PBAP_PSE);\n        }\n        if (profile == BluetoothProfile.HEARING_AID) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HEARING_AID);\n        }\n        if (profile == BluetoothProfile.SAP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.SAP);\n        }\n        if (profile == BluetoothProfile.VOLUME_CONTROL) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.VOLUME_CONTROL);\n        }\n        if (profile == BluetoothProfile.CSIP_SET_COORDINATOR) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.COORDINATED_SET);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.LE_AUDIO);\n        }\n        if (profile == BluetoothProfile.HAP_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HAS);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BASS);\n        }\n        if (profile == BluetoothProfile.BATTERY) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BATTERY);\n        }\n\n        Log.e(TAG, \"isSupported: Unexpected profile passed in to function: \" + profile);\n        return false;\n    }\n\n    /**\n     * Checks if the connection policy of all profiles are unknown for the given device\n     *\n     * @param device is the device for which we are checking if the connection policy of all\n     *     profiles are unknown\n     * @return false if one of profile is enabled or disabled, true otherwise\n     */\n    boolean isAllProfilesUnknown(BluetoothDevice device) {\n        if (mA2dpService != null\n                && mA2dpService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mA2dpSinkService != null\n                && mA2dpSinkService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mHeadsetService != null\n                && mHeadsetService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mHeadsetClientService != null\n                && mHeadsetClientService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mMapClientService != null\n                && mMapClientService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mHidHostService != null\n                && mHidHostService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mPanService != null\n                && mPanService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mPbapClientService != null\n                && mPbapClientService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mHearingAidService != null\n                && mHearingAidService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mHapClientService != null\n                && mHapClientService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mVolumeControlService != null\n                && mVolumeControlService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mCsipSetCoordinatorService != null\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mLeAudioService != null\n                && mLeAudioService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mBassClientService != null\n                && mBassClientService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Connects only available profiles (those with {@link\n     * BluetoothProfile#CONNECTION_POLICY_ALLOWED})\n     *\n     * @param device is the device with which we are connecting the profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS}\n     */\n    private int connectEnabledProfiles(BluetoothDevice device) {\n        if (mCsipSetCoordinatorService != null\n                && isProfileSupported(device, BluetoothProfile.CSIP_SET_COORDINATOR)\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.connect(device);\n        }\n        if (mA2dpService != null\n                && isProfileSupported(device, BluetoothProfile.A2DP)\n                && mA2dpService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp\");\n            mA2dpService.connect(device);\n        }\n        if (mA2dpSinkService != null\n                && isProfileSupported(device, BluetoothProfile.A2DP_SINK)\n                && mA2dpSinkService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.connect(device);\n        }\n        if (mHeadsetService != null\n                && isProfileSupported(device, BluetoothProfile.HEADSET)\n                && mHeadsetService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Headset Profile\");\n            mHeadsetService.connect(device);\n        }\n        if (mHeadsetClientService != null\n                && isProfileSupported(device, BluetoothProfile.HEADSET_CLIENT)\n                && mHeadsetClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HFP\");\n            mHeadsetClientService.connect(device);\n        }\n        if (mMapClientService != null\n                && isProfileSupported(device, BluetoothProfile.MAP_CLIENT)\n                && mMapClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting MAP\");\n            mMapClientService.connect(device);\n        }\n        if (mHidHostService != null\n                && isProfileSupported(device, BluetoothProfile.HID_HOST)\n                && mHidHostService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hid Host Profile\");\n            mHidHostService.connect(device);\n        }\n        if (mPanService != null\n                && isProfileSupported(device, BluetoothProfile.PAN)\n                && mPanService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pan Profile\");\n            mPanService.connect(device);\n        }\n        if (mPbapClientService != null\n                && isProfileSupported(device, BluetoothProfile.PBAP_CLIENT)\n                && mPbapClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pbap\");\n            mPbapClientService.connect(device);\n        }\n        if (mHearingAidService != null\n                && isProfileSupported(device, BluetoothProfile.HEARING_AID)\n                && mHearingAidService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hearing Aid Profile\");\n            mHearingAidService.connect(device);\n        }\n        if (mHapClientService != null\n                && isProfileSupported(device, BluetoothProfile.HAP_CLIENT)\n                && mHapClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HAS Profile\");\n            mHapClientService.connect(device);\n        }\n        if (mVolumeControlService != null\n                && isProfileSupported(device, BluetoothProfile.VOLUME_CONTROL)\n                && mVolumeControlService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.connect(device);\n        }\n        if (mLeAudioService != null\n                && isProfileSupported(device, BluetoothProfile.LE_AUDIO)\n                && mLeAudioService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.connect(device);\n        }\n        if (mBassClientService != null\n                && isProfileSupported(device, BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT)\n                && mBassClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.connect(device);\n        }\n        if (mBatteryService != null\n                && isProfileSupported(device, BluetoothProfile.BATTERY)\n                && mBatteryService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Battery Service\");\n            mBatteryService.connect(device);\n        }\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Verifies that all bluetooth profile services are running\n     *\n     * @return true if all bluetooth profile services running, false otherwise\n     */\n    private boolean profileServicesRunning() {\n        if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n            return true;\n        }\n\n        Log.e(TAG, \"profileServicesRunning: One or more supported services not running\");\n        return false;\n    }\n\n    /** Initializes all the profile services fields */\n    private void initProfileServices() {\n        Log.i(TAG, \"initProfileServices: Initializing all bluetooth profile services\");\n        mA2dpService = A2dpService.getA2dpService();\n        mA2dpSinkService = A2dpSinkService.getA2dpSinkService();\n        mHeadsetService = HeadsetService.getHeadsetService();\n        mHeadsetClientService = HeadsetClientService.getHeadsetClientService();\n        mMapService = BluetoothMapService.getBluetoothMapService();\n        mMapClientService = MapClientService.getMapClientService();\n        mHidDeviceService = HidDeviceService.getHidDeviceService();\n        mHidHostService = HidHostService.getHidHostService();\n        mPanService = PanService.getPanService();\n        mPbapService = BluetoothPbapService.getBluetoothPbapService();\n        mPbapClientService = PbapClientService.getPbapClientService();\n        mHearingAidService = HearingAidService.getHearingAidService();\n        mHapClientService = HapClientService.getHapClientService();\n        mSapService = SapService.getSapService();\n        mVolumeControlService = VolumeControlService.getVolumeControlService();\n        mCsipSetCoordinatorService = CsipSetCoordinatorService.getCsipSetCoordinatorService();\n        mLeAudioService = LeAudioService.getLeAudioService();\n        mBassClientService = BassClientService.getBassClientService();\n        mBatteryService = BatteryService.getBatteryService();\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    @RequiresPermission(BLUETOOTH_CONNECT)\n    private int startRfcommListener(\n            String name, ParcelUuid uuid, PendingIntent pendingIntent, AttributionSource source) {\n        if (mBluetoothServerSockets.containsKey(uuid.getUuid())) {\n            Log.d(TAG, \"Cannot start RFCOMM listener: UUID \" + uuid.getUuid() + \"already in use.\");\n            return BluetoothStatusCodes.RFCOMM_LISTENER_START_FAILED_UUID_IN_USE;\n        }\n\n        try {\n            startRfcommListenerInternal(name, uuid.getUuid(), pendingIntent, source);\n        } catch (IOException e) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CREATE_SERVER_SOCKET;\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    @VisibleForTesting\n    int stopRfcommListener(ParcelUuid uuid, AttributionSource source) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            Log.d(TAG, \"Cannot stop RFCOMM listener: UUID \" + uuid.getUuid() + \"is not registered\");\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n        }\n\n        if (source.getUid() != listenerData.mAttributionSource.getUid()) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n        }\n\n        // Remove the entry so that it does not try and restart the server socket.\n        mBluetoothServerSockets.remove(uuid.getUuid());\n\n        return listenerData.closeServerAndPendingSockets(mHandler);\n    }\n\n    @VisibleForTesting\n    IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n            ParcelUuid uuid, AttributionSource source) {\n        IncomingRfcommSocketInfo socketInfo = new IncomingRfcommSocketInfo();\n\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            socketInfo.status =\n                    BluetoothStatusCodes\n                            .RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n            return socketInfo;\n        }\n\n        if (source.getUid() != listenerData.mAttributionSource.getUid()) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n            return socketInfo;\n        }\n\n        BluetoothSocket socket = listenerData.mPendingSockets.poll();\n\n        if (socket == null) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_NO_SOCKET_AVAILABLE;\n            return socketInfo;\n        }\n\n        mHandler.removeCallbacksAndMessages(socket);\n\n        socketInfo.bluetoothDevice = socket.getRemoteDevice();\n        socketInfo.pfd = socket.getParcelFileDescriptor();\n        socketInfo.status = BluetoothStatusCodes.SUCCESS;\n\n        return socketInfo;\n    }\n\n    @RequiresPermission(BLUETOOTH_CONNECT)\n    private void handleIncomingRfcommConnections(UUID uuid) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid);\n        while (true) {\n            BluetoothSocket socket;\n            try {\n                socket = listenerData.mServerSocket.accept();\n            } catch (IOException e) {\n                if (mBluetoothServerSockets.containsKey(uuid)) {\n                    // The uuid still being in the map indicates that the accept failure is\n                    // unexpected. Try and restart the listener.\n                    Log.e(TAG, \"Failed to accept socket on \" + listenerData.mServerSocket, e);\n                    restartRfcommListener(listenerData, uuid);\n                }\n                return;\n            }\n\n            listenerData.mPendingSockets.add(socket);\n            try {\n                listenerData.mPendingIntent.send();\n            } catch (PendingIntent.CanceledException e) {\n                Log.e(TAG, \"PendingIntent for RFCOMM socket notifications cancelled.\", e);\n                // The pending intent was cancelled, close the server as there is no longer any way\n                // to notify the app that registered the listener.\n                listenerData.closeServerAndPendingSockets(mHandler);\n                mBluetoothServerSockets.remove(uuid);\n                return;\n            }\n            mHandler.postDelayed(\n                    () -> pendingSocketTimeoutRunnable(listenerData, socket),\n                    socket,\n                    PENDING_SOCKET_HANDOFF_TIMEOUT.toMillis());\n        }\n    }\n\n    // Tries to restart the rfcomm listener for the given UUID\n    @RequiresPermission(BLUETOOTH_CONNECT)\n    private void restartRfcommListener(RfcommListenerData listenerData, UUID uuid) {\n        listenerData.closeServerAndPendingSockets(mHandler);\n        try {\n            startRfcommListenerInternal(\n                    listenerData.mName,\n                    uuid,\n                    listenerData.mPendingIntent,\n                    listenerData.mAttributionSource);\n        } catch (IOException e) {\n            Log.e(TAG, \"Failed to recreate rfcomm server socket\", e);\n\n            mBluetoothServerSockets.remove(uuid);\n        }\n    }\n\n    private void pendingSocketTimeoutRunnable(\n            RfcommListenerData listenerData, BluetoothSocket socket) {\n        boolean socketFound = listenerData.mPendingSockets.remove(socket);\n        if (socketFound) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to close bt socket\", e);\n                // We don't care if closing the socket failed, just continue on.\n            }\n        }\n    }\n\n    @RequiresPermission(BLUETOOTH_CONNECT)\n    private void startRfcommListenerInternal(\n            String name, UUID uuid, PendingIntent intent, AttributionSource source)\n            throws IOException {\n        BluetoothServerSocket bluetoothServerSocket =\n                mAdapter.listenUsingRfcommWithServiceRecord(name, uuid);\n\n        RfcommListenerData listenerData =\n                new RfcommListenerData(bluetoothServerSocket, name, intent, source);\n\n        mBluetoothServerSockets.put(uuid, listenerData);\n\n        new Thread(() -> handleIncomingRfcommConnections(uuid)).start();\n    }\n\n    private void stopRfcommServerSockets() {\n        Iterator<Map.Entry<UUID, RfcommListenerData>> socketsIterator =\n                mBluetoothServerSockets.entrySet().iterator();\n        while (socketsIterator.hasNext()) {\n            socketsIterator.next().getValue().closeServerAndPendingSockets(mHandler);\n            socketsIterator.remove();\n        }\n    }\n\n    private static class RfcommListenerData {\n        final BluetoothServerSocket mServerSocket;\n        // Service record name\n        final String mName;\n        // The Intent which contains the Service info to which the incoming socket connections are\n        // handed off to.\n        final PendingIntent mPendingIntent;\n        // AttributionSource for the requester of the RFCOMM listener\n        final AttributionSource mAttributionSource;\n        // Contains the connected sockets which are pending transfer to the app which requested the\n        // listener.\n        final ConcurrentLinkedQueue<BluetoothSocket> mPendingSockets =\n                new ConcurrentLinkedQueue<>();\n\n        RfcommListenerData(\n                BluetoothServerSocket serverSocket,\n                String name,\n                PendingIntent pendingIntent,\n                AttributionSource source) {\n            mServerSocket = serverSocket;\n            mName = name;\n            mPendingIntent = pendingIntent;\n            mAttributionSource = source;\n        }\n\n        int closeServerAndPendingSockets(Handler handler) {\n            int result = BluetoothStatusCodes.SUCCESS;\n            try {\n                mServerSocket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to call close on rfcomm server socket\", e);\n                result = BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CLOSE_SERVER_SOCKET;\n            }\n            mPendingSockets.forEach(\n                    pendingSocket -> {\n                        handler.removeCallbacksAndMessages(pendingSocket);\n                        try {\n                            pendingSocket.close();\n                        } catch (IOException e) {\n                            Log.e(TAG, \"Failed to close socket\", e);\n                        }\n                    });\n            mPendingSockets.clear();\n\n            return result;\n        }\n    }\n\n    @VisibleForTesting\n    boolean isAvailable() {\n        return !mCleaningUp;\n    }\n\n    /**\n     * Set metadata value for the given device and key\n     *\n     * @return true if metadata is set successfully\n     */\n    public boolean setMetadata(BluetoothDevice device, int key, byte[] value) {\n        if (value == null || value.length > BluetoothDevice.METADATA_MAX_LENGTH) {\n            return false;\n        }\n        return mDatabaseManager.setCustomMeta(device, key, value);\n    }\n\n    /**\n     * Get metadata of given device and key\n     *\n     * @return value of given device and key combination\n     */\n    public byte[] getMetadata(BluetoothDevice device, int key) {\n        return mDatabaseManager.getCustomMeta(device, key);\n    }\n\n    /** Update Adapter Properties when BT profiles connection state changes. */\n    public void updateProfileConnectionAdapterProperties(\n            BluetoothDevice device, int profile, int state, int prevState) {\n        mHandler.post(\n                () ->\n                        mAdapterProperties.updateOnProfileConnectionChanged(\n                                device, profile, state, prevState));\n    }\n\n    /**\n     * There is no leak of this binder since it is never re-used and the process is systematically\n     * killed\n     */\n    @VisibleForTesting\n    public static class AdapterServiceBinder extends IBluetooth.Stub {\n        private final AdapterService mService;\n\n        AdapterServiceBinder(AdapterService svc) {\n            mService = svc;\n            if (Flags.getStateFromSystemServer()) {\n                return;\n            }\n            mService.invalidateBluetoothGetStateCache();\n            BluetoothAdapter.getDefaultAdapter().disableBluetoothGetStateCache();\n        }\n\n        public AdapterService getService() {\n            if (!mService.isAvailable()) {\n                return null;\n            }\n            return mService;\n        }\n\n        @Override\n        public int getState() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_OFF;\n            }\n\n            return service.getState();\n        }\n\n        @Override\n        public void killBluetoothProcess() {\n            mService.enforceCallingPermission(BLUETOOTH_PRIVILEGED, null);\n\n            Runnable killAction =\n                    () -> {\n                        if (Flags.killInsteadOfExit()) {\n                            Log.i(TAG, \"killBluetoothProcess: Calling killProcess(myPid())\");\n                            Process.killProcess(Process.myPid());\n                        } else {\n                            Log.i(TAG, \"killBluetoothProcess: Calling System.exit\");\n                            System.exit(0);\n                        }\n                    };\n\n            // Post on the main handler to let the cleanup complete before calling exit\n            mService.mHandler.post(killAction);\n\n            try {\n                // Wait for Bluetooth to be killed from its main thread\n                Thread.sleep(1_000); // SystemServer is waiting 2000 ms, we need to wait less here\n            } catch (InterruptedException e) {\n                Log.e(TAG, \"killBluetoothProcess: Interrupted while waiting for kill\");\n            }\n\n            // Bluetooth cannot be killed on the main thread; it is in a deadLock.\n            // Trying to recover by killing the Bluetooth from the binder thread.\n            // This is bad :(\n            Counter.logIncrement(\"bluetooth.value_kill_from_binder_thread\");\n            Log.wtf(TAG, \"Failed to kill Bluetooth using its main thread. Trying from binder\");\n            killAction.run();\n        }\n\n        @Override\n        public void offToBleOn(boolean quietMode, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"offToBleOn\")) {\n                return;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.offToBleOn(quietMode);\n        }\n\n        @Override\n        public void onToBleOn(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"onToBleOn\")) {\n                return;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.onToBleOn();\n        }\n\n        @Override\n        public String getAddress(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getAddress\")) {\n                return null;\n            }\n\n            service.enforceCallingOrSelfPermission(LOCAL_MAC_ADDRESS, null);\n\n            return Utils.getAddressStringFromByte(service.mAdapterProperties.getAddress());\n        }\n\n        @Override\n        public List<ParcelUuid> getUuids(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getUuids\")) {\n                return Collections.emptyList();\n            }\n\n            ParcelUuid[] parcels = service.mAdapterProperties.getUuids();\n            if (parcels == null) {\n                parcels = new ParcelUuid[0];\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public String getIdentityAddress(String address) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getIdentityAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service,\n                            Utils.getCallingAttributionSource(mService),\n                            \"AdapterService getIdentityAddress\")) {\n                return null;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.getIdentityAddress(address);\n        }\n\n        @Override\n        public String getName(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getName\")) {\n                return null;\n            }\n\n            return service.getName();\n        }\n\n        @Override\n        public int getNameLengthForAdvertise(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getNameLengthForAdvertise\")\n                    || !Utils.checkAdvertisePermissionForDataDelivery(service, source, TAG)) {\n                return -1;\n            }\n\n            return service.getNameLengthForAdvertise();\n        }\n\n        @Override\n        public boolean setName(String name, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService setName\")) {\n                return false;\n            }\n\n            Log.d(TAG, \"AdapterServiceBinder.setName(\" + name + \")\");\n            return service.mAdapterProperties.setName(name);\n        }\n\n        @Override\n        public int getScanMode(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, source, \"AdapterService getScanMode\")) {\n                return SCAN_MODE_NONE;\n            }\n\n            return service.getScanMode();\n        }\n\n        @Override\n        public int setScanMode(int mode, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, source, \"AdapterService setScanMode\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            String logCaller = Utils.getUidPidString() + \" packageName=\" + source.getPackageName();\n            CompletableFuture<Boolean> future = new CompletableFuture<>();\n            mService.mHandler.post(\n                    () ->\n                            future.complete(\n                                    service.getState() == BluetoothAdapter.STATE_ON\n                                            && service.setScanMode(mode, logCaller)));\n            return future.join()\n                    ? BluetoothStatusCodes.SUCCESS\n                    : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public long getDiscoverableTimeout(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, source, \"AdapterService getDiscoverableTimeout\")) {\n                return -1;\n            }\n\n            return service.mAdapterProperties.getDiscoverableTimeout();\n        }\n\n        @Override\n        public int setDiscoverableTimeout(long timeout, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, source, \"AdapterService setDiscoverableTimeout\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.mAdapterProperties.setDiscoverableTimeout((int) timeout)\n                    ? BluetoothStatusCodes.SUCCESS\n                    : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public boolean startDiscovery(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"startDiscovery\")) {\n                return false;\n            }\n\n            if (!Utils.checkScanPermissionForDataDelivery(service, source, \"Starting discovery.\")) {\n                return false;\n            }\n\n            Log.i(TAG, \"startDiscovery: from \" + Utils.getUidPidString());\n            return service.startDiscovery(source);\n        }\n\n        @Override\n        public boolean cancelDiscovery(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"cancelDiscovery\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, source, \"AdapterService cancelDiscovery\")) {\n                return false;\n            }\n\n            Log.i(TAG, \"cancelDiscovery: from \" + Utils.getUidPidString());\n            return service.mNativeInterface.cancelDiscovery();\n        }\n\n        @Override\n        public boolean isDiscovering(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"isDiscovering\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, source, \"AdapterService isDiscovering\")) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isDiscovering();\n        }\n\n        @Override\n        public long getDiscoveryEndMillis(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getDiscoveryEndMillis\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return -1;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.mAdapterProperties.discoveryEndMillis();\n        }\n\n        @Override\n        public List<BluetoothDevice> getMostRecentlyConnectedDevices(AttributionSource source) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getMostRecentlyConnectedDevices\")) {\n                return Collections.emptyList();\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.mDatabaseManager.getMostRecentlyConnectedDevices();\n        }\n\n        @Override\n        public List<BluetoothDevice> getBondedDevices(AttributionSource source) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getBondedDevices\")) {\n                return Collections.emptyList();\n            }\n\n            return Arrays.asList(service.getBondedDevices());\n        }\n\n        @Override\n        public int getAdapterConnectionState() {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getConnectionState();\n        }\n\n        /**\n         * This method has an associated binder cache. The invalidation methods must be changed if\n         * the logic behind this method changes.\n         */\n        @Override\n        public int getProfileConnectionState(int profile, AttributionSource source) {\n            AdapterService service = getService();\n            boolean checkConnect = false;\n            final int callingUid = Binder.getCallingUid();\n            final long token = Binder.clearCallingIdentity();\n            try {\n                checkConnect = CompatChanges.isChangeEnabled(ENFORCE_CONNECT, callingUid);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getProfileConnectionState\")\n                    || (checkConnect\n                            && !Utils.checkConnectPermissionForDataDelivery(\n                                    service, source, \"AdapterService getProfileConnectionState\"))) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getProfileConnectionState(profile);\n        }\n\n        @Override\n        public boolean createBond(\n                BluetoothDevice device,\n                int transport,\n                OobData remoteP192Data,\n                OobData remoteP256Data,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"createBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService createBond\")) {\n                return false;\n            }\n\n            // This conditional is required to satisfy permission dependencies\n            // since createBond calls createBondOutOfBand with null value passed as data.\n            // BluetoothDevice#createBond requires BLUETOOTH_ADMIN only.\n            service.enforceBluetoothPrivilegedPermissionIfNeeded(remoteP192Data, remoteP256Data);\n\n            Log.i(\n                    TAG,\n                    \"createBond:\"\n                            + (\" device=\" + device)\n                            + (\" transport=\" + transport)\n                            + (\" from \" + Utils.getUidPidString()));\n            return service.createBond(\n                    device, transport, remoteP192Data, remoteP256Data, source.getPackageName());\n        }\n\n        @Override\n        public boolean cancelBondProcess(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"cancelBondProcess\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService cancelBondProcess\")) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            Log.i(TAG, \"cancelBondProcess: device=\" + device + \", from \" + Utils.getUidPidString());\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp != null) {\n                deviceProp.setBondingInitiatedLocally(false);\n            }\n\n            return service.mNativeInterface.cancelBond(getBytesFromAddress(device.getAddress()));\n        }\n\n        @Override\n        public boolean removeBond(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"removeBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService removeBond\")) {\n                return false;\n            }\n\n            Log.i(TAG, \"removeBond: device=\" + device + \", from \" + Utils.getUidPidString());\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || deviceProp.getBondState() != BluetoothDevice.BOND_BONDED) {\n                Log.w(\n                        TAG,\n                        device\n                                + \" cannot be removed since \"\n                                + ((deviceProp == null)\n                                        ? \"properties are empty\"\n                                        : \"bond state is \" + deviceProp.getBondState()));\n                return false;\n            }\n            service.mBondAttemptCallerInfo.remove(device.getAddress());\n            deviceProp.setBondingInitiatedLocally(false);\n\n            Message msg = service.mBondStateMachine.obtainMessage(BondStateMachine.REMOVE_BOND);\n            msg.obj = device;\n            service.mBondStateMachine.sendMessage(msg);\n            return true;\n        }\n\n        @Override\n        public int getBondState(BluetoothDevice device, AttributionSource source) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getBondState\")) {\n                return BluetoothDevice.BOND_NONE;\n            }\n\n            return service.getBondState(device);\n        }\n\n        @Override\n        public boolean isBondingInitiatedLocally(BluetoothDevice device, AttributionSource source) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService isBondingInitiatedLocally\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null && deviceProp.isBondingInitiatedLocally();\n        }\n\n        @Override\n        public void generateLocalOobData(\n                int transport, IBluetoothOobDataCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"generateLocalOobData\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            service.generateLocalOobData(transport, callback);\n        }\n\n        @Override\n        public long getSupportedProfiles(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return 0;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return Config.getSupportedProfilesBitMask();\n        }\n\n        @Override\n        public int getConnectionState(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getConnectionState\")) {\n                return BluetoothDevice.CONNECTION_STATE_DISCONNECTED;\n            }\n\n            return service.getConnectionState(device);\n        }\n\n        @Override\n        public int getConnectionHandle(\n                BluetoothDevice device, int transport, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getConnectionHandle\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothDevice.ERROR;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.getConnectionHandle(device, transport);\n        }\n\n        @Override\n        public boolean canBondWithoutDialog(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.canBondWithoutDialog(device);\n        }\n\n        @Override\n        public String getPackageNameOfBondingApplication(\n                BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.getPackageNameOfBondingApplication(device);\n        }\n\n        @Override\n        public boolean removeActiveDevice(@ActiveDeviceUse int profiles, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"removeActiveDevice\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(MODIFY_PHONE_STATE, null);\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            Log.i(\n                    TAG,\n                    \"removeActiveDevice: profiles=\"\n                            + profiles\n                            + \", from \"\n                            + Utils.getUidPidString());\n            return service.setActiveDevice(null, profiles);\n        }\n\n        @Override\n        public boolean setActiveDevice(\n                BluetoothDevice device, @ActiveDeviceUse int profiles, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setActiveDevice\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(MODIFY_PHONE_STATE, null);\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            Log.i(\n                    TAG,\n                    \"setActiveDevice: device=\"\n                            + device\n                            + \", profiles=\"\n                            + profiles\n                            + \", from \"\n                            + Utils.getUidPidString());\n\n            return service.setActiveDevice(device, profiles);\n        }\n\n        @Override\n        public List<BluetoothDevice> getActiveDevices(\n                @ActiveDeviceProfile int profile, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getActiveDevices\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return Collections.emptyList();\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.getActiveDevices(profile);\n        }\n\n        @Override\n        public int connectAllEnabledProfiles(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null || !service.isEnabled()) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(service, TAG, \"connectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            service.enforceCallingOrSelfPermission(MODIFY_PHONE_STATE, null);\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            Log.i(\n                    TAG,\n                    \"connectAllEnabledProfiles: device=\"\n                            + device\n                            + \", from \"\n                            + Utils.getUidPidString());\n            MetricsLogger.getInstance()\n                    .logBluetoothEvent(\n                            device,\n                            BluetoothStatsLog\n                                    .BLUETOOTH_CROSS_LAYER_EVENT_REPORTED__EVENT_TYPE__INITIATOR_CONNECTION,\n                            BluetoothStatsLog.BLUETOOTH_CROSS_LAYER_EVENT_REPORTED__STATE__START,\n                            source.getUid());\n\n            try {\n                return service.connectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"connectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public int disconnectAllEnabledProfiles(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(\n                    service, TAG, \"disconnectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            Log.i(\n                    TAG,\n                    \"disconnectAllEnabledProfiles: device=\"\n                            + device\n                            + \", from \"\n                            + Utils.getUidPidString());\n\n            try {\n                return service.disconnectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"disconnectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public String getRemoteName(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getRemoteName\")) {\n                return null;\n            }\n\n            return service.getRemoteName(device);\n        }\n\n        @Override\n        public int getRemoteType(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteType\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getRemoteType\")) {\n                return BluetoothDevice.DEVICE_TYPE_UNKNOWN;\n            }\n\n            return service.getRemoteType(device);\n        }\n\n        @Override\n        public String getRemoteAlias(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteAlias\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getRemoteAlias\")) {\n                return null;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null ? deviceProp.getAlias() : null;\n        }\n\n        @Override\n        public int setRemoteAlias(BluetoothDevice device, String name, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(service, TAG, \"setRemoteAlias\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (name != null && name.isEmpty()) {\n                throw new IllegalArgumentException(\"alias cannot be the empty string\");\n            }\n\n            if (!Utils.checkConnectPermissionForDataDelivery(\n                    service, source, \"AdapterService setRemoteAlias\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            Utils.enforceCdmAssociationIfNotBluetoothPrivileged(\n                    service, service.mCompanionDeviceManager, source, device);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n            }\n            deviceProp.setAlias(device, name);\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public int getRemoteClass(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteClass\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getRemoteClass\")) {\n                return 0;\n            }\n\n            return service.getRemoteClass(device);\n        }\n\n        @Override\n        public List<ParcelUuid> getRemoteUuids(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getRemoteUuids\")) {\n                return Collections.emptyList();\n            }\n\n            final ParcelUuid[] parcels = service.getRemoteUuids(device);\n            if (parcels == null) {\n                return null;\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public boolean fetchRemoteUuids(\n                BluetoothDevice device, int transport, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"fetchRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService fetchRemoteUuids\")) {\n                return false;\n            }\n            if (transport != TRANSPORT_AUTO) {\n                service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            }\n\n            Log.i(\n                    TAG,\n                    \"fetchRemoteUuids: device=\"\n                            + device\n                            + \", transport=\"\n                            + transport\n                            + \", from \"\n                            + Utils.getUidPidString());\n\n            service.mRemoteDevices.fetchUuids(device, transport);\n            MetricsLogger.getInstance().cacheCount(BluetoothProtoEnums.SDP_FETCH_UUID_REQUEST, 1);\n            return true;\n        }\n\n        @Override\n        public boolean setPin(\n                BluetoothDevice device,\n                boolean accept,\n                int len,\n                byte[] pinCode,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setPin\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService setPin\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            // Only allow setting a pin in bonding state, or bonded state in case of security\n            // upgrade.\n            if (deviceProp == null || !deviceProp.isBondingOrBonded()) {\n                Log.e(TAG, \"setPin: device=\" + device + \", not bonding\");\n                return false;\n            }\n            if (pinCode.length != len) {\n                android.util.EventLog.writeEvent(\n                        0x534e4554, \"139287605\", -1, \"PIN code length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(\n                    device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_PIN_REPLIED);\n            Log.i(\n                    TAG,\n                    \"setPin: device=\"\n                            + device\n                            + \", accept=\"\n                            + accept\n                            + \", from \"\n                            + Utils.getUidPidString());\n            return service.mNativeInterface.pinReply(\n                    getBytesFromAddress(device.getAddress()), accept, len, pinCode);\n        }\n\n        @Override\n        public boolean setPasskey(\n                BluetoothDevice device,\n                boolean accept,\n                int len,\n                byte[] passkey,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setPasskey\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService setPasskey\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                Log.e(TAG, \"setPasskey: device=\" + device + \", not bonding\");\n                return false;\n            }\n            if (passkey.length != len) {\n                android.util.EventLog.writeEvent(\n                        0x534e4554, \"139287605\", -1, \"Passkey length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(\n                    device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            Log.i(\n                    TAG,\n                    \"setPasskey: device=\"\n                            + device\n                            + \", accept=\"\n                            + accept\n                            + \", from \"\n                            + Utils.getUidPidString());\n\n            return service.mNativeInterface.sspReply(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_ENTRY,\n                    accept,\n                    Utils.byteArrayToInt(passkey));\n        }\n\n        @Override\n        public boolean setPairingConfirmation(\n                BluetoothDevice device, boolean accept, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setPairingConfirmation\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                Log.e(TAG, \"setPairingConfirmation: device=\" + device + \", not bonding\");\n                return false;\n            }\n            service.logUserBondResponse(\n                    device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            Log.i(\n                    TAG,\n                    \"setPairingConfirmation: device=\"\n                            + device\n                            + \", accept=\"\n                            + accept\n                            + \", from \"\n                            + Utils.getUidPidString());\n\n            return service.mNativeInterface.sspReply(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_CONFIRMATION,\n                    accept,\n                    0);\n        }\n\n        @Override\n        public boolean getSilenceMode(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getSilenceMode\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.mSilenceDeviceManager.getSilenceMode(device);\n        }\n\n        @Override\n        public boolean setSilenceMode(\n                BluetoothDevice device, boolean silence, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setSilenceMode\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.mSilenceDeviceManager.setSilenceMode(device, silence);\n            return true;\n        }\n\n        @Override\n        public int getPhonebookAccessPermission(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getPhonebookAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getPhonebookAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getPhonebookAccessPermission(device);\n        }\n\n        @Override\n        public boolean setPhonebookAccessPermission(\n                BluetoothDevice device, int value, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"setPhonebookAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.setPhonebookAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public int getMessageAccessPermission(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getMessageAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getMessageAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getMessageAccessPermission(device);\n        }\n\n        @Override\n        public boolean setMessageAccessPermission(\n                BluetoothDevice device, int value, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"setMessageAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.setMessageAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public int getSimAccessPermission(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getSimAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getSimAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getSimAccessPermission(device);\n        }\n\n        @Override\n        public boolean setSimAccessPermission(\n                BluetoothDevice device, int value, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setSimAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.setSimAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public void logL2capcocServerConnection(\n                BluetoothDevice device,\n                int port,\n                boolean isSecured,\n                int result,\n                long socketCreationTimeMillis,\n                long socketCreationLatencyMillis,\n                long socketConnectionTimeMillis,\n                long timeoutMillis) {\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n            service.logL2capcocServerConnection(\n                    device,\n                    port,\n                    isSecured,\n                    result,\n                    socketCreationTimeMillis,\n                    socketCreationLatencyMillis,\n                    socketConnectionTimeMillis,\n                    timeoutMillis,\n                    Binder.getCallingUid());\n        }\n\n        @Override\n        public IBluetoothSocketManager getSocketManager() {\n            AdapterService service = getService();\n            if (service == null) {\n                return null;\n            }\n\n            return IBluetoothSocketManager.Stub.asInterface(service.mBluetoothSocketManagerBinder);\n        }\n\n        @Override\n        public void logL2capcocClientConnection(\n                BluetoothDevice device,\n                int port,\n                boolean isSecured,\n                int result,\n                long socketCreationTimeNanos,\n                long socketCreationLatencyNanos,\n                long socketConnectionTimeNanos) {\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n            service.logL2capcocClientConnection(\n                    device,\n                    port,\n                    isSecured,\n                    result,\n                    socketCreationTimeNanos,\n                    socketCreationLatencyNanos,\n                    socketConnectionTimeNanos,\n                    Binder.getCallingUid());\n        }\n\n        @Override\n        public void logRfcommConnectionAttempt(\n                BluetoothDevice device,\n                boolean isSecured,\n                int resultCode,\n                long socketCreationTimeNanos,\n                boolean isSerialPort) {\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n            service.logRfcommConnectionAttempt(\n                    device,\n                    isSecured,\n                    resultCode,\n                    socketCreationTimeNanos,\n                    isSerialPort,\n                    Binder.getCallingUid());\n        }\n\n        @Override\n        public boolean sdpSearch(\n                BluetoothDevice device, ParcelUuid uuid, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"sdpSearch\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService sdpSearch\")) {\n                return false;\n            }\n            return service.sdpSearch(device, uuid);\n        }\n\n        @Override\n        public int getBatteryLevel(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getBatteryLevel\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getBatteryLevel\")) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n            return deviceProp.getBatteryLevel();\n        }\n\n        @Override\n        public int getMaxConnectedAudioDevices(AttributionSource source) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getMaxConnectedAudioDevices\")) {\n                return -1;\n            }\n\n            return service.getMaxConnectedAudioDevices();\n        }\n\n        @Override\n        public boolean factoryReset(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.factoryReset();\n        }\n\n        @Override\n        public void registerBluetoothConnectionCallback(\n                IBluetoothConnectionCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"registerBluetoothConnectionCallback\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            service.mBluetoothConnectionCallbacks.register(callback);\n        }\n\n        @Override\n        public void unregisterBluetoothConnectionCallback(\n                IBluetoothConnectionCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"unregisterBluetoothConnectionCallback\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            service.mBluetoothConnectionCallbacks.unregister(callback);\n        }\n\n        @Override\n        public void registerCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"registerCallback\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.registerRemoteCallback(callback);\n        }\n\n        @Override\n        public void unregisterCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"unregisterCallback\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.unregisterRemoteCallback(callback);\n        }\n\n        @Override\n        public boolean isMultiAdvertisementSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.mAdapterProperties.getNumOfAdvertisementInstancesSupported();\n            return val >= MIN_ADVT_INSTANCES_FOR_MA;\n        }\n\n        /**\n         * This method has an associated binder cache. The invalidation methods must be changed if\n         * the logic behind this method changes.\n         */\n        @Override\n        public boolean isOffloadedFilteringSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getNumOfOffloadedScanFilterSupported();\n            return val >= MIN_OFFLOADED_FILTERS;\n        }\n\n        @Override\n        public boolean isOffloadedScanBatchingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getOffloadedScanResultStorage();\n            return val >= MIN_OFFLOADED_SCAN_STORAGE_BYTES;\n        }\n\n        @Override\n        public boolean isLe2MPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLe2MPhySupported();\n        }\n\n        @Override\n        public boolean isLeCodedPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeCodedPhySupported();\n        }\n\n        @Override\n        public boolean isLeExtendedAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeExtendedAdvertisingSupported();\n        }\n\n        @Override\n        public boolean isLePeriodicAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLePeriodicAdvertisingSupported();\n        }\n\n        @Override\n        public int isLeAudioSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            Set<Integer> supportedProfileServices =\n                    Arrays.stream(Config.getSupportedProfiles())\n                            .boxed()\n                            .collect(Collectors.toSet());\n            int[] leAudioUnicastProfiles = Config.getLeAudioUnicastProfiles();\n\n            if (Arrays.stream(leAudioUnicastProfiles)\n                    .allMatch(supportedProfileServices::contains)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public int isLeAudioBroadcastSourceSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            long supportBitMask = Config.getSupportedProfilesBitMask();\n            if ((supportBitMask & (1 << BluetoothProfile.LE_AUDIO_BROADCAST)) != 0) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public int isLeAudioBroadcastAssistantSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            int[] supportedProfileServices = Config.getSupportedProfiles();\n\n            if (Arrays.stream(supportedProfileServices)\n                    .anyMatch(\n                            profileId ->\n                                    profileId == BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public int isDistanceMeasurementSupported(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            } else if (!callerIsSystemOrActiveOrManagedUser(\n                    service, TAG, \"isDistanceMeasurementSupported\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            } else if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return BluetoothStatusCodes.FEATURE_SUPPORTED;\n        }\n\n        @Override\n        public int getLeMaximumAdvertisingDataLength() {\n            AdapterService service = getService();\n            if (service == null) {\n                return 0;\n            }\n\n            return service.getLeMaximumAdvertisingDataLength();\n        }\n\n        @Override\n        public boolean isActivityAndEnergyReportingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isActivityAndEnergyReportingSupported();\n        }\n\n        @Override\n        public BluetoothActivityEnergyInfo reportActivityInfo(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.reportActivityInfo();\n        }\n\n        @Override\n        public boolean registerMetadataListener(\n                IBluetoothMetadataListener listener,\n                BluetoothDevice device,\n                AttributionSource source) {\n            requireNonNull(device);\n            requireNonNull(listener);\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"registerMetadataListener\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.mHandler.post(\n                    () ->\n                            service.mMetadataListeners\n                                    .computeIfAbsent(device, k -> new RemoteCallbackList())\n                                    .register(listener));\n\n            return true;\n        }\n\n        @Override\n        public boolean unregisterMetadataListener(\n                IBluetoothMetadataListener listener,\n                BluetoothDevice device,\n                AttributionSource source) {\n            requireNonNull(device);\n            requireNonNull(listener);\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"unregisterMetadataListener\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.mHandler.post(\n                    () ->\n                            service.mMetadataListeners.computeIfPresent(\n                                    device,\n                                    (k, v) -> {\n                                        v.unregister(listener);\n                                        if (v.getRegisteredCallbackCount() == 0) {\n                                            return null;\n                                        }\n                                        return v;\n                                    }));\n            return true;\n        }\n\n        @Override\n        public boolean setMetadata(\n                BluetoothDevice device, int key, byte[] value, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setMetadata\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.setMetadata(device, key, value);\n        }\n\n        @Override\n        public byte[] getMetadata(BluetoothDevice device, int key, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getMetadata\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.getMetadata(device, key);\n        }\n\n        @Override\n        public int isRequestAudioPolicyAsSinkSupported(\n                BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"isRequestAudioPolicyAsSinkSupported\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.FEATURE_NOT_CONFIGURED;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.isRequestAudioPolicyAsSinkSupported(device);\n        }\n\n        @Override\n        public int requestAudioPolicyAsSink(\n                BluetoothDevice device,\n                BluetoothSinkAudioPolicy policies,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            } else if (!callerIsSystemOrActiveOrManagedUser(\n                    service, TAG, \"requestAudioPolicyAsSink\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            } else if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.requestAudioPolicyAsSink(device, policies);\n        }\n\n        @Override\n        public BluetoothSinkAudioPolicy getRequestedAudioPolicyAsSink(\n                BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getRequestedAudioPolicyAsSink\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.getRequestedAudioPolicyAsSink(device);\n        }\n\n        @Override\n        public void requestActivityInfo(\n                IBluetoothActivityEnergyInfoListener listener, AttributionSource source) {\n            BluetoothActivityEnergyInfo info = reportActivityInfo(source);\n            try {\n                listener.onBluetoothActivityEnergyInfoAvailable(info);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"onBluetoothActivityEnergyInfo: RemoteException\", e);\n            }\n        }\n\n        @Override\n        public void bleOnToOn(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"bleOnToOn\")) {\n                return;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.bleOnToOn();\n        }\n\n        @Override\n        public void bleOnToOff(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"bleOnToOff\")) {\n                return;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.bleOnToOff();\n        }\n\n        @Override\n        public void dump(FileDescriptor fd, String[] args) {\n            PrintWriter writer = new PrintWriter(new FileOutputStream(fd));\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n\n            service.enforceCallingOrSelfPermission(DUMP, null);\n\n            service.dump(fd, writer, args);\n            writer.close();\n        }\n\n        @Override\n        public boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"allowLowLatencyAudio\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service,\n                            Utils.getCallingAttributionSource(service),\n                            \"AdapterService allowLowLatencyAudio\")) {\n                return false;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.allowLowLatencyAudio(allowed, device);\n        }\n\n        @Override\n        public int startRfcommListener(\n                String name,\n                ParcelUuid uuid,\n                PendingIntent pendingIntent,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"startRfcommListener\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService startRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.startRfcommListener(name, uuid, pendingIntent, source);\n        }\n\n        @Override\n        public int stopRfcommListener(ParcelUuid uuid, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"stopRfcommListener\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService stopRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.stopRfcommListener(uuid, source);\n        }\n\n        @Override\n        public IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n                ParcelUuid uuid, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"retrievePendingSocketForServiceRecord\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service,\n                            source,\n                            \"AdapterService retrievePendingSocketForServiceRecord\")) {\n                return null;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.retrievePendingSocketForServiceRecord(uuid, source);\n        }\n\n        @Override\n        public void setForegroundUserId(int userId, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service,\n                            Utils.getCallingAttributionSource(mService),\n                            \"AdapterService setForegroundUserId\")) {\n                return;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            Utils.setForegroundUserId(userId);\n        }\n\n        @Override\n        public int setPreferredAudioProfiles(\n                BluetoothDevice device, Bundle modeToProfileBundle, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(service, TAG, \"setPreferredAudioProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            requireNonNull(device);\n            requireNonNull(modeToProfileBundle);\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (service.getBondState(device) != BluetoothDevice.BOND_BONDED) {\n                return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.setPreferredAudioProfiles(device, modeToProfileBundle);\n        }\n\n        @Override\n        public Bundle getPreferredAudioProfiles(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return Bundle.EMPTY;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(service, TAG, \"getPreferredAudioProfiles\")) {\n                return Bundle.EMPTY;\n            }\n            requireNonNull(device);\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (service.getBondState(device) != BluetoothDevice.BOND_BONDED) {\n                return Bundle.EMPTY;\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return Bundle.EMPTY;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.getPreferredAudioProfiles(device);\n        }\n\n        @Override\n        public int notifyActiveDeviceChangeApplied(\n                BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystem(TAG, \"notifyActiveDeviceChangeApplied\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            requireNonNull(device);\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (service.getBondState(device) != BluetoothDevice.BOND_BONDED) {\n                return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.notifyActiveDeviceChangeApplied(device);\n        }\n\n        @Override\n        public int isDualModeAudioEnabled(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            if (!Utils.isDualModeAudioEnabled()) {\n                return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public int registerPreferredAudioProfilesChangedCallback(\n                IBluetoothPreferredAudioProfilesCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(\n                    service, TAG, \"registerPreferredAudioProfilesChangedCallback\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            requireNonNull(callback);\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            // If LE only mode is enabled, the dual mode audio feature is disabled\n            if (!Utils.isDualModeAudioEnabled()) {\n                return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n            }\n\n            service.mPreferredAudioProfilesCallbacks.register(callback);\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public int unregisterPreferredAudioProfilesChangedCallback(\n                IBluetoothPreferredAudioProfilesCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(\n                    service, TAG, \"unregisterPreferredAudioProfilesChangedCallback\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            requireNonNull(callback);\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            if (!service.mPreferredAudioProfilesCallbacks.unregister(callback)) {\n                Log.e(\n                        TAG,\n                        \"unregisterPreferredAudioProfilesChangedCallback: callback was never \"\n                                + \"registered\");\n                return BluetoothStatusCodes.ERROR_CALLBACK_NOT_REGISTERED;\n            }\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public int registerBluetoothQualityReportReadyCallback(\n                IBluetoothQualityReportReadyCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(\n                    service, TAG, \"registerBluetoothQualityReportReadyCallback\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            requireNonNull(callback);\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.mBluetoothQualityReportReadyCallbacks.register(callback);\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public int unregisterBluetoothQualityReportReadyCallback(\n                IBluetoothQualityReportReadyCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(\n                    service, TAG, \"unregisterBluetoothQualityReportReadyCallback\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            requireNonNull(callback);\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            if (!service.mBluetoothQualityReportReadyCallbacks.unregister(callback)) {\n                Log.e(\n                        TAG,\n                        \"unregisterBluetoothQualityReportReadyCallback: callback was never \"\n                                + \"registered\");\n                return BluetoothStatusCodes.ERROR_CALLBACK_NOT_REGISTERED;\n            }\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public int getOffloadedTransportDiscoveryDataScanSupported(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getOffloadedTransportDiscoveryDataScanSupported\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, source, \"getOffloadedTransportDiscoveryDataScanSupported\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.getOffloadedTransportDiscoveryDataScanSupported();\n        }\n\n        @Override\n        public boolean isMediaProfileConnected(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService.isMediaProfileConnected\")) {\n                return false;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.isMediaProfileConnected();\n        }\n\n        @Override\n        public IBinder getBluetoothGatt() {\n            AdapterService service = getService();\n            return service == null ? null : service.getBluetoothGatt();\n        }\n\n        @Override\n        public IBinder getBluetoothScan() {\n            AdapterService service = getService();\n            return service == null ? null : service.getBluetoothScan();\n        }\n\n        @Override\n        public void unregAllGattClient(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            service.unregAllGattClient(source);\n        }\n\n        @Override\n        public IBinder getProfile(int profileId) {\n            AdapterService service = getService();\n            if (service == null) {\n                return null;\n            }\n\n            return service.getProfile(profileId);\n        }\n\n        @Override\n        public int setActiveAudioDevicePolicy(\n                BluetoothDevice device, int activeAudioDevicePolicy, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(service, TAG, \"setActiveAudioDevicePolicy\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.mDatabaseManager.setActiveAudioDevicePolicy(\n                    device, activeAudioDevicePolicy);\n        }\n\n        @Override\n        public int getActiveAudioDevicePolicy(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothDevice.ACTIVE_AUDIO_DEVICE_POLICY_DEFAULT;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(service, TAG, \"getActiveAudioDevicePolicy\")) {\n                throw new IllegalStateException(\n                        \"Caller is not the system or part of the active/managed user\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothDevice.ACTIVE_AUDIO_DEVICE_POLICY_DEFAULT;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.mDatabaseManager.getActiveAudioDevicePolicy(device);\n        }\n    }\n\n    /**\n     * Gets the preferred audio profiles for the device. See {@link\n     * BluetoothAdapter#getPreferredAudioProfiles(BluetoothDevice)} for more details.\n     *\n     * @param device is the remote device whose preferences we want to fetch\n     * @return a Bundle containing the preferred audio profiles for the device\n     */\n    public Bundle getPreferredAudioProfiles(BluetoothDevice device) {\n        if (!isDualModeAudioEnabled()\n                || mLeAudioService == null\n                || !isDualModeAudioSinkDevice(device)) {\n            return Bundle.EMPTY;\n        }\n        // Checks if the device is part of an LE Audio group\n        List<BluetoothDevice> groupDevices = mLeAudioService.getGroupDevices(device);\n        if (groupDevices.isEmpty()) {\n            return Bundle.EMPTY;\n        }\n\n        // If there are no preferences stored, return the defaults\n        Bundle storedBundle = Bundle.EMPTY;\n        for (BluetoothDevice groupDevice : groupDevices) {\n            Bundle groupDevicePreferences = mDatabaseManager.getPreferredAudioProfiles(groupDevice);\n            if (!groupDevicePreferences.isEmpty()) {\n                storedBundle = groupDevicePreferences;\n                break;\n            }\n        }\n\n        if (storedBundle.isEmpty()) {\n            Bundle defaultPreferencesBundle = new Bundle();\n            boolean useDefaultPreferences = false;\n            if (isOutputOnlyAudioSupported(groupDevices)) {\n                // Gets the default output only audio profile or defaults to LE_AUDIO if not present\n                int outputOnlyDefault =\n                        BluetoothProperties.getDefaultOutputOnlyAudioProfile()\n                                .orElse(BluetoothProfile.LE_AUDIO);\n                if (outputOnlyDefault != BluetoothProfile.A2DP\n                        && outputOnlyDefault != BluetoothProfile.LE_AUDIO) {\n                    outputOnlyDefault = BluetoothProfile.LE_AUDIO;\n                }\n                defaultPreferencesBundle.putInt(\n                        BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY, outputOnlyDefault);\n                useDefaultPreferences = true;\n            }\n            if (isDuplexAudioSupported(groupDevices)) {\n                // Gets the default duplex audio profile or defaults to LE_AUDIO if not present\n                int duplexDefault =\n                        BluetoothProperties.getDefaultDuplexAudioProfile()\n                                .orElse(BluetoothProfile.LE_AUDIO);\n                if (duplexDefault != BluetoothProfile.HEADSET\n                        && duplexDefault != BluetoothProfile.LE_AUDIO) {\n                    duplexDefault = BluetoothProfile.LE_AUDIO;\n                }\n                defaultPreferencesBundle.putInt(BluetoothAdapter.AUDIO_MODE_DUPLEX, duplexDefault);\n                useDefaultPreferences = true;\n            }\n\n            if (useDefaultPreferences) {\n                return defaultPreferencesBundle;\n            }\n        }\n        return storedBundle;\n    }\n\n    /**\n     * Sets the preferred audio profiles for the device. See {@link\n     * BluetoothAdapter#setPreferredAudioProfiles(BluetoothDevice, Bundle)} for more details.\n     *\n     * @param device is the remote device whose preferences we want to fetch\n     * @param modeToProfileBundle is the preferences we want to set for the device\n     * @return whether the preferences were successfully requested\n     */\n    private int setPreferredAudioProfiles(BluetoothDevice device, Bundle modeToProfileBundle) {\n        Log.i(TAG, \"setPreferredAudioProfiles for device=\" + device);\n        if (!isDualModeAudioEnabled()) {\n            Log.e(TAG, \"setPreferredAudioProfiles called while sysprop is disabled\");\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n        if (mLeAudioService == null) {\n            Log.e(TAG, \"setPreferredAudioProfiles: LEA service is not up\");\n            return BluetoothStatusCodes.ERROR_PROFILE_NOT_CONNECTED;\n        }\n        if (!isDualModeAudioSinkDevice(device)) {\n            Log.e(TAG, \"setPreferredAudioProfiles: Not a dual mode audio device\");\n            return BluetoothStatusCodes.ERROR_NOT_DUAL_MODE_AUDIO_DEVICE;\n        }\n        // Checks if the device is part of an LE Audio group\n        int groupId = mLeAudioService.getGroupId(device);\n        List<BluetoothDevice> groupDevices = mLeAudioService.getGroupDevices(groupId);\n        if (groupDevices.isEmpty()) {\n            return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n        }\n\n        // Copies relevant keys & values from modeToProfile bundle\n        Bundle strippedPreferences = new Bundle();\n        if (modeToProfileBundle.containsKey(BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY)\n                && isOutputOnlyAudioSupported(groupDevices)) {\n            int outputOnlyProfile =\n                    modeToProfileBundle.getInt(BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY);\n            if (outputOnlyProfile != BluetoothProfile.A2DP\n                    && outputOnlyProfile != BluetoothProfile.LE_AUDIO) {\n                throw new IllegalArgumentException(\n                        \"AUDIO_MODE_OUTPUT_ONLY has invalid value: \" + outputOnlyProfile);\n            }\n            strippedPreferences.putInt(BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY, outputOnlyProfile);\n        }\n        if (modeToProfileBundle.containsKey(BluetoothAdapter.AUDIO_MODE_DUPLEX)\n                && isDuplexAudioSupported(groupDevices)) {\n            int duplexProfile = modeToProfileBundle.getInt(BluetoothAdapter.AUDIO_MODE_DUPLEX);\n            if (duplexProfile != BluetoothProfile.HEADSET\n                    && duplexProfile != BluetoothProfile.LE_AUDIO) {\n                throw new IllegalArgumentException(\n                        \"AUDIO_MODE_DUPLEX has invalid value: \" + duplexProfile);\n            }\n            strippedPreferences.putInt(BluetoothAdapter.AUDIO_MODE_DUPLEX, duplexProfile);\n        }\n\n        synchronized (mCsipGroupsPendingAudioProfileChanges) {\n            if (mCsipGroupsPendingAudioProfileChanges.containsKey(groupId)) {\n                return BluetoothStatusCodes.ERROR_ANOTHER_ACTIVE_REQUEST;\n            }\n\n            Bundle previousPreferences = getPreferredAudioProfiles(device);\n\n            int dbResult =\n                    mDatabaseManager.setPreferredAudioProfiles(groupDevices, strippedPreferences);\n            if (dbResult != BluetoothStatusCodes.SUCCESS) {\n                return dbResult;\n            }\n\n            int outputOnlyPreference =\n                    strippedPreferences.getInt(BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY);\n            if (outputOnlyPreference == 0) {\n                outputOnlyPreference =\n                        previousPreferences.getInt(BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY);\n            }\n            int duplexPreference = strippedPreferences.getInt(BluetoothAdapter.AUDIO_MODE_DUPLEX);\n            if (duplexPreference == 0) {\n                duplexPreference = previousPreferences.getInt(BluetoothAdapter.AUDIO_MODE_DUPLEX);\n            }\n\n            mLeAudioService.sendAudioProfilePreferencesToNative(\n                    groupId,\n                    outputOnlyPreference == BluetoothProfile.LE_AUDIO,\n                    duplexPreference == BluetoothProfile.LE_AUDIO);\n\n            /* Populates the HashMap to hold requests on the groupId. We will update\n            numRequestsToAudioFramework after we make requests to the audio framework */\n            PendingAudioProfilePreferenceRequest holdRequest =\n                    new PendingAudioProfilePreferenceRequest(strippedPreferences, 0, device);\n            mCsipGroupsPendingAudioProfileChanges.put(groupId, holdRequest);\n\n            // Notifies audio framework via the handler thread to avoid this blocking calls\n            mHandler.post(\n                    () ->\n                            sendPreferredAudioProfileChangeToAudioFramework(\n                                    device, strippedPreferences, previousPreferences));\n            return BluetoothStatusCodes.SUCCESS;\n        }\n    }\n\n    /**\n     * Sends the updated preferred audio profiles to the audio framework.\n     *\n     * @param device is the device with updated audio preferences\n     * @param strippedPreferences is a {@link Bundle} containing the preferences\n     */\n    private void sendPreferredAudioProfileChangeToAudioFramework(\n            BluetoothDevice device, Bundle strippedPreferences, Bundle previousPreferences) {\n        int newOutput = strippedPreferences.getInt(BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY);\n        int newDuplex = strippedPreferences.getInt(BluetoothAdapter.AUDIO_MODE_DUPLEX);\n        int previousOutput = previousPreferences.getInt(BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY);\n        int previousDuplex = previousPreferences.getInt(BluetoothAdapter.AUDIO_MODE_DUPLEX);\n\n        Log.i(\n                TAG,\n                \"sendPreferredAudioProfileChangeToAudioFramework: changing output from \"\n                        + BluetoothProfile.getProfileName(previousOutput)\n                        + \" to \"\n                        + BluetoothProfile.getProfileName(newOutput)\n                        + \" and duplex from \"\n                        + BluetoothProfile.getProfileName(previousDuplex)\n                        + \" to \"\n                        + BluetoothProfile.getProfileName(newDuplex));\n\n        // If no change from existing preferences, do not inform audio framework\n        if (previousOutput == newOutput && previousDuplex == newDuplex) {\n            Log.i(TAG, \"No change to preferred audio profiles, no requests to Audio FW\");\n            sendPreferredAudioProfilesCallbackToApps(\n                    device, strippedPreferences, BluetoothStatusCodes.SUCCESS);\n            return;\n        }\n\n        int numRequestsToAudioFw = 0;\n\n        // Checks if the device is part of an LE Audio group\n        int groupId = mLeAudioService.getGroupId(device);\n        List<BluetoothDevice> groupDevices = mLeAudioService.getGroupDevices(groupId);\n        if (groupDevices.isEmpty()) {\n            Log.i(\n                    TAG,\n                    \"sendPreferredAudioProfileChangeToAudioFramework: Empty LEA group for \"\n                            + \"device - \"\n                            + device);\n            sendPreferredAudioProfilesCallbackToApps(\n                    device, strippedPreferences, BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED);\n            return;\n        }\n\n        synchronized (mCsipGroupsPendingAudioProfileChanges) {\n            if (previousOutput != newOutput) {\n                if (newOutput == BluetoothProfile.A2DP\n                        && mA2dpService.getActiveDevice() != null\n                        && groupDevices.contains(mA2dpService.getActiveDevice())) {\n                    Log.i(TAG, \"Sent change for AUDIO_MODE_OUTPUT_ONLY to A2DP to Audio FW\");\n                    numRequestsToAudioFw +=\n                            mA2dpService.sendPreferredAudioProfileChangeToAudioFramework();\n                } else if (newOutput == BluetoothProfile.LE_AUDIO\n                        && mLeAudioService.getActiveGroupId() == groupId) {\n                    Log.i(TAG, \"Sent change for AUDIO_MODE_OUTPUT_ONLY to LE_AUDIO to Audio FW\");\n                    numRequestsToAudioFw +=\n                            mLeAudioService.sendPreferredAudioProfileChangeToAudioFramework();\n                }\n            }\n\n            if (previousDuplex != newDuplex) {\n                if (newDuplex == BluetoothProfile.HEADSET\n                        && mHeadsetService.getActiveDevice() != null\n                        && groupDevices.contains(mHeadsetService.getActiveDevice())) {\n                    Log.i(TAG, \"Sent change for AUDIO_MODE_DUPLEX to HFP to Audio FW\");\n                    // TODO(b/275426145): Add similar HFP method in BluetoothProfileConnectionInfo\n                    numRequestsToAudioFw +=\n                            mA2dpService.sendPreferredAudioProfileChangeToAudioFramework();\n                } else if (newDuplex == BluetoothProfile.LE_AUDIO\n                        && mLeAudioService.getActiveGroupId() == groupId) {\n                    Log.i(TAG, \"Sent change for AUDIO_MODE_DUPLEX to LE_AUDIO to Audio FW\");\n                    numRequestsToAudioFw +=\n                            mLeAudioService.sendPreferredAudioProfileChangeToAudioFramework();\n                }\n            }\n\n            Log.i(\n                    TAG,\n                    \"sendPreferredAudioProfileChangeToAudioFramework: sent \"\n                            + numRequestsToAudioFw\n                            + \" request(s) to the Audio Framework for device: \"\n                            + device);\n\n            if (numRequestsToAudioFw > 0) {\n                mCsipGroupsPendingAudioProfileChanges.put(\n                        groupId,\n                        new PendingAudioProfilePreferenceRequest(\n                                strippedPreferences, numRequestsToAudioFw, device));\n\n                Message m =\n                        mHandler.obtainMessage(\n                                MESSAGE_PREFERRED_AUDIO_PROFILES_AUDIO_FRAMEWORK_TIMEOUT);\n                m.obj = groupId;\n                mHandler.sendMessageDelayed(m, PREFERRED_AUDIO_PROFILE_CHANGE_TIMEOUT.toMillis());\n                return;\n            }\n        }\n        sendPreferredAudioProfilesCallbackToApps(\n                device, strippedPreferences, BluetoothStatusCodes.SUCCESS);\n    }\n\n    private void removeFromPendingAudioProfileChanges(int groupId) {\n        synchronized (mCsipGroupsPendingAudioProfileChanges) {\n            Log.i(\n                    TAG,\n                    \"removeFromPendingAudioProfileChanges: Timeout on change for groupId=\"\n                            + groupId);\n            if (!mCsipGroupsPendingAudioProfileChanges.containsKey(groupId)) {\n                Log.e(\n                        TAG,\n                        \"removeFromPendingAudioProfileChanges( \"\n                                + groupId\n                                + \", \"\n                                + groupId\n                                + \") is not pending\");\n                return;\n            }\n        }\n    }\n\n    /**\n     * Notification from the audio framework that an active device change has taken effect. See\n     * {@link BluetoothAdapter#notifyActiveDeviceChangeApplied(BluetoothDevice)} for more details.\n     *\n     * @param device the remote device whose preferred audio profiles have been changed\n     * @return whether the Bluetooth stack acknowledged the change successfully\n     */\n    private int notifyActiveDeviceChangeApplied(BluetoothDevice device) {\n        if (mLeAudioService == null) {\n            Log.e(TAG, \"LE Audio profile not enabled\");\n            return BluetoothStatusCodes.ERROR_PROFILE_NOT_CONNECTED;\n        }\n\n        int groupId = mLeAudioService.getGroupId(device);\n        if (groupId == LE_AUDIO_GROUP_ID_INVALID) {\n            return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n        }\n\n        synchronized (mCsipGroupsPendingAudioProfileChanges) {\n            if (!mCsipGroupsPendingAudioProfileChanges.containsKey(groupId)) {\n                Log.e(\n                        TAG,\n                        \"notifyActiveDeviceChangeApplied, but no pending request for \"\n                                + \"groupId: \"\n                                + groupId);\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n            }\n\n            PendingAudioProfilePreferenceRequest pendingRequest =\n                    mCsipGroupsPendingAudioProfileChanges.get(groupId);\n\n            // If this is the final audio framework request, send callback to apps\n            if (pendingRequest.mRemainingRequestsToAudioFramework == 1) {\n                Log.i(\n                        TAG,\n                        \"notifyActiveDeviceChangeApplied: Complete for device \"\n                                + pendingRequest.mDeviceRequested);\n                sendPreferredAudioProfilesCallbackToApps(\n                        pendingRequest.mDeviceRequested,\n                        pendingRequest.mRequestedPreferences,\n                        BluetoothStatusCodes.SUCCESS);\n                // Removes the timeout from the handler\n                mHandler.removeMessages(\n                        MESSAGE_PREFERRED_AUDIO_PROFILES_AUDIO_FRAMEWORK_TIMEOUT, groupId);\n            } else if (pendingRequest.mRemainingRequestsToAudioFramework > 1) {\n                PendingAudioProfilePreferenceRequest updatedPendingRequest =\n                        new PendingAudioProfilePreferenceRequest(\n                                pendingRequest.mRequestedPreferences,\n                                pendingRequest.mRemainingRequestsToAudioFramework - 1,\n                                pendingRequest.mDeviceRequested);\n                Log.i(\n                        TAG,\n                        \"notifyActiveDeviceChangeApplied: Updating device \"\n                                + updatedPendingRequest.mDeviceRequested\n                                + \" with new remaining requests count=\"\n                                + updatedPendingRequest.mRemainingRequestsToAudioFramework);\n                mCsipGroupsPendingAudioProfileChanges.put(groupId, updatedPendingRequest);\n            } else {\n                Log.i(\n                        TAG,\n                        \"notifyActiveDeviceChangeApplied: \"\n                                + pendingRequest.mDeviceRequested\n                                + \" has no remaining requests to audio framework, but is still\"\n                                + \" present in mCsipGroupsPendingAudioProfileChanges\");\n            }\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    private void sendPreferredAudioProfilesCallbackToApps(\n            BluetoothDevice device, Bundle preferredAudioProfiles, int status) {\n        int n = mPreferredAudioProfilesCallbacks.beginBroadcast();\n        Log.d(\n                TAG,\n                \"sendPreferredAudioProfilesCallbackToApps() - Broadcasting audio profile \"\n                        + (\"change callback to device: \" + device)\n                        + (\" and status=\" + status)\n                        + (\" to \" + n + \" receivers.\"));\n        for (int i = 0; i < n; i++) {\n            try {\n                mPreferredAudioProfilesCallbacks\n                        .getBroadcastItem(i)\n                        .onPreferredAudioProfilesChanged(device, preferredAudioProfiles, status);\n            } catch (RemoteException e) {\n                Log.d(\n                        TAG,\n                        \"sendPreferredAudioProfilesCallbackToApps() - Callback #\"\n                                + i\n                                + \" failed (\"\n                                + e\n                                + \")\");\n            }\n        }\n        mPreferredAudioProfilesCallbacks.finishBroadcast();\n    }\n\n    // ----API Methods--------\n\n    public boolean isEnabled() {\n        return getState() == BluetoothAdapter.STATE_ON;\n    }\n\n    public int getState() {\n        if (mAdapterProperties != null) {\n            return mAdapterProperties.getState();\n        }\n        return BluetoothAdapter.STATE_OFF;\n    }\n\n    public synchronized void offToBleOn(boolean quietMode) {\n        // Enforce the user restriction for disallowing Bluetooth if it was set.\n        if (mUserManager.hasUserRestrictionForUser(\n                UserManager.DISALLOW_BLUETOOTH, UserHandle.SYSTEM)) {\n            Log.d(TAG, \"offToBleOn() called when Bluetooth was disallowed\");\n            return;\n        }\n        if (Flags.fastBindToApp()) {\n            // The call to init must be done on the main thread\n            mHandler.post(() -> init());\n        }\n\n        Log.i(TAG, \"offToBleOn() - Enable called with quiet mode status =  \" + quietMode);\n        mQuietmode = quietMode;\n        mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_ON);\n    }\n\n    void onToBleOn() {\n        Log.d(TAG, \"onToBleOn() called with mRunningProfiles.size() = \" + mRunningProfiles.size());\n        mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_OFF);\n    }\n\n    public String getName() {\n        return mAdapterProperties.getName();\n    }\n\n    public int getNameLengthForAdvertise() {\n        return mAdapterProperties.getName().length();\n    }\n\n    List<DiscoveringPackage> getDiscoveringPackages() {\n        return mDiscoveringPackages;\n    }\n\n    void clearDiscoveringPackages() {\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.clear();\n        }\n    }\n\n    boolean startDiscovery(AttributionSource source) {\n        UserHandle callingUser = Binder.getCallingUserHandle();\n        Log.d(TAG, \"startDiscovery\");\n        String callingPackage = source.getPackageName();\n        mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);\n        boolean isQApp = Utils.checkCallerTargetSdk(this, callingPackage, Build.VERSION_CODES.Q);\n        boolean hasDisavowedLocation =\n                Utils.hasDisavowedLocationForScan(this, source, mTestModeEnabled);\n        String permission = null;\n        if (Utils.checkCallerHasNetworkSettingsPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETTINGS;\n        } else if (Utils.checkCallerHasNetworkSetupWizardPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETUP_WIZARD;\n        } else if (!hasDisavowedLocation) {\n            if (isQApp) {\n                if (!Utils.checkCallerHasFineLocation(this, source, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_FINE_LOCATION;\n            } else {\n                if (!Utils.checkCallerHasCoarseLocation(this, source, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_COARSE_LOCATION;\n            }\n        }\n\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.add(\n                    new DiscoveringPackage(callingPackage, permission, hasDisavowedLocation));\n        }\n        return mNativeInterface.startDiscovery();\n    }\n\n    /**\n     * Same as API method {@link BluetoothAdapter#getBondedDevices()}\n     *\n     * @return array of bonded {@link BluetoothDevice} or null on error\n     */\n    public BluetoothDevice[] getBondedDevices() {\n        return mAdapterProperties.getBondedDevices();\n    }\n\n    /**\n     * Get the database manager to access Bluetooth storage\n     *\n     * @return {@link DatabaseManager} or null on error\n     */\n    public DatabaseManager getDatabase() {\n        return mDatabaseManager;\n    }\n\n    public byte[] getByteIdentityAddress(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.getIdentityAddress() != null) {\n            return Utils.getBytesFromAddress(deviceProp.getIdentityAddress());\n        }\n\n        if (Flags.identityAddressNullIfNotKnown()) {\n            // Return null if identity address unknown\n            return null;\n        } else {\n            return Utils.getByteAddress(device);\n        }\n    }\n\n    public BluetoothDevice getDeviceFromByte(byte[] address) {\n        BluetoothDevice device = mRemoteDevices.getDevice(address);\n        if (device == null) {\n            device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address);\n        }\n        return device;\n    }\n\n    public String getIdentityAddress(String address) {\n        BluetoothDevice device =\n                BluetoothAdapter.getDefaultAdapter().getRemoteDevice(Ascii.toUpperCase(address));\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.getIdentityAddress() != null) {\n            return deviceProp.getIdentityAddress();\n        } else {\n            if (Flags.identityAddressNullIfNotKnown()) {\n                // Return null if identity address unknown\n                return null;\n            } else {\n                return address;\n            }\n        }\n    }\n\n    private static class CallerInfo {\n        public String callerPackageName;\n        public UserHandle user;\n    }\n\n    boolean createBond(\n            BluetoothDevice device,\n            int transport,\n            OobData remoteP192Data,\n            OobData remoteP256Data,\n            String callingPackage) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.getBondState() != BluetoothDevice.BOND_NONE) {\n            // true for BONDING, false for BONDED\n            return deviceProp.getBondState() == BluetoothDevice.BOND_BONDING;\n        }\n\n        if (!isEnabled()) {\n            Log.e(TAG, \"Impossible to call createBond when Bluetooth is not enabled\");\n            return false;\n        }\n\n        if (!isPackageNameAccurate(this, callingPackage, Binder.getCallingUid())) {\n            return false;\n        }\n\n        CallerInfo createBondCaller = new CallerInfo();\n        createBondCaller.callerPackageName = callingPackage;\n        createBondCaller.user = Binder.getCallingUserHandle();\n        mBondAttemptCallerInfo.put(device.getAddress(), createBondCaller);\n\n        mRemoteDevices.setBondingInitiatedLocally(Utils.getByteAddress(device));\n\n        // Pairing is unreliable while scanning, so cancel discovery\n        // Note, remove this when native stack improves\n        mNativeInterface.cancelDiscovery();\n\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.CREATE_BOND);\n        msg.obj = device;\n        msg.arg1 = transport;\n\n        Bundle remoteOobDatasBundle = new Bundle();\n        boolean setData = false;\n        if (remoteP192Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP192, remoteP192Data);\n            setData = true;\n        }\n        if (remoteP256Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP256, remoteP256Data);\n            setData = true;\n        }\n        if (setData) {\n            msg.setData(remoteOobDatasBundle);\n        } else {\n            MetricsLogger.getInstance()\n                    .logBluetoothEvent(\n                            device,\n                            BluetoothStatsLog\n                                    .BLUETOOTH_CROSS_LAYER_EVENT_REPORTED__EVENT_TYPE__BONDING,\n                            BluetoothStatsLog.BLUETOOTH_CROSS_LAYER_EVENT_REPORTED__STATE__START,\n                            Binder.getCallingUid());\n        }\n        mBondStateMachine.sendMessage(msg);\n        return true;\n    }\n\n    /**\n     * Fetches the local OOB data to give out to remote.\n     *\n     * @param transport - specify data transport.\n     * @param callback - callback used to receive the requested {@link OobData}; null will be\n     *     ignored silently.\n     */\n    public synchronized void generateLocalOobData(\n            int transport, IBluetoothOobDataCallback callback) {\n        if (callback == null) {\n            Log.e(TAG, \"'callback' argument must not be null!\");\n            return;\n        }\n        if (mOobDataCallbackQueue.peek() != null) {\n            try {\n                callback.onError(BluetoothStatusCodes.ERROR_ANOTHER_ACTIVE_OOB_REQUEST);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n            return;\n        }\n        mOobDataCallbackQueue.offer(callback);\n        mHandler.postDelayed(\n                () -> removeFromOobDataCallbackQueue(callback),\n                GENERATE_LOCAL_OOB_DATA_TIMEOUT.toMillis());\n        mNativeInterface.generateLocalOobData(transport);\n    }\n\n    private synchronized void removeFromOobDataCallbackQueue(IBluetoothOobDataCallback callback) {\n        if (callback == null) {\n            return;\n        }\n\n        if (mOobDataCallbackQueue.peek() == callback) {\n            try {\n                mOobDataCallbackQueue.poll().onError(BluetoothStatusCodes.ERROR_UNKNOWN);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make OobDataCallback to remove callback from queue\", e);\n            }\n        }\n    }\n\n    /* package */ synchronized void notifyOobDataCallback(int transport, OobData oobData) {\n        if (mOobDataCallbackQueue.peek() == null) {\n            Log.e(TAG, \"Failed to make callback, no callback exists\");\n            return;\n        }\n        if (oobData == null) {\n            try {\n                mOobDataCallbackQueue.poll().onError(BluetoothStatusCodes.ERROR_UNKNOWN);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        } else {\n            try {\n                mOobDataCallbackQueue.poll().onOobData(transport, oobData);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        }\n    }\n\n    public boolean isQuietModeEnabled() {\n        Log.d(TAG, \"isQuietModeEnabled() - Enabled = \" + mQuietmode);\n        return mQuietmode;\n    }\n\n    public void updateUuids() {\n        Log.d(TAG, \"updateUuids() - Updating UUIDs for bonded devices\");\n        BluetoothDevice[] bondedDevices = getBondedDevices();\n        if (bondedDevices == null) {\n            return;\n        }\n\n        for (BluetoothDevice device : bondedDevices) {\n            mRemoteDevices.updateUuids(device);\n        }\n    }\n\n    /**\n     * Update device UUID changed to {@link BondStateMachine}\n     *\n     * @param device remote device of interest\n     */\n    public void deviceUuidUpdated(BluetoothDevice device) {\n        // Notify BondStateMachine for SDP complete / UUID changed.\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.UUID_UPDATE);\n        msg.obj = device;\n        mBondStateMachine.sendMessage(msg);\n    }\n\n    /**\n     * Get the bond state of a particular {@link BluetoothDevice}\n     *\n     * @param device remote device of interest\n     * @return bond state\n     *     <p>Possible values are {@link BluetoothDevice#BOND_NONE}, {@link\n     *     BluetoothDevice#BOND_BONDING}, {@link BluetoothDevice#BOND_BONDED}.\n     */\n    public int getBondState(BluetoothDevice device) {\n        return mRemoteDevices.getBondState(device);\n    }\n\n    public boolean isConnected(BluetoothDevice device) {\n        return getConnectionState(device) != BluetoothDevice.CONNECTION_STATE_DISCONNECTED;\n    }\n\n    public int getConnectionState(BluetoothDevice device) {\n        final String address = device.getAddress();\n        if (Flags.apiGetConnectionStateUsingIdentityAddress()) {\n            int connectionState = mNativeInterface.getConnectionState(getBytesFromAddress(address));\n            final String identityAddress = getIdentityAddress(address);\n            if (identityAddress != null) {\n                connectionState |=\n                        mNativeInterface.getConnectionState(getBytesFromAddress(identityAddress));\n            }\n            return connectionState;\n        }\n        return mNativeInterface.getConnectionState(getBytesFromAddress(address));\n    }\n\n    int getConnectionHandle(BluetoothDevice device, int transport) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return BluetoothDevice.ERROR;\n        }\n        return deviceProp.getConnectionHandle(transport);\n    }\n\n    /**\n     * Get ASHA Capability\n     *\n     * @param device discovered bluetooth device\n     * @return ASHA capability\n     */\n    public int getAshaCapability(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return BluetoothDevice.ERROR;\n        }\n        return deviceProp.getAshaCapability();\n    }\n\n    /**\n     * Get ASHA truncated HiSyncId\n     *\n     * @param device discovered bluetooth device\n     * @return ASHA truncated HiSyncId\n     */\n    public int getAshaTruncatedHiSyncId(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return BluetoothDevice.ERROR;\n        }\n        return deviceProp.getAshaTruncatedHiSyncId();\n    }\n\n    /**\n     * Checks whether the device was recently associated with the comapnion app that called {@link\n     * BluetoothDevice#createBond}. This allows these devices to skip the pairing dialog if their\n     * pairing variant is {@link BluetoothDevice#PAIRING_VARIANT_CONSENT}.\n     *\n     * @param device the bluetooth device that is being bonded\n     * @return true if it was recently associated and we can bypass the dialog, false otherwise\n     */\n    public boolean canBondWithoutDialog(BluetoothDevice device) {\n        if (mBondAttemptCallerInfo.containsKey(device.getAddress())) {\n            CallerInfo bondCallerInfo = mBondAttemptCallerInfo.get(device.getAddress());\n\n            return mCompanionDeviceManager.canPairWithoutPrompt(\n                    bondCallerInfo.callerPackageName, device.getAddress(), bondCallerInfo.user);\n        }\n        return false;\n    }\n\n    /**\n     * Returns the package name of the most recent caller that called {@link\n     * BluetoothDevice#createBond} on the given device.\n     */\n    @Nullable\n    public String getPackageNameOfBondingApplication(BluetoothDevice device) {\n        CallerInfo info = mBondAttemptCallerInfo.get(device.getAddress());\n        if (info == null) {\n            return null;\n        }\n        return info.callerPackageName;\n    }\n\n    /**\n     * Sets device as the active devices for the profiles passed into the function.\n     *\n     * @param device is the remote bluetooth device\n     * @param profiles is a constant that references for which profiles we'll be setting the remote\n     *     device as our active device. One of the following: {@link\n     *     BluetoothAdapter#ACTIVE_DEVICE_AUDIO}, {@link BluetoothAdapter#ACTIVE_DEVICE_PHONE_CALL}\n     *     {@link BluetoothAdapter#ACTIVE_DEVICE_ALL}\n     * @return false if profiles value is not one of the constants we accept, true otherwise\n     */\n    public boolean setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles) {\n        if (getState() != BluetoothAdapter.STATE_ON) {\n            Log.e(TAG, \"setActiveDevice: Bluetooth is not enabled\");\n            return false;\n        }\n        boolean setA2dp = false;\n        boolean setHeadset = false;\n\n        // Determine for which profiles we want to set device as our active device\n        switch (profiles) {\n            case BluetoothAdapter.ACTIVE_DEVICE_AUDIO:\n                setA2dp = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_PHONE_CALL:\n                setHeadset = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_ALL:\n                setA2dp = true;\n                setHeadset = true;\n                break;\n            default:\n                return false;\n        }\n\n        boolean a2dpSupported =\n                mA2dpService != null\n                        && (device == null\n                                || mA2dpService.getConnectionPolicy(device)\n                                        == BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n        boolean hfpSupported =\n                mHeadsetService != null\n                        && (device == null\n                                || mHeadsetService.getConnectionPolicy(device)\n                                        == BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n        boolean leAudioSupported =\n                mLeAudioService != null\n                        && (device == null\n                                || mLeAudioService.getConnectionPolicy(device)\n                                        == BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n\n        if (leAudioSupported) {\n            Log.i(TAG, \"setActiveDevice: Setting active Le Audio device \" + device);\n            if (device == null) {\n                /* If called by BluetoothAdapter it means Audio should not be stopped.\n                 * For this reason let's say that fallback device exists\n                 */\n                mLeAudioService.removeActiveDevice(true /* hasFallbackDevice */);\n            } else {\n                mLeAudioService.setActiveDevice(device);\n            }\n        }\n\n        if (setA2dp && a2dpSupported) {\n            Log.i(TAG, \"setActiveDevice: Setting active A2dp device \" + device);\n            if (device == null) {\n                mA2dpService.removeActiveDevice(false);\n            } else {\n                /* Workaround for the controller issue which is not able to handle correctly\n                 * A2DP offloader vendor specific command while ISO Data path is set.\n                 * Proper solutions should be delivered in b/312396770\n                 */\n                if (mLeAudioService != null) {\n                    List<BluetoothDevice> activeLeAudioDevices = mLeAudioService.getActiveDevices();\n                    if (activeLeAudioDevices.get(0) != null) {\n                        mLeAudioService.removeActiveDevice(true);\n                    }\n                }\n                mA2dpService.setActiveDevice(device);\n            }\n        }\n\n        if (mHearingAidService != null\n                && (device == null\n                        || mHearingAidService.getConnectionPolicy(device)\n                                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Hearing Aid \" + device);\n            if (device == null) {\n                mHearingAidService.removeActiveDevice(false);\n            } else {\n                mHearingAidService.setActiveDevice(device);\n            }\n        }\n\n        if (setHeadset && hfpSupported) {\n            Log.i(TAG, \"setActiveDevice: Setting active Headset \" + device);\n            mHeadsetService.setActiveDevice(device);\n        }\n\n        return true;\n    }\n\n    /**\n     * Checks if all supported classic audio profiles are active on this LE Audio device.\n     *\n     * @param leAudioDevice the remote device\n     * @return {@code true} if all supported classic audio profiles are active on this device,\n     *     {@code false} otherwise\n     */\n    public boolean isAllSupportedClassicAudioProfilesActive(BluetoothDevice leAudioDevice) {\n        if (mLeAudioService == null) {\n            return false;\n        }\n        boolean a2dpSupported = isProfileSupported(leAudioDevice, BluetoothProfile.A2DP);\n        boolean hfpSupported = isProfileSupported(leAudioDevice, BluetoothProfile.HEADSET);\n\n        List<BluetoothDevice> groupDevices = mLeAudioService.getGroupDevices(leAudioDevice);\n        if (hfpSupported && mHeadsetService != null) {\n            BluetoothDevice activeHfpDevice = mHeadsetService.getActiveDevice();\n            if (activeHfpDevice == null || !groupDevices.contains(activeHfpDevice)) {\n                return false;\n            }\n        }\n        if (a2dpSupported && mA2dpService != null) {\n            BluetoothDevice activeA2dpDevice = mA2dpService.getActiveDevice();\n            if (activeA2dpDevice == null || !groupDevices.contains(activeA2dpDevice)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Get the active devices for the BluetoothProfile specified\n     *\n     * @param profile is the profile from which we want the active devices. Possible values are:\n     *     {@link BluetoothProfile#HEADSET}, {@link BluetoothProfile#A2DP}, {@link\n     *     BluetoothProfile#HEARING_AID} {@link BluetoothProfile#LE_AUDIO}\n     * @return A list of active bluetooth devices\n     */\n    public List<BluetoothDevice> getActiveDevices(@ActiveDeviceProfile int profile) {\n        List<BluetoothDevice> activeDevices = new ArrayList<>();\n\n        switch (profile) {\n            case BluetoothProfile.HEADSET:\n                if (mHeadsetService == null) {\n                    Log.e(TAG, \"getActiveDevices: HeadsetService is null\");\n                } else {\n                    BluetoothDevice device = mHeadsetService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: Headset device: \" + device);\n                }\n                break;\n            case BluetoothProfile.A2DP:\n                if (mA2dpService == null) {\n                    Log.e(TAG, \"getActiveDevices: A2dpService is null\");\n                } else {\n                    BluetoothDevice device = mA2dpService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: A2dp device: \" + device);\n                }\n                break;\n            case BluetoothProfile.HEARING_AID:\n                if (mHearingAidService == null) {\n                    Log.e(TAG, \"getActiveDevices: HearingAidService is null\");\n                } else {\n                    activeDevices = mHearingAidService.getActiveDevices();\n                    Log.i(\n                            TAG,\n                            \"getActiveDevices: Hearing Aid devices:\"\n                                    + (\" Left[\" + activeDevices.get(0) + \"] -\")\n                                    + (\" Right[\" + activeDevices.get(1) + \"]\"));\n                }\n                break;\n            case BluetoothProfile.LE_AUDIO:\n                if (mLeAudioService == null) {\n                    Log.e(TAG, \"getActiveDevices: LeAudioService is null\");\n                } else {\n                    activeDevices = mLeAudioService.getActiveDevices();\n                    Log.i(\n                            TAG,\n                            \"getActiveDevices: LeAudio devices:\"\n                                    + (\" Lead[\" + activeDevices.get(0) + \"] -\")\n                                    + (\" member_1[\" + activeDevices.get(1) + \"]\"));\n                }\n                break;\n            default:\n                Log.e(TAG, \"getActiveDevices: profile value is not valid\");\n        }\n        return activeDevices;\n    }\n\n    /**\n     * Attempts connection to all enabled and supported bluetooth profiles between the local and\n     * remote device\n     *\n     * @param device is the remote device with which to connect these profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS} if all profiles connections are attempted, false\n     *     if an error occurred\n     */\n    public int connectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"connectAllEnabledProfiles: Not all profile services running\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        // Checks if any profiles are enablde or disabled and if so, only connect enabled profiles\n        if (!isAllProfilesUnknown(device)) {\n            return connectEnabledProfiles(device);\n        }\n\n        connectAllSupportedProfiles(device);\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Connect all supported bluetooth profiles between the local and remote device\n     *\n     * @param device is the remote device with which to connect all supported profiles\n     */\n    void connectAllSupportedProfiles(BluetoothDevice device) {\n        int numProfilesConnected = 0;\n\n        // All profile toggles disabled, so connects all supported profiles\n        if (mA2dpService != null && isProfileSupported(device, BluetoothProfile.A2DP)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting A2dp\");\n            // Set connection policy also connects the profile with CONNECTION_POLICY_ALLOWED\n            mA2dpService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mA2dpSinkService != null && isProfileSupported(device, BluetoothProfile.A2DP_SINK)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetService != null && isProfileSupported(device, BluetoothProfile.HEADSET)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Headset Profile\");\n            mHeadsetService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetClientService != null\n                && isProfileSupported(device, BluetoothProfile.HEADSET_CLIENT)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting HFP\");\n            mHeadsetClientService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mMapClientService != null && isProfileSupported(device, BluetoothProfile.MAP_CLIENT)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting MAP\");\n            mMapClientService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHidHostService != null && isProfileSupported(device, BluetoothProfile.HID_HOST)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Hid Host Profile\");\n            mHidHostService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPanService != null && isProfileSupported(device, BluetoothProfile.PAN)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Pan Profile\");\n            mPanService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPbapClientService != null\n                && isProfileSupported(device, BluetoothProfile.PBAP_CLIENT)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Pbap\");\n            mPbapClientService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHearingAidService != null\n                && isProfileSupported(device, BluetoothProfile.HEARING_AID)) {\n            if (mHapClientService != null\n                    && isProfileSupported(device, BluetoothProfile.HAP_CLIENT)) {\n                Log.i(\n                        TAG,\n                        \"connectAllSupportedProfiles: Hearing Access Client Profile is enabled at\"\n                                + \" the same time with Hearing Aid Profile, ignore Hearing Aid\"\n                                + \" Profile\");\n            } else {\n                Log.i(TAG, \"connectAllSupportedProfiles: Connecting Hearing Aid Profile\");\n                mHearingAidService.setConnectionPolicy(\n                        device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n                numProfilesConnected++;\n            }\n        }\n        if (mHapClientService != null && isProfileSupported(device, BluetoothProfile.HAP_CLIENT)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Hearing Access Client Profile\");\n            mHapClientService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mVolumeControlService != null\n                && isProfileSupported(device, BluetoothProfile.VOLUME_CONTROL)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mCsipSetCoordinatorService != null\n                && isProfileSupported(device, BluetoothProfile.CSIP_SET_COORDINATOR)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mLeAudioService != null && isProfileSupported(device, BluetoothProfile.LE_AUDIO)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mBassClientService != null\n                && isProfileSupported(device, BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mBatteryService != null && isProfileSupported(device, BluetoothProfile.BATTERY)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Battery Service\");\n            mBatteryService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n\n        Log.i(\n                TAG,\n                \"connectAllSupportedProfiles: Number of Profiles Connected: \"\n                        + numProfilesConnected);\n    }\n\n    /**\n     * Disconnects all enabled and supported bluetooth profiles between the local and remote device\n     *\n     * @param device is the remote device with which to disconnect these profiles\n     * @return true if all profiles successfully disconnected, false if an error occurred\n     */\n    public int disconnectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"disconnectAllEnabledProfiles: Not all profile services bound\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        if (mA2dpService != null\n                && (mA2dpService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mA2dpService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp\");\n            mA2dpService.disconnect(device);\n        }\n        if (mA2dpSinkService != null\n                && (mA2dpSinkService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mA2dpSinkService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp Sink\");\n            mA2dpSinkService.disconnect(device);\n        }\n        if (mHeadsetService != null\n                && (mHeadsetService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mHeadsetService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Headset Profile\");\n            mHeadsetService.disconnect(device);\n        }\n        if (mHeadsetClientService != null\n                && (mHeadsetClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTED\n                        || mHeadsetClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting HFP\");\n            mHeadsetClientService.disconnect(device);\n        }\n        if (mMapClientService != null\n                && (mMapClientService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mMapClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP Client\");\n            mMapClientService.disconnect(device);\n        }\n        if (mMapService != null\n                && (mMapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mMapService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP\");\n            mMapService.disconnect(device);\n        }\n        if (mHidDeviceService != null\n                && (mHidDeviceService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mHidDeviceService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Device Profile\");\n            mHidDeviceService.disconnect(device);\n        }\n        if (mHidHostService != null\n                && (mHidHostService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mHidHostService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Host Profile\");\n            mHidHostService.disconnect(device);\n        }\n        if (mPanService != null\n                && (mPanService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mPanService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pan Profile\");\n            mPanService.disconnect(device);\n        }\n        if (mPbapClientService != null\n                && (mPbapClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTED\n                        || mPbapClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Client\");\n            mPbapClientService.disconnect(device);\n        }\n        if (mPbapService != null\n                && (mPbapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mPbapService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Server\");\n            mPbapService.disconnect(device);\n        }\n        if (mHearingAidService != null\n                && (mHearingAidService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTED\n                        || mHearingAidService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Aid Profile\");\n            mHearingAidService.disconnect(device);\n        }\n        if (mHapClientService != null\n                && (mHapClientService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mHapClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Access Profile Client\");\n            mHapClientService.disconnect(device);\n        }\n        if (mVolumeControlService != null\n                && (mVolumeControlService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTED\n                        || mVolumeControlService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Volume Control Profile\");\n            mVolumeControlService.disconnect(device);\n        }\n        if (mSapService != null\n                && (mSapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mSapService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Sap Profile\");\n            mSapService.disconnect(device);\n        }\n        if (mCsipSetCoordinatorService != null\n                && (mCsipSetCoordinatorService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTED\n                        || mCsipSetCoordinatorService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Coordinator Set Profile\");\n            mCsipSetCoordinatorService.disconnect(device);\n        }\n        if (mLeAudioService != null\n                && (mLeAudioService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mLeAudioService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting LeAudio profile (BAP)\");\n            mLeAudioService.disconnect(device);\n        }\n        if (mBassClientService != null\n                && (mBassClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTED\n                        || mBassClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(\n                    TAG,\n                    \"disconnectAllEnabledProfiles: Disconnecting \"\n                            + \"LE Broadcast Assistant Profile\");\n            mBassClientService.disconnect(device);\n        }\n        if (mBatteryService != null\n                && (mBatteryService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mBatteryService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting \" + \"Battery Service\");\n            mBatteryService.disconnect(device);\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Same as API method {@link BluetoothDevice#getName()}\n     *\n     * @param device remote device of interest\n     * @return remote device name\n     */\n    public String getRemoteName(BluetoothDevice device) {\n        return mRemoteDevices.getName(device);\n    }\n\n    public int getRemoteClass(BluetoothDevice device) {\n        return mRemoteDevices.getBluetoothClass(device);\n    }\n\n    /**\n     * Get UUIDs for service supported by a remote device\n     *\n     * @param device the remote device that we want to get UUIDs from\n     * @return the uuids of the remote device\n     */\n    public ParcelUuid[] getRemoteUuids(BluetoothDevice device) {\n        return mRemoteDevices.getUuids(device);\n    }\n\n    void aclStateChangeBroadcastCallback(Consumer<IBluetoothConnectionCallback> cb) {\n        int n = mBluetoothConnectionCallbacks.beginBroadcast();\n        Log.d(TAG, \"aclStateChangeBroadcastCallback() - Broadcasting to \" + n + \" receivers.\");\n        for (int i = 0; i < n; i++) {\n            cb.accept(mBluetoothConnectionCallbacks.getBroadcastItem(i));\n        }\n        mBluetoothConnectionCallbacks.finishBroadcast();\n    }\n\n    /**\n     * Converts HCI disconnect reasons to Android disconnect reasons.\n     *\n     * <p>The HCI Error Codes used for ACL disconnect reasons propagated up from native code were\n     * copied from: packages/modules/Bluetooth/system/stack/include/hci_error_code.h\n     *\n     * <p>These error codes are specified and described in Bluetooth Core Spec v5.1, Vol 2, Part D.\n     *\n     * @param hciReason is the raw HCI disconnect reason from native.\n     * @return the Android disconnect reason for apps.\n     */\n    static @BluetoothAdapter.BluetoothConnectionCallback.DisconnectReason int\n            hciToAndroidDisconnectReason(int hciReason) {\n        switch (hciReason) {\n            case /*HCI_SUCCESS*/ 0x00:\n            case /*HCI_ERR_UNSPECIFIED*/ 0x1F:\n            case /*HCI_ERR_UNDEFINED*/ 0xff:\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n            case /*HCI_ERR_ILLEGAL_COMMAND*/ 0x01:\n            case /*HCI_ERR_NO_CONNECTION*/ 0x02:\n            case /*HCI_ERR_HW_FAILURE*/ 0x03:\n            case /*HCI_ERR_DIFF_TRANSACTION_COLLISION*/ 0x2A:\n            case /*HCI_ERR_ROLE_SWITCH_PENDING*/ 0x32:\n            case /*HCI_ERR_ROLE_SWITCH_FAILED*/ 0x35:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL;\n            case /*HCI_ERR_PAGE_TIMEOUT*/ 0x04:\n            case /*HCI_ERR_CONNECTION_TOUT*/ 0x08:\n            case /*HCI_ERR_HOST_TIMEOUT*/ 0x10:\n            case /*HCI_ERR_LMP_RESPONSE_TIMEOUT*/ 0x22:\n            case /*HCI_ERR_ADVERTISING_TIMEOUT*/ 0x3C:\n            case /*HCI_ERR_CONN_FAILED_ESTABLISHMENT*/ 0x3E:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_TIMEOUT;\n            case /*HCI_ERR_AUTH_FAILURE*/ 0x05:\n            case /*HCI_ERR_KEY_MISSING*/ 0x06:\n            case /*HCI_ERR_HOST_REJECT_SECURITY*/ 0x0E:\n            case /*HCI_ERR_REPEATED_ATTEMPTS*/ 0x17:\n            case /*HCI_ERR_PAIRING_NOT_ALLOWED*/ 0x18:\n            case /*HCI_ERR_ENCRY_MODE_NOT_ACCEPTABLE*/ 0x25:\n            case /*HCI_ERR_UNIT_KEY_USED*/ 0x26:\n            case /*HCI_ERR_PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED*/ 0x29:\n            case /*HCI_ERR_INSUFFCIENT_SECURITY*/ 0x2F:\n            case /*HCI_ERR_HOST_BUSY_PAIRING*/ 0x38:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SECURITY;\n            case /*HCI_ERR_MEMORY_FULL*/ 0x07:\n            case /*HCI_ERR_MAX_NUM_OF_CONNECTIONS*/ 0x09:\n            case /*HCI_ERR_MAX_NUM_OF_SCOS*/ 0x0A:\n            case /*HCI_ERR_COMMAND_DISALLOWED*/ 0x0C:\n            case /*HCI_ERR_HOST_REJECT_RESOURCES*/ 0x0D:\n            case /*HCI_ERR_LIMIT_REACHED*/ 0x43:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_RESOURCE_LIMIT_REACHED;\n            case /*HCI_ERR_CONNECTION_EXISTS*/ 0x0B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_CONNECTION_ALREADY_EXISTS;\n            case /*HCI_ERR_HOST_REJECT_DEVICE*/ 0x0F:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SYSTEM_POLICY;\n            case /*HCI_ERR_ILLEGAL_PARAMETER_FMT*/ 0x12:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            case /*HCI_ERR_PEER_USER*/ 0x13:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE_REQUEST;\n            case /*HCI_ERR_REMOTE_POWER_OFF*/ 0x15:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE_REQUEST;\n            case /*HCI_ERR_CONN_CAUSE_LOCAL_HOST*/ 0x16:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL_REQUEST;\n            case /*HCI_ERR_UNSUPPORTED_REM_FEATURE*/ 0x1A:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE;\n            case /*HCI_ERR_UNACCEPT_CONN_INTERVAL*/ 0x3B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            default:\n                Log.e(TAG, \"Invalid HCI disconnect reason: \" + hciReason);\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n    }\n\n    void logUserBondResponse(BluetoothDevice device, boolean accepted, int event) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            BluetoothStatsLog.write(\n                    BluetoothStatsLog.BLUETOOTH_BOND_STATE_CHANGED,\n                    obfuscateAddress(device),\n                    0,\n                    device.getType(),\n                    BluetoothDevice.BOND_BONDING,\n                    event,\n                    accepted ? 0 : BluetoothDevice.UNBOND_REASON_AUTH_REJECTED);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    public int getPhonebookAccessPermission(BluetoothDevice device) {\n        return getDeviceAccessFromPrefs(device, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public int getMessageAccessPermission(BluetoothDevice device) {\n        return getDeviceAccessFromPrefs(device, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public int getSimAccessPermission(BluetoothDevice device) {\n        return getDeviceAccessFromPrefs(device, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    int getDeviceAccessFromPrefs(BluetoothDevice device, String prefFile) {\n        SharedPreferences prefs = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        if (!prefs.contains(device.getAddress())) {\n            return BluetoothDevice.ACCESS_UNKNOWN;\n        }\n        return prefs.getBoolean(device.getAddress(), false)\n                ? BluetoothDevice.ACCESS_ALLOWED\n                : BluetoothDevice.ACCESS_REJECTED;\n    }\n\n    void setDeviceAccessFromPrefs(BluetoothDevice device, int value, String prefFile) {\n        SharedPreferences pref = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = pref.edit();\n        if (value == BluetoothDevice.ACCESS_UNKNOWN) {\n            editor.remove(device.getAddress());\n        } else {\n            editor.putBoolean(device.getAddress(), value == BluetoothDevice.ACCESS_ALLOWED);\n        }\n        editor.apply();\n    }\n\n    public void setPhonebookAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setMessageAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setSimAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public boolean isRpaOffloadSupported() {\n        return mAdapterProperties.isRpaOffloadSupported();\n    }\n\n    public int getNumOfOffloadedIrkSupported() {\n        return mAdapterProperties.getNumOfOffloadedIrkSupported();\n    }\n\n    public int getNumOfOffloadedScanFilterSupported() {\n        return mAdapterProperties.getNumOfOffloadedScanFilterSupported();\n    }\n\n    public int getOffloadedScanResultStorage() {\n        return mAdapterProperties.getOffloadedScanResultStorage();\n    }\n\n    public boolean isLe2MPhySupported() {\n        return mAdapterProperties.isLe2MPhySupported();\n    }\n\n    public boolean isLeCodedPhySupported() {\n        return mAdapterProperties.isLeCodedPhySupported();\n    }\n\n    public boolean isLeExtendedAdvertisingSupported() {\n        return mAdapterProperties.isLeExtendedAdvertisingSupported();\n    }\n\n    public boolean isLePeriodicAdvertisingSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast source feature is supported.\n     *\n     * @return true, if the LE audio broadcast source is supported\n     */\n    public boolean isLeAudioBroadcastSourceSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported()\n                && mAdapterProperties.isLeExtendedAdvertisingSupported()\n                && mAdapterProperties.isLeIsochronousBroadcasterSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast assistant feature is supported.\n     *\n     * @return true, if the LE audio broadcast assistant is supported\n     */\n    public boolean isLeAudioBroadcastAssistantSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported()\n                && mAdapterProperties.isLeExtendedAdvertisingSupported()\n                && (mAdapterProperties.isLePeriodicAdvertisingSyncTransferSenderSupported()\n                        || mAdapterProperties\n                                .isLePeriodicAdvertisingSyncTransferRecipientSupported());\n    }\n\n    /**\n     * Check if the LE channel sounding feature is supported.\n     *\n     * @return true, if the LE channel sounding is supported\n     */\n    public boolean isLeChannelSoundingSupported() {\n        return mAdapterProperties.isLeChannelSoundingSupported();\n    }\n\n    public long getSupportedProfilesBitMask() {\n        return Config.getSupportedProfilesBitMask();\n    }\n\n    /**\n     * Check if the LE audio CIS central feature is supported.\n     *\n     * @return true, if the LE audio CIS central is supported\n     */\n    public boolean isLeConnectedIsochronousStreamCentralSupported() {\n        return mAdapterProperties.isLeConnectedIsochronousStreamCentralSupported();\n    }\n\n    public int getLeMaximumAdvertisingDataLength() {\n        return mAdapterProperties.getLeMaximumAdvertisingDataLength();\n    }\n\n    /**\n     * Get the maximum number of connected audio devices.\n     *\n     * @return the maximum number of connected audio devices\n     */\n    public int getMaxConnectedAudioDevices() {\n        return mAdapterProperties.getMaxConnectedAudioDevices();\n    }\n\n    /**\n     * Check whether A2DP offload is enabled.\n     *\n     * @return true if A2DP offload is enabled\n     */\n    public boolean isA2dpOffloadEnabled() {\n        return mAdapterProperties.isA2dpOffloadEnabled();\n    }\n\n    /** Register a bluetooth state callback */\n    public void registerBluetoothStateCallback(Executor executor, BluetoothStateCallback callback) {\n        mLocalCallbacks.put(callback, executor);\n    }\n\n    /** Unregister a bluetooth state callback */\n    public void unregisterBluetoothStateCallback(BluetoothStateCallback callback) {\n        mLocalCallbacks.remove(callback);\n    }\n\n    @VisibleForTesting\n    void registerRemoteCallback(IBluetoothCallback callback) {\n        mRemoteCallbacks.register(callback);\n    }\n\n    @VisibleForTesting\n    void unregisterRemoteCallback(IBluetoothCallback callback) {\n        mRemoteCallbacks.unregister(callback);\n    }\n\n    @VisibleForTesting\n    void bleOnToOn() {\n        mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_ON);\n    }\n\n    @VisibleForTesting\n    void bleOnToOff() {\n        mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n    }\n\n    @VisibleForTesting\n    boolean factoryReset() {\n        mDatabaseManager.factoryReset();\n\n        if (mBluetoothKeystoreService != null) {\n            mBluetoothKeystoreService.factoryReset();\n        }\n\n        if (mBtCompanionManager != null) {\n            mBtCompanionManager.factoryReset();\n        }\n\n        return mNativeInterface.factoryReset();\n    }\n\n    @VisibleForTesting\n    int getScanMode() {\n        return mScanMode;\n    }\n\n    private boolean setScanMode(int mode, String from) {\n        mScanModeChanges.add(Utils.getLocalTimeString() + \" (\" + from + \") \" + dumpScanMode(mode));\n        if (!mNativeInterface.setScanMode(convertScanModeToHal(mode))) {\n            return false;\n        }\n        mScanMode = mode;\n        Intent intent =\n                new Intent(BluetoothAdapter.ACTION_SCAN_MODE_CHANGED)\n                        .putExtra(BluetoothAdapter.EXTRA_SCAN_MODE, mScanMode)\n                        .addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);\n        sendBroadcast(intent, BLUETOOTH_SCAN, Utils.getTempBroadcastOptions().toBundle());\n        return true;\n    }\n\n    @VisibleForTesting\n    BluetoothActivityEnergyInfo reportActivityInfo() {\n        if (mAdapterProperties.getState() != BluetoothAdapter.STATE_ON\n                || !mAdapterProperties.isActivityAndEnergyReportingSupported()) {\n            return null;\n        }\n\n        // Pull the data. The callback will notify mEnergyInfoLock.\n        mNativeInterface.readEnergyInfo();\n\n        synchronized (mEnergyInfoLock) {\n            long now = System.currentTimeMillis();\n            final long deadline = now + CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS;\n            while (now < deadline) {\n                try {\n                    mEnergyInfoLock.wait(deadline - now);\n                    break;\n                } catch (InterruptedException e) {\n                    now = System.currentTimeMillis();\n                }\n            }\n\n            final BluetoothActivityEnergyInfo info =\n                    new BluetoothActivityEnergyInfo(\n                            SystemClock.elapsedRealtime(),\n                            mStackReportedState,\n                            mTxTimeTotalMs,\n                            mRxTimeTotalMs,\n                            mIdleTimeTotalMs,\n                            mEnergyUsedTotalVoltAmpSecMicro);\n\n            // Copy the traffic objects whose byte counts are > 0\n            final List<UidTraffic> result = new ArrayList<>();\n            for (int i = 0; i < mUidTraffic.size(); i++) {\n                final UidTraffic traffic = mUidTraffic.valueAt(i);\n                if (traffic.getTxBytes() != 0 || traffic.getRxBytes() != 0) {\n                    result.add(traffic.clone());\n                }\n            }\n\n            info.setUidTraffic(result);\n\n            return info;\n        }\n    }\n\n    public int getTotalNumOfTrackableAdvertisements() {\n        return mAdapterProperties.getTotalNumOfTrackableAdvertisements();\n    }\n\n    /**\n     * Return if offloaded TDS filter is supported.\n     *\n     * @return {@code BluetoothStatusCodes.FEATURE_SUPPORTED} if supported\n     */\n    public int getOffloadedTransportDiscoveryDataScanSupported() {\n        if (mAdapterProperties.isOffloadedTransportDiscoveryDataScanSupported()) {\n            return BluetoothStatusCodes.FEATURE_SUPPORTED;\n        }\n        return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n    }\n\n    IBinder getBluetoothGatt() {\n        return mGattService == null ? null : mGattService.getBinder();\n    }\n\n    public GattService getBluetoothGattService() {\n        return mGattService;\n    }\n\n    IBinder getBluetoothScan() {\n        return mScanController == null ? null : mScanController.getBinder();\n    }\n\n    public ScanController getBluetoothScanController() {\n        return mScanController;\n    }\n\n    @RequiresPermission(BLUETOOTH_CONNECT)\n    void unregAllGattClient(AttributionSource source) {\n        if (mGattService != null) {\n            mGattService.unregAll(source);\n        }\n    }\n\n    IBinder getProfile(int profileId) {\n        if (getState() == BluetoothAdapter.STATE_TURNING_ON) {\n            return null;\n        }\n\n        // LE_AUDIO_BROADCAST is not associated with a service and use LE_AUDIO's Binder\n        if (profileId == BluetoothProfile.LE_AUDIO_BROADCAST) {\n            profileId = BluetoothProfile.LE_AUDIO;\n        }\n\n        ProfileService profile = mStartedProfiles.get(profileId);\n        if (profile != null) {\n            return profile.getBinder();\n        } else {\n            return null;\n        }\n    }\n\n    boolean isMediaProfileConnected() {\n        if (mA2dpService != null && mA2dpService.getConnectedDevices().size() > 0) {\n            Log.d(TAG, \"isMediaProfileConnected. A2dp is connected\");\n            return true;\n        } else if (mHearingAidService != null\n                && mHearingAidService.getConnectedDevices().size() > 0) {\n            Log.d(TAG, \"isMediaProfileConnected. HearingAid is connected\");\n            return true;\n        } else if (mLeAudioService != null && mLeAudioService.getConnectedDevices().size() > 0) {\n            Log.d(TAG, \"isMediaProfileConnected. LeAudio is connected\");\n            return true;\n        } else {\n            Log.d(\n                    TAG,\n                    \"isMediaProfileConnected: no Media connected.\"\n                            + (\" A2dp=\" + mA2dpService)\n                            + (\" HearingAid=\" + mHearingAidService)\n                            + (\" LeAudio=\" + mLeAudioService));\n            return false;\n        }\n    }\n\n    /** Update PhonePolicy when new {@link BluetoothDevice} creates an ACL connection. */\n    public void updatePhonePolicyOnAclConnect(BluetoothDevice device) {\n        if (mPhonePolicy != null) {\n            mPhonePolicy.handleAclConnected(device);\n        }\n    }\n\n    /**\n     * Notify {@link BluetoothProfile} when ACL connection disconnects from {@link BluetoothDevice}\n     * for a given {@code transport}.\n     */\n    public void notifyAclDisconnected(BluetoothDevice device, int transport) {\n        if (mMapService != null && mMapService.isAvailable()) {\n            mMapService.aclDisconnected(device);\n        }\n        if (mMapClientService != null && mMapClientService.isAvailable()) {\n            mMapClientService.aclDisconnected(device, transport);\n        }\n        if (mSapService != null && mSapService.isAvailable()) {\n            mSapService.aclDisconnected(device);\n        }\n        if (mPbapClientService != null && mPbapClientService.isAvailable()) {\n            mPbapClientService.aclDisconnected(device, transport);\n        }\n    }\n\n    /**\n     * Notify GATT of a Bluetooth profile's connection state change for a given {@link\n     * BluetoothProfile}.\n     */\n    public void notifyProfileConnectionStateChangeToGatt(int profile, int fromState, int toState) {\n        if (mGattService == null) {\n            Log.w(TAG, \"GATT Service is not running!\");\n            return;\n        }\n        if (Flags.scanManagerRefactor()) {\n            mScanController.notifyProfileConnectionStateChange(profile, fromState, toState);\n        } else {\n            mGattService.notifyProfileConnectionStateChange(profile, fromState, toState);\n        }\n    }\n\n    /**\n     * Handle Bluetooth app state when connection state changes for a given {@code profile}.\n     *\n     * <p>Currently this function is limited to handling Phone policy but the eventual goal is to\n     * move all connection logic here.\n     */\n    public void handleProfileConnectionStateChange(\n            int profile, BluetoothDevice device, int fromState, int toState) {\n        if (mPhonePolicy != null) {\n            mPhonePolicy.profileConnectionStateChanged(profile, device, fromState, toState);\n        }\n    }\n\n    /** Handle Bluetooth app state when active device changes for a given {@code profile}. */\n    public void handleActiveDeviceChange(int profile, BluetoothDevice device) {\n        mActiveDeviceManager.profileActiveDeviceChanged(profile, device);\n        mSilenceDeviceManager.profileActiveDeviceChanged(profile, device);\n        if (mPhonePolicy != null) {\n            mPhonePolicy.profileActiveDeviceChanged(profile, device);\n        }\n    }\n\n    /** Notify MAP and Pbap when a new sdp search record is found. */\n    public void sendSdpSearchRecord(\n            BluetoothDevice device, int status, Parcelable record, ParcelUuid uuid) {\n        if (mMapService != null && mMapService.isAvailable()) {\n            mMapService.receiveSdpSearchRecord(status, record, uuid);\n        }\n        if (mMapClientService != null && mMapClientService.isAvailable()) {\n            mMapClientService.receiveSdpSearchRecord(device, status, record, uuid);\n        }\n        if (mPbapClientService != null && mPbapClientService.isAvailable()) {\n            mPbapClientService.receiveSdpSearchRecord(device, status, record, uuid);\n        }\n    }\n\n    /** Handle Bluetooth profiles when bond state changes with a {@link BluetoothDevice} */\n    public void handleBondStateChanged(BluetoothDevice device, int fromState, int toState) {\n        if (mA2dpService != null && mA2dpService.isAvailable()) {\n            mA2dpService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mHeadsetService != null && mHeadsetService.isAvailable()) {\n            mHeadsetService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mLeAudioService != null && mLeAudioService.isAvailable()) {\n            mLeAudioService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mHearingAidService != null && mHearingAidService.isAvailable()) {\n            mHearingAidService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mHapClientService != null && mHapClientService.isAvailable()) {\n            mHapClientService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mBassClientService != null && mBassClientService.isAvailable()) {\n            mBassClientService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mBatteryService != null && mBatteryService.isAvailable()) {\n            mBatteryService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mVolumeControlService != null && mVolumeControlService.isAvailable()) {\n            mVolumeControlService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mPbapService != null && mPbapService.isAvailable()) {\n            mPbapService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mCsipSetCoordinatorService != null && mCsipSetCoordinatorService.isAvailable()) {\n            mCsipSetCoordinatorService.handleBondStateChanged(device, fromState, toState);\n        }\n        mDatabaseManager.handleBondStateChanged(device, fromState, toState);\n\n        if (toState == BOND_NONE) {\n            // Remove the permissions for unbonded devices\n            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n        }\n    }\n\n    static int convertScanModeToHal(int mode) {\n        switch (mode) {\n            case SCAN_MODE_NONE:\n                return AbstractionLayer.BT_SCAN_MODE_NONE;\n            case SCAN_MODE_CONNECTABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE;\n            case SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        return -1;\n    }\n\n    static int convertScanModeFromHal(int mode) {\n        switch (mode) {\n            case AbstractionLayer.BT_SCAN_MODE_NONE:\n                return SCAN_MODE_NONE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE:\n                return SCAN_MODE_CONNECTABLE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        return -1;\n    }\n\n    // This function is called from JNI. It allows native code to acquire a single wake lock.\n    // If the wake lock is already held, this function returns success. Although this function\n    // only supports acquiring a single wake lock at a time right now, it will eventually be\n    // extended to allow acquiring an arbitrary number of wake locks. The current interface\n    // takes |lockName| as a parameter in anticipation of that implementation.\n    boolean acquireWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                mWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, lockName);\n            }\n\n            if (!mWakeLock.isHeld()) {\n                mWakeLock.acquire();\n            }\n        }\n        return true;\n    }\n\n    // This function is called from JNI. It allows native code to release a wake lock acquired\n    // by |acquireWakeLock|. If the wake lock is not held, this function returns failure.\n    // Note that the release() call is also invoked by {@link #cleanup()} so a synchronization is\n    // needed here. See the comment for |acquireWakeLock| for an explanation of the interface.\n    boolean releaseWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                Log.e(TAG, \"Repeated wake lock release; aborting release: \" + lockName);\n                return false;\n            }\n\n            if (mWakeLock.isHeld()) {\n                mWakeLock.release();\n            }\n        }\n        return true;\n    }\n\n    void energyInfoCallbackInternal(\n            int status,\n            int ctrlState,\n            long txTime,\n            long rxTime,\n            long idleTime,\n            long energyUsed,\n            UidTraffic[] data) {\n        // Energy is product of mA, V and ms. If the chipset doesn't\n        // report it, we have to compute it from time\n        if (energyUsed == 0) {\n            try {\n                final long txMah = Math.multiplyExact(txTime, getTxCurrentMa());\n                final long rxMah = Math.multiplyExact(rxTime, getRxCurrentMa());\n                final long idleMah = Math.multiplyExact(idleTime, getIdleCurrentMa());\n                energyUsed =\n                        (long)\n                                (Math.addExact(Math.addExact(txMah, rxMah), idleMah)\n                                        * getOperatingVolt());\n            } catch (ArithmeticException e) {\n                Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                // Energy is already 0 if the exception was thrown.\n            }\n        }\n\n        synchronized (mEnergyInfoLock) {\n            mStackReportedState = ctrlState;\n            long totalTxTimeMs;\n            long totalRxTimeMs;\n            long totalIdleTimeMs;\n            long totalEnergy;\n            try {\n                totalTxTimeMs = Math.addExact(mTxTimeTotalMs, txTime);\n                totalRxTimeMs = Math.addExact(mRxTimeTotalMs, rxTime);\n                totalIdleTimeMs = Math.addExact(mIdleTimeTotalMs, idleTime);\n                totalEnergy = Math.addExact(mEnergyUsedTotalVoltAmpSecMicro, energyUsed);\n            } catch (ArithmeticException e) {\n                // This could be because we accumulated a lot of time, or we got a very strange\n                // value from the controller (more likely). Discard this data.\n                Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                totalTxTimeMs = mTxTimeTotalMs;\n                totalRxTimeMs = mRxTimeTotalMs;\n                totalIdleTimeMs = mIdleTimeTotalMs;\n                totalEnergy = mEnergyUsedTotalVoltAmpSecMicro;\n            }\n\n            mTxTimeTotalMs = totalTxTimeMs;\n            mRxTimeTotalMs = totalRxTimeMs;\n            mIdleTimeTotalMs = totalIdleTimeMs;\n            mEnergyUsedTotalVoltAmpSecMicro = totalEnergy;\n\n            for (UidTraffic traffic : data) {\n                UidTraffic existingTraffic = mUidTraffic.get(traffic.getUid());\n                if (existingTraffic == null) {\n                    mUidTraffic.put(traffic.getUid(), traffic);\n                } else {\n                    existingTraffic.addRxBytes(traffic.getRxBytes());\n                    existingTraffic.addTxBytes(traffic.getTxBytes());\n                }\n            }\n            mEnergyInfoLock.notifyAll();\n        }\n    }\n\n    void energyInfoCallback(\n            int status,\n            int ctrlState,\n            long txTime,\n            long rxTime,\n            long idleTime,\n            long energyUsed,\n            UidTraffic[] data) {\n        if (Flags.btSystemContextReport()) {\n            energyInfoCallbackInternal(\n                    status, ctrlState, txTime, rxTime, idleTime, energyUsed, data);\n        } else if (ctrlState >= BluetoothActivityEnergyInfo.BT_STACK_STATE_INVALID\n                && ctrlState <= BluetoothActivityEnergyInfo.BT_STACK_STATE_STATE_IDLE) {\n            energyInfoCallbackInternal(\n                    status, ctrlState, txTime, rxTime, idleTime, energyUsed, data);\n        }\n        Log.v(\n                TAG,\n                \"energyInfoCallback()\"\n                        + (\" status = \" + status)\n                        + (\" txTime = \" + txTime)\n                        + (\" rxTime = \" + rxTime)\n                        + (\" idleTime = \" + idleTime)\n                        + (\" energyUsed = \" + energyUsed)\n                        + (\" ctrlState = \" + Utils.formatSimple(\"0x%08x\", ctrlState))\n                        + (\" traffic = \" + Arrays.toString(data)));\n    }\n\n    /** Update metadata change to registered listeners */\n    @VisibleForTesting\n    public void metadataChanged(String address, int key, byte[] value) {\n        BluetoothDevice device = mRemoteDevices.getDevice(Utils.getBytesFromAddress(address));\n\n        // pass just interesting metadata to native, to reduce spam\n        if (key == BluetoothDevice.METADATA_LE_AUDIO) {\n            mNativeInterface.metadataChanged(Utils.getBytesFromAddress(address), key, value);\n        }\n\n        RemoteCallbackList<IBluetoothMetadataListener> list = mMetadataListeners.get(device);\n        if (list == null) {\n            return;\n        }\n        int n = list.beginBroadcast();\n        for (int i = 0; i < n; i++) {\n            try {\n                list.getBroadcastItem(i).onMetadataChanged(device, key, value);\n            } catch (RemoteException e) {\n                Log.d(TAG, \"metadataChanged() - Callback #\" + i + \" failed (\" + e + \")\");\n            }\n        }\n        list.finishBroadcast();\n    }\n\n    private int getIdleCurrentMa() {\n        return BluetoothProperties.getHardwareIdleCurrentMa().orElse(0);\n    }\n\n    private int getTxCurrentMa() {\n        return BluetoothProperties.getHardwareTxCurrentMa().orElse(0);\n    }\n\n    private int getRxCurrentMa() {\n        return BluetoothProperties.getHardwareRxCurrentMa().orElse(0);\n    }\n\n    private double getOperatingVolt() {\n        return BluetoothProperties.getHardwareOperatingVoltageMv().orElse(0) / 1000.0;\n    }\n\n    public RemoteDevices getRemoteDevices() {\n        return mRemoteDevices;\n    }\n\n    private String dumpScanMode(int scanMode) {\n        switch (scanMode) {\n            case SCAN_MODE_NONE:\n                return \"SCAN_MODE_NONE\";\n            case SCAN_MODE_CONNECTABLE:\n                return \"SCAN_MODE_CONNECTABLE\";\n            case SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return \"SCAN_MODE_CONNECTABLE_DISCOVERABLE\";\n            default:\n                return \"Unknown Scan Mode \" + scanMode;\n        }\n    }\n\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        if (args.length == 0) {\n            writer.println(\"Skipping dump in APP SERVICES, see bluetooth_manager section.\");\n            writer.println(\"Use --print argument for dumpsys direct from AdapterService.\");\n            return;\n        }\n\n        if (\"set-test-mode\".equals(args[0])) {\n            final boolean testModeEnabled = \"enabled\".equalsIgnoreCase(args[1]);\n            for (ProfileService profile : mRunningProfiles) {\n                profile.setTestModeEnabled(testModeEnabled);\n            }\n            if (Flags.scanManagerRefactor() && mScanController != null) {\n                mScanController.setTestModeEnabled(testModeEnabled);\n            }\n            mTestModeEnabled = testModeEnabled;\n            return;\n        }\n\n        Log.v(TAG, \"dumpsys arguments, check for protobuf output: \" + TextUtils.join(\" \", args));\n        if (args[0].equals(\"--proto-bin\")) {\n            dumpMetrics(fd);\n            return;\n        }\n\n        writer.println();\n        mAdapterProperties.dump(fd, writer, args);\n\n        writer.println(\"ScanMode: \" + dumpScanMode(getScanMode()));\n        writer.println(\"Scan Mode Changes:\");\n        for (String log : mScanModeChanges) {\n            writer.println(\"    \" + log);\n        }\n        writer.println();\n        writer.println(\"sSnoopLogSettingAtEnable = \" + sSnoopLogSettingAtEnable);\n        writer.println(\"sDefaultSnoopLogSettingAtEnable = \" + sDefaultSnoopLogSettingAtEnable);\n\n        writer.println();\n        writer.println(\"Enabled Profile Services:\");\n        for (int profileId : Config.getSupportedProfiles()) {\n            writer.println(\"  \" + BluetoothProfile.getProfileName(profileId));\n        }\n        writer.println();\n\n        mAdapterStateMachine.dump(fd, writer, args);\n\n        StringBuilder sb = new StringBuilder();\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dump(sb);\n        }\n        mSilenceDeviceManager.dump(fd, writer, args);\n        mDatabaseManager.dump(writer);\n\n        writer.write(sb.toString());\n        writer.flush();\n\n        final int currentState = mAdapterProperties.getState();\n        if (currentState == BluetoothAdapter.STATE_OFF\n                || currentState == BluetoothAdapter.STATE_BLE_TURNING_ON\n                || currentState == BluetoothAdapter.STATE_TURNING_OFF\n                || currentState == BluetoothAdapter.STATE_BLE_TURNING_OFF) {\n            writer.println();\n            writer.println(\n                    \"Impossible to dump native stack. state=\"\n                            + BluetoothAdapter.nameForState(currentState));\n            writer.println();\n        } else {\n            mNativeInterface.dump(fd, args);\n        }\n    }\n\n    private void dumpMetrics(FileDescriptor fd) {\n        BluetoothMetricsProto.BluetoothLog.Builder metricsBuilder =\n                BluetoothMetricsProto.BluetoothLog.newBuilder();\n        byte[] nativeMetricsBytes = mNativeInterface.dumpMetrics();\n        Log.d(TAG, \"dumpMetrics: native metrics size is \" + nativeMetricsBytes.length);\n        if (nativeMetricsBytes.length > 0) {\n            try {\n                metricsBuilder.mergeFrom(nativeMetricsBytes);\n            } catch (InvalidProtocolBufferException ex) {\n                Log.w(TAG, \"dumpMetrics: problem parsing metrics protobuf, \" + ex.getMessage());\n                return;\n            }\n        }\n        metricsBuilder.setNumBondedDevices(getBondedDevices().length);\n        MetricsLogger.dumpProto(metricsBuilder);\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dumpProto(metricsBuilder);\n        }\n        byte[] metricsBytes = Base64.encode(metricsBuilder.build().toByteArray(), Base64.DEFAULT);\n        Log.d(TAG, \"dumpMetrics: combined metrics size is \" + metricsBytes.length);\n        try (FileOutputStream protoOut = new FileOutputStream(fd)) {\n            protoOut.write(metricsBytes);\n        } catch (IOException e) {\n            Log.e(TAG, \"dumpMetrics: error writing combined protobuf to fd, \" + e.getMessage());\n        }\n    }\n\n    @SuppressLint(\"AndroidFrameworkRequiresPermission\")\n    private void enforceBluetoothPrivilegedPermissionIfNeeded(\n            OobData remoteP192Data, OobData remoteP256Data) {\n        if (remoteP192Data != null || remoteP256Data != null) {\n            this.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n        }\n    }\n\n    private final Object mDeviceConfigLock = new Object();\n\n    /**\n     * Predicate that can be applied to names to determine if a device is well-known to be used for\n     * physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<String> mLocationDenylistName = (v) -> false;\n\n    /**\n     * Predicate that can be applied to MAC addresses to determine if a device is well-known to be\n     * used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistMac = (v) -> false;\n\n    /**\n     * Predicate that can be applied to Advertising Data payloads to determine if a device is\n     * well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistAdvertisingData = (v) -> false;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanQuotaCount = DeviceConfigListener.DEFAULT_SCAN_QUOTA_COUNT;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanQuotaWindowMillis = DeviceConfigListener.DEFAULT_SCAN_QUOTA_WINDOW_MILLIS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanTimeoutMillis = DeviceConfigListener.DEFAULT_SCAN_TIMEOUT_MILLIS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanUpgradeDurationMillis =\n            DeviceConfigListener.DEFAULT_SCAN_UPGRADE_DURATION_MILLIS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanDowngradeDurationMillis =\n            DeviceConfigListener.DEFAULT_SCAN_DOWNGRADE_DURATION_BT_CONNECTING_MILLIS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private String mLeAudioAllowList;\n\n    public @NonNull Predicate<String> getLocationDenylistName() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistName;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistMac() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistMac;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistAdvertisingData() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistAdvertisingData;\n        }\n    }\n\n    /** Returns scan quota count. */\n    public int getScanQuotaCount() {\n        synchronized (mDeviceConfigLock) {\n            return mScanQuotaCount;\n        }\n    }\n\n    /** Returns scan quota window in millis. */\n    public long getScanQuotaWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScanQuotaWindowMillis;\n        }\n    }\n\n    /** Returns scan timeout in millis. */\n    public long getScanTimeoutMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScanTimeoutMillis;\n        }\n    }\n\n    /** Returns scan upgrade duration in millis. */\n    public long getScanUpgradeDurationMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScanUpgradeDurationMillis;\n        }\n    }\n\n    /** Returns scan downgrade duration in millis. */\n    public long getScanDowngradeDurationMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScanDowngradeDurationMillis;\n        }\n    }\n\n    /** Returns SCREEN_OFF_BALANCED scan window in millis. */\n    public int getScreenOffBalancedWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedWindowMillis;\n        }\n    }\n\n    /** Returns SCREEN_OFF_BALANCED scan interval in millis. */\n    public int getScreenOffBalancedIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedIntervalMillis;\n        }\n    }\n\n    /** Returns SCREEN_OFF low power scan window in millis. */\n    public int getScreenOffLowPowerWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerWindowMillis;\n        }\n    }\n\n    /** Returns SCREEN_OFF low power scan interval in millis. */\n    public int getScreenOffLowPowerIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerIntervalMillis;\n        }\n    }\n\n    private class DeviceConfigListener implements DeviceConfig.OnPropertiesChangedListener {\n        private static final String LOCATION_DENYLIST_NAME = \"location_denylist_name\";\n        private static final String LOCATION_DENYLIST_MAC = \"location_denylist_mac\";\n        private static final String LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"location_denylist_advertising_data\";\n        private static final String SCAN_QUOTA_COUNT = \"scan_quota_count\";\n        private static final String SCAN_QUOTA_WINDOW_MILLIS = \"scan_quota_window_millis\";\n        private static final String SCAN_TIMEOUT_MILLIS = \"scan_timeout_millis\";\n        private static final String SCAN_UPGRADE_DURATION_MILLIS = \"scan_upgrade_duration_millis\";\n        private static final String SCAN_DOWNGRADE_DURATION_MILLIS =\n                \"scan_downgrade_duration_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_WINDOW_MILLIS =\n                \"screen_off_low_power_window_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS =\n                \"screen_off_low_power_interval_millis\";\n        private static final String SCREEN_OFF_BALANCED_WINDOW_MILLIS =\n                \"screen_off_balanced_window_millis\";\n        private static final String SCREEN_OFF_BALANCED_INTERVAL_MILLIS =\n                \"screen_off_balanced_interval_millis\";\n        private static final String LE_AUDIO_ALLOW_LIST = \"le_audio_allow_list\";\n\n        /**\n         * Default denylist which matches Eddystone (except for Eddystone-E2EE-EID) and iBeacon\n         * payloads.\n         */\n        private static final String DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"\u22880016AAFE40/00FFFFFFF0,\u22860016AAFE/00FFFFFF,\u228600FF4C0002/00FFFFFFFF\";\n\n        private static final int DEFAULT_SCAN_QUOTA_COUNT = 5;\n        private static final long DEFAULT_SCAN_QUOTA_WINDOW_MILLIS = 30 * SECOND_IN_MILLIS;\n        private static final long DEFAULT_SCAN_TIMEOUT_MILLIS = 10 * MINUTE_IN_MILLIS;\n        private static final int DEFAULT_SCAN_UPGRADE_DURATION_MILLIS = (int) SECOND_IN_MILLIS * 6;\n        private static final int DEFAULT_SCAN_DOWNGRADE_DURATION_BT_CONNECTING_MILLIS =\n                (int) SECOND_IN_MILLIS * 6;\n\n        public void start() {\n            DeviceConfig.addOnPropertiesChangedListener(\n                    DeviceConfig.NAMESPACE_BLUETOOTH, BackgroundThread.getExecutor(), this);\n            onPropertiesChanged(DeviceConfig.getProperties(DeviceConfig.NAMESPACE_BLUETOOTH));\n        }\n\n        @Override\n        public void onPropertiesChanged(DeviceConfig.Properties properties) {\n            synchronized (mDeviceConfigLock) {\n                final String name = properties.getString(LOCATION_DENYLIST_NAME, null);\n                mLocationDenylistName =\n                        !TextUtils.isEmpty(name)\n                                ? Pattern.compile(name).asPredicate()\n                                : (v) -> false;\n                mLocationDenylistMac =\n                        BytesMatcher.decode(properties.getString(LOCATION_DENYLIST_MAC, null));\n                mLocationDenylistAdvertisingData =\n                        BytesMatcher.decode(\n                                properties.getString(\n                                        LOCATION_DENYLIST_ADVERTISING_DATA,\n                                        DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA));\n                mScanQuotaCount = properties.getInt(SCAN_QUOTA_COUNT, DEFAULT_SCAN_QUOTA_COUNT);\n                mScanQuotaWindowMillis =\n                        properties.getLong(\n                                SCAN_QUOTA_WINDOW_MILLIS, DEFAULT_SCAN_QUOTA_WINDOW_MILLIS);\n                mScanTimeoutMillis =\n                        properties.getLong(SCAN_TIMEOUT_MILLIS, DEFAULT_SCAN_TIMEOUT_MILLIS);\n                mScanUpgradeDurationMillis =\n                        properties.getInt(\n                                SCAN_UPGRADE_DURATION_MILLIS, DEFAULT_SCAN_UPGRADE_DURATION_MILLIS);\n                mScanDowngradeDurationMillis =\n                        properties.getInt(\n                                SCAN_DOWNGRADE_DURATION_MILLIS,\n                                DEFAULT_SCAN_DOWNGRADE_DURATION_BT_CONNECTING_MILLIS);\n                mScreenOffLowPowerWindowMillis =\n                        properties.getInt(\n                                SCREEN_OFF_LOW_POWER_WINDOW_MILLIS,\n                                ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS);\n                mScreenOffLowPowerIntervalMillis =\n                        properties.getInt(\n                                SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS,\n                                ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS);\n                mScreenOffBalancedWindowMillis =\n                        properties.getInt(\n                                SCREEN_OFF_BALANCED_WINDOW_MILLIS,\n                                ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS);\n                mScreenOffBalancedIntervalMillis =\n                        properties.getInt(\n                                SCREEN_OFF_BALANCED_INTERVAL_MILLIS,\n                                ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS);\n                mLeAudioAllowList = properties.getString(LE_AUDIO_ALLOW_LIST, \"\");\n\n                if (!mLeAudioAllowList.isEmpty()) {\n                    List<String> leAudioAllowlistFromDeviceConfig =\n                            Arrays.asList(mLeAudioAllowList.split(\",\"));\n                    BluetoothProperties.le_audio_allow_list(leAudioAllowlistFromDeviceConfig);\n                }\n\n                List<String> leAudioAllowlistProp = BluetoothProperties.le_audio_allow_list();\n                if (leAudioAllowlistProp != null && !leAudioAllowlistProp.isEmpty()) {\n                    mLeAudioAllowDevices.clear();\n                    mLeAudioAllowDevices.addAll(leAudioAllowlistProp);\n                }\n            }\n        }\n    }\n\n    /** A callback that will be called when AdapterState is changed */\n    public interface BluetoothStateCallback {\n        /**\n         * Called when the status of bluetooth adapter is changing. {@code prevState} and {@code\n         * newState} takes one of following values defined in BluetoothAdapter.java: STATE_OFF,\n         * STATE_TURNING_ON, STATE_ON, STATE_TURNING_OFF, STATE_BLE_TURNING_ON, STATE_BLE_ON,\n         * STATE_BLE_TURNING_OFF\n         *\n         * @param prevState the previous Bluetooth state.\n         * @param newState the new Bluetooth state.\n         */\n        void onBluetoothStateChange(int prevState, int newState);\n    }\n\n    /**\n     * Obfuscate Bluetooth MAC address into a PII free ID string\n     *\n     * @param device Bluetooth device whose MAC address will be obfuscated\n     * @return a byte array that is unique to this MAC address on this device, or empty byte array\n     *     when either device is null or obfuscateAddressNative fails\n     */\n    public byte[] obfuscateAddress(BluetoothDevice device) {\n        if (device == null) {\n            return new byte[0];\n        }\n        return mNativeInterface.obfuscateAddress(Utils.getByteAddress(device));\n    }\n\n    /**\n     * Get dynamic audio buffer size supported type\n     *\n     * @return support\n     *     <p>Possible values are {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_NONE}, {@link\n     *     BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_OFFLOAD}, {@link\n     *     BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_SOFTWARE_ENCODING}.\n     */\n    public int getDynamicBufferSupport() {\n        return mAdapterProperties.getDynamicBufferSupport();\n    }\n\n    /**\n     * Get dynamic audio buffer size\n     *\n     * @return BufferConstraints\n     */\n    public BufferConstraints getBufferConstraints() {\n        return mAdapterProperties.getBufferConstraints();\n    }\n\n    /**\n     * Set dynamic audio buffer size\n     *\n     * @param codec Audio codec\n     * @param value buffer millis\n     * @return true if the settings is successful, false otherwise\n     */\n    public boolean setBufferLengthMillis(int codec, int value) {\n        return mAdapterProperties.setBufferLengthMillis(codec, value);\n    }\n\n    /**\n     * Get an incremental id of Bluetooth metrics and log\n     *\n     * @param device Bluetooth device\n     * @return int of id for Bluetooth metrics and logging, 0 if the device is invalid\n     */\n    public int getMetricId(BluetoothDevice device) {\n        if (device == null) {\n            return 0;\n        }\n        return mNativeInterface.getMetricId(Utils.getByteAddress(device));\n    }\n\n    public CompanionManager getCompanionManager() {\n        return mBtCompanionManager;\n    }\n\n    /**\n     * Call for the AdapterService receives bond state change\n     *\n     * @param device Bluetooth device\n     * @param state bond state\n     */\n    public void onBondStateChanged(BluetoothDevice device, int state) {\n        if (mBtCompanionManager != null) {\n            mBtCompanionManager.onBondStateChanged(device, state);\n        }\n    }\n\n    /**\n     * Get audio policy feature support status\n     *\n     * @param device Bluetooth device to be checked for audio policy support\n     * @return int status of the remote support for audio policy feature\n     */\n    public int isRequestAudioPolicyAsSinkSupported(BluetoothDevice device) {\n        if (mHeadsetClientService != null) {\n            return mHeadsetClientService.getAudioPolicyRemoteSupported(device);\n        } else {\n            Log.e(TAG, \"No audio transport connected\");\n            return BluetoothStatusCodes.FEATURE_NOT_CONFIGURED;\n        }\n    }\n\n    /**\n     * Set audio policy for remote device\n     *\n     * @param device Bluetooth device to be set policy for\n     * @return int result status for requestAudioPolicyAsSink API\n     */\n    public int requestAudioPolicyAsSink(BluetoothDevice device, BluetoothSinkAudioPolicy policies) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n        }\n\n        if (mHeadsetClientService != null) {\n            if (isRequestAudioPolicyAsSinkSupported(device)\n                    != BluetoothStatusCodes.FEATURE_SUPPORTED) {\n                throw new UnsupportedOperationException(\n                        \"Request Audio Policy As Sink not supported\");\n            }\n            deviceProp.setHfAudioPolicyForRemoteAg(policies);\n            mHeadsetClientService.setAudioPolicy(device, policies);\n            return BluetoothStatusCodes.SUCCESS;\n        } else {\n            Log.e(TAG, \"HeadsetClient not connected\");\n            return BluetoothStatusCodes.ERROR_PROFILE_NOT_CONNECTED;\n        }\n    }\n\n    /**\n     * Get audio policy for remote device\n     *\n     * @param device Bluetooth device to be set policy for\n     * @return {@link BluetoothSinkAudioPolicy} policy stored for the device\n     */\n    public BluetoothSinkAudioPolicy getRequestedAudioPolicyAsSink(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return null;\n        }\n\n        if (mHeadsetClientService != null) {\n            return deviceProp.getHfAudioPolicyForRemoteAg();\n        } else {\n            Log.e(TAG, \"HeadsetClient not connected\");\n            return null;\n        }\n    }\n\n    /**\n     * Allow audio low latency\n     *\n     * @param allowed true if audio low latency is being allowed\n     * @param device device whose audio low latency will be allowed or disallowed\n     * @return boolean true if audio low latency is successfully allowed or disallowed\n     */\n    public boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n        return mNativeInterface.allowLowLatencyAudio(allowed, Utils.getByteAddress(device));\n    }\n\n    /**\n     * get remote PBAP PCE version.\n     *\n     * @param address of remote device\n     * @return int value other than 0 if remote PBAP PCE version is found\n     */\n    public int getRemotePbapPceVersion(String address) {\n        return mNativeInterface.getRemotePbapPceVersion(address);\n    }\n\n    /**\n     * check, if PBAP PSE dynamic version upgrade is enabled.\n     *\n     * @return true/false.\n     */\n    public boolean pbapPseDynamicVersionUpgradeIsEnabled() {\n        return mNativeInterface.pbapPseDynamicVersionUpgradeIsEnabled();\n    }\n\n    /** Sets the battery level of the remote device */\n    public void setBatteryLevel(BluetoothDevice device, int batteryLevel, boolean isBas) {\n        if (batteryLevel == BATTERY_LEVEL_UNKNOWN) {\n            mRemoteDevices.resetBatteryLevel(device, isBas);\n        } else {\n            mRemoteDevices.updateBatteryLevel(device, batteryLevel, isBas);\n        }\n    }\n\n    public boolean interopMatchAddr(InteropFeature feature, String address) {\n        return mNativeInterface.interopMatchAddr(feature.name(), address);\n    }\n\n    public boolean interopMatchName(InteropFeature feature, String name) {\n        return mNativeInterface.interopMatchName(feature.name(), name);\n    }\n\n    public boolean interopMatchAddrOrName(InteropFeature feature, String address) {\n        return mNativeInterface.interopMatchAddrOrName(feature.name(), address);\n    }\n\n    public void interopDatabaseAddAddr(InteropFeature feature, String address, int length) {\n        mNativeInterface.interopDatabaseAddRemoveAddr(true, feature.name(), address, length);\n    }\n\n    public void interopDatabaseRemoveAddr(InteropFeature feature, String address) {\n        mNativeInterface.interopDatabaseAddRemoveAddr(false, feature.name(), address, 0);\n    }\n\n    public void interopDatabaseAddName(InteropFeature feature, String name) {\n        mNativeInterface.interopDatabaseAddRemoveName(true, feature.name(), name);\n    }\n\n    public void interopDatabaseRemoveName(InteropFeature feature, String name) {\n        mNativeInterface.interopDatabaseAddRemoveName(false, feature.name(), name);\n    }\n\n    /**\n     * Checks the remote device is in the LE Audio allow list or not.\n     *\n     * @param device the device to check\n     * @return boolean true if the device is in the allow list, false otherwise.\n     */\n    public boolean isLeAudioAllowed(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n\n        if (deviceProp == null\n                || deviceProp.getModelName() == null\n                || !mLeAudioAllowDevices.contains(deviceProp.getModelName())) {\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get type of the remote device\n     *\n     * @param device the device to check\n     * @return int device type\n     */\n    public int getRemoteType(BluetoothDevice device) {\n        return mRemoteDevices.getType(device);\n    }\n\n    /**\n     * Sends service discovery UUIDs internally within the stack. This is meant to remove internal\n     * dependencies on the broadcast {@link BluetoothDevice#ACTION_UUID}.\n     *\n     * @param device is the remote device whose UUIDs have been discovered\n     * @param uuids are the services supported on the remote device\n     */\n    void sendUuidsInternal(BluetoothDevice device, ParcelUuid[] uuids) {\n        if (device == null) {\n            Log.w(TAG, \"sendUuidsInternal: null device\");\n            return;\n        }\n        if (uuids == null) {\n            Log.w(TAG, \"sendUuidsInternal: uuids is null\");\n            return;\n        }\n        Log.i(TAG, \"sendUuidsInternal: Received service discovery UUIDs for device \" + device);\n        for (int i = 0; i < uuids.length; i++) {\n            Log.d(TAG, \"sendUuidsInternal: index=\" + i + \" uuid=\" + uuids[i]);\n        }\n        if (mPhonePolicy != null) {\n            mPhonePolicy.onUuidsDiscovered(device, uuids);\n        }\n    }\n}\n```",
                                    "upstream_file_tokens": {
                                        "openai": 55948,
                                        "general": {
                                            "word_based": 19367,
                                            "char_based": 74792
                                        },
                                        "gemini": 65821
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.bluetooth.btservice;\n\nimport static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\nimport static android.text.format.DateUtils.MINUTE_IN_MILLIS;\nimport static android.text.format.DateUtils.SECOND_IN_MILLIS;\n\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveOrManagedUser;\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveUser;\nimport static com.android.bluetooth.Utils.enforceBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.enforceCdmAssociation;\nimport static com.android.bluetooth.Utils.enforceDumpPermission;\nimport static com.android.bluetooth.Utils.enforceLocalMacAddressPermission;\nimport static com.android.bluetooth.Utils.getBytesFromAddress;\nimport static com.android.bluetooth.Utils.hasBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.isPackageNameAccurate;\n\nimport android.annotation.NonNull;\nimport android.annotation.RequiresPermission;\nimport android.annotation.SuppressLint;\nimport android.app.AlarmManager;\nimport android.app.AppOpsManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.app.admin.DevicePolicyManager;\nimport android.bluetooth.BluetoothA2dp;\nimport android.bluetooth.BluetoothActivityEnergyInfo;\nimport android.bluetooth.BluetoothAdapter;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceProfile;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceUse;\nimport android.bluetooth.BluetoothClass;\nimport android.bluetooth.BluetoothDevice;\nimport android.bluetooth.BluetoothFrameworkInitializer;\nimport android.bluetooth.BluetoothMap;\nimport android.bluetooth.BluetoothProfile;\nimport android.bluetooth.BluetoothProtoEnums;\nimport android.bluetooth.BluetoothSap;\nimport android.bluetooth.BluetoothServerSocket;\nimport android.bluetooth.BluetoothSocket;\nimport android.bluetooth.BluetoothStatusCodes;\nimport android.bluetooth.BluetoothUuid;\nimport android.bluetooth.BufferConstraints;\nimport android.bluetooth.IBluetooth;\nimport android.bluetooth.IBluetoothActivityEnergyInfoListener;\nimport android.bluetooth.IBluetoothCallback;\nimport android.bluetooth.IBluetoothConnectionCallback;\nimport android.bluetooth.IBluetoothMetadataListener;\nimport android.bluetooth.IBluetoothOobDataCallback;\nimport android.bluetooth.IBluetoothSocketManager;\nimport android.bluetooth.IncomingRfcommSocketInfo;\nimport android.bluetooth.OobData;\nimport android.bluetooth.UidTraffic;\nimport android.companion.CompanionDeviceManager;\nimport android.content.AttributionSource;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.os.AsyncTask;\nimport android.os.BatteryStatsManager;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelUuid;\nimport android.os.PowerManager;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.DeviceConfig;\nimport android.provider.Settings;\nimport android.sysprop.BluetoothProperties;\nimport android.text.TextUtils;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.util.SparseArray;\n\nimport com.android.bluetooth.BluetoothMetricsProto;\nimport com.android.bluetooth.BluetoothStatsLog;\nimport com.android.bluetooth.R;\nimport com.android.bluetooth.Utils;\nimport com.android.bluetooth.a2dp.A2dpService;\nimport com.android.bluetooth.a2dpsink.A2dpSinkService;\nimport com.android.bluetooth.bas.BatteryService;\nimport com.android.bluetooth.bass_client.BassClientService;\nimport com.android.bluetooth.btservice.RemoteDevices.DeviceProperties;\nimport com.android.bluetooth.btservice.activityattribution.ActivityAttributionService;\nimport com.android.bluetooth.btservice.bluetoothkeystore.BluetoothKeystoreService;\nimport com.android.bluetooth.btservice.storage.DatabaseManager;\nimport com.android.bluetooth.btservice.storage.MetadataDatabase;\nimport com.android.bluetooth.csip.CsipSetCoordinatorService;\nimport com.android.bluetooth.gatt.GattService;\nimport com.android.bluetooth.gatt.ScanManager;\nimport com.android.bluetooth.hap.HapClientService;\nimport com.android.bluetooth.hearingaid.HearingAidService;\nimport com.android.bluetooth.hfp.HeadsetService;\nimport com.android.bluetooth.hfpclient.HeadsetClientService;\nimport com.android.bluetooth.hid.HidDeviceService;\nimport com.android.bluetooth.hid.HidHostService;\nimport com.android.bluetooth.le_audio.LeAudioService;\nimport com.android.bluetooth.map.BluetoothMapService;\nimport com.android.bluetooth.mapclient.MapClientService;\nimport com.android.bluetooth.pan.PanService;\nimport com.android.bluetooth.pbap.BluetoothPbapService;\nimport com.android.bluetooth.pbapclient.PbapClientService;\nimport com.android.bluetooth.sap.SapService;\nimport com.android.bluetooth.sdp.SdpManager;\nimport com.android.bluetooth.telephony.BluetoothInCallService;\nimport com.android.bluetooth.vc.VolumeControlService;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.modules.utils.BackgroundThread;\nimport com.android.modules.utils.BytesMatcher;\nimport com.android.modules.utils.SynchronousResultReceiver;\n\nimport com.google.protobuf.InvalidProtocolBufferException;\n\nimport libcore.util.SneakyThrow;\n\nimport java.io.FileDescriptor;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.time.Duration;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.function.Predicate;\nimport java.util.regex.Pattern;\n\npublic class AdapterService extends Service {\n    private static final String TAG = \"BluetoothAdapterService\";\n    private static final boolean DBG = true;\n    private static final boolean VERBOSE = false;\n    private static final int MIN_ADVT_INSTANCES_FOR_MA = 5;\n    private static final int MIN_OFFLOADED_FILTERS = 10;\n    private static final int MIN_OFFLOADED_SCAN_STORAGE_BYTES = 1024;\n    private static final Duration PENDING_SOCKET_HANDOFF_TIMEOUT = Duration.ofMinutes(1);\n\n    private final Object mEnergyInfoLock = new Object();\n    private int mStackReportedState;\n    private long mTxTimeTotalMs;\n    private long mRxTimeTotalMs;\n    private long mIdleTimeTotalMs;\n    private long mEnergyUsedTotalVoltAmpSecMicro;\n    private final SparseArray<UidTraffic> mUidTraffic = new SparseArray<>();\n\n    private final ArrayList<String> mStartedProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRegisteredProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRunningProfiles = new ArrayList<>();\n\n    public static final String ACTION_LOAD_ADAPTER_PROPERTIES =\n            \"com.android.bluetooth.btservice.action.LOAD_ADAPTER_PROPERTIES\";\n    public static final String ACTION_SERVICE_STATE_CHANGED =\n            \"com.android.bluetooth.btservice.action.STATE_CHANGED\";\n    public static final String EXTRA_ACTION = \"action\";\n    public static final int PROFILE_CONN_REJECTED = 2;\n\n    private static final String ACTION_ALARM_WAKEUP =\n            \"com.android.bluetooth.btservice.action.ALARM_WAKEUP\";\n\n    static final String BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY = \"persist.bluetooth.btsnooplogmode\";\n    static final String BLUETOOTH_BTSNOOP_DEFAULT_MODE_PROPERTY =\n            \"persist.bluetooth.btsnoopdefaultmode\";\n    private String mSnoopLogSettingAtEnable = \"empty\";\n    private String mDefaultSnoopLogSettingAtEnable = \"empty\";\n\n    public static final String BLUETOOTH_PRIVILEGED =\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED;\n    static final String BLUETOOTH_PERM = android.Manifest.permission.BLUETOOTH;\n    static final String LOCAL_MAC_ADDRESS_PERM = android.Manifest.permission.LOCAL_MAC_ADDRESS;\n    static final String RECEIVE_MAP_PERM = android.Manifest.permission.RECEIVE_BLUETOOTH_MAP;\n\n    private static final String PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"phonebook_access_permission\";\n    private static final String MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"message_access_permission\";\n    private static final String SIM_ACCESS_PERMISSION_PREFERENCE_FILE = \"sim_access_permission\";\n\n    private static final int CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS = 30;\n\n    public static final String ACTIVITY_ATTRIBUTION_NO_ACTIVE_DEVICE_ADDRESS =\n            \"no_active_device_address\";\n\n    // Report ID definition\n    public enum BqrQualityReportId {\n        QUALITY_REPORT_ID_MONITOR_MODE(0x01),\n        QUALITY_REPORT_ID_APPROACH_LSTO(0x02),\n        QUALITY_REPORT_ID_A2DP_AUDIO_CHOPPY(0x03),\n        QUALITY_REPORT_ID_SCO_VOICE_CHOPPY(0x04),\n        QUALITY_REPORT_ID_ROOT_INFLAMMATION(0x05),\n        QUALITY_REPORT_ID_LMP_LL_MESSAGE_TRACE(0x11),\n        QUALITY_REPORT_ID_BT_SCHEDULING_TRACE(0x12),\n        QUALITY_REPORT_ID_CONTROLLER_DBG_INFO(0x13);\n\n        private final int value;\n        private BqrQualityReportId(int value) {\n            this.value = value;\n        }\n        public int getValue() {\n            return value;\n        }\n    };\n\n    private final ArrayList<DiscoveringPackage> mDiscoveringPackages = new ArrayList<>();\n\n    static {\n        classInitNative();\n    }\n\n    private static AdapterService sAdapterService;\n\n    public static synchronized AdapterService getAdapterService() {\n        return sAdapterService;\n    }\n\n    private static synchronized void setAdapterService(AdapterService instance) {\n        Log.d(TAG, \"setAdapterService() - trying to set service to \" + instance);\n        if (instance == null) {\n            return;\n        }\n        sAdapterService = instance;\n    }\n\n    private static synchronized void clearAdapterService(AdapterService current) {\n        if (sAdapterService == current) {\n            sAdapterService = null;\n        }\n    }\n\n    private BluetoothAdapter mAdapter;\n    private AdapterProperties mAdapterProperties;\n    private AdapterState mAdapterStateMachine;\n    private BondStateMachine mBondStateMachine;\n    private JniCallbacks mJniCallbacks;\n    private RemoteDevices mRemoteDevices;\n\n    /* TODO: Consider to remove the search API from this class, if changed to use call-back */\n    private SdpManager mSdpManager = null;\n\n    private boolean mNativeAvailable;\n    private boolean mCleaningUp;\n    private final HashMap<BluetoothDevice, ArrayList<IBluetoothMetadataListener>>\n            mMetadataListeners = new HashMap<>();\n    private final HashMap<String, Integer> mProfileServicesState = new HashMap<String, Integer>();\n    private Set<IBluetoothConnectionCallback> mBluetoothConnectionCallbacks = new HashSet<>();\n    //Only BluetoothManagerService should be registered\n    private RemoteCallbackList<IBluetoothCallback> mCallbacks;\n    private int mCurrentRequestId;\n    private boolean mQuietmode = false;\n    private HashMap<String, CallerInfo> mBondAttemptCallerInfo = new HashMap<>();\n\n    private final Map<UUID, RfcommListenerData> mBluetoothServerSockets = new ConcurrentHashMap<>();\n    private final Executor mSocketServersExecutor = r -> new Thread(r).start();\n\n    private AlarmManager mAlarmManager;\n    private PendingIntent mPendingAlarm;\n    private BatteryStatsManager mBatteryStatsManager;\n    private PowerManager mPowerManager;\n    private PowerManager.WakeLock mWakeLock;\n    private String mWakeLockName;\n    private UserManager mUserManager;\n    private CompanionDeviceManager mCompanionDeviceManager;\n\n    private PhonePolicy mPhonePolicy;\n    private ActiveDeviceManager mActiveDeviceManager;\n    private DatabaseManager mDatabaseManager;\n    private SilenceDeviceManager mSilenceDeviceManager;\n    private AppOpsManager mAppOps;\n\n    private BluetoothSocketManagerBinder mBluetoothSocketManagerBinder;\n\n    private BluetoothKeystoreService mBluetoothKeystoreService;\n    private A2dpService mA2dpService;\n    private A2dpSinkService mA2dpSinkService;\n    private ActivityAttributionService mActivityAttributionService;\n    private HeadsetService mHeadsetService;\n    private HeadsetClientService mHeadsetClientService;\n    private BluetoothMapService mMapService;\n    private MapClientService mMapClientService;\n    private HidDeviceService mHidDeviceService;\n    private HidHostService mHidHostService;\n    private PanService mPanService;\n    private BluetoothPbapService mPbapService;\n    private PbapClientService mPbapClientService;\n    private HearingAidService mHearingAidService;\n    private HapClientService mHapClientService;\n    private SapService mSapService;\n    private VolumeControlService mVolumeControlService;\n    private CsipSetCoordinatorService mCsipSetCoordinatorService;\n    private LeAudioService mLeAudioService;\n    private BassClientService mBassClientService;\n    private BatteryService mBatteryService;\n\n    private volatile boolean mTestModeEnabled = false;\n\n    private MetricsLogger mMetricsLogger;\n\n    /**\n     * Register a {@link ProfileService} with AdapterService.\n     *\n     * @param profile the service being added.\n     */\n    public void addProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_REGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Unregister a ProfileService with AdapterService.\n     *\n     * @param profile the service being removed.\n     */\n    public void removeProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_UNREGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Notify AdapterService that a ProfileService has started or stopped.\n     *\n     * @param profile the service being removed.\n     * @param state {@link BluetoothAdapter#STATE_ON} or {@link BluetoothAdapter#STATE_OFF}\n     */\n    public void onProfileServiceStateChanged(ProfileService profile, int state) {\n        if (state != BluetoothAdapter.STATE_ON && state != BluetoothAdapter.STATE_OFF) {\n            throw new IllegalArgumentException(BluetoothAdapter.nameForState(state));\n        }\n        Message m = mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_STATE_CHANGED);\n        m.obj = profile;\n        m.arg1 = state;\n        mHandler.sendMessage(m);\n    }\n\n    /**\n     * Confirm whether the ProfileService is started expectedly.\n     *\n     * @param serviceSampleName the service simple name.\n     * @return true if the service is started expectedly, false otherwise.\n     */\n    public boolean isStartedProfile(String serviceSampleName) {\n        return mStartedProfiles.contains(serviceSampleName);\n    }\n\n    private static final int MESSAGE_PROFILE_SERVICE_STATE_CHANGED = 1;\n    private static final int MESSAGE_PROFILE_SERVICE_REGISTERED = 2;\n    private static final int MESSAGE_PROFILE_SERVICE_UNREGISTERED = 3;\n\n    class AdapterServiceHandler extends Handler {\n        @Override\n        public void handleMessage(Message msg) {\n            verboseLog(\"handleMessage() - Message: \" + msg.what);\n\n            switch (msg.what) {\n                case MESSAGE_PROFILE_SERVICE_STATE_CHANGED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_STATE_CHANGED\");\n                    processProfileServiceStateChanged((ProfileService) msg.obj, msg.arg1);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_REGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_REGISTERED\");\n                    registerProfileService((ProfileService) msg.obj);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_UNREGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_UNREGISTERED\");\n                    unregisterProfileService((ProfileService) msg.obj);\n                    break;\n            }\n        }\n\n        private void registerProfileService(ProfileService profile) {\n            if (mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" already registered.\");\n                return;\n            }\n            mRegisteredProfiles.add(profile);\n        }\n\n        private void unregisterProfileService(ProfileService profile) {\n            if (!mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" not registered (UNREGISTER).\");\n                return;\n            }\n            mRegisteredProfiles.remove(profile);\n        }\n\n        private void processProfileServiceStateChanged(ProfileService profile, int state) {\n            switch (state) {\n                case BluetoothAdapter.STATE_ON:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_ON).\");\n                        return;\n                    }\n                    if (mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" already running.\");\n                        return;\n                    }\n                    mRunningProfiles.add(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT starting triggers hardware\n                    // initializtion. Configuring a device without GATT causes start up failures.\n                    if (GattService.class.getSimpleName().equals(profile.getName())) {\n                        enableNative();\n                    } else if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                            && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n                        mAdapterProperties.onBluetoothReady();\n                        updateUuids();\n                        setBluetoothClassFromConfig();\n                        initProfileServices();\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS_BLE);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_DYNAMIC_AUDIO_BUFFER);\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n                    }\n                    break;\n                case BluetoothAdapter.STATE_OFF:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_OFF).\");\n                        return;\n                    }\n                    if (!mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not running.\");\n                        return;\n                    }\n                    mRunningProfiles.remove(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT is expected to be the only\n                    // profile available in the \"BLE ON\" state. If only GATT is left, send\n                    // BREDR_STOPPED. If GATT is stopped, deinitialize the hardware.\n                    if ((mRunningProfiles.size() == 1 && (GattService.class.getSimpleName()\n                            .equals(mRunningProfiles.get(0).getName())))) {\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n                    } else if (mRunningProfiles.size() == 0) {\n                        disableNative();\n                    }\n                    break;\n                default:\n                    Log.e(TAG, \"Unhandled profile state: \" + state);\n            }\n        }\n    }\n\n    private final AdapterServiceHandler mHandler = new AdapterServiceHandler();\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        initMetricsLogger();\n        debugLog(\"onCreate()\");\n        mDeviceConfigListener.start();\n        mRemoteDevices = new RemoteDevices(this, Looper.getMainLooper());\n        mRemoteDevices.init();\n        clearDiscoveringPackages();\n        mBinder = new AdapterServiceBinder(this);\n        mAdapter = BluetoothAdapter.getDefaultAdapter();\n        mAdapterProperties = new AdapterProperties(this);\n        mAdapterStateMachine = AdapterState.make(this);\n        mJniCallbacks = new JniCallbacks(this, mAdapterProperties);\n        mBluetoothKeystoreService = new BluetoothKeystoreService(isCommonCriteriaMode());\n        mBluetoothKeystoreService.start();\n        int configCompareResult = mBluetoothKeystoreService.getCompareResult();\n\n        // Start tracking Binder latency for the bluetooth process.\n        BluetoothFrameworkInitializer.initializeBinderCallsStats(getApplicationContext());\n\n        // Android TV doesn't show consent dialogs for just works and encryption only le pairing\n        boolean isAtvDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_LEANBACK_ONLY);\n        mUserManager = getSystemService(UserManager.class);\n        initNative(mUserManager.isGuestUser(), isCommonCriteriaMode(), configCompareResult,\n                getInitFlags(), isAtvDevice, getApplicationInfo().dataDir);\n        mNativeAvailable = true;\n        mCallbacks = new RemoteCallbackList<IBluetoothCallback>();\n        mAppOps = getSystemService(AppOpsManager.class);\n        //Load the name and address\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDADDR);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDNAME);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_CLASS_OF_DEVICE);\n        mAlarmManager = getSystemService(AlarmManager.class);\n        mPowerManager = getSystemService(PowerManager.class);\n        mBatteryStatsManager = getSystemService(BatteryStatsManager.class);\n        mCompanionDeviceManager = getSystemService(CompanionDeviceManager.class);\n\n        mBluetoothKeystoreService.initJni();\n\n        mSdpManager = SdpManager.init(this);\n        registerReceiver(mAlarmBroadcastReceiver, new IntentFilter(ACTION_ALARM_WAKEUP));\n\n        mDatabaseManager = new DatabaseManager(this);\n        mDatabaseManager.start(MetadataDatabase.createDatabase(this));\n\n        boolean isAutomotiveDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_AUTOMOTIVE);\n\n        /*\n         * Phone policy is specific to phone implementations and hence if a device wants to exclude\n         * it out then it can be disabled by using the flag below. Phone policy is never used on\n         * Android Automotive OS builds, in favor of a policy currently located in\n         * CarBluetoothService.\n         */\n        if (!isAutomotiveDevice && getResources().getBoolean(R.bool.enable_phone_policy)) {\n            Log.i(TAG, \"Phone policy enabled\");\n            mPhonePolicy = new PhonePolicy(this, new ServiceFactory());\n            mPhonePolicy.start();\n        } else {\n            Log.i(TAG, \"Phone policy disabled\");\n        }\n\n        mActiveDeviceManager = new ActiveDeviceManager(this, new ServiceFactory());\n        mActiveDeviceManager.start();\n\n        mSilenceDeviceManager = new SilenceDeviceManager(this, new ServiceFactory(),\n                Looper.getMainLooper());\n        mSilenceDeviceManager.start();\n\n        mBluetoothSocketManagerBinder = new BluetoothSocketManagerBinder(this);\n\n        mActivityAttributionService = new ActivityAttributionService();\n        mActivityAttributionService.start();\n\n        setAdapterService(this);\n\n        invalidateBluetoothCaches();\n\n        // First call to getSharedPreferences will result in a file read into\n        // memory cache. Call it here asynchronously to avoid potential ANR\n        // in the future\n        new AsyncTask<Void, Void, Void>() {\n            @Override\n            protected Void doInBackground(Void... params) {\n                getSharedPreferences(PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(SIM_ACCESS_PERMISSION_PREFERENCE_FILE, Context.MODE_PRIVATE);\n                return null;\n            }\n        }.execute();\n\n        try {\n            int systemUiUid = getApplicationContext()\n                    .createContextAsUser(UserHandle.SYSTEM, /* flags= */ 0)\n                    .getPackageManager()\n                    .getPackageUid(\"com.android.systemui\", PackageManager.MATCH_SYSTEM_ONLY);\n\n            Utils.setSystemUiUid(systemUiUid);\n        } catch (PackageManager.NameNotFoundException e) {\n            // Some platforms, such as wearables do not have a system ui.\n            Log.w(TAG, \"Unable to resolve SystemUI's UID.\", e);\n        }\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        debugLog(\"onBind()\");\n        return mBinder;\n    }\n\n    @Override\n    public boolean onUnbind(Intent intent) {\n        debugLog(\"onUnbind() - calling cleanup\");\n        cleanup();\n        return super.onUnbind(intent);\n    }\n\n    @Override\n    public void onDestroy() {\n        debugLog(\"onDestroy()\");\n        if (!isMock()) {\n            // TODO(b/27859763)\n            Log.i(TAG, \"Force exit to cleanup internal state in Bluetooth stack\");\n            System.exit(0);\n        }\n    }\n\n    private boolean initMetricsLogger() {\n        if (mMetricsLogger != null) {\n            return false;\n        }\n        mMetricsLogger = MetricsLogger.getInstance();\n        return mMetricsLogger.init(this);\n    }\n\n    private boolean closeMetricsLogger() {\n        if (mMetricsLogger == null) {\n            return false;\n        }\n        boolean result = mMetricsLogger.close();\n        mMetricsLogger = null;\n        return result;\n    }\n\n    public void setMetricsLogger(MetricsLogger metricsLogger) {\n        mMetricsLogger = metricsLogger;\n    }\n\n    void bringUpBle() {\n        debugLog(\"bleOnProcessStart()\");\n\n        if (getResources().getBoolean(\n                R.bool.config_bluetooth_reload_supported_profiles_when_enabled)) {\n            Config.init(getApplicationContext());\n        }\n\n        // Reset |mRemoteDevices| whenever BLE is turned off then on\n        // This is to replace the fact that |mRemoteDevices| was\n        // reinitialized in previous code.\n        //\n        // TODO(apanicke): The reason is unclear but\n        // I believe it is to clear the variable every time BLE was\n        // turned off then on. The same effect can be achieved by\n        // calling cleanup but this may not be necessary at all\n        // We should figure out why this is needed later\n        mRemoteDevices.reset();\n        mAdapterProperties.init(mRemoteDevices);\n\n        debugLog(\"bleOnProcessStart() - Make Bond State Machine\");\n        mBondStateMachine = BondStateMachine.make(this, mAdapterProperties, mRemoteDevices);\n\n        mJniCallbacks.init(mBondStateMachine, mRemoteDevices);\n\n        mBatteryStatsManager.reportBleScanReset();\n        BluetoothStatsLog.write_non_chained(BluetoothStatsLog.BLE_SCAN_STATE_CHANGED, -1, null,\n                BluetoothStatsLog.BLE_SCAN_STATE_CHANGED__STATE__RESET, false, false, false);\n\n        // TODO(b/228875190): GATT is assumed supported. As a result, we don't respect the\n        // configuration sysprop. Configuring a device without GATT, although rare, will cause stack\n        // start up errors yielding init loops.\n        if (!GattService.isEnabled()) {\n            Log.w(TAG,\n                    \"GATT is configured off but the stack assumes it to be enabled. Start anyway.\");\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_ON);\n    }\n\n    void bringDownBle() {\n        stopGattProfileService();\n    }\n\n    void stateChangeCallback(int status) {\n        if (status == AbstractionLayer.BT_STATE_OFF) {\n            debugLog(\"stateChangeCallback: disableNative() completed\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        } else if (status == AbstractionLayer.BT_STATE_ON) {\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STARTED);\n        } else {\n            Log.e(TAG, \"Incorrect status \" + status + \" in stateChangeCallback\");\n        }\n    }\n\n    /**\n     * Sets the Bluetooth CoD value of the local adapter if there exists a config value for it.\n     */\n    void setBluetoothClassFromConfig() {\n        int bluetoothClassConfig = retrieveBluetoothClassConfig();\n        if (bluetoothClassConfig != 0) {\n            mAdapterProperties.setBluetoothClass(new BluetoothClass(bluetoothClassConfig));\n        }\n    }\n\n    private int retrieveBluetoothClassConfig() {\n        return Settings.Global.getInt(\n                getContentResolver(), Settings.Global.BLUETOOTH_CLASS_OF_DEVICE, 0);\n    }\n\n    void startProfileServices() {\n        debugLog(\"startCoreServices()\");\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no other profiles then just\n        // move on to BREDR_STARTED. Note that configuring GATT to NOT supported will cause adapter\n        // initialization failures\n        if (supportedProfileServices.length == 1 && GattService.class.getSimpleName()\n                .equals(supportedProfileServices[0].getSimpleName())) {\n            mAdapterProperties.onBluetoothReady();\n            updateUuids();\n            setBluetoothClassFromConfig();\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_ON);\n        }\n    }\n\n    void stopProfileServices() {\n        // Make sure to stop classic background tasks now\n        cancelDiscoveryNative();\n        mAdapterProperties.setScanMode(AbstractionLayer.BT_SCAN_MODE_NONE);\n\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no profiles then just move on\n        // to BREDR_STOPPED\n        if (supportedProfileServices.length == 1 && (mRunningProfiles.size() == 1\n                && GattService.class.getSimpleName().equals(mRunningProfiles.get(0).getName()))) {\n            debugLog(\"stopProfileServices() - No profiles services to stop or already stopped.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_OFF);\n        }\n    }\n\n    private void stopGattProfileService() {\n        mAdapterProperties.onBleDisable();\n        if (mRunningProfiles.size() == 0) {\n            debugLog(\"stopGattProfileService() - No profiles services to stop.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_OFF);\n    }\n\n    private void invalidateBluetoothGetStateCache() {\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n    }\n\n    void updateLeAudioProfileServiceState() {\n        HashSet<Class> nonSupportedProfiles = new HashSet<>();\n\n        if (!isLeConnectedIsochronousStreamCentralSupported()) {\n            nonSupportedProfiles.addAll(Config.geLeAudioUnicastProfiles());\n        }\n\n        if (!isLeAudioBroadcastAssistantSupported()) {\n            nonSupportedProfiles.add(BassClientService.class);\n        }\n\n        if (isLeAudioBroadcastSourceSupported()) {\n            Config.addSupportedProfile(BluetoothProfile.LE_AUDIO_BROADCAST);\n        }\n\n        if (!nonSupportedProfiles.isEmpty()) {\n            // Remove non-supported profiles from the supported list\n            // since the controller doesn't support\n            Config.removeProfileFromSupportedList(nonSupportedProfiles);\n\n            // Disable the non-supported profiles service\n            for (Class profileService : nonSupportedProfiles) {\n                if (isStartedProfile(profileService.getSimpleName())) {\n                    setProfileServiceState(profileService, BluetoothAdapter.STATE_OFF);\n                }\n            }\n        }\n    }\n\n    void updateAdapterState(int prevState, int newState) {\n        mAdapterProperties.setState(newState);\n        invalidateBluetoothGetStateCache();\n        if (mCallbacks != null) {\n            int n = mCallbacks.beginBroadcast();\n            debugLog(\"updateAdapterState() - Broadcasting state \" + BluetoothAdapter.nameForState(\n                    newState) + \" to \" + n + \" receivers.\");\n            for (int i = 0; i < n; i++) {\n                try {\n                    mCallbacks.getBroadcastItem(i).onBluetoothStateChange(prevState, newState);\n                } catch (RemoteException e) {\n                    debugLog(\"updateAdapterState() - Callback #\" + i + \" failed (\" + e + \")\");\n                }\n            }\n            mCallbacks.finishBroadcast();\n        }\n\n        // Turn the Adapter all the way off if we are disabling and the snoop log setting changed.\n        if (newState == BluetoothAdapter.STATE_BLE_TURNING_ON) {\n            mSnoopLogSettingAtEnable =\n                    SystemProperties.get(BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY, \"empty\");\n            mDefaultSnoopLogSettingAtEnable =\n                    Settings.Global.getString(getContentResolver(),\n                            Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n            BluetoothProperties.snoop_default_mode(\n                    BluetoothProperties.snoop_default_mode_values.DISABLED);\n            for (BluetoothProperties.snoop_default_mode_values value :\n                    BluetoothProperties.snoop_default_mode_values.values()) {\n                if (value.getPropValue().equals(mDefaultSnoopLogSettingAtEnable)) {\n                    BluetoothProperties.snoop_default_mode(value);\n                }\n            }\n        } else if (newState == BluetoothAdapter.STATE_BLE_ON\n                   && prevState != BluetoothAdapter.STATE_OFF) {\n            String snoopLogSetting =\n                    SystemProperties.get(BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY, \"empty\");\n            String snoopDefaultModeSetting =\n                    Settings.Global.getString(getContentResolver(),\n                            Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n\n            if (!TextUtils.equals(mSnoopLogSettingAtEnable, snoopLogSetting)\n                    || !TextUtils.equals(mDefaultSnoopLogSettingAtEnable,\n                            snoopDefaultModeSetting)) {\n                mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n            }\n        }\n    }\n\n    void linkQualityReportCallback(\n            long timestamp,\n            int reportId,\n            int rssi,\n            int snr,\n            int retransmissionCount,\n            int packetsNotReceiveCount,\n            int negativeAcknowledgementCount) {\n        BluetoothInCallService bluetoothInCallService = BluetoothInCallService.getInstance();\n\n        if (reportId == BqrQualityReportId.QUALITY_REPORT_ID_SCO_VOICE_CHOPPY.getValue()) {\n            if (bluetoothInCallService == null) {\n                Log.w(TAG, \"No BluetoothInCallService while trying to send BQR.\"\n                        + \" timestamp: \" + timestamp + \" reportId: \" + reportId\n                        + \" rssi: \" + rssi + \" snr: \" + snr\n                        + \" retransmissionCount: \" + retransmissionCount\n                        + \" packetsNotReceiveCount: \" + packetsNotReceiveCount\n                        + \" negativeAcknowledgementCount: \" + negativeAcknowledgementCount);\n                return;\n            }\n            bluetoothInCallService.sendBluetoothCallQualityReport(\n                    timestamp, rssi, snr, retransmissionCount,\n                    packetsNotReceiveCount, negativeAcknowledgementCount);\n        }\n    }\n\n    void switchBufferSizeCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            errorLog(\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n        }\n\n        // Send intent to fastpair\n        Intent switchBufferSizeIntent = new Intent(BluetoothDevice.ACTION_SWITCH_BUFFER_SIZE);\n        switchBufferSizeIntent.setClassName(\n                getString(com.android.bluetooth.R.string.peripheral_link_package),\n                getString(com.android.bluetooth.R.string.peripheral_link_package)\n                        + getString(com.android.bluetooth.R.string.peripheral_link_service));\n        switchBufferSizeIntent.putExtra(BluetoothDevice.EXTRA_DEVICE, activeDevices.get(0));\n        switchBufferSizeIntent.putExtra(\n                BluetoothDevice.EXTRA_LOW_LATENCY_BUFFER_SIZE, isLowLatencyBufferSize);\n        sendBroadcast(switchBufferSizeIntent);\n    }\n\n    void switchCodecCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            errorLog(\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n            return;\n        }\n        mA2dpService.switchCodecByBufferSize(activeDevices.get(0), isLowLatencyBufferSize);\n    }\n\n    void cleanup() {\n        debugLog(\"cleanup()\");\n        if (mCleaningUp) {\n            errorLog(\"cleanup() - Service already starting to cleanup, ignoring request...\");\n            return;\n        }\n\n        closeMetricsLogger();\n\n        clearAdapterService(this);\n\n        mCleaningUp = true;\n        invalidateBluetoothCaches();\n\n        unregisterReceiver(mAlarmBroadcastReceiver);\n\n        stopRfcommServerSockets();\n\n        if (mPendingAlarm != null) {\n            mAlarmManager.cancel(mPendingAlarm);\n            mPendingAlarm = null;\n        }\n\n        // This wake lock release may also be called concurrently by\n        // {@link #releaseWakeLock(String lockName)}, so a synchronization is needed here.\n        synchronized (this) {\n            if (mWakeLock != null) {\n                if (mWakeLock.isHeld()) {\n                    mWakeLock.release();\n                }\n                mWakeLock = null;\n            }\n        }\n\n        if (mDatabaseManager != null) {\n            mDatabaseManager.cleanup();\n        }\n\n        if (mAdapterStateMachine != null) {\n            mAdapterStateMachine.doQuit();\n        }\n\n        if (mBondStateMachine != null) {\n            mBondStateMachine.doQuit();\n        }\n\n        if (mRemoteDevices != null) {\n            mRemoteDevices.cleanup();\n        }\n\n        if (mSdpManager != null) {\n            mSdpManager.cleanup();\n            mSdpManager = null;\n        }\n\n        if (mActivityAttributionService != null) {\n            mActivityAttributionService.cleanup();\n        }\n\n        if (mNativeAvailable) {\n            debugLog(\"cleanup() - Cleaning up adapter native\");\n            cleanupNative();\n            mNativeAvailable = false;\n        }\n\n        if (mAdapterProperties != null) {\n            mAdapterProperties.cleanup();\n        }\n\n        if (mJniCallbacks != null) {\n            mJniCallbacks.cleanup();\n        }\n\n        if (mBluetoothKeystoreService != null) {\n            debugLog(\"cleanup(): mBluetoothKeystoreService.cleanup()\");\n            mBluetoothKeystoreService.cleanup();\n        }\n\n        if (mPhonePolicy != null) {\n            mPhonePolicy.cleanup();\n        }\n\n        if (mSilenceDeviceManager != null) {\n            mSilenceDeviceManager.cleanup();\n        }\n\n        if (mActiveDeviceManager != null) {\n            mActiveDeviceManager.cleanup();\n        }\n\n        if (mProfileServicesState != null) {\n            mProfileServicesState.clear();\n        }\n\n        if (mBluetoothSocketManagerBinder != null) {\n            mBluetoothSocketManagerBinder.cleanUp();\n            mBluetoothSocketManagerBinder = null;\n        }\n\n        if (mBinder != null) {\n            mBinder.cleanup();\n            mBinder = null;  //Do not remove. Otherwise Binder leak!\n        }\n\n        if (mCallbacks != null) {\n            mCallbacks.kill();\n        }\n    }\n\n    private void invalidateBluetoothCaches() {\n        BluetoothAdapter.invalidateGetProfileConnectionStateCache();\n        BluetoothAdapter.invalidateIsOffloadedFilteringSupportedCache();\n        BluetoothDevice.invalidateBluetoothGetBondStateCache();\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n        BluetoothAdapter.invalidateGetAdapterConnectionStateCache();\n        BluetoothMap.invalidateBluetoothGetConnectionStateCache();\n        BluetoothSap.invalidateBluetoothGetConnectionStateCache();\n    }\n\n    private void setProfileServiceState(Class service, int state) {\n        if (state == BluetoothAdapter.STATE_ON) {\n            mStartedProfiles.add(service.getSimpleName());\n        } else if (state == BluetoothAdapter.STATE_OFF) {\n            mStartedProfiles.remove(service.getSimpleName());\n        }\n        Intent intent = new Intent(this, service);\n        intent.putExtra(EXTRA_ACTION, ACTION_SERVICE_STATE_CHANGED);\n        intent.putExtra(BluetoothAdapter.EXTRA_STATE, state);\n        startService(intent);\n    }\n\n    private void setAllProfileServiceStates(Class[] services, int state) {\n        for (Class service : services) {\n            // TODO(b/228875190): GATT is assumed supported and treated differently as part of the\n            // \"BLE ON\" state, despite GATT not being BLE specific.\n            if (GattService.class.getSimpleName().equals(service.getSimpleName())) {\n                continue;\n            }\n            setProfileServiceState(service, state);\n        }\n    }\n\n    /**\n     * Verifies whether the profile is supported by the local bluetooth adapter by checking a\n     * bitmask of its supported profiles\n     *\n     * @param remoteDeviceUuids is an array of all supported profiles by the remote device\n     * @param localDeviceUuids  is an array of all supported profiles by the local device\n     * @param profile           is the profile we are checking for support\n     * @param device            is the remote device we wish to connect to\n     * @return true if the profile is supported by both the local and remote device, false otherwise\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    private boolean isSupported(ParcelUuid[] localDeviceUuids, ParcelUuid[] remoteDeviceUuids,\n            int profile, BluetoothDevice device) {\n        if (remoteDeviceUuids == null || remoteDeviceUuids.length == 0) {\n            Log.e(TAG, \"isSupported: Remote Device Uuids Empty\");\n        }\n\n        if (profile == BluetoothProfile.HEADSET) {\n            return (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HSP_AG)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HSP))\n                    || (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP_AG)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP));\n        }\n        if (profile == BluetoothProfile.HEADSET_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP_AG)\n                    && Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP);\n        }\n        if (profile == BluetoothProfile.A2DP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SINK);\n        }\n        if (profile == BluetoothProfile.A2DP_SINK) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SOURCE);\n        }\n        if (profile == BluetoothProfile.OPP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.OBEX_OBJECT_PUSH);\n        }\n        if (profile == BluetoothProfile.HID_HOST) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HID)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HOGP);\n        }\n        if (profile == BluetoothProfile.HID_DEVICE) {\n            return mHidDeviceService.getConnectionState(device)\n                    == BluetoothProfile.STATE_DISCONNECTED;\n        }\n        if (profile == BluetoothProfile.PAN) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.NAP);\n        }\n        if (profile == BluetoothProfile.MAP) {\n            return mMapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.PBAP) {\n            return mPbapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.MAP_CLIENT) {\n            return true;\n        }\n        if (profile == BluetoothProfile.PBAP_CLIENT) {\n            return Utils.arrayContains(localDeviceUuids, BluetoothUuid.PBAP_PCE)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.PBAP_PSE);\n        }\n        if (profile == BluetoothProfile.HEARING_AID) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HEARING_AID);\n        }\n        if (profile == BluetoothProfile.SAP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.SAP);\n        }\n        if (profile == BluetoothProfile.VOLUME_CONTROL) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.VOLUME_CONTROL);\n        }\n        if (profile == BluetoothProfile.CSIP_SET_COORDINATOR) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.COORDINATED_SET);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.LE_AUDIO);\n        }\n        if (profile == BluetoothProfile.HAP_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HAS);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BASS);\n        }\n        if (profile == BluetoothProfile.BATTERY) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BATTERY);\n        }\n\n        Log.e(TAG, \"isSupported: Unexpected profile passed in to function: \" + profile);\n        return false;\n    }\n\n    /**\n     * Checks if any profile is enabled for the given device\n     *\n     * @param device is the device for which we are checking if any profiles are enabled\n     * @return true if any profile is enabled, false otherwise\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    boolean isAnyProfileEnabled(BluetoothDevice device) {\n        if (mA2dpService != null && mA2dpService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mA2dpSinkService != null && mA2dpSinkService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHeadsetService != null && mHeadsetService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHeadsetClientService != null && mHeadsetClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mMapClientService != null && mMapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHidHostService != null && mHidHostService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mPanService != null && mPanService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mPbapClientService != null && mPbapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHearingAidService != null && mHearingAidService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHapClientService != null && mHapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mVolumeControlService != null && mVolumeControlService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mCsipSetCoordinatorService != null\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mLeAudioService != null && mLeAudioService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mBassClientService != null && mBassClientService.getConnectionPolicy(device)\n                 > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mBatteryService != null && mBatteryService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Connects only available profiles\n     * (those with {@link BluetoothProfile#CONNECTION_POLICY_ALLOWED})\n     *\n     * @param device is the device with which we are connecting the profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS}\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    private int connectEnabledProfiles(BluetoothDevice device) {\n        ParcelUuid[] remoteDeviceUuids = getRemoteUuids(device);\n        ParcelUuid[] localDeviceUuids = mAdapterProperties.getUuids();\n\n        if (mA2dpService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP, device) && mA2dpService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp\");\n            mA2dpService.connect(device);\n        }\n        if (mA2dpSinkService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP_SINK, device) && mA2dpSinkService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.connect(device);\n        }\n        if (mHeadsetService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET, device) && mHeadsetService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Headset Profile\");\n            mHeadsetService.connect(device);\n        }\n        if (mHeadsetClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET_CLIENT, device)\n                && mHeadsetClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HFP\");\n            mHeadsetClientService.connect(device);\n        }\n        if (mMapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.MAP_CLIENT, device)\n                && mMapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting MAP\");\n            mMapClientService.connect(device);\n        }\n        if (mHidHostService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HID_HOST, device) && mHidHostService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hid Host Profile\");\n            mHidHostService.connect(device);\n        }\n        if (mPanService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PAN, device) && mPanService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pan Profile\");\n            mPanService.connect(device);\n        }\n        if (mPbapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PBAP_CLIENT, device)\n                && mPbapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pbap\");\n            mPbapClientService.connect(device);\n        }\n        if (mHearingAidService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEARING_AID, device)\n                && mHearingAidService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hearing Aid Profile\");\n            mHearingAidService.connect(device);\n        }\n        if (mHapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HAP_CLIENT, device)\n                && mHapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HAS Profile\");\n            mHapClientService.connect(device);\n        }\n        if (mVolumeControlService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.VOLUME_CONTROL, device)\n                && mVolumeControlService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.connect(device);\n        }\n        if (mCsipSetCoordinatorService != null\n                && isSupported(localDeviceUuids, remoteDeviceUuids,\n                        BluetoothProfile.CSIP_SET_COORDINATOR, device)\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.connect(device);\n        }\n        if (mLeAudioService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO, device)\n                && mLeAudioService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.connect(device);\n        }\n        if (mBassClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT, device)\n                && mBassClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.connect(device);\n        }\n        if (mBatteryService != null\n                && isSupported(\n                        localDeviceUuids, remoteDeviceUuids, BluetoothProfile.BATTERY, device)\n                && mBatteryService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Battery Service\");\n            mBatteryService.connect(device);\n        }\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Verifies that all bluetooth profile services are running\n     *\n     * @return true if all bluetooth profile services running, false otherwise\n     */\n    private boolean profileServicesRunning() {\n        if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n            return true;\n        }\n\n        Log.e(TAG, \"profileServicesRunning: One or more supported services not running\");\n        return false;\n    }\n\n    /**\n     * Initializes all the profile services fields\n     */\n    private void initProfileServices() {\n        Log.i(TAG, \"initProfileServices: Initializing all bluetooth profile services\");\n        mA2dpService = A2dpService.getA2dpService();\n        mA2dpSinkService = A2dpSinkService.getA2dpSinkService();\n        mHeadsetService = HeadsetService.getHeadsetService();\n        mHeadsetClientService = HeadsetClientService.getHeadsetClientService();\n        mMapService = BluetoothMapService.getBluetoothMapService();\n        mMapClientService = MapClientService.getMapClientService();\n        mHidDeviceService = HidDeviceService.getHidDeviceService();\n        mHidHostService = HidHostService.getHidHostService();\n        mPanService = PanService.getPanService();\n        mPbapService = BluetoothPbapService.getBluetoothPbapService();\n        mPbapClientService = PbapClientService.getPbapClientService();\n        mHearingAidService = HearingAidService.getHearingAidService();\n        mHapClientService = HapClientService.getHapClientService();\n        mSapService = SapService.getSapService();\n        mVolumeControlService = VolumeControlService.getVolumeControlService();\n        mCsipSetCoordinatorService = CsipSetCoordinatorService.getCsipSetCoordinatorService();\n        mLeAudioService = LeAudioService.getLeAudioService();\n        mBassClientService = BassClientService.getBassClientService();\n        mBatteryService = BatteryService.getBatteryService();\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    private int startRfcommListener(\n            String name,\n            ParcelUuid uuid,\n            PendingIntent pendingIntent,\n            AttributionSource attributionSource) {\n        if (mBluetoothServerSockets.containsKey(uuid.getUuid())) {\n            Log.d(TAG, String.format(\n                        \"Cannot start RFCOMM listener: UUID %s already in use.\", uuid.getUuid()));\n            return BluetoothStatusCodes.RFCOMM_LISTENER_START_FAILED_UUID_IN_USE;\n        }\n\n        try {\n            startRfcommListenerInternal(name, uuid.getUuid(), pendingIntent, attributionSource);\n        } catch (IOException e) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CREATE_SERVER_SOCKET;\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    private int stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            Log.d(TAG, String.format(\n                        \"Cannot stop RFCOMM listener: UUID %s is not registered.\", uuid.getUuid()));\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n        }\n\n        if (attributionSource.getUid() != listenerData.mAttributionSource.getUid()) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n        }\n\n        // Remove the entry so that it does not try and restart the server socket.\n        mBluetoothServerSockets.remove(uuid.getUuid());\n\n        return listenerData.closeServerAndPendingSockets(mHandler);\n    }\n\n    private IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n            ParcelUuid uuid, AttributionSource attributionSource) {\n        IncomingRfcommSocketInfo socketInfo = new IncomingRfcommSocketInfo();\n\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            socketInfo.status =\n                    BluetoothStatusCodes\n                            .RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n            return socketInfo;\n        }\n\n        if (attributionSource.getUid() != listenerData.mAttributionSource.getUid()) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n            return socketInfo;\n        }\n\n        BluetoothSocket socket = listenerData.mPendingSockets.poll();\n\n        if (socket == null) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_NO_SOCKET_AVAILABLE;\n            return socketInfo;\n        }\n\n        mHandler.removeCallbacksAndMessages(socket);\n\n        socketInfo.bluetoothDevice = socket.getRemoteDevice();\n        socketInfo.pfd = socket.getParcelFileDescriptor();\n        socketInfo.status = BluetoothStatusCodes.SUCCESS;\n\n        return socketInfo;\n    }\n\n    private void handleIncomingRfcommConnections(UUID uuid) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid);\n        for (;;) {\n            BluetoothSocket socket;\n            try {\n                socket = listenerData.mServerSocket.accept();\n            } catch (IOException e) {\n                if (mBluetoothServerSockets.containsKey(uuid)) {\n                    // The uuid still being in the map indicates that the accept failure is\n                    // unexpected. Try and restart the listener.\n                    Log.e(TAG, \"Failed to accept socket on \" + listenerData.mServerSocket, e);\n                    restartRfcommListener(listenerData, uuid);\n                }\n                return;\n            }\n\n            listenerData.mPendingSockets.add(socket);\n            try {\n                listenerData.mPendingIntent.send();\n            } catch (PendingIntent.CanceledException e) {\n                Log.e(TAG, \"PendingIntent for RFCOMM socket notifications cancelled.\", e);\n                // The pending intent was cancelled, close the server as there is no longer any way\n                // to notify the app that registered the listener.\n                listenerData.closeServerAndPendingSockets(mHandler);\n                mBluetoothServerSockets.remove(uuid);\n                return;\n            }\n            mHandler.postDelayed(\n                    () -> pendingSocketTimeoutRunnable(listenerData, socket),\n                    socket,\n                    PENDING_SOCKET_HANDOFF_TIMEOUT.toMillis());\n        }\n    }\n\n    // Tries to restart the rfcomm listener for the given UUID\n    private void restartRfcommListener(RfcommListenerData listenerData, UUID uuid) {\n        listenerData.closeServerAndPendingSockets(mHandler);\n        try {\n            startRfcommListenerInternal(\n                    listenerData.mName,\n                    uuid,\n                    listenerData.mPendingIntent,\n                    listenerData.mAttributionSource);\n        } catch (IOException e) {\n            Log.e(TAG, \"Failed to recreate rfcomm server socket\", e);\n\n            mBluetoothServerSockets.remove(uuid);\n        }\n    }\n\n    private void pendingSocketTimeoutRunnable(\n            RfcommListenerData listenerData, BluetoothSocket socket) {\n        boolean socketFound = listenerData.mPendingSockets.remove(socket);\n        if (socketFound) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to close bt socket\", e);\n                // We don't care if closing the socket failed, just continue on.\n            }\n        }\n    }\n\n    private void startRfcommListenerInternal(\n            String name, UUID uuid, PendingIntent intent, AttributionSource attributionSource)\n            throws IOException {\n        BluetoothServerSocket bluetoothServerSocket =\n                mAdapter.listenUsingRfcommWithServiceRecord(name, uuid);\n\n        RfcommListenerData listenerData =\n                new RfcommListenerData(bluetoothServerSocket, name, intent, attributionSource);\n\n        mBluetoothServerSockets.put(uuid, listenerData);\n\n        mSocketServersExecutor.execute(() -> handleIncomingRfcommConnections(uuid));\n    }\n\n    private void stopRfcommServerSockets() {\n        Iterator<Map.Entry<UUID, RfcommListenerData>> socketsIterator =\n                mBluetoothServerSockets.entrySet().iterator();\n        while (socketsIterator.hasNext()) {\n            socketsIterator.next().getValue().closeServerAndPendingSockets(mHandler);\n            socketsIterator.remove();\n        }\n    }\n\n    private static class RfcommListenerData {\n        final BluetoothServerSocket mServerSocket;\n        // Service record name\n        final String mName;\n        // The Intent which contains the Service info to which the incoming socket connections are\n        // handed off to.\n        final PendingIntent mPendingIntent;\n        // AttributionSource for the requester of the RFCOMM listener\n        final AttributionSource mAttributionSource;\n        // Contains the connected sockets which are pending transfer to the app which requested the\n        // listener.\n        final ConcurrentLinkedQueue<BluetoothSocket> mPendingSockets =\n                new ConcurrentLinkedQueue<>();\n\n        RfcommListenerData(\n                BluetoothServerSocket serverSocket,\n                String name,\n                PendingIntent pendingIntent,\n                AttributionSource attributionSource) {\n            mServerSocket = serverSocket;\n            mName = name;\n            mPendingIntent = pendingIntent;\n            mAttributionSource = attributionSource;\n        }\n\n        int closeServerAndPendingSockets(Handler handler) {\n            int result = BluetoothStatusCodes.SUCCESS;\n            try {\n                mServerSocket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to call close on rfcomm server socket\", e);\n                result = BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CLOSE_SERVER_SOCKET;\n            }\n            mPendingSockets.forEach(\n                    pendingSocket -> {\n                        handler.removeCallbacksAndMessages(pendingSocket);\n                        try {\n                            pendingSocket.close();\n                        } catch (IOException e) {\n                            Log.e(TAG, \"Failed to close socket\", e);\n                        }\n                    });\n            mPendingSockets.clear();\n\n            return result;\n        }\n    }\n\n    private boolean isAvailable() {\n        return !mCleaningUp;\n    }\n\n    /**\n     * Handlers for incoming service calls\n     */\n    private AdapterServiceBinder mBinder;\n\n    /**\n     * The Binder implementation must be declared to be a static class, with\n     * the AdapterService instance passed in the constructor. Furthermore,\n     * when the AdapterService shuts down, the reference to the AdapterService\n     * must be explicitly removed.\n     *\n     * Otherwise, a memory leak can occur from repeated starting/stopping the\n     * service...Please refer to android.os.Binder for further details on\n     * why an inner instance class should be avoided.\n     *\n     */\n    @VisibleForTesting\n    public static class AdapterServiceBinder extends IBluetooth.Stub {\n        private AdapterService mService;\n\n        AdapterServiceBinder(AdapterService svc) {\n            mService = svc;\n            mService.invalidateBluetoothGetStateCache();\n            BluetoothAdapter.getDefaultAdapter().disableBluetoothGetStateCache();\n        }\n\n        public void cleanup() {\n            mService = null;\n        }\n\n        public AdapterService getService() {\n            if (mService != null && mService.isAvailable()) {\n                return mService;\n            }\n            return null;\n        }\n\n        @Override\n        public void getState(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getState());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getState() {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_OFF;\n            }\n\n            return service.getState();\n        }\n\n        @Override\n        public void enable(boolean quietMode, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(enable(quietMode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean enable(boolean quietMode, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"enable\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService enable\")) {\n                return false;\n            }\n\n            return service.enable(quietMode);\n        }\n\n        @Override\n        public void disable(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(disable(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean disable(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"disable\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService disable\")) {\n                return false;\n            }\n\n            return service.disable();\n        }\n\n        @Override\n        public String getAddress() {\n            if (mService == null) {\n                return null;\n            }\n            return getAddressWithAttribution(Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getAddressWithAttribution(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getAddressWithAttribution(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getAddressWithAttribution(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getAddress\")) {\n                return null;\n            }\n\n            enforceLocalMacAddressPermission(service);\n\n            return Utils.getAddressStringFromByte(service.mAdapterProperties.getAddress());\n        }\n\n        @Override\n        public void getUuids(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getUuids(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<ParcelUuid> getUuids(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getUuids\")) {\n                return new ArrayList<>();\n            }\n\n            ParcelUuid[] parcels = service.mAdapterProperties.getUuids();\n            if (parcels == null) {\n                parcels = new ParcelUuid[0];\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public void getIdentityAddress(String address, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getIdentityAddress(address));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public String getIdentityAddress(String address) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getIdentityAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, Utils.getCallingAttributionSource(mService),\n                                \"AdapterService getIdentityAddress\")) {\n                return null;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.getIdentityAddress(address);\n        }\n\n        @Override\n        public void getName(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getName(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getName(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getName\")) {\n                return null;\n            }\n\n            return service.getName();\n        }\n\n        @Override\n        public void getNameLengthForAdvertise(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getNameLengthForAdvertise(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getNameLengthForAdvertise(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getNameLengthForAdvertise\")\n                    || !Utils.checkAdvertisePermissionForDataDelivery(\n                            service, attributionSource, TAG)) {\n                return -1;\n            }\n\n            return service.getNameLengthForAdvertise();\n        }\n\n        @Override\n        public void setName(String name, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setName(name, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setName(String name, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setName\")) {\n                return false;\n            }\n\n            return service.mAdapterProperties.setName(name);\n        }\n\n        @Override\n        public void getBluetoothClass(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBluetoothClass(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private BluetoothClass getBluetoothClass(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getBluetoothClass\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterSource getBluetoothClass\")) {\n                return null;\n            }\n\n            return service.mAdapterProperties.getBluetoothClass();\n        }\n\n        @Override\n        public void setBluetoothClass(BluetoothClass bluetoothClass, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setBluetoothClass(bluetoothClass, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setBluetoothClass(BluetoothClass bluetoothClass, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!service.mAdapterProperties.setBluetoothClass(bluetoothClass)) {\n              return false;\n            }\n\n            return Settings.Global.putInt(\n                    service.getContentResolver(),\n                    Settings.Global.BLUETOOTH_CLASS_OF_DEVICE,\n                    bluetoothClass.getClassOfDevice());\n        }\n\n        @Override\n        public void getIoCapability(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getIoCapability(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getIoCapability(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getIoCapability\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getIoCapability\")) {\n                return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;\n            }\n\n            return service.mAdapterProperties.getIoCapability();\n        }\n\n        @Override\n        public void setIoCapability(int capability, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setIoCapability(capability, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setIoCapability(int capability, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!isValidIoCapability(capability)) {\n              return false;\n            }\n\n            return service.mAdapterProperties.setIoCapability(capability);\n        }\n\n        @Override\n        public void getLeIoCapability(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getLeIoCapability(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getLeIoCapability(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getLeIoCapability\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getLeIoCapability\")) {\n                return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;\n            }\n\n            return service.mAdapterProperties.getLeIoCapability();\n        }\n\n        @Override\n        public void setLeIoCapability(int capability, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setLeIoCapability(capability, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setLeIoCapability(int capability, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!isValidIoCapability(capability)) {\n              return false;\n            }\n\n            return service.mAdapterProperties.setLeIoCapability(capability);\n        }\n\n        @Override\n        public void getScanMode(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getScanMode(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        int getScanMode(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getScanMode\")) {\n                return BluetoothAdapter.SCAN_MODE_NONE;\n            }\n\n            return service.mAdapterProperties.getScanMode();\n        }\n\n        @Override\n        public void setScanMode(int mode, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setScanMode(mode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setScanMode(int mode, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setScanMode\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.setScanMode(convertScanModeToHal(mode))\n                    ? BluetoothStatusCodes.SUCCESS : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public void getDiscoverableTimeout(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getDiscoverableTimeout(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getDiscoverableTimeout(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getDiscoverableTimeout\")) {\n                return -1;\n            }\n\n            return service.mAdapterProperties.getDiscoverableTimeout();\n        }\n\n        @Override\n        public void setDiscoverableTimeout(long timeout, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setDiscoverableTimeout(timeout, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setDiscoverableTimeout(long timeout, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setDiscoverableTimeout\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.setDiscoverableTimeout((int) timeout)\n                    ? BluetoothStatusCodes.SUCCESS : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public void startDiscovery(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(startDiscovery(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean startDiscovery(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"startDiscovery\")) {\n                return false;\n            }\n\n            if (!Utils.checkScanPermissionForDataDelivery(\n                    service, attributionSource, \"Starting discovery.\")) {\n                return false;\n            }\n\n            return service.startDiscovery(attributionSource);\n        }\n\n        @Override\n        public void cancelDiscovery(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(cancelDiscovery(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean cancelDiscovery(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"cancelDiscovery\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService cancelDiscovery\")) {\n                return false;\n            }\n\n            service.debugLog(\"cancelDiscovery\");\n            return service.cancelDiscoveryNative();\n        }\n\n        @Override\n        public void isDiscovering(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isDiscovering(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isDiscovering(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"isDiscovering\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService isDiscovering\")) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isDiscovering();\n        }\n\n        @Override\n        public void getDiscoveryEndMillis(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getDiscoveryEndMillis(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getDiscoveryEndMillis(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return -1;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.discoveryEndMillis();\n        }\n\n        @Override\n        public void getMostRecentlyConnectedDevices(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMostRecentlyConnectedDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getMostRecentlyConnectedDevices(\n                AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMostRecentlyConnectedDevices\")) {\n                return new ArrayList<>();\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mDatabaseManager.getMostRecentlyConnectedDevices();\n        }\n\n        @Override\n        public void getBondedDevices(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBondedDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getBondedDevices(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getBondedDevices\")) {\n                return new ArrayList<>();\n            }\n\n            return Arrays.asList(service.getBondedDevices());\n        }\n\n        @Override\n        public void getAdapterConnectionState(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getAdapterConnectionState());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getAdapterConnectionState() {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getConnectionState();\n        }\n\n        /**\n         * This method has an associated binder cache.  The invalidation\n         * methods must be changed if the logic behind this method changes.\n         */\n        @Override\n        public void getProfileConnectionState(int profile, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getProfileConnectionState(profile));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getProfileConnectionState(int profile) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getProfileConnectionState\")) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getProfileConnectionState(profile);\n        }\n\n        @Override\n        public void createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n                OobData remoteP256Data, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(createBond(device, transport, remoteP192Data, remoteP256Data,\n                            source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n                OobData remoteP256Data, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"createBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService createBond\")) {\n                return false;\n            }\n\n            // This conditional is required to satisfy permission dependencies\n            // since createBond calls createBondOutOfBand with null value passed as data.\n            // BluetoothDevice#createBond requires BLUETOOTH_ADMIN only.\n            service.enforceBluetoothPrivilegedPermissionIfNeeded(remoteP192Data, remoteP256Data);\n\n            return service.createBond(device, transport, remoteP192Data, remoteP256Data,\n                    attributionSource.getPackageName());\n        }\n\n        @Override\n        public void cancelBondProcess(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(cancelBondProcess(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean cancelBondProcess(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"cancelBondProcess\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService cancelBondProcess\")) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp != null) {\n                deviceProp.setBondingInitiatedLocally(false);\n            }\n\n            return service.cancelBondNative(getBytesFromAddress(device.getAddress()));\n        }\n\n        @Override\n        public void removeBond(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(removeBond(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean removeBond(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"removeBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService removeBond\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || deviceProp.getBondState() != BluetoothDevice.BOND_BONDED) {\n                return false;\n            }\n            service.mBondAttemptCallerInfo.remove(device.getAddress());\n            deviceProp.setBondingInitiatedLocally(false);\n\n            Message msg = service.mBondStateMachine.obtainMessage(BondStateMachine.REMOVE_BOND);\n            msg.obj = device;\n            service.mBondStateMachine.sendMessage(msg);\n            return true;\n        }\n\n        @Override\n        public void getBondState(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBondState(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getBondState(BluetoothDevice device, AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getBondState\")) {\n                return BluetoothDevice.BOND_NONE;\n            }\n\n            return service.getBondState(device);\n        }\n\n        @Override\n        public void isBondingInitiatedLocally(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isBondingInitiatedLocally(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isBondingInitiatedLocally(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService isBondingInitiatedLocally\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null && deviceProp.isBondingInitiatedLocally();\n        }\n\n        @Override\n        public void generateLocalOobData(int transport, IBluetoothOobDataCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                generateLocalOobData(transport, callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private void generateLocalOobData(int transport, IBluetoothOobDataCallback callback,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveOrManagedUser(service, TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            service.generateLocalOobData(transport, callback);\n        }\n\n        @Override\n        public void getSupportedProfiles(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSupportedProfiles(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getSupportedProfiles(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return 0;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return Config.getSupportedProfilesBitMask();\n        }\n\n        @Override\n        public int getConnectionState(BluetoothDevice device) {\n            if (mService == null) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n            return getConnectionStateWithAttribution(device,\n                        Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getConnectionStateWithAttribution(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getConnectionStateWithAttribution(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public int getConnectionStateWithAttribution(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getConnectionState\")) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n\n            return service.getConnectionState(device);\n        }\n\n        @Override\n        public void canBondWithoutDialog(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(canBondWithoutDialog(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean canBondWithoutDialog(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.canBondWithoutDialog(device);\n        }\n\n        @Override\n        public void removeActiveDevice(@ActiveDeviceUse int profiles,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(removeActiveDevice(profiles, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean removeActiveDevice(@ActiveDeviceUse int profiles,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            return service.setActiveDevice(null, profiles);\n        }\n\n        @Override\n        public void setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setActiveDevice(device, profiles, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.setActiveDevice(device, profiles);\n        }\n\n        @Override\n        public void getActiveDevices(@ActiveDeviceProfile int profile,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getActiveDevices(profile, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getActiveDevices(@ActiveDeviceProfile int profile,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return new ArrayList<>();\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.getActiveDevices(profile);\n        }\n\n        @Override\n        public void connectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(connectAllEnabledProfiles(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int connectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"connectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            try {\n                return service.connectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"connectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public void disconnectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(disconnectAllEnabledProfiles(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int disconnectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"disconnectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            try {\n                return service.disconnectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"disconnectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public void getRemoteName(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteName(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getRemoteName(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteName\")) {\n                return null;\n            }\n\n            return service.getRemoteName(device);\n        }\n\n        @Override\n        public void getRemoteType(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteType(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getRemoteType(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteType\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteType\")) {\n                return BluetoothDevice.DEVICE_TYPE_UNKNOWN;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null\n                    ? deviceProp.getDeviceType() : BluetoothDevice.DEVICE_TYPE_UNKNOWN;\n        }\n\n        @Override\n        public String getRemoteAlias(BluetoothDevice device) {\n            if (mService == null) {\n                return null;\n            }\n            return getRemoteAliasWithAttribution(device,\n                    Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getRemoteAliasWithAttribution(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteAliasWithAttribution(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getRemoteAliasWithAttribution(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteAlias\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteAlias\")) {\n                return null;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null ? deviceProp.getAlias() : null;\n        }\n\n        @Override\n        public void setRemoteAlias(BluetoothDevice device, String name, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setRemoteAlias(device, name, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setRemoteAlias(BluetoothDevice device, String name,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"setRemoteAlias\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (name != null && name.isEmpty()) {\n                throw new IllegalArgumentException(\"alias cannot be the empty string\");\n            }\n\n            if (!hasBluetoothPrivilegedPermission(service)) {\n                if (!Utils.checkConnectPermissionForDataDelivery(\n                        service, attributionSource, \"AdapterService setRemoteAlias\")) {\n                    return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n                }\n                enforceCdmAssociation(service.mCompanionDeviceManager, service,\n                        attributionSource.getPackageName(), Binder.getCallingUid(), device);\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n            }\n            deviceProp.setAlias(device, name);\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public void getRemoteClass(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteClass(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getRemoteClass(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteClass\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteClass\")) {\n                return 0;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null ? deviceProp.getBluetoothClass() : 0;\n        }\n\n        @Override\n        public void getRemoteUuids(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteUuids(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<ParcelUuid> getRemoteUuids(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteUuids\")) {\n                return new ArrayList<>();\n            }\n\n            ParcelUuid[] parcels = service.getRemoteUuids(device);\n            if (parcels == null) {\n                return null;\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public boolean fetchRemoteUuids(BluetoothDevice device) {\n            if (mService == null) {\n                return false;\n            }\n            return fetchRemoteUuidsWithAttribution(device, TRANSPORT_AUTO,\n                    Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void fetchRemoteUuidsWithAttribution(BluetoothDevice device, int transport,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(fetchRemoteUuidsWithAttribution(device, transport, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean fetchRemoteUuidsWithAttribution(\n                BluetoothDevice device, int transport, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"fetchRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService fetchRemoteUuids\")) {\n                return false;\n            }\n            if (transport != TRANSPORT_AUTO) {\n                enforceBluetoothPrivilegedPermission(service);\n            }\n\n            service.mRemoteDevices.fetchUuids(device, transport);\n            return true;\n        }\n\n        @Override\n        public void setPin(BluetoothDevice device, boolean accept, int len, byte[] pinCode,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPin(device, accept, len, pinCode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPin(BluetoothDevice device, boolean accept, int len, byte[] pinCode,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setPin\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setPin\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            // Only allow setting a pin in bonding state, or bonded state in case of security\n            // upgrade.\n            if (deviceProp == null || !deviceProp.isBondingOrBonded()) {\n                return false;\n            }\n            if (pinCode.length != len) {\n                android.util.EventLog.writeEvent(0x534e4554, \"139287605\", -1,\n                        \"PIN code length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(device, accept,\n                    BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_PIN_REPLIED);\n            return service.pinReplyNative(\n                    getBytesFromAddress(device.getAddress()), accept, len, pinCode);\n        }\n\n        @Override\n        public void setPasskey(BluetoothDevice device, boolean accept, int len, byte[] passkey,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPasskey(device, accept, len, passkey, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPasskey(BluetoothDevice device, boolean accept, int len, byte[] passkey,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setPasskey\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setPasskey\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                return false;\n            }\n            if (passkey.length != len) {\n                android.util.EventLog.writeEvent(0x534e4554, \"139287605\", -1,\n                        \"Passkey length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            return service.sspReplyNative(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_ENTRY,\n                    accept,\n                    Utils.byteArrayToInt(passkey));\n        }\n\n        @Override\n        public void setPairingConfirmation(BluetoothDevice device, boolean accept,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPairingConfirmation(device, accept, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPairingConfirmation(BluetoothDevice device, boolean accept,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                return false;\n            }\n            service.logUserBondResponse(device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            return service.sspReplyNative(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_CONFIRMATION,\n                    accept,\n                    0);\n        }\n\n        @Override\n        public void getSilenceMode(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSilenceMode(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean getSilenceMode(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mSilenceDeviceManager.getSilenceMode(device);\n        }\n\n        @Override\n        public void setSilenceMode(BluetoothDevice device, boolean silence,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setSilenceMode(device, silence, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setSilenceMode(BluetoothDevice device, boolean silence,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mSilenceDeviceManager.setSilenceMode(device, silence);\n            return true;\n        }\n\n        @Override\n        public void getPhonebookAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getPhonebookAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getPhonebookAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getPhonebookAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getPhonebookAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setPhonebookAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPhonebookAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPhonebookAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setPhonebookAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public void getMessageAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMessageAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getMessageAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getMessageAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMessageAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setMessageAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setMessageAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setMessageAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setMessageAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public void getSimAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSimAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getSimAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getSimAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getSimAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setSimAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setSimAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setSimAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setSimAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public IBluetoothSocketManager getSocketManager() {\n            AdapterService service = getService();\n            if (service == null) {\n                return null;\n            }\n\n            return IBluetoothSocketManager.Stub.asInterface(service.mBluetoothSocketManagerBinder);\n        }\n\n        @Override\n        public void sdpSearch(BluetoothDevice device, ParcelUuid uuid, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(sdpSearch(device, uuid, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean sdpSearch(\n                BluetoothDevice device, ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"sdpSearch\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService sdpSearch\")) {\n                return false;\n            }\n\n            if (service.mSdpManager == null) {\n                return false;\n            }\n            service.mSdpManager.sdpSearch(device, uuid);\n            return true;\n        }\n\n        @Override\n        public void getBatteryLevel(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBatteryLevel(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getBatteryLevel(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getBatteryLevel\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getBatteryLevel\")) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n            return deviceProp.getBatteryLevel();\n        }\n\n        @Override\n        public void getMaxConnectedAudioDevices(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMaxConnectedAudioDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getMaxConnectedAudioDevices(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMaxConnectedAudioDevices\")) {\n                return -1;\n            }\n\n            return service.getMaxConnectedAudioDevices();\n        }\n\n        //@Override\n        @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)\n        public void isA2dpOffloadEnabled(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isA2dpOffloadEnabled(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isA2dpOffloadEnabled(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService isA2dpOffloadEnabled\")) {\n                return false;\n            }\n\n            return service.isA2dpOffloadEnabled();\n        }\n\n        @Override\n        public void factoryReset(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(factoryReset(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        boolean factoryReset(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mDatabaseManager != null) {\n                service.mDatabaseManager.factoryReset();\n            }\n\n            if (service.mBluetoothKeystoreService != null) {\n                service.mBluetoothKeystoreService.factoryReset();\n            }\n\n            return service.factoryResetNative();\n        }\n\n        @Override\n        public void registerBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(registerBluetoothConnectionCallback(callback, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean registerBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            service.mBluetoothConnectionCallbacks.add(callback);\n            return true;\n        }\n\n        @Override\n        public void unregisterBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(unregisterBluetoothConnectionCallback(callback, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean unregisterBluetoothConnectionCallback(\n                IBluetoothConnectionCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.mBluetoothConnectionCallbacks.remove(callback);\n        }\n\n        @Override\n        public void registerCallback(IBluetoothCallback callback, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                registerCallback(callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void registerCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mCallbacks.register(callback);\n        }\n\n        @Override\n        public void unregisterCallback(IBluetoothCallback callback, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                unregisterCallback(callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void unregisterCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null || service.mCallbacks == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mCallbacks.unregister(callback);\n        }\n\n        @Override\n        public void isMultiAdvertisementSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isMultiAdvertisementSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isMultiAdvertisementSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.mAdapterProperties.getNumOfAdvertisementInstancesSupported();\n            return val >= MIN_ADVT_INSTANCES_FOR_MA;\n        }\n\n        /**\n         * This method has an associated binder cache.  The invalidation\n         * methods must be changed if the logic behind this method changes.\n         */\n        @Override\n        public void isOffloadedFilteringSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isOffloadedFilteringSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isOffloadedFilteringSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getNumOfOffloadedScanFilterSupported();\n            return val >= MIN_OFFLOADED_FILTERS;\n        }\n\n        @Override\n        public void isOffloadedScanBatchingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isOffloadedScanBatchingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isOffloadedScanBatchingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getOffloadedScanResultStorage();\n            return val >= MIN_OFFLOADED_SCAN_STORAGE_BYTES;\n        }\n\n        @Override\n        public void isLe2MPhySupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLe2MPhySupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLe2MPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLe2MPhySupported();\n        }\n\n        @Override\n        public void isLeCodedPhySupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeCodedPhySupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLeCodedPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeCodedPhySupported();\n        }\n\n        @Override\n        public void isLeExtendedAdvertisingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeExtendedAdvertisingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLeExtendedAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeExtendedAdvertisingSupported();\n        }\n\n        @Override\n        public void isLePeriodicAdvertisingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLePeriodicAdvertisingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLePeriodicAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLePeriodicAdvertisingSupported();\n        }\n\n        @Override\n        public void isLeAudioSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int isLeAudioSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            HashSet<Class> supportedProfileServices =\n                    new HashSet<Class>(Arrays.asList(Config.getSupportedProfiles()));\n            HashSet<Class> leAudioUnicastProfiles = Config.geLeAudioUnicastProfiles();\n\n            if (supportedProfileServices.containsAll(leAudioUnicastProfiles)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void isLeAudioBroadcastSourceSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioBroadcastSourceSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int isLeAudioBroadcastSourceSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            if (service.isLeAudioBroadcastSourceSupported()) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void isLeAudioBroadcastAssistantSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioBroadcastAssistantSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public int isLeAudioBroadcastAssistantSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            HashSet<Class> supportedProfileServices =\n                    new HashSet<Class>(Arrays.asList(Config.getSupportedProfiles()));\n\n            if (supportedProfileServices.contains(BassClientService.class)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void getLeMaximumAdvertisingDataLength(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getLeMaximumAdvertisingDataLength());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getLeMaximumAdvertisingDataLength() {\n            AdapterService service = getService();\n            if (service == null) {\n                return 0;\n            }\n\n            return service.getLeMaximumAdvertisingDataLength();\n        }\n\n        @Override\n        public void isActivityAndEnergyReportingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isActivityAndEnergyReportingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isActivityAndEnergyReportingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isActivityAndEnergyReportingSupported();\n        }\n\n        @Override\n        public void reportActivityInfo(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(reportActivityInfo(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private BluetoothActivityEnergyInfo reportActivityInfo(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.reportActivityInfo();\n        }\n\n        @Override\n        public void registerMetadataListener(IBluetoothMetadataListener listener,\n                BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(registerMetadataListener(listener, device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean registerMetadataListener(IBluetoothMetadataListener listener,\n                BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mMetadataListeners == null) {\n                return false;\n            }\n            ArrayList<IBluetoothMetadataListener> list = service.mMetadataListeners.get(device);\n            if (list == null) {\n                list = new ArrayList<>();\n            } else if (list.contains(listener)) {\n                // The device is already registered with this listener\n                return true;\n            }\n            list.add(listener);\n            service.mMetadataListeners.put(device, list);\n            return true;\n        }\n\n        @Override\n        public void unregisterMetadataListener(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(unregisterMetadataListener(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean unregisterMetadataListener(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mMetadataListeners == null) {\n                return false;\n            }\n            if (service.mMetadataListeners.containsKey(device)) {\n                service.mMetadataListeners.remove(device);\n            }\n            return true;\n        }\n\n        @Override\n        public void setMetadata(BluetoothDevice device, int key, byte[] value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setMetadata(device, key, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setMetadata(BluetoothDevice device, int key, byte[] value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (value.length > BluetoothDevice.METADATA_MAX_LENGTH) {\n                return false;\n            }\n            return service.mDatabaseManager.setCustomMeta(device, key, value);\n        }\n\n        @Override\n        public void getMetadata(BluetoothDevice device, int key, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMetadata(device, key, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private byte[] getMetadata(BluetoothDevice device, int key,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mDatabaseManager.getCustomMeta(device, key);\n        }\n\n        @Override\n        public void requestActivityInfo(IBluetoothActivityEnergyInfoListener listener,\n                    AttributionSource source) {\n            BluetoothActivityEnergyInfo info = reportActivityInfo(source);\n            try {\n                listener.onBluetoothActivityEnergyInfoAvailable(info);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"onBluetoothActivityEnergyInfo: RemoteException\", e);\n            }\n        }\n\n        @Override\n        public void onLeServiceUp(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                onLeServiceUp(source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void onLeServiceUp(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_ON);\n        }\n\n        @Override\n        public void onBrEdrDown(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                onBrEdrDown(source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void onBrEdrDown(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n        }\n\n        @Override\n        public void dump(FileDescriptor fd, String[] args) {\n            PrintWriter writer = new PrintWriter(new FileOutputStream(fd));\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n\n            enforceDumpPermission(service);\n\n            service.dump(fd, writer, args);\n            writer.close();\n        }\n\n        @Override\n        public void allowLowLatencyAudio(boolean allowed, BluetoothDevice device,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(allowLowLatencyAudio(allowed, device));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, Utils.getCallingAttributionSource(service),\n                                \"AdapterService allowLowLatencyAudio\")) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.allowLowLatencyAudio(allowed, device);\n        }\n\n        @Override\n        public void startRfcommListener(String name, ParcelUuid uuid, PendingIntent pendingIntent,\n                AttributionSource attributionSource, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(startRfcommListener(name, uuid, pendingIntent, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private int startRfcommListener(\n                String name,\n                ParcelUuid uuid,\n                PendingIntent pendingIntent,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService startRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.startRfcommListener(name, uuid, pendingIntent, attributionSource);\n        }\n\n        @Override\n        public void stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(stopRfcommListener(uuid, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private int stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService stopRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.stopRfcommListener(uuid, attributionSource);\n        }\n\n        @Override\n        public void retrievePendingSocketForServiceRecord(ParcelUuid uuid,\n                AttributionSource attributionSource, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(retrievePendingSocketForServiceRecord(uuid, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n                ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource,\n                            \"AdapterService retrievePendingSocketForServiceRecord\")) {\n                return null;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.retrievePendingSocketForServiceRecord(uuid, attributionSource);\n        }\n\n        @Override\n        public void setForegroundUserId(int userId, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, Utils.getCallingAttributionSource(mService),\n                    \"AdapterService setForegroundUserId\")) {\n                return;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            Utils.setForegroundUserId(userId);\n        }\n    }\n\n    // ----API Methods--------\n\n    public boolean isEnabled() {\n        return getState() == BluetoothAdapter.STATE_ON;\n    }\n\n    public int getState() {\n        if (mAdapterProperties != null) {\n            return mAdapterProperties.getState();\n        }\n        return BluetoothAdapter.STATE_OFF;\n    }\n\n    public synchronized boolean enable(boolean quietMode) {\n        // Enforce the user restriction for disallowing Bluetooth if it was set.\n        if (mUserManager.hasUserRestrictionForUser(UserManager.DISALLOW_BLUETOOTH,\n                    UserHandle.SYSTEM)) {\n            debugLog(\"enable() called when Bluetooth was disallowed\");\n            return false;\n        }\n\n        debugLog(\"enable() - Enable called with quiet mode status =  \" + quietMode);\n        mQuietmode = quietMode;\n        mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_ON);\n        return true;\n    }\n\n    boolean disable() {\n        debugLog(\"disable() called with mRunningProfiles.size() = \" + mRunningProfiles.size());\n        mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_OFF);\n        return true;\n    }\n\n    public String getName() {\n        return mAdapterProperties.getName();\n    }\n\n    public int getNameLengthForAdvertise() {\n        return mAdapterProperties.getName().length();\n    }\n\n    private static boolean isValidIoCapability(int capability) {\n        if (capability < 0 || capability >= BluetoothAdapter.IO_CAPABILITY_MAX) {\n            Log.e(TAG, \"Invalid IO capability value - \" + capability);\n            return false;\n        }\n\n        return true;\n    }\n\n    ArrayList<DiscoveringPackage> getDiscoveringPackages() {\n        return mDiscoveringPackages;\n    }\n\n    void clearDiscoveringPackages() {\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.clear();\n        }\n    }\n\n    boolean startDiscovery(AttributionSource attributionSource) {\n        UserHandle callingUser = Binder.getCallingUserHandle();\n        debugLog(\"startDiscovery\");\n        String callingPackage = attributionSource.getPackageName();\n        mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);\n        boolean isQApp = Utils.checkCallerTargetSdk(this, callingPackage, Build.VERSION_CODES.Q);\n        boolean hasDisavowedLocation =\n                Utils.hasDisavowedLocationForScan(this, attributionSource, mTestModeEnabled);\n        String permission = null;\n        if (Utils.checkCallerHasNetworkSettingsPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETTINGS;\n        } else if (Utils.checkCallerHasNetworkSetupWizardPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETUP_WIZARD;\n        } else if (!hasDisavowedLocation) {\n            if (isQApp) {\n                if (!Utils.checkCallerHasFineLocation(this, attributionSource, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_FINE_LOCATION;\n            } else {\n                if (!Utils.checkCallerHasCoarseLocation(this, attributionSource, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_COARSE_LOCATION;\n            }\n        }\n\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.add(\n                    new DiscoveringPackage(callingPackage, permission, hasDisavowedLocation));\n        }\n        return startDiscoveryNative();\n    }\n\n    /**\n     * Same as API method {@link BluetoothAdapter#getBondedDevices()}\n     *\n     * @return array of bonded {@link BluetoothDevice} or null on error\n     */\n    public BluetoothDevice[] getBondedDevices() {\n        return mAdapterProperties.getBondedDevices();\n    }\n\n    /**\n     * Get the database manager to access Bluetooth storage\n     *\n     * @return {@link DatabaseManager} or null on error\n     */\n    @VisibleForTesting\n    public DatabaseManager getDatabase() {\n        return mDatabaseManager;\n    }\n\n    public byte[] getByteIdentityAddress(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.isConsolidated()) {\n            return Utils.getBytesFromAddress(deviceProp.getIdentityAddress());\n        } else {\n            return Utils.getByteAddress(device);\n        }\n    }\n\n    public BluetoothDevice getDeviceFromByte(byte[] address) {\n        BluetoothDevice device = mRemoteDevices.getDevice(address);\n        if (device == null) {\n            device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address);\n        }\n        return device;\n    }\n\n    public String getIdentityAddress(String address) {\n        BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address.toUpperCase());\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.isConsolidated()) {\n            return deviceProp.getIdentityAddress();\n        } else {\n            return address;\n        }\n    }\n\n    private class CallerInfo {\n        public String callerPackageName;\n        public UserHandle user;\n    }\n\n    boolean createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n            OobData remoteP256Data, String callingPackage) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.getBondState() != BluetoothDevice.BOND_NONE) {\n            return false;\n        }\n\n        if (!isPackageNameAccurate(this, callingPackage, Binder.getCallingUid())) {\n            return false;\n        }\n\n        CallerInfo createBondCaller = new CallerInfo();\n        createBondCaller.callerPackageName = callingPackage;\n        createBondCaller.user = Binder.getCallingUserHandle();\n        mBondAttemptCallerInfo.put(device.getAddress(), createBondCaller);\n\n        mRemoteDevices.setBondingInitiatedLocally(Utils.getByteAddress(device));\n\n        // Pairing is unreliable while scanning, so cancel discovery\n        // Note, remove this when native stack improves\n        cancelDiscoveryNative();\n\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.CREATE_BOND);\n        msg.obj = device;\n        msg.arg1 = transport;\n\n        Bundle remoteOobDatasBundle = new Bundle();\n        boolean setData = false;\n        if (remoteP192Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP192, remoteP192Data);\n            setData = true;\n        }\n        if (remoteP256Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP256, remoteP256Data);\n            setData = true;\n        }\n        if (setData) {\n            msg.setData(remoteOobDatasBundle);\n        }\n        mBondStateMachine.sendMessage(msg);\n        return true;\n    }\n\n    private final ArrayDeque<IBluetoothOobDataCallback> mOobDataCallbackQueue =\n            new ArrayDeque<>();\n\n    /**\n     * Fetches the local OOB data to give out to remote.\n     *\n     * @param transport - specify data transport.\n     * @param callback - callback used to receive the requested {@link OobData}; null will be\n     * ignored silently.\n     *\n     * @hide\n     */\n    public synchronized void generateLocalOobData(int transport,\n            IBluetoothOobDataCallback callback) {\n        if (callback == null) {\n            Log.e(TAG, \"'callback' argument must not be null!\");\n            return;\n        }\n        if (mOobDataCallbackQueue.peek() != null) {\n            try {\n                callback.onError(BluetoothStatusCodes.ERROR_ANOTHER_ACTIVE_OOB_REQUEST);\n                return;\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        }\n        mOobDataCallbackQueue.offer(callback);\n        generateLocalOobDataNative(transport);\n    }\n\n    /* package */ synchronized void notifyOobDataCallback(int transport, OobData oobData) {\n        if (mOobDataCallbackQueue.peek() == null) {\n            Log.e(TAG, \"Failed to make callback, no callback exists\");\n            return;\n        }\n        if (oobData == null) {\n            try {\n                mOobDataCallbackQueue.poll().onError(BluetoothStatusCodes.ERROR_UNKNOWN);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        } else {\n            try {\n                mOobDataCallbackQueue.poll().onOobData(transport, oobData);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        }\n    }\n\n    public boolean isQuietModeEnabled() {\n        debugLog(\"isQuietModeEnabled() - Enabled = \" + mQuietmode);\n        return mQuietmode;\n    }\n\n    public void updateUuids() {\n        debugLog(\"updateUuids() - Updating UUIDs for bonded devices\");\n        BluetoothDevice[] bondedDevices = getBondedDevices();\n        if (bondedDevices == null) {\n            return;\n        }\n\n        for (BluetoothDevice device : bondedDevices) {\n            mRemoteDevices.updateUuids(device);\n        }\n    }\n\n    /**\n     * Update device UUID changed to {@link BondStateMachine}\n     *\n     * @param device remote device of interest\n     */\n    public void deviceUuidUpdated(BluetoothDevice device) {\n        // Notify BondStateMachine for SDP complete / UUID changed.\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.UUID_UPDATE);\n        msg.obj = device;\n        mBondStateMachine.sendMessage(msg);\n    }\n\n    /**\n     * Get the bond state of a particular {@link BluetoothDevice}\n     *\n     * @param device remote device of interest\n     * @return bond state <p>Possible values are\n     * {@link BluetoothDevice#BOND_NONE},\n     * {@link BluetoothDevice#BOND_BONDING},\n     * {@link BluetoothDevice#BOND_BONDED}.\n     */\n    @VisibleForTesting\n    public int getBondState(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return BluetoothDevice.BOND_NONE;\n        }\n        return deviceProp.getBondState();\n    }\n\n    int getConnectionState(BluetoothDevice device) {\n        return getConnectionStateNative(getBytesFromAddress(device.getAddress()));\n    }\n\n    /**\n     * Checks whether the device was recently associated with the comapnion app that called\n     * {@link BluetoothDevice#createBond}. This allows these devices to skip the pairing dialog if\n     * their pairing variant is {@link BluetoothDevice#PAIRING_VARIANT_CONSENT}.\n     *\n     * @param device the bluetooth device that is being bonded\n     * @return true if it was recently associated and we can bypass the dialog, false otherwise\n     */\n    public boolean canBondWithoutDialog(BluetoothDevice device) {\n        if (mBondAttemptCallerInfo.containsKey(device.getAddress())) {\n            CallerInfo bondCallerInfo = mBondAttemptCallerInfo.get(device.getAddress());\n\n            return mCompanionDeviceManager.canPairWithoutPrompt(bondCallerInfo.callerPackageName,\n                    device.getAddress(), bondCallerInfo.user);\n        }\n        return false;\n    }\n\n    /**\n     * Sets device as the active devices for the profiles passed into the function\n     *\n     * @param device is the remote bluetooth device\n     * @param profiles is a constant that references for which profiles we'll be setting the remote\n     *                 device as our active device. One of the following:\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_AUDIO},\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_PHONE_CALL}\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_ALL}\n     * @return false if profiles value is not one of the constants we accept, true otherwise\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    public boolean setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles) {\n        boolean setA2dp = false;\n        boolean setHeadset = false;\n\n        // Determine for which profiles we want to set device as our active device\n        switch(profiles) {\n            case BluetoothAdapter.ACTIVE_DEVICE_AUDIO:\n                setA2dp = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_PHONE_CALL:\n                setHeadset = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_ALL:\n                setA2dp = true;\n                setHeadset = true;\n                break;\n            default:\n                return false;\n        }\n\n        if (mLeAudioService != null && (device == null\n                || mLeAudioService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Le Audio device \" + device);\n            mLeAudioService.setActiveDevice(device);\n        }\n\n        if (setA2dp && mA2dpService != null && (device == null\n                || mA2dpService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active A2dp device \" + device);\n            mA2dpService.setActiveDevice(device);\n        }\n\n        if (mHearingAidService != null && (device == null\n                || mHearingAidService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Hearing Aid \" + device);\n            mHearingAidService.setActiveDevice(device);\n        }\n\n        if (setHeadset && mHeadsetService != null && (device == null\n                || mHeadsetService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Headset \" + device);\n            mHeadsetService.setActiveDevice(device);\n        }\n\n        return true;\n    }\n\n    /**\n     * Get the active devices for the BluetoothProfile specified\n     *\n     * @param profile is the profile from which we want the active devices.\n     *                Possible values are:\n     *                {@link BluetoothProfile#HEADSET},\n     *                {@link BluetoothProfile#A2DP},\n     *                {@link BluetoothProfile#HEARING_AID}\n     *                {@link BluetoothProfile#LE_AUDIO}\n     * @return A list of active bluetooth devices\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    public List<BluetoothDevice> getActiveDevices(@ActiveDeviceProfile int profile) {\n        List<BluetoothDevice> activeDevices = new ArrayList<>();\n\n        switch (profile) {\n            case BluetoothProfile.HEADSET:\n                if (mHeadsetService == null) {\n                    Log.e(TAG, \"getActiveDevices: HeadsetService is null\");\n                } else {\n                    BluetoothDevice device = mHeadsetService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: Headset device: \" + device);\n                }\n                break;\n            case BluetoothProfile.A2DP:\n                if (mA2dpService == null) {\n                    Log.e(TAG, \"getActiveDevices: A2dpService is null\");\n                } else {\n                    BluetoothDevice device = mA2dpService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: A2dp device: \" + device);\n                }\n                break;\n            case BluetoothProfile.HEARING_AID:\n                if (mHearingAidService == null) {\n                    Log.e(TAG, \"getActiveDevices: HearingAidService is null\");\n                } else {\n                    activeDevices = mHearingAidService.getActiveDevices();\n                    Log.i(TAG, \"getActiveDevices: Hearing Aid devices: Left[\"\n                            + activeDevices.get(0) + \"] - Right[\" + activeDevices.get(1) + \"]\");\n                }\n                break;\n            case BluetoothProfile.LE_AUDIO:\n                if (mLeAudioService == null) {\n                Log.e(TAG, \"getActiveDevices: LeAudioService is null\");\n                } else {\n                    activeDevices = mLeAudioService.getActiveDevices();\n                    Log.i(TAG, \"getActiveDevices: LeAudio devices: Out[\"\n                            + activeDevices.get(0) + \"] - In[\" + activeDevices.get(1) + \"]\");\n                }\n                break;\n            default:\n                Log.e(TAG, \"getActiveDevices: profile value is not valid\");\n        }\n        return activeDevices;\n    }\n\n    /**\n     * Attempts connection to all enabled and supported bluetooth profiles between the local and\n     * remote device\n     *\n     * @param device is the remote device with which to connect these profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS} if all profiles connections are attempted, false\n     *         if an error occurred\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    public int connectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"connectAllEnabledProfiles: Not all profile services running\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        // Checks if any profiles are enabled and if so, only connect enabled profiles\n        if (isAnyProfileEnabled(device)) {\n            return connectEnabledProfiles(device);\n        }\n\n        int numProfilesConnected = 0;\n        ParcelUuid[] remoteDeviceUuids = getRemoteUuids(device);\n        ParcelUuid[] localDeviceUuids = mAdapterProperties.getUuids();\n\n        // All profile toggles disabled, so connects all supported profiles\n        if (mA2dpService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting A2dp\");\n            // Set connection policy also connects the profile with CONNECTION_POLICY_ALLOWED\n            mA2dpService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mA2dpSinkService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP_SINK, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Headset Profile\");\n            mHeadsetService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting HFP\");\n            mHeadsetClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mMapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.MAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting MAP\");\n            mMapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHidHostService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HID_HOST, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hid Host Profile\");\n            mHidHostService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPanService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PAN, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Pan Profile\");\n            mPanService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPbapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PBAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Pbap\");\n            mPbapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHearingAidService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEARING_AID, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hearing Aid Profile\");\n            mHearingAidService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hearing Access Client Profile\");\n            mHapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mVolumeControlService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.VOLUME_CONTROL, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mCsipSetCoordinatorService != null\n                && isSupported(localDeviceUuids, remoteDeviceUuids,\n                        BluetoothProfile.CSIP_SET_COORDINATOR, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mLeAudioService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mBassClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n\n        Log.i(TAG, \"connectAllEnabledProfiles: Number of Profiles Connected: \"\n                + numProfilesConnected);\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Disconnects all enabled and supported bluetooth profiles between the local and remote device\n     *\n     * @param device is the remote device with which to disconnect these profiles\n     * @return true if all profiles successfully disconnected, false if an error occurred\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    public int disconnectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"disconnectAllEnabledProfiles: Not all profile services bound\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        if (mA2dpService != null && mA2dpService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp\");\n            mA2dpService.disconnect(device);\n        }\n        if (mA2dpSinkService != null && mA2dpSinkService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp Sink\");\n            mA2dpSinkService.disconnect(device);\n        }\n        if (mHeadsetService != null && mHeadsetService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG,\n                    \"disconnectAllEnabledProfiles: Disconnecting Headset Profile\");\n            mHeadsetService.disconnect(device);\n        }\n        if (mHeadsetClientService != null && mHeadsetClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting HFP\");\n            mHeadsetClientService.disconnect(device);\n        }\n        if (mMapClientService != null && mMapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP Client\");\n            mMapClientService.disconnect(device);\n        }\n        if (mMapService != null && mMapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP\");\n            mMapService.disconnect(device);\n        }\n        if (mHidDeviceService != null && mHidDeviceService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Device Profile\");\n            mHidDeviceService.disconnect(device);\n        }\n        if (mHidHostService != null && mHidHostService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Host Profile\");\n            mHidHostService.disconnect(device);\n        }\n        if (mPanService != null && mPanService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pan Profile\");\n            mPanService.disconnect(device);\n        }\n        if (mPbapClientService != null && mPbapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Client\");\n            mPbapClientService.disconnect(device);\n        }\n        if (mPbapService != null && mPbapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Server\");\n            mPbapService.disconnect(device);\n        }\n        if (mHearingAidService != null && mHearingAidService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Aid Profile\");\n            mHearingAidService.disconnect(device);\n        }\n        if (mHapClientService != null && mHapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Access Profile Client\");\n            mHapClientService.disconnect(device);\n        }\n        if (mVolumeControlService != null && mVolumeControlService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Volume Control Profile\");\n            mVolumeControlService.disconnect(device);\n        }\n        if (mSapService != null && mSapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Sap Profile\");\n            mSapService.disconnect(device);\n        }\n        if (mCsipSetCoordinatorService != null\n                && mCsipSetCoordinatorService.getConnectionState(device)\n                        == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Coordinater Set Profile\");\n            mCsipSetCoordinatorService.disconnect(device);\n        }\n        if (mLeAudioService != null && mLeAudioService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting LeAudio profile (BAP)\");\n            mLeAudioService.disconnect(device);\n        }\n        if (mBassClientService != null && mBassClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting \"\n                            + \"LE Broadcast Assistant Profile\");\n            mBassClientService.disconnect(device);\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Same as API method {@link BluetoothDevice#getName()}\n     *\n     * @param device remote device of interest\n     * @return remote device name\n     */\n    public String getRemoteName(BluetoothDevice device) {\n        if (mRemoteDevices == null) {\n            return null;\n        }\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return null;\n        }\n        return deviceProp.getName();\n    }\n\n    /**\n     * Get UUIDs for service supported by a remote device\n     *\n     * @param device the remote device that we want to get UUIDs from\n     * @return\n     */\n    @VisibleForTesting\n    public ParcelUuid[] getRemoteUuids(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return null;\n        }\n        return deviceProp.getUuids();\n    }\n\n    public Set<IBluetoothConnectionCallback> getBluetoothConnectionCallbacks() {\n        return mBluetoothConnectionCallbacks;\n    }\n\n    /**\n     * Converts HCI disconnect reasons to Android disconnect reasons.\n     * <p>\n     * The HCI Error Codes used for ACL disconnect reasons propagated up from native code were\n     * copied from: {@link system/bt/stack/include/hci_error_code.h}.\n     * <p>\n     * These error codes are specified and described in Bluetooth Core Spec v5.1, Vol 2, Part D.\n     *\n     * @param hciReason is the raw HCI disconnect reason from native.\n     * @return the Android disconnect reason for apps.\n     */\n    static @BluetoothAdapter.BluetoothConnectionCallback.DisconnectReason int\n            hciToAndroidDisconnectReason(int hciReason) {\n        switch(hciReason) {\n            case /*HCI_SUCCESS*/ 0x00:\n            case /*HCI_ERR_UNSPECIFIED*/ 0x1F:\n            case /*HCI_ERR_UNDEFINED*/ 0xff:\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n            case /*HCI_ERR_ILLEGAL_COMMAND*/ 0x01:\n            case /*HCI_ERR_NO_CONNECTION*/ 0x02:\n            case /*HCI_ERR_HW_FAILURE*/ 0x03:\n            case /*HCI_ERR_DIFF_TRANSACTION_COLLISION*/ 0x2A:\n            case /*HCI_ERR_ROLE_SWITCH_PENDING*/ 0x32:\n            case /*HCI_ERR_ROLE_SWITCH_FAILED*/ 0x35:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL;\n            case /*HCI_ERR_PAGE_TIMEOUT*/ 0x04:\n            case /*HCI_ERR_CONNECTION_TOUT*/ 0x08:\n            case /*HCI_ERR_HOST_TIMEOUT*/ 0x10:\n            case /*HCI_ERR_LMP_RESPONSE_TIMEOUT*/ 0x22:\n            case /*HCI_ERR_ADVERTISING_TIMEOUT*/ 0x3C:\n            case /*HCI_ERR_CONN_FAILED_ESTABLISHMENT*/ 0x3E:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_TIMEOUT;\n            case /*HCI_ERR_AUTH_FAILURE*/ 0x05:\n            case /*HCI_ERR_KEY_MISSING*/ 0x06:\n            case /*HCI_ERR_HOST_REJECT_SECURITY*/ 0x0E:\n            case /*HCI_ERR_REPEATED_ATTEMPTS*/ 0x17:\n            case /*HCI_ERR_PAIRING_NOT_ALLOWED*/ 0x18:\n            case /*HCI_ERR_ENCRY_MODE_NOT_ACCEPTABLE*/ 0x25:\n            case /*HCI_ERR_UNIT_KEY_USED*/ 0x26:\n            case /*HCI_ERR_PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED*/ 0x29:\n            case /*HCI_ERR_INSUFFCIENT_SECURITY*/ 0x2F:\n            case /*HCI_ERR_HOST_BUSY_PAIRING*/ 0x38:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SECURITY;\n            case /*HCI_ERR_MEMORY_FULL*/ 0x07:\n            case /*HCI_ERR_MAX_NUM_OF_CONNECTIONS*/ 0x09:\n            case /*HCI_ERR_MAX_NUM_OF_SCOS*/ 0x0A:\n            case /*HCI_ERR_COMMAND_DISALLOWED*/ 0x0C:\n            case /*HCI_ERR_HOST_REJECT_RESOURCES*/ 0x0D:\n            case /*HCI_ERR_LIMIT_REACHED*/ 0x43:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_RESOURCE_LIMIT_REACHED;\n            case /*HCI_ERR_CONNECTION_EXISTS*/ 0x0B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_CONNECTION_ALREADY_EXISTS;\n            case /*HCI_ERR_HOST_REJECT_DEVICE*/ 0x0F:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SYSTEM_POLICY;\n            case /*HCI_ERR_ILLEGAL_PARAMETER_FMT*/ 0x12:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            case /*HCI_ERR_PEER_USER*/ 0x13:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE_REQUEST;\n            case /*HCI_ERR_CONN_CAUSE_LOCAL_HOST*/ 0x16:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL_REQUEST;\n            case /*HCI_ERR_UNSUPPORTED_REM_FEATURE*/ 0x1A:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE;\n            case /*HCI_ERR_UNACCEPT_CONN_INTERVAL*/ 0x3B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            default:\n                Log.e(TAG, \"Invalid HCI disconnect reason: \" + hciReason);\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n    }\n\n    void logUserBondResponse(BluetoothDevice device, boolean accepted, int event) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            BluetoothStatsLog.write(BluetoothStatsLog.BLUETOOTH_BOND_STATE_CHANGED,\n                    obfuscateAddress(device), 0, device.getType(),\n                    BluetoothDevice.BOND_BONDING,\n                    event,\n                    accepted ? 0 : BluetoothDevice.UNBOND_REASON_AUTH_REJECTED);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    int getDeviceAccessFromPrefs(BluetoothDevice device, String prefFile) {\n        SharedPreferences prefs = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        if (!prefs.contains(device.getAddress())) {\n            return BluetoothDevice.ACCESS_UNKNOWN;\n        }\n        return prefs.getBoolean(device.getAddress(), false)\n                ? BluetoothDevice.ACCESS_ALLOWED\n                : BluetoothDevice.ACCESS_REJECTED;\n    }\n\n    void setDeviceAccessFromPrefs(BluetoothDevice device, int value, String prefFile) {\n        SharedPreferences pref = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = pref.edit();\n        if (value == BluetoothDevice.ACCESS_UNKNOWN) {\n            editor.remove(device.getAddress());\n        } else {\n            editor.putBoolean(device.getAddress(), value == BluetoothDevice.ACCESS_ALLOWED);\n        }\n        editor.apply();\n    }\n\n    public void setPhonebookAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setMessageAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setSimAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public boolean isRpaOffloadSupported() {\n        return mAdapterProperties.isRpaOffloadSupported();\n    }\n\n    public int getNumOfOffloadedIrkSupported() {\n        return mAdapterProperties.getNumOfOffloadedIrkSupported();\n    }\n\n    public int getNumOfOffloadedScanFilterSupported() {\n        return mAdapterProperties.getNumOfOffloadedScanFilterSupported();\n    }\n\n    public int getOffloadedScanResultStorage() {\n        return mAdapterProperties.getOffloadedScanResultStorage();\n    }\n\n    public boolean isLe2MPhySupported() {\n        return mAdapterProperties.isLe2MPhySupported();\n    }\n\n    public boolean isLeCodedPhySupported() {\n        return mAdapterProperties.isLeCodedPhySupported();\n    }\n\n    public boolean isLeExtendedAdvertisingSupported() {\n        return mAdapterProperties.isLeExtendedAdvertisingSupported();\n    }\n\n    public boolean isLePeriodicAdvertisingSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast source feature is supported.\n     *\n     * @return true, if the LE audio broadcast source is supported\n     */\n    public boolean isLeAudioBroadcastSourceSupported() {\n        return  BluetoothProperties.isProfileBapBroadcastSourceEnabled().orElse(false)\n                && mAdapterProperties.isLePeriodicAdvertisingSupported()\n                && mAdapterProperties.isLeExtendedAdvertisingSupported()\n                && mAdapterProperties.isLeIsochronousBroadcasterSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast assistant feature is supported.\n     *\n     * @return true, if the LE audio broadcast assistant is supported\n     */\n    public boolean isLeAudioBroadcastAssistantSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported()\n            && mAdapterProperties.isLeExtendedAdvertisingSupported()\n            && (mAdapterProperties.isLePeriodicAdvertisingSyncTransferSenderSupported()\n                || mAdapterProperties.isLePeriodicAdvertisingSyncTransferRecipientSupported());\n    }\n\n    /**\n     * Check if the LE audio CIS central feature is supported.\n     *\n     * @return true, if the LE audio CIS central is supported\n     */\n    public boolean isLeConnectedIsochronousStreamCentralSupported() {\n        return mAdapterProperties.isLeConnectedIsochronousStreamCentralSupported();\n    }\n\n    public int getLeMaximumAdvertisingDataLength() {\n        return mAdapterProperties.getLeMaximumAdvertisingDataLength();\n    }\n\n    /**\n     * Get the maximum number of connected audio devices.\n     *\n     * @return the maximum number of connected audio devices\n     */\n    public int getMaxConnectedAudioDevices() {\n        return mAdapterProperties.getMaxConnectedAudioDevices();\n    }\n\n    /**\n     * Check whether A2DP offload is enabled.\n     *\n     * @return true if A2DP offload is enabled\n     */\n    public boolean isA2dpOffloadEnabled() {\n        return mAdapterProperties.isA2dpOffloadEnabled();\n    }\n\n    private BluetoothActivityEnergyInfo reportActivityInfo() {\n        if (mAdapterProperties.getState() != BluetoothAdapter.STATE_ON\n                || !mAdapterProperties.isActivityAndEnergyReportingSupported()) {\n            return null;\n        }\n\n        // Pull the data. The callback will notify mEnergyInfoLock.\n        readEnergyInfo();\n\n        synchronized (mEnergyInfoLock) {\n            try {\n                mEnergyInfoLock.wait(CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS);\n            } catch (InterruptedException e) {\n                // Just continue, the energy data may be stale but we won't miss anything next time\n                // we query.\n            }\n\n            final BluetoothActivityEnergyInfo info =\n                    new BluetoothActivityEnergyInfo(SystemClock.elapsedRealtime(),\n                            mStackReportedState, mTxTimeTotalMs, mRxTimeTotalMs, mIdleTimeTotalMs,\n                            mEnergyUsedTotalVoltAmpSecMicro);\n\n            // Count the number of entries that have byte counts > 0\n            int arrayLen = 0;\n            for (int i = 0; i < mUidTraffic.size(); i++) {\n                final UidTraffic traffic = mUidTraffic.valueAt(i);\n                if (traffic.getTxBytes() != 0 || traffic.getRxBytes() != 0) {\n                    arrayLen++;\n                }\n            }\n\n            // Copy the traffic objects whose byte counts are > 0\n            final List<UidTraffic> result = new ArrayList<>();\n            int putIdx = 0;\n            for (int i = 0; i < mUidTraffic.size(); i++) {\n                final UidTraffic traffic = mUidTraffic.valueAt(i);\n                if (traffic.getTxBytes() != 0 || traffic.getRxBytes() != 0) {\n                    result.add(traffic.clone());\n                }\n            }\n\n            info.setUidTraffic(result);\n\n            return info;\n        }\n    }\n\n    public int getTotalNumOfTrackableAdvertisements() {\n        return mAdapterProperties.getTotalNumOfTrackableAdvertisements();\n    }\n\n    /**\n     * Notify the UID and package name of the app, and the address of associated active device\n     *\n     * @param source The attribution source that starts the activity\n     * @param deviceAddress The address of the active device associated with the app\n     */\n    public void notifyActivityAttributionInfo(AttributionSource source, String deviceAddress) {\n        mActivityAttributionService.notifyActivityAttributionInfo(\n                source.getUid(), source.getPackageName(), deviceAddress);\n    }\n\n    private static int convertScanModeToHal(int mode) {\n        switch (mode) {\n            case BluetoothAdapter.SCAN_MODE_NONE:\n                return AbstractionLayer.BT_SCAN_MODE_NONE;\n            case BluetoothAdapter.SCAN_MODE_CONNECTABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE;\n            case BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        // errorLog(\"Incorrect scan mode in convertScanModeToHal\");\n        return -1;\n    }\n\n    static int convertScanModeFromHal(int mode) {\n        switch (mode) {\n            case AbstractionLayer.BT_SCAN_MODE_NONE:\n                return BluetoothAdapter.SCAN_MODE_NONE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE:\n                return BluetoothAdapter.SCAN_MODE_CONNECTABLE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        //errorLog(\"Incorrect scan mode in convertScanModeFromHal\");\n        return -1;\n    }\n\n    // This function is called from JNI. It allows native code to set a single wake\n    // alarm. If an alarm is already pending and a new request comes in, the alarm\n    // will be rescheduled (i.e. the previously set alarm will be cancelled).\n    private boolean setWakeAlarm(long delayMillis, boolean shouldWake) {\n        synchronized (this) {\n            if (mPendingAlarm != null) {\n                mAlarmManager.cancel(mPendingAlarm);\n            }\n\n            long wakeupTime = SystemClock.elapsedRealtime() + delayMillis;\n            int type = shouldWake ? AlarmManager.ELAPSED_REALTIME_WAKEUP\n                    : AlarmManager.ELAPSED_REALTIME;\n\n            Intent intent = new Intent(ACTION_ALARM_WAKEUP);\n            mPendingAlarm =\n                    PendingIntent.getBroadcast(this, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                            | PendingIntent.FLAG_IMMUTABLE);\n            mAlarmManager.setExact(type, wakeupTime, mPendingAlarm);\n            return true;\n        }\n    }\n\n    // This function is called from JNI. It allows native code to acquire a single wake lock.\n    // If the wake lock is already held, this function returns success. Although this function\n    // only supports acquiring a single wake lock at a time right now, it will eventually be\n    // extended to allow acquiring an arbitrary number of wake locks. The current interface\n    // takes |lockName| as a parameter in anticipation of that implementation.\n    private boolean acquireWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                mWakeLockName = lockName;\n                mWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, lockName);\n            }\n\n            if (!mWakeLock.isHeld()) {\n                mWakeLock.acquire();\n            }\n        }\n        return true;\n    }\n\n    // This function is called from JNI. It allows native code to release a wake lock acquired\n    // by |acquireWakeLock|. If the wake lock is not held, this function returns failure.\n    // Note that the release() call is also invoked by {@link #cleanup()} so a synchronization is\n    // needed here. See the comment for |acquireWakeLock| for an explanation of the interface.\n    private boolean releaseWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                errorLog(\"Repeated wake lock release; aborting release: \" + lockName);\n                return false;\n            }\n\n            if (mWakeLock.isHeld()) {\n                mWakeLock.release();\n            }\n        }\n        return true;\n    }\n\n    private void energyInfoCallback(int status, int ctrlState, long txTime, long rxTime,\n            long idleTime, long energyUsed, UidTraffic[] data) throws RemoteException {\n        if (ctrlState >= BluetoothActivityEnergyInfo.BT_STACK_STATE_INVALID\n                && ctrlState <= BluetoothActivityEnergyInfo.BT_STACK_STATE_STATE_IDLE) {\n            // Energy is product of mA, V and ms. If the chipset doesn't\n            // report it, we have to compute it from time\n            if (energyUsed == 0) {\n                try {\n                    final long txMah = Math.multiplyExact(txTime, getTxCurrentMa());\n                    final long rxMah = Math.multiplyExact(rxTime, getRxCurrentMa());\n                    final long idleMah = Math.multiplyExact(idleTime, getIdleCurrentMa());\n                    energyUsed = (long) (Math.addExact(Math.addExact(txMah, rxMah), idleMah)\n                            * getOperatingVolt());\n                } catch (ArithmeticException e) {\n                    Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                    // Energy is already 0 if the exception was thrown.\n                }\n            }\n\n            synchronized (mEnergyInfoLock) {\n                mStackReportedState = ctrlState;\n                long totalTxTimeMs;\n                long totalRxTimeMs;\n                long totalIdleTimeMs;\n                long totalEnergy;\n                try {\n                    totalTxTimeMs = Math.addExact(mTxTimeTotalMs, txTime);\n                    totalRxTimeMs = Math.addExact(mRxTimeTotalMs, rxTime);\n                    totalIdleTimeMs = Math.addExact(mIdleTimeTotalMs, idleTime);\n                    totalEnergy = Math.addExact(mEnergyUsedTotalVoltAmpSecMicro, energyUsed);\n                } catch (ArithmeticException e) {\n                    // This could be because we accumulated a lot of time, or we got a very strange\n                    // value from the controller (more likely). Discard this data.\n                    Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                    totalTxTimeMs = mTxTimeTotalMs;\n                    totalRxTimeMs = mRxTimeTotalMs;\n                    totalIdleTimeMs = mIdleTimeTotalMs;\n                    totalEnergy = mEnergyUsedTotalVoltAmpSecMicro;\n                }\n\n                mTxTimeTotalMs = totalTxTimeMs;\n                mRxTimeTotalMs = totalRxTimeMs;\n                mIdleTimeTotalMs = totalIdleTimeMs;\n                mEnergyUsedTotalVoltAmpSecMicro = totalEnergy;\n\n                for (UidTraffic traffic : data) {\n                    UidTraffic existingTraffic = mUidTraffic.get(traffic.getUid());\n                    if (existingTraffic == null) {\n                        mUidTraffic.put(traffic.getUid(), traffic);\n                    } else {\n                        existingTraffic.addRxBytes(traffic.getRxBytes());\n                        existingTraffic.addTxBytes(traffic.getTxBytes());\n                    }\n                }\n                mEnergyInfoLock.notifyAll();\n            }\n        }\n\n        verboseLog(\"energyInfoCallback() status = \" + status + \"txTime = \" + txTime + \"rxTime = \"\n                + rxTime + \"idleTime = \" + idleTime + \"energyUsed = \" + energyUsed + \"ctrlState = \"\n                + ctrlState + \"traffic = \" + Arrays.toString(data));\n    }\n\n    /**\n     * Update metadata change to registered listeners\n     */\n    @VisibleForTesting\n    public void metadataChanged(String address, int key, byte[] value) {\n        BluetoothDevice device = mRemoteDevices.getDevice(Utils.getBytesFromAddress(address));\n        if (mMetadataListeners.containsKey(device)) {\n            ArrayList<IBluetoothMetadataListener> list = mMetadataListeners.get(device);\n            for (IBluetoothMetadataListener listener : list) {\n                try {\n                    listener.onMetadataChanged(device, key, value);\n                } catch (RemoteException e) {\n                    Log.w(TAG, \"RemoteException when onMetadataChanged\");\n                }\n            }\n        }\n    }\n\n    private int getIdleCurrentMa() {\n        return BluetoothProperties.getHardwareIdleCurrentMa().orElse(0);\n    }\n\n    private int getTxCurrentMa() {\n        return BluetoothProperties.getHardwareTxCurrentMa().orElse(0);\n    }\n\n    private int getRxCurrentMa() {\n        return BluetoothProperties.getHardwareRxCurrentMa().orElse(0);\n    }\n\n    private double getOperatingVolt() {\n        return BluetoothProperties.getHardwareOperatingVoltageMv().orElse(0) / 1000.0;\n    }\n\n    @VisibleForTesting\n    protected RemoteDevices getRemoteDevices() {\n        return mRemoteDevices;\n    }\n\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        if (args.length == 0) {\n            writer.println(\"Skipping dump in APP SERVICES, see bluetooth_manager section.\");\n            writer.println(\"Use --print argument for dumpsys direct from AdapterService.\");\n            return;\n        }\n\n        if (\"set-test-mode\".equals(args[0])) {\n            final boolean testModeEnabled = \"enabled\".equalsIgnoreCase(args[1]);\n            for (ProfileService profile : mRunningProfiles) {\n                profile.setTestModeEnabled(testModeEnabled);\n            }\n            mTestModeEnabled = testModeEnabled;\n            return;\n        }\n\n        verboseLog(\"dumpsys arguments, check for protobuf output: \" + TextUtils.join(\" \", args));\n        if (args[0].equals(\"--proto-bin\")) {\n            dumpMetrics(fd);\n            return;\n        }\n\n        writer.println();\n        mAdapterProperties.dump(fd, writer, args);\n        writer.println(\"mSnoopLogSettingAtEnable = \" + mSnoopLogSettingAtEnable);\n        writer.println(\"mDefaultSnoopLogSettingAtEnable = \" + mDefaultSnoopLogSettingAtEnable);\n\n        writer.println();\n        writer.println(\"Enabled Profile Services:\");\n        for (Class profile : Config.getSupportedProfiles()) {\n            writer.println(\"  \" + profile.getSimpleName());\n        }\n        writer.println();\n\n        mAdapterStateMachine.dump(fd, writer, args);\n\n        StringBuilder sb = new StringBuilder();\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dump(sb);\n        }\n        mSilenceDeviceManager.dump(fd, writer, args);\n        mDatabaseManager.dump(writer);\n\n        writer.write(sb.toString());\n        writer.flush();\n\n        dumpNative(fd, args);\n    }\n\n    private void dumpMetrics(FileDescriptor fd) {\n        BluetoothMetricsProto.BluetoothLog.Builder metricsBuilder =\n                BluetoothMetricsProto.BluetoothLog.newBuilder();\n        byte[] nativeMetricsBytes = dumpMetricsNative();\n        debugLog(\"dumpMetrics: native metrics size is \" + nativeMetricsBytes.length);\n        if (nativeMetricsBytes.length > 0) {\n            try {\n                metricsBuilder.mergeFrom(nativeMetricsBytes);\n            } catch (InvalidProtocolBufferException ex) {\n                Log.w(TAG, \"dumpMetrics: problem parsing metrics protobuf, \" + ex.getMessage());\n                return;\n            }\n        }\n        metricsBuilder.setNumBondedDevices(getBondedDevices().length);\n        MetricsLogger.dumpProto(metricsBuilder);\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dumpProto(metricsBuilder);\n        }\n        byte[] metricsBytes = Base64.encode(metricsBuilder.build().toByteArray(), Base64.DEFAULT);\n        debugLog(\"dumpMetrics: combined metrics size is \" + metricsBytes.length);\n        try (FileOutputStream protoOut = new FileOutputStream(fd)) {\n            protoOut.write(metricsBytes);\n        } catch (IOException e) {\n            errorLog(\"dumpMetrics: error writing combined protobuf to fd, \" + e.getMessage());\n        }\n    }\n\n    private void debugLog(String msg) {\n        if (DBG) {\n            Log.d(TAG, msg);\n        }\n    }\n\n    private void verboseLog(String msg) {\n        if (VERBOSE) {\n            Log.v(TAG, msg);\n        }\n    }\n\n    private void errorLog(String msg) {\n        Log.e(TAG, msg);\n    }\n\n    private final BroadcastReceiver mAlarmBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            synchronized (AdapterService.this) {\n                mPendingAlarm = null;\n                alarmFiredNative();\n            }\n        }\n    };\n\n    private boolean isCommonCriteriaMode() {\n        return getSystemService(DevicePolicyManager.class).isCommonCriteriaModeEnabled(null);\n    }\n\n    @SuppressLint(\"AndroidFrameworkRequiresPermission\")\n    private void enforceBluetoothPrivilegedPermissionIfNeeded(OobData remoteP192Data,\n            OobData remoteP256Data) {\n        if (remoteP192Data != null || remoteP256Data != null) {\n            enforceBluetoothPrivilegedPermission(this);\n        }\n    }\n\n    // Boolean flags\n    private static final String GD_CORE_FLAG = \"INIT_gd_core\";\n    private static final String GD_ADVERTISING_FLAG = \"INIT_gd_advertising\";\n    private static final String GD_SCANNING_FLAG = \"INIT_gd_scanning\";\n    private static final String GD_HCI_FLAG = \"INIT_gd_hci\";\n    private static final String GD_CONTROLLER_FLAG = \"INIT_gd_controller\";\n    private static final String GD_ACL_FLAG = \"INIT_gd_acl\";\n    private static final String GD_L2CAP_FLAG = \"INIT_gd_l2cap\";\n    private static final String GD_RUST_FLAG = \"INIT_gd_rust\";\n    private static final String GD_LINK_POLICY_FLAG = \"INIT_gd_link_policy\";\n    private static final String GATT_ROBUST_CACHING_FLAG = \"INIT_gatt_robust_caching\";\n    private static final String IRK_ROTATION_FLAG = \"INIT_irk_rotation\";\n\n    /**\n     * Logging flags logic (only applies to DEBUG and VERBOSE levels):\n     * if LOG_TAG in LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG:\n     *   DO NOT LOG\n     * else if LOG_TAG in LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG:\n     *   DO LOG\n     * else if LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG:\n     *   DO LOG\n     * else:\n     *   DO NOT LOG\n     */\n    private static final String LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG =\n            \"INIT_logging_debug_enabled_for_all\";\n    // String flags\n    // Comma separated tags\n    private static final String LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG =\n            \"INIT_logging_debug_enabled_for_tags\";\n    private static final String LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG =\n            \"INIT_logging_debug_disabled_for_tags\";\n    private static final String BTAA_HCI_LOG_FLAG = \"INIT_btaa_hci\";\n\n    private String[] getInitFlags() {\n        ArrayList<String> initFlags = new ArrayList<>();\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_CORE_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_CORE_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_ADVERTISING_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_ADVERTISING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_SCANNING_FLAG,\n                Config.isGdEnabledUpToScanningLayer())) {\n            initFlags.add(String.format(\"%s=%s\", GD_SCANNING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_HCI_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_HCI_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_CONTROLLER_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_CONTROLLER_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_ACL_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_ACL_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_L2CAP_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_L2CAP_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_RUST_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_RUST_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_LINK_POLICY_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_LINK_POLICY_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH,\n                GATT_ROBUST_CACHING_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GATT_ROBUST_CACHING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, IRK_ROTATION_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", IRK_ROTATION_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG, \"true\"));\n        }\n        String debugLoggingEnabledTags = DeviceConfig.getString(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG, \"\");\n        if (!debugLoggingEnabledTags.isEmpty()) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG,\n                    debugLoggingEnabledTags));\n        }\n        String debugLoggingDisabledTags = DeviceConfig.getString(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG, \"\");\n        if (!debugLoggingDisabledTags.isEmpty()) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG,\n                    debugLoggingDisabledTags));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, BTAA_HCI_LOG_FLAG, true)) {\n            initFlags.add(String.format(\"%s=%s\", BTAA_HCI_LOG_FLAG, \"true\"));\n        }\n        return initFlags.toArray(new String[0]);\n    }\n\n    private final Object mDeviceConfigLock = new Object();\n\n    /**\n     * Predicate that can be applied to names to determine if a device is\n     * well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<String> mLocationDenylistName = (v) -> false;\n\n    /**\n     * Predicate that can be applied to MAC addresses to determine if a device\n     * is well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistMac = (v) -> false;\n\n    /**\n     * Predicate that can be applied to Advertising Data payloads to determine\n     * if a device is well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistAdvertisingData = (v) -> false;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanQuotaCount = DeviceConfigListener.DEFAULT_SCAN_QUOTA_COUNT;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanQuotaWindowMillis = DeviceConfigListener.DEFAULT_SCAN_QUOTA_WINDOW_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanTimeoutMillis = DeviceConfigListener.DEFAULT_SCAN_TIMEOUT_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanUpgradeDurationMillis =\n            DeviceConfigListener.DEFAULT_SCAN_UPGRADE_DURATION_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS;\n\n    public @NonNull Predicate<String> getLocationDenylistName() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistName;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistMac() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistMac;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistAdvertisingData() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistAdvertisingData;\n        }\n    }\n\n    public static int getScanQuotaCount() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_QUOTA_COUNT;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanQuotaCount;\n        }\n    }\n\n    public static long getScanQuotaWindowMillis() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_QUOTA_WINDOW_MILLIS;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanQuotaWindowMillis;\n        }\n    }\n\n    public static long getScanTimeoutMillis() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_TIMEOUT_MILLIS;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanTimeoutMillis;\n        }\n    }\n\n    /**\n     * Returns scan upgrade duration in millis.\n     */\n    public long getScanUpgradeDurationMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScanUpgradeDurationMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF_BALANCED scan window in millis.\n     */\n    public int getScreenOffBalancedWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedWindowMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF_BALANCED scan interval in millis.\n     */\n    public int getScreenOffBalancedIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedIntervalMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF low power scan window in millis.\n     */\n    public int getScreenOffLowPowerWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerWindowMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF low power scan interval in millis.\n     */\n    public int getScreenOffLowPowerIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerIntervalMillis;\n        }\n    }\n\n    private final DeviceConfigListener mDeviceConfigListener = new DeviceConfigListener();\n\n    private class DeviceConfigListener implements DeviceConfig.OnPropertiesChangedListener {\n        private static final String LOCATION_DENYLIST_NAME =\n                \"location_denylist_name\";\n        private static final String LOCATION_DENYLIST_MAC =\n                \"location_denylist_mac\";\n        private static final String LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"location_denylist_advertising_data\";\n        private static final String SCAN_QUOTA_COUNT =\n                \"scan_quota_count\";\n        private static final String SCAN_QUOTA_WINDOW_MILLIS =\n                \"scan_quota_window_millis\";\n        private static final String SCAN_TIMEOUT_MILLIS =\n                \"scan_timeout_millis\";\n        private static final String SCAN_UPGRADE_DURATION_MILLIS =\n                \"scan_upgrade_duration_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_WINDOW_MILLIS =\n                \"screen_off_low_power_window_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS =\n                \"screen_off_low_power_interval_millis\";\n        private static final String SCREEN_OFF_BALANCED_WINDOW_MILLIS =\n                \"screen_off_balanced_window_millis\";\n        private static final String SCREEN_OFF_BALANCED_INTERVAL_MILLIS =\n                \"screen_off_balanced_interval_millis\";\n\n        /**\n         * Default denylist which matches Eddystone and iBeacon payloads.\n         */\n        private static final String DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"\u22860016AAFE/00FFFFFF,\u228600FF4C0002/00FFFFFFFF\";\n\n        private static final int DEFAULT_SCAN_QUOTA_COUNT = 5;\n        private static final long DEFAULT_SCAN_QUOTA_WINDOW_MILLIS = 30 * SECOND_IN_MILLIS;\n        private static final long DEFAULT_SCAN_TIMEOUT_MILLIS = 30 * MINUTE_IN_MILLIS;\n        private static final int DEFAULT_SCAN_UPGRADE_DURATION_MILLIS = (int) SECOND_IN_MILLIS * 6;\n\n        public void start() {\n            DeviceConfig.addOnPropertiesChangedListener(DeviceConfig.NAMESPACE_BLUETOOTH,\n                    BackgroundThread.getExecutor(), this);\n            onPropertiesChanged(DeviceConfig.getProperties(DeviceConfig.NAMESPACE_BLUETOOTH));\n        }\n\n        @Override\n        public void onPropertiesChanged(DeviceConfig.Properties properties) {\n            synchronized (mDeviceConfigLock) {\n                final String name = properties.getString(LOCATION_DENYLIST_NAME, null);\n                mLocationDenylistName = !TextUtils.isEmpty(name)\n                        ? Pattern.compile(name).asPredicate()\n                        : (v) -> false;\n                mLocationDenylistMac = BytesMatcher\n                        .decode(properties.getString(LOCATION_DENYLIST_MAC, null));\n                mLocationDenylistAdvertisingData = BytesMatcher\n                        .decode(properties.getString(LOCATION_DENYLIST_ADVERTISING_DATA,\n                                DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA));\n                mScanQuotaCount = properties.getInt(SCAN_QUOTA_COUNT,\n                        DEFAULT_SCAN_QUOTA_COUNT);\n                mScanQuotaWindowMillis = properties.getLong(SCAN_QUOTA_WINDOW_MILLIS,\n                        DEFAULT_SCAN_QUOTA_WINDOW_MILLIS);\n                mScanTimeoutMillis = properties.getLong(SCAN_TIMEOUT_MILLIS,\n                        DEFAULT_SCAN_TIMEOUT_MILLIS);\n                mScanUpgradeDurationMillis = properties.getInt(SCAN_UPGRADE_DURATION_MILLIS,\n                        DEFAULT_SCAN_UPGRADE_DURATION_MILLIS);\n                mScreenOffLowPowerWindowMillis = properties.getInt(\n                        SCREEN_OFF_LOW_POWER_WINDOW_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS);\n                mScreenOffLowPowerIntervalMillis = properties.getInt(\n                        SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS);\n                mScreenOffBalancedWindowMillis = properties.getInt(\n                        SCREEN_OFF_BALANCED_WINDOW_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS);\n                mScreenOffBalancedIntervalMillis = properties.getInt(\n                        SCREEN_OFF_BALANCED_INTERVAL_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS);\n            }\n        }\n    }\n\n    /**\n     *  Obfuscate Bluetooth MAC address into a PII free ID string\n     *\n     *  @param device Bluetooth device whose MAC address will be obfuscated\n     *  @return a byte array that is unique to this MAC address on this device,\n     *          or empty byte array when either device is null or obfuscateAddressNative fails\n     */\n    public byte[] obfuscateAddress(BluetoothDevice device) {\n        if (device == null) {\n            return new byte[0];\n        }\n        return obfuscateAddressNative(Utils.getByteAddress(device));\n    }\n\n    /**\n     * Get dynamic audio buffer size supported type\n     *\n     * @return support <p>Possible values are\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_NONE},\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_OFFLOAD},\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_SOFTWARE_ENCODING}.\n     */\n    public int getDynamicBufferSupport() {\n        return mAdapterProperties.getDynamicBufferSupport();\n    }\n\n    /**\n     * Get dynamic audio buffer size\n     *\n     * @return BufferConstraints\n     */\n    public BufferConstraints getBufferConstraints() {\n        return mAdapterProperties.getBufferConstraints();\n    }\n\n    /**\n     * Set dynamic audio buffer size\n     *\n     * @param codec Audio codec\n     * @param value buffer millis\n     * @return true if the settings is successful, false otherwise\n     */\n    public boolean setBufferLengthMillis(int codec, int value) {\n        return mAdapterProperties.setBufferLengthMillis(codec, value);\n    }\n\n    /**\n     *  Get an incremental id of Bluetooth metrics and log\n     *\n     *  @param device Bluetooth device\n     *  @return int of id for Bluetooth metrics and logging, 0 if the device is invalid\n     */\n    public int getMetricId(BluetoothDevice device) {\n        if (device == null) {\n            return 0;\n        }\n        return getMetricIdNative(Utils.getByteAddress(device));\n    }\n\n    /**\n     *  Allow audio low latency\n     *\n     *  @param allowed true if audio low latency is being allowed\n     *  @param device device whose audio low latency will be allowed or disallowed\n     *  @return boolean true if audio low latency is successfully allowed or disallowed\n     */\n    public boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n        return allowLowLatencyAudioNative(allowed, Utils.getByteAddress(device));\n    }\n\n    /**\n     * Sets the battery level of the remote device\n     */\n    public void setBatteryLevel(BluetoothDevice device, int batteryLevel) {\n        mRemoteDevices.updateBatteryLevel(device, batteryLevel);\n    }\n\n    static native void classInitNative();\n\n    native boolean initNative(boolean startRestricted, boolean isCommonCriteriaMode,\n            int configCompareResult, String[] initFlags, boolean isAtvDevice,\n            String userDataDirectory);\n\n    native void cleanupNative();\n\n    /*package*/\n    native boolean enableNative();\n\n    /*package*/\n    native boolean disableNative();\n\n    /*package*/\n    native boolean setAdapterPropertyNative(int type, byte[] val);\n\n    /*package*/\n    native boolean getAdapterPropertiesNative();\n\n    /*package*/\n    native boolean getAdapterPropertyNative(int type);\n\n    /*package*/\n    native boolean setAdapterPropertyNative(int type);\n\n    /*package*/\n    native boolean setDevicePropertyNative(byte[] address, int type, byte[] val);\n\n    /*package*/\n    native boolean getDevicePropertyNative(byte[] address, int type);\n\n    /*package*/\n    public native boolean createBondNative(byte[] address, int transport);\n\n    /*package*/\n    native boolean createBondOutOfBandNative(byte[] address, int transport,\n            OobData p192Data, OobData p256Data);\n\n    /*package*/\n    public native boolean removeBondNative(byte[] address);\n\n    /*package*/\n    native boolean cancelBondNative(byte[] address);\n\n    /*package*/\n    native void generateLocalOobDataNative(int transport);\n\n    /*package*/\n    native boolean sdpSearchNative(byte[] address, byte[] uuid);\n\n    /*package*/\n    native int getConnectionStateNative(byte[] address);\n\n    private native boolean startDiscoveryNative();\n\n    private native boolean cancelDiscoveryNative();\n\n    private native boolean pinReplyNative(byte[] address, boolean accept, int len, byte[] pin);\n\n    private native boolean sspReplyNative(byte[] address, int type, boolean accept, int passkey);\n\n    /*package*/\n    native boolean getRemoteServicesNative(byte[] address, int transport);\n\n    /*package*/\n    native boolean getRemoteMasInstancesNative(byte[] address);\n\n    private native int readEnergyInfo();\n\n    /*package*/\n    native boolean factoryResetNative();\n\n    private native void alarmFiredNative();\n\n    private native void dumpNative(FileDescriptor fd, String[] arguments);\n\n    private native byte[] dumpMetricsNative();\n\n    private native byte[] obfuscateAddressNative(byte[] address);\n\n    native boolean setBufferLengthMillisNative(int codec, int value);\n\n    private native int getMetricIdNative(byte[] address);\n\n    /*package*/ native int connectSocketNative(\n            byte[] address, int type, byte[] uuid, int port, int flag, int callingUid);\n\n    /*package*/ native int createSocketChannelNative(\n            int type, String serviceName, byte[] uuid, int port, int flag, int callingUid);\n\n    /*package*/ native void requestMaximumTxDataLengthNative(byte[] address);\n\n    private native boolean allowLowLatencyAudioNative(boolean allowed, byte[] address);\n\n    // Returns if this is a mock object. This is currently used in testing so that we may not call\n    // System.exit() while finalizing the object. Otherwise GC of mock objects unfortunately ends up\n    // calling finalize() which in turn calls System.exit() and the process crashes.\n    //\n    // Mock this in your testing framework to return true to avoid the mentioned behavior. In\n    // production this has no effect.\n    public boolean isMock() {\n        return false;\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 44183,
                                        "general": {
                                            "word_based": 15796,
                                            "char_based": 58930
                                        },
                                        "gemini": 52360
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "038b1e8626399ff3f374d5af987e3efd64a19321",
                            "repo_path": "android_repos/Bluetooth",
                            "result": "failure",
                            "downstream_patch_content": "commit 038b1e8626399ff3f374d5af987e3efd64a19321\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Thu Nov 14 00:35:48 2024 +0000\n\n    Reset permissions for not bonded device\n    \n    According to the PBAP specification,\n    The PSE user shall have to confirm at least the first Phone Book Access\n    Profile connection from each new PCE.\n    \n    According to the MAP specification,\n    The MCE and MSE shall be bonded before setting up a Message Access Profile\n    connection.\n    \n    Let's remove the permissions when the device is unbonded.\n    \n    This is a backport of change ag/30386015 but requires minor changes to\n    logic.\n    \n    Flag: EXEMPT, security fix\n    Bug: 289375038\n    Bug: 289811388\n    Test: atest BluetoothInstrumentationTests\n    Ignore-AOSP-First: security fix\n    Merged-In: I94478a4a45a434732d4bc4810da31ef45ef891af\n    Change-Id: I8b9b29310db2d14e5dfaddc81a682366fbef42d3\n\ndiff --git a/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java b/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java\nindex d62d7ba06d..1a1c912f3f 100644\n--- a/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java\n+++ b/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java\n@@ -439,6 +439,13 @@ final class BondStateMachine extends StateMachine {\n             }\n         }\n \n+        if (newState == BluetoothDevice.BOND_NONE) {\n+            // Remove the permissions for unbonded devices\n+            mAdapterService.setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            mAdapterService.setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            mAdapterService.setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+        }\n+\n         Intent intent = new Intent(BluetoothDevice.ACTION_BOND_STATE_CHANGED);\n         intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);\n         intent.putExtra(BluetoothDevice.EXTRA_BOND_STATE, newState);\n",
                            "downstream_patch_tokens": {
                                "openai": 499,
                                "general": {
                                    "word_based": 210,
                                    "char_based": 496
                                },
                                "gemini": 644
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "android/app/src/com/android/bluetooth/btservice/AdapterService.java",
                                    "total_hunks": 2,
                                    "failed_hunks": [
                                        1,
                                        2
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n\n        if (toState == BOND_NONE) {\n            // Remove the permissions for unbonded devices\n            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n        }\n    }\n>>>>>>> UPSTREAM PATCH (commit 771aed3ea225d9ca2ef91e88f45f330ced952772)",
                                            "merge_conflict_tokens": {
                                                "openai": 100,
                                                "general": {
                                                    "word_based": 28,
                                                    "char_based": 115
                                                },
                                                "gemini": 129
                                            }
                                        }
                                    ],
                                    "inline_merge_token_summary": {
                                        "gemini": 1419,
                                        "openai": 1200,
                                        "general_word": 336,
                                        "general_char": 1380
                                    },
                                    "rej_file_content": "```diff\n--- android/app/src/com/android/bluetooth/btservice/AdapterService.java\n+++ android/app/src/com/android/bluetooth/btservice/AdapterService.java\n@@ -27,6 +27,7 @@ import static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE;\n import static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n import static android.bluetooth.BluetoothAdapter.SCAN_MODE_NONE;\n import static android.bluetooth.BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n+import static android.bluetooth.BluetoothDevice.BOND_NONE;\n import static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\n import static android.bluetooth.IBluetoothLeAudio.LE_AUDIO_GROUP_ID_INVALID;\n import static android.text.format.DateUtils.MINUTE_IN_MILLIS;\n@@ -6121,6 +6122,13 @@ public class AdapterService extends Service {\n             mCsipSetCoordinatorService.handleBondStateChanged(device, fromState, toState);\n         }\n         mDatabaseManager.handleBondStateChanged(device, fromState, toState);\n+\n+        if (toState == BOND_NONE) {\n+            // Remove the permissions for unbonded devices\n+            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+        }\n     }\n \n     static int convertScanModeToHal(int mode) {\n```",
                                    "rej_file_tokens": {
                                        "openai": 282,
                                        "general": {
                                            "word_based": 116,
                                            "char_based": 345
                                        },
                                        "gemini": 358
                                    },
                                    "patch_apply_output": "patching file android/app/src/com/android/bluetooth/btservice/AdapterService.java\nHunk #1 FAILED at 27.\nHunk #2 FAILED at 6121.\n2 out of 2 hunks FAILED -- saving rejects to file android/app/src/com/android/bluetooth/btservice/AdapterService.java.rej",
                                    "inline_merge_output": "patching file android/app/src/com/android/bluetooth/btservice/AdapterService.java\nHunk #1 already applied at 30.\nHunk #2 NOT MERGED at 6125-6135.",
                                    "upstream_file_content": "```java\n/*\n * Copyright (C) 2012 The Android Open Source Project\n * Copyright (C) 2016-2017 The Linux Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.bluetooth.btservice;\n\nimport static android.Manifest.permission.BLUETOOTH_CONNECT;\nimport static android.Manifest.permission.BLUETOOTH_PRIVILEGED;\nimport static android.Manifest.permission.BLUETOOTH_SCAN;\nimport static android.Manifest.permission.DUMP;\nimport static android.Manifest.permission.LOCAL_MAC_ADDRESS;\nimport static android.Manifest.permission.MODIFY_PHONE_STATE;\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE;\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_NONE;\nimport static android.bluetooth.BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\nimport static android.bluetooth.BluetoothDevice.BOND_NONE;\nimport static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\nimport static android.bluetooth.IBluetoothLeAudio.LE_AUDIO_GROUP_ID_INVALID;\nimport static android.text.format.DateUtils.MINUTE_IN_MILLIS;\nimport static android.text.format.DateUtils.SECOND_IN_MILLIS;\n\nimport static com.android.bluetooth.ChangeIds.ENFORCE_CONNECT;\nimport static com.android.bluetooth.Utils.callerIsSystem;\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveOrManagedUser;\nimport static com.android.bluetooth.Utils.getBytesFromAddress;\nimport static com.android.bluetooth.Utils.isDualModeAudioEnabled;\nimport static com.android.bluetooth.Utils.isPackageNameAccurate;\n\nimport static java.util.Objects.requireNonNull;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.RequiresPermission;\nimport android.annotation.SuppressLint;\nimport android.app.AppOpsManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.compat.CompatChanges;\nimport android.bluetooth.BluetoothA2dp;\nimport android.bluetooth.BluetoothActivityEnergyInfo;\nimport android.bluetooth.BluetoothAdapter;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceProfile;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceUse;\nimport android.bluetooth.BluetoothDevice;\nimport android.bluetooth.BluetoothFrameworkInitializer;\nimport android.bluetooth.BluetoothMap;\nimport android.bluetooth.BluetoothProfile;\nimport android.bluetooth.BluetoothProtoEnums;\nimport android.bluetooth.BluetoothQualityReport;\nimport android.bluetooth.BluetoothSap;\nimport android.bluetooth.BluetoothServerSocket;\nimport android.bluetooth.BluetoothSinkAudioPolicy;\nimport android.bluetooth.BluetoothSocket;\nimport android.bluetooth.BluetoothStatusCodes;\nimport android.bluetooth.BluetoothUtils;\nimport android.bluetooth.BluetoothUuid;\nimport android.bluetooth.BufferConstraints;\nimport android.bluetooth.IBluetooth;\nimport android.bluetooth.IBluetoothActivityEnergyInfoListener;\nimport android.bluetooth.IBluetoothCallback;\nimport android.bluetooth.IBluetoothConnectionCallback;\nimport android.bluetooth.IBluetoothMetadataListener;\nimport android.bluetooth.IBluetoothOobDataCallback;\nimport android.bluetooth.IBluetoothPreferredAudioProfilesCallback;\nimport android.bluetooth.IBluetoothQualityReportReadyCallback;\nimport android.bluetooth.IBluetoothSocketManager;\nimport android.bluetooth.IncomingRfcommSocketInfo;\nimport android.bluetooth.OobData;\nimport android.bluetooth.UidTraffic;\nimport android.bluetooth.rfcomm.BluetoothRfcommProtoEnums;\nimport android.companion.CompanionDeviceManager;\nimport android.content.AttributionSource;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.hardware.display.DisplayManager;\nimport android.os.AsyncTask;\nimport android.os.BatteryStatsManager;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelUuid;\nimport android.os.Parcelable;\nimport android.os.PowerManager;\nimport android.os.Process;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.DeviceConfig;\nimport android.provider.Settings;\nimport android.sysprop.BluetoothProperties;\nimport android.text.TextUtils;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.util.SparseArray;\n\nimport com.android.bluetooth.BluetoothMetricsProto;\nimport com.android.bluetooth.BluetoothStatsLog;\nimport com.android.bluetooth.R;\nimport com.android.bluetooth.Utils;\nimport com.android.bluetooth.a2dp.A2dpService;\nimport com.android.bluetooth.a2dpsink.A2dpSinkService;\nimport com.android.bluetooth.avrcp.AvrcpTargetService;\nimport com.android.bluetooth.avrcpcontroller.AvrcpControllerService;\nimport com.android.bluetooth.bas.BatteryService;\nimport com.android.bluetooth.bass_client.BassClientService;\nimport com.android.bluetooth.btservice.InteropUtil.InteropFeature;\nimport com.android.bluetooth.btservice.RemoteDevices.DeviceProperties;\nimport com.android.bluetooth.btservice.bluetoothkeystore.BluetoothKeystoreNativeInterface;\nimport com.android.bluetooth.btservice.bluetoothkeystore.BluetoothKeystoreService;\nimport com.android.bluetooth.btservice.storage.DatabaseManager;\nimport com.android.bluetooth.btservice.storage.MetadataDatabase;\nimport com.android.bluetooth.csip.CsipSetCoordinatorService;\nimport com.android.bluetooth.flags.Flags;\nimport com.android.bluetooth.gatt.GattService;\nimport com.android.bluetooth.hap.HapClientService;\nimport com.android.bluetooth.hearingaid.HearingAidService;\nimport com.android.bluetooth.hfp.HeadsetService;\nimport com.android.bluetooth.hfpclient.HeadsetClientService;\nimport com.android.bluetooth.hid.HidDeviceService;\nimport com.android.bluetooth.hid.HidHostService;\nimport com.android.bluetooth.le_audio.LeAudioService;\nimport com.android.bluetooth.le_scan.ScanController;\nimport com.android.bluetooth.le_scan.ScanManager;\nimport com.android.bluetooth.map.BluetoothMapService;\nimport com.android.bluetooth.mapclient.MapClientService;\nimport com.android.bluetooth.mcp.McpService;\nimport com.android.bluetooth.opp.BluetoothOppService;\nimport com.android.bluetooth.pan.PanService;\nimport com.android.bluetooth.pbap.BluetoothPbapService;\nimport com.android.bluetooth.pbapclient.PbapClientService;\nimport com.android.bluetooth.sap.SapService;\nimport com.android.bluetooth.sdp.SdpManager;\nimport com.android.bluetooth.tbs.TbsService;\nimport com.android.bluetooth.telephony.BluetoothInCallService;\nimport com.android.bluetooth.vc.VolumeControlService;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.modules.expresslog.Counter;\nimport com.android.modules.utils.BackgroundThread;\nimport com.android.modules.utils.BytesMatcher;\n\nimport libcore.util.SneakyThrow;\n\nimport com.google.common.base.Ascii;\nimport com.google.common.collect.EvictingQueue;\nimport com.google.protobuf.InvalidProtocolBufferException;\n\nimport java.io.FileDescriptor;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.time.Duration;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\npublic class AdapterService extends Service {\n    private static final String TAG = \"BluetoothAdapterService\";\n\n    private static final int MESSAGE_PROFILE_SERVICE_STATE_CHANGED = 1;\n    private static final int MESSAGE_PROFILE_SERVICE_REGISTERED = 2;\n    private static final int MESSAGE_PROFILE_SERVICE_UNREGISTERED = 3;\n    private static final int MESSAGE_PREFERRED_AUDIO_PROFILES_AUDIO_FRAMEWORK_TIMEOUT = 4;\n\n    private static final int CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS = 100;\n    private static final int MIN_ADVT_INSTANCES_FOR_MA = 5;\n    private static final int MIN_OFFLOADED_FILTERS = 10;\n    private static final int MIN_OFFLOADED_SCAN_STORAGE_BYTES = 1024;\n\n    private static final Duration PENDING_SOCKET_HANDOFF_TIMEOUT = Duration.ofMinutes(1);\n    private static final Duration GENERATE_LOCAL_OOB_DATA_TIMEOUT = Duration.ofSeconds(2);\n    private static final Duration PREFERRED_AUDIO_PROFILE_CHANGE_TIMEOUT = Duration.ofSeconds(10);\n\n    static final String PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE = \"phonebook_access_permission\";\n    static final String MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE = \"message_access_permission\";\n    static final String SIM_ACCESS_PERMISSION_PREFERENCE_FILE = \"sim_access_permission\";\n\n    private static BluetoothProperties.snoop_log_mode_values sSnoopLogSettingAtEnable =\n            BluetoothProperties.snoop_log_mode_values.EMPTY;\n    private static String sDefaultSnoopLogSettingAtEnable = \"empty\";\n    private static boolean sSnoopLogFilterHeadersSettingAtEnable = false;\n    private static boolean sSnoopLogFilterProfileA2dpSettingAtEnable = false;\n    private static boolean sSnoopLogFilterProfileRfcommSettingAtEnable = false;\n\n    private static BluetoothProperties.snoop_log_filter_profile_pbap_values\n            sSnoopLogFilterProfilePbapModeSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_pbap_values.EMPTY;\n    private static BluetoothProperties.snoop_log_filter_profile_map_values\n            sSnoopLogFilterProfileMapModeSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_map_values.EMPTY;\n\n    private static AdapterService sAdapterService;\n\n    private final Object mEnergyInfoLock = new Object();\n    private final SparseArray<UidTraffic> mUidTraffic = new SparseArray<>();\n\n    private final Map<Integer, ProfileService> mStartedProfiles = new HashMap<>();\n    private final List<ProfileService> mRegisteredProfiles = new ArrayList<>();\n    private final List<ProfileService> mRunningProfiles = new ArrayList<>();\n\n    private final List<DiscoveringPackage> mDiscoveringPackages = new ArrayList<>();\n\n    private final AdapterNativeInterface mNativeInterface = AdapterNativeInterface.getInstance();\n\n    private final Map<BluetoothDevice, RemoteCallbackList<IBluetoothMetadataListener>>\n            mMetadataListeners = new HashMap<>();\n\n    // Map<groupId, PendingAudioProfilePreferenceRequest>\n    @GuardedBy(\"mCsipGroupsPendingAudioProfileChanges\")\n    private final Map<Integer, PendingAudioProfilePreferenceRequest>\n            mCsipGroupsPendingAudioProfileChanges = new HashMap<>();\n\n    private final Map<BluetoothStateCallback, Executor> mLocalCallbacks = new ConcurrentHashMap<>();\n    private final Map<UUID, RfcommListenerData> mBluetoothServerSockets = new ConcurrentHashMap<>();\n    private final ArrayDeque<IBluetoothOobDataCallback> mOobDataCallbackQueue = new ArrayDeque<>();\n\n    private final RemoteCallbackList<IBluetoothPreferredAudioProfilesCallback>\n            mPreferredAudioProfilesCallbacks = new RemoteCallbackList<>();\n    private final RemoteCallbackList<IBluetoothQualityReportReadyCallback>\n            mBluetoothQualityReportReadyCallbacks = new RemoteCallbackList<>();\n    private final RemoteCallbackList<IBluetoothCallback> mRemoteCallbacks =\n            new RemoteCallbackList<>();\n    private final RemoteCallbackList<IBluetoothConnectionCallback> mBluetoothConnectionCallbacks =\n            new RemoteCallbackList<>();\n\n    private final EvictingQueue<String> mScanModeChanges = EvictingQueue.create(10);\n\n    private final DeviceConfigListener mDeviceConfigListener = new DeviceConfigListener();\n\n    private final Looper mLooper;\n    private final AdapterServiceHandler mHandler;\n\n    private int mStackReportedState;\n    private long mTxTimeTotalMs;\n    private long mRxTimeTotalMs;\n    private long mIdleTimeTotalMs;\n    private long mEnergyUsedTotalVoltAmpSecMicro;\n    private HashSet<String> mLeAudioAllowDevices = new HashSet<>();\n\n    private BluetoothAdapter mAdapter;\n    @VisibleForTesting AdapterProperties mAdapterProperties;\n    private AdapterState mAdapterStateMachine;\n    private BondStateMachine mBondStateMachine;\n    private RemoteDevices mRemoteDevices;\n    private AdapterSuspend mAdapterSuspend;\n\n    /* TODO: Consider to remove the search API from this class, if changed to use call-back */\n    private SdpManager mSdpManager = null;\n\n    private boolean mNativeAvailable;\n    private boolean mCleaningUp;\n    private boolean mQuietmode = false;\n    private Map<String, CallerInfo> mBondAttemptCallerInfo = new HashMap<>();\n\n    private BatteryStatsManager mBatteryStatsManager;\n    private PowerManager mPowerManager;\n    private PowerManager.WakeLock mWakeLock;\n    private UserManager mUserManager;\n    private CompanionDeviceManager mCompanionDeviceManager;\n\n    // Phone Policy is not used on all devices. Ensure you null check before using it\n    @Nullable private PhonePolicy mPhonePolicy;\n\n    private ActiveDeviceManager mActiveDeviceManager;\n    private final DatabaseManager mDatabaseManager;\n    private final SilenceDeviceManager mSilenceDeviceManager;\n    private CompanionManager mBtCompanionManager;\n    private AppOpsManager mAppOps;\n\n    private BluetoothSocketManagerBinder mBluetoothSocketManagerBinder;\n\n    private BluetoothKeystoreService mBluetoothKeystoreService;\n    private A2dpService mA2dpService;\n    private A2dpSinkService mA2dpSinkService;\n    private HeadsetService mHeadsetService;\n    private HeadsetClientService mHeadsetClientService;\n    private BluetoothMapService mMapService;\n    private MapClientService mMapClientService;\n    private HidDeviceService mHidDeviceService;\n    private HidHostService mHidHostService;\n    private PanService mPanService;\n    private BluetoothPbapService mPbapService;\n    private PbapClientService mPbapClientService;\n    private HearingAidService mHearingAidService;\n    private HapClientService mHapClientService;\n    private SapService mSapService;\n    private VolumeControlService mVolumeControlService;\n    private CsipSetCoordinatorService mCsipSetCoordinatorService;\n    private LeAudioService mLeAudioService;\n    private BassClientService mBassClientService;\n    private BatteryService mBatteryService;\n    private BluetoothQualityReportNativeInterface mBluetoothQualityReportNativeInterface;\n    private GattService mGattService;\n    private ScanController mScanController;\n\n    private volatile boolean mTestModeEnabled = false;\n\n    private MetricsLogger mMetricsLogger;\n\n    /** Handlers for incoming service calls */\n    private AdapterServiceBinder mBinder;\n\n    private volatile int mScanMode;\n\n    // Report ID definition\n    public enum BqrQualityReportId {\n        QUALITY_REPORT_ID_MONITOR_MODE(0x01),\n        QUALITY_REPORT_ID_APPROACH_LSTO(0x02),\n        QUALITY_REPORT_ID_A2DP_AUDIO_CHOPPY(0x03),\n        QUALITY_REPORT_ID_SCO_VOICE_CHOPPY(0x04),\n        QUALITY_REPORT_ID_ROOT_INFLAMMATION(0x05),\n        QUALITY_REPORT_ID_CONNECT_FAIL(0x08),\n        QUALITY_REPORT_ID_LMP_LL_MESSAGE_TRACE(0x11),\n        QUALITY_REPORT_ID_BT_SCHEDULING_TRACE(0x12),\n        QUALITY_REPORT_ID_CONTROLLER_DBG_INFO(0x13);\n\n        private final int mValue;\n\n        BqrQualityReportId(int value) {\n            mValue = value;\n        }\n\n        public int getValue() {\n            return mValue;\n        }\n    };\n\n    static {\n        if (!Flags.avoidStaticLoadingOfNative()) {\n            Log.d(TAG, \"Loading JNI Library\");\n            if (Utils.isInstrumentationTestMode()) {\n                Log.w(TAG, \"App is instrumented. Skip loading the native\");\n            } else {\n                System.loadLibrary(\"bluetooth_jni\");\n            }\n        }\n    }\n\n    // Keep a constructor for ActivityThread.handleCreateService\n    AdapterService() {\n        this(Looper.getMainLooper());\n    }\n\n    @VisibleForTesting\n    AdapterService(Looper looper) {\n        mLooper = requireNonNull(looper);\n        mHandler = new AdapterServiceHandler(mLooper);\n        mSilenceDeviceManager = new SilenceDeviceManager(this, new ServiceFactory(), mLooper);\n        mDatabaseManager = new DatabaseManager(this);\n    }\n\n    @VisibleForTesting\n    public AdapterService(Context ctx) {\n        this(Looper.getMainLooper());\n        attachBaseContext(ctx);\n    }\n\n    public static synchronized AdapterService getAdapterService() {\n        return sAdapterService;\n    }\n\n    AdapterNativeInterface getNative() {\n        return mNativeInterface;\n    }\n\n    /** Allow test to set an AdapterService to be return by AdapterService.getAdapterService() */\n    @VisibleForTesting\n    public static synchronized void setAdapterService(AdapterService instance) {\n        if (instance == null) {\n            Log.e(TAG, \"setAdapterService() - instance is null\");\n            return;\n        }\n        Log.d(TAG, \"setAdapterService() - set service to \" + instance);\n        sAdapterService = instance;\n    }\n\n    /** Clear test Adapter service. See {@code setAdapterService} */\n    @VisibleForTesting\n    public static synchronized void clearAdapterService(AdapterService instance) {\n        if (sAdapterService == instance) {\n            Log.d(TAG, \"clearAdapterService() - This adapter was cleared \" + instance);\n            sAdapterService = null;\n        } else {\n            Log.d(\n                    TAG,\n                    \"clearAdapterService() - incorrect cleared adapter.\"\n                            + (\" Instance=\" + instance)\n                            + (\" vs sAdapterService=\" + sAdapterService));\n        }\n    }\n\n    /**\n     * Register a {@link ProfileService} with AdapterService.\n     *\n     * @param profile the service being added.\n     */\n    public void addProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_REGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Unregister a ProfileService with AdapterService.\n     *\n     * @param profile the service being removed.\n     */\n    public void removeProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_UNREGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Notify AdapterService that a ProfileService has started or stopped.\n     *\n     * @param profile the service being removed.\n     * @param state {@link BluetoothAdapter#STATE_ON} or {@link BluetoothAdapter#STATE_OFF}\n     */\n    public void onProfileServiceStateChanged(ProfileService profile, int state) {\n        if (state != BluetoothAdapter.STATE_ON && state != BluetoothAdapter.STATE_OFF) {\n            throw new IllegalArgumentException(BluetoothAdapter.nameForState(state));\n        }\n        Message m = mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_STATE_CHANGED);\n        m.obj = profile;\n        m.arg1 = state;\n        mHandler.sendMessage(m);\n    }\n\n    class AdapterServiceHandler extends Handler {\n        AdapterServiceHandler(Looper looper) {\n            super(looper);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            Log.v(TAG, \"handleMessage() - Message: \" + msg.what);\n\n            switch (msg.what) {\n                case MESSAGE_PROFILE_SERVICE_STATE_CHANGED:\n                    Log.v(TAG, \"handleMessage() - MESSAGE_PROFILE_SERVICE_STATE_CHANGED\");\n                    processProfileServiceStateChanged((ProfileService) msg.obj, msg.arg1);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_REGISTERED:\n                    Log.v(TAG, \"handleMessage() - MESSAGE_PROFILE_SERVICE_REGISTERED\");\n                    registerProfileService((ProfileService) msg.obj);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_UNREGISTERED:\n                    Log.v(TAG, \"handleMessage() - MESSAGE_PROFILE_SERVICE_UNREGISTERED\");\n                    unregisterProfileService((ProfileService) msg.obj);\n                    break;\n                case MESSAGE_PREFERRED_AUDIO_PROFILES_AUDIO_FRAMEWORK_TIMEOUT:\n                    Log.e(\n                            TAG,\n                            \"handleMessage() - \"\n                                    + \"MESSAGE_PREFERRED_PROFILE_CHANGE_AUDIO_FRAMEWORK_TIMEOUT\");\n                    int groupId = (int) msg.obj;\n\n                    synchronized (mCsipGroupsPendingAudioProfileChanges) {\n                        removeFromPendingAudioProfileChanges(groupId);\n                        PendingAudioProfilePreferenceRequest request =\n                                mCsipGroupsPendingAudioProfileChanges.remove(groupId);\n                        Log.e(\n                                TAG,\n                                \"Preferred audio profiles change audio framework timeout for \"\n                                        + (\"device \" + request.mDeviceRequested));\n                        sendPreferredAudioProfilesCallbackToApps(\n                                request.mDeviceRequested,\n                                request.mRequestedPreferences,\n                                BluetoothStatusCodes.ERROR_TIMEOUT);\n                    }\n                    break;\n            }\n        }\n\n        private void registerProfileService(ProfileService profile) {\n            if (mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" already registered.\");\n                return;\n            }\n            mRegisteredProfiles.add(profile);\n        }\n\n        private void unregisterProfileService(ProfileService profile) {\n            if (!mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" not registered (UNREGISTER).\");\n                return;\n            }\n            mRegisteredProfiles.remove(profile);\n        }\n\n        private void processProfileServiceStateChanged(ProfileService profile, int state) {\n            switch (state) {\n                case BluetoothAdapter.STATE_ON:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_ON).\");\n                        return;\n                    }\n                    if (mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" already running.\");\n                        return;\n                    }\n                    mRunningProfiles.add(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT starting triggers hardware\n                    // initialization. Configuring a device without GATT causes start up failures.\n                    if (GattService.class.getSimpleName().equals(profile.getName())\n                            && !Flags.scanManagerRefactor()) {\n                        mNativeInterface.enable();\n                    } else if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                            && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n                        mAdapterProperties.onBluetoothReady();\n                        setScanMode(SCAN_MODE_CONNECTABLE, \"processProfileServiceStateChanged\");\n                        updateUuids();\n                        initProfileServices();\n                        mNativeInterface.getAdapterProperty(\n                                AbstractionLayer.BT_PROPERTY_DYNAMIC_AUDIO_BUFFER);\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n                        mBtCompanionManager.loadCompanionInfo();\n                    }\n                    break;\n                case BluetoothAdapter.STATE_OFF:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_OFF).\");\n                        return;\n                    }\n                    if (!mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not running.\");\n                        return;\n                    }\n                    mRunningProfiles.remove(profile);\n\n                    if (Flags.scanManagerRefactor()) {\n                        if (mRunningProfiles.size() == 0) {\n                            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n                        }\n                    } else {\n                        // TODO(b/228875190): GATT is assumed supported. GATT is expected to be the\n                        // only profile available in the \"BLE ON\" state. If only GATT is left, send\n                        // BREDR_STOPPED. If GATT is stopped, deinitialize the hardware.\n                        if ((mRunningProfiles.size() == 1\n                                && (GattService.class\n                                        .getSimpleName()\n                                        .equals(mRunningProfiles.get(0).getName())))) {\n                            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n                        } else if (mRunningProfiles.size() == 0) {\n                            mNativeInterface.disable();\n                        }\n                    }\n                    break;\n                default:\n                    Log.e(TAG, \"Unhandled profile state: \" + state);\n            }\n        }\n    }\n\n    /**\n     * Stores information about requests made to the audio framework arising from calls to {@link\n     * BluetoothAdapter#setPreferredAudioProfiles(BluetoothDevice, Bundle)}.\n     */\n    private static class PendingAudioProfilePreferenceRequest {\n        // The newly requested preferences\n        final Bundle mRequestedPreferences;\n        // Reference counter for how many calls are pending completion in the audio framework\n        int mRemainingRequestsToAudioFramework;\n        // The device with which the request was made. Used for sending the callback.\n        final BluetoothDevice mDeviceRequested;\n\n        /**\n         * Constructs an entity to store information about pending preferred audio profile changes.\n         *\n         * @param preferences newly requested preferences\n         * @param numRequestsToAudioFramework how many active device changed requests are sent to\n         *     the audio framework\n         * @param device the device with which the request was made\n         */\n        PendingAudioProfilePreferenceRequest(\n                Bundle preferences, int numRequestsToAudioFramework, BluetoothDevice device) {\n            mRequestedPreferences = preferences;\n            mRemainingRequestsToAudioFramework = numRequestsToAudioFramework;\n            mDeviceRequested = device;\n        }\n    }\n\n    final @NonNull <T> T getNonNullSystemService(@NonNull Class<T> clazz) {\n        return requireNonNull(getSystemService(clazz));\n    }\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        Log.d(TAG, \"onCreate()\");\n        if (!Flags.fastBindToApp()) {\n            init();\n            return;\n        }\n        // OnCreate must perform the minimum of infaillible and mandatory initialization\n        mRemoteDevices = new RemoteDevices(this, mLooper);\n        mAdapterProperties = new AdapterProperties(this);\n        mAdapterStateMachine = new AdapterState(this, mLooper);\n        mBinder = new AdapterServiceBinder(this);\n        mUserManager = getNonNullSystemService(UserManager.class);\n        mAppOps = getNonNullSystemService(AppOpsManager.class);\n        mPowerManager = getNonNullSystemService(PowerManager.class);\n        mBatteryStatsManager = getNonNullSystemService(BatteryStatsManager.class);\n        mCompanionDeviceManager = getNonNullSystemService(CompanionDeviceManager.class);\n        setAdapterService(this);\n    }\n\n    @SuppressLint(\"AndroidFrameworkRequiresPermission\")\n    private void init() {\n        Log.d(TAG, \"init()\");\n        Config.init(this);\n        initMetricsLogger();\n        mDeviceConfigListener.start();\n\n        if (!Flags.fastBindToApp()) {\n            // Moved to OnCreate\n            mUserManager = getNonNullSystemService(UserManager.class);\n            mAppOps = getNonNullSystemService(AppOpsManager.class);\n            mPowerManager = getNonNullSystemService(PowerManager.class);\n            mBatteryStatsManager = getNonNullSystemService(BatteryStatsManager.class);\n            mCompanionDeviceManager = getNonNullSystemService(CompanionDeviceManager.class);\n            mRemoteDevices = new RemoteDevices(this, mLooper);\n        }\n\n        clearDiscoveringPackages();\n        if (!Flags.fastBindToApp()) {\n            mBinder = new AdapterServiceBinder(this);\n        }\n        mAdapter = BluetoothAdapter.getDefaultAdapter();\n        if (!Flags.fastBindToApp()) {\n            // Moved to OnCreate\n            mAdapterProperties = new AdapterProperties(this);\n            mAdapterStateMachine = new AdapterState(this, mLooper);\n        }\n        boolean isCommonCriteriaMode =\n                getNonNullSystemService(DevicePolicyManager.class)\n                        .isCommonCriteriaModeEnabled(null);\n        mBluetoothKeystoreService =\n                new BluetoothKeystoreService(\n                        BluetoothKeystoreNativeInterface.getInstance(), isCommonCriteriaMode);\n        mBluetoothKeystoreService.start();\n        int configCompareResult = mBluetoothKeystoreService.getCompareResult();\n\n        // Start tracking Binder latency for the bluetooth process.\n        BluetoothFrameworkInitializer.initializeBinderCallsStats(getApplicationContext());\n\n        // Android TV doesn't show consent dialogs for just works and encryption only le pairing\n        boolean isAtvDevice =\n                getApplicationContext()\n                        .getPackageManager()\n                        .hasSystemFeature(PackageManager.FEATURE_LEANBACK_ONLY);\n        if (Flags.avoidStaticLoadingOfNative()) {\n            if (Utils.isInstrumentationTestMode()) {\n                Log.w(TAG, \"This Bluetooth App is instrumented. ** Skip loading the native **\");\n            } else {\n                Log.d(TAG, \"Loading JNI Library\");\n                System.loadLibrary(\"bluetooth_jni\");\n            }\n        }\n        mNativeInterface.init(\n                this,\n                mAdapterProperties,\n                mUserManager.isGuestUser(),\n                isCommonCriteriaMode,\n                configCompareResult,\n                isAtvDevice,\n                getApplicationInfo().dataDir);\n        mNativeAvailable = true;\n        // Load the name and address\n        mNativeInterface.getAdapterProperty(AbstractionLayer.BT_PROPERTY_BDADDR);\n        mNativeInterface.getAdapterProperty(AbstractionLayer.BT_PROPERTY_BDNAME);\n        mNativeInterface.getAdapterProperty(AbstractionLayer.BT_PROPERTY_CLASS_OF_DEVICE);\n\n        mBluetoothKeystoreService.initJni();\n\n        mBluetoothQualityReportNativeInterface =\n                requireNonNull(\n                        BluetoothQualityReportNativeInterface.getInstance(),\n                        \"BluetoothQualityReportNativeInterface cannot be null when BQR starts\");\n        mBluetoothQualityReportNativeInterface.init();\n\n        if (Flags.fastBindToApp()) {\n            mSdpManager = new SdpManager(this, mLooper);\n        } else {\n            mSdpManager = new SdpManager(this);\n        }\n\n        mDatabaseManager.start(MetadataDatabase.createDatabase(this));\n\n        boolean isAutomotiveDevice =\n                getApplicationContext()\n                        .getPackageManager()\n                        .hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);\n\n        /*\n         * Phone policy is specific to phone implementations and hence if a device wants to exclude\n         * it out then it can be disabled by using the flag below. Phone policy is never used on\n         * Android Automotive OS builds, in favor of a policy currently located in\n         * CarBluetoothService.\n         */\n        if (!isAutomotiveDevice && getResources().getBoolean(R.bool.enable_phone_policy)) {\n            Log.i(TAG, \"Phone policy enabled\");\n            mPhonePolicy = new PhonePolicy(this, new ServiceFactory());\n            mPhonePolicy.start();\n        } else {\n            Log.i(TAG, \"Phone policy disabled\");\n        }\n\n        if (Flags.audioRoutingCentralization()) {\n            mActiveDeviceManager = new AudioRoutingManager(this, new ServiceFactory());\n        } else {\n            mActiveDeviceManager = new ActiveDeviceManager(this, new ServiceFactory());\n        }\n        mActiveDeviceManager.start();\n\n        mSilenceDeviceManager.start();\n\n        mBtCompanionManager = new CompanionManager(this, new ServiceFactory());\n\n        mBluetoothSocketManagerBinder = new BluetoothSocketManagerBinder(this);\n\n        if (Flags.adapterSuspendMgmt()) {\n            mAdapterSuspend =\n                    new AdapterSuspend(\n                            mNativeInterface, mLooper, getSystemService(DisplayManager.class));\n        }\n\n        if (!Flags.fastBindToApp()) {\n            setAdapterService(this);\n        }\n\n        invalidateBluetoothCaches();\n\n        // First call to getSharedPreferences will result in a file read into\n        // memory cache. Call it here asynchronously to avoid potential ANR\n        // in the future\n        new AsyncTask<Void, Void, Void>() {\n            @Override\n            protected Void doInBackground(Void... params) {\n                getSharedPreferences(\n                        PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE, Context.MODE_PRIVATE);\n                getSharedPreferences(\n                        MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE, Context.MODE_PRIVATE);\n                getSharedPreferences(SIM_ACCESS_PERMISSION_PREFERENCE_FILE, Context.MODE_PRIVATE);\n                return null;\n            }\n        }.execute();\n\n        try {\n            int systemUiUid =\n                    getApplicationContext()\n                            .createContextAsUser(UserHandle.SYSTEM, /* flags= */ 0)\n                            .getPackageManager()\n                            .getPackageUid(\n                                    \"com.android.systemui\", PackageManager.MATCH_SYSTEM_ONLY);\n\n            Utils.setSystemUiUid(systemUiUid);\n        } catch (PackageManager.NameNotFoundException e) {\n            // Some platforms, such as wearables do not have a system ui.\n            Log.w(TAG, \"Unable to resolve SystemUI's UID.\", e);\n        }\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        Log.d(TAG, \"onBind()\");\n        return mBinder;\n    }\n\n    @Override\n    public boolean onUnbind(Intent intent) {\n        Log.d(TAG, \"onUnbind()\");\n        return super.onUnbind(intent);\n    }\n\n    @Override\n    public void onDestroy() {\n        Log.d(TAG, \"onDestroy()\");\n    }\n\n    public ActiveDeviceManager getActiveDeviceManager() {\n        return mActiveDeviceManager;\n    }\n\n    public SilenceDeviceManager getSilenceDeviceManager() {\n        return mSilenceDeviceManager;\n    }\n\n    private boolean initMetricsLogger() {\n        if (mMetricsLogger != null) {\n            return false;\n        }\n        mMetricsLogger = MetricsLogger.getInstance();\n        return mMetricsLogger.init(this);\n    }\n\n    private boolean closeMetricsLogger() {\n        if (mMetricsLogger == null) {\n            return false;\n        }\n        boolean result = mMetricsLogger.close();\n        mMetricsLogger = null;\n        return result;\n    }\n\n    /**\n     * Log L2CAP CoC Server Connection Metrics\n     *\n     * @param port port of socket\n     * @param isSecured if secured API is called\n     * @param result transaction result of the connection\n     * @param socketCreationLatencyMillis latency of the connection\n     * @param timeoutMillis timeout set by the app\n     */\n    public void logL2capcocServerConnection(\n            BluetoothDevice device,\n            int port,\n            boolean isSecured,\n            int result,\n            long socketCreationTimeMillis,\n            long socketCreationLatencyMillis,\n            long socketConnectionTimeMillis,\n            long timeoutMillis,\n            int appUid) {\n\n        int metricId = 0;\n        if (device != null) {\n            metricId = getMetricId(device);\n        }\n        long currentTime = System.currentTimeMillis();\n        long endToEndLatencyMillis = currentTime - socketCreationTimeMillis;\n        long socketAcceptanceLatencyMillis = currentTime - socketConnectionTimeMillis;\n        Log.i(\n                TAG,\n                \"Statslog L2capcoc server connection.\"\n                        + (\" metricId \" + metricId)\n                        + (\" port \" + port)\n                        + (\" isSecured \" + isSecured)\n                        + (\" result \" + result)\n                        + (\" endToEndLatencyMillis \" + endToEndLatencyMillis)\n                        + (\" socketCreationLatencyMillis \" + socketCreationLatencyMillis)\n                        + (\" socketAcceptanceLatencyMillis \" + socketAcceptanceLatencyMillis)\n                        + (\" timeout set by app \" + timeoutMillis)\n                        + (\" appUid \" + appUid));\n        BluetoothStatsLog.write(\n                BluetoothStatsLog.BLUETOOTH_L2CAP_COC_SERVER_CONNECTION,\n                metricId,\n                port,\n                isSecured,\n                result,\n                endToEndLatencyMillis,\n                timeoutMillis,\n                appUid,\n                socketCreationLatencyMillis,\n                socketAcceptanceLatencyMillis);\n    }\n\n    public void setMetricsLogger(MetricsLogger metricsLogger) {\n        mMetricsLogger = metricsLogger;\n    }\n\n    /**\n     * Log L2CAP CoC Client Connection Metrics\n     *\n     * @param device Bluetooth device\n     * @param port port of socket\n     * @param isSecured if secured API is called\n     * @param result transaction result of the connection\n     * @param socketCreationLatencyNanos latency of the connection\n     */\n    public void logL2capcocClientConnection(\n            BluetoothDevice device,\n            int port,\n            boolean isSecured,\n            int result,\n            long socketCreationTimeNanos,\n            long socketCreationLatencyNanos,\n            long socketConnectionTimeNanos,\n            int appUid) {\n\n        int metricId = getMetricId(device);\n        long currentTime = System.nanoTime();\n        long endToEndLatencyMillis = (currentTime - socketCreationTimeNanos) / 1000000;\n        long socketCreationLatencyMillis = socketCreationLatencyNanos / 1000000;\n        long socketConnectionLatencyMillis = (currentTime - socketConnectionTimeNanos) / 1000000;\n        Log.i(\n                TAG,\n                \"Statslog L2capcoc client connection.\"\n                        + (\" metricId \" + metricId)\n                        + (\" port \" + port)\n                        + (\" isSecured \" + isSecured)\n                        + (\" result \" + result)\n                        + (\" endToEndLatencyMillis \" + endToEndLatencyMillis)\n                        + (\" socketCreationLatencyMillis \" + socketCreationLatencyMillis)\n                        + (\" socketConnectionLatencyMillis \" + socketConnectionLatencyMillis)\n                        + (\" appUid \" + appUid));\n        BluetoothStatsLog.write(\n                BluetoothStatsLog.BLUETOOTH_L2CAP_COC_CLIENT_CONNECTION,\n                metricId,\n                port,\n                isSecured,\n                result,\n                endToEndLatencyMillis,\n                appUid,\n                socketCreationLatencyMillis,\n                socketConnectionLatencyMillis);\n    }\n\n    /**\n     * Log RFCOMM Connection Metrics\n     *\n     * @param device Bluetooth device\n     * @param isSecured if secured API is called\n     * @param resultCode transaction result of the connection\n     * @param isSerialPort true if service class UUID is 0x1101\n     */\n    public void logRfcommConnectionAttempt(\n            BluetoothDevice device,\n            boolean isSecured,\n            int resultCode,\n            long socketCreationTimeNanos,\n            boolean isSerialPort,\n            int appUid) {\n        int metricId = getMetricId(device);\n        long currentTime = System.nanoTime();\n        long endToEndLatencyNanos = currentTime - socketCreationTimeNanos;\n        byte[] remoteDeviceInfoBytes = MetricsLogger.getInstance().getRemoteDeviceInfoProto(device);\n        BluetoothStatsLog.write(\n                BluetoothStatsLog.BLUETOOTH_RFCOMM_CONNECTION_ATTEMPTED,\n                metricId,\n                endToEndLatencyNanos,\n                isSecured\n                        ? BluetoothRfcommProtoEnums.SOCKET_SECURITY_SECURE\n                        : BluetoothRfcommProtoEnums.SOCKET_SECURITY_INSECURE,\n                resultCode,\n                isSerialPort,\n                appUid,\n                remoteDeviceInfoBytes);\n    }\n\n    public boolean sdpSearch(BluetoothDevice device, ParcelUuid uuid) {\n        if (mSdpManager == null) {\n            return false;\n        }\n        mSdpManager.sdpSearch(device, uuid);\n        return true;\n    }\n\n    @RequiresPermission(BLUETOOTH_CONNECT)\n    void bringUpBle() {\n        Log.d(TAG, \"bleOnProcessStart()\");\n\n        if (getResources()\n                .getBoolean(R.bool.config_bluetooth_reload_supported_profiles_when_enabled)) {\n            Config.init(getApplicationContext());\n        }\n\n        // Reset |mRemoteDevices| whenever BLE is turned off then on\n        // This is to replace the fact that |mRemoteDevices| was\n        // reinitialized in previous code.\n        //\n        // TODO(apanicke): The reason is unclear but\n        // I believe it is to clear the variable every time BLE was\n        // turned off then on. The same effect can be achieved by\n        // calling cleanup but this may not be necessary at all\n        // We should figure out why this is needed later\n        mRemoteDevices.reset();\n        mAdapterProperties.init(mRemoteDevices);\n\n        Log.d(TAG, \"bleOnProcessStart() - Make Bond State Machine\");\n        mBondStateMachine = BondStateMachine.make(this, mAdapterProperties, mRemoteDevices);\n\n        mNativeInterface.getCallbacks().init(mBondStateMachine, mRemoteDevices);\n\n        mBatteryStatsManager.reportBleScanReset();\n        BluetoothStatsLog.write_non_chained(\n                BluetoothStatsLog.BLE_SCAN_STATE_CHANGED,\n                -1,\n                null,\n                BluetoothStatsLog.BLE_SCAN_STATE_CHANGED__STATE__RESET,\n                false,\n                false,\n                false);\n\n        // TODO(b/228875190): GATT is assumed supported. As a result, we don't respect the\n        // configuration sysprop. Configuring a device without GATT, although rare, will cause stack\n        // start up errors yielding init loops.\n        if (!GattService.isEnabled()) {\n            Log.w(\n                    TAG,\n                    \"GATT is configured off but the stack assumes it to be enabled. Start anyway.\");\n        }\n        if (Flags.scanManagerRefactor()) {\n            startScanController();\n        } else {\n            startGattProfileService();\n        }\n    }\n\n    void bringDownBle() {\n        if (Flags.scanManagerRefactor()) {\n            stopScanController();\n        } else {\n            stopGattProfileService();\n        }\n    }\n\n    void stateChangeCallback(int status) {\n        if (status == AbstractionLayer.BT_STATE_OFF) {\n            Log.d(TAG, \"stateChangeCallback: disableNative() completed\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        } else if (status == AbstractionLayer.BT_STATE_ON) {\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STARTED);\n        } else {\n            Log.e(TAG, \"Incorrect status \" + status + \" in stateChangeCallback\");\n        }\n    }\n\n    void startProfileServices() {\n        Log.d(TAG, \"startCoreServices()\");\n        int[] supportedProfileServices = Config.getSupportedProfiles();\n        if (Flags.scanManagerRefactor()) {\n            // Scanning is always supported, started separately, and is not a profile service.\n            // This will check other profile services.\n            if (supportedProfileServices.length == 0) {\n                mAdapterProperties.onBluetoothReady();\n                setScanMode(SCAN_MODE_CONNECTABLE, \"startProfileServices\");\n                updateUuids();\n                mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n            } else {\n                setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_ON);\n            }\n        } else {\n            // TODO(b/228875190): GATT is assumed supported. If we support no other profiles then\n            // just move on to BREDR_STARTED. Note that configuring GATT to NOT supported will cause\n            // adapter initialization failures\n            if (supportedProfileServices.length == 1\n                    && supportedProfileServices[0] == BluetoothProfile.GATT) {\n                mAdapterProperties.onBluetoothReady();\n                setScanMode(SCAN_MODE_CONNECTABLE, \"startProfileServices\");\n                updateUuids();\n                mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n            } else {\n                setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_ON);\n            }\n        }\n    }\n\n    void stopProfileServices() {\n        // Make sure to stop classic background tasks now\n        mNativeInterface.cancelDiscovery();\n        setScanMode(SCAN_MODE_NONE, \"StopProfileServices\");\n\n        int[] supportedProfileServices = Config.getSupportedProfiles();\n        if (Flags.scanManagerRefactor()) {\n            // Scanning is always supported, started separately, and is not a profile service.\n            // This will check other profile services.\n            if (supportedProfileServices.length == 0) {\n                mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n            } else {\n                setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_OFF);\n            }\n        } else {\n            // TODO(b/228875190): GATT is assumed supported. If we support no profiles then just\n            // move on to BREDR_STOPPED\n            if (supportedProfileServices.length == 1\n                    && (mRunningProfiles.size() == 1\n                            && GattService.class\n                                    .getSimpleName()\n                                    .equals(mRunningProfiles.get(0).getName()))) {\n                Log.d(\n                        TAG,\n                        \"stopProfileServices() - No profiles services to stop or already stopped.\");\n                mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n            } else {\n                setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_OFF);\n            }\n        }\n    }\n\n    private void startGattProfileService() {\n        Log.d(TAG, \"startGattProfileService() called\");\n        mGattService = new GattService(this);\n\n        mStartedProfiles.put(BluetoothProfile.GATT, mGattService);\n        addProfile(mGattService);\n        mGattService.start();\n        mGattService.setAvailable(true);\n        onProfileServiceStateChanged(mGattService, BluetoothAdapter.STATE_ON);\n    }\n\n    private void startScanController() {\n        Log.d(TAG, \"startScanController() called\");\n        mScanController = new ScanController(this);\n        mNativeInterface.enable();\n    }\n\n    private void stopGattProfileService() {\n        Log.d(TAG, \"stopGattProfileService() called\");\n        setScanMode(SCAN_MODE_NONE, \"stopGattProfileService\");\n\n        if (mRunningProfiles.size() == 0) {\n            Log.d(TAG, \"stopGattProfileService() - No profiles services to stop.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        }\n\n        mStartedProfiles.remove(BluetoothProfile.GATT);\n        if (mGattService != null) {\n            mGattService.setAvailable(false);\n            onProfileServiceStateChanged(mGattService, BluetoothAdapter.STATE_OFF);\n            mGattService.stop();\n            removeProfile(mGattService);\n            mGattService.cleanup();\n            mGattService.getBinder().cleanup();\n            mGattService = null;\n        }\n    }\n\n    private void stopScanController() {\n        Log.d(TAG, \"stopScanController() called\");\n        setScanMode(SCAN_MODE_NONE, \"stopScanController\");\n\n        if (mScanController == null) {\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        } else {\n            mScanController.stop();\n            mScanController = null;\n            mNativeInterface.disable();\n        }\n    }\n\n    private void invalidateBluetoothGetStateCache() {\n        if (Flags.getStateFromSystemServer()) {\n            // State is managed by the system server\n            return;\n        }\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n    }\n\n    void updateLeAudioProfileServiceState() {\n        Set<Integer> nonSupportedProfiles = new HashSet<>();\n\n        if (!isLeConnectedIsochronousStreamCentralSupported()) {\n            for (int profileId : Config.getLeAudioUnicastProfiles()) {\n                nonSupportedProfiles.add(profileId);\n            }\n        }\n\n        if (!isLeAudioBroadcastAssistantSupported()) {\n            nonSupportedProfiles.add(BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT);\n        }\n\n        if (!isLeAudioBroadcastSourceSupported()) {\n            Config.setProfileEnabled(BluetoothProfile.LE_AUDIO_BROADCAST, false);\n        }\n\n        // Disable the non-supported profiles service\n        for (int profileId : nonSupportedProfiles) {\n            Config.setProfileEnabled(profileId, false);\n            if (mStartedProfiles.containsKey(profileId)) {\n                setProfileServiceState(profileId, BluetoothAdapter.STATE_OFF);\n            }\n        }\n    }\n\n    void updateAdapterName(String name) {\n        int n = mRemoteCallbacks.beginBroadcast();\n        Log.d(TAG, \"updateAdapterName(\" + name + \")\");\n        for (int i = 0; i < n; i++) {\n            try {\n                mRemoteCallbacks.getBroadcastItem(i).onAdapterNameChange(name);\n            } catch (RemoteException e) {\n                Log.d(TAG, \"updateAdapterName() - Callback #\" + i + \" failed (\" + e + \")\");\n            }\n        }\n        mRemoteCallbacks.finishBroadcast();\n    }\n\n    void updateAdapterAddress(String address) {\n        int n = mRemoteCallbacks.beginBroadcast();\n        Log.d(TAG, \"updateAdapterAddress(\" + BluetoothUtils.toAnonymizedAddress(address) + \")\");\n        for (int i = 0; i < n; i++) {\n            try {\n                mRemoteCallbacks.getBroadcastItem(i).onAdapterAddressChange(address);\n            } catch (RemoteException e) {\n                Log.d(TAG, \"updateAdapterAddress() - Callback #\" + i + \" failed (\" + e + \")\");\n            }\n        }\n        mRemoteCallbacks.finishBroadcast();\n    }\n\n    void updateAdapterState(int prevState, int newState) {\n        mAdapterProperties.setState(newState);\n        invalidateBluetoothGetStateCache();\n\n        // Only BluetoothManagerService should be registered\n        int n = mRemoteCallbacks.beginBroadcast();\n        Log.d(\n                TAG,\n                \"updateAdapterState() - Broadcasting state \"\n                        + BluetoothAdapter.nameForState(newState)\n                        + \" to \"\n                        + n\n                        + \" receivers.\");\n        for (int i = 0; i < n; i++) {\n            try {\n                mRemoteCallbacks.getBroadcastItem(i).onBluetoothStateChange(prevState, newState);\n            } catch (RemoteException e) {\n                Log.d(TAG, \"updateAdapterState() - Callback #\" + i + \" failed (\" + e + \")\");\n            }\n        }\n        mRemoteCallbacks.finishBroadcast();\n\n        for (Map.Entry<BluetoothStateCallback, Executor> e : mLocalCallbacks.entrySet()) {\n            e.getValue().execute(() -> e.getKey().onBluetoothStateChange(prevState, newState));\n        }\n\n        // Turn the Adapter all the way off if we are disabling and the snoop log setting changed.\n        if (newState == BluetoothAdapter.STATE_BLE_TURNING_ON) {\n            sSnoopLogSettingAtEnable =\n                    BluetoothProperties.snoop_log_mode()\n                            .orElse(BluetoothProperties.snoop_log_mode_values.EMPTY);\n            sDefaultSnoopLogSettingAtEnable =\n                    Settings.Global.getString(\n                            getContentResolver(), Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n\n            sSnoopLogFilterHeadersSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_snoop_headers_enabled().orElse(false);\n            sSnoopLogFilterProfileA2dpSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_a2dp_enabled().orElse(false);\n            sSnoopLogFilterProfileRfcommSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_rfcomm_enabled().orElse(false);\n            sSnoopLogFilterProfilePbapModeSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_pbap()\n                            .orElse(BluetoothProperties.snoop_log_filter_profile_pbap_values.EMPTY);\n            sSnoopLogFilterProfileMapModeSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_map()\n                            .orElse(BluetoothProperties.snoop_log_filter_profile_map_values.EMPTY);\n\n            BluetoothProperties.snoop_default_mode(\n                    BluetoothProperties.snoop_default_mode_values.DISABLED);\n            for (BluetoothProperties.snoop_default_mode_values value :\n                    BluetoothProperties.snoop_default_mode_values.values()) {\n                if (value.getPropValue().equals(sDefaultSnoopLogSettingAtEnable)) {\n                    BluetoothProperties.snoop_default_mode(value);\n                }\n            }\n        } else if (newState == BluetoothAdapter.STATE_BLE_ON\n                && prevState != BluetoothAdapter.STATE_OFF) {\n            var snoopLogSetting =\n                    BluetoothProperties.snoop_log_mode()\n                            .orElse(BluetoothProperties.snoop_log_mode_values.EMPTY);\n            var snoopDefaultModeSetting =\n                    Settings.Global.getString(\n                            getContentResolver(), Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n\n            var snoopLogFilterHeadersSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_snoop_headers_enabled().orElse(false);\n            var snoopLogFilterProfileA2dpSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_a2dp_enabled().orElse(false);\n            var snoopLogFilterProfileRfcommSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_rfcomm_enabled().orElse(false);\n\n            var snoopLogFilterProfilePbapModeSetting =\n                    BluetoothProperties.snoop_log_filter_profile_pbap()\n                            .orElse(BluetoothProperties.snoop_log_filter_profile_pbap_values.EMPTY);\n            var snoopLogFilterProfileMapModeSetting =\n                    BluetoothProperties.snoop_log_filter_profile_map()\n                            .orElse(BluetoothProperties.snoop_log_filter_profile_map_values.EMPTY);\n\n            if (!(sSnoopLogSettingAtEnable == snoopLogSetting)\n                    || !(Objects.equals(sDefaultSnoopLogSettingAtEnable, snoopDefaultModeSetting))\n                    || !(sSnoopLogFilterHeadersSettingAtEnable\n                            == snoopLogFilterHeadersSettingAtEnable)\n                    || !(sSnoopLogFilterProfileA2dpSettingAtEnable\n                            == snoopLogFilterProfileA2dpSettingAtEnable)\n                    || !(sSnoopLogFilterProfileRfcommSettingAtEnable\n                            == snoopLogFilterProfileRfcommSettingAtEnable)\n                    || !(sSnoopLogFilterProfilePbapModeSettingAtEnable\n                            == snoopLogFilterProfilePbapModeSetting)\n                    || !(sSnoopLogFilterProfileMapModeSettingAtEnable\n                            == snoopLogFilterProfileMapModeSetting)) {\n                mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n            }\n        }\n    }\n\n    void linkQualityReportCallback(\n            long timestamp,\n            int reportId,\n            int rssi,\n            int snr,\n            int retransmissionCount,\n            int packetsNotReceiveCount,\n            int negativeAcknowledgementCount) {\n        BluetoothInCallService bluetoothInCallService = BluetoothInCallService.getInstance();\n\n        if (reportId == BqrQualityReportId.QUALITY_REPORT_ID_SCO_VOICE_CHOPPY.getValue()) {\n            if (bluetoothInCallService == null) {\n                Log.w(\n                        TAG,\n                        \"No BluetoothInCallService while trying to send BQR.\"\n                                + (\" timestamp: \" + timestamp)\n                                + (\" reportId: \" + reportId)\n                                + (\" rssi: \" + rssi)\n                                + (\" snr: \" + snr)\n                                + (\" retransmissionCount: \" + retransmissionCount)\n                                + (\" packetsNotReceiveCount: \" + packetsNotReceiveCount)\n                                + (\" negativeAcknowledgementCount: \"\n                                        + negativeAcknowledgementCount));\n                return;\n            }\n            bluetoothInCallService.sendBluetoothCallQualityReport(\n                    timestamp,\n                    rssi,\n                    snr,\n                    retransmissionCount,\n                    packetsNotReceiveCount,\n                    negativeAcknowledgementCount);\n        }\n    }\n\n    /**\n     * Callback from Bluetooth Quality Report Native Interface to inform the listeners about\n     * Bluetooth Quality.\n     *\n     * @param device is the BluetoothDevice which connection quality is being reported\n     * @param bluetoothQualityReport a Parcel that contains information about Bluetooth Quality\n     * @return whether the Bluetooth stack acknowledged the change successfully\n     */\n    public int bluetoothQualityReportReadyCallback(\n            BluetoothDevice device, BluetoothQualityReport bluetoothQualityReport) {\n        synchronized (mBluetoothQualityReportReadyCallbacks) {\n            int n = mBluetoothQualityReportReadyCallbacks.beginBroadcast();\n            Log.d(\n                    TAG,\n                    \"bluetoothQualityReportReadyCallback() - \"\n                            + \"Broadcasting Bluetooth Quality Report to \"\n                            + n\n                            + \" receivers.\");\n            for (int i = 0; i < n; i++) {\n                try {\n                    mBluetoothQualityReportReadyCallbacks\n                            .getBroadcastItem(i)\n                            .onBluetoothQualityReportReady(\n                                    device, bluetoothQualityReport, BluetoothStatusCodes.SUCCESS);\n                } catch (RemoteException e) {\n                    Log.d(\n                            TAG,\n                            \"bluetoothQualityReportReadyCallback() - Callback #\"\n                                    + i\n                                    + \" failed (\"\n                                    + e\n                                    + \")\");\n                }\n            }\n            mBluetoothQualityReportReadyCallbacks.finishBroadcast();\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    void switchBufferSizeCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            Log.e(\n                    TAG,\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n            return;\n        }\n\n        // Send intent to fastpair\n        Intent switchBufferSizeIntent = new Intent(BluetoothDevice.ACTION_SWITCH_BUFFER_SIZE);\n        switchBufferSizeIntent.setClassName(\n                getString(com.android.bluetooth.R.string.peripheral_link_package),\n                getString(com.android.bluetooth.R.string.peripheral_link_package)\n                        + getString(com.android.bluetooth.R.string.peripheral_link_service));\n        switchBufferSizeIntent.putExtra(BluetoothDevice.EXTRA_DEVICE, activeDevices.get(0));\n        switchBufferSizeIntent.putExtra(\n                BluetoothDevice.EXTRA_LOW_LATENCY_BUFFER_SIZE, isLowLatencyBufferSize);\n        sendBroadcastMultiplePermissions(\n                switchBufferSizeIntent,\n                new String[] {BLUETOOTH_CONNECT, BLUETOOTH_PRIVILEGED},\n                null);\n    }\n\n    void switchCodecCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            Log.e(\n                    TAG,\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n            return;\n        }\n        mA2dpService.switchCodecByBufferSize(activeDevices.get(0), isLowLatencyBufferSize);\n    }\n\n    @RequiresPermission(BLUETOOTH_CONNECT)\n    void cleanup() {\n        Log.d(TAG, \"cleanup()\");\n        if (mCleaningUp) {\n            Log.e(TAG, \"cleanup() - Service already starting to cleanup, ignoring request...\");\n            return;\n        }\n\n        closeMetricsLogger();\n\n        clearAdapterService(this);\n\n        mCleaningUp = true;\n        invalidateBluetoothCaches();\n\n        stopRfcommServerSockets();\n\n        // This wake lock release may also be called concurrently by\n        // {@link #releaseWakeLock(String lockName)}, so a synchronization is needed here.\n        synchronized (this) {\n            if (mWakeLock != null) {\n                if (mWakeLock.isHeld()) {\n                    mWakeLock.release();\n                }\n                mWakeLock = null;\n            }\n        }\n\n        mDatabaseManager.cleanup();\n\n        if (mAdapterStateMachine != null) {\n            mAdapterStateMachine.doQuit();\n        }\n\n        if (mBondStateMachine != null) {\n            mBondStateMachine.doQuit();\n        }\n\n        if (mRemoteDevices != null) {\n            mRemoteDevices.reset();\n        }\n\n        if (mSdpManager != null) {\n            mSdpManager.cleanup();\n            mSdpManager = null;\n        }\n\n        if (mNativeAvailable) {\n            Log.d(TAG, \"cleanup() - Cleaning up adapter native\");\n            mNativeInterface.cleanup();\n            mNativeAvailable = false;\n        }\n\n        if (mAdapterProperties != null) {\n            mAdapterProperties.cleanup();\n        }\n\n        if (mNativeInterface.getCallbacks() != null) {\n            mNativeInterface.getCallbacks().cleanup();\n        }\n\n        if (mBluetoothKeystoreService != null) {\n            Log.d(TAG, \"cleanup(): mBluetoothKeystoreService.cleanup()\");\n            mBluetoothKeystoreService.cleanup();\n        }\n\n        if (mPhonePolicy != null) {\n            mPhonePolicy.cleanup();\n        }\n\n        mSilenceDeviceManager.cleanup();\n\n        if (mActiveDeviceManager != null) {\n            mActiveDeviceManager.cleanup();\n        }\n\n        if (mBluetoothSocketManagerBinder != null) {\n            mBluetoothSocketManagerBinder.cleanUp();\n            mBluetoothSocketManagerBinder = null;\n        }\n\n        if (mAdapterSuspend != null) {\n            mAdapterSuspend.cleanup();\n            mAdapterSuspend = null;\n        }\n\n        mPreferredAudioProfilesCallbacks.kill();\n\n        mBluetoothQualityReportReadyCallbacks.kill();\n\n        mBluetoothConnectionCallbacks.kill();\n\n        mRemoteCallbacks.kill();\n\n        mMetadataListeners.values().forEach(v -> v.kill());\n    }\n\n    private void invalidateBluetoothCaches() {\n        BluetoothAdapter.invalidateGetProfileConnectionStateCache();\n        BluetoothAdapter.invalidateIsOffloadedFilteringSupportedCache();\n        BluetoothDevice.invalidateBluetoothGetBondStateCache();\n        if (!Flags.getStateFromSystemServer()) {\n            BluetoothAdapter.invalidateBluetoothGetStateCache();\n        }\n        BluetoothAdapter.invalidateGetAdapterConnectionStateCache();\n        BluetoothMap.invalidateBluetoothGetConnectionStateCache();\n        BluetoothSap.invalidateBluetoothGetConnectionStateCache();\n    }\n\n    private static final Map<Integer, Function<AdapterService, ProfileService>>\n            PROFILE_CONSTRUCTORS =\n                    Map.ofEntries(\n                            Map.entry(BluetoothProfile.A2DP, A2dpService::new),\n                            Map.entry(BluetoothProfile.A2DP_SINK, A2dpSinkService::new),\n                            Map.entry(BluetoothProfile.AVRCP, AvrcpTargetService::new),\n                            Map.entry(\n                                    BluetoothProfile.AVRCP_CONTROLLER, AvrcpControllerService::new),\n                            Map.entry(\n                                    BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT,\n                                    BassClientService::new),\n                            Map.entry(BluetoothProfile.BATTERY, BatteryService::new),\n                            Map.entry(\n                                    BluetoothProfile.CSIP_SET_COORDINATOR,\n                                    CsipSetCoordinatorService::new),\n                            Map.entry(BluetoothProfile.HAP_CLIENT, HapClientService::new),\n                            Map.entry(BluetoothProfile.HEADSET, HeadsetService::new),\n                            Map.entry(BluetoothProfile.HEADSET_CLIENT, HeadsetClientService::new),\n                            Map.entry(BluetoothProfile.HEARING_AID, HearingAidService::new),\n                            Map.entry(BluetoothProfile.HID_DEVICE, HidDeviceService::new),\n                            Map.entry(BluetoothProfile.HID_HOST, HidHostService::new),\n                            Map.entry(BluetoothProfile.GATT, GattService::new),\n                            Map.entry(BluetoothProfile.LE_AUDIO, LeAudioService::new),\n                            Map.entry(BluetoothProfile.LE_CALL_CONTROL, TbsService::new),\n                            Map.entry(BluetoothProfile.MAP, BluetoothMapService::new),\n                            Map.entry(BluetoothProfile.MAP_CLIENT, MapClientService::new),\n                            Map.entry(BluetoothProfile.MCP_SERVER, McpService::new),\n                            Map.entry(BluetoothProfile.OPP, BluetoothOppService::new),\n                            Map.entry(BluetoothProfile.PAN, PanService::new),\n                            Map.entry(BluetoothProfile.PBAP, BluetoothPbapService::new),\n                            Map.entry(BluetoothProfile.PBAP_CLIENT, PbapClientService::new),\n                            Map.entry(BluetoothProfile.SAP, SapService::new),\n                            Map.entry(BluetoothProfile.VOLUME_CONTROL, VolumeControlService::new));\n\n    @VisibleForTesting\n    void setProfileServiceState(int profileId, int state) {\n        if (state == BluetoothAdapter.STATE_ON) {\n            if (!mStartedProfiles.containsKey(profileId)) {\n                ProfileService profileService = PROFILE_CONSTRUCTORS.get(profileId).apply(this);\n                mStartedProfiles.put(profileId, profileService);\n                addProfile(profileService);\n                profileService.start();\n                profileService.setAvailable(true);\n                // With `Flags.scanManagerRefactor()` GattService initialization is pushed back to\n                // `ON` state instead of `BLE_ON`. Here we ensure mGattService is set prior\n                // to other Profiles using it.\n                if (profileId == BluetoothProfile.GATT && Flags.scanManagerRefactor()) {\n                    mGattService = GattService.getGattService();\n                }\n                onProfileServiceStateChanged(profileService, BluetoothAdapter.STATE_ON);\n            } else {\n                Log.e(\n                        TAG,\n                        \"setProfileServiceState(\"\n                                + BluetoothProfile.getProfileName(profileId)\n                                + \", STATE_ON): profile is already started\");\n            }\n        } else if (state == BluetoothAdapter.STATE_OFF) {\n            ProfileService profileService = mStartedProfiles.remove(profileId);\n            if (profileService != null) {\n                profileService.setAvailable(false);\n                onProfileServiceStateChanged(profileService, BluetoothAdapter.STATE_OFF);\n                profileService.stop();\n                removeProfile(profileService);\n                profileService.cleanup();\n                if (profileService.getBinder() != null) {\n                    profileService.getBinder().cleanup();\n                }\n            } else {\n                Log.e(\n                        TAG,\n                        \"setProfileServiceState(\"\n                                + BluetoothProfile.getProfileName(profileId)\n                                + \", STATE_OFF): profile is already stopped\");\n            }\n        }\n    }\n\n    private void setAllProfileServiceStates(int[] profileIds, int state) {\n        for (int profileId : profileIds) {\n            if (!Flags.scanManagerRefactor()) {\n                // TODO(b/228875190): GATT is assumed supported and treated differently as part of\n                //  the \"BLE ON\" state, despite GATT not being BLE specific.\n                if (profileId == BluetoothProfile.GATT) {\n                    continue;\n                }\n            }\n            setProfileServiceState(profileId, state);\n        }\n    }\n\n    /**\n     * Checks whether the remote device is a dual mode audio sink device (supports both classic and\n     * LE Audio sink roles.\n     *\n     * @param device the remote device\n     * @return {@code true} if it's a dual mode audio device, {@code false} otherwise\n     */\n    public boolean isDualModeAudioSinkDevice(BluetoothDevice device) {\n        if (mLeAudioService == null\n                || mLeAudioService.getGroupId(device) == LE_AUDIO_GROUP_ID_INVALID) {\n            return false;\n        }\n\n        // Check if any device in the CSIP group is a dual mode audio sink device\n        for (BluetoothDevice groupDevice :\n                mLeAudioService.getGroupDevices(mLeAudioService.getGroupId(device))) {\n            if (isProfileSupported(groupDevice, BluetoothProfile.LE_AUDIO)\n                    && (isProfileSupported(groupDevice, BluetoothProfile.HEADSET)\n                            || isProfileSupported(groupDevice, BluetoothProfile.A2DP))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the local and remote device support a connection for duplex audio (input and\n     * output) over HFP or LE Audio.\n     *\n     * @param groupDevices the devices in the CSIP group\n     * @return {@code true} if duplex is supported on the remote device, {@code false} otherwise\n     */\n    private boolean isDuplexAudioSupported(List<BluetoothDevice> groupDevices) {\n        for (BluetoothDevice device : groupDevices) {\n            if (isProfileSupported(device, BluetoothProfile.HEADSET)\n                    || (isProfileSupported(device, BluetoothProfile.LE_AUDIO)\n                            && mLeAudioService != null\n                            && mLeAudioService.isLeAudioDuplexSupported(device))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the local and remote device support a connection for output only audio over\n     * A2DP or LE Audio.\n     *\n     * @param groupDevices the devices in the CSIP group\n     * @return {@code true} if output only is supported, {@code false} otherwise\n     */\n    private boolean isOutputOnlyAudioSupported(List<BluetoothDevice> groupDevices) {\n        for (BluetoothDevice device : groupDevices) {\n            if (isProfileSupported(device, BluetoothProfile.A2DP)\n                    || (isProfileSupported(device, BluetoothProfile.LE_AUDIO)\n                            && mLeAudioService != null\n                            && mLeAudioService.isLeAudioOutputSupported(device))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Verifies whether the profile is supported by the local bluetooth adapter by checking a\n     * bitmask of its supported profiles\n     *\n     * @param device is the remote device we wish to connect to\n     * @param profile is the profile we are checking for support\n     * @return true if the profile is supported by both the local and remote device, false otherwise\n     */\n    @VisibleForTesting\n    boolean isProfileSupported(BluetoothDevice device, int profile) {\n        final ParcelUuid[] remoteDeviceUuids = getRemoteUuids(device);\n        final ParcelUuid[] localDeviceUuids = mAdapterProperties.getUuids();\n        if (remoteDeviceUuids == null || remoteDeviceUuids.length == 0) {\n            Log.e(\n                    TAG,\n                    \"isProfileSupported(\"\n                            + (\"device=\" + device)\n                            + (\", profile=\" + BluetoothProfile.getProfileName(profile) + \"):\")\n                            + \" remote device Uuids Empty\");\n        }\n\n        Log.v(\n                TAG,\n                \"isProfileSupported(\"\n                        + (\"device=\" + device)\n                        + (\", profile=\" + BluetoothProfile.getProfileName(profile) + \"):\")\n                        + (\" local_uuids=\" + Arrays.toString(localDeviceUuids))\n                        + (\", remote_uuids=\" + Arrays.toString(remoteDeviceUuids)));\n\n        if (profile == BluetoothProfile.HEADSET) {\n            return (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HSP_AG)\n                            && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HSP))\n                    || (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP_AG)\n                            && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP));\n        }\n        if (profile == BluetoothProfile.HEADSET_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP_AG)\n                    && Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP);\n        }\n        if (profile == BluetoothProfile.A2DP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SINK);\n        }\n        if (profile == BluetoothProfile.A2DP_SINK) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SOURCE);\n        }\n        if (profile == BluetoothProfile.OPP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.OBEX_OBJECT_PUSH);\n        }\n        if (profile == BluetoothProfile.HID_HOST) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HID)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HOGP)\n                    || (Flags.androidHeadtrackerService()\n                            && Utils.arrayContains(\n                                    remoteDeviceUuids, HidHostService.ANDROID_HEADTRACKER_UUID));\n        }\n        if (profile == BluetoothProfile.HID_DEVICE) {\n            return mHidDeviceService.getConnectionState(device)\n                    == BluetoothProfile.STATE_DISCONNECTED;\n        }\n        if (profile == BluetoothProfile.PAN) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.NAP);\n        }\n        if (profile == BluetoothProfile.MAP) {\n            return mMapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.PBAP) {\n            return mPbapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.MAP_CLIENT) {\n            return Utils.arrayContains(localDeviceUuids, BluetoothUuid.MNS)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.MAS);\n        }\n        if (profile == BluetoothProfile.PBAP_CLIENT) {\n            return Utils.arrayContains(localDeviceUuids, BluetoothUuid.PBAP_PCE)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.PBAP_PSE);\n        }\n        if (profile == BluetoothProfile.HEARING_AID) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HEARING_AID);\n        }\n        if (profile == BluetoothProfile.SAP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.SAP);\n        }\n        if (profile == BluetoothProfile.VOLUME_CONTROL) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.VOLUME_CONTROL);\n        }\n        if (profile == BluetoothProfile.CSIP_SET_COORDINATOR) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.COORDINATED_SET);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.LE_AUDIO);\n        }\n        if (profile == BluetoothProfile.HAP_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HAS);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BASS);\n        }\n        if (profile == BluetoothProfile.BATTERY) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BATTERY);\n        }\n\n        Log.e(TAG, \"isSupported: Unexpected profile passed in to function: \" + profile);\n        return false;\n    }\n\n    /**\n     * Checks if the connection policy of all profiles are unknown for the given device\n     *\n     * @param device is the device for which we are checking if the connection policy of all\n     *     profiles are unknown\n     * @return false if one of profile is enabled or disabled, true otherwise\n     */\n    boolean isAllProfilesUnknown(BluetoothDevice device) {\n        if (mA2dpService != null\n                && mA2dpService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mA2dpSinkService != null\n                && mA2dpSinkService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mHeadsetService != null\n                && mHeadsetService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mHeadsetClientService != null\n                && mHeadsetClientService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mMapClientService != null\n                && mMapClientService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mHidHostService != null\n                && mHidHostService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mPanService != null\n                && mPanService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mPbapClientService != null\n                && mPbapClientService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mHearingAidService != null\n                && mHearingAidService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mHapClientService != null\n                && mHapClientService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mVolumeControlService != null\n                && mVolumeControlService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mCsipSetCoordinatorService != null\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mLeAudioService != null\n                && mLeAudioService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mBassClientService != null\n                && mBassClientService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Connects only available profiles (those with {@link\n     * BluetoothProfile#CONNECTION_POLICY_ALLOWED})\n     *\n     * @param device is the device with which we are connecting the profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS}\n     */\n    private int connectEnabledProfiles(BluetoothDevice device) {\n        if (mCsipSetCoordinatorService != null\n                && isProfileSupported(device, BluetoothProfile.CSIP_SET_COORDINATOR)\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.connect(device);\n        }\n        if (mA2dpService != null\n                && isProfileSupported(device, BluetoothProfile.A2DP)\n                && mA2dpService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp\");\n            mA2dpService.connect(device);\n        }\n        if (mA2dpSinkService != null\n                && isProfileSupported(device, BluetoothProfile.A2DP_SINK)\n                && mA2dpSinkService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.connect(device);\n        }\n        if (mHeadsetService != null\n                && isProfileSupported(device, BluetoothProfile.HEADSET)\n                && mHeadsetService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Headset Profile\");\n            mHeadsetService.connect(device);\n        }\n        if (mHeadsetClientService != null\n                && isProfileSupported(device, BluetoothProfile.HEADSET_CLIENT)\n                && mHeadsetClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HFP\");\n            mHeadsetClientService.connect(device);\n        }\n        if (mMapClientService != null\n                && isProfileSupported(device, BluetoothProfile.MAP_CLIENT)\n                && mMapClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting MAP\");\n            mMapClientService.connect(device);\n        }\n        if (mHidHostService != null\n                && isProfileSupported(device, BluetoothProfile.HID_HOST)\n                && mHidHostService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hid Host Profile\");\n            mHidHostService.connect(device);\n        }\n        if (mPanService != null\n                && isProfileSupported(device, BluetoothProfile.PAN)\n                && mPanService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pan Profile\");\n            mPanService.connect(device);\n        }\n        if (mPbapClientService != null\n                && isProfileSupported(device, BluetoothProfile.PBAP_CLIENT)\n                && mPbapClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pbap\");\n            mPbapClientService.connect(device);\n        }\n        if (mHearingAidService != null\n                && isProfileSupported(device, BluetoothProfile.HEARING_AID)\n                && mHearingAidService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hearing Aid Profile\");\n            mHearingAidService.connect(device);\n        }\n        if (mHapClientService != null\n                && isProfileSupported(device, BluetoothProfile.HAP_CLIENT)\n                && mHapClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HAS Profile\");\n            mHapClientService.connect(device);\n        }\n        if (mVolumeControlService != null\n                && isProfileSupported(device, BluetoothProfile.VOLUME_CONTROL)\n                && mVolumeControlService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.connect(device);\n        }\n        if (mLeAudioService != null\n                && isProfileSupported(device, BluetoothProfile.LE_AUDIO)\n                && mLeAudioService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.connect(device);\n        }\n        if (mBassClientService != null\n                && isProfileSupported(device, BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT)\n                && mBassClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.connect(device);\n        }\n        if (mBatteryService != null\n                && isProfileSupported(device, BluetoothProfile.BATTERY)\n                && mBatteryService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Battery Service\");\n            mBatteryService.connect(device);\n        }\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Verifies that all bluetooth profile services are running\n     *\n     * @return true if all bluetooth profile services running, false otherwise\n     */\n    private boolean profileServicesRunning() {\n        if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n            return true;\n        }\n\n        Log.e(TAG, \"profileServicesRunning: One or more supported services not running\");\n        return false;\n    }\n\n    /** Initializes all the profile services fields */\n    private void initProfileServices() {\n        Log.i(TAG, \"initProfileServices: Initializing all bluetooth profile services\");\n        mA2dpService = A2dpService.getA2dpService();\n        mA2dpSinkService = A2dpSinkService.getA2dpSinkService();\n        mHeadsetService = HeadsetService.getHeadsetService();\n        mHeadsetClientService = HeadsetClientService.getHeadsetClientService();\n        mMapService = BluetoothMapService.getBluetoothMapService();\n        mMapClientService = MapClientService.getMapClientService();\n        mHidDeviceService = HidDeviceService.getHidDeviceService();\n        mHidHostService = HidHostService.getHidHostService();\n        mPanService = PanService.getPanService();\n        mPbapService = BluetoothPbapService.getBluetoothPbapService();\n        mPbapClientService = PbapClientService.getPbapClientService();\n        mHearingAidService = HearingAidService.getHearingAidService();\n        mHapClientService = HapClientService.getHapClientService();\n        mSapService = SapService.getSapService();\n        mVolumeControlService = VolumeControlService.getVolumeControlService();\n        mCsipSetCoordinatorService = CsipSetCoordinatorService.getCsipSetCoordinatorService();\n        mLeAudioService = LeAudioService.getLeAudioService();\n        mBassClientService = BassClientService.getBassClientService();\n        mBatteryService = BatteryService.getBatteryService();\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    @RequiresPermission(BLUETOOTH_CONNECT)\n    private int startRfcommListener(\n            String name, ParcelUuid uuid, PendingIntent pendingIntent, AttributionSource source) {\n        if (mBluetoothServerSockets.containsKey(uuid.getUuid())) {\n            Log.d(TAG, \"Cannot start RFCOMM listener: UUID \" + uuid.getUuid() + \"already in use.\");\n            return BluetoothStatusCodes.RFCOMM_LISTENER_START_FAILED_UUID_IN_USE;\n        }\n\n        try {\n            startRfcommListenerInternal(name, uuid.getUuid(), pendingIntent, source);\n        } catch (IOException e) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CREATE_SERVER_SOCKET;\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    @VisibleForTesting\n    int stopRfcommListener(ParcelUuid uuid, AttributionSource source) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            Log.d(TAG, \"Cannot stop RFCOMM listener: UUID \" + uuid.getUuid() + \"is not registered\");\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n        }\n\n        if (source.getUid() != listenerData.mAttributionSource.getUid()) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n        }\n\n        // Remove the entry so that it does not try and restart the server socket.\n        mBluetoothServerSockets.remove(uuid.getUuid());\n\n        return listenerData.closeServerAndPendingSockets(mHandler);\n    }\n\n    @VisibleForTesting\n    IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n            ParcelUuid uuid, AttributionSource source) {\n        IncomingRfcommSocketInfo socketInfo = new IncomingRfcommSocketInfo();\n\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            socketInfo.status =\n                    BluetoothStatusCodes\n                            .RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n            return socketInfo;\n        }\n\n        if (source.getUid() != listenerData.mAttributionSource.getUid()) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n            return socketInfo;\n        }\n\n        BluetoothSocket socket = listenerData.mPendingSockets.poll();\n\n        if (socket == null) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_NO_SOCKET_AVAILABLE;\n            return socketInfo;\n        }\n\n        mHandler.removeCallbacksAndMessages(socket);\n\n        socketInfo.bluetoothDevice = socket.getRemoteDevice();\n        socketInfo.pfd = socket.getParcelFileDescriptor();\n        socketInfo.status = BluetoothStatusCodes.SUCCESS;\n\n        return socketInfo;\n    }\n\n    @RequiresPermission(BLUETOOTH_CONNECT)\n    private void handleIncomingRfcommConnections(UUID uuid) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid);\n        while (true) {\n            BluetoothSocket socket;\n            try {\n                socket = listenerData.mServerSocket.accept();\n            } catch (IOException e) {\n                if (mBluetoothServerSockets.containsKey(uuid)) {\n                    // The uuid still being in the map indicates that the accept failure is\n                    // unexpected. Try and restart the listener.\n                    Log.e(TAG, \"Failed to accept socket on \" + listenerData.mServerSocket, e);\n                    restartRfcommListener(listenerData, uuid);\n                }\n                return;\n            }\n\n            listenerData.mPendingSockets.add(socket);\n            try {\n                listenerData.mPendingIntent.send();\n            } catch (PendingIntent.CanceledException e) {\n                Log.e(TAG, \"PendingIntent for RFCOMM socket notifications cancelled.\", e);\n                // The pending intent was cancelled, close the server as there is no longer any way\n                // to notify the app that registered the listener.\n                listenerData.closeServerAndPendingSockets(mHandler);\n                mBluetoothServerSockets.remove(uuid);\n                return;\n            }\n            mHandler.postDelayed(\n                    () -> pendingSocketTimeoutRunnable(listenerData, socket),\n                    socket,\n                    PENDING_SOCKET_HANDOFF_TIMEOUT.toMillis());\n        }\n    }\n\n    // Tries to restart the rfcomm listener for the given UUID\n    @RequiresPermission(BLUETOOTH_CONNECT)\n    private void restartRfcommListener(RfcommListenerData listenerData, UUID uuid) {\n        listenerData.closeServerAndPendingSockets(mHandler);\n        try {\n            startRfcommListenerInternal(\n                    listenerData.mName,\n                    uuid,\n                    listenerData.mPendingIntent,\n                    listenerData.mAttributionSource);\n        } catch (IOException e) {\n            Log.e(TAG, \"Failed to recreate rfcomm server socket\", e);\n\n            mBluetoothServerSockets.remove(uuid);\n        }\n    }\n\n    private void pendingSocketTimeoutRunnable(\n            RfcommListenerData listenerData, BluetoothSocket socket) {\n        boolean socketFound = listenerData.mPendingSockets.remove(socket);\n        if (socketFound) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to close bt socket\", e);\n                // We don't care if closing the socket failed, just continue on.\n            }\n        }\n    }\n\n    @RequiresPermission(BLUETOOTH_CONNECT)\n    private void startRfcommListenerInternal(\n            String name, UUID uuid, PendingIntent intent, AttributionSource source)\n            throws IOException {\n        BluetoothServerSocket bluetoothServerSocket =\n                mAdapter.listenUsingRfcommWithServiceRecord(name, uuid);\n\n        RfcommListenerData listenerData =\n                new RfcommListenerData(bluetoothServerSocket, name, intent, source);\n\n        mBluetoothServerSockets.put(uuid, listenerData);\n\n        new Thread(() -> handleIncomingRfcommConnections(uuid)).start();\n    }\n\n    private void stopRfcommServerSockets() {\n        Iterator<Map.Entry<UUID, RfcommListenerData>> socketsIterator =\n                mBluetoothServerSockets.entrySet().iterator();\n        while (socketsIterator.hasNext()) {\n            socketsIterator.next().getValue().closeServerAndPendingSockets(mHandler);\n            socketsIterator.remove();\n        }\n    }\n\n    private static class RfcommListenerData {\n        final BluetoothServerSocket mServerSocket;\n        // Service record name\n        final String mName;\n        // The Intent which contains the Service info to which the incoming socket connections are\n        // handed off to.\n        final PendingIntent mPendingIntent;\n        // AttributionSource for the requester of the RFCOMM listener\n        final AttributionSource mAttributionSource;\n        // Contains the connected sockets which are pending transfer to the app which requested the\n        // listener.\n        final ConcurrentLinkedQueue<BluetoothSocket> mPendingSockets =\n                new ConcurrentLinkedQueue<>();\n\n        RfcommListenerData(\n                BluetoothServerSocket serverSocket,\n                String name,\n                PendingIntent pendingIntent,\n                AttributionSource source) {\n            mServerSocket = serverSocket;\n            mName = name;\n            mPendingIntent = pendingIntent;\n            mAttributionSource = source;\n        }\n\n        int closeServerAndPendingSockets(Handler handler) {\n            int result = BluetoothStatusCodes.SUCCESS;\n            try {\n                mServerSocket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to call close on rfcomm server socket\", e);\n                result = BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CLOSE_SERVER_SOCKET;\n            }\n            mPendingSockets.forEach(\n                    pendingSocket -> {\n                        handler.removeCallbacksAndMessages(pendingSocket);\n                        try {\n                            pendingSocket.close();\n                        } catch (IOException e) {\n                            Log.e(TAG, \"Failed to close socket\", e);\n                        }\n                    });\n            mPendingSockets.clear();\n\n            return result;\n        }\n    }\n\n    @VisibleForTesting\n    boolean isAvailable() {\n        return !mCleaningUp;\n    }\n\n    /**\n     * Set metadata value for the given device and key\n     *\n     * @return true if metadata is set successfully\n     */\n    public boolean setMetadata(BluetoothDevice device, int key, byte[] value) {\n        if (value == null || value.length > BluetoothDevice.METADATA_MAX_LENGTH) {\n            return false;\n        }\n        return mDatabaseManager.setCustomMeta(device, key, value);\n    }\n\n    /**\n     * Get metadata of given device and key\n     *\n     * @return value of given device and key combination\n     */\n    public byte[] getMetadata(BluetoothDevice device, int key) {\n        return mDatabaseManager.getCustomMeta(device, key);\n    }\n\n    /** Update Adapter Properties when BT profiles connection state changes. */\n    public void updateProfileConnectionAdapterProperties(\n            BluetoothDevice device, int profile, int state, int prevState) {\n        mHandler.post(\n                () ->\n                        mAdapterProperties.updateOnProfileConnectionChanged(\n                                device, profile, state, prevState));\n    }\n\n    /**\n     * There is no leak of this binder since it is never re-used and the process is systematically\n     * killed\n     */\n    @VisibleForTesting\n    public static class AdapterServiceBinder extends IBluetooth.Stub {\n        private final AdapterService mService;\n\n        AdapterServiceBinder(AdapterService svc) {\n            mService = svc;\n            if (Flags.getStateFromSystemServer()) {\n                return;\n            }\n            mService.invalidateBluetoothGetStateCache();\n            BluetoothAdapter.getDefaultAdapter().disableBluetoothGetStateCache();\n        }\n\n        public AdapterService getService() {\n            if (!mService.isAvailable()) {\n                return null;\n            }\n            return mService;\n        }\n\n        @Override\n        public int getState() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_OFF;\n            }\n\n            return service.getState();\n        }\n\n        @Override\n        public void killBluetoothProcess() {\n            mService.enforceCallingPermission(BLUETOOTH_PRIVILEGED, null);\n\n            Runnable killAction =\n                    () -> {\n                        if (Flags.killInsteadOfExit()) {\n                            Log.i(TAG, \"killBluetoothProcess: Calling killProcess(myPid())\");\n                            Process.killProcess(Process.myPid());\n                        } else {\n                            Log.i(TAG, \"killBluetoothProcess: Calling System.exit\");\n                            System.exit(0);\n                        }\n                    };\n\n            // Post on the main handler to let the cleanup complete before calling exit\n            mService.mHandler.post(killAction);\n\n            try {\n                // Wait for Bluetooth to be killed from its main thread\n                Thread.sleep(1_000); // SystemServer is waiting 2000 ms, we need to wait less here\n            } catch (InterruptedException e) {\n                Log.e(TAG, \"killBluetoothProcess: Interrupted while waiting for kill\");\n            }\n\n            // Bluetooth cannot be killed on the main thread; it is in a deadLock.\n            // Trying to recover by killing the Bluetooth from the binder thread.\n            // This is bad :(\n            Counter.logIncrement(\"bluetooth.value_kill_from_binder_thread\");\n            Log.wtf(TAG, \"Failed to kill Bluetooth using its main thread. Trying from binder\");\n            killAction.run();\n        }\n\n        @Override\n        public void offToBleOn(boolean quietMode, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"offToBleOn\")) {\n                return;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.offToBleOn(quietMode);\n        }\n\n        @Override\n        public void onToBleOn(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"onToBleOn\")) {\n                return;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.onToBleOn();\n        }\n\n        @Override\n        public String getAddress(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getAddress\")) {\n                return null;\n            }\n\n            service.enforceCallingOrSelfPermission(LOCAL_MAC_ADDRESS, null);\n\n            return Utils.getAddressStringFromByte(service.mAdapterProperties.getAddress());\n        }\n\n        @Override\n        public List<ParcelUuid> getUuids(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getUuids\")) {\n                return Collections.emptyList();\n            }\n\n            ParcelUuid[] parcels = service.mAdapterProperties.getUuids();\n            if (parcels == null) {\n                parcels = new ParcelUuid[0];\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public String getIdentityAddress(String address) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getIdentityAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service,\n                            Utils.getCallingAttributionSource(mService),\n                            \"AdapterService getIdentityAddress\")) {\n                return null;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.getIdentityAddress(address);\n        }\n\n        @Override\n        public String getName(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getName\")) {\n                return null;\n            }\n\n            return service.getName();\n        }\n\n        @Override\n        public int getNameLengthForAdvertise(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getNameLengthForAdvertise\")\n                    || !Utils.checkAdvertisePermissionForDataDelivery(service, source, TAG)) {\n                return -1;\n            }\n\n            return service.getNameLengthForAdvertise();\n        }\n\n        @Override\n        public boolean setName(String name, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService setName\")) {\n                return false;\n            }\n\n            Log.d(TAG, \"AdapterServiceBinder.setName(\" + name + \")\");\n            return service.mAdapterProperties.setName(name);\n        }\n\n        @Override\n        public int getScanMode(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, source, \"AdapterService getScanMode\")) {\n                return SCAN_MODE_NONE;\n            }\n\n            return service.getScanMode();\n        }\n\n        @Override\n        public int setScanMode(int mode, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, source, \"AdapterService setScanMode\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            String logCaller = Utils.getUidPidString() + \" packageName=\" + source.getPackageName();\n            CompletableFuture<Boolean> future = new CompletableFuture<>();\n            mService.mHandler.post(\n                    () ->\n                            future.complete(\n                                    service.getState() == BluetoothAdapter.STATE_ON\n                                            && service.setScanMode(mode, logCaller)));\n            return future.join()\n                    ? BluetoothStatusCodes.SUCCESS\n                    : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public long getDiscoverableTimeout(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, source, \"AdapterService getDiscoverableTimeout\")) {\n                return -1;\n            }\n\n            return service.mAdapterProperties.getDiscoverableTimeout();\n        }\n\n        @Override\n        public int setDiscoverableTimeout(long timeout, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, source, \"AdapterService setDiscoverableTimeout\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.mAdapterProperties.setDiscoverableTimeout((int) timeout)\n                    ? BluetoothStatusCodes.SUCCESS\n                    : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public boolean startDiscovery(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"startDiscovery\")) {\n                return false;\n            }\n\n            if (!Utils.checkScanPermissionForDataDelivery(service, source, \"Starting discovery.\")) {\n                return false;\n            }\n\n            Log.i(TAG, \"startDiscovery: from \" + Utils.getUidPidString());\n            return service.startDiscovery(source);\n        }\n\n        @Override\n        public boolean cancelDiscovery(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"cancelDiscovery\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, source, \"AdapterService cancelDiscovery\")) {\n                return false;\n            }\n\n            Log.i(TAG, \"cancelDiscovery: from \" + Utils.getUidPidString());\n            return service.mNativeInterface.cancelDiscovery();\n        }\n\n        @Override\n        public boolean isDiscovering(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"isDiscovering\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, source, \"AdapterService isDiscovering\")) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isDiscovering();\n        }\n\n        @Override\n        public long getDiscoveryEndMillis(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getDiscoveryEndMillis\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return -1;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.mAdapterProperties.discoveryEndMillis();\n        }\n\n        @Override\n        public List<BluetoothDevice> getMostRecentlyConnectedDevices(AttributionSource source) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getMostRecentlyConnectedDevices\")) {\n                return Collections.emptyList();\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.mDatabaseManager.getMostRecentlyConnectedDevices();\n        }\n\n        @Override\n        public List<BluetoothDevice> getBondedDevices(AttributionSource source) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getBondedDevices\")) {\n                return Collections.emptyList();\n            }\n\n            return Arrays.asList(service.getBondedDevices());\n        }\n\n        @Override\n        public int getAdapterConnectionState() {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getConnectionState();\n        }\n\n        /**\n         * This method has an associated binder cache. The invalidation methods must be changed if\n         * the logic behind this method changes.\n         */\n        @Override\n        public int getProfileConnectionState(int profile, AttributionSource source) {\n            AdapterService service = getService();\n            boolean checkConnect = false;\n            final int callingUid = Binder.getCallingUid();\n            final long token = Binder.clearCallingIdentity();\n            try {\n                checkConnect = CompatChanges.isChangeEnabled(ENFORCE_CONNECT, callingUid);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getProfileConnectionState\")\n                    || (checkConnect\n                            && !Utils.checkConnectPermissionForDataDelivery(\n                                    service, source, \"AdapterService getProfileConnectionState\"))) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getProfileConnectionState(profile);\n        }\n\n        @Override\n        public boolean createBond(\n                BluetoothDevice device,\n                int transport,\n                OobData remoteP192Data,\n                OobData remoteP256Data,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"createBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService createBond\")) {\n                return false;\n            }\n\n            // This conditional is required to satisfy permission dependencies\n            // since createBond calls createBondOutOfBand with null value passed as data.\n            // BluetoothDevice#createBond requires BLUETOOTH_ADMIN only.\n            service.enforceBluetoothPrivilegedPermissionIfNeeded(remoteP192Data, remoteP256Data);\n\n            Log.i(\n                    TAG,\n                    \"createBond:\"\n                            + (\" device=\" + device)\n                            + (\" transport=\" + transport)\n                            + (\" from \" + Utils.getUidPidString()));\n            return service.createBond(\n                    device, transport, remoteP192Data, remoteP256Data, source.getPackageName());\n        }\n\n        @Override\n        public boolean cancelBondProcess(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"cancelBondProcess\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService cancelBondProcess\")) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            Log.i(TAG, \"cancelBondProcess: device=\" + device + \", from \" + Utils.getUidPidString());\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp != null) {\n                deviceProp.setBondingInitiatedLocally(false);\n            }\n\n            return service.mNativeInterface.cancelBond(getBytesFromAddress(device.getAddress()));\n        }\n\n        @Override\n        public boolean removeBond(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"removeBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService removeBond\")) {\n                return false;\n            }\n\n            Log.i(TAG, \"removeBond: device=\" + device + \", from \" + Utils.getUidPidString());\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || deviceProp.getBondState() != BluetoothDevice.BOND_BONDED) {\n                Log.w(\n                        TAG,\n                        device\n                                + \" cannot be removed since \"\n                                + ((deviceProp == null)\n                                        ? \"properties are empty\"\n                                        : \"bond state is \" + deviceProp.getBondState()));\n                return false;\n            }\n            service.mBondAttemptCallerInfo.remove(device.getAddress());\n            deviceProp.setBondingInitiatedLocally(false);\n\n            Message msg = service.mBondStateMachine.obtainMessage(BondStateMachine.REMOVE_BOND);\n            msg.obj = device;\n            service.mBondStateMachine.sendMessage(msg);\n            return true;\n        }\n\n        @Override\n        public int getBondState(BluetoothDevice device, AttributionSource source) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getBondState\")) {\n                return BluetoothDevice.BOND_NONE;\n            }\n\n            return service.getBondState(device);\n        }\n\n        @Override\n        public boolean isBondingInitiatedLocally(BluetoothDevice device, AttributionSource source) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService isBondingInitiatedLocally\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null && deviceProp.isBondingInitiatedLocally();\n        }\n\n        @Override\n        public void generateLocalOobData(\n                int transport, IBluetoothOobDataCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"generateLocalOobData\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            service.generateLocalOobData(transport, callback);\n        }\n\n        @Override\n        public long getSupportedProfiles(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return 0;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return Config.getSupportedProfilesBitMask();\n        }\n\n        @Override\n        public int getConnectionState(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getConnectionState\")) {\n                return BluetoothDevice.CONNECTION_STATE_DISCONNECTED;\n            }\n\n            return service.getConnectionState(device);\n        }\n\n        @Override\n        public int getConnectionHandle(\n                BluetoothDevice device, int transport, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getConnectionHandle\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothDevice.ERROR;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.getConnectionHandle(device, transport);\n        }\n\n        @Override\n        public boolean canBondWithoutDialog(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.canBondWithoutDialog(device);\n        }\n\n        @Override\n        public String getPackageNameOfBondingApplication(\n                BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.getPackageNameOfBondingApplication(device);\n        }\n\n        @Override\n        public boolean removeActiveDevice(@ActiveDeviceUse int profiles, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"removeActiveDevice\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(MODIFY_PHONE_STATE, null);\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            Log.i(\n                    TAG,\n                    \"removeActiveDevice: profiles=\"\n                            + profiles\n                            + \", from \"\n                            + Utils.getUidPidString());\n            return service.setActiveDevice(null, profiles);\n        }\n\n        @Override\n        public boolean setActiveDevice(\n                BluetoothDevice device, @ActiveDeviceUse int profiles, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setActiveDevice\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(MODIFY_PHONE_STATE, null);\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            Log.i(\n                    TAG,\n                    \"setActiveDevice: device=\"\n                            + device\n                            + \", profiles=\"\n                            + profiles\n                            + \", from \"\n                            + Utils.getUidPidString());\n\n            return service.setActiveDevice(device, profiles);\n        }\n\n        @Override\n        public List<BluetoothDevice> getActiveDevices(\n                @ActiveDeviceProfile int profile, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getActiveDevices\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return Collections.emptyList();\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.getActiveDevices(profile);\n        }\n\n        @Override\n        public int connectAllEnabledProfiles(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null || !service.isEnabled()) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(service, TAG, \"connectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            service.enforceCallingOrSelfPermission(MODIFY_PHONE_STATE, null);\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            Log.i(\n                    TAG,\n                    \"connectAllEnabledProfiles: device=\"\n                            + device\n                            + \", from \"\n                            + Utils.getUidPidString());\n            MetricsLogger.getInstance()\n                    .logBluetoothEvent(\n                            device,\n                            BluetoothStatsLog\n                                    .BLUETOOTH_CROSS_LAYER_EVENT_REPORTED__EVENT_TYPE__INITIATOR_CONNECTION,\n                            BluetoothStatsLog.BLUETOOTH_CROSS_LAYER_EVENT_REPORTED__STATE__START,\n                            source.getUid());\n\n            try {\n                return service.connectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"connectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public int disconnectAllEnabledProfiles(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(\n                    service, TAG, \"disconnectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            Log.i(\n                    TAG,\n                    \"disconnectAllEnabledProfiles: device=\"\n                            + device\n                            + \", from \"\n                            + Utils.getUidPidString());\n\n            try {\n                return service.disconnectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"disconnectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public String getRemoteName(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getRemoteName\")) {\n                return null;\n            }\n\n            return service.getRemoteName(device);\n        }\n\n        @Override\n        public int getRemoteType(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteType\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getRemoteType\")) {\n                return BluetoothDevice.DEVICE_TYPE_UNKNOWN;\n            }\n\n            return service.getRemoteType(device);\n        }\n\n        @Override\n        public String getRemoteAlias(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteAlias\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getRemoteAlias\")) {\n                return null;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null ? deviceProp.getAlias() : null;\n        }\n\n        @Override\n        public int setRemoteAlias(BluetoothDevice device, String name, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(service, TAG, \"setRemoteAlias\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (name != null && name.isEmpty()) {\n                throw new IllegalArgumentException(\"alias cannot be the empty string\");\n            }\n\n            if (!Utils.checkConnectPermissionForDataDelivery(\n                    service, source, \"AdapterService setRemoteAlias\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            Utils.enforceCdmAssociationIfNotBluetoothPrivileged(\n                    service, service.mCompanionDeviceManager, source, device);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n            }\n            deviceProp.setAlias(device, name);\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public int getRemoteClass(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteClass\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getRemoteClass\")) {\n                return 0;\n            }\n\n            return service.getRemoteClass(device);\n        }\n\n        @Override\n        public List<ParcelUuid> getRemoteUuids(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getRemoteUuids\")) {\n                return Collections.emptyList();\n            }\n\n            final ParcelUuid[] parcels = service.getRemoteUuids(device);\n            if (parcels == null) {\n                return null;\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public boolean fetchRemoteUuids(\n                BluetoothDevice device, int transport, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"fetchRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService fetchRemoteUuids\")) {\n                return false;\n            }\n            if (transport != TRANSPORT_AUTO) {\n                service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            }\n\n            Log.i(\n                    TAG,\n                    \"fetchRemoteUuids: device=\"\n                            + device\n                            + \", transport=\"\n                            + transport\n                            + \", from \"\n                            + Utils.getUidPidString());\n\n            service.mRemoteDevices.fetchUuids(device, transport);\n            MetricsLogger.getInstance().cacheCount(BluetoothProtoEnums.SDP_FETCH_UUID_REQUEST, 1);\n            return true;\n        }\n\n        @Override\n        public boolean setPin(\n                BluetoothDevice device,\n                boolean accept,\n                int len,\n                byte[] pinCode,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setPin\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService setPin\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            // Only allow setting a pin in bonding state, or bonded state in case of security\n            // upgrade.\n            if (deviceProp == null || !deviceProp.isBondingOrBonded()) {\n                Log.e(TAG, \"setPin: device=\" + device + \", not bonding\");\n                return false;\n            }\n            if (pinCode.length != len) {\n                android.util.EventLog.writeEvent(\n                        0x534e4554, \"139287605\", -1, \"PIN code length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(\n                    device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_PIN_REPLIED);\n            Log.i(\n                    TAG,\n                    \"setPin: device=\"\n                            + device\n                            + \", accept=\"\n                            + accept\n                            + \", from \"\n                            + Utils.getUidPidString());\n            return service.mNativeInterface.pinReply(\n                    getBytesFromAddress(device.getAddress()), accept, len, pinCode);\n        }\n\n        @Override\n        public boolean setPasskey(\n                BluetoothDevice device,\n                boolean accept,\n                int len,\n                byte[] passkey,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setPasskey\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService setPasskey\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                Log.e(TAG, \"setPasskey: device=\" + device + \", not bonding\");\n                return false;\n            }\n            if (passkey.length != len) {\n                android.util.EventLog.writeEvent(\n                        0x534e4554, \"139287605\", -1, \"Passkey length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(\n                    device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            Log.i(\n                    TAG,\n                    \"setPasskey: device=\"\n                            + device\n                            + \", accept=\"\n                            + accept\n                            + \", from \"\n                            + Utils.getUidPidString());\n\n            return service.mNativeInterface.sspReply(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_ENTRY,\n                    accept,\n                    Utils.byteArrayToInt(passkey));\n        }\n\n        @Override\n        public boolean setPairingConfirmation(\n                BluetoothDevice device, boolean accept, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setPairingConfirmation\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                Log.e(TAG, \"setPairingConfirmation: device=\" + device + \", not bonding\");\n                return false;\n            }\n            service.logUserBondResponse(\n                    device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            Log.i(\n                    TAG,\n                    \"setPairingConfirmation: device=\"\n                            + device\n                            + \", accept=\"\n                            + accept\n                            + \", from \"\n                            + Utils.getUidPidString());\n\n            return service.mNativeInterface.sspReply(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_CONFIRMATION,\n                    accept,\n                    0);\n        }\n\n        @Override\n        public boolean getSilenceMode(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getSilenceMode\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.mSilenceDeviceManager.getSilenceMode(device);\n        }\n\n        @Override\n        public boolean setSilenceMode(\n                BluetoothDevice device, boolean silence, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setSilenceMode\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.mSilenceDeviceManager.setSilenceMode(device, silence);\n            return true;\n        }\n\n        @Override\n        public int getPhonebookAccessPermission(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getPhonebookAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getPhonebookAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getPhonebookAccessPermission(device);\n        }\n\n        @Override\n        public boolean setPhonebookAccessPermission(\n                BluetoothDevice device, int value, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"setPhonebookAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.setPhonebookAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public int getMessageAccessPermission(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getMessageAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getMessageAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getMessageAccessPermission(device);\n        }\n\n        @Override\n        public boolean setMessageAccessPermission(\n                BluetoothDevice device, int value, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"setMessageAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.setMessageAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public int getSimAccessPermission(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getSimAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getSimAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getSimAccessPermission(device);\n        }\n\n        @Override\n        public boolean setSimAccessPermission(\n                BluetoothDevice device, int value, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setSimAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.setSimAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public void logL2capcocServerConnection(\n                BluetoothDevice device,\n                int port,\n                boolean isSecured,\n                int result,\n                long socketCreationTimeMillis,\n                long socketCreationLatencyMillis,\n                long socketConnectionTimeMillis,\n                long timeoutMillis) {\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n            service.logL2capcocServerConnection(\n                    device,\n                    port,\n                    isSecured,\n                    result,\n                    socketCreationTimeMillis,\n                    socketCreationLatencyMillis,\n                    socketConnectionTimeMillis,\n                    timeoutMillis,\n                    Binder.getCallingUid());\n        }\n\n        @Override\n        public IBluetoothSocketManager getSocketManager() {\n            AdapterService service = getService();\n            if (service == null) {\n                return null;\n            }\n\n            return IBluetoothSocketManager.Stub.asInterface(service.mBluetoothSocketManagerBinder);\n        }\n\n        @Override\n        public void logL2capcocClientConnection(\n                BluetoothDevice device,\n                int port,\n                boolean isSecured,\n                int result,\n                long socketCreationTimeNanos,\n                long socketCreationLatencyNanos,\n                long socketConnectionTimeNanos) {\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n            service.logL2capcocClientConnection(\n                    device,\n                    port,\n                    isSecured,\n                    result,\n                    socketCreationTimeNanos,\n                    socketCreationLatencyNanos,\n                    socketConnectionTimeNanos,\n                    Binder.getCallingUid());\n        }\n\n        @Override\n        public void logRfcommConnectionAttempt(\n                BluetoothDevice device,\n                boolean isSecured,\n                int resultCode,\n                long socketCreationTimeNanos,\n                boolean isSerialPort) {\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n            service.logRfcommConnectionAttempt(\n                    device,\n                    isSecured,\n                    resultCode,\n                    socketCreationTimeNanos,\n                    isSerialPort,\n                    Binder.getCallingUid());\n        }\n\n        @Override\n        public boolean sdpSearch(\n                BluetoothDevice device, ParcelUuid uuid, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"sdpSearch\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService sdpSearch\")) {\n                return false;\n            }\n            return service.sdpSearch(device, uuid);\n        }\n\n        @Override\n        public int getBatteryLevel(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getBatteryLevel\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getBatteryLevel\")) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n            return deviceProp.getBatteryLevel();\n        }\n\n        @Override\n        public int getMaxConnectedAudioDevices(AttributionSource source) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getMaxConnectedAudioDevices\")) {\n                return -1;\n            }\n\n            return service.getMaxConnectedAudioDevices();\n        }\n\n        @Override\n        public boolean factoryReset(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.factoryReset();\n        }\n\n        @Override\n        public void registerBluetoothConnectionCallback(\n                IBluetoothConnectionCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"registerBluetoothConnectionCallback\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            service.mBluetoothConnectionCallbacks.register(callback);\n        }\n\n        @Override\n        public void unregisterBluetoothConnectionCallback(\n                IBluetoothConnectionCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"unregisterBluetoothConnectionCallback\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            service.mBluetoothConnectionCallbacks.unregister(callback);\n        }\n\n        @Override\n        public void registerCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"registerCallback\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.registerRemoteCallback(callback);\n        }\n\n        @Override\n        public void unregisterCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"unregisterCallback\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.unregisterRemoteCallback(callback);\n        }\n\n        @Override\n        public boolean isMultiAdvertisementSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.mAdapterProperties.getNumOfAdvertisementInstancesSupported();\n            return val >= MIN_ADVT_INSTANCES_FOR_MA;\n        }\n\n        /**\n         * This method has an associated binder cache. The invalidation methods must be changed if\n         * the logic behind this method changes.\n         */\n        @Override\n        public boolean isOffloadedFilteringSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getNumOfOffloadedScanFilterSupported();\n            return val >= MIN_OFFLOADED_FILTERS;\n        }\n\n        @Override\n        public boolean isOffloadedScanBatchingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getOffloadedScanResultStorage();\n            return val >= MIN_OFFLOADED_SCAN_STORAGE_BYTES;\n        }\n\n        @Override\n        public boolean isLe2MPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLe2MPhySupported();\n        }\n\n        @Override\n        public boolean isLeCodedPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeCodedPhySupported();\n        }\n\n        @Override\n        public boolean isLeExtendedAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeExtendedAdvertisingSupported();\n        }\n\n        @Override\n        public boolean isLePeriodicAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLePeriodicAdvertisingSupported();\n        }\n\n        @Override\n        public int isLeAudioSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            Set<Integer> supportedProfileServices =\n                    Arrays.stream(Config.getSupportedProfiles())\n                            .boxed()\n                            .collect(Collectors.toSet());\n            int[] leAudioUnicastProfiles = Config.getLeAudioUnicastProfiles();\n\n            if (Arrays.stream(leAudioUnicastProfiles)\n                    .allMatch(supportedProfileServices::contains)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public int isLeAudioBroadcastSourceSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            long supportBitMask = Config.getSupportedProfilesBitMask();\n            if ((supportBitMask & (1 << BluetoothProfile.LE_AUDIO_BROADCAST)) != 0) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public int isLeAudioBroadcastAssistantSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            int[] supportedProfileServices = Config.getSupportedProfiles();\n\n            if (Arrays.stream(supportedProfileServices)\n                    .anyMatch(\n                            profileId ->\n                                    profileId == BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public int isDistanceMeasurementSupported(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            } else if (!callerIsSystemOrActiveOrManagedUser(\n                    service, TAG, \"isDistanceMeasurementSupported\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            } else if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return BluetoothStatusCodes.FEATURE_SUPPORTED;\n        }\n\n        @Override\n        public int getLeMaximumAdvertisingDataLength() {\n            AdapterService service = getService();\n            if (service == null) {\n                return 0;\n            }\n\n            return service.getLeMaximumAdvertisingDataLength();\n        }\n\n        @Override\n        public boolean isActivityAndEnergyReportingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isActivityAndEnergyReportingSupported();\n        }\n\n        @Override\n        public BluetoothActivityEnergyInfo reportActivityInfo(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.reportActivityInfo();\n        }\n\n        @Override\n        public boolean registerMetadataListener(\n                IBluetoothMetadataListener listener,\n                BluetoothDevice device,\n                AttributionSource source) {\n            requireNonNull(device);\n            requireNonNull(listener);\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"registerMetadataListener\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.mHandler.post(\n                    () ->\n                            service.mMetadataListeners\n                                    .computeIfAbsent(device, k -> new RemoteCallbackList())\n                                    .register(listener));\n\n            return true;\n        }\n\n        @Override\n        public boolean unregisterMetadataListener(\n                IBluetoothMetadataListener listener,\n                BluetoothDevice device,\n                AttributionSource source) {\n            requireNonNull(device);\n            requireNonNull(listener);\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"unregisterMetadataListener\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.mHandler.post(\n                    () ->\n                            service.mMetadataListeners.computeIfPresent(\n                                    device,\n                                    (k, v) -> {\n                                        v.unregister(listener);\n                                        if (v.getRegisteredCallbackCount() == 0) {\n                                            return null;\n                                        }\n                                        return v;\n                                    }));\n            return true;\n        }\n\n        @Override\n        public boolean setMetadata(\n                BluetoothDevice device, int key, byte[] value, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setMetadata\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.setMetadata(device, key, value);\n        }\n\n        @Override\n        public byte[] getMetadata(BluetoothDevice device, int key, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getMetadata\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.getMetadata(device, key);\n        }\n\n        @Override\n        public int isRequestAudioPolicyAsSinkSupported(\n                BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"isRequestAudioPolicyAsSinkSupported\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.FEATURE_NOT_CONFIGURED;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.isRequestAudioPolicyAsSinkSupported(device);\n        }\n\n        @Override\n        public int requestAudioPolicyAsSink(\n                BluetoothDevice device,\n                BluetoothSinkAudioPolicy policies,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            } else if (!callerIsSystemOrActiveOrManagedUser(\n                    service, TAG, \"requestAudioPolicyAsSink\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            } else if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.requestAudioPolicyAsSink(device, policies);\n        }\n\n        @Override\n        public BluetoothSinkAudioPolicy getRequestedAudioPolicyAsSink(\n                BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getRequestedAudioPolicyAsSink\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.getRequestedAudioPolicyAsSink(device);\n        }\n\n        @Override\n        public void requestActivityInfo(\n                IBluetoothActivityEnergyInfoListener listener, AttributionSource source) {\n            BluetoothActivityEnergyInfo info = reportActivityInfo(source);\n            try {\n                listener.onBluetoothActivityEnergyInfoAvailable(info);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"onBluetoothActivityEnergyInfo: RemoteException\", e);\n            }\n        }\n\n        @Override\n        public void bleOnToOn(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"bleOnToOn\")) {\n                return;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.bleOnToOn();\n        }\n\n        @Override\n        public void bleOnToOff(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"bleOnToOff\")) {\n                return;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.bleOnToOff();\n        }\n\n        @Override\n        public void dump(FileDescriptor fd, String[] args) {\n            PrintWriter writer = new PrintWriter(new FileOutputStream(fd));\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n\n            service.enforceCallingOrSelfPermission(DUMP, null);\n\n            service.dump(fd, writer, args);\n            writer.close();\n        }\n\n        @Override\n        public boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"allowLowLatencyAudio\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service,\n                            Utils.getCallingAttributionSource(service),\n                            \"AdapterService allowLowLatencyAudio\")) {\n                return false;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.allowLowLatencyAudio(allowed, device);\n        }\n\n        @Override\n        public int startRfcommListener(\n                String name,\n                ParcelUuid uuid,\n                PendingIntent pendingIntent,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"startRfcommListener\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService startRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.startRfcommListener(name, uuid, pendingIntent, source);\n        }\n\n        @Override\n        public int stopRfcommListener(ParcelUuid uuid, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"stopRfcommListener\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService stopRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.stopRfcommListener(uuid, source);\n        }\n\n        @Override\n        public IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n                ParcelUuid uuid, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"retrievePendingSocketForServiceRecord\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service,\n                            source,\n                            \"AdapterService retrievePendingSocketForServiceRecord\")) {\n                return null;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.retrievePendingSocketForServiceRecord(uuid, source);\n        }\n\n        @Override\n        public void setForegroundUserId(int userId, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service,\n                            Utils.getCallingAttributionSource(mService),\n                            \"AdapterService setForegroundUserId\")) {\n                return;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            Utils.setForegroundUserId(userId);\n        }\n\n        @Override\n        public int setPreferredAudioProfiles(\n                BluetoothDevice device, Bundle modeToProfileBundle, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(service, TAG, \"setPreferredAudioProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            requireNonNull(device);\n            requireNonNull(modeToProfileBundle);\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (service.getBondState(device) != BluetoothDevice.BOND_BONDED) {\n                return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.setPreferredAudioProfiles(device, modeToProfileBundle);\n        }\n\n        @Override\n        public Bundle getPreferredAudioProfiles(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return Bundle.EMPTY;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(service, TAG, \"getPreferredAudioProfiles\")) {\n                return Bundle.EMPTY;\n            }\n            requireNonNull(device);\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (service.getBondState(device) != BluetoothDevice.BOND_BONDED) {\n                return Bundle.EMPTY;\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return Bundle.EMPTY;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.getPreferredAudioProfiles(device);\n        }\n\n        @Override\n        public int notifyActiveDeviceChangeApplied(\n                BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystem(TAG, \"notifyActiveDeviceChangeApplied\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            requireNonNull(device);\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (service.getBondState(device) != BluetoothDevice.BOND_BONDED) {\n                return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.notifyActiveDeviceChangeApplied(device);\n        }\n\n        @Override\n        public int isDualModeAudioEnabled(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            if (!Utils.isDualModeAudioEnabled()) {\n                return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public int registerPreferredAudioProfilesChangedCallback(\n                IBluetoothPreferredAudioProfilesCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(\n                    service, TAG, \"registerPreferredAudioProfilesChangedCallback\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            requireNonNull(callback);\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            // If LE only mode is enabled, the dual mode audio feature is disabled\n            if (!Utils.isDualModeAudioEnabled()) {\n                return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n            }\n\n            service.mPreferredAudioProfilesCallbacks.register(callback);\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public int unregisterPreferredAudioProfilesChangedCallback(\n                IBluetoothPreferredAudioProfilesCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(\n                    service, TAG, \"unregisterPreferredAudioProfilesChangedCallback\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            requireNonNull(callback);\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            if (!service.mPreferredAudioProfilesCallbacks.unregister(callback)) {\n                Log.e(\n                        TAG,\n                        \"unregisterPreferredAudioProfilesChangedCallback: callback was never \"\n                                + \"registered\");\n                return BluetoothStatusCodes.ERROR_CALLBACK_NOT_REGISTERED;\n            }\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public int registerBluetoothQualityReportReadyCallback(\n                IBluetoothQualityReportReadyCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(\n                    service, TAG, \"registerBluetoothQualityReportReadyCallback\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            requireNonNull(callback);\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.mBluetoothQualityReportReadyCallbacks.register(callback);\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public int unregisterBluetoothQualityReportReadyCallback(\n                IBluetoothQualityReportReadyCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(\n                    service, TAG, \"unregisterBluetoothQualityReportReadyCallback\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            requireNonNull(callback);\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            if (!service.mBluetoothQualityReportReadyCallbacks.unregister(callback)) {\n                Log.e(\n                        TAG,\n                        \"unregisterBluetoothQualityReportReadyCallback: callback was never \"\n                                + \"registered\");\n                return BluetoothStatusCodes.ERROR_CALLBACK_NOT_REGISTERED;\n            }\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public int getOffloadedTransportDiscoveryDataScanSupported(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getOffloadedTransportDiscoveryDataScanSupported\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, source, \"getOffloadedTransportDiscoveryDataScanSupported\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.getOffloadedTransportDiscoveryDataScanSupported();\n        }\n\n        @Override\n        public boolean isMediaProfileConnected(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService.isMediaProfileConnected\")) {\n                return false;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.isMediaProfileConnected();\n        }\n\n        @Override\n        public IBinder getBluetoothGatt() {\n            AdapterService service = getService();\n            return service == null ? null : service.getBluetoothGatt();\n        }\n\n        @Override\n        public IBinder getBluetoothScan() {\n            AdapterService service = getService();\n            return service == null ? null : service.getBluetoothScan();\n        }\n\n        @Override\n        public void unregAllGattClient(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            service.unregAllGattClient(source);\n        }\n\n        @Override\n        public IBinder getProfile(int profileId) {\n            AdapterService service = getService();\n            if (service == null) {\n                return null;\n            }\n\n            return service.getProfile(profileId);\n        }\n\n        @Override\n        public int setActiveAudioDevicePolicy(\n                BluetoothDevice device, int activeAudioDevicePolicy, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(service, TAG, \"setActiveAudioDevicePolicy\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.mDatabaseManager.setActiveAudioDevicePolicy(\n                    device, activeAudioDevicePolicy);\n        }\n\n        @Override\n        public int getActiveAudioDevicePolicy(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothDevice.ACTIVE_AUDIO_DEVICE_POLICY_DEFAULT;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(service, TAG, \"getActiveAudioDevicePolicy\")) {\n                throw new IllegalStateException(\n                        \"Caller is not the system or part of the active/managed user\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothDevice.ACTIVE_AUDIO_DEVICE_POLICY_DEFAULT;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.mDatabaseManager.getActiveAudioDevicePolicy(device);\n        }\n    }\n\n    /**\n     * Gets the preferred audio profiles for the device. See {@link\n     * BluetoothAdapter#getPreferredAudioProfiles(BluetoothDevice)} for more details.\n     *\n     * @param device is the remote device whose preferences we want to fetch\n     * @return a Bundle containing the preferred audio profiles for the device\n     */\n    public Bundle getPreferredAudioProfiles(BluetoothDevice device) {\n        if (!isDualModeAudioEnabled()\n                || mLeAudioService == null\n                || !isDualModeAudioSinkDevice(device)) {\n            return Bundle.EMPTY;\n        }\n        // Checks if the device is part of an LE Audio group\n        List<BluetoothDevice> groupDevices = mLeAudioService.getGroupDevices(device);\n        if (groupDevices.isEmpty()) {\n            return Bundle.EMPTY;\n        }\n\n        // If there are no preferences stored, return the defaults\n        Bundle storedBundle = Bundle.EMPTY;\n        for (BluetoothDevice groupDevice : groupDevices) {\n            Bundle groupDevicePreferences = mDatabaseManager.getPreferredAudioProfiles(groupDevice);\n            if (!groupDevicePreferences.isEmpty()) {\n                storedBundle = groupDevicePreferences;\n                break;\n            }\n        }\n\n        if (storedBundle.isEmpty()) {\n            Bundle defaultPreferencesBundle = new Bundle();\n            boolean useDefaultPreferences = false;\n            if (isOutputOnlyAudioSupported(groupDevices)) {\n                // Gets the default output only audio profile or defaults to LE_AUDIO if not present\n                int outputOnlyDefault =\n                        BluetoothProperties.getDefaultOutputOnlyAudioProfile()\n                                .orElse(BluetoothProfile.LE_AUDIO);\n                if (outputOnlyDefault != BluetoothProfile.A2DP\n                        && outputOnlyDefault != BluetoothProfile.LE_AUDIO) {\n                    outputOnlyDefault = BluetoothProfile.LE_AUDIO;\n                }\n                defaultPreferencesBundle.putInt(\n                        BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY, outputOnlyDefault);\n                useDefaultPreferences = true;\n            }\n            if (isDuplexAudioSupported(groupDevices)) {\n                // Gets the default duplex audio profile or defaults to LE_AUDIO if not present\n                int duplexDefault =\n                        BluetoothProperties.getDefaultDuplexAudioProfile()\n                                .orElse(BluetoothProfile.LE_AUDIO);\n                if (duplexDefault != BluetoothProfile.HEADSET\n                        && duplexDefault != BluetoothProfile.LE_AUDIO) {\n                    duplexDefault = BluetoothProfile.LE_AUDIO;\n                }\n                defaultPreferencesBundle.putInt(BluetoothAdapter.AUDIO_MODE_DUPLEX, duplexDefault);\n                useDefaultPreferences = true;\n            }\n\n            if (useDefaultPreferences) {\n                return defaultPreferencesBundle;\n            }\n        }\n        return storedBundle;\n    }\n\n    /**\n     * Sets the preferred audio profiles for the device. See {@link\n     * BluetoothAdapter#setPreferredAudioProfiles(BluetoothDevice, Bundle)} for more details.\n     *\n     * @param device is the remote device whose preferences we want to fetch\n     * @param modeToProfileBundle is the preferences we want to set for the device\n     * @return whether the preferences were successfully requested\n     */\n    private int setPreferredAudioProfiles(BluetoothDevice device, Bundle modeToProfileBundle) {\n        Log.i(TAG, \"setPreferredAudioProfiles for device=\" + device);\n        if (!isDualModeAudioEnabled()) {\n            Log.e(TAG, \"setPreferredAudioProfiles called while sysprop is disabled\");\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n        if (mLeAudioService == null) {\n            Log.e(TAG, \"setPreferredAudioProfiles: LEA service is not up\");\n            return BluetoothStatusCodes.ERROR_PROFILE_NOT_CONNECTED;\n        }\n        if (!isDualModeAudioSinkDevice(device)) {\n            Log.e(TAG, \"setPreferredAudioProfiles: Not a dual mode audio device\");\n            return BluetoothStatusCodes.ERROR_NOT_DUAL_MODE_AUDIO_DEVICE;\n        }\n        // Checks if the device is part of an LE Audio group\n        int groupId = mLeAudioService.getGroupId(device);\n        List<BluetoothDevice> groupDevices = mLeAudioService.getGroupDevices(groupId);\n        if (groupDevices.isEmpty()) {\n            return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n        }\n\n        // Copies relevant keys & values from modeToProfile bundle\n        Bundle strippedPreferences = new Bundle();\n        if (modeToProfileBundle.containsKey(BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY)\n                && isOutputOnlyAudioSupported(groupDevices)) {\n            int outputOnlyProfile =\n                    modeToProfileBundle.getInt(BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY);\n            if (outputOnlyProfile != BluetoothProfile.A2DP\n                    && outputOnlyProfile != BluetoothProfile.LE_AUDIO) {\n                throw new IllegalArgumentException(\n                        \"AUDIO_MODE_OUTPUT_ONLY has invalid value: \" + outputOnlyProfile);\n            }\n            strippedPreferences.putInt(BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY, outputOnlyProfile);\n        }\n        if (modeToProfileBundle.containsKey(BluetoothAdapter.AUDIO_MODE_DUPLEX)\n                && isDuplexAudioSupported(groupDevices)) {\n            int duplexProfile = modeToProfileBundle.getInt(BluetoothAdapter.AUDIO_MODE_DUPLEX);\n            if (duplexProfile != BluetoothProfile.HEADSET\n                    && duplexProfile != BluetoothProfile.LE_AUDIO) {\n                throw new IllegalArgumentException(\n                        \"AUDIO_MODE_DUPLEX has invalid value: \" + duplexProfile);\n            }\n            strippedPreferences.putInt(BluetoothAdapter.AUDIO_MODE_DUPLEX, duplexProfile);\n        }\n\n        synchronized (mCsipGroupsPendingAudioProfileChanges) {\n            if (mCsipGroupsPendingAudioProfileChanges.containsKey(groupId)) {\n                return BluetoothStatusCodes.ERROR_ANOTHER_ACTIVE_REQUEST;\n            }\n\n            Bundle previousPreferences = getPreferredAudioProfiles(device);\n\n            int dbResult =\n                    mDatabaseManager.setPreferredAudioProfiles(groupDevices, strippedPreferences);\n            if (dbResult != BluetoothStatusCodes.SUCCESS) {\n                return dbResult;\n            }\n\n            int outputOnlyPreference =\n                    strippedPreferences.getInt(BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY);\n            if (outputOnlyPreference == 0) {\n                outputOnlyPreference =\n                        previousPreferences.getInt(BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY);\n            }\n            int duplexPreference = strippedPreferences.getInt(BluetoothAdapter.AUDIO_MODE_DUPLEX);\n            if (duplexPreference == 0) {\n                duplexPreference = previousPreferences.getInt(BluetoothAdapter.AUDIO_MODE_DUPLEX);\n            }\n\n            mLeAudioService.sendAudioProfilePreferencesToNative(\n                    groupId,\n                    outputOnlyPreference == BluetoothProfile.LE_AUDIO,\n                    duplexPreference == BluetoothProfile.LE_AUDIO);\n\n            /* Populates the HashMap to hold requests on the groupId. We will update\n            numRequestsToAudioFramework after we make requests to the audio framework */\n            PendingAudioProfilePreferenceRequest holdRequest =\n                    new PendingAudioProfilePreferenceRequest(strippedPreferences, 0, device);\n            mCsipGroupsPendingAudioProfileChanges.put(groupId, holdRequest);\n\n            // Notifies audio framework via the handler thread to avoid this blocking calls\n            mHandler.post(\n                    () ->\n                            sendPreferredAudioProfileChangeToAudioFramework(\n                                    device, strippedPreferences, previousPreferences));\n            return BluetoothStatusCodes.SUCCESS;\n        }\n    }\n\n    /**\n     * Sends the updated preferred audio profiles to the audio framework.\n     *\n     * @param device is the device with updated audio preferences\n     * @param strippedPreferences is a {@link Bundle} containing the preferences\n     */\n    private void sendPreferredAudioProfileChangeToAudioFramework(\n            BluetoothDevice device, Bundle strippedPreferences, Bundle previousPreferences) {\n        int newOutput = strippedPreferences.getInt(BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY);\n        int newDuplex = strippedPreferences.getInt(BluetoothAdapter.AUDIO_MODE_DUPLEX);\n        int previousOutput = previousPreferences.getInt(BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY);\n        int previousDuplex = previousPreferences.getInt(BluetoothAdapter.AUDIO_MODE_DUPLEX);\n\n        Log.i(\n                TAG,\n                \"sendPreferredAudioProfileChangeToAudioFramework: changing output from \"\n                        + BluetoothProfile.getProfileName(previousOutput)\n                        + \" to \"\n                        + BluetoothProfile.getProfileName(newOutput)\n                        + \" and duplex from \"\n                        + BluetoothProfile.getProfileName(previousDuplex)\n                        + \" to \"\n                        + BluetoothProfile.getProfileName(newDuplex));\n\n        // If no change from existing preferences, do not inform audio framework\n        if (previousOutput == newOutput && previousDuplex == newDuplex) {\n            Log.i(TAG, \"No change to preferred audio profiles, no requests to Audio FW\");\n            sendPreferredAudioProfilesCallbackToApps(\n                    device, strippedPreferences, BluetoothStatusCodes.SUCCESS);\n            return;\n        }\n\n        int numRequestsToAudioFw = 0;\n\n        // Checks if the device is part of an LE Audio group\n        int groupId = mLeAudioService.getGroupId(device);\n        List<BluetoothDevice> groupDevices = mLeAudioService.getGroupDevices(groupId);\n        if (groupDevices.isEmpty()) {\n            Log.i(\n                    TAG,\n                    \"sendPreferredAudioProfileChangeToAudioFramework: Empty LEA group for \"\n                            + \"device - \"\n                            + device);\n            sendPreferredAudioProfilesCallbackToApps(\n                    device, strippedPreferences, BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED);\n            return;\n        }\n\n        synchronized (mCsipGroupsPendingAudioProfileChanges) {\n            if (previousOutput != newOutput) {\n                if (newOutput == BluetoothProfile.A2DP\n                        && mA2dpService.getActiveDevice() != null\n                        && groupDevices.contains(mA2dpService.getActiveDevice())) {\n                    Log.i(TAG, \"Sent change for AUDIO_MODE_OUTPUT_ONLY to A2DP to Audio FW\");\n                    numRequestsToAudioFw +=\n                            mA2dpService.sendPreferredAudioProfileChangeToAudioFramework();\n                } else if (newOutput == BluetoothProfile.LE_AUDIO\n                        && mLeAudioService.getActiveGroupId() == groupId) {\n                    Log.i(TAG, \"Sent change for AUDIO_MODE_OUTPUT_ONLY to LE_AUDIO to Audio FW\");\n                    numRequestsToAudioFw +=\n                            mLeAudioService.sendPreferredAudioProfileChangeToAudioFramework();\n                }\n            }\n\n            if (previousDuplex != newDuplex) {\n                if (newDuplex == BluetoothProfile.HEADSET\n                        && mHeadsetService.getActiveDevice() != null\n                        && groupDevices.contains(mHeadsetService.getActiveDevice())) {\n                    Log.i(TAG, \"Sent change for AUDIO_MODE_DUPLEX to HFP to Audio FW\");\n                    // TODO(b/275426145): Add similar HFP method in BluetoothProfileConnectionInfo\n                    numRequestsToAudioFw +=\n                            mA2dpService.sendPreferredAudioProfileChangeToAudioFramework();\n                } else if (newDuplex == BluetoothProfile.LE_AUDIO\n                        && mLeAudioService.getActiveGroupId() == groupId) {\n                    Log.i(TAG, \"Sent change for AUDIO_MODE_DUPLEX to LE_AUDIO to Audio FW\");\n                    numRequestsToAudioFw +=\n                            mLeAudioService.sendPreferredAudioProfileChangeToAudioFramework();\n                }\n            }\n\n            Log.i(\n                    TAG,\n                    \"sendPreferredAudioProfileChangeToAudioFramework: sent \"\n                            + numRequestsToAudioFw\n                            + \" request(s) to the Audio Framework for device: \"\n                            + device);\n\n            if (numRequestsToAudioFw > 0) {\n                mCsipGroupsPendingAudioProfileChanges.put(\n                        groupId,\n                        new PendingAudioProfilePreferenceRequest(\n                                strippedPreferences, numRequestsToAudioFw, device));\n\n                Message m =\n                        mHandler.obtainMessage(\n                                MESSAGE_PREFERRED_AUDIO_PROFILES_AUDIO_FRAMEWORK_TIMEOUT);\n                m.obj = groupId;\n                mHandler.sendMessageDelayed(m, PREFERRED_AUDIO_PROFILE_CHANGE_TIMEOUT.toMillis());\n                return;\n            }\n        }\n        sendPreferredAudioProfilesCallbackToApps(\n                device, strippedPreferences, BluetoothStatusCodes.SUCCESS);\n    }\n\n    private void removeFromPendingAudioProfileChanges(int groupId) {\n        synchronized (mCsipGroupsPendingAudioProfileChanges) {\n            Log.i(\n                    TAG,\n                    \"removeFromPendingAudioProfileChanges: Timeout on change for groupId=\"\n                            + groupId);\n            if (!mCsipGroupsPendingAudioProfileChanges.containsKey(groupId)) {\n                Log.e(\n                        TAG,\n                        \"removeFromPendingAudioProfileChanges( \"\n                                + groupId\n                                + \", \"\n                                + groupId\n                                + \") is not pending\");\n                return;\n            }\n        }\n    }\n\n    /**\n     * Notification from the audio framework that an active device change has taken effect. See\n     * {@link BluetoothAdapter#notifyActiveDeviceChangeApplied(BluetoothDevice)} for more details.\n     *\n     * @param device the remote device whose preferred audio profiles have been changed\n     * @return whether the Bluetooth stack acknowledged the change successfully\n     */\n    private int notifyActiveDeviceChangeApplied(BluetoothDevice device) {\n        if (mLeAudioService == null) {\n            Log.e(TAG, \"LE Audio profile not enabled\");\n            return BluetoothStatusCodes.ERROR_PROFILE_NOT_CONNECTED;\n        }\n\n        int groupId = mLeAudioService.getGroupId(device);\n        if (groupId == LE_AUDIO_GROUP_ID_INVALID) {\n            return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n        }\n\n        synchronized (mCsipGroupsPendingAudioProfileChanges) {\n            if (!mCsipGroupsPendingAudioProfileChanges.containsKey(groupId)) {\n                Log.e(\n                        TAG,\n                        \"notifyActiveDeviceChangeApplied, but no pending request for \"\n                                + \"groupId: \"\n                                + groupId);\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n            }\n\n            PendingAudioProfilePreferenceRequest pendingRequest =\n                    mCsipGroupsPendingAudioProfileChanges.get(groupId);\n\n            // If this is the final audio framework request, send callback to apps\n            if (pendingRequest.mRemainingRequestsToAudioFramework == 1) {\n                Log.i(\n                        TAG,\n                        \"notifyActiveDeviceChangeApplied: Complete for device \"\n                                + pendingRequest.mDeviceRequested);\n                sendPreferredAudioProfilesCallbackToApps(\n                        pendingRequest.mDeviceRequested,\n                        pendingRequest.mRequestedPreferences,\n                        BluetoothStatusCodes.SUCCESS);\n                // Removes the timeout from the handler\n                mHandler.removeMessages(\n                        MESSAGE_PREFERRED_AUDIO_PROFILES_AUDIO_FRAMEWORK_TIMEOUT, groupId);\n            } else if (pendingRequest.mRemainingRequestsToAudioFramework > 1) {\n                PendingAudioProfilePreferenceRequest updatedPendingRequest =\n                        new PendingAudioProfilePreferenceRequest(\n                                pendingRequest.mRequestedPreferences,\n                                pendingRequest.mRemainingRequestsToAudioFramework - 1,\n                                pendingRequest.mDeviceRequested);\n                Log.i(\n                        TAG,\n                        \"notifyActiveDeviceChangeApplied: Updating device \"\n                                + updatedPendingRequest.mDeviceRequested\n                                + \" with new remaining requests count=\"\n                                + updatedPendingRequest.mRemainingRequestsToAudioFramework);\n                mCsipGroupsPendingAudioProfileChanges.put(groupId, updatedPendingRequest);\n            } else {\n                Log.i(\n                        TAG,\n                        \"notifyActiveDeviceChangeApplied: \"\n                                + pendingRequest.mDeviceRequested\n                                + \" has no remaining requests to audio framework, but is still\"\n                                + \" present in mCsipGroupsPendingAudioProfileChanges\");\n            }\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    private void sendPreferredAudioProfilesCallbackToApps(\n            BluetoothDevice device, Bundle preferredAudioProfiles, int status) {\n        int n = mPreferredAudioProfilesCallbacks.beginBroadcast();\n        Log.d(\n                TAG,\n                \"sendPreferredAudioProfilesCallbackToApps() - Broadcasting audio profile \"\n                        + (\"change callback to device: \" + device)\n                        + (\" and status=\" + status)\n                        + (\" to \" + n + \" receivers.\"));\n        for (int i = 0; i < n; i++) {\n            try {\n                mPreferredAudioProfilesCallbacks\n                        .getBroadcastItem(i)\n                        .onPreferredAudioProfilesChanged(device, preferredAudioProfiles, status);\n            } catch (RemoteException e) {\n                Log.d(\n                        TAG,\n                        \"sendPreferredAudioProfilesCallbackToApps() - Callback #\"\n                                + i\n                                + \" failed (\"\n                                + e\n                                + \")\");\n            }\n        }\n        mPreferredAudioProfilesCallbacks.finishBroadcast();\n    }\n\n    // ----API Methods--------\n\n    public boolean isEnabled() {\n        return getState() == BluetoothAdapter.STATE_ON;\n    }\n\n    public int getState() {\n        if (mAdapterProperties != null) {\n            return mAdapterProperties.getState();\n        }\n        return BluetoothAdapter.STATE_OFF;\n    }\n\n    public synchronized void offToBleOn(boolean quietMode) {\n        // Enforce the user restriction for disallowing Bluetooth if it was set.\n        if (mUserManager.hasUserRestrictionForUser(\n                UserManager.DISALLOW_BLUETOOTH, UserHandle.SYSTEM)) {\n            Log.d(TAG, \"offToBleOn() called when Bluetooth was disallowed\");\n            return;\n        }\n        if (Flags.fastBindToApp()) {\n            // The call to init must be done on the main thread\n            mHandler.post(() -> init());\n        }\n\n        Log.i(TAG, \"offToBleOn() - Enable called with quiet mode status =  \" + quietMode);\n        mQuietmode = quietMode;\n        mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_ON);\n    }\n\n    void onToBleOn() {\n        Log.d(TAG, \"onToBleOn() called with mRunningProfiles.size() = \" + mRunningProfiles.size());\n        mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_OFF);\n    }\n\n    public String getName() {\n        return mAdapterProperties.getName();\n    }\n\n    public int getNameLengthForAdvertise() {\n        return mAdapterProperties.getName().length();\n    }\n\n    List<DiscoveringPackage> getDiscoveringPackages() {\n        return mDiscoveringPackages;\n    }\n\n    void clearDiscoveringPackages() {\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.clear();\n        }\n    }\n\n    boolean startDiscovery(AttributionSource source) {\n        UserHandle callingUser = Binder.getCallingUserHandle();\n        Log.d(TAG, \"startDiscovery\");\n        String callingPackage = source.getPackageName();\n        mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);\n        boolean isQApp = Utils.checkCallerTargetSdk(this, callingPackage, Build.VERSION_CODES.Q);\n        boolean hasDisavowedLocation =\n                Utils.hasDisavowedLocationForScan(this, source, mTestModeEnabled);\n        String permission = null;\n        if (Utils.checkCallerHasNetworkSettingsPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETTINGS;\n        } else if (Utils.checkCallerHasNetworkSetupWizardPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETUP_WIZARD;\n        } else if (!hasDisavowedLocation) {\n            if (isQApp) {\n                if (!Utils.checkCallerHasFineLocation(this, source, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_FINE_LOCATION;\n            } else {\n                if (!Utils.checkCallerHasCoarseLocation(this, source, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_COARSE_LOCATION;\n            }\n        }\n\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.add(\n                    new DiscoveringPackage(callingPackage, permission, hasDisavowedLocation));\n        }\n        return mNativeInterface.startDiscovery();\n    }\n\n    /**\n     * Same as API method {@link BluetoothAdapter#getBondedDevices()}\n     *\n     * @return array of bonded {@link BluetoothDevice} or null on error\n     */\n    public BluetoothDevice[] getBondedDevices() {\n        return mAdapterProperties.getBondedDevices();\n    }\n\n    /**\n     * Get the database manager to access Bluetooth storage\n     *\n     * @return {@link DatabaseManager} or null on error\n     */\n    public DatabaseManager getDatabase() {\n        return mDatabaseManager;\n    }\n\n    public byte[] getByteIdentityAddress(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.getIdentityAddress() != null) {\n            return Utils.getBytesFromAddress(deviceProp.getIdentityAddress());\n        }\n\n        if (Flags.identityAddressNullIfNotKnown()) {\n            // Return null if identity address unknown\n            return null;\n        } else {\n            return Utils.getByteAddress(device);\n        }\n    }\n\n    public BluetoothDevice getDeviceFromByte(byte[] address) {\n        BluetoothDevice device = mRemoteDevices.getDevice(address);\n        if (device == null) {\n            device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address);\n        }\n        return device;\n    }\n\n    public String getIdentityAddress(String address) {\n        BluetoothDevice device =\n                BluetoothAdapter.getDefaultAdapter().getRemoteDevice(Ascii.toUpperCase(address));\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.getIdentityAddress() != null) {\n            return deviceProp.getIdentityAddress();\n        } else {\n            if (Flags.identityAddressNullIfNotKnown()) {\n                // Return null if identity address unknown\n                return null;\n            } else {\n                return address;\n            }\n        }\n    }\n\n    private static class CallerInfo {\n        public String callerPackageName;\n        public UserHandle user;\n    }\n\n    boolean createBond(\n            BluetoothDevice device,\n            int transport,\n            OobData remoteP192Data,\n            OobData remoteP256Data,\n            String callingPackage) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.getBondState() != BluetoothDevice.BOND_NONE) {\n            // true for BONDING, false for BONDED\n            return deviceProp.getBondState() == BluetoothDevice.BOND_BONDING;\n        }\n\n        if (!isEnabled()) {\n            Log.e(TAG, \"Impossible to call createBond when Bluetooth is not enabled\");\n            return false;\n        }\n\n        if (!isPackageNameAccurate(this, callingPackage, Binder.getCallingUid())) {\n            return false;\n        }\n\n        CallerInfo createBondCaller = new CallerInfo();\n        createBondCaller.callerPackageName = callingPackage;\n        createBondCaller.user = Binder.getCallingUserHandle();\n        mBondAttemptCallerInfo.put(device.getAddress(), createBondCaller);\n\n        mRemoteDevices.setBondingInitiatedLocally(Utils.getByteAddress(device));\n\n        // Pairing is unreliable while scanning, so cancel discovery\n        // Note, remove this when native stack improves\n        mNativeInterface.cancelDiscovery();\n\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.CREATE_BOND);\n        msg.obj = device;\n        msg.arg1 = transport;\n\n        Bundle remoteOobDatasBundle = new Bundle();\n        boolean setData = false;\n        if (remoteP192Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP192, remoteP192Data);\n            setData = true;\n        }\n        if (remoteP256Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP256, remoteP256Data);\n            setData = true;\n        }\n        if (setData) {\n            msg.setData(remoteOobDatasBundle);\n        } else {\n            MetricsLogger.getInstance()\n                    .logBluetoothEvent(\n                            device,\n                            BluetoothStatsLog\n                                    .BLUETOOTH_CROSS_LAYER_EVENT_REPORTED__EVENT_TYPE__BONDING,\n                            BluetoothStatsLog.BLUETOOTH_CROSS_LAYER_EVENT_REPORTED__STATE__START,\n                            Binder.getCallingUid());\n        }\n        mBondStateMachine.sendMessage(msg);\n        return true;\n    }\n\n    /**\n     * Fetches the local OOB data to give out to remote.\n     *\n     * @param transport - specify data transport.\n     * @param callback - callback used to receive the requested {@link OobData}; null will be\n     *     ignored silently.\n     */\n    public synchronized void generateLocalOobData(\n            int transport, IBluetoothOobDataCallback callback) {\n        if (callback == null) {\n            Log.e(TAG, \"'callback' argument must not be null!\");\n            return;\n        }\n        if (mOobDataCallbackQueue.peek() != null) {\n            try {\n                callback.onError(BluetoothStatusCodes.ERROR_ANOTHER_ACTIVE_OOB_REQUEST);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n            return;\n        }\n        mOobDataCallbackQueue.offer(callback);\n        mHandler.postDelayed(\n                () -> removeFromOobDataCallbackQueue(callback),\n                GENERATE_LOCAL_OOB_DATA_TIMEOUT.toMillis());\n        mNativeInterface.generateLocalOobData(transport);\n    }\n\n    private synchronized void removeFromOobDataCallbackQueue(IBluetoothOobDataCallback callback) {\n        if (callback == null) {\n            return;\n        }\n\n        if (mOobDataCallbackQueue.peek() == callback) {\n            try {\n                mOobDataCallbackQueue.poll().onError(BluetoothStatusCodes.ERROR_UNKNOWN);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make OobDataCallback to remove callback from queue\", e);\n            }\n        }\n    }\n\n    /* package */ synchronized void notifyOobDataCallback(int transport, OobData oobData) {\n        if (mOobDataCallbackQueue.peek() == null) {\n            Log.e(TAG, \"Failed to make callback, no callback exists\");\n            return;\n        }\n        if (oobData == null) {\n            try {\n                mOobDataCallbackQueue.poll().onError(BluetoothStatusCodes.ERROR_UNKNOWN);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        } else {\n            try {\n                mOobDataCallbackQueue.poll().onOobData(transport, oobData);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        }\n    }\n\n    public boolean isQuietModeEnabled() {\n        Log.d(TAG, \"isQuietModeEnabled() - Enabled = \" + mQuietmode);\n        return mQuietmode;\n    }\n\n    public void updateUuids() {\n        Log.d(TAG, \"updateUuids() - Updating UUIDs for bonded devices\");\n        BluetoothDevice[] bondedDevices = getBondedDevices();\n        if (bondedDevices == null) {\n            return;\n        }\n\n        for (BluetoothDevice device : bondedDevices) {\n            mRemoteDevices.updateUuids(device);\n        }\n    }\n\n    /**\n     * Update device UUID changed to {@link BondStateMachine}\n     *\n     * @param device remote device of interest\n     */\n    public void deviceUuidUpdated(BluetoothDevice device) {\n        // Notify BondStateMachine for SDP complete / UUID changed.\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.UUID_UPDATE);\n        msg.obj = device;\n        mBondStateMachine.sendMessage(msg);\n    }\n\n    /**\n     * Get the bond state of a particular {@link BluetoothDevice}\n     *\n     * @param device remote device of interest\n     * @return bond state\n     *     <p>Possible values are {@link BluetoothDevice#BOND_NONE}, {@link\n     *     BluetoothDevice#BOND_BONDING}, {@link BluetoothDevice#BOND_BONDED}.\n     */\n    public int getBondState(BluetoothDevice device) {\n        return mRemoteDevices.getBondState(device);\n    }\n\n    public boolean isConnected(BluetoothDevice device) {\n        return getConnectionState(device) != BluetoothDevice.CONNECTION_STATE_DISCONNECTED;\n    }\n\n    public int getConnectionState(BluetoothDevice device) {\n        final String address = device.getAddress();\n        if (Flags.apiGetConnectionStateUsingIdentityAddress()) {\n            int connectionState = mNativeInterface.getConnectionState(getBytesFromAddress(address));\n            final String identityAddress = getIdentityAddress(address);\n            if (identityAddress != null) {\n                connectionState |=\n                        mNativeInterface.getConnectionState(getBytesFromAddress(identityAddress));\n            }\n            return connectionState;\n        }\n        return mNativeInterface.getConnectionState(getBytesFromAddress(address));\n    }\n\n    int getConnectionHandle(BluetoothDevice device, int transport) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return BluetoothDevice.ERROR;\n        }\n        return deviceProp.getConnectionHandle(transport);\n    }\n\n    /**\n     * Get ASHA Capability\n     *\n     * @param device discovered bluetooth device\n     * @return ASHA capability\n     */\n    public int getAshaCapability(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return BluetoothDevice.ERROR;\n        }\n        return deviceProp.getAshaCapability();\n    }\n\n    /**\n     * Get ASHA truncated HiSyncId\n     *\n     * @param device discovered bluetooth device\n     * @return ASHA truncated HiSyncId\n     */\n    public int getAshaTruncatedHiSyncId(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return BluetoothDevice.ERROR;\n        }\n        return deviceProp.getAshaTruncatedHiSyncId();\n    }\n\n    /**\n     * Checks whether the device was recently associated with the comapnion app that called {@link\n     * BluetoothDevice#createBond}. This allows these devices to skip the pairing dialog if their\n     * pairing variant is {@link BluetoothDevice#PAIRING_VARIANT_CONSENT}.\n     *\n     * @param device the bluetooth device that is being bonded\n     * @return true if it was recently associated and we can bypass the dialog, false otherwise\n     */\n    public boolean canBondWithoutDialog(BluetoothDevice device) {\n        if (mBondAttemptCallerInfo.containsKey(device.getAddress())) {\n            CallerInfo bondCallerInfo = mBondAttemptCallerInfo.get(device.getAddress());\n\n            return mCompanionDeviceManager.canPairWithoutPrompt(\n                    bondCallerInfo.callerPackageName, device.getAddress(), bondCallerInfo.user);\n        }\n        return false;\n    }\n\n    /**\n     * Returns the package name of the most recent caller that called {@link\n     * BluetoothDevice#createBond} on the given device.\n     */\n    @Nullable\n    public String getPackageNameOfBondingApplication(BluetoothDevice device) {\n        CallerInfo info = mBondAttemptCallerInfo.get(device.getAddress());\n        if (info == null) {\n            return null;\n        }\n        return info.callerPackageName;\n    }\n\n    /**\n     * Sets device as the active devices for the profiles passed into the function.\n     *\n     * @param device is the remote bluetooth device\n     * @param profiles is a constant that references for which profiles we'll be setting the remote\n     *     device as our active device. One of the following: {@link\n     *     BluetoothAdapter#ACTIVE_DEVICE_AUDIO}, {@link BluetoothAdapter#ACTIVE_DEVICE_PHONE_CALL}\n     *     {@link BluetoothAdapter#ACTIVE_DEVICE_ALL}\n     * @return false if profiles value is not one of the constants we accept, true otherwise\n     */\n    public boolean setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles) {\n        if (getState() != BluetoothAdapter.STATE_ON) {\n            Log.e(TAG, \"setActiveDevice: Bluetooth is not enabled\");\n            return false;\n        }\n        boolean setA2dp = false;\n        boolean setHeadset = false;\n\n        // Determine for which profiles we want to set device as our active device\n        switch (profiles) {\n            case BluetoothAdapter.ACTIVE_DEVICE_AUDIO:\n                setA2dp = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_PHONE_CALL:\n                setHeadset = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_ALL:\n                setA2dp = true;\n                setHeadset = true;\n                break;\n            default:\n                return false;\n        }\n\n        boolean a2dpSupported =\n                mA2dpService != null\n                        && (device == null\n                                || mA2dpService.getConnectionPolicy(device)\n                                        == BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n        boolean hfpSupported =\n                mHeadsetService != null\n                        && (device == null\n                                || mHeadsetService.getConnectionPolicy(device)\n                                        == BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n        boolean leAudioSupported =\n                mLeAudioService != null\n                        && (device == null\n                                || mLeAudioService.getConnectionPolicy(device)\n                                        == BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n\n        if (leAudioSupported) {\n            Log.i(TAG, \"setActiveDevice: Setting active Le Audio device \" + device);\n            if (device == null) {\n                /* If called by BluetoothAdapter it means Audio should not be stopped.\n                 * For this reason let's say that fallback device exists\n                 */\n                mLeAudioService.removeActiveDevice(true /* hasFallbackDevice */);\n            } else {\n                mLeAudioService.setActiveDevice(device);\n            }\n        }\n\n        if (setA2dp && a2dpSupported) {\n            Log.i(TAG, \"setActiveDevice: Setting active A2dp device \" + device);\n            if (device == null) {\n                mA2dpService.removeActiveDevice(false);\n            } else {\n                /* Workaround for the controller issue which is not able to handle correctly\n                 * A2DP offloader vendor specific command while ISO Data path is set.\n                 * Proper solutions should be delivered in b/312396770\n                 */\n                if (mLeAudioService != null) {\n                    List<BluetoothDevice> activeLeAudioDevices = mLeAudioService.getActiveDevices();\n                    if (activeLeAudioDevices.get(0) != null) {\n                        mLeAudioService.removeActiveDevice(true);\n                    }\n                }\n                mA2dpService.setActiveDevice(device);\n            }\n        }\n\n        if (mHearingAidService != null\n                && (device == null\n                        || mHearingAidService.getConnectionPolicy(device)\n                                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Hearing Aid \" + device);\n            if (device == null) {\n                mHearingAidService.removeActiveDevice(false);\n            } else {\n                mHearingAidService.setActiveDevice(device);\n            }\n        }\n\n        if (setHeadset && hfpSupported) {\n            Log.i(TAG, \"setActiveDevice: Setting active Headset \" + device);\n            mHeadsetService.setActiveDevice(device);\n        }\n\n        return true;\n    }\n\n    /**\n     * Checks if all supported classic audio profiles are active on this LE Audio device.\n     *\n     * @param leAudioDevice the remote device\n     * @return {@code true} if all supported classic audio profiles are active on this device,\n     *     {@code false} otherwise\n     */\n    public boolean isAllSupportedClassicAudioProfilesActive(BluetoothDevice leAudioDevice) {\n        if (mLeAudioService == null) {\n            return false;\n        }\n        boolean a2dpSupported = isProfileSupported(leAudioDevice, BluetoothProfile.A2DP);\n        boolean hfpSupported = isProfileSupported(leAudioDevice, BluetoothProfile.HEADSET);\n\n        List<BluetoothDevice> groupDevices = mLeAudioService.getGroupDevices(leAudioDevice);\n        if (hfpSupported && mHeadsetService != null) {\n            BluetoothDevice activeHfpDevice = mHeadsetService.getActiveDevice();\n            if (activeHfpDevice == null || !groupDevices.contains(activeHfpDevice)) {\n                return false;\n            }\n        }\n        if (a2dpSupported && mA2dpService != null) {\n            BluetoothDevice activeA2dpDevice = mA2dpService.getActiveDevice();\n            if (activeA2dpDevice == null || !groupDevices.contains(activeA2dpDevice)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Get the active devices for the BluetoothProfile specified\n     *\n     * @param profile is the profile from which we want the active devices. Possible values are:\n     *     {@link BluetoothProfile#HEADSET}, {@link BluetoothProfile#A2DP}, {@link\n     *     BluetoothProfile#HEARING_AID} {@link BluetoothProfile#LE_AUDIO}\n     * @return A list of active bluetooth devices\n     */\n    public List<BluetoothDevice> getActiveDevices(@ActiveDeviceProfile int profile) {\n        List<BluetoothDevice> activeDevices = new ArrayList<>();\n\n        switch (profile) {\n            case BluetoothProfile.HEADSET:\n                if (mHeadsetService == null) {\n                    Log.e(TAG, \"getActiveDevices: HeadsetService is null\");\n                } else {\n                    BluetoothDevice device = mHeadsetService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: Headset device: \" + device);\n                }\n                break;\n            case BluetoothProfile.A2DP:\n                if (mA2dpService == null) {\n                    Log.e(TAG, \"getActiveDevices: A2dpService is null\");\n                } else {\n                    BluetoothDevice device = mA2dpService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: A2dp device: \" + device);\n                }\n                break;\n            case BluetoothProfile.HEARING_AID:\n                if (mHearingAidService == null) {\n                    Log.e(TAG, \"getActiveDevices: HearingAidService is null\");\n                } else {\n                    activeDevices = mHearingAidService.getActiveDevices();\n                    Log.i(\n                            TAG,\n                            \"getActiveDevices: Hearing Aid devices:\"\n                                    + (\" Left[\" + activeDevices.get(0) + \"] -\")\n                                    + (\" Right[\" + activeDevices.get(1) + \"]\"));\n                }\n                break;\n            case BluetoothProfile.LE_AUDIO:\n                if (mLeAudioService == null) {\n                    Log.e(TAG, \"getActiveDevices: LeAudioService is null\");\n                } else {\n                    activeDevices = mLeAudioService.getActiveDevices();\n                    Log.i(\n                            TAG,\n                            \"getActiveDevices: LeAudio devices:\"\n                                    + (\" Lead[\" + activeDevices.get(0) + \"] -\")\n                                    + (\" member_1[\" + activeDevices.get(1) + \"]\"));\n                }\n                break;\n            default:\n                Log.e(TAG, \"getActiveDevices: profile value is not valid\");\n        }\n        return activeDevices;\n    }\n\n    /**\n     * Attempts connection to all enabled and supported bluetooth profiles between the local and\n     * remote device\n     *\n     * @param device is the remote device with which to connect these profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS} if all profiles connections are attempted, false\n     *     if an error occurred\n     */\n    public int connectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"connectAllEnabledProfiles: Not all profile services running\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        // Checks if any profiles are enablde or disabled and if so, only connect enabled profiles\n        if (!isAllProfilesUnknown(device)) {\n            return connectEnabledProfiles(device);\n        }\n\n        connectAllSupportedProfiles(device);\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Connect all supported bluetooth profiles between the local and remote device\n     *\n     * @param device is the remote device with which to connect all supported profiles\n     */\n    void connectAllSupportedProfiles(BluetoothDevice device) {\n        int numProfilesConnected = 0;\n\n        // All profile toggles disabled, so connects all supported profiles\n        if (mA2dpService != null && isProfileSupported(device, BluetoothProfile.A2DP)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting A2dp\");\n            // Set connection policy also connects the profile with CONNECTION_POLICY_ALLOWED\n            mA2dpService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mA2dpSinkService != null && isProfileSupported(device, BluetoothProfile.A2DP_SINK)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetService != null && isProfileSupported(device, BluetoothProfile.HEADSET)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Headset Profile\");\n            mHeadsetService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetClientService != null\n                && isProfileSupported(device, BluetoothProfile.HEADSET_CLIENT)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting HFP\");\n            mHeadsetClientService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mMapClientService != null && isProfileSupported(device, BluetoothProfile.MAP_CLIENT)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting MAP\");\n            mMapClientService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHidHostService != null && isProfileSupported(device, BluetoothProfile.HID_HOST)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Hid Host Profile\");\n            mHidHostService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPanService != null && isProfileSupported(device, BluetoothProfile.PAN)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Pan Profile\");\n            mPanService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPbapClientService != null\n                && isProfileSupported(device, BluetoothProfile.PBAP_CLIENT)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Pbap\");\n            mPbapClientService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHearingAidService != null\n                && isProfileSupported(device, BluetoothProfile.HEARING_AID)) {\n            if (mHapClientService != null\n                    && isProfileSupported(device, BluetoothProfile.HAP_CLIENT)) {\n                Log.i(\n                        TAG,\n                        \"connectAllSupportedProfiles: Hearing Access Client Profile is enabled at\"\n                                + \" the same time with Hearing Aid Profile, ignore Hearing Aid\"\n                                + \" Profile\");\n            } else {\n                Log.i(TAG, \"connectAllSupportedProfiles: Connecting Hearing Aid Profile\");\n                mHearingAidService.setConnectionPolicy(\n                        device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n                numProfilesConnected++;\n            }\n        }\n        if (mHapClientService != null && isProfileSupported(device, BluetoothProfile.HAP_CLIENT)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Hearing Access Client Profile\");\n            mHapClientService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mVolumeControlService != null\n                && isProfileSupported(device, BluetoothProfile.VOLUME_CONTROL)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mCsipSetCoordinatorService != null\n                && isProfileSupported(device, BluetoothProfile.CSIP_SET_COORDINATOR)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mLeAudioService != null && isProfileSupported(device, BluetoothProfile.LE_AUDIO)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mBassClientService != null\n                && isProfileSupported(device, BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mBatteryService != null && isProfileSupported(device, BluetoothProfile.BATTERY)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Battery Service\");\n            mBatteryService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n\n        Log.i(\n                TAG,\n                \"connectAllSupportedProfiles: Number of Profiles Connected: \"\n                        + numProfilesConnected);\n    }\n\n    /**\n     * Disconnects all enabled and supported bluetooth profiles between the local and remote device\n     *\n     * @param device is the remote device with which to disconnect these profiles\n     * @return true if all profiles successfully disconnected, false if an error occurred\n     */\n    public int disconnectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"disconnectAllEnabledProfiles: Not all profile services bound\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        if (mA2dpService != null\n                && (mA2dpService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mA2dpService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp\");\n            mA2dpService.disconnect(device);\n        }\n        if (mA2dpSinkService != null\n                && (mA2dpSinkService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mA2dpSinkService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp Sink\");\n            mA2dpSinkService.disconnect(device);\n        }\n        if (mHeadsetService != null\n                && (mHeadsetService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mHeadsetService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Headset Profile\");\n            mHeadsetService.disconnect(device);\n        }\n        if (mHeadsetClientService != null\n                && (mHeadsetClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTED\n                        || mHeadsetClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting HFP\");\n            mHeadsetClientService.disconnect(device);\n        }\n        if (mMapClientService != null\n                && (mMapClientService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mMapClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP Client\");\n            mMapClientService.disconnect(device);\n        }\n        if (mMapService != null\n                && (mMapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mMapService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP\");\n            mMapService.disconnect(device);\n        }\n        if (mHidDeviceService != null\n                && (mHidDeviceService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mHidDeviceService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Device Profile\");\n            mHidDeviceService.disconnect(device);\n        }\n        if (mHidHostService != null\n                && (mHidHostService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mHidHostService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Host Profile\");\n            mHidHostService.disconnect(device);\n        }\n        if (mPanService != null\n                && (mPanService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mPanService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pan Profile\");\n            mPanService.disconnect(device);\n        }\n        if (mPbapClientService != null\n                && (mPbapClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTED\n                        || mPbapClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Client\");\n            mPbapClientService.disconnect(device);\n        }\n        if (mPbapService != null\n                && (mPbapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mPbapService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Server\");\n            mPbapService.disconnect(device);\n        }\n        if (mHearingAidService != null\n                && (mHearingAidService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTED\n                        || mHearingAidService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Aid Profile\");\n            mHearingAidService.disconnect(device);\n        }\n        if (mHapClientService != null\n                && (mHapClientService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mHapClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Access Profile Client\");\n            mHapClientService.disconnect(device);\n        }\n        if (mVolumeControlService != null\n                && (mVolumeControlService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTED\n                        || mVolumeControlService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Volume Control Profile\");\n            mVolumeControlService.disconnect(device);\n        }\n        if (mSapService != null\n                && (mSapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mSapService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Sap Profile\");\n            mSapService.disconnect(device);\n        }\n        if (mCsipSetCoordinatorService != null\n                && (mCsipSetCoordinatorService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTED\n                        || mCsipSetCoordinatorService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Coordinator Set Profile\");\n            mCsipSetCoordinatorService.disconnect(device);\n        }\n        if (mLeAudioService != null\n                && (mLeAudioService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mLeAudioService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting LeAudio profile (BAP)\");\n            mLeAudioService.disconnect(device);\n        }\n        if (mBassClientService != null\n                && (mBassClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTED\n                        || mBassClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(\n                    TAG,\n                    \"disconnectAllEnabledProfiles: Disconnecting \"\n                            + \"LE Broadcast Assistant Profile\");\n            mBassClientService.disconnect(device);\n        }\n        if (mBatteryService != null\n                && (mBatteryService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mBatteryService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting \" + \"Battery Service\");\n            mBatteryService.disconnect(device);\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Same as API method {@link BluetoothDevice#getName()}\n     *\n     * @param device remote device of interest\n     * @return remote device name\n     */\n    public String getRemoteName(BluetoothDevice device) {\n        return mRemoteDevices.getName(device);\n    }\n\n    public int getRemoteClass(BluetoothDevice device) {\n        return mRemoteDevices.getBluetoothClass(device);\n    }\n\n    /**\n     * Get UUIDs for service supported by a remote device\n     *\n     * @param device the remote device that we want to get UUIDs from\n     * @return the uuids of the remote device\n     */\n    public ParcelUuid[] getRemoteUuids(BluetoothDevice device) {\n        return mRemoteDevices.getUuids(device);\n    }\n\n    void aclStateChangeBroadcastCallback(Consumer<IBluetoothConnectionCallback> cb) {\n        int n = mBluetoothConnectionCallbacks.beginBroadcast();\n        Log.d(TAG, \"aclStateChangeBroadcastCallback() - Broadcasting to \" + n + \" receivers.\");\n        for (int i = 0; i < n; i++) {\n            cb.accept(mBluetoothConnectionCallbacks.getBroadcastItem(i));\n        }\n        mBluetoothConnectionCallbacks.finishBroadcast();\n    }\n\n    /**\n     * Converts HCI disconnect reasons to Android disconnect reasons.\n     *\n     * <p>The HCI Error Codes used for ACL disconnect reasons propagated up from native code were\n     * copied from: packages/modules/Bluetooth/system/stack/include/hci_error_code.h\n     *\n     * <p>These error codes are specified and described in Bluetooth Core Spec v5.1, Vol 2, Part D.\n     *\n     * @param hciReason is the raw HCI disconnect reason from native.\n     * @return the Android disconnect reason for apps.\n     */\n    static @BluetoothAdapter.BluetoothConnectionCallback.DisconnectReason int\n            hciToAndroidDisconnectReason(int hciReason) {\n        switch (hciReason) {\n            case /*HCI_SUCCESS*/ 0x00:\n            case /*HCI_ERR_UNSPECIFIED*/ 0x1F:\n            case /*HCI_ERR_UNDEFINED*/ 0xff:\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n            case /*HCI_ERR_ILLEGAL_COMMAND*/ 0x01:\n            case /*HCI_ERR_NO_CONNECTION*/ 0x02:\n            case /*HCI_ERR_HW_FAILURE*/ 0x03:\n            case /*HCI_ERR_DIFF_TRANSACTION_COLLISION*/ 0x2A:\n            case /*HCI_ERR_ROLE_SWITCH_PENDING*/ 0x32:\n            case /*HCI_ERR_ROLE_SWITCH_FAILED*/ 0x35:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL;\n            case /*HCI_ERR_PAGE_TIMEOUT*/ 0x04:\n            case /*HCI_ERR_CONNECTION_TOUT*/ 0x08:\n            case /*HCI_ERR_HOST_TIMEOUT*/ 0x10:\n            case /*HCI_ERR_LMP_RESPONSE_TIMEOUT*/ 0x22:\n            case /*HCI_ERR_ADVERTISING_TIMEOUT*/ 0x3C:\n            case /*HCI_ERR_CONN_FAILED_ESTABLISHMENT*/ 0x3E:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_TIMEOUT;\n            case /*HCI_ERR_AUTH_FAILURE*/ 0x05:\n            case /*HCI_ERR_KEY_MISSING*/ 0x06:\n            case /*HCI_ERR_HOST_REJECT_SECURITY*/ 0x0E:\n            case /*HCI_ERR_REPEATED_ATTEMPTS*/ 0x17:\n            case /*HCI_ERR_PAIRING_NOT_ALLOWED*/ 0x18:\n            case /*HCI_ERR_ENCRY_MODE_NOT_ACCEPTABLE*/ 0x25:\n            case /*HCI_ERR_UNIT_KEY_USED*/ 0x26:\n            case /*HCI_ERR_PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED*/ 0x29:\n            case /*HCI_ERR_INSUFFCIENT_SECURITY*/ 0x2F:\n            case /*HCI_ERR_HOST_BUSY_PAIRING*/ 0x38:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SECURITY;\n            case /*HCI_ERR_MEMORY_FULL*/ 0x07:\n            case /*HCI_ERR_MAX_NUM_OF_CONNECTIONS*/ 0x09:\n            case /*HCI_ERR_MAX_NUM_OF_SCOS*/ 0x0A:\n            case /*HCI_ERR_COMMAND_DISALLOWED*/ 0x0C:\n            case /*HCI_ERR_HOST_REJECT_RESOURCES*/ 0x0D:\n            case /*HCI_ERR_LIMIT_REACHED*/ 0x43:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_RESOURCE_LIMIT_REACHED;\n            case /*HCI_ERR_CONNECTION_EXISTS*/ 0x0B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_CONNECTION_ALREADY_EXISTS;\n            case /*HCI_ERR_HOST_REJECT_DEVICE*/ 0x0F:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SYSTEM_POLICY;\n            case /*HCI_ERR_ILLEGAL_PARAMETER_FMT*/ 0x12:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            case /*HCI_ERR_PEER_USER*/ 0x13:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE_REQUEST;\n            case /*HCI_ERR_REMOTE_POWER_OFF*/ 0x15:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE_REQUEST;\n            case /*HCI_ERR_CONN_CAUSE_LOCAL_HOST*/ 0x16:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL_REQUEST;\n            case /*HCI_ERR_UNSUPPORTED_REM_FEATURE*/ 0x1A:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE;\n            case /*HCI_ERR_UNACCEPT_CONN_INTERVAL*/ 0x3B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            default:\n                Log.e(TAG, \"Invalid HCI disconnect reason: \" + hciReason);\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n    }\n\n    void logUserBondResponse(BluetoothDevice device, boolean accepted, int event) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            BluetoothStatsLog.write(\n                    BluetoothStatsLog.BLUETOOTH_BOND_STATE_CHANGED,\n                    obfuscateAddress(device),\n                    0,\n                    device.getType(),\n                    BluetoothDevice.BOND_BONDING,\n                    event,\n                    accepted ? 0 : BluetoothDevice.UNBOND_REASON_AUTH_REJECTED);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    public int getPhonebookAccessPermission(BluetoothDevice device) {\n        return getDeviceAccessFromPrefs(device, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public int getMessageAccessPermission(BluetoothDevice device) {\n        return getDeviceAccessFromPrefs(device, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public int getSimAccessPermission(BluetoothDevice device) {\n        return getDeviceAccessFromPrefs(device, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    int getDeviceAccessFromPrefs(BluetoothDevice device, String prefFile) {\n        SharedPreferences prefs = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        if (!prefs.contains(device.getAddress())) {\n            return BluetoothDevice.ACCESS_UNKNOWN;\n        }\n        return prefs.getBoolean(device.getAddress(), false)\n                ? BluetoothDevice.ACCESS_ALLOWED\n                : BluetoothDevice.ACCESS_REJECTED;\n    }\n\n    void setDeviceAccessFromPrefs(BluetoothDevice device, int value, String prefFile) {\n        SharedPreferences pref = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = pref.edit();\n        if (value == BluetoothDevice.ACCESS_UNKNOWN) {\n            editor.remove(device.getAddress());\n        } else {\n            editor.putBoolean(device.getAddress(), value == BluetoothDevice.ACCESS_ALLOWED);\n        }\n        editor.apply();\n    }\n\n    public void setPhonebookAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setMessageAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setSimAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public boolean isRpaOffloadSupported() {\n        return mAdapterProperties.isRpaOffloadSupported();\n    }\n\n    public int getNumOfOffloadedIrkSupported() {\n        return mAdapterProperties.getNumOfOffloadedIrkSupported();\n    }\n\n    public int getNumOfOffloadedScanFilterSupported() {\n        return mAdapterProperties.getNumOfOffloadedScanFilterSupported();\n    }\n\n    public int getOffloadedScanResultStorage() {\n        return mAdapterProperties.getOffloadedScanResultStorage();\n    }\n\n    public boolean isLe2MPhySupported() {\n        return mAdapterProperties.isLe2MPhySupported();\n    }\n\n    public boolean isLeCodedPhySupported() {\n        return mAdapterProperties.isLeCodedPhySupported();\n    }\n\n    public boolean isLeExtendedAdvertisingSupported() {\n        return mAdapterProperties.isLeExtendedAdvertisingSupported();\n    }\n\n    public boolean isLePeriodicAdvertisingSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast source feature is supported.\n     *\n     * @return true, if the LE audio broadcast source is supported\n     */\n    public boolean isLeAudioBroadcastSourceSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported()\n                && mAdapterProperties.isLeExtendedAdvertisingSupported()\n                && mAdapterProperties.isLeIsochronousBroadcasterSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast assistant feature is supported.\n     *\n     * @return true, if the LE audio broadcast assistant is supported\n     */\n    public boolean isLeAudioBroadcastAssistantSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported()\n                && mAdapterProperties.isLeExtendedAdvertisingSupported()\n                && (mAdapterProperties.isLePeriodicAdvertisingSyncTransferSenderSupported()\n                        || mAdapterProperties\n                                .isLePeriodicAdvertisingSyncTransferRecipientSupported());\n    }\n\n    /**\n     * Check if the LE channel sounding feature is supported.\n     *\n     * @return true, if the LE channel sounding is supported\n     */\n    public boolean isLeChannelSoundingSupported() {\n        return mAdapterProperties.isLeChannelSoundingSupported();\n    }\n\n    public long getSupportedProfilesBitMask() {\n        return Config.getSupportedProfilesBitMask();\n    }\n\n    /**\n     * Check if the LE audio CIS central feature is supported.\n     *\n     * @return true, if the LE audio CIS central is supported\n     */\n    public boolean isLeConnectedIsochronousStreamCentralSupported() {\n        return mAdapterProperties.isLeConnectedIsochronousStreamCentralSupported();\n    }\n\n    public int getLeMaximumAdvertisingDataLength() {\n        return mAdapterProperties.getLeMaximumAdvertisingDataLength();\n    }\n\n    /**\n     * Get the maximum number of connected audio devices.\n     *\n     * @return the maximum number of connected audio devices\n     */\n    public int getMaxConnectedAudioDevices() {\n        return mAdapterProperties.getMaxConnectedAudioDevices();\n    }\n\n    /**\n     * Check whether A2DP offload is enabled.\n     *\n     * @return true if A2DP offload is enabled\n     */\n    public boolean isA2dpOffloadEnabled() {\n        return mAdapterProperties.isA2dpOffloadEnabled();\n    }\n\n    /** Register a bluetooth state callback */\n    public void registerBluetoothStateCallback(Executor executor, BluetoothStateCallback callback) {\n        mLocalCallbacks.put(callback, executor);\n    }\n\n    /** Unregister a bluetooth state callback */\n    public void unregisterBluetoothStateCallback(BluetoothStateCallback callback) {\n        mLocalCallbacks.remove(callback);\n    }\n\n    @VisibleForTesting\n    void registerRemoteCallback(IBluetoothCallback callback) {\n        mRemoteCallbacks.register(callback);\n    }\n\n    @VisibleForTesting\n    void unregisterRemoteCallback(IBluetoothCallback callback) {\n        mRemoteCallbacks.unregister(callback);\n    }\n\n    @VisibleForTesting\n    void bleOnToOn() {\n        mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_ON);\n    }\n\n    @VisibleForTesting\n    void bleOnToOff() {\n        mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n    }\n\n    @VisibleForTesting\n    boolean factoryReset() {\n        mDatabaseManager.factoryReset();\n\n        if (mBluetoothKeystoreService != null) {\n            mBluetoothKeystoreService.factoryReset();\n        }\n\n        if (mBtCompanionManager != null) {\n            mBtCompanionManager.factoryReset();\n        }\n\n        return mNativeInterface.factoryReset();\n    }\n\n    @VisibleForTesting\n    int getScanMode() {\n        return mScanMode;\n    }\n\n    private boolean setScanMode(int mode, String from) {\n        mScanModeChanges.add(Utils.getLocalTimeString() + \" (\" + from + \") \" + dumpScanMode(mode));\n        if (!mNativeInterface.setScanMode(convertScanModeToHal(mode))) {\n            return false;\n        }\n        mScanMode = mode;\n        Intent intent =\n                new Intent(BluetoothAdapter.ACTION_SCAN_MODE_CHANGED)\n                        .putExtra(BluetoothAdapter.EXTRA_SCAN_MODE, mScanMode)\n                        .addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);\n        sendBroadcast(intent, BLUETOOTH_SCAN, Utils.getTempBroadcastOptions().toBundle());\n        return true;\n    }\n\n    @VisibleForTesting\n    BluetoothActivityEnergyInfo reportActivityInfo() {\n        if (mAdapterProperties.getState() != BluetoothAdapter.STATE_ON\n                || !mAdapterProperties.isActivityAndEnergyReportingSupported()) {\n            return null;\n        }\n\n        // Pull the data. The callback will notify mEnergyInfoLock.\n        mNativeInterface.readEnergyInfo();\n\n        synchronized (mEnergyInfoLock) {\n            long now = System.currentTimeMillis();\n            final long deadline = now + CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS;\n            while (now < deadline) {\n                try {\n                    mEnergyInfoLock.wait(deadline - now);\n                    break;\n                } catch (InterruptedException e) {\n                    now = System.currentTimeMillis();\n                }\n            }\n\n            final BluetoothActivityEnergyInfo info =\n                    new BluetoothActivityEnergyInfo(\n                            SystemClock.elapsedRealtime(),\n                            mStackReportedState,\n                            mTxTimeTotalMs,\n                            mRxTimeTotalMs,\n                            mIdleTimeTotalMs,\n                            mEnergyUsedTotalVoltAmpSecMicro);\n\n            // Copy the traffic objects whose byte counts are > 0\n            final List<UidTraffic> result = new ArrayList<>();\n            for (int i = 0; i < mUidTraffic.size(); i++) {\n                final UidTraffic traffic = mUidTraffic.valueAt(i);\n                if (traffic.getTxBytes() != 0 || traffic.getRxBytes() != 0) {\n                    result.add(traffic.clone());\n                }\n            }\n\n            info.setUidTraffic(result);\n\n            return info;\n        }\n    }\n\n    public int getTotalNumOfTrackableAdvertisements() {\n        return mAdapterProperties.getTotalNumOfTrackableAdvertisements();\n    }\n\n    /**\n     * Return if offloaded TDS filter is supported.\n     *\n     * @return {@code BluetoothStatusCodes.FEATURE_SUPPORTED} if supported\n     */\n    public int getOffloadedTransportDiscoveryDataScanSupported() {\n        if (mAdapterProperties.isOffloadedTransportDiscoveryDataScanSupported()) {\n            return BluetoothStatusCodes.FEATURE_SUPPORTED;\n        }\n        return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n    }\n\n    IBinder getBluetoothGatt() {\n        return mGattService == null ? null : mGattService.getBinder();\n    }\n\n    public GattService getBluetoothGattService() {\n        return mGattService;\n    }\n\n    IBinder getBluetoothScan() {\n        return mScanController == null ? null : mScanController.getBinder();\n    }\n\n    public ScanController getBluetoothScanController() {\n        return mScanController;\n    }\n\n    @RequiresPermission(BLUETOOTH_CONNECT)\n    void unregAllGattClient(AttributionSource source) {\n        if (mGattService != null) {\n            mGattService.unregAll(source);\n        }\n    }\n\n    IBinder getProfile(int profileId) {\n        if (getState() == BluetoothAdapter.STATE_TURNING_ON) {\n            return null;\n        }\n\n        // LE_AUDIO_BROADCAST is not associated with a service and use LE_AUDIO's Binder\n        if (profileId == BluetoothProfile.LE_AUDIO_BROADCAST) {\n            profileId = BluetoothProfile.LE_AUDIO;\n        }\n\n        ProfileService profile = mStartedProfiles.get(profileId);\n        if (profile != null) {\n            return profile.getBinder();\n        } else {\n            return null;\n        }\n    }\n\n    boolean isMediaProfileConnected() {\n        if (mA2dpService != null && mA2dpService.getConnectedDevices().size() > 0) {\n            Log.d(TAG, \"isMediaProfileConnected. A2dp is connected\");\n            return true;\n        } else if (mHearingAidService != null\n                && mHearingAidService.getConnectedDevices().size() > 0) {\n            Log.d(TAG, \"isMediaProfileConnected. HearingAid is connected\");\n            return true;\n        } else if (mLeAudioService != null && mLeAudioService.getConnectedDevices().size() > 0) {\n            Log.d(TAG, \"isMediaProfileConnected. LeAudio is connected\");\n            return true;\n        } else {\n            Log.d(\n                    TAG,\n                    \"isMediaProfileConnected: no Media connected.\"\n                            + (\" A2dp=\" + mA2dpService)\n                            + (\" HearingAid=\" + mHearingAidService)\n                            + (\" LeAudio=\" + mLeAudioService));\n            return false;\n        }\n    }\n\n    /** Update PhonePolicy when new {@link BluetoothDevice} creates an ACL connection. */\n    public void updatePhonePolicyOnAclConnect(BluetoothDevice device) {\n        if (mPhonePolicy != null) {\n            mPhonePolicy.handleAclConnected(device);\n        }\n    }\n\n    /**\n     * Notify {@link BluetoothProfile} when ACL connection disconnects from {@link BluetoothDevice}\n     * for a given {@code transport}.\n     */\n    public void notifyAclDisconnected(BluetoothDevice device, int transport) {\n        if (mMapService != null && mMapService.isAvailable()) {\n            mMapService.aclDisconnected(device);\n        }\n        if (mMapClientService != null && mMapClientService.isAvailable()) {\n            mMapClientService.aclDisconnected(device, transport);\n        }\n        if (mSapService != null && mSapService.isAvailable()) {\n            mSapService.aclDisconnected(device);\n        }\n        if (mPbapClientService != null && mPbapClientService.isAvailable()) {\n            mPbapClientService.aclDisconnected(device, transport);\n        }\n    }\n\n    /**\n     * Notify GATT of a Bluetooth profile's connection state change for a given {@link\n     * BluetoothProfile}.\n     */\n    public void notifyProfileConnectionStateChangeToGatt(int profile, int fromState, int toState) {\n        if (mGattService == null) {\n            Log.w(TAG, \"GATT Service is not running!\");\n            return;\n        }\n        if (Flags.scanManagerRefactor()) {\n            mScanController.notifyProfileConnectionStateChange(profile, fromState, toState);\n        } else {\n            mGattService.notifyProfileConnectionStateChange(profile, fromState, toState);\n        }\n    }\n\n    /**\n     * Handle Bluetooth app state when connection state changes for a given {@code profile}.\n     *\n     * <p>Currently this function is limited to handling Phone policy but the eventual goal is to\n     * move all connection logic here.\n     */\n    public void handleProfileConnectionStateChange(\n            int profile, BluetoothDevice device, int fromState, int toState) {\n        if (mPhonePolicy != null) {\n            mPhonePolicy.profileConnectionStateChanged(profile, device, fromState, toState);\n        }\n    }\n\n    /** Handle Bluetooth app state when active device changes for a given {@code profile}. */\n    public void handleActiveDeviceChange(int profile, BluetoothDevice device) {\n        mActiveDeviceManager.profileActiveDeviceChanged(profile, device);\n        mSilenceDeviceManager.profileActiveDeviceChanged(profile, device);\n        if (mPhonePolicy != null) {\n            mPhonePolicy.profileActiveDeviceChanged(profile, device);\n        }\n    }\n\n    /** Notify MAP and Pbap when a new sdp search record is found. */\n    public void sendSdpSearchRecord(\n            BluetoothDevice device, int status, Parcelable record, ParcelUuid uuid) {\n        if (mMapService != null && mMapService.isAvailable()) {\n            mMapService.receiveSdpSearchRecord(status, record, uuid);\n        }\n        if (mMapClientService != null && mMapClientService.isAvailable()) {\n            mMapClientService.receiveSdpSearchRecord(device, status, record, uuid);\n        }\n        if (mPbapClientService != null && mPbapClientService.isAvailable()) {\n            mPbapClientService.receiveSdpSearchRecord(device, status, record, uuid);\n        }\n    }\n\n    /** Handle Bluetooth profiles when bond state changes with a {@link BluetoothDevice} */\n    public void handleBondStateChanged(BluetoothDevice device, int fromState, int toState) {\n        if (mA2dpService != null && mA2dpService.isAvailable()) {\n            mA2dpService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mHeadsetService != null && mHeadsetService.isAvailable()) {\n            mHeadsetService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mLeAudioService != null && mLeAudioService.isAvailable()) {\n            mLeAudioService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mHearingAidService != null && mHearingAidService.isAvailable()) {\n            mHearingAidService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mHapClientService != null && mHapClientService.isAvailable()) {\n            mHapClientService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mBassClientService != null && mBassClientService.isAvailable()) {\n            mBassClientService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mBatteryService != null && mBatteryService.isAvailable()) {\n            mBatteryService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mVolumeControlService != null && mVolumeControlService.isAvailable()) {\n            mVolumeControlService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mPbapService != null && mPbapService.isAvailable()) {\n            mPbapService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mCsipSetCoordinatorService != null && mCsipSetCoordinatorService.isAvailable()) {\n            mCsipSetCoordinatorService.handleBondStateChanged(device, fromState, toState);\n        }\n        mDatabaseManager.handleBondStateChanged(device, fromState, toState);\n\n        if (toState == BOND_NONE) {\n            // Remove the permissions for unbonded devices\n            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n        }\n    }\n\n    static int convertScanModeToHal(int mode) {\n        switch (mode) {\n            case SCAN_MODE_NONE:\n                return AbstractionLayer.BT_SCAN_MODE_NONE;\n            case SCAN_MODE_CONNECTABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE;\n            case SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        return -1;\n    }\n\n    static int convertScanModeFromHal(int mode) {\n        switch (mode) {\n            case AbstractionLayer.BT_SCAN_MODE_NONE:\n                return SCAN_MODE_NONE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE:\n                return SCAN_MODE_CONNECTABLE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        return -1;\n    }\n\n    // This function is called from JNI. It allows native code to acquire a single wake lock.\n    // If the wake lock is already held, this function returns success. Although this function\n    // only supports acquiring a single wake lock at a time right now, it will eventually be\n    // extended to allow acquiring an arbitrary number of wake locks. The current interface\n    // takes |lockName| as a parameter in anticipation of that implementation.\n    boolean acquireWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                mWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, lockName);\n            }\n\n            if (!mWakeLock.isHeld()) {\n                mWakeLock.acquire();\n            }\n        }\n        return true;\n    }\n\n    // This function is called from JNI. It allows native code to release a wake lock acquired\n    // by |acquireWakeLock|. If the wake lock is not held, this function returns failure.\n    // Note that the release() call is also invoked by {@link #cleanup()} so a synchronization is\n    // needed here. See the comment for |acquireWakeLock| for an explanation of the interface.\n    boolean releaseWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                Log.e(TAG, \"Repeated wake lock release; aborting release: \" + lockName);\n                return false;\n            }\n\n            if (mWakeLock.isHeld()) {\n                mWakeLock.release();\n            }\n        }\n        return true;\n    }\n\n    void energyInfoCallbackInternal(\n            int status,\n            int ctrlState,\n            long txTime,\n            long rxTime,\n            long idleTime,\n            long energyUsed,\n            UidTraffic[] data) {\n        // Energy is product of mA, V and ms. If the chipset doesn't\n        // report it, we have to compute it from time\n        if (energyUsed == 0) {\n            try {\n                final long txMah = Math.multiplyExact(txTime, getTxCurrentMa());\n                final long rxMah = Math.multiplyExact(rxTime, getRxCurrentMa());\n                final long idleMah = Math.multiplyExact(idleTime, getIdleCurrentMa());\n                energyUsed =\n                        (long)\n                                (Math.addExact(Math.addExact(txMah, rxMah), idleMah)\n                                        * getOperatingVolt());\n            } catch (ArithmeticException e) {\n                Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                // Energy is already 0 if the exception was thrown.\n            }\n        }\n\n        synchronized (mEnergyInfoLock) {\n            mStackReportedState = ctrlState;\n            long totalTxTimeMs;\n            long totalRxTimeMs;\n            long totalIdleTimeMs;\n            long totalEnergy;\n            try {\n                totalTxTimeMs = Math.addExact(mTxTimeTotalMs, txTime);\n                totalRxTimeMs = Math.addExact(mRxTimeTotalMs, rxTime);\n                totalIdleTimeMs = Math.addExact(mIdleTimeTotalMs, idleTime);\n                totalEnergy = Math.addExact(mEnergyUsedTotalVoltAmpSecMicro, energyUsed);\n            } catch (ArithmeticException e) {\n                // This could be because we accumulated a lot of time, or we got a very strange\n                // value from the controller (more likely). Discard this data.\n                Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                totalTxTimeMs = mTxTimeTotalMs;\n                totalRxTimeMs = mRxTimeTotalMs;\n                totalIdleTimeMs = mIdleTimeTotalMs;\n                totalEnergy = mEnergyUsedTotalVoltAmpSecMicro;\n            }\n\n            mTxTimeTotalMs = totalTxTimeMs;\n            mRxTimeTotalMs = totalRxTimeMs;\n            mIdleTimeTotalMs = totalIdleTimeMs;\n            mEnergyUsedTotalVoltAmpSecMicro = totalEnergy;\n\n            for (UidTraffic traffic : data) {\n                UidTraffic existingTraffic = mUidTraffic.get(traffic.getUid());\n                if (existingTraffic == null) {\n                    mUidTraffic.put(traffic.getUid(), traffic);\n                } else {\n                    existingTraffic.addRxBytes(traffic.getRxBytes());\n                    existingTraffic.addTxBytes(traffic.getTxBytes());\n                }\n            }\n            mEnergyInfoLock.notifyAll();\n        }\n    }\n\n    void energyInfoCallback(\n            int status,\n            int ctrlState,\n            long txTime,\n            long rxTime,\n            long idleTime,\n            long energyUsed,\n            UidTraffic[] data) {\n        if (Flags.btSystemContextReport()) {\n            energyInfoCallbackInternal(\n                    status, ctrlState, txTime, rxTime, idleTime, energyUsed, data);\n        } else if (ctrlState >= BluetoothActivityEnergyInfo.BT_STACK_STATE_INVALID\n                && ctrlState <= BluetoothActivityEnergyInfo.BT_STACK_STATE_STATE_IDLE) {\n            energyInfoCallbackInternal(\n                    status, ctrlState, txTime, rxTime, idleTime, energyUsed, data);\n        }\n        Log.v(\n                TAG,\n                \"energyInfoCallback()\"\n                        + (\" status = \" + status)\n                        + (\" txTime = \" + txTime)\n                        + (\" rxTime = \" + rxTime)\n                        + (\" idleTime = \" + idleTime)\n                        + (\" energyUsed = \" + energyUsed)\n                        + (\" ctrlState = \" + Utils.formatSimple(\"0x%08x\", ctrlState))\n                        + (\" traffic = \" + Arrays.toString(data)));\n    }\n\n    /** Update metadata change to registered listeners */\n    @VisibleForTesting\n    public void metadataChanged(String address, int key, byte[] value) {\n        BluetoothDevice device = mRemoteDevices.getDevice(Utils.getBytesFromAddress(address));\n\n        // pass just interesting metadata to native, to reduce spam\n        if (key == BluetoothDevice.METADATA_LE_AUDIO) {\n            mNativeInterface.metadataChanged(Utils.getBytesFromAddress(address), key, value);\n        }\n\n        RemoteCallbackList<IBluetoothMetadataListener> list = mMetadataListeners.get(device);\n        if (list == null) {\n            return;\n        }\n        int n = list.beginBroadcast();\n        for (int i = 0; i < n; i++) {\n            try {\n                list.getBroadcastItem(i).onMetadataChanged(device, key, value);\n            } catch (RemoteException e) {\n                Log.d(TAG, \"metadataChanged() - Callback #\" + i + \" failed (\" + e + \")\");\n            }\n        }\n        list.finishBroadcast();\n    }\n\n    private int getIdleCurrentMa() {\n        return BluetoothProperties.getHardwareIdleCurrentMa().orElse(0);\n    }\n\n    private int getTxCurrentMa() {\n        return BluetoothProperties.getHardwareTxCurrentMa().orElse(0);\n    }\n\n    private int getRxCurrentMa() {\n        return BluetoothProperties.getHardwareRxCurrentMa().orElse(0);\n    }\n\n    private double getOperatingVolt() {\n        return BluetoothProperties.getHardwareOperatingVoltageMv().orElse(0) / 1000.0;\n    }\n\n    public RemoteDevices getRemoteDevices() {\n        return mRemoteDevices;\n    }\n\n    private String dumpScanMode(int scanMode) {\n        switch (scanMode) {\n            case SCAN_MODE_NONE:\n                return \"SCAN_MODE_NONE\";\n            case SCAN_MODE_CONNECTABLE:\n                return \"SCAN_MODE_CONNECTABLE\";\n            case SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return \"SCAN_MODE_CONNECTABLE_DISCOVERABLE\";\n            default:\n                return \"Unknown Scan Mode \" + scanMode;\n        }\n    }\n\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        if (args.length == 0) {\n            writer.println(\"Skipping dump in APP SERVICES, see bluetooth_manager section.\");\n            writer.println(\"Use --print argument for dumpsys direct from AdapterService.\");\n            return;\n        }\n\n        if (\"set-test-mode\".equals(args[0])) {\n            final boolean testModeEnabled = \"enabled\".equalsIgnoreCase(args[1]);\n            for (ProfileService profile : mRunningProfiles) {\n                profile.setTestModeEnabled(testModeEnabled);\n            }\n            if (Flags.scanManagerRefactor() && mScanController != null) {\n                mScanController.setTestModeEnabled(testModeEnabled);\n            }\n            mTestModeEnabled = testModeEnabled;\n            return;\n        }\n\n        Log.v(TAG, \"dumpsys arguments, check for protobuf output: \" + TextUtils.join(\" \", args));\n        if (args[0].equals(\"--proto-bin\")) {\n            dumpMetrics(fd);\n            return;\n        }\n\n        writer.println();\n        mAdapterProperties.dump(fd, writer, args);\n\n        writer.println(\"ScanMode: \" + dumpScanMode(getScanMode()));\n        writer.println(\"Scan Mode Changes:\");\n        for (String log : mScanModeChanges) {\n            writer.println(\"    \" + log);\n        }\n        writer.println();\n        writer.println(\"sSnoopLogSettingAtEnable = \" + sSnoopLogSettingAtEnable);\n        writer.println(\"sDefaultSnoopLogSettingAtEnable = \" + sDefaultSnoopLogSettingAtEnable);\n\n        writer.println();\n        writer.println(\"Enabled Profile Services:\");\n        for (int profileId : Config.getSupportedProfiles()) {\n            writer.println(\"  \" + BluetoothProfile.getProfileName(profileId));\n        }\n        writer.println();\n\n        mAdapterStateMachine.dump(fd, writer, args);\n\n        StringBuilder sb = new StringBuilder();\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dump(sb);\n        }\n        mSilenceDeviceManager.dump(fd, writer, args);\n        mDatabaseManager.dump(writer);\n\n        writer.write(sb.toString());\n        writer.flush();\n\n        final int currentState = mAdapterProperties.getState();\n        if (currentState == BluetoothAdapter.STATE_OFF\n                || currentState == BluetoothAdapter.STATE_BLE_TURNING_ON\n                || currentState == BluetoothAdapter.STATE_TURNING_OFF\n                || currentState == BluetoothAdapter.STATE_BLE_TURNING_OFF) {\n            writer.println();\n            writer.println(\n                    \"Impossible to dump native stack. state=\"\n                            + BluetoothAdapter.nameForState(currentState));\n            writer.println();\n        } else {\n            mNativeInterface.dump(fd, args);\n        }\n    }\n\n    private void dumpMetrics(FileDescriptor fd) {\n        BluetoothMetricsProto.BluetoothLog.Builder metricsBuilder =\n                BluetoothMetricsProto.BluetoothLog.newBuilder();\n        byte[] nativeMetricsBytes = mNativeInterface.dumpMetrics();\n        Log.d(TAG, \"dumpMetrics: native metrics size is \" + nativeMetricsBytes.length);\n        if (nativeMetricsBytes.length > 0) {\n            try {\n                metricsBuilder.mergeFrom(nativeMetricsBytes);\n            } catch (InvalidProtocolBufferException ex) {\n                Log.w(TAG, \"dumpMetrics: problem parsing metrics protobuf, \" + ex.getMessage());\n                return;\n            }\n        }\n        metricsBuilder.setNumBondedDevices(getBondedDevices().length);\n        MetricsLogger.dumpProto(metricsBuilder);\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dumpProto(metricsBuilder);\n        }\n        byte[] metricsBytes = Base64.encode(metricsBuilder.build().toByteArray(), Base64.DEFAULT);\n        Log.d(TAG, \"dumpMetrics: combined metrics size is \" + metricsBytes.length);\n        try (FileOutputStream protoOut = new FileOutputStream(fd)) {\n            protoOut.write(metricsBytes);\n        } catch (IOException e) {\n            Log.e(TAG, \"dumpMetrics: error writing combined protobuf to fd, \" + e.getMessage());\n        }\n    }\n\n    @SuppressLint(\"AndroidFrameworkRequiresPermission\")\n    private void enforceBluetoothPrivilegedPermissionIfNeeded(\n            OobData remoteP192Data, OobData remoteP256Data) {\n        if (remoteP192Data != null || remoteP256Data != null) {\n            this.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n        }\n    }\n\n    private final Object mDeviceConfigLock = new Object();\n\n    /**\n     * Predicate that can be applied to names to determine if a device is well-known to be used for\n     * physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<String> mLocationDenylistName = (v) -> false;\n\n    /**\n     * Predicate that can be applied to MAC addresses to determine if a device is well-known to be\n     * used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistMac = (v) -> false;\n\n    /**\n     * Predicate that can be applied to Advertising Data payloads to determine if a device is\n     * well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistAdvertisingData = (v) -> false;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanQuotaCount = DeviceConfigListener.DEFAULT_SCAN_QUOTA_COUNT;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanQuotaWindowMillis = DeviceConfigListener.DEFAULT_SCAN_QUOTA_WINDOW_MILLIS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanTimeoutMillis = DeviceConfigListener.DEFAULT_SCAN_TIMEOUT_MILLIS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanUpgradeDurationMillis =\n            DeviceConfigListener.DEFAULT_SCAN_UPGRADE_DURATION_MILLIS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanDowngradeDurationMillis =\n            DeviceConfigListener.DEFAULT_SCAN_DOWNGRADE_DURATION_BT_CONNECTING_MILLIS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private String mLeAudioAllowList;\n\n    public @NonNull Predicate<String> getLocationDenylistName() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistName;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistMac() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistMac;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistAdvertisingData() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistAdvertisingData;\n        }\n    }\n\n    /** Returns scan quota count. */\n    public int getScanQuotaCount() {\n        synchronized (mDeviceConfigLock) {\n            return mScanQuotaCount;\n        }\n    }\n\n    /** Returns scan quota window in millis. */\n    public long getScanQuotaWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScanQuotaWindowMillis;\n        }\n    }\n\n    /** Returns scan timeout in millis. */\n    public long getScanTimeoutMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScanTimeoutMillis;\n        }\n    }\n\n    /** Returns scan upgrade duration in millis. */\n    public long getScanUpgradeDurationMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScanUpgradeDurationMillis;\n        }\n    }\n\n    /** Returns scan downgrade duration in millis. */\n    public long getScanDowngradeDurationMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScanDowngradeDurationMillis;\n        }\n    }\n\n    /** Returns SCREEN_OFF_BALANCED scan window in millis. */\n    public int getScreenOffBalancedWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedWindowMillis;\n        }\n    }\n\n    /** Returns SCREEN_OFF_BALANCED scan interval in millis. */\n    public int getScreenOffBalancedIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedIntervalMillis;\n        }\n    }\n\n    /** Returns SCREEN_OFF low power scan window in millis. */\n    public int getScreenOffLowPowerWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerWindowMillis;\n        }\n    }\n\n    /** Returns SCREEN_OFF low power scan interval in millis. */\n    public int getScreenOffLowPowerIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerIntervalMillis;\n        }\n    }\n\n    private class DeviceConfigListener implements DeviceConfig.OnPropertiesChangedListener {\n        private static final String LOCATION_DENYLIST_NAME = \"location_denylist_name\";\n        private static final String LOCATION_DENYLIST_MAC = \"location_denylist_mac\";\n        private static final String LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"location_denylist_advertising_data\";\n        private static final String SCAN_QUOTA_COUNT = \"scan_quota_count\";\n        private static final String SCAN_QUOTA_WINDOW_MILLIS = \"scan_quota_window_millis\";\n        private static final String SCAN_TIMEOUT_MILLIS = \"scan_timeout_millis\";\n        private static final String SCAN_UPGRADE_DURATION_MILLIS = \"scan_upgrade_duration_millis\";\n        private static final String SCAN_DOWNGRADE_DURATION_MILLIS =\n                \"scan_downgrade_duration_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_WINDOW_MILLIS =\n                \"screen_off_low_power_window_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS =\n                \"screen_off_low_power_interval_millis\";\n        private static final String SCREEN_OFF_BALANCED_WINDOW_MILLIS =\n                \"screen_off_balanced_window_millis\";\n        private static final String SCREEN_OFF_BALANCED_INTERVAL_MILLIS =\n                \"screen_off_balanced_interval_millis\";\n        private static final String LE_AUDIO_ALLOW_LIST = \"le_audio_allow_list\";\n\n        /**\n         * Default denylist which matches Eddystone (except for Eddystone-E2EE-EID) and iBeacon\n         * payloads.\n         */\n        private static final String DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"\u22880016AAFE40/00FFFFFFF0,\u22860016AAFE/00FFFFFF,\u228600FF4C0002/00FFFFFFFF\";\n\n        private static final int DEFAULT_SCAN_QUOTA_COUNT = 5;\n        private static final long DEFAULT_SCAN_QUOTA_WINDOW_MILLIS = 30 * SECOND_IN_MILLIS;\n        private static final long DEFAULT_SCAN_TIMEOUT_MILLIS = 10 * MINUTE_IN_MILLIS;\n        private static final int DEFAULT_SCAN_UPGRADE_DURATION_MILLIS = (int) SECOND_IN_MILLIS * 6;\n        private static final int DEFAULT_SCAN_DOWNGRADE_DURATION_BT_CONNECTING_MILLIS =\n                (int) SECOND_IN_MILLIS * 6;\n\n        public void start() {\n            DeviceConfig.addOnPropertiesChangedListener(\n                    DeviceConfig.NAMESPACE_BLUETOOTH, BackgroundThread.getExecutor(), this);\n            onPropertiesChanged(DeviceConfig.getProperties(DeviceConfig.NAMESPACE_BLUETOOTH));\n        }\n\n        @Override\n        public void onPropertiesChanged(DeviceConfig.Properties properties) {\n            synchronized (mDeviceConfigLock) {\n                final String name = properties.getString(LOCATION_DENYLIST_NAME, null);\n                mLocationDenylistName =\n                        !TextUtils.isEmpty(name)\n                                ? Pattern.compile(name).asPredicate()\n                                : (v) -> false;\n                mLocationDenylistMac =\n                        BytesMatcher.decode(properties.getString(LOCATION_DENYLIST_MAC, null));\n                mLocationDenylistAdvertisingData =\n                        BytesMatcher.decode(\n                                properties.getString(\n                                        LOCATION_DENYLIST_ADVERTISING_DATA,\n                                        DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA));\n                mScanQuotaCount = properties.getInt(SCAN_QUOTA_COUNT, DEFAULT_SCAN_QUOTA_COUNT);\n                mScanQuotaWindowMillis =\n                        properties.getLong(\n                                SCAN_QUOTA_WINDOW_MILLIS, DEFAULT_SCAN_QUOTA_WINDOW_MILLIS);\n                mScanTimeoutMillis =\n                        properties.getLong(SCAN_TIMEOUT_MILLIS, DEFAULT_SCAN_TIMEOUT_MILLIS);\n                mScanUpgradeDurationMillis =\n                        properties.getInt(\n                                SCAN_UPGRADE_DURATION_MILLIS, DEFAULT_SCAN_UPGRADE_DURATION_MILLIS);\n                mScanDowngradeDurationMillis =\n                        properties.getInt(\n                                SCAN_DOWNGRADE_DURATION_MILLIS,\n                                DEFAULT_SCAN_DOWNGRADE_DURATION_BT_CONNECTING_MILLIS);\n                mScreenOffLowPowerWindowMillis =\n                        properties.getInt(\n                                SCREEN_OFF_LOW_POWER_WINDOW_MILLIS,\n                                ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS);\n                mScreenOffLowPowerIntervalMillis =\n                        properties.getInt(\n                                SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS,\n                                ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS);\n                mScreenOffBalancedWindowMillis =\n                        properties.getInt(\n                                SCREEN_OFF_BALANCED_WINDOW_MILLIS,\n                                ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS);\n                mScreenOffBalancedIntervalMillis =\n                        properties.getInt(\n                                SCREEN_OFF_BALANCED_INTERVAL_MILLIS,\n                                ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS);\n                mLeAudioAllowList = properties.getString(LE_AUDIO_ALLOW_LIST, \"\");\n\n                if (!mLeAudioAllowList.isEmpty()) {\n                    List<String> leAudioAllowlistFromDeviceConfig =\n                            Arrays.asList(mLeAudioAllowList.split(\",\"));\n                    BluetoothProperties.le_audio_allow_list(leAudioAllowlistFromDeviceConfig);\n                }\n\n                List<String> leAudioAllowlistProp = BluetoothProperties.le_audio_allow_list();\n                if (leAudioAllowlistProp != null && !leAudioAllowlistProp.isEmpty()) {\n                    mLeAudioAllowDevices.clear();\n                    mLeAudioAllowDevices.addAll(leAudioAllowlistProp);\n                }\n            }\n        }\n    }\n\n    /** A callback that will be called when AdapterState is changed */\n    public interface BluetoothStateCallback {\n        /**\n         * Called when the status of bluetooth adapter is changing. {@code prevState} and {@code\n         * newState} takes one of following values defined in BluetoothAdapter.java: STATE_OFF,\n         * STATE_TURNING_ON, STATE_ON, STATE_TURNING_OFF, STATE_BLE_TURNING_ON, STATE_BLE_ON,\n         * STATE_BLE_TURNING_OFF\n         *\n         * @param prevState the previous Bluetooth state.\n         * @param newState the new Bluetooth state.\n         */\n        void onBluetoothStateChange(int prevState, int newState);\n    }\n\n    /**\n     * Obfuscate Bluetooth MAC address into a PII free ID string\n     *\n     * @param device Bluetooth device whose MAC address will be obfuscated\n     * @return a byte array that is unique to this MAC address on this device, or empty byte array\n     *     when either device is null or obfuscateAddressNative fails\n     */\n    public byte[] obfuscateAddress(BluetoothDevice device) {\n        if (device == null) {\n            return new byte[0];\n        }\n        return mNativeInterface.obfuscateAddress(Utils.getByteAddress(device));\n    }\n\n    /**\n     * Get dynamic audio buffer size supported type\n     *\n     * @return support\n     *     <p>Possible values are {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_NONE}, {@link\n     *     BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_OFFLOAD}, {@link\n     *     BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_SOFTWARE_ENCODING}.\n     */\n    public int getDynamicBufferSupport() {\n        return mAdapterProperties.getDynamicBufferSupport();\n    }\n\n    /**\n     * Get dynamic audio buffer size\n     *\n     * @return BufferConstraints\n     */\n    public BufferConstraints getBufferConstraints() {\n        return mAdapterProperties.getBufferConstraints();\n    }\n\n    /**\n     * Set dynamic audio buffer size\n     *\n     * @param codec Audio codec\n     * @param value buffer millis\n     * @return true if the settings is successful, false otherwise\n     */\n    public boolean setBufferLengthMillis(int codec, int value) {\n        return mAdapterProperties.setBufferLengthMillis(codec, value);\n    }\n\n    /**\n     * Get an incremental id of Bluetooth metrics and log\n     *\n     * @param device Bluetooth device\n     * @return int of id for Bluetooth metrics and logging, 0 if the device is invalid\n     */\n    public int getMetricId(BluetoothDevice device) {\n        if (device == null) {\n            return 0;\n        }\n        return mNativeInterface.getMetricId(Utils.getByteAddress(device));\n    }\n\n    public CompanionManager getCompanionManager() {\n        return mBtCompanionManager;\n    }\n\n    /**\n     * Call for the AdapterService receives bond state change\n     *\n     * @param device Bluetooth device\n     * @param state bond state\n     */\n    public void onBondStateChanged(BluetoothDevice device, int state) {\n        if (mBtCompanionManager != null) {\n            mBtCompanionManager.onBondStateChanged(device, state);\n        }\n    }\n\n    /**\n     * Get audio policy feature support status\n     *\n     * @param device Bluetooth device to be checked for audio policy support\n     * @return int status of the remote support for audio policy feature\n     */\n    public int isRequestAudioPolicyAsSinkSupported(BluetoothDevice device) {\n        if (mHeadsetClientService != null) {\n            return mHeadsetClientService.getAudioPolicyRemoteSupported(device);\n        } else {\n            Log.e(TAG, \"No audio transport connected\");\n            return BluetoothStatusCodes.FEATURE_NOT_CONFIGURED;\n        }\n    }\n\n    /**\n     * Set audio policy for remote device\n     *\n     * @param device Bluetooth device to be set policy for\n     * @return int result status for requestAudioPolicyAsSink API\n     */\n    public int requestAudioPolicyAsSink(BluetoothDevice device, BluetoothSinkAudioPolicy policies) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n        }\n\n        if (mHeadsetClientService != null) {\n            if (isRequestAudioPolicyAsSinkSupported(device)\n                    != BluetoothStatusCodes.FEATURE_SUPPORTED) {\n                throw new UnsupportedOperationException(\n                        \"Request Audio Policy As Sink not supported\");\n            }\n            deviceProp.setHfAudioPolicyForRemoteAg(policies);\n            mHeadsetClientService.setAudioPolicy(device, policies);\n            return BluetoothStatusCodes.SUCCESS;\n        } else {\n            Log.e(TAG, \"HeadsetClient not connected\");\n            return BluetoothStatusCodes.ERROR_PROFILE_NOT_CONNECTED;\n        }\n    }\n\n    /**\n     * Get audio policy for remote device\n     *\n     * @param device Bluetooth device to be set policy for\n     * @return {@link BluetoothSinkAudioPolicy} policy stored for the device\n     */\n    public BluetoothSinkAudioPolicy getRequestedAudioPolicyAsSink(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return null;\n        }\n\n        if (mHeadsetClientService != null) {\n            return deviceProp.getHfAudioPolicyForRemoteAg();\n        } else {\n            Log.e(TAG, \"HeadsetClient not connected\");\n            return null;\n        }\n    }\n\n    /**\n     * Allow audio low latency\n     *\n     * @param allowed true if audio low latency is being allowed\n     * @param device device whose audio low latency will be allowed or disallowed\n     * @return boolean true if audio low latency is successfully allowed or disallowed\n     */\n    public boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n        return mNativeInterface.allowLowLatencyAudio(allowed, Utils.getByteAddress(device));\n    }\n\n    /**\n     * get remote PBAP PCE version.\n     *\n     * @param address of remote device\n     * @return int value other than 0 if remote PBAP PCE version is found\n     */\n    public int getRemotePbapPceVersion(String address) {\n        return mNativeInterface.getRemotePbapPceVersion(address);\n    }\n\n    /**\n     * check, if PBAP PSE dynamic version upgrade is enabled.\n     *\n     * @return true/false.\n     */\n    public boolean pbapPseDynamicVersionUpgradeIsEnabled() {\n        return mNativeInterface.pbapPseDynamicVersionUpgradeIsEnabled();\n    }\n\n    /** Sets the battery level of the remote device */\n    public void setBatteryLevel(BluetoothDevice device, int batteryLevel, boolean isBas) {\n        if (batteryLevel == BATTERY_LEVEL_UNKNOWN) {\n            mRemoteDevices.resetBatteryLevel(device, isBas);\n        } else {\n            mRemoteDevices.updateBatteryLevel(device, batteryLevel, isBas);\n        }\n    }\n\n    public boolean interopMatchAddr(InteropFeature feature, String address) {\n        return mNativeInterface.interopMatchAddr(feature.name(), address);\n    }\n\n    public boolean interopMatchName(InteropFeature feature, String name) {\n        return mNativeInterface.interopMatchName(feature.name(), name);\n    }\n\n    public boolean interopMatchAddrOrName(InteropFeature feature, String address) {\n        return mNativeInterface.interopMatchAddrOrName(feature.name(), address);\n    }\n\n    public void interopDatabaseAddAddr(InteropFeature feature, String address, int length) {\n        mNativeInterface.interopDatabaseAddRemoveAddr(true, feature.name(), address, length);\n    }\n\n    public void interopDatabaseRemoveAddr(InteropFeature feature, String address) {\n        mNativeInterface.interopDatabaseAddRemoveAddr(false, feature.name(), address, 0);\n    }\n\n    public void interopDatabaseAddName(InteropFeature feature, String name) {\n        mNativeInterface.interopDatabaseAddRemoveName(true, feature.name(), name);\n    }\n\n    public void interopDatabaseRemoveName(InteropFeature feature, String name) {\n        mNativeInterface.interopDatabaseAddRemoveName(false, feature.name(), name);\n    }\n\n    /**\n     * Checks the remote device is in the LE Audio allow list or not.\n     *\n     * @param device the device to check\n     * @return boolean true if the device is in the allow list, false otherwise.\n     */\n    public boolean isLeAudioAllowed(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n\n        if (deviceProp == null\n                || deviceProp.getModelName() == null\n                || !mLeAudioAllowDevices.contains(deviceProp.getModelName())) {\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get type of the remote device\n     *\n     * @param device the device to check\n     * @return int device type\n     */\n    public int getRemoteType(BluetoothDevice device) {\n        return mRemoteDevices.getType(device);\n    }\n\n    /**\n     * Sends service discovery UUIDs internally within the stack. This is meant to remove internal\n     * dependencies on the broadcast {@link BluetoothDevice#ACTION_UUID}.\n     *\n     * @param device is the remote device whose UUIDs have been discovered\n     * @param uuids are the services supported on the remote device\n     */\n    void sendUuidsInternal(BluetoothDevice device, ParcelUuid[] uuids) {\n        if (device == null) {\n            Log.w(TAG, \"sendUuidsInternal: null device\");\n            return;\n        }\n        if (uuids == null) {\n            Log.w(TAG, \"sendUuidsInternal: uuids is null\");\n            return;\n        }\n        Log.i(TAG, \"sendUuidsInternal: Received service discovery UUIDs for device \" + device);\n        for (int i = 0; i < uuids.length; i++) {\n            Log.d(TAG, \"sendUuidsInternal: index=\" + i + \" uuid=\" + uuids[i]);\n        }\n        if (mPhonePolicy != null) {\n            mPhonePolicy.onUuidsDiscovered(device, uuids);\n        }\n    }\n}\n```",
                                    "upstream_file_tokens": {
                                        "openai": 55948,
                                        "general": {
                                            "word_based": 19367,
                                            "char_based": 74792
                                        },
                                        "gemini": 65821
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.bluetooth.btservice;\n\nimport static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\nimport static android.text.format.DateUtils.MINUTE_IN_MILLIS;\nimport static android.text.format.DateUtils.SECOND_IN_MILLIS;\n\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveOrManagedUser;\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveUser;\nimport static com.android.bluetooth.Utils.enforceBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.enforceCdmAssociation;\nimport static com.android.bluetooth.Utils.enforceDumpPermission;\nimport static com.android.bluetooth.Utils.enforceLocalMacAddressPermission;\nimport static com.android.bluetooth.Utils.getBytesFromAddress;\nimport static com.android.bluetooth.Utils.hasBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.isPackageNameAccurate;\n\nimport android.annotation.NonNull;\nimport android.annotation.RequiresPermission;\nimport android.annotation.SuppressLint;\nimport android.app.AlarmManager;\nimport android.app.AppOpsManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.app.admin.DevicePolicyManager;\nimport android.bluetooth.BluetoothA2dp;\nimport android.bluetooth.BluetoothActivityEnergyInfo;\nimport android.bluetooth.BluetoothAdapter;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceProfile;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceUse;\nimport android.bluetooth.BluetoothClass;\nimport android.bluetooth.BluetoothDevice;\nimport android.bluetooth.BluetoothFrameworkInitializer;\nimport android.bluetooth.BluetoothMap;\nimport android.bluetooth.BluetoothProfile;\nimport android.bluetooth.BluetoothProtoEnums;\nimport android.bluetooth.BluetoothSap;\nimport android.bluetooth.BluetoothServerSocket;\nimport android.bluetooth.BluetoothSocket;\nimport android.bluetooth.BluetoothStatusCodes;\nimport android.bluetooth.BluetoothUuid;\nimport android.bluetooth.BufferConstraints;\nimport android.bluetooth.IBluetooth;\nimport android.bluetooth.IBluetoothActivityEnergyInfoListener;\nimport android.bluetooth.IBluetoothCallback;\nimport android.bluetooth.IBluetoothConnectionCallback;\nimport android.bluetooth.IBluetoothMetadataListener;\nimport android.bluetooth.IBluetoothOobDataCallback;\nimport android.bluetooth.IBluetoothSocketManager;\nimport android.bluetooth.IncomingRfcommSocketInfo;\nimport android.bluetooth.OobData;\nimport android.bluetooth.UidTraffic;\nimport android.companion.CompanionDeviceManager;\nimport android.content.AttributionSource;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.os.AsyncTask;\nimport android.os.BatteryStatsManager;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelUuid;\nimport android.os.PowerManager;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.DeviceConfig;\nimport android.provider.Settings;\nimport android.sysprop.BluetoothProperties;\nimport android.text.TextUtils;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.util.SparseArray;\n\nimport com.android.bluetooth.BluetoothMetricsProto;\nimport com.android.bluetooth.BluetoothStatsLog;\nimport com.android.bluetooth.R;\nimport com.android.bluetooth.Utils;\nimport com.android.bluetooth.a2dp.A2dpService;\nimport com.android.bluetooth.a2dpsink.A2dpSinkService;\nimport com.android.bluetooth.bas.BatteryService;\nimport com.android.bluetooth.bass_client.BassClientService;\nimport com.android.bluetooth.btservice.RemoteDevices.DeviceProperties;\nimport com.android.bluetooth.btservice.activityattribution.ActivityAttributionService;\nimport com.android.bluetooth.btservice.bluetoothkeystore.BluetoothKeystoreService;\nimport com.android.bluetooth.btservice.storage.DatabaseManager;\nimport com.android.bluetooth.btservice.storage.MetadataDatabase;\nimport com.android.bluetooth.csip.CsipSetCoordinatorService;\nimport com.android.bluetooth.gatt.GattService;\nimport com.android.bluetooth.gatt.ScanManager;\nimport com.android.bluetooth.hap.HapClientService;\nimport com.android.bluetooth.hearingaid.HearingAidService;\nimport com.android.bluetooth.hfp.HeadsetService;\nimport com.android.bluetooth.hfpclient.HeadsetClientService;\nimport com.android.bluetooth.hid.HidDeviceService;\nimport com.android.bluetooth.hid.HidHostService;\nimport com.android.bluetooth.le_audio.LeAudioService;\nimport com.android.bluetooth.map.BluetoothMapService;\nimport com.android.bluetooth.mapclient.MapClientService;\nimport com.android.bluetooth.pan.PanService;\nimport com.android.bluetooth.pbap.BluetoothPbapService;\nimport com.android.bluetooth.pbapclient.PbapClientService;\nimport com.android.bluetooth.sap.SapService;\nimport com.android.bluetooth.sdp.SdpManager;\nimport com.android.bluetooth.telephony.BluetoothInCallService;\nimport com.android.bluetooth.vc.VolumeControlService;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.modules.utils.BackgroundThread;\nimport com.android.modules.utils.BytesMatcher;\nimport com.android.modules.utils.SynchronousResultReceiver;\n\nimport com.google.protobuf.InvalidProtocolBufferException;\n\nimport libcore.util.SneakyThrow;\n\nimport java.io.FileDescriptor;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.time.Duration;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.function.Predicate;\nimport java.util.regex.Pattern;\n\npublic class AdapterService extends Service {\n    private static final String TAG = \"BluetoothAdapterService\";\n    private static final boolean DBG = true;\n    private static final boolean VERBOSE = false;\n    private static final int MIN_ADVT_INSTANCES_FOR_MA = 5;\n    private static final int MIN_OFFLOADED_FILTERS = 10;\n    private static final int MIN_OFFLOADED_SCAN_STORAGE_BYTES = 1024;\n    private static final Duration PENDING_SOCKET_HANDOFF_TIMEOUT = Duration.ofMinutes(1);\n\n    private final Object mEnergyInfoLock = new Object();\n    private int mStackReportedState;\n    private long mTxTimeTotalMs;\n    private long mRxTimeTotalMs;\n    private long mIdleTimeTotalMs;\n    private long mEnergyUsedTotalVoltAmpSecMicro;\n    private final SparseArray<UidTraffic> mUidTraffic = new SparseArray<>();\n\n    private final ArrayList<String> mStartedProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRegisteredProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRunningProfiles = new ArrayList<>();\n\n    public static final String ACTION_LOAD_ADAPTER_PROPERTIES =\n            \"com.android.bluetooth.btservice.action.LOAD_ADAPTER_PROPERTIES\";\n    public static final String ACTION_SERVICE_STATE_CHANGED =\n            \"com.android.bluetooth.btservice.action.STATE_CHANGED\";\n    public static final String EXTRA_ACTION = \"action\";\n    public static final int PROFILE_CONN_REJECTED = 2;\n\n    private static final String ACTION_ALARM_WAKEUP =\n            \"com.android.bluetooth.btservice.action.ALARM_WAKEUP\";\n\n    static final String BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY = \"persist.bluetooth.btsnooplogmode\";\n    static final String BLUETOOTH_BTSNOOP_DEFAULT_MODE_PROPERTY =\n            \"persist.bluetooth.btsnoopdefaultmode\";\n    private String mSnoopLogSettingAtEnable = \"empty\";\n    private String mDefaultSnoopLogSettingAtEnable = \"empty\";\n\n    public static final String BLUETOOTH_PRIVILEGED =\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED;\n    static final String BLUETOOTH_PERM = android.Manifest.permission.BLUETOOTH;\n    static final String LOCAL_MAC_ADDRESS_PERM = android.Manifest.permission.LOCAL_MAC_ADDRESS;\n    static final String RECEIVE_MAP_PERM = android.Manifest.permission.RECEIVE_BLUETOOTH_MAP;\n\n    private static final String PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"phonebook_access_permission\";\n    private static final String MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"message_access_permission\";\n    private static final String SIM_ACCESS_PERMISSION_PREFERENCE_FILE = \"sim_access_permission\";\n\n    private static final int CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS = 30;\n\n    public static final String ACTIVITY_ATTRIBUTION_NO_ACTIVE_DEVICE_ADDRESS =\n            \"no_active_device_address\";\n\n    // Report ID definition\n    public enum BqrQualityReportId {\n        QUALITY_REPORT_ID_MONITOR_MODE(0x01),\n        QUALITY_REPORT_ID_APPROACH_LSTO(0x02),\n        QUALITY_REPORT_ID_A2DP_AUDIO_CHOPPY(0x03),\n        QUALITY_REPORT_ID_SCO_VOICE_CHOPPY(0x04),\n        QUALITY_REPORT_ID_ROOT_INFLAMMATION(0x05),\n        QUALITY_REPORT_ID_LMP_LL_MESSAGE_TRACE(0x11),\n        QUALITY_REPORT_ID_BT_SCHEDULING_TRACE(0x12),\n        QUALITY_REPORT_ID_CONTROLLER_DBG_INFO(0x13);\n\n        private final int value;\n        private BqrQualityReportId(int value) {\n            this.value = value;\n        }\n        public int getValue() {\n            return value;\n        }\n    };\n\n    private final ArrayList<DiscoveringPackage> mDiscoveringPackages = new ArrayList<>();\n\n    static {\n        classInitNative();\n    }\n\n    private static AdapterService sAdapterService;\n\n    public static synchronized AdapterService getAdapterService() {\n        return sAdapterService;\n    }\n\n    private static synchronized void setAdapterService(AdapterService instance) {\n        Log.d(TAG, \"setAdapterService() - trying to set service to \" + instance);\n        if (instance == null) {\n            return;\n        }\n        sAdapterService = instance;\n    }\n\n    private static synchronized void clearAdapterService(AdapterService current) {\n        if (sAdapterService == current) {\n            sAdapterService = null;\n        }\n    }\n\n    private BluetoothAdapter mAdapter;\n    private AdapterProperties mAdapterProperties;\n    private AdapterState mAdapterStateMachine;\n    private BondStateMachine mBondStateMachine;\n    private JniCallbacks mJniCallbacks;\n    private RemoteDevices mRemoteDevices;\n\n    /* TODO: Consider to remove the search API from this class, if changed to use call-back */\n    private SdpManager mSdpManager = null;\n\n    private boolean mNativeAvailable;\n    private boolean mCleaningUp;\n    private final HashMap<BluetoothDevice, ArrayList<IBluetoothMetadataListener>>\n            mMetadataListeners = new HashMap<>();\n    private final HashMap<String, Integer> mProfileServicesState = new HashMap<String, Integer>();\n    private Set<IBluetoothConnectionCallback> mBluetoothConnectionCallbacks = new HashSet<>();\n    //Only BluetoothManagerService should be registered\n    private RemoteCallbackList<IBluetoothCallback> mCallbacks;\n    private int mCurrentRequestId;\n    private boolean mQuietmode = false;\n    private HashMap<String, CallerInfo> mBondAttemptCallerInfo = new HashMap<>();\n\n    private final Map<UUID, RfcommListenerData> mBluetoothServerSockets = new ConcurrentHashMap<>();\n    private final Executor mSocketServersExecutor = r -> new Thread(r).start();\n\n    private AlarmManager mAlarmManager;\n    private PendingIntent mPendingAlarm;\n    private BatteryStatsManager mBatteryStatsManager;\n    private PowerManager mPowerManager;\n    private PowerManager.WakeLock mWakeLock;\n    private String mWakeLockName;\n    private UserManager mUserManager;\n    private CompanionDeviceManager mCompanionDeviceManager;\n\n    private PhonePolicy mPhonePolicy;\n    private ActiveDeviceManager mActiveDeviceManager;\n    private DatabaseManager mDatabaseManager;\n    private SilenceDeviceManager mSilenceDeviceManager;\n    private AppOpsManager mAppOps;\n\n    private BluetoothSocketManagerBinder mBluetoothSocketManagerBinder;\n\n    private BluetoothKeystoreService mBluetoothKeystoreService;\n    private A2dpService mA2dpService;\n    private A2dpSinkService mA2dpSinkService;\n    private ActivityAttributionService mActivityAttributionService;\n    private HeadsetService mHeadsetService;\n    private HeadsetClientService mHeadsetClientService;\n    private BluetoothMapService mMapService;\n    private MapClientService mMapClientService;\n    private HidDeviceService mHidDeviceService;\n    private HidHostService mHidHostService;\n    private PanService mPanService;\n    private BluetoothPbapService mPbapService;\n    private PbapClientService mPbapClientService;\n    private HearingAidService mHearingAidService;\n    private HapClientService mHapClientService;\n    private SapService mSapService;\n    private VolumeControlService mVolumeControlService;\n    private CsipSetCoordinatorService mCsipSetCoordinatorService;\n    private LeAudioService mLeAudioService;\n    private BassClientService mBassClientService;\n    private BatteryService mBatteryService;\n\n    private volatile boolean mTestModeEnabled = false;\n\n    private MetricsLogger mMetricsLogger;\n\n    /**\n     * Register a {@link ProfileService} with AdapterService.\n     *\n     * @param profile the service being added.\n     */\n    public void addProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_REGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Unregister a ProfileService with AdapterService.\n     *\n     * @param profile the service being removed.\n     */\n    public void removeProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_UNREGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Notify AdapterService that a ProfileService has started or stopped.\n     *\n     * @param profile the service being removed.\n     * @param state {@link BluetoothAdapter#STATE_ON} or {@link BluetoothAdapter#STATE_OFF}\n     */\n    public void onProfileServiceStateChanged(ProfileService profile, int state) {\n        if (state != BluetoothAdapter.STATE_ON && state != BluetoothAdapter.STATE_OFF) {\n            throw new IllegalArgumentException(BluetoothAdapter.nameForState(state));\n        }\n        Message m = mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_STATE_CHANGED);\n        m.obj = profile;\n        m.arg1 = state;\n        mHandler.sendMessage(m);\n    }\n\n    /**\n     * Confirm whether the ProfileService is started expectedly.\n     *\n     * @param serviceSampleName the service simple name.\n     * @return true if the service is started expectedly, false otherwise.\n     */\n    public boolean isStartedProfile(String serviceSampleName) {\n        return mStartedProfiles.contains(serviceSampleName);\n    }\n\n    private static final int MESSAGE_PROFILE_SERVICE_STATE_CHANGED = 1;\n    private static final int MESSAGE_PROFILE_SERVICE_REGISTERED = 2;\n    private static final int MESSAGE_PROFILE_SERVICE_UNREGISTERED = 3;\n\n    class AdapterServiceHandler extends Handler {\n        @Override\n        public void handleMessage(Message msg) {\n            verboseLog(\"handleMessage() - Message: \" + msg.what);\n\n            switch (msg.what) {\n                case MESSAGE_PROFILE_SERVICE_STATE_CHANGED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_STATE_CHANGED\");\n                    processProfileServiceStateChanged((ProfileService) msg.obj, msg.arg1);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_REGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_REGISTERED\");\n                    registerProfileService((ProfileService) msg.obj);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_UNREGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_UNREGISTERED\");\n                    unregisterProfileService((ProfileService) msg.obj);\n                    break;\n            }\n        }\n\n        private void registerProfileService(ProfileService profile) {\n            if (mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" already registered.\");\n                return;\n            }\n            mRegisteredProfiles.add(profile);\n        }\n\n        private void unregisterProfileService(ProfileService profile) {\n            if (!mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" not registered (UNREGISTER).\");\n                return;\n            }\n            mRegisteredProfiles.remove(profile);\n        }\n\n        private void processProfileServiceStateChanged(ProfileService profile, int state) {\n            switch (state) {\n                case BluetoothAdapter.STATE_ON:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_ON).\");\n                        return;\n                    }\n                    if (mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" already running.\");\n                        return;\n                    }\n                    mRunningProfiles.add(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT starting triggers hardware\n                    // initializtion. Configuring a device without GATT causes start up failures.\n                    if (GattService.class.getSimpleName().equals(profile.getName())) {\n                        enableNative();\n                    } else if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                            && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n                        mAdapterProperties.onBluetoothReady();\n                        updateUuids();\n                        setBluetoothClassFromConfig();\n                        initProfileServices();\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS_BLE);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_DYNAMIC_AUDIO_BUFFER);\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n                    }\n                    break;\n                case BluetoothAdapter.STATE_OFF:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_OFF).\");\n                        return;\n                    }\n                    if (!mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not running.\");\n                        return;\n                    }\n                    mRunningProfiles.remove(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT is expected to be the only\n                    // profile available in the \"BLE ON\" state. If only GATT is left, send\n                    // BREDR_STOPPED. If GATT is stopped, deinitialize the hardware.\n                    if ((mRunningProfiles.size() == 1 && (GattService.class.getSimpleName()\n                            .equals(mRunningProfiles.get(0).getName())))) {\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n                    } else if (mRunningProfiles.size() == 0) {\n                        disableNative();\n                    }\n                    break;\n                default:\n                    Log.e(TAG, \"Unhandled profile state: \" + state);\n            }\n        }\n    }\n\n    private final AdapterServiceHandler mHandler = new AdapterServiceHandler();\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        initMetricsLogger();\n        debugLog(\"onCreate()\");\n        mDeviceConfigListener.start();\n        mRemoteDevices = new RemoteDevices(this, Looper.getMainLooper());\n        mRemoteDevices.init();\n        clearDiscoveringPackages();\n        mBinder = new AdapterServiceBinder(this);\n        mAdapter = BluetoothAdapter.getDefaultAdapter();\n        mAdapterProperties = new AdapterProperties(this);\n        mAdapterStateMachine = AdapterState.make(this);\n        mJniCallbacks = new JniCallbacks(this, mAdapterProperties);\n        mBluetoothKeystoreService = new BluetoothKeystoreService(isCommonCriteriaMode());\n        mBluetoothKeystoreService.start();\n        int configCompareResult = mBluetoothKeystoreService.getCompareResult();\n\n        // Start tracking Binder latency for the bluetooth process.\n        BluetoothFrameworkInitializer.initializeBinderCallsStats(getApplicationContext());\n\n        // Android TV doesn't show consent dialogs for just works and encryption only le pairing\n        boolean isAtvDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_LEANBACK_ONLY);\n        mUserManager = getSystemService(UserManager.class);\n        initNative(mUserManager.isGuestUser(), isCommonCriteriaMode(), configCompareResult,\n                getInitFlags(), isAtvDevice, getApplicationInfo().dataDir);\n        mNativeAvailable = true;\n        mCallbacks = new RemoteCallbackList<IBluetoothCallback>();\n        mAppOps = getSystemService(AppOpsManager.class);\n        //Load the name and address\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDADDR);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDNAME);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_CLASS_OF_DEVICE);\n        mAlarmManager = getSystemService(AlarmManager.class);\n        mPowerManager = getSystemService(PowerManager.class);\n        mBatteryStatsManager = getSystemService(BatteryStatsManager.class);\n        mCompanionDeviceManager = getSystemService(CompanionDeviceManager.class);\n\n        mBluetoothKeystoreService.initJni();\n\n        mSdpManager = SdpManager.init(this);\n        registerReceiver(mAlarmBroadcastReceiver, new IntentFilter(ACTION_ALARM_WAKEUP));\n\n        mDatabaseManager = new DatabaseManager(this);\n        mDatabaseManager.start(MetadataDatabase.createDatabase(this));\n\n        boolean isAutomotiveDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_AUTOMOTIVE);\n\n        /*\n         * Phone policy is specific to phone implementations and hence if a device wants to exclude\n         * it out then it can be disabled by using the flag below. Phone policy is never used on\n         * Android Automotive OS builds, in favor of a policy currently located in\n         * CarBluetoothService.\n         */\n        if (!isAutomotiveDevice && getResources().getBoolean(R.bool.enable_phone_policy)) {\n            Log.i(TAG, \"Phone policy enabled\");\n            mPhonePolicy = new PhonePolicy(this, new ServiceFactory());\n            mPhonePolicy.start();\n        } else {\n            Log.i(TAG, \"Phone policy disabled\");\n        }\n\n        mActiveDeviceManager = new ActiveDeviceManager(this, new ServiceFactory());\n        mActiveDeviceManager.start();\n\n        mSilenceDeviceManager = new SilenceDeviceManager(this, new ServiceFactory(),\n                Looper.getMainLooper());\n        mSilenceDeviceManager.start();\n\n        mBluetoothSocketManagerBinder = new BluetoothSocketManagerBinder(this);\n\n        mActivityAttributionService = new ActivityAttributionService();\n        mActivityAttributionService.start();\n\n        setAdapterService(this);\n\n        invalidateBluetoothCaches();\n\n        // First call to getSharedPreferences will result in a file read into\n        // memory cache. Call it here asynchronously to avoid potential ANR\n        // in the future\n        new AsyncTask<Void, Void, Void>() {\n            @Override\n            protected Void doInBackground(Void... params) {\n                getSharedPreferences(PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(SIM_ACCESS_PERMISSION_PREFERENCE_FILE, Context.MODE_PRIVATE);\n                return null;\n            }\n        }.execute();\n\n        try {\n            int systemUiUid = getApplicationContext()\n                    .createContextAsUser(UserHandle.SYSTEM, /* flags= */ 0)\n                    .getPackageManager()\n                    .getPackageUid(\"com.android.systemui\", PackageManager.MATCH_SYSTEM_ONLY);\n\n            Utils.setSystemUiUid(systemUiUid);\n        } catch (PackageManager.NameNotFoundException e) {\n            // Some platforms, such as wearables do not have a system ui.\n            Log.w(TAG, \"Unable to resolve SystemUI's UID.\", e);\n        }\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        debugLog(\"onBind()\");\n        return mBinder;\n    }\n\n    @Override\n    public boolean onUnbind(Intent intent) {\n        debugLog(\"onUnbind() - calling cleanup\");\n        cleanup();\n        return super.onUnbind(intent);\n    }\n\n    @Override\n    public void onDestroy() {\n        debugLog(\"onDestroy()\");\n        if (!isMock()) {\n            // TODO(b/27859763)\n            Log.i(TAG, \"Force exit to cleanup internal state in Bluetooth stack\");\n            System.exit(0);\n        }\n    }\n\n    private boolean initMetricsLogger() {\n        if (mMetricsLogger != null) {\n            return false;\n        }\n        mMetricsLogger = MetricsLogger.getInstance();\n        return mMetricsLogger.init(this);\n    }\n\n    private boolean closeMetricsLogger() {\n        if (mMetricsLogger == null) {\n            return false;\n        }\n        boolean result = mMetricsLogger.close();\n        mMetricsLogger = null;\n        return result;\n    }\n\n    public void setMetricsLogger(MetricsLogger metricsLogger) {\n        mMetricsLogger = metricsLogger;\n    }\n\n    void bringUpBle() {\n        debugLog(\"bleOnProcessStart()\");\n\n        if (getResources().getBoolean(\n                R.bool.config_bluetooth_reload_supported_profiles_when_enabled)) {\n            Config.init(getApplicationContext());\n        }\n\n        // Reset |mRemoteDevices| whenever BLE is turned off then on\n        // This is to replace the fact that |mRemoteDevices| was\n        // reinitialized in previous code.\n        //\n        // TODO(apanicke): The reason is unclear but\n        // I believe it is to clear the variable every time BLE was\n        // turned off then on. The same effect can be achieved by\n        // calling cleanup but this may not be necessary at all\n        // We should figure out why this is needed later\n        mRemoteDevices.reset();\n        mAdapterProperties.init(mRemoteDevices);\n\n        debugLog(\"bleOnProcessStart() - Make Bond State Machine\");\n        mBondStateMachine = BondStateMachine.make(this, mAdapterProperties, mRemoteDevices);\n\n        mJniCallbacks.init(mBondStateMachine, mRemoteDevices);\n\n        mBatteryStatsManager.reportBleScanReset();\n        BluetoothStatsLog.write_non_chained(BluetoothStatsLog.BLE_SCAN_STATE_CHANGED, -1, null,\n                BluetoothStatsLog.BLE_SCAN_STATE_CHANGED__STATE__RESET, false, false, false);\n\n        // TODO(b/228875190): GATT is assumed supported. As a result, we don't respect the\n        // configuration sysprop. Configuring a device without GATT, although rare, will cause stack\n        // start up errors yielding init loops.\n        if (!GattService.isEnabled()) {\n            Log.w(TAG,\n                    \"GATT is configured off but the stack assumes it to be enabled. Start anyway.\");\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_ON);\n    }\n\n    void bringDownBle() {\n        stopGattProfileService();\n    }\n\n    void stateChangeCallback(int status) {\n        if (status == AbstractionLayer.BT_STATE_OFF) {\n            debugLog(\"stateChangeCallback: disableNative() completed\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        } else if (status == AbstractionLayer.BT_STATE_ON) {\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STARTED);\n        } else {\n            Log.e(TAG, \"Incorrect status \" + status + \" in stateChangeCallback\");\n        }\n    }\n\n    /**\n     * Sets the Bluetooth CoD value of the local adapter if there exists a config value for it.\n     */\n    void setBluetoothClassFromConfig() {\n        int bluetoothClassConfig = retrieveBluetoothClassConfig();\n        if (bluetoothClassConfig != 0) {\n            mAdapterProperties.setBluetoothClass(new BluetoothClass(bluetoothClassConfig));\n        }\n    }\n\n    private int retrieveBluetoothClassConfig() {\n        return Settings.Global.getInt(\n                getContentResolver(), Settings.Global.BLUETOOTH_CLASS_OF_DEVICE, 0);\n    }\n\n    void startProfileServices() {\n        debugLog(\"startCoreServices()\");\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no other profiles then just\n        // move on to BREDR_STARTED. Note that configuring GATT to NOT supported will cause adapter\n        // initialization failures\n        if (supportedProfileServices.length == 1 && GattService.class.getSimpleName()\n                .equals(supportedProfileServices[0].getSimpleName())) {\n            mAdapterProperties.onBluetoothReady();\n            updateUuids();\n            setBluetoothClassFromConfig();\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_ON);\n        }\n    }\n\n    void stopProfileServices() {\n        // Make sure to stop classic background tasks now\n        cancelDiscoveryNative();\n        mAdapterProperties.setScanMode(AbstractionLayer.BT_SCAN_MODE_NONE);\n\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no profiles then just move on\n        // to BREDR_STOPPED\n        if (supportedProfileServices.length == 1 && (mRunningProfiles.size() == 1\n                && GattService.class.getSimpleName().equals(mRunningProfiles.get(0).getName()))) {\n            debugLog(\"stopProfileServices() - No profiles services to stop or already stopped.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_OFF);\n        }\n    }\n\n    private void stopGattProfileService() {\n        mAdapterProperties.onBleDisable();\n        if (mRunningProfiles.size() == 0) {\n            debugLog(\"stopGattProfileService() - No profiles services to stop.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_OFF);\n    }\n\n    private void invalidateBluetoothGetStateCache() {\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n    }\n\n    void updateLeAudioProfileServiceState() {\n        HashSet<Class> nonSupportedProfiles = new HashSet<>();\n\n        if (!isLeConnectedIsochronousStreamCentralSupported()) {\n            nonSupportedProfiles.addAll(Config.geLeAudioUnicastProfiles());\n        }\n\n        if (!isLeAudioBroadcastAssistantSupported()) {\n            nonSupportedProfiles.add(BassClientService.class);\n        }\n\n        if (isLeAudioBroadcastSourceSupported()) {\n            Config.addSupportedProfile(BluetoothProfile.LE_AUDIO_BROADCAST);\n        }\n\n        if (!nonSupportedProfiles.isEmpty()) {\n            // Remove non-supported profiles from the supported list\n            // since the controller doesn't support\n            Config.removeProfileFromSupportedList(nonSupportedProfiles);\n\n            // Disable the non-supported profiles service\n            for (Class profileService : nonSupportedProfiles) {\n                if (isStartedProfile(profileService.getSimpleName())) {\n                    setProfileServiceState(profileService, BluetoothAdapter.STATE_OFF);\n                }\n            }\n        }\n    }\n\n    void updateAdapterState(int prevState, int newState) {\n        mAdapterProperties.setState(newState);\n        invalidateBluetoothGetStateCache();\n        if (mCallbacks != null) {\n            int n = mCallbacks.beginBroadcast();\n            debugLog(\"updateAdapterState() - Broadcasting state \" + BluetoothAdapter.nameForState(\n                    newState) + \" to \" + n + \" receivers.\");\n            for (int i = 0; i < n; i++) {\n                try {\n                    mCallbacks.getBroadcastItem(i).onBluetoothStateChange(prevState, newState);\n                } catch (RemoteException e) {\n                    debugLog(\"updateAdapterState() - Callback #\" + i + \" failed (\" + e + \")\");\n                }\n            }\n            mCallbacks.finishBroadcast();\n        }\n\n        // Turn the Adapter all the way off if we are disabling and the snoop log setting changed.\n        if (newState == BluetoothAdapter.STATE_BLE_TURNING_ON) {\n            mSnoopLogSettingAtEnable =\n                    SystemProperties.get(BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY, \"empty\");\n            mDefaultSnoopLogSettingAtEnable =\n                    Settings.Global.getString(getContentResolver(),\n                            Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n            BluetoothProperties.snoop_default_mode(\n                    BluetoothProperties.snoop_default_mode_values.DISABLED);\n            for (BluetoothProperties.snoop_default_mode_values value :\n                    BluetoothProperties.snoop_default_mode_values.values()) {\n                if (value.getPropValue().equals(mDefaultSnoopLogSettingAtEnable)) {\n                    BluetoothProperties.snoop_default_mode(value);\n                }\n            }\n        } else if (newState == BluetoothAdapter.STATE_BLE_ON\n                   && prevState != BluetoothAdapter.STATE_OFF) {\n            String snoopLogSetting =\n                    SystemProperties.get(BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY, \"empty\");\n            String snoopDefaultModeSetting =\n                    Settings.Global.getString(getContentResolver(),\n                            Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n\n            if (!TextUtils.equals(mSnoopLogSettingAtEnable, snoopLogSetting)\n                    || !TextUtils.equals(mDefaultSnoopLogSettingAtEnable,\n                            snoopDefaultModeSetting)) {\n                mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n            }\n        }\n    }\n\n    void linkQualityReportCallback(\n            long timestamp,\n            int reportId,\n            int rssi,\n            int snr,\n            int retransmissionCount,\n            int packetsNotReceiveCount,\n            int negativeAcknowledgementCount) {\n        BluetoothInCallService bluetoothInCallService = BluetoothInCallService.getInstance();\n\n        if (reportId == BqrQualityReportId.QUALITY_REPORT_ID_SCO_VOICE_CHOPPY.getValue()) {\n            if (bluetoothInCallService == null) {\n                Log.w(TAG, \"No BluetoothInCallService while trying to send BQR.\"\n                        + \" timestamp: \" + timestamp + \" reportId: \" + reportId\n                        + \" rssi: \" + rssi + \" snr: \" + snr\n                        + \" retransmissionCount: \" + retransmissionCount\n                        + \" packetsNotReceiveCount: \" + packetsNotReceiveCount\n                        + \" negativeAcknowledgementCount: \" + negativeAcknowledgementCount);\n                return;\n            }\n            bluetoothInCallService.sendBluetoothCallQualityReport(\n                    timestamp, rssi, snr, retransmissionCount,\n                    packetsNotReceiveCount, negativeAcknowledgementCount);\n        }\n    }\n\n    void switchBufferSizeCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            errorLog(\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n        }\n\n        // Send intent to fastpair\n        Intent switchBufferSizeIntent = new Intent(BluetoothDevice.ACTION_SWITCH_BUFFER_SIZE);\n        switchBufferSizeIntent.setClassName(\n                getString(com.android.bluetooth.R.string.peripheral_link_package),\n                getString(com.android.bluetooth.R.string.peripheral_link_package)\n                        + getString(com.android.bluetooth.R.string.peripheral_link_service));\n        switchBufferSizeIntent.putExtra(BluetoothDevice.EXTRA_DEVICE, activeDevices.get(0));\n        switchBufferSizeIntent.putExtra(\n                BluetoothDevice.EXTRA_LOW_LATENCY_BUFFER_SIZE, isLowLatencyBufferSize);\n        sendBroadcast(switchBufferSizeIntent);\n    }\n\n    void switchCodecCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            errorLog(\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n            return;\n        }\n        mA2dpService.switchCodecByBufferSize(activeDevices.get(0), isLowLatencyBufferSize);\n    }\n\n    void cleanup() {\n        debugLog(\"cleanup()\");\n        if (mCleaningUp) {\n            errorLog(\"cleanup() - Service already starting to cleanup, ignoring request...\");\n            return;\n        }\n\n        closeMetricsLogger();\n\n        clearAdapterService(this);\n\n        mCleaningUp = true;\n        invalidateBluetoothCaches();\n\n        unregisterReceiver(mAlarmBroadcastReceiver);\n\n        stopRfcommServerSockets();\n\n        if (mPendingAlarm != null) {\n            mAlarmManager.cancel(mPendingAlarm);\n            mPendingAlarm = null;\n        }\n\n        // This wake lock release may also be called concurrently by\n        // {@link #releaseWakeLock(String lockName)}, so a synchronization is needed here.\n        synchronized (this) {\n            if (mWakeLock != null) {\n                if (mWakeLock.isHeld()) {\n                    mWakeLock.release();\n                }\n                mWakeLock = null;\n            }\n        }\n\n        if (mDatabaseManager != null) {\n            mDatabaseManager.cleanup();\n        }\n\n        if (mAdapterStateMachine != null) {\n            mAdapterStateMachine.doQuit();\n        }\n\n        if (mBondStateMachine != null) {\n            mBondStateMachine.doQuit();\n        }\n\n        if (mRemoteDevices != null) {\n            mRemoteDevices.cleanup();\n        }\n\n        if (mSdpManager != null) {\n            mSdpManager.cleanup();\n            mSdpManager = null;\n        }\n\n        if (mActivityAttributionService != null) {\n            mActivityAttributionService.cleanup();\n        }\n\n        if (mNativeAvailable) {\n            debugLog(\"cleanup() - Cleaning up adapter native\");\n            cleanupNative();\n            mNativeAvailable = false;\n        }\n\n        if (mAdapterProperties != null) {\n            mAdapterProperties.cleanup();\n        }\n\n        if (mJniCallbacks != null) {\n            mJniCallbacks.cleanup();\n        }\n\n        if (mBluetoothKeystoreService != null) {\n            debugLog(\"cleanup(): mBluetoothKeystoreService.cleanup()\");\n            mBluetoothKeystoreService.cleanup();\n        }\n\n        if (mPhonePolicy != null) {\n            mPhonePolicy.cleanup();\n        }\n\n        if (mSilenceDeviceManager != null) {\n            mSilenceDeviceManager.cleanup();\n        }\n\n        if (mActiveDeviceManager != null) {\n            mActiveDeviceManager.cleanup();\n        }\n\n        if (mProfileServicesState != null) {\n            mProfileServicesState.clear();\n        }\n\n        if (mBluetoothSocketManagerBinder != null) {\n            mBluetoothSocketManagerBinder.cleanUp();\n            mBluetoothSocketManagerBinder = null;\n        }\n\n        if (mBinder != null) {\n            mBinder.cleanup();\n            mBinder = null;  //Do not remove. Otherwise Binder leak!\n        }\n\n        if (mCallbacks != null) {\n            mCallbacks.kill();\n        }\n    }\n\n    private void invalidateBluetoothCaches() {\n        BluetoothAdapter.invalidateGetProfileConnectionStateCache();\n        BluetoothAdapter.invalidateIsOffloadedFilteringSupportedCache();\n        BluetoothDevice.invalidateBluetoothGetBondStateCache();\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n        BluetoothAdapter.invalidateGetAdapterConnectionStateCache();\n        BluetoothMap.invalidateBluetoothGetConnectionStateCache();\n        BluetoothSap.invalidateBluetoothGetConnectionStateCache();\n    }\n\n    private void setProfileServiceState(Class service, int state) {\n        if (state == BluetoothAdapter.STATE_ON) {\n            mStartedProfiles.add(service.getSimpleName());\n        } else if (state == BluetoothAdapter.STATE_OFF) {\n            mStartedProfiles.remove(service.getSimpleName());\n        }\n        Intent intent = new Intent(this, service);\n        intent.putExtra(EXTRA_ACTION, ACTION_SERVICE_STATE_CHANGED);\n        intent.putExtra(BluetoothAdapter.EXTRA_STATE, state);\n        startService(intent);\n    }\n\n    private void setAllProfileServiceStates(Class[] services, int state) {\n        for (Class service : services) {\n            // TODO(b/228875190): GATT is assumed supported and treated differently as part of the\n            // \"BLE ON\" state, despite GATT not being BLE specific.\n            if (GattService.class.getSimpleName().equals(service.getSimpleName())) {\n                continue;\n            }\n            setProfileServiceState(service, state);\n        }\n    }\n\n    /**\n     * Verifies whether the profile is supported by the local bluetooth adapter by checking a\n     * bitmask of its supported profiles\n     *\n     * @param remoteDeviceUuids is an array of all supported profiles by the remote device\n     * @param localDeviceUuids  is an array of all supported profiles by the local device\n     * @param profile           is the profile we are checking for support\n     * @param device            is the remote device we wish to connect to\n     * @return true if the profile is supported by both the local and remote device, false otherwise\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    private boolean isSupported(ParcelUuid[] localDeviceUuids, ParcelUuid[] remoteDeviceUuids,\n            int profile, BluetoothDevice device) {\n        if (remoteDeviceUuids == null || remoteDeviceUuids.length == 0) {\n            Log.e(TAG, \"isSupported: Remote Device Uuids Empty\");\n        }\n\n        if (profile == BluetoothProfile.HEADSET) {\n            return (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HSP_AG)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HSP))\n                    || (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP_AG)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP));\n        }\n        if (profile == BluetoothProfile.HEADSET_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP_AG)\n                    && Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP);\n        }\n        if (profile == BluetoothProfile.A2DP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SINK);\n        }\n        if (profile == BluetoothProfile.A2DP_SINK) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SOURCE);\n        }\n        if (profile == BluetoothProfile.OPP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.OBEX_OBJECT_PUSH);\n        }\n        if (profile == BluetoothProfile.HID_HOST) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HID)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HOGP);\n        }\n        if (profile == BluetoothProfile.HID_DEVICE) {\n            return mHidDeviceService.getConnectionState(device)\n                    == BluetoothProfile.STATE_DISCONNECTED;\n        }\n        if (profile == BluetoothProfile.PAN) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.NAP);\n        }\n        if (profile == BluetoothProfile.MAP) {\n            return mMapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.PBAP) {\n            return mPbapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.MAP_CLIENT) {\n            return true;\n        }\n        if (profile == BluetoothProfile.PBAP_CLIENT) {\n            return Utils.arrayContains(localDeviceUuids, BluetoothUuid.PBAP_PCE)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.PBAP_PSE);\n        }\n        if (profile == BluetoothProfile.HEARING_AID) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HEARING_AID);\n        }\n        if (profile == BluetoothProfile.SAP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.SAP);\n        }\n        if (profile == BluetoothProfile.VOLUME_CONTROL) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.VOLUME_CONTROL);\n        }\n        if (profile == BluetoothProfile.CSIP_SET_COORDINATOR) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.COORDINATED_SET);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.LE_AUDIO);\n        }\n        if (profile == BluetoothProfile.HAP_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HAS);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BASS);\n        }\n        if (profile == BluetoothProfile.BATTERY) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BATTERY);\n        }\n\n        Log.e(TAG, \"isSupported: Unexpected profile passed in to function: \" + profile);\n        return false;\n    }\n\n    /**\n     * Checks if any profile is enabled for the given device\n     *\n     * @param device is the device for which we are checking if any profiles are enabled\n     * @return true if any profile is enabled, false otherwise\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    boolean isAnyProfileEnabled(BluetoothDevice device) {\n        if (mA2dpService != null && mA2dpService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mA2dpSinkService != null && mA2dpSinkService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHeadsetService != null && mHeadsetService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHeadsetClientService != null && mHeadsetClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mMapClientService != null && mMapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHidHostService != null && mHidHostService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mPanService != null && mPanService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mPbapClientService != null && mPbapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHearingAidService != null && mHearingAidService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHapClientService != null && mHapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mVolumeControlService != null && mVolumeControlService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mCsipSetCoordinatorService != null\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mLeAudioService != null && mLeAudioService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mBassClientService != null && mBassClientService.getConnectionPolicy(device)\n                 > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mBatteryService != null && mBatteryService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Connects only available profiles\n     * (those with {@link BluetoothProfile#CONNECTION_POLICY_ALLOWED})\n     *\n     * @param device is the device with which we are connecting the profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS}\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    private int connectEnabledProfiles(BluetoothDevice device) {\n        ParcelUuid[] remoteDeviceUuids = getRemoteUuids(device);\n        ParcelUuid[] localDeviceUuids = mAdapterProperties.getUuids();\n\n        if (mA2dpService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP, device) && mA2dpService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp\");\n            mA2dpService.connect(device);\n        }\n        if (mA2dpSinkService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP_SINK, device) && mA2dpSinkService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.connect(device);\n        }\n        if (mHeadsetService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET, device) && mHeadsetService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Headset Profile\");\n            mHeadsetService.connect(device);\n        }\n        if (mHeadsetClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET_CLIENT, device)\n                && mHeadsetClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HFP\");\n            mHeadsetClientService.connect(device);\n        }\n        if (mMapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.MAP_CLIENT, device)\n                && mMapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting MAP\");\n            mMapClientService.connect(device);\n        }\n        if (mHidHostService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HID_HOST, device) && mHidHostService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hid Host Profile\");\n            mHidHostService.connect(device);\n        }\n        if (mPanService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PAN, device) && mPanService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pan Profile\");\n            mPanService.connect(device);\n        }\n        if (mPbapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PBAP_CLIENT, device)\n                && mPbapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pbap\");\n            mPbapClientService.connect(device);\n        }\n        if (mHearingAidService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEARING_AID, device)\n                && mHearingAidService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hearing Aid Profile\");\n            mHearingAidService.connect(device);\n        }\n        if (mHapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HAP_CLIENT, device)\n                && mHapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HAS Profile\");\n            mHapClientService.connect(device);\n        }\n        if (mVolumeControlService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.VOLUME_CONTROL, device)\n                && mVolumeControlService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.connect(device);\n        }\n        if (mCsipSetCoordinatorService != null\n                && isSupported(localDeviceUuids, remoteDeviceUuids,\n                        BluetoothProfile.CSIP_SET_COORDINATOR, device)\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.connect(device);\n        }\n        if (mLeAudioService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO, device)\n                && mLeAudioService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.connect(device);\n        }\n        if (mBassClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT, device)\n                && mBassClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.connect(device);\n        }\n        if (mBatteryService != null\n                && isSupported(\n                        localDeviceUuids, remoteDeviceUuids, BluetoothProfile.BATTERY, device)\n                && mBatteryService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Battery Service\");\n            mBatteryService.connect(device);\n        }\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Verifies that all bluetooth profile services are running\n     *\n     * @return true if all bluetooth profile services running, false otherwise\n     */\n    private boolean profileServicesRunning() {\n        if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n            return true;\n        }\n\n        Log.e(TAG, \"profileServicesRunning: One or more supported services not running\");\n        return false;\n    }\n\n    /**\n     * Initializes all the profile services fields\n     */\n    private void initProfileServices() {\n        Log.i(TAG, \"initProfileServices: Initializing all bluetooth profile services\");\n        mA2dpService = A2dpService.getA2dpService();\n        mA2dpSinkService = A2dpSinkService.getA2dpSinkService();\n        mHeadsetService = HeadsetService.getHeadsetService();\n        mHeadsetClientService = HeadsetClientService.getHeadsetClientService();\n        mMapService = BluetoothMapService.getBluetoothMapService();\n        mMapClientService = MapClientService.getMapClientService();\n        mHidDeviceService = HidDeviceService.getHidDeviceService();\n        mHidHostService = HidHostService.getHidHostService();\n        mPanService = PanService.getPanService();\n        mPbapService = BluetoothPbapService.getBluetoothPbapService();\n        mPbapClientService = PbapClientService.getPbapClientService();\n        mHearingAidService = HearingAidService.getHearingAidService();\n        mHapClientService = HapClientService.getHapClientService();\n        mSapService = SapService.getSapService();\n        mVolumeControlService = VolumeControlService.getVolumeControlService();\n        mCsipSetCoordinatorService = CsipSetCoordinatorService.getCsipSetCoordinatorService();\n        mLeAudioService = LeAudioService.getLeAudioService();\n        mBassClientService = BassClientService.getBassClientService();\n        mBatteryService = BatteryService.getBatteryService();\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    private int startRfcommListener(\n            String name,\n            ParcelUuid uuid,\n            PendingIntent pendingIntent,\n            AttributionSource attributionSource) {\n        if (mBluetoothServerSockets.containsKey(uuid.getUuid())) {\n            Log.d(TAG, String.format(\n                        \"Cannot start RFCOMM listener: UUID %s already in use.\", uuid.getUuid()));\n            return BluetoothStatusCodes.RFCOMM_LISTENER_START_FAILED_UUID_IN_USE;\n        }\n\n        try {\n            startRfcommListenerInternal(name, uuid.getUuid(), pendingIntent, attributionSource);\n        } catch (IOException e) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CREATE_SERVER_SOCKET;\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    private int stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            Log.d(TAG, String.format(\n                        \"Cannot stop RFCOMM listener: UUID %s is not registered.\", uuid.getUuid()));\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n        }\n\n        if (attributionSource.getUid() != listenerData.mAttributionSource.getUid()) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n        }\n\n        // Remove the entry so that it does not try and restart the server socket.\n        mBluetoothServerSockets.remove(uuid.getUuid());\n\n        return listenerData.closeServerAndPendingSockets(mHandler);\n    }\n\n    private IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n            ParcelUuid uuid, AttributionSource attributionSource) {\n        IncomingRfcommSocketInfo socketInfo = new IncomingRfcommSocketInfo();\n\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            socketInfo.status =\n                    BluetoothStatusCodes\n                            .RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n            return socketInfo;\n        }\n\n        if (attributionSource.getUid() != listenerData.mAttributionSource.getUid()) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n            return socketInfo;\n        }\n\n        BluetoothSocket socket = listenerData.mPendingSockets.poll();\n\n        if (socket == null) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_NO_SOCKET_AVAILABLE;\n            return socketInfo;\n        }\n\n        mHandler.removeCallbacksAndMessages(socket);\n\n        socketInfo.bluetoothDevice = socket.getRemoteDevice();\n        socketInfo.pfd = socket.getParcelFileDescriptor();\n        socketInfo.status = BluetoothStatusCodes.SUCCESS;\n\n        return socketInfo;\n    }\n\n    private void handleIncomingRfcommConnections(UUID uuid) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid);\n        for (;;) {\n            BluetoothSocket socket;\n            try {\n                socket = listenerData.mServerSocket.accept();\n            } catch (IOException e) {\n                if (mBluetoothServerSockets.containsKey(uuid)) {\n                    // The uuid still being in the map indicates that the accept failure is\n                    // unexpected. Try and restart the listener.\n                    Log.e(TAG, \"Failed to accept socket on \" + listenerData.mServerSocket, e);\n                    restartRfcommListener(listenerData, uuid);\n                }\n                return;\n            }\n\n            listenerData.mPendingSockets.add(socket);\n            try {\n                listenerData.mPendingIntent.send();\n            } catch (PendingIntent.CanceledException e) {\n                Log.e(TAG, \"PendingIntent for RFCOMM socket notifications cancelled.\", e);\n                // The pending intent was cancelled, close the server as there is no longer any way\n                // to notify the app that registered the listener.\n                listenerData.closeServerAndPendingSockets(mHandler);\n                mBluetoothServerSockets.remove(uuid);\n                return;\n            }\n            mHandler.postDelayed(\n                    () -> pendingSocketTimeoutRunnable(listenerData, socket),\n                    socket,\n                    PENDING_SOCKET_HANDOFF_TIMEOUT.toMillis());\n        }\n    }\n\n    // Tries to restart the rfcomm listener for the given UUID\n    private void restartRfcommListener(RfcommListenerData listenerData, UUID uuid) {\n        listenerData.closeServerAndPendingSockets(mHandler);\n        try {\n            startRfcommListenerInternal(\n                    listenerData.mName,\n                    uuid,\n                    listenerData.mPendingIntent,\n                    listenerData.mAttributionSource);\n        } catch (IOException e) {\n            Log.e(TAG, \"Failed to recreate rfcomm server socket\", e);\n\n            mBluetoothServerSockets.remove(uuid);\n        }\n    }\n\n    private void pendingSocketTimeoutRunnable(\n            RfcommListenerData listenerData, BluetoothSocket socket) {\n        boolean socketFound = listenerData.mPendingSockets.remove(socket);\n        if (socketFound) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to close bt socket\", e);\n                // We don't care if closing the socket failed, just continue on.\n            }\n        }\n    }\n\n    private void startRfcommListenerInternal(\n            String name, UUID uuid, PendingIntent intent, AttributionSource attributionSource)\n            throws IOException {\n        BluetoothServerSocket bluetoothServerSocket =\n                mAdapter.listenUsingRfcommWithServiceRecord(name, uuid);\n\n        RfcommListenerData listenerData =\n                new RfcommListenerData(bluetoothServerSocket, name, intent, attributionSource);\n\n        mBluetoothServerSockets.put(uuid, listenerData);\n\n        mSocketServersExecutor.execute(() -> handleIncomingRfcommConnections(uuid));\n    }\n\n    private void stopRfcommServerSockets() {\n        Iterator<Map.Entry<UUID, RfcommListenerData>> socketsIterator =\n                mBluetoothServerSockets.entrySet().iterator();\n        while (socketsIterator.hasNext()) {\n            socketsIterator.next().getValue().closeServerAndPendingSockets(mHandler);\n            socketsIterator.remove();\n        }\n    }\n\n    private static class RfcommListenerData {\n        final BluetoothServerSocket mServerSocket;\n        // Service record name\n        final String mName;\n        // The Intent which contains the Service info to which the incoming socket connections are\n        // handed off to.\n        final PendingIntent mPendingIntent;\n        // AttributionSource for the requester of the RFCOMM listener\n        final AttributionSource mAttributionSource;\n        // Contains the connected sockets which are pending transfer to the app which requested the\n        // listener.\n        final ConcurrentLinkedQueue<BluetoothSocket> mPendingSockets =\n                new ConcurrentLinkedQueue<>();\n\n        RfcommListenerData(\n                BluetoothServerSocket serverSocket,\n                String name,\n                PendingIntent pendingIntent,\n                AttributionSource attributionSource) {\n            mServerSocket = serverSocket;\n            mName = name;\n            mPendingIntent = pendingIntent;\n            mAttributionSource = attributionSource;\n        }\n\n        int closeServerAndPendingSockets(Handler handler) {\n            int result = BluetoothStatusCodes.SUCCESS;\n            try {\n                mServerSocket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to call close on rfcomm server socket\", e);\n                result = BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CLOSE_SERVER_SOCKET;\n            }\n            mPendingSockets.forEach(\n                    pendingSocket -> {\n                        handler.removeCallbacksAndMessages(pendingSocket);\n                        try {\n                            pendingSocket.close();\n                        } catch (IOException e) {\n                            Log.e(TAG, \"Failed to close socket\", e);\n                        }\n                    });\n            mPendingSockets.clear();\n\n            return result;\n        }\n    }\n\n    private boolean isAvailable() {\n        return !mCleaningUp;\n    }\n\n    /**\n     * Handlers for incoming service calls\n     */\n    private AdapterServiceBinder mBinder;\n\n    /**\n     * The Binder implementation must be declared to be a static class, with\n     * the AdapterService instance passed in the constructor. Furthermore,\n     * when the AdapterService shuts down, the reference to the AdapterService\n     * must be explicitly removed.\n     *\n     * Otherwise, a memory leak can occur from repeated starting/stopping the\n     * service...Please refer to android.os.Binder for further details on\n     * why an inner instance class should be avoided.\n     *\n     */\n    @VisibleForTesting\n    public static class AdapterServiceBinder extends IBluetooth.Stub {\n        private AdapterService mService;\n\n        AdapterServiceBinder(AdapterService svc) {\n            mService = svc;\n            mService.invalidateBluetoothGetStateCache();\n            BluetoothAdapter.getDefaultAdapter().disableBluetoothGetStateCache();\n        }\n\n        public void cleanup() {\n            mService = null;\n        }\n\n        public AdapterService getService() {\n            if (mService != null && mService.isAvailable()) {\n                return mService;\n            }\n            return null;\n        }\n\n        @Override\n        public void getState(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getState());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getState() {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_OFF;\n            }\n\n            return service.getState();\n        }\n\n        @Override\n        public void enable(boolean quietMode, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(enable(quietMode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean enable(boolean quietMode, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"enable\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService enable\")) {\n                return false;\n            }\n\n            return service.enable(quietMode);\n        }\n\n        @Override\n        public void disable(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(disable(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean disable(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"disable\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService disable\")) {\n                return false;\n            }\n\n            return service.disable();\n        }\n\n        @Override\n        public String getAddress() {\n            if (mService == null) {\n                return null;\n            }\n            return getAddressWithAttribution(Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getAddressWithAttribution(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getAddressWithAttribution(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getAddressWithAttribution(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getAddress\")) {\n                return null;\n            }\n\n            enforceLocalMacAddressPermission(service);\n\n            return Utils.getAddressStringFromByte(service.mAdapterProperties.getAddress());\n        }\n\n        @Override\n        public void getUuids(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getUuids(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<ParcelUuid> getUuids(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getUuids\")) {\n                return new ArrayList<>();\n            }\n\n            ParcelUuid[] parcels = service.mAdapterProperties.getUuids();\n            if (parcels == null) {\n                parcels = new ParcelUuid[0];\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public void getIdentityAddress(String address, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getIdentityAddress(address));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public String getIdentityAddress(String address) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getIdentityAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, Utils.getCallingAttributionSource(mService),\n                                \"AdapterService getIdentityAddress\")) {\n                return null;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.getIdentityAddress(address);\n        }\n\n        @Override\n        public void getName(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getName(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getName(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getName\")) {\n                return null;\n            }\n\n            return service.getName();\n        }\n\n        @Override\n        public void getNameLengthForAdvertise(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getNameLengthForAdvertise(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getNameLengthForAdvertise(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getNameLengthForAdvertise\")\n                    || !Utils.checkAdvertisePermissionForDataDelivery(\n                            service, attributionSource, TAG)) {\n                return -1;\n            }\n\n            return service.getNameLengthForAdvertise();\n        }\n\n        @Override\n        public void setName(String name, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setName(name, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setName(String name, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setName\")) {\n                return false;\n            }\n\n            return service.mAdapterProperties.setName(name);\n        }\n\n        @Override\n        public void getBluetoothClass(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBluetoothClass(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private BluetoothClass getBluetoothClass(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getBluetoothClass\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterSource getBluetoothClass\")) {\n                return null;\n            }\n\n            return service.mAdapterProperties.getBluetoothClass();\n        }\n\n        @Override\n        public void setBluetoothClass(BluetoothClass bluetoothClass, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setBluetoothClass(bluetoothClass, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setBluetoothClass(BluetoothClass bluetoothClass, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!service.mAdapterProperties.setBluetoothClass(bluetoothClass)) {\n              return false;\n            }\n\n            return Settings.Global.putInt(\n                    service.getContentResolver(),\n                    Settings.Global.BLUETOOTH_CLASS_OF_DEVICE,\n                    bluetoothClass.getClassOfDevice());\n        }\n\n        @Override\n        public void getIoCapability(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getIoCapability(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getIoCapability(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getIoCapability\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getIoCapability\")) {\n                return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;\n            }\n\n            return service.mAdapterProperties.getIoCapability();\n        }\n\n        @Override\n        public void setIoCapability(int capability, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setIoCapability(capability, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setIoCapability(int capability, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!isValidIoCapability(capability)) {\n              return false;\n            }\n\n            return service.mAdapterProperties.setIoCapability(capability);\n        }\n\n        @Override\n        public void getLeIoCapability(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getLeIoCapability(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getLeIoCapability(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getLeIoCapability\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getLeIoCapability\")) {\n                return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;\n            }\n\n            return service.mAdapterProperties.getLeIoCapability();\n        }\n\n        @Override\n        public void setLeIoCapability(int capability, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setLeIoCapability(capability, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setLeIoCapability(int capability, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!isValidIoCapability(capability)) {\n              return false;\n            }\n\n            return service.mAdapterProperties.setLeIoCapability(capability);\n        }\n\n        @Override\n        public void getScanMode(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getScanMode(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        int getScanMode(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getScanMode\")) {\n                return BluetoothAdapter.SCAN_MODE_NONE;\n            }\n\n            return service.mAdapterProperties.getScanMode();\n        }\n\n        @Override\n        public void setScanMode(int mode, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setScanMode(mode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setScanMode(int mode, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setScanMode\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.setScanMode(convertScanModeToHal(mode))\n                    ? BluetoothStatusCodes.SUCCESS : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public void getDiscoverableTimeout(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getDiscoverableTimeout(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getDiscoverableTimeout(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getDiscoverableTimeout\")) {\n                return -1;\n            }\n\n            return service.mAdapterProperties.getDiscoverableTimeout();\n        }\n\n        @Override\n        public void setDiscoverableTimeout(long timeout, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setDiscoverableTimeout(timeout, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setDiscoverableTimeout(long timeout, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setDiscoverableTimeout\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.setDiscoverableTimeout((int) timeout)\n                    ? BluetoothStatusCodes.SUCCESS : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public void startDiscovery(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(startDiscovery(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean startDiscovery(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"startDiscovery\")) {\n                return false;\n            }\n\n            if (!Utils.checkScanPermissionForDataDelivery(\n                    service, attributionSource, \"Starting discovery.\")) {\n                return false;\n            }\n\n            return service.startDiscovery(attributionSource);\n        }\n\n        @Override\n        public void cancelDiscovery(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(cancelDiscovery(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean cancelDiscovery(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"cancelDiscovery\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService cancelDiscovery\")) {\n                return false;\n            }\n\n            service.debugLog(\"cancelDiscovery\");\n            return service.cancelDiscoveryNative();\n        }\n\n        @Override\n        public void isDiscovering(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isDiscovering(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isDiscovering(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"isDiscovering\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService isDiscovering\")) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isDiscovering();\n        }\n\n        @Override\n        public void getDiscoveryEndMillis(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getDiscoveryEndMillis(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getDiscoveryEndMillis(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return -1;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.discoveryEndMillis();\n        }\n\n        @Override\n        public void getMostRecentlyConnectedDevices(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMostRecentlyConnectedDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getMostRecentlyConnectedDevices(\n                AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMostRecentlyConnectedDevices\")) {\n                return new ArrayList<>();\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mDatabaseManager.getMostRecentlyConnectedDevices();\n        }\n\n        @Override\n        public void getBondedDevices(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBondedDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getBondedDevices(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getBondedDevices\")) {\n                return new ArrayList<>();\n            }\n\n            return Arrays.asList(service.getBondedDevices());\n        }\n\n        @Override\n        public void getAdapterConnectionState(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getAdapterConnectionState());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getAdapterConnectionState() {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getConnectionState();\n        }\n\n        /**\n         * This method has an associated binder cache.  The invalidation\n         * methods must be changed if the logic behind this method changes.\n         */\n        @Override\n        public void getProfileConnectionState(int profile, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getProfileConnectionState(profile));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getProfileConnectionState(int profile) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getProfileConnectionState\")) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getProfileConnectionState(profile);\n        }\n\n        @Override\n        public void createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n                OobData remoteP256Data, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(createBond(device, transport, remoteP192Data, remoteP256Data,\n                            source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n                OobData remoteP256Data, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"createBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService createBond\")) {\n                return false;\n            }\n\n            // This conditional is required to satisfy permission dependencies\n            // since createBond calls createBondOutOfBand with null value passed as data.\n            // BluetoothDevice#createBond requires BLUETOOTH_ADMIN only.\n            service.enforceBluetoothPrivilegedPermissionIfNeeded(remoteP192Data, remoteP256Data);\n\n            return service.createBond(device, transport, remoteP192Data, remoteP256Data,\n                    attributionSource.getPackageName());\n        }\n\n        @Override\n        public void cancelBondProcess(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(cancelBondProcess(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean cancelBondProcess(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"cancelBondProcess\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService cancelBondProcess\")) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp != null) {\n                deviceProp.setBondingInitiatedLocally(false);\n            }\n\n            return service.cancelBondNative(getBytesFromAddress(device.getAddress()));\n        }\n\n        @Override\n        public void removeBond(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(removeBond(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean removeBond(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"removeBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService removeBond\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || deviceProp.getBondState() != BluetoothDevice.BOND_BONDED) {\n                return false;\n            }\n            service.mBondAttemptCallerInfo.remove(device.getAddress());\n            deviceProp.setBondingInitiatedLocally(false);\n\n            Message msg = service.mBondStateMachine.obtainMessage(BondStateMachine.REMOVE_BOND);\n            msg.obj = device;\n            service.mBondStateMachine.sendMessage(msg);\n            return true;\n        }\n\n        @Override\n        public void getBondState(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBondState(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getBondState(BluetoothDevice device, AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getBondState\")) {\n                return BluetoothDevice.BOND_NONE;\n            }\n\n            return service.getBondState(device);\n        }\n\n        @Override\n        public void isBondingInitiatedLocally(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isBondingInitiatedLocally(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isBondingInitiatedLocally(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService isBondingInitiatedLocally\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null && deviceProp.isBondingInitiatedLocally();\n        }\n\n        @Override\n        public void generateLocalOobData(int transport, IBluetoothOobDataCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                generateLocalOobData(transport, callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private void generateLocalOobData(int transport, IBluetoothOobDataCallback callback,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveOrManagedUser(service, TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            service.generateLocalOobData(transport, callback);\n        }\n\n        @Override\n        public void getSupportedProfiles(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSupportedProfiles(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getSupportedProfiles(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return 0;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return Config.getSupportedProfilesBitMask();\n        }\n\n        @Override\n        public int getConnectionState(BluetoothDevice device) {\n            if (mService == null) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n            return getConnectionStateWithAttribution(device,\n                        Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getConnectionStateWithAttribution(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getConnectionStateWithAttribution(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public int getConnectionStateWithAttribution(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getConnectionState\")) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n\n            return service.getConnectionState(device);\n        }\n\n        @Override\n        public void canBondWithoutDialog(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(canBondWithoutDialog(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean canBondWithoutDialog(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.canBondWithoutDialog(device);\n        }\n\n        @Override\n        public void removeActiveDevice(@ActiveDeviceUse int profiles,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(removeActiveDevice(profiles, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean removeActiveDevice(@ActiveDeviceUse int profiles,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            return service.setActiveDevice(null, profiles);\n        }\n\n        @Override\n        public void setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setActiveDevice(device, profiles, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.setActiveDevice(device, profiles);\n        }\n\n        @Override\n        public void getActiveDevices(@ActiveDeviceProfile int profile,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getActiveDevices(profile, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getActiveDevices(@ActiveDeviceProfile int profile,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return new ArrayList<>();\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.getActiveDevices(profile);\n        }\n\n        @Override\n        public void connectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(connectAllEnabledProfiles(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int connectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"connectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            try {\n                return service.connectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"connectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public void disconnectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(disconnectAllEnabledProfiles(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int disconnectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"disconnectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            try {\n                return service.disconnectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"disconnectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public void getRemoteName(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteName(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getRemoteName(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteName\")) {\n                return null;\n            }\n\n            return service.getRemoteName(device);\n        }\n\n        @Override\n        public void getRemoteType(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteType(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getRemoteType(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteType\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteType\")) {\n                return BluetoothDevice.DEVICE_TYPE_UNKNOWN;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null\n                    ? deviceProp.getDeviceType() : BluetoothDevice.DEVICE_TYPE_UNKNOWN;\n        }\n\n        @Override\n        public String getRemoteAlias(BluetoothDevice device) {\n            if (mService == null) {\n                return null;\n            }\n            return getRemoteAliasWithAttribution(device,\n                    Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getRemoteAliasWithAttribution(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteAliasWithAttribution(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getRemoteAliasWithAttribution(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteAlias\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteAlias\")) {\n                return null;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null ? deviceProp.getAlias() : null;\n        }\n\n        @Override\n        public void setRemoteAlias(BluetoothDevice device, String name, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setRemoteAlias(device, name, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setRemoteAlias(BluetoothDevice device, String name,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"setRemoteAlias\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (name != null && name.isEmpty()) {\n                throw new IllegalArgumentException(\"alias cannot be the empty string\");\n            }\n\n            if (!hasBluetoothPrivilegedPermission(service)) {\n                if (!Utils.checkConnectPermissionForDataDelivery(\n                        service, attributionSource, \"AdapterService setRemoteAlias\")) {\n                    return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n                }\n                enforceCdmAssociation(service.mCompanionDeviceManager, service,\n                        attributionSource.getPackageName(), Binder.getCallingUid(), device);\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n            }\n            deviceProp.setAlias(device, name);\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public void getRemoteClass(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteClass(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getRemoteClass(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteClass\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteClass\")) {\n                return 0;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null ? deviceProp.getBluetoothClass() : 0;\n        }\n\n        @Override\n        public void getRemoteUuids(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteUuids(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<ParcelUuid> getRemoteUuids(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteUuids\")) {\n                return new ArrayList<>();\n            }\n\n            ParcelUuid[] parcels = service.getRemoteUuids(device);\n            if (parcels == null) {\n                return null;\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public boolean fetchRemoteUuids(BluetoothDevice device) {\n            if (mService == null) {\n                return false;\n            }\n            return fetchRemoteUuidsWithAttribution(device, TRANSPORT_AUTO,\n                    Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void fetchRemoteUuidsWithAttribution(BluetoothDevice device, int transport,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(fetchRemoteUuidsWithAttribution(device, transport, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean fetchRemoteUuidsWithAttribution(\n                BluetoothDevice device, int transport, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"fetchRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService fetchRemoteUuids\")) {\n                return false;\n            }\n            if (transport != TRANSPORT_AUTO) {\n                enforceBluetoothPrivilegedPermission(service);\n            }\n\n            service.mRemoteDevices.fetchUuids(device, transport);\n            return true;\n        }\n\n        @Override\n        public void setPin(BluetoothDevice device, boolean accept, int len, byte[] pinCode,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPin(device, accept, len, pinCode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPin(BluetoothDevice device, boolean accept, int len, byte[] pinCode,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setPin\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setPin\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            // Only allow setting a pin in bonding state, or bonded state in case of security\n            // upgrade.\n            if (deviceProp == null || !deviceProp.isBondingOrBonded()) {\n                return false;\n            }\n            if (pinCode.length != len) {\n                android.util.EventLog.writeEvent(0x534e4554, \"139287605\", -1,\n                        \"PIN code length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(device, accept,\n                    BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_PIN_REPLIED);\n            return service.pinReplyNative(\n                    getBytesFromAddress(device.getAddress()), accept, len, pinCode);\n        }\n\n        @Override\n        public void setPasskey(BluetoothDevice device, boolean accept, int len, byte[] passkey,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPasskey(device, accept, len, passkey, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPasskey(BluetoothDevice device, boolean accept, int len, byte[] passkey,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setPasskey\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setPasskey\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                return false;\n            }\n            if (passkey.length != len) {\n                android.util.EventLog.writeEvent(0x534e4554, \"139287605\", -1,\n                        \"Passkey length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            return service.sspReplyNative(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_ENTRY,\n                    accept,\n                    Utils.byteArrayToInt(passkey));\n        }\n\n        @Override\n        public void setPairingConfirmation(BluetoothDevice device, boolean accept,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPairingConfirmation(device, accept, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPairingConfirmation(BluetoothDevice device, boolean accept,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                return false;\n            }\n            service.logUserBondResponse(device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            return service.sspReplyNative(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_CONFIRMATION,\n                    accept,\n                    0);\n        }\n\n        @Override\n        public void getSilenceMode(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSilenceMode(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean getSilenceMode(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mSilenceDeviceManager.getSilenceMode(device);\n        }\n\n        @Override\n        public void setSilenceMode(BluetoothDevice device, boolean silence,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setSilenceMode(device, silence, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setSilenceMode(BluetoothDevice device, boolean silence,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mSilenceDeviceManager.setSilenceMode(device, silence);\n            return true;\n        }\n\n        @Override\n        public void getPhonebookAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getPhonebookAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getPhonebookAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getPhonebookAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getPhonebookAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setPhonebookAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPhonebookAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPhonebookAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setPhonebookAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public void getMessageAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMessageAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getMessageAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getMessageAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMessageAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setMessageAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setMessageAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setMessageAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setMessageAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public void getSimAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSimAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getSimAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getSimAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getSimAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setSimAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setSimAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setSimAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setSimAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public IBluetoothSocketManager getSocketManager() {\n            AdapterService service = getService();\n            if (service == null) {\n                return null;\n            }\n\n            return IBluetoothSocketManager.Stub.asInterface(service.mBluetoothSocketManagerBinder);\n        }\n\n        @Override\n        public void sdpSearch(BluetoothDevice device, ParcelUuid uuid, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(sdpSearch(device, uuid, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean sdpSearch(\n                BluetoothDevice device, ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"sdpSearch\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService sdpSearch\")) {\n                return false;\n            }\n\n            if (service.mSdpManager == null) {\n                return false;\n            }\n            service.mSdpManager.sdpSearch(device, uuid);\n            return true;\n        }\n\n        @Override\n        public void getBatteryLevel(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBatteryLevel(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getBatteryLevel(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getBatteryLevel\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getBatteryLevel\")) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n            return deviceProp.getBatteryLevel();\n        }\n\n        @Override\n        public void getMaxConnectedAudioDevices(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMaxConnectedAudioDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getMaxConnectedAudioDevices(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMaxConnectedAudioDevices\")) {\n                return -1;\n            }\n\n            return service.getMaxConnectedAudioDevices();\n        }\n\n        //@Override\n        @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)\n        public void isA2dpOffloadEnabled(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isA2dpOffloadEnabled(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isA2dpOffloadEnabled(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService isA2dpOffloadEnabled\")) {\n                return false;\n            }\n\n            return service.isA2dpOffloadEnabled();\n        }\n\n        @Override\n        public void factoryReset(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(factoryReset(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        boolean factoryReset(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mDatabaseManager != null) {\n                service.mDatabaseManager.factoryReset();\n            }\n\n            if (service.mBluetoothKeystoreService != null) {\n                service.mBluetoothKeystoreService.factoryReset();\n            }\n\n            return service.factoryResetNative();\n        }\n\n        @Override\n        public void registerBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(registerBluetoothConnectionCallback(callback, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean registerBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            service.mBluetoothConnectionCallbacks.add(callback);\n            return true;\n        }\n\n        @Override\n        public void unregisterBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(unregisterBluetoothConnectionCallback(callback, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean unregisterBluetoothConnectionCallback(\n                IBluetoothConnectionCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.mBluetoothConnectionCallbacks.remove(callback);\n        }\n\n        @Override\n        public void registerCallback(IBluetoothCallback callback, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                registerCallback(callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void registerCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mCallbacks.register(callback);\n        }\n\n        @Override\n        public void unregisterCallback(IBluetoothCallback callback, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                unregisterCallback(callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void unregisterCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null || service.mCallbacks == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mCallbacks.unregister(callback);\n        }\n\n        @Override\n        public void isMultiAdvertisementSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isMultiAdvertisementSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isMultiAdvertisementSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.mAdapterProperties.getNumOfAdvertisementInstancesSupported();\n            return val >= MIN_ADVT_INSTANCES_FOR_MA;\n        }\n\n        /**\n         * This method has an associated binder cache.  The invalidation\n         * methods must be changed if the logic behind this method changes.\n         */\n        @Override\n        public void isOffloadedFilteringSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isOffloadedFilteringSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isOffloadedFilteringSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getNumOfOffloadedScanFilterSupported();\n            return val >= MIN_OFFLOADED_FILTERS;\n        }\n\n        @Override\n        public void isOffloadedScanBatchingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isOffloadedScanBatchingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isOffloadedScanBatchingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getOffloadedScanResultStorage();\n            return val >= MIN_OFFLOADED_SCAN_STORAGE_BYTES;\n        }\n\n        @Override\n        public void isLe2MPhySupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLe2MPhySupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLe2MPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLe2MPhySupported();\n        }\n\n        @Override\n        public void isLeCodedPhySupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeCodedPhySupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLeCodedPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeCodedPhySupported();\n        }\n\n        @Override\n        public void isLeExtendedAdvertisingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeExtendedAdvertisingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLeExtendedAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeExtendedAdvertisingSupported();\n        }\n\n        @Override\n        public void isLePeriodicAdvertisingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLePeriodicAdvertisingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLePeriodicAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLePeriodicAdvertisingSupported();\n        }\n\n        @Override\n        public void isLeAudioSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int isLeAudioSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            HashSet<Class> supportedProfileServices =\n                    new HashSet<Class>(Arrays.asList(Config.getSupportedProfiles()));\n            HashSet<Class> leAudioUnicastProfiles = Config.geLeAudioUnicastProfiles();\n\n            if (supportedProfileServices.containsAll(leAudioUnicastProfiles)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void isLeAudioBroadcastSourceSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioBroadcastSourceSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int isLeAudioBroadcastSourceSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            if (service.isLeAudioBroadcastSourceSupported()) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void isLeAudioBroadcastAssistantSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioBroadcastAssistantSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public int isLeAudioBroadcastAssistantSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            HashSet<Class> supportedProfileServices =\n                    new HashSet<Class>(Arrays.asList(Config.getSupportedProfiles()));\n\n            if (supportedProfileServices.contains(BassClientService.class)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void getLeMaximumAdvertisingDataLength(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getLeMaximumAdvertisingDataLength());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getLeMaximumAdvertisingDataLength() {\n            AdapterService service = getService();\n            if (service == null) {\n                return 0;\n            }\n\n            return service.getLeMaximumAdvertisingDataLength();\n        }\n\n        @Override\n        public void isActivityAndEnergyReportingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isActivityAndEnergyReportingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isActivityAndEnergyReportingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isActivityAndEnergyReportingSupported();\n        }\n\n        @Override\n        public void reportActivityInfo(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(reportActivityInfo(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private BluetoothActivityEnergyInfo reportActivityInfo(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.reportActivityInfo();\n        }\n\n        @Override\n        public void registerMetadataListener(IBluetoothMetadataListener listener,\n                BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(registerMetadataListener(listener, device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean registerMetadataListener(IBluetoothMetadataListener listener,\n                BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mMetadataListeners == null) {\n                return false;\n            }\n            ArrayList<IBluetoothMetadataListener> list = service.mMetadataListeners.get(device);\n            if (list == null) {\n                list = new ArrayList<>();\n            } else if (list.contains(listener)) {\n                // The device is already registered with this listener\n                return true;\n            }\n            list.add(listener);\n            service.mMetadataListeners.put(device, list);\n            return true;\n        }\n\n        @Override\n        public void unregisterMetadataListener(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(unregisterMetadataListener(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean unregisterMetadataListener(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mMetadataListeners == null) {\n                return false;\n            }\n            if (service.mMetadataListeners.containsKey(device)) {\n                service.mMetadataListeners.remove(device);\n            }\n            return true;\n        }\n\n        @Override\n        public void setMetadata(BluetoothDevice device, int key, byte[] value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setMetadata(device, key, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setMetadata(BluetoothDevice device, int key, byte[] value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (value.length > BluetoothDevice.METADATA_MAX_LENGTH) {\n                return false;\n            }\n            return service.mDatabaseManager.setCustomMeta(device, key, value);\n        }\n\n        @Override\n        public void getMetadata(BluetoothDevice device, int key, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMetadata(device, key, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private byte[] getMetadata(BluetoothDevice device, int key,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mDatabaseManager.getCustomMeta(device, key);\n        }\n\n        @Override\n        public void requestActivityInfo(IBluetoothActivityEnergyInfoListener listener,\n                    AttributionSource source) {\n            BluetoothActivityEnergyInfo info = reportActivityInfo(source);\n            try {\n                listener.onBluetoothActivityEnergyInfoAvailable(info);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"onBluetoothActivityEnergyInfo: RemoteException\", e);\n            }\n        }\n\n        @Override\n        public void onLeServiceUp(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                onLeServiceUp(source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void onLeServiceUp(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_ON);\n        }\n\n        @Override\n        public void onBrEdrDown(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                onBrEdrDown(source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void onBrEdrDown(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n        }\n\n        @Override\n        public void dump(FileDescriptor fd, String[] args) {\n            PrintWriter writer = new PrintWriter(new FileOutputStream(fd));\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n\n            enforceDumpPermission(service);\n\n            service.dump(fd, writer, args);\n            writer.close();\n        }\n\n        @Override\n        public void allowLowLatencyAudio(boolean allowed, BluetoothDevice device,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(allowLowLatencyAudio(allowed, device));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, Utils.getCallingAttributionSource(service),\n                                \"AdapterService allowLowLatencyAudio\")) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.allowLowLatencyAudio(allowed, device);\n        }\n\n        @Override\n        public void startRfcommListener(String name, ParcelUuid uuid, PendingIntent pendingIntent,\n                AttributionSource attributionSource, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(startRfcommListener(name, uuid, pendingIntent, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private int startRfcommListener(\n                String name,\n                ParcelUuid uuid,\n                PendingIntent pendingIntent,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService startRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.startRfcommListener(name, uuid, pendingIntent, attributionSource);\n        }\n\n        @Override\n        public void stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(stopRfcommListener(uuid, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private int stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService stopRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.stopRfcommListener(uuid, attributionSource);\n        }\n\n        @Override\n        public void retrievePendingSocketForServiceRecord(ParcelUuid uuid,\n                AttributionSource attributionSource, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(retrievePendingSocketForServiceRecord(uuid, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n                ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource,\n                            \"AdapterService retrievePendingSocketForServiceRecord\")) {\n                return null;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.retrievePendingSocketForServiceRecord(uuid, attributionSource);\n        }\n\n        @Override\n        public void setForegroundUserId(int userId, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, Utils.getCallingAttributionSource(mService),\n                    \"AdapterService setForegroundUserId\")) {\n                return;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            Utils.setForegroundUserId(userId);\n        }\n    }\n\n    // ----API Methods--------\n\n    public boolean isEnabled() {\n        return getState() == BluetoothAdapter.STATE_ON;\n    }\n\n    public int getState() {\n        if (mAdapterProperties != null) {\n            return mAdapterProperties.getState();\n        }\n        return BluetoothAdapter.STATE_OFF;\n    }\n\n    public synchronized boolean enable(boolean quietMode) {\n        // Enforce the user restriction for disallowing Bluetooth if it was set.\n        if (mUserManager.hasUserRestrictionForUser(UserManager.DISALLOW_BLUETOOTH,\n                    UserHandle.SYSTEM)) {\n            debugLog(\"enable() called when Bluetooth was disallowed\");\n            return false;\n        }\n\n        debugLog(\"enable() - Enable called with quiet mode status =  \" + quietMode);\n        mQuietmode = quietMode;\n        mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_ON);\n        return true;\n    }\n\n    boolean disable() {\n        debugLog(\"disable() called with mRunningProfiles.size() = \" + mRunningProfiles.size());\n        mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_OFF);\n        return true;\n    }\n\n    public String getName() {\n        return mAdapterProperties.getName();\n    }\n\n    public int getNameLengthForAdvertise() {\n        return mAdapterProperties.getName().length();\n    }\n\n    private static boolean isValidIoCapability(int capability) {\n        if (capability < 0 || capability >= BluetoothAdapter.IO_CAPABILITY_MAX) {\n            Log.e(TAG, \"Invalid IO capability value - \" + capability);\n            return false;\n        }\n\n        return true;\n    }\n\n    ArrayList<DiscoveringPackage> getDiscoveringPackages() {\n        return mDiscoveringPackages;\n    }\n\n    void clearDiscoveringPackages() {\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.clear();\n        }\n    }\n\n    boolean startDiscovery(AttributionSource attributionSource) {\n        UserHandle callingUser = Binder.getCallingUserHandle();\n        debugLog(\"startDiscovery\");\n        String callingPackage = attributionSource.getPackageName();\n        mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);\n        boolean isQApp = Utils.checkCallerTargetSdk(this, callingPackage, Build.VERSION_CODES.Q);\n        boolean hasDisavowedLocation =\n                Utils.hasDisavowedLocationForScan(this, attributionSource, mTestModeEnabled);\n        String permission = null;\n        if (Utils.checkCallerHasNetworkSettingsPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETTINGS;\n        } else if (Utils.checkCallerHasNetworkSetupWizardPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETUP_WIZARD;\n        } else if (!hasDisavowedLocation) {\n            if (isQApp) {\n                if (!Utils.checkCallerHasFineLocation(this, attributionSource, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_FINE_LOCATION;\n            } else {\n                if (!Utils.checkCallerHasCoarseLocation(this, attributionSource, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_COARSE_LOCATION;\n            }\n        }\n\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.add(\n                    new DiscoveringPackage(callingPackage, permission, hasDisavowedLocation));\n        }\n        return startDiscoveryNative();\n    }\n\n    /**\n     * Same as API method {@link BluetoothAdapter#getBondedDevices()}\n     *\n     * @return array of bonded {@link BluetoothDevice} or null on error\n     */\n    public BluetoothDevice[] getBondedDevices() {\n        return mAdapterProperties.getBondedDevices();\n    }\n\n    /**\n     * Get the database manager to access Bluetooth storage\n     *\n     * @return {@link DatabaseManager} or null on error\n     */\n    @VisibleForTesting\n    public DatabaseManager getDatabase() {\n        return mDatabaseManager;\n    }\n\n    public byte[] getByteIdentityAddress(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.isConsolidated()) {\n            return Utils.getBytesFromAddress(deviceProp.getIdentityAddress());\n        } else {\n            return Utils.getByteAddress(device);\n        }\n    }\n\n    public BluetoothDevice getDeviceFromByte(byte[] address) {\n        BluetoothDevice device = mRemoteDevices.getDevice(address);\n        if (device == null) {\n            device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address);\n        }\n        return device;\n    }\n\n    public String getIdentityAddress(String address) {\n        BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address.toUpperCase());\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.isConsolidated()) {\n            return deviceProp.getIdentityAddress();\n        } else {\n            return address;\n        }\n    }\n\n    private class CallerInfo {\n        public String callerPackageName;\n        public UserHandle user;\n    }\n\n    boolean createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n            OobData remoteP256Data, String callingPackage) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.getBondState() != BluetoothDevice.BOND_NONE) {\n            return false;\n        }\n\n        if (!isPackageNameAccurate(this, callingPackage, Binder.getCallingUid())) {\n            return false;\n        }\n\n        CallerInfo createBondCaller = new CallerInfo();\n        createBondCaller.callerPackageName = callingPackage;\n        createBondCaller.user = Binder.getCallingUserHandle();\n        mBondAttemptCallerInfo.put(device.getAddress(), createBondCaller);\n\n        mRemoteDevices.setBondingInitiatedLocally(Utils.getByteAddress(device));\n\n        // Pairing is unreliable while scanning, so cancel discovery\n        // Note, remove this when native stack improves\n        cancelDiscoveryNative();\n\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.CREATE_BOND);\n        msg.obj = device;\n        msg.arg1 = transport;\n\n        Bundle remoteOobDatasBundle = new Bundle();\n        boolean setData = false;\n        if (remoteP192Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP192, remoteP192Data);\n            setData = true;\n        }\n        if (remoteP256Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP256, remoteP256Data);\n            setData = true;\n        }\n        if (setData) {\n            msg.setData(remoteOobDatasBundle);\n        }\n        mBondStateMachine.sendMessage(msg);\n        return true;\n    }\n\n    private final ArrayDeque<IBluetoothOobDataCallback> mOobDataCallbackQueue =\n            new ArrayDeque<>();\n\n    /**\n     * Fetches the local OOB data to give out to remote.\n     *\n     * @param transport - specify data transport.\n     * @param callback - callback used to receive the requested {@link OobData}; null will be\n     * ignored silently.\n     *\n     * @hide\n     */\n    public synchronized void generateLocalOobData(int transport,\n            IBluetoothOobDataCallback callback) {\n        if (callback == null) {\n            Log.e(TAG, \"'callback' argument must not be null!\");\n            return;\n        }\n        if (mOobDataCallbackQueue.peek() != null) {\n            try {\n                callback.onError(BluetoothStatusCodes.ERROR_ANOTHER_ACTIVE_OOB_REQUEST);\n                return;\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        }\n        mOobDataCallbackQueue.offer(callback);\n        generateLocalOobDataNative(transport);\n    }\n\n    /* package */ synchronized void notifyOobDataCallback(int transport, OobData oobData) {\n        if (mOobDataCallbackQueue.peek() == null) {\n            Log.e(TAG, \"Failed to make callback, no callback exists\");\n            return;\n        }\n        if (oobData == null) {\n            try {\n                mOobDataCallbackQueue.poll().onError(BluetoothStatusCodes.ERROR_UNKNOWN);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        } else {\n            try {\n                mOobDataCallbackQueue.poll().onOobData(transport, oobData);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        }\n    }\n\n    public boolean isQuietModeEnabled() {\n        debugLog(\"isQuietModeEnabled() - Enabled = \" + mQuietmode);\n        return mQuietmode;\n    }\n\n    public void updateUuids() {\n        debugLog(\"updateUuids() - Updating UUIDs for bonded devices\");\n        BluetoothDevice[] bondedDevices = getBondedDevices();\n        if (bondedDevices == null) {\n            return;\n        }\n\n        for (BluetoothDevice device : bondedDevices) {\n            mRemoteDevices.updateUuids(device);\n        }\n    }\n\n    /**\n     * Update device UUID changed to {@link BondStateMachine}\n     *\n     * @param device remote device of interest\n     */\n    public void deviceUuidUpdated(BluetoothDevice device) {\n        // Notify BondStateMachine for SDP complete / UUID changed.\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.UUID_UPDATE);\n        msg.obj = device;\n        mBondStateMachine.sendMessage(msg);\n    }\n\n    /**\n     * Get the bond state of a particular {@link BluetoothDevice}\n     *\n     * @param device remote device of interest\n     * @return bond state <p>Possible values are\n     * {@link BluetoothDevice#BOND_NONE},\n     * {@link BluetoothDevice#BOND_BONDING},\n     * {@link BluetoothDevice#BOND_BONDED}.\n     */\n    @VisibleForTesting\n    public int getBondState(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return BluetoothDevice.BOND_NONE;\n        }\n        return deviceProp.getBondState();\n    }\n\n    int getConnectionState(BluetoothDevice device) {\n        return getConnectionStateNative(getBytesFromAddress(device.getAddress()));\n    }\n\n    /**\n     * Checks whether the device was recently associated with the comapnion app that called\n     * {@link BluetoothDevice#createBond}. This allows these devices to skip the pairing dialog if\n     * their pairing variant is {@link BluetoothDevice#PAIRING_VARIANT_CONSENT}.\n     *\n     * @param device the bluetooth device that is being bonded\n     * @return true if it was recently associated and we can bypass the dialog, false otherwise\n     */\n    public boolean canBondWithoutDialog(BluetoothDevice device) {\n        if (mBondAttemptCallerInfo.containsKey(device.getAddress())) {\n            CallerInfo bondCallerInfo = mBondAttemptCallerInfo.get(device.getAddress());\n\n            return mCompanionDeviceManager.canPairWithoutPrompt(bondCallerInfo.callerPackageName,\n                    device.getAddress(), bondCallerInfo.user);\n        }\n        return false;\n    }\n\n    /**\n     * Sets device as the active devices for the profiles passed into the function\n     *\n     * @param device is the remote bluetooth device\n     * @param profiles is a constant that references for which profiles we'll be setting the remote\n     *                 device as our active device. One of the following:\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_AUDIO},\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_PHONE_CALL}\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_ALL}\n     * @return false if profiles value is not one of the constants we accept, true otherwise\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    public boolean setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles) {\n        boolean setA2dp = false;\n        boolean setHeadset = false;\n\n        // Determine for which profiles we want to set device as our active device\n        switch(profiles) {\n            case BluetoothAdapter.ACTIVE_DEVICE_AUDIO:\n                setA2dp = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_PHONE_CALL:\n                setHeadset = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_ALL:\n                setA2dp = true;\n                setHeadset = true;\n                break;\n            default:\n                return false;\n        }\n\n        if (mLeAudioService != null && (device == null\n                || mLeAudioService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Le Audio device \" + device);\n            mLeAudioService.setActiveDevice(device);\n        }\n\n        if (setA2dp && mA2dpService != null && (device == null\n                || mA2dpService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active A2dp device \" + device);\n            mA2dpService.setActiveDevice(device);\n        }\n\n        if (mHearingAidService != null && (device == null\n                || mHearingAidService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Hearing Aid \" + device);\n            mHearingAidService.setActiveDevice(device);\n        }\n\n        if (setHeadset && mHeadsetService != null && (device == null\n                || mHeadsetService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Headset \" + device);\n            mHeadsetService.setActiveDevice(device);\n        }\n\n        return true;\n    }\n\n    /**\n     * Get the active devices for the BluetoothProfile specified\n     *\n     * @param profile is the profile from which we want the active devices.\n     *                Possible values are:\n     *                {@link BluetoothProfile#HEADSET},\n     *                {@link BluetoothProfile#A2DP},\n     *                {@link BluetoothProfile#HEARING_AID}\n     *                {@link BluetoothProfile#LE_AUDIO}\n     * @return A list of active bluetooth devices\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    public List<BluetoothDevice> getActiveDevices(@ActiveDeviceProfile int profile) {\n        List<BluetoothDevice> activeDevices = new ArrayList<>();\n\n        switch (profile) {\n            case BluetoothProfile.HEADSET:\n                if (mHeadsetService == null) {\n                    Log.e(TAG, \"getActiveDevices: HeadsetService is null\");\n                } else {\n                    BluetoothDevice device = mHeadsetService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: Headset device: \" + device);\n                }\n                break;\n            case BluetoothProfile.A2DP:\n                if (mA2dpService == null) {\n                    Log.e(TAG, \"getActiveDevices: A2dpService is null\");\n                } else {\n                    BluetoothDevice device = mA2dpService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: A2dp device: \" + device);\n                }\n                break;\n            case BluetoothProfile.HEARING_AID:\n                if (mHearingAidService == null) {\n                    Log.e(TAG, \"getActiveDevices: HearingAidService is null\");\n                } else {\n                    activeDevices = mHearingAidService.getActiveDevices();\n                    Log.i(TAG, \"getActiveDevices: Hearing Aid devices: Left[\"\n                            + activeDevices.get(0) + \"] - Right[\" + activeDevices.get(1) + \"]\");\n                }\n                break;\n            case BluetoothProfile.LE_AUDIO:\n                if (mLeAudioService == null) {\n                Log.e(TAG, \"getActiveDevices: LeAudioService is null\");\n                } else {\n                    activeDevices = mLeAudioService.getActiveDevices();\n                    Log.i(TAG, \"getActiveDevices: LeAudio devices: Out[\"\n                            + activeDevices.get(0) + \"] - In[\" + activeDevices.get(1) + \"]\");\n                }\n                break;\n            default:\n                Log.e(TAG, \"getActiveDevices: profile value is not valid\");\n        }\n        return activeDevices;\n    }\n\n    /**\n     * Attempts connection to all enabled and supported bluetooth profiles between the local and\n     * remote device\n     *\n     * @param device is the remote device with which to connect these profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS} if all profiles connections are attempted, false\n     *         if an error occurred\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    public int connectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"connectAllEnabledProfiles: Not all profile services running\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        // Checks if any profiles are enabled and if so, only connect enabled profiles\n        if (isAnyProfileEnabled(device)) {\n            return connectEnabledProfiles(device);\n        }\n\n        int numProfilesConnected = 0;\n        ParcelUuid[] remoteDeviceUuids = getRemoteUuids(device);\n        ParcelUuid[] localDeviceUuids = mAdapterProperties.getUuids();\n\n        // All profile toggles disabled, so connects all supported profiles\n        if (mA2dpService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting A2dp\");\n            // Set connection policy also connects the profile with CONNECTION_POLICY_ALLOWED\n            mA2dpService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mA2dpSinkService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP_SINK, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Headset Profile\");\n            mHeadsetService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting HFP\");\n            mHeadsetClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mMapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.MAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting MAP\");\n            mMapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHidHostService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HID_HOST, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hid Host Profile\");\n            mHidHostService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPanService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PAN, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Pan Profile\");\n            mPanService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPbapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PBAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Pbap\");\n            mPbapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHearingAidService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEARING_AID, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hearing Aid Profile\");\n            mHearingAidService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hearing Access Client Profile\");\n            mHapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mVolumeControlService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.VOLUME_CONTROL, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mCsipSetCoordinatorService != null\n                && isSupported(localDeviceUuids, remoteDeviceUuids,\n                        BluetoothProfile.CSIP_SET_COORDINATOR, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mLeAudioService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mBassClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n\n        Log.i(TAG, \"connectAllEnabledProfiles: Number of Profiles Connected: \"\n                + numProfilesConnected);\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Disconnects all enabled and supported bluetooth profiles between the local and remote device\n     *\n     * @param device is the remote device with which to disconnect these profiles\n     * @return true if all profiles successfully disconnected, false if an error occurred\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    public int disconnectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"disconnectAllEnabledProfiles: Not all profile services bound\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        if (mA2dpService != null && mA2dpService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp\");\n            mA2dpService.disconnect(device);\n        }\n        if (mA2dpSinkService != null && mA2dpSinkService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp Sink\");\n            mA2dpSinkService.disconnect(device);\n        }\n        if (mHeadsetService != null && mHeadsetService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG,\n                    \"disconnectAllEnabledProfiles: Disconnecting Headset Profile\");\n            mHeadsetService.disconnect(device);\n        }\n        if (mHeadsetClientService != null && mHeadsetClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting HFP\");\n            mHeadsetClientService.disconnect(device);\n        }\n        if (mMapClientService != null && mMapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP Client\");\n            mMapClientService.disconnect(device);\n        }\n        if (mMapService != null && mMapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP\");\n            mMapService.disconnect(device);\n        }\n        if (mHidDeviceService != null && mHidDeviceService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Device Profile\");\n            mHidDeviceService.disconnect(device);\n        }\n        if (mHidHostService != null && mHidHostService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Host Profile\");\n            mHidHostService.disconnect(device);\n        }\n        if (mPanService != null && mPanService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pan Profile\");\n            mPanService.disconnect(device);\n        }\n        if (mPbapClientService != null && mPbapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Client\");\n            mPbapClientService.disconnect(device);\n        }\n        if (mPbapService != null && mPbapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Server\");\n            mPbapService.disconnect(device);\n        }\n        if (mHearingAidService != null && mHearingAidService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Aid Profile\");\n            mHearingAidService.disconnect(device);\n        }\n        if (mHapClientService != null && mHapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Access Profile Client\");\n            mHapClientService.disconnect(device);\n        }\n        if (mVolumeControlService != null && mVolumeControlService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Volume Control Profile\");\n            mVolumeControlService.disconnect(device);\n        }\n        if (mSapService != null && mSapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Sap Profile\");\n            mSapService.disconnect(device);\n        }\n        if (mCsipSetCoordinatorService != null\n                && mCsipSetCoordinatorService.getConnectionState(device)\n                        == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Coordinater Set Profile\");\n            mCsipSetCoordinatorService.disconnect(device);\n        }\n        if (mLeAudioService != null && mLeAudioService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting LeAudio profile (BAP)\");\n            mLeAudioService.disconnect(device);\n        }\n        if (mBassClientService != null && mBassClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting \"\n                            + \"LE Broadcast Assistant Profile\");\n            mBassClientService.disconnect(device);\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Same as API method {@link BluetoothDevice#getName()}\n     *\n     * @param device remote device of interest\n     * @return remote device name\n     */\n    public String getRemoteName(BluetoothDevice device) {\n        if (mRemoteDevices == null) {\n            return null;\n        }\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return null;\n        }\n        return deviceProp.getName();\n    }\n\n    /**\n     * Get UUIDs for service supported by a remote device\n     *\n     * @param device the remote device that we want to get UUIDs from\n     * @return\n     */\n    @VisibleForTesting\n    public ParcelUuid[] getRemoteUuids(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return null;\n        }\n        return deviceProp.getUuids();\n    }\n\n    public Set<IBluetoothConnectionCallback> getBluetoothConnectionCallbacks() {\n        return mBluetoothConnectionCallbacks;\n    }\n\n    /**\n     * Converts HCI disconnect reasons to Android disconnect reasons.\n     * <p>\n     * The HCI Error Codes used for ACL disconnect reasons propagated up from native code were\n     * copied from: {@link system/bt/stack/include/hci_error_code.h}.\n     * <p>\n     * These error codes are specified and described in Bluetooth Core Spec v5.1, Vol 2, Part D.\n     *\n     * @param hciReason is the raw HCI disconnect reason from native.\n     * @return the Android disconnect reason for apps.\n     */\n    static @BluetoothAdapter.BluetoothConnectionCallback.DisconnectReason int\n            hciToAndroidDisconnectReason(int hciReason) {\n        switch(hciReason) {\n            case /*HCI_SUCCESS*/ 0x00:\n            case /*HCI_ERR_UNSPECIFIED*/ 0x1F:\n            case /*HCI_ERR_UNDEFINED*/ 0xff:\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n            case /*HCI_ERR_ILLEGAL_COMMAND*/ 0x01:\n            case /*HCI_ERR_NO_CONNECTION*/ 0x02:\n            case /*HCI_ERR_HW_FAILURE*/ 0x03:\n            case /*HCI_ERR_DIFF_TRANSACTION_COLLISION*/ 0x2A:\n            case /*HCI_ERR_ROLE_SWITCH_PENDING*/ 0x32:\n            case /*HCI_ERR_ROLE_SWITCH_FAILED*/ 0x35:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL;\n            case /*HCI_ERR_PAGE_TIMEOUT*/ 0x04:\n            case /*HCI_ERR_CONNECTION_TOUT*/ 0x08:\n            case /*HCI_ERR_HOST_TIMEOUT*/ 0x10:\n            case /*HCI_ERR_LMP_RESPONSE_TIMEOUT*/ 0x22:\n            case /*HCI_ERR_ADVERTISING_TIMEOUT*/ 0x3C:\n            case /*HCI_ERR_CONN_FAILED_ESTABLISHMENT*/ 0x3E:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_TIMEOUT;\n            case /*HCI_ERR_AUTH_FAILURE*/ 0x05:\n            case /*HCI_ERR_KEY_MISSING*/ 0x06:\n            case /*HCI_ERR_HOST_REJECT_SECURITY*/ 0x0E:\n            case /*HCI_ERR_REPEATED_ATTEMPTS*/ 0x17:\n            case /*HCI_ERR_PAIRING_NOT_ALLOWED*/ 0x18:\n            case /*HCI_ERR_ENCRY_MODE_NOT_ACCEPTABLE*/ 0x25:\n            case /*HCI_ERR_UNIT_KEY_USED*/ 0x26:\n            case /*HCI_ERR_PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED*/ 0x29:\n            case /*HCI_ERR_INSUFFCIENT_SECURITY*/ 0x2F:\n            case /*HCI_ERR_HOST_BUSY_PAIRING*/ 0x38:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SECURITY;\n            case /*HCI_ERR_MEMORY_FULL*/ 0x07:\n            case /*HCI_ERR_MAX_NUM_OF_CONNECTIONS*/ 0x09:\n            case /*HCI_ERR_MAX_NUM_OF_SCOS*/ 0x0A:\n            case /*HCI_ERR_COMMAND_DISALLOWED*/ 0x0C:\n            case /*HCI_ERR_HOST_REJECT_RESOURCES*/ 0x0D:\n            case /*HCI_ERR_LIMIT_REACHED*/ 0x43:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_RESOURCE_LIMIT_REACHED;\n            case /*HCI_ERR_CONNECTION_EXISTS*/ 0x0B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_CONNECTION_ALREADY_EXISTS;\n            case /*HCI_ERR_HOST_REJECT_DEVICE*/ 0x0F:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SYSTEM_POLICY;\n            case /*HCI_ERR_ILLEGAL_PARAMETER_FMT*/ 0x12:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            case /*HCI_ERR_PEER_USER*/ 0x13:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE_REQUEST;\n            case /*HCI_ERR_CONN_CAUSE_LOCAL_HOST*/ 0x16:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL_REQUEST;\n            case /*HCI_ERR_UNSUPPORTED_REM_FEATURE*/ 0x1A:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE;\n            case /*HCI_ERR_UNACCEPT_CONN_INTERVAL*/ 0x3B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            default:\n                Log.e(TAG, \"Invalid HCI disconnect reason: \" + hciReason);\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n    }\n\n    void logUserBondResponse(BluetoothDevice device, boolean accepted, int event) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            BluetoothStatsLog.write(BluetoothStatsLog.BLUETOOTH_BOND_STATE_CHANGED,\n                    obfuscateAddress(device), 0, device.getType(),\n                    BluetoothDevice.BOND_BONDING,\n                    event,\n                    accepted ? 0 : BluetoothDevice.UNBOND_REASON_AUTH_REJECTED);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    int getDeviceAccessFromPrefs(BluetoothDevice device, String prefFile) {\n        SharedPreferences prefs = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        if (!prefs.contains(device.getAddress())) {\n            return BluetoothDevice.ACCESS_UNKNOWN;\n        }\n        return prefs.getBoolean(device.getAddress(), false)\n                ? BluetoothDevice.ACCESS_ALLOWED\n                : BluetoothDevice.ACCESS_REJECTED;\n    }\n\n    void setDeviceAccessFromPrefs(BluetoothDevice device, int value, String prefFile) {\n        SharedPreferences pref = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = pref.edit();\n        if (value == BluetoothDevice.ACCESS_UNKNOWN) {\n            editor.remove(device.getAddress());\n        } else {\n            editor.putBoolean(device.getAddress(), value == BluetoothDevice.ACCESS_ALLOWED);\n        }\n        editor.apply();\n    }\n\n    public void setPhonebookAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setMessageAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setSimAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public boolean isRpaOffloadSupported() {\n        return mAdapterProperties.isRpaOffloadSupported();\n    }\n\n    public int getNumOfOffloadedIrkSupported() {\n        return mAdapterProperties.getNumOfOffloadedIrkSupported();\n    }\n\n    public int getNumOfOffloadedScanFilterSupported() {\n        return mAdapterProperties.getNumOfOffloadedScanFilterSupported();\n    }\n\n    public int getOffloadedScanResultStorage() {\n        return mAdapterProperties.getOffloadedScanResultStorage();\n    }\n\n    public boolean isLe2MPhySupported() {\n        return mAdapterProperties.isLe2MPhySupported();\n    }\n\n    public boolean isLeCodedPhySupported() {\n        return mAdapterProperties.isLeCodedPhySupported();\n    }\n\n    public boolean isLeExtendedAdvertisingSupported() {\n        return mAdapterProperties.isLeExtendedAdvertisingSupported();\n    }\n\n    public boolean isLePeriodicAdvertisingSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast source feature is supported.\n     *\n     * @return true, if the LE audio broadcast source is supported\n     */\n    public boolean isLeAudioBroadcastSourceSupported() {\n        return  BluetoothProperties.isProfileBapBroadcastSourceEnabled().orElse(false)\n                && mAdapterProperties.isLePeriodicAdvertisingSupported()\n                && mAdapterProperties.isLeExtendedAdvertisingSupported()\n                && mAdapterProperties.isLeIsochronousBroadcasterSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast assistant feature is supported.\n     *\n     * @return true, if the LE audio broadcast assistant is supported\n     */\n    public boolean isLeAudioBroadcastAssistantSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported()\n            && mAdapterProperties.isLeExtendedAdvertisingSupported()\n            && (mAdapterProperties.isLePeriodicAdvertisingSyncTransferSenderSupported()\n                || mAdapterProperties.isLePeriodicAdvertisingSyncTransferRecipientSupported());\n    }\n\n    /**\n     * Check if the LE audio CIS central feature is supported.\n     *\n     * @return true, if the LE audio CIS central is supported\n     */\n    public boolean isLeConnectedIsochronousStreamCentralSupported() {\n        return mAdapterProperties.isLeConnectedIsochronousStreamCentralSupported();\n    }\n\n    public int getLeMaximumAdvertisingDataLength() {\n        return mAdapterProperties.getLeMaximumAdvertisingDataLength();\n    }\n\n    /**\n     * Get the maximum number of connected audio devices.\n     *\n     * @return the maximum number of connected audio devices\n     */\n    public int getMaxConnectedAudioDevices() {\n        return mAdapterProperties.getMaxConnectedAudioDevices();\n    }\n\n    /**\n     * Check whether A2DP offload is enabled.\n     *\n     * @return true if A2DP offload is enabled\n     */\n    public boolean isA2dpOffloadEnabled() {\n        return mAdapterProperties.isA2dpOffloadEnabled();\n    }\n\n    private BluetoothActivityEnergyInfo reportActivityInfo() {\n        if (mAdapterProperties.getState() != BluetoothAdapter.STATE_ON\n                || !mAdapterProperties.isActivityAndEnergyReportingSupported()) {\n            return null;\n        }\n\n        // Pull the data. The callback will notify mEnergyInfoLock.\n        readEnergyInfo();\n\n        synchronized (mEnergyInfoLock) {\n            try {\n                mEnergyInfoLock.wait(CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS);\n            } catch (InterruptedException e) {\n                // Just continue, the energy data may be stale but we won't miss anything next time\n                // we query.\n            }\n\n            final BluetoothActivityEnergyInfo info =\n                    new BluetoothActivityEnergyInfo(SystemClock.elapsedRealtime(),\n                            mStackReportedState, mTxTimeTotalMs, mRxTimeTotalMs, mIdleTimeTotalMs,\n                            mEnergyUsedTotalVoltAmpSecMicro);\n\n            // Count the number of entries that have byte counts > 0\n            int arrayLen = 0;\n            for (int i = 0; i < mUidTraffic.size(); i++) {\n                final UidTraffic traffic = mUidTraffic.valueAt(i);\n                if (traffic.getTxBytes() != 0 || traffic.getRxBytes() != 0) {\n                    arrayLen++;\n                }\n            }\n\n            // Copy the traffic objects whose byte counts are > 0\n            final List<UidTraffic> result = new ArrayList<>();\n            int putIdx = 0;\n            for (int i = 0; i < mUidTraffic.size(); i++) {\n                final UidTraffic traffic = mUidTraffic.valueAt(i);\n                if (traffic.getTxBytes() != 0 || traffic.getRxBytes() != 0) {\n                    result.add(traffic.clone());\n                }\n            }\n\n            info.setUidTraffic(result);\n\n            return info;\n        }\n    }\n\n    public int getTotalNumOfTrackableAdvertisements() {\n        return mAdapterProperties.getTotalNumOfTrackableAdvertisements();\n    }\n\n    /**\n     * Notify the UID and package name of the app, and the address of associated active device\n     *\n     * @param source The attribution source that starts the activity\n     * @param deviceAddress The address of the active device associated with the app\n     */\n    public void notifyActivityAttributionInfo(AttributionSource source, String deviceAddress) {\n        mActivityAttributionService.notifyActivityAttributionInfo(\n                source.getUid(), source.getPackageName(), deviceAddress);\n    }\n\n    private static int convertScanModeToHal(int mode) {\n        switch (mode) {\n            case BluetoothAdapter.SCAN_MODE_NONE:\n                return AbstractionLayer.BT_SCAN_MODE_NONE;\n            case BluetoothAdapter.SCAN_MODE_CONNECTABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE;\n            case BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        // errorLog(\"Incorrect scan mode in convertScanModeToHal\");\n        return -1;\n    }\n\n    static int convertScanModeFromHal(int mode) {\n        switch (mode) {\n            case AbstractionLayer.BT_SCAN_MODE_NONE:\n                return BluetoothAdapter.SCAN_MODE_NONE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE:\n                return BluetoothAdapter.SCAN_MODE_CONNECTABLE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        //errorLog(\"Incorrect scan mode in convertScanModeFromHal\");\n        return -1;\n    }\n\n    // This function is called from JNI. It allows native code to set a single wake\n    // alarm. If an alarm is already pending and a new request comes in, the alarm\n    // will be rescheduled (i.e. the previously set alarm will be cancelled).\n    private boolean setWakeAlarm(long delayMillis, boolean shouldWake) {\n        synchronized (this) {\n            if (mPendingAlarm != null) {\n                mAlarmManager.cancel(mPendingAlarm);\n            }\n\n            long wakeupTime = SystemClock.elapsedRealtime() + delayMillis;\n            int type = shouldWake ? AlarmManager.ELAPSED_REALTIME_WAKEUP\n                    : AlarmManager.ELAPSED_REALTIME;\n\n            Intent intent = new Intent(ACTION_ALARM_WAKEUP);\n            mPendingAlarm =\n                    PendingIntent.getBroadcast(this, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                            | PendingIntent.FLAG_IMMUTABLE);\n            mAlarmManager.setExact(type, wakeupTime, mPendingAlarm);\n            return true;\n        }\n    }\n\n    // This function is called from JNI. It allows native code to acquire a single wake lock.\n    // If the wake lock is already held, this function returns success. Although this function\n    // only supports acquiring a single wake lock at a time right now, it will eventually be\n    // extended to allow acquiring an arbitrary number of wake locks. The current interface\n    // takes |lockName| as a parameter in anticipation of that implementation.\n    private boolean acquireWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                mWakeLockName = lockName;\n                mWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, lockName);\n            }\n\n            if (!mWakeLock.isHeld()) {\n                mWakeLock.acquire();\n            }\n        }\n        return true;\n    }\n\n    // This function is called from JNI. It allows native code to release a wake lock acquired\n    // by |acquireWakeLock|. If the wake lock is not held, this function returns failure.\n    // Note that the release() call is also invoked by {@link #cleanup()} so a synchronization is\n    // needed here. See the comment for |acquireWakeLock| for an explanation of the interface.\n    private boolean releaseWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                errorLog(\"Repeated wake lock release; aborting release: \" + lockName);\n                return false;\n            }\n\n            if (mWakeLock.isHeld()) {\n                mWakeLock.release();\n            }\n        }\n        return true;\n    }\n\n    private void energyInfoCallback(int status, int ctrlState, long txTime, long rxTime,\n            long idleTime, long energyUsed, UidTraffic[] data) throws RemoteException {\n        if (ctrlState >= BluetoothActivityEnergyInfo.BT_STACK_STATE_INVALID\n                && ctrlState <= BluetoothActivityEnergyInfo.BT_STACK_STATE_STATE_IDLE) {\n            // Energy is product of mA, V and ms. If the chipset doesn't\n            // report it, we have to compute it from time\n            if (energyUsed == 0) {\n                try {\n                    final long txMah = Math.multiplyExact(txTime, getTxCurrentMa());\n                    final long rxMah = Math.multiplyExact(rxTime, getRxCurrentMa());\n                    final long idleMah = Math.multiplyExact(idleTime, getIdleCurrentMa());\n                    energyUsed = (long) (Math.addExact(Math.addExact(txMah, rxMah), idleMah)\n                            * getOperatingVolt());\n                } catch (ArithmeticException e) {\n                    Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                    // Energy is already 0 if the exception was thrown.\n                }\n            }\n\n            synchronized (mEnergyInfoLock) {\n                mStackReportedState = ctrlState;\n                long totalTxTimeMs;\n                long totalRxTimeMs;\n                long totalIdleTimeMs;\n                long totalEnergy;\n                try {\n                    totalTxTimeMs = Math.addExact(mTxTimeTotalMs, txTime);\n                    totalRxTimeMs = Math.addExact(mRxTimeTotalMs, rxTime);\n                    totalIdleTimeMs = Math.addExact(mIdleTimeTotalMs, idleTime);\n                    totalEnergy = Math.addExact(mEnergyUsedTotalVoltAmpSecMicro, energyUsed);\n                } catch (ArithmeticException e) {\n                    // This could be because we accumulated a lot of time, or we got a very strange\n                    // value from the controller (more likely). Discard this data.\n                    Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                    totalTxTimeMs = mTxTimeTotalMs;\n                    totalRxTimeMs = mRxTimeTotalMs;\n                    totalIdleTimeMs = mIdleTimeTotalMs;\n                    totalEnergy = mEnergyUsedTotalVoltAmpSecMicro;\n                }\n\n                mTxTimeTotalMs = totalTxTimeMs;\n                mRxTimeTotalMs = totalRxTimeMs;\n                mIdleTimeTotalMs = totalIdleTimeMs;\n                mEnergyUsedTotalVoltAmpSecMicro = totalEnergy;\n\n                for (UidTraffic traffic : data) {\n                    UidTraffic existingTraffic = mUidTraffic.get(traffic.getUid());\n                    if (existingTraffic == null) {\n                        mUidTraffic.put(traffic.getUid(), traffic);\n                    } else {\n                        existingTraffic.addRxBytes(traffic.getRxBytes());\n                        existingTraffic.addTxBytes(traffic.getTxBytes());\n                    }\n                }\n                mEnergyInfoLock.notifyAll();\n            }\n        }\n\n        verboseLog(\"energyInfoCallback() status = \" + status + \"txTime = \" + txTime + \"rxTime = \"\n                + rxTime + \"idleTime = \" + idleTime + \"energyUsed = \" + energyUsed + \"ctrlState = \"\n                + ctrlState + \"traffic = \" + Arrays.toString(data));\n    }\n\n    /**\n     * Update metadata change to registered listeners\n     */\n    @VisibleForTesting\n    public void metadataChanged(String address, int key, byte[] value) {\n        BluetoothDevice device = mRemoteDevices.getDevice(Utils.getBytesFromAddress(address));\n        if (mMetadataListeners.containsKey(device)) {\n            ArrayList<IBluetoothMetadataListener> list = mMetadataListeners.get(device);\n            for (IBluetoothMetadataListener listener : list) {\n                try {\n                    listener.onMetadataChanged(device, key, value);\n                } catch (RemoteException e) {\n                    Log.w(TAG, \"RemoteException when onMetadataChanged\");\n                }\n            }\n        }\n    }\n\n    private int getIdleCurrentMa() {\n        return BluetoothProperties.getHardwareIdleCurrentMa().orElse(0);\n    }\n\n    private int getTxCurrentMa() {\n        return BluetoothProperties.getHardwareTxCurrentMa().orElse(0);\n    }\n\n    private int getRxCurrentMa() {\n        return BluetoothProperties.getHardwareRxCurrentMa().orElse(0);\n    }\n\n    private double getOperatingVolt() {\n        return BluetoothProperties.getHardwareOperatingVoltageMv().orElse(0) / 1000.0;\n    }\n\n    @VisibleForTesting\n    protected RemoteDevices getRemoteDevices() {\n        return mRemoteDevices;\n    }\n\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        if (args.length == 0) {\n            writer.println(\"Skipping dump in APP SERVICES, see bluetooth_manager section.\");\n            writer.println(\"Use --print argument for dumpsys direct from AdapterService.\");\n            return;\n        }\n\n        if (\"set-test-mode\".equals(args[0])) {\n            final boolean testModeEnabled = \"enabled\".equalsIgnoreCase(args[1]);\n            for (ProfileService profile : mRunningProfiles) {\n                profile.setTestModeEnabled(testModeEnabled);\n            }\n            mTestModeEnabled = testModeEnabled;\n            return;\n        }\n\n        verboseLog(\"dumpsys arguments, check for protobuf output: \" + TextUtils.join(\" \", args));\n        if (args[0].equals(\"--proto-bin\")) {\n            dumpMetrics(fd);\n            return;\n        }\n\n        writer.println();\n        mAdapterProperties.dump(fd, writer, args);\n        writer.println(\"mSnoopLogSettingAtEnable = \" + mSnoopLogSettingAtEnable);\n        writer.println(\"mDefaultSnoopLogSettingAtEnable = \" + mDefaultSnoopLogSettingAtEnable);\n\n        writer.println();\n        writer.println(\"Enabled Profile Services:\");\n        for (Class profile : Config.getSupportedProfiles()) {\n            writer.println(\"  \" + profile.getSimpleName());\n        }\n        writer.println();\n\n        mAdapterStateMachine.dump(fd, writer, args);\n\n        StringBuilder sb = new StringBuilder();\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dump(sb);\n        }\n        mSilenceDeviceManager.dump(fd, writer, args);\n        mDatabaseManager.dump(writer);\n\n        writer.write(sb.toString());\n        writer.flush();\n\n        dumpNative(fd, args);\n    }\n\n    private void dumpMetrics(FileDescriptor fd) {\n        BluetoothMetricsProto.BluetoothLog.Builder metricsBuilder =\n                BluetoothMetricsProto.BluetoothLog.newBuilder();\n        byte[] nativeMetricsBytes = dumpMetricsNative();\n        debugLog(\"dumpMetrics: native metrics size is \" + nativeMetricsBytes.length);\n        if (nativeMetricsBytes.length > 0) {\n            try {\n                metricsBuilder.mergeFrom(nativeMetricsBytes);\n            } catch (InvalidProtocolBufferException ex) {\n                Log.w(TAG, \"dumpMetrics: problem parsing metrics protobuf, \" + ex.getMessage());\n                return;\n            }\n        }\n        metricsBuilder.setNumBondedDevices(getBondedDevices().length);\n        MetricsLogger.dumpProto(metricsBuilder);\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dumpProto(metricsBuilder);\n        }\n        byte[] metricsBytes = Base64.encode(metricsBuilder.build().toByteArray(), Base64.DEFAULT);\n        debugLog(\"dumpMetrics: combined metrics size is \" + metricsBytes.length);\n        try (FileOutputStream protoOut = new FileOutputStream(fd)) {\n            protoOut.write(metricsBytes);\n        } catch (IOException e) {\n            errorLog(\"dumpMetrics: error writing combined protobuf to fd, \" + e.getMessage());\n        }\n    }\n\n    private void debugLog(String msg) {\n        if (DBG) {\n            Log.d(TAG, msg);\n        }\n    }\n\n    private void verboseLog(String msg) {\n        if (VERBOSE) {\n            Log.v(TAG, msg);\n        }\n    }\n\n    private void errorLog(String msg) {\n        Log.e(TAG, msg);\n    }\n\n    private final BroadcastReceiver mAlarmBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            synchronized (AdapterService.this) {\n                mPendingAlarm = null;\n                alarmFiredNative();\n            }\n        }\n    };\n\n    private boolean isCommonCriteriaMode() {\n        return getSystemService(DevicePolicyManager.class).isCommonCriteriaModeEnabled(null);\n    }\n\n    @SuppressLint(\"AndroidFrameworkRequiresPermission\")\n    private void enforceBluetoothPrivilegedPermissionIfNeeded(OobData remoteP192Data,\n            OobData remoteP256Data) {\n        if (remoteP192Data != null || remoteP256Data != null) {\n            enforceBluetoothPrivilegedPermission(this);\n        }\n    }\n\n    // Boolean flags\n    private static final String GD_CORE_FLAG = \"INIT_gd_core\";\n    private static final String GD_ADVERTISING_FLAG = \"INIT_gd_advertising\";\n    private static final String GD_SCANNING_FLAG = \"INIT_gd_scanning\";\n    private static final String GD_HCI_FLAG = \"INIT_gd_hci\";\n    private static final String GD_CONTROLLER_FLAG = \"INIT_gd_controller\";\n    private static final String GD_ACL_FLAG = \"INIT_gd_acl\";\n    private static final String GD_L2CAP_FLAG = \"INIT_gd_l2cap\";\n    private static final String GD_RUST_FLAG = \"INIT_gd_rust\";\n    private static final String GD_LINK_POLICY_FLAG = \"INIT_gd_link_policy\";\n    private static final String GATT_ROBUST_CACHING_FLAG = \"INIT_gatt_robust_caching\";\n    private static final String IRK_ROTATION_FLAG = \"INIT_irk_rotation\";\n\n    /**\n     * Logging flags logic (only applies to DEBUG and VERBOSE levels):\n     * if LOG_TAG in LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG:\n     *   DO NOT LOG\n     * else if LOG_TAG in LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG:\n     *   DO LOG\n     * else if LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG:\n     *   DO LOG\n     * else:\n     *   DO NOT LOG\n     */\n    private static final String LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG =\n            \"INIT_logging_debug_enabled_for_all\";\n    // String flags\n    // Comma separated tags\n    private static final String LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG =\n            \"INIT_logging_debug_enabled_for_tags\";\n    private static final String LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG =\n            \"INIT_logging_debug_disabled_for_tags\";\n    private static final String BTAA_HCI_LOG_FLAG = \"INIT_btaa_hci\";\n\n    private String[] getInitFlags() {\n        ArrayList<String> initFlags = new ArrayList<>();\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_CORE_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_CORE_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_ADVERTISING_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_ADVERTISING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_SCANNING_FLAG,\n                Config.isGdEnabledUpToScanningLayer())) {\n            initFlags.add(String.format(\"%s=%s\", GD_SCANNING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_HCI_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_HCI_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_CONTROLLER_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_CONTROLLER_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_ACL_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_ACL_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_L2CAP_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_L2CAP_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_RUST_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_RUST_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_LINK_POLICY_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_LINK_POLICY_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH,\n                GATT_ROBUST_CACHING_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GATT_ROBUST_CACHING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, IRK_ROTATION_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", IRK_ROTATION_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG, \"true\"));\n        }\n        String debugLoggingEnabledTags = DeviceConfig.getString(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG, \"\");\n        if (!debugLoggingEnabledTags.isEmpty()) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG,\n                    debugLoggingEnabledTags));\n        }\n        String debugLoggingDisabledTags = DeviceConfig.getString(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG, \"\");\n        if (!debugLoggingDisabledTags.isEmpty()) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG,\n                    debugLoggingDisabledTags));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, BTAA_HCI_LOG_FLAG, true)) {\n            initFlags.add(String.format(\"%s=%s\", BTAA_HCI_LOG_FLAG, \"true\"));\n        }\n        return initFlags.toArray(new String[0]);\n    }\n\n    private final Object mDeviceConfigLock = new Object();\n\n    /**\n     * Predicate that can be applied to names to determine if a device is\n     * well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<String> mLocationDenylistName = (v) -> false;\n\n    /**\n     * Predicate that can be applied to MAC addresses to determine if a device\n     * is well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistMac = (v) -> false;\n\n    /**\n     * Predicate that can be applied to Advertising Data payloads to determine\n     * if a device is well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistAdvertisingData = (v) -> false;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanQuotaCount = DeviceConfigListener.DEFAULT_SCAN_QUOTA_COUNT;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanQuotaWindowMillis = DeviceConfigListener.DEFAULT_SCAN_QUOTA_WINDOW_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanTimeoutMillis = DeviceConfigListener.DEFAULT_SCAN_TIMEOUT_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanUpgradeDurationMillis =\n            DeviceConfigListener.DEFAULT_SCAN_UPGRADE_DURATION_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS;\n\n    public @NonNull Predicate<String> getLocationDenylistName() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistName;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistMac() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistMac;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistAdvertisingData() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistAdvertisingData;\n        }\n    }\n\n    public static int getScanQuotaCount() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_QUOTA_COUNT;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanQuotaCount;\n        }\n    }\n\n    public static long getScanQuotaWindowMillis() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_QUOTA_WINDOW_MILLIS;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanQuotaWindowMillis;\n        }\n    }\n\n    public static long getScanTimeoutMillis() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_TIMEOUT_MILLIS;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanTimeoutMillis;\n        }\n    }\n\n    /**\n     * Returns scan upgrade duration in millis.\n     */\n    public long getScanUpgradeDurationMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScanUpgradeDurationMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF_BALANCED scan window in millis.\n     */\n    public int getScreenOffBalancedWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedWindowMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF_BALANCED scan interval in millis.\n     */\n    public int getScreenOffBalancedIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedIntervalMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF low power scan window in millis.\n     */\n    public int getScreenOffLowPowerWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerWindowMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF low power scan interval in millis.\n     */\n    public int getScreenOffLowPowerIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerIntervalMillis;\n        }\n    }\n\n    private final DeviceConfigListener mDeviceConfigListener = new DeviceConfigListener();\n\n    private class DeviceConfigListener implements DeviceConfig.OnPropertiesChangedListener {\n        private static final String LOCATION_DENYLIST_NAME =\n                \"location_denylist_name\";\n        private static final String LOCATION_DENYLIST_MAC =\n                \"location_denylist_mac\";\n        private static final String LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"location_denylist_advertising_data\";\n        private static final String SCAN_QUOTA_COUNT =\n                \"scan_quota_count\";\n        private static final String SCAN_QUOTA_WINDOW_MILLIS =\n                \"scan_quota_window_millis\";\n        private static final String SCAN_TIMEOUT_MILLIS =\n                \"scan_timeout_millis\";\n        private static final String SCAN_UPGRADE_DURATION_MILLIS =\n                \"scan_upgrade_duration_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_WINDOW_MILLIS =\n                \"screen_off_low_power_window_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS =\n                \"screen_off_low_power_interval_millis\";\n        private static final String SCREEN_OFF_BALANCED_WINDOW_MILLIS =\n                \"screen_off_balanced_window_millis\";\n        private static final String SCREEN_OFF_BALANCED_INTERVAL_MILLIS =\n                \"screen_off_balanced_interval_millis\";\n\n        /**\n         * Default denylist which matches Eddystone and iBeacon payloads.\n         */\n        private static final String DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"\u22860016AAFE/00FFFFFF,\u228600FF4C0002/00FFFFFFFF\";\n\n        private static final int DEFAULT_SCAN_QUOTA_COUNT = 5;\n        private static final long DEFAULT_SCAN_QUOTA_WINDOW_MILLIS = 30 * SECOND_IN_MILLIS;\n        private static final long DEFAULT_SCAN_TIMEOUT_MILLIS = 30 * MINUTE_IN_MILLIS;\n        private static final int DEFAULT_SCAN_UPGRADE_DURATION_MILLIS = (int) SECOND_IN_MILLIS * 6;\n\n        public void start() {\n            DeviceConfig.addOnPropertiesChangedListener(DeviceConfig.NAMESPACE_BLUETOOTH,\n                    BackgroundThread.getExecutor(), this);\n            onPropertiesChanged(DeviceConfig.getProperties(DeviceConfig.NAMESPACE_BLUETOOTH));\n        }\n\n        @Override\n        public void onPropertiesChanged(DeviceConfig.Properties properties) {\n            synchronized (mDeviceConfigLock) {\n                final String name = properties.getString(LOCATION_DENYLIST_NAME, null);\n                mLocationDenylistName = !TextUtils.isEmpty(name)\n                        ? Pattern.compile(name).asPredicate()\n                        : (v) -> false;\n                mLocationDenylistMac = BytesMatcher\n                        .decode(properties.getString(LOCATION_DENYLIST_MAC, null));\n                mLocationDenylistAdvertisingData = BytesMatcher\n                        .decode(properties.getString(LOCATION_DENYLIST_ADVERTISING_DATA,\n                                DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA));\n                mScanQuotaCount = properties.getInt(SCAN_QUOTA_COUNT,\n                        DEFAULT_SCAN_QUOTA_COUNT);\n                mScanQuotaWindowMillis = properties.getLong(SCAN_QUOTA_WINDOW_MILLIS,\n                        DEFAULT_SCAN_QUOTA_WINDOW_MILLIS);\n                mScanTimeoutMillis = properties.getLong(SCAN_TIMEOUT_MILLIS,\n                        DEFAULT_SCAN_TIMEOUT_MILLIS);\n                mScanUpgradeDurationMillis = properties.getInt(SCAN_UPGRADE_DURATION_MILLIS,\n                        DEFAULT_SCAN_UPGRADE_DURATION_MILLIS);\n                mScreenOffLowPowerWindowMillis = properties.getInt(\n                        SCREEN_OFF_LOW_POWER_WINDOW_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS);\n                mScreenOffLowPowerIntervalMillis = properties.getInt(\n                        SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS);\n                mScreenOffBalancedWindowMillis = properties.getInt(\n                        SCREEN_OFF_BALANCED_WINDOW_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS);\n                mScreenOffBalancedIntervalMillis = properties.getInt(\n                        SCREEN_OFF_BALANCED_INTERVAL_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS);\n            }\n        }\n    }\n\n    /**\n     *  Obfuscate Bluetooth MAC address into a PII free ID string\n     *\n     *  @param device Bluetooth device whose MAC address will be obfuscated\n     *  @return a byte array that is unique to this MAC address on this device,\n     *          or empty byte array when either device is null or obfuscateAddressNative fails\n     */\n    public byte[] obfuscateAddress(BluetoothDevice device) {\n        if (device == null) {\n            return new byte[0];\n        }\n        return obfuscateAddressNative(Utils.getByteAddress(device));\n    }\n\n    /**\n     * Get dynamic audio buffer size supported type\n     *\n     * @return support <p>Possible values are\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_NONE},\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_OFFLOAD},\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_SOFTWARE_ENCODING}.\n     */\n    public int getDynamicBufferSupport() {\n        return mAdapterProperties.getDynamicBufferSupport();\n    }\n\n    /**\n     * Get dynamic audio buffer size\n     *\n     * @return BufferConstraints\n     */\n    public BufferConstraints getBufferConstraints() {\n        return mAdapterProperties.getBufferConstraints();\n    }\n\n    /**\n     * Set dynamic audio buffer size\n     *\n     * @param codec Audio codec\n     * @param value buffer millis\n     * @return true if the settings is successful, false otherwise\n     */\n    public boolean setBufferLengthMillis(int codec, int value) {\n        return mAdapterProperties.setBufferLengthMillis(codec, value);\n    }\n\n    /**\n     *  Get an incremental id of Bluetooth metrics and log\n     *\n     *  @param device Bluetooth device\n     *  @return int of id for Bluetooth metrics and logging, 0 if the device is invalid\n     */\n    public int getMetricId(BluetoothDevice device) {\n        if (device == null) {\n            return 0;\n        }\n        return getMetricIdNative(Utils.getByteAddress(device));\n    }\n\n    /**\n     *  Allow audio low latency\n     *\n     *  @param allowed true if audio low latency is being allowed\n     *  @param device device whose audio low latency will be allowed or disallowed\n     *  @return boolean true if audio low latency is successfully allowed or disallowed\n     */\n    public boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n        return allowLowLatencyAudioNative(allowed, Utils.getByteAddress(device));\n    }\n\n    /**\n     * Sets the battery level of the remote device\n     */\n    public void setBatteryLevel(BluetoothDevice device, int batteryLevel) {\n        mRemoteDevices.updateBatteryLevel(device, batteryLevel);\n    }\n\n    static native void classInitNative();\n\n    native boolean initNative(boolean startRestricted, boolean isCommonCriteriaMode,\n            int configCompareResult, String[] initFlags, boolean isAtvDevice,\n            String userDataDirectory);\n\n    native void cleanupNative();\n\n    /*package*/\n    native boolean enableNative();\n\n    /*package*/\n    native boolean disableNative();\n\n    /*package*/\n    native boolean setAdapterPropertyNative(int type, byte[] val);\n\n    /*package*/\n    native boolean getAdapterPropertiesNative();\n\n    /*package*/\n    native boolean getAdapterPropertyNative(int type);\n\n    /*package*/\n    native boolean setAdapterPropertyNative(int type);\n\n    /*package*/\n    native boolean setDevicePropertyNative(byte[] address, int type, byte[] val);\n\n    /*package*/\n    native boolean getDevicePropertyNative(byte[] address, int type);\n\n    /*package*/\n    public native boolean createBondNative(byte[] address, int transport);\n\n    /*package*/\n    native boolean createBondOutOfBandNative(byte[] address, int transport,\n            OobData p192Data, OobData p256Data);\n\n    /*package*/\n    public native boolean removeBondNative(byte[] address);\n\n    /*package*/\n    native boolean cancelBondNative(byte[] address);\n\n    /*package*/\n    native void generateLocalOobDataNative(int transport);\n\n    /*package*/\n    native boolean sdpSearchNative(byte[] address, byte[] uuid);\n\n    /*package*/\n    native int getConnectionStateNative(byte[] address);\n\n    private native boolean startDiscoveryNative();\n\n    private native boolean cancelDiscoveryNative();\n\n    private native boolean pinReplyNative(byte[] address, boolean accept, int len, byte[] pin);\n\n    private native boolean sspReplyNative(byte[] address, int type, boolean accept, int passkey);\n\n    /*package*/\n    native boolean getRemoteServicesNative(byte[] address, int transport);\n\n    /*package*/\n    native boolean getRemoteMasInstancesNative(byte[] address);\n\n    private native int readEnergyInfo();\n\n    /*package*/\n    native boolean factoryResetNative();\n\n    private native void alarmFiredNative();\n\n    private native void dumpNative(FileDescriptor fd, String[] arguments);\n\n    private native byte[] dumpMetricsNative();\n\n    private native byte[] obfuscateAddressNative(byte[] address);\n\n    native boolean setBufferLengthMillisNative(int codec, int value);\n\n    private native int getMetricIdNative(byte[] address);\n\n    /*package*/ native int connectSocketNative(\n            byte[] address, int type, byte[] uuid, int port, int flag, int callingUid);\n\n    /*package*/ native int createSocketChannelNative(\n            int type, String serviceName, byte[] uuid, int port, int flag, int callingUid);\n\n    /*package*/ native void requestMaximumTxDataLengthNative(byte[] address);\n\n    private native boolean allowLowLatencyAudioNative(boolean allowed, byte[] address);\n\n    // Returns if this is a mock object. This is currently used in testing so that we may not call\n    // System.exit() while finalizing the object. Otherwise GC of mock objects unfortunately ends up\n    // calling finalize() which in turn calls System.exit() and the process crashes.\n    //\n    // Mock this in your testing framework to return true to avoid the mentioned behavior. In\n    // production this has no effect.\n    public boolean isMock() {\n        return false;\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 44183,
                                        "general": {
                                            "word_based": 15796,
                                            "char_based": 58930
                                        },
                                        "gemini": 52360
                                    }
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-382775095",
            "aliases": [
                "A-382775095",
                "CVE-2025-0078"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-382775095",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "90b14eab96ef0de6f91375a2d55768798ce11059"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 90b14eab96ef0de6f91375a2d55768798ce11059 Mon Sep 17 00:00:00 2001\nFrom: Steven Moreland <smoreland@google.com>\nDate: Fri, 6 Dec 2024 23:55:35 +0000\nSubject: [PATCH] servicemanager: set consistent flags for self-reg\n\nSM has special flags set to become a context object, but\nthese were not set when it registers as itself.\n\nBug: 382775095\nTest: boot w/ harsher checks\nChange-Id: I0fb567cbcca67a2fc6c088f652c8af570b8d7e53\n---\n cmds/servicemanager/main.cpp | 1 +\n 1 file changed, 1 insertion(+)\n\ndiff --git a/cmds/servicemanager/main.cpp b/cmds/servicemanager/main.cpp\nindex c126e91373..df5a8ed0d1 100644\n--- a/cmds/servicemanager/main.cpp\n+++ b/cmds/servicemanager/main.cpp\n@@ -165,6 +165,7 @@ int main(int argc, char** argv) {\n     IPCThreadState::self()->disableBackgroundScheduling(true);\n \n     sp<ServiceManager> manager = sp<ServiceManager>::make(std::make_unique<Access>());\n+    manager->setRequestingSid(true);\n     if (!manager->addService(\"manager\", manager, false /*allowIsolated*/, IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT).isOk()) {\n         LOG(ERROR) << \"Could not self register servicemanager\";\n     }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 368,
                        "general": {
                            "word_based": 148,
                            "char_based": 288
                        },
                        "gemini": 454
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "6c86b6c926ab527eb88804711beb4bd09e348e06",
                            "repo_path": "android_repos/native",
                            "result": "success",
                            "downstream_patch_content": "commit 6c86b6c926ab527eb88804711beb4bd09e348e06\nAuthor: Steven Moreland <smoreland@google.com>\nDate:   Fri Dec 6 23:55:35 2024 +0000\n\n    servicemanager: set consistent flags for self-reg\n    \n    SM has special flags set to become a context object, but\n    these were not set when it registers as itself.\n    \n    Bug: 382775095\n    Test: boot w/ harsher checks\n    Merged-In: I0fb567cbcca67a2fc6c088f652c8af570b8d7e53\n    Change-Id: I0fb567cbcca67a2fc6c088f652c8af570b8d7e53\n\ndiff --git a/cmds/servicemanager/main.cpp b/cmds/servicemanager/main.cpp\nindex 8c1beaca20..d8cc8e6a20 100644\n--- a/cmds/servicemanager/main.cpp\n+++ b/cmds/servicemanager/main.cpp\n@@ -122,6 +122,7 @@ int main(int argc, char** argv) {\n     ps->setCallRestriction(ProcessState::CallRestriction::FATAL_IF_NOT_ONEWAY);\n \n     sp<ServiceManager> manager = sp<ServiceManager>::make(std::make_unique<Access>());\n+    manager->setRequestingSid(true);\n     if (!manager->addService(\"manager\", manager, false /*allowIsolated*/, IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT).isOk()) {\n         LOG(ERROR) << \"Could not self register servicemanager\";\n     }\n",
                            "downstream_patch_tokens": {
                                "openai": 361,
                                "general": {
                                    "word_based": 127,
                                    "char_based": 280
                                },
                                "gemini": 445
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "6c86b6c926ab527eb88804711beb4bd09e348e06",
                            "repo_path": "android_repos/native",
                            "result": "success",
                            "downstream_patch_content": "commit 6c86b6c926ab527eb88804711beb4bd09e348e06\nAuthor: Steven Moreland <smoreland@google.com>\nDate:   Fri Dec 6 23:55:35 2024 +0000\n\n    servicemanager: set consistent flags for self-reg\n    \n    SM has special flags set to become a context object, but\n    these were not set when it registers as itself.\n    \n    Bug: 382775095\n    Test: boot w/ harsher checks\n    Merged-In: I0fb567cbcca67a2fc6c088f652c8af570b8d7e53\n    Change-Id: I0fb567cbcca67a2fc6c088f652c8af570b8d7e53\n\ndiff --git a/cmds/servicemanager/main.cpp b/cmds/servicemanager/main.cpp\nindex 8c1beaca20..d8cc8e6a20 100644\n--- a/cmds/servicemanager/main.cpp\n+++ b/cmds/servicemanager/main.cpp\n@@ -122,6 +122,7 @@ int main(int argc, char** argv) {\n     ps->setCallRestriction(ProcessState::CallRestriction::FATAL_IF_NOT_ONEWAY);\n \n     sp<ServiceManager> manager = sp<ServiceManager>::make(std::make_unique<Access>());\n+    manager->setRequestingSid(true);\n     if (!manager->addService(\"manager\", manager, false /*allowIsolated*/, IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT).isOk()) {\n         LOG(ERROR) << \"Could not self register servicemanager\";\n     }\n",
                            "downstream_patch_tokens": {
                                "openai": 361,
                                "general": {
                                    "word_based": 127,
                                    "char_based": 280
                                },
                                "gemini": 445
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "6c86b6c926ab527eb88804711beb4bd09e348e06",
                            "repo_path": "android_repos/native",
                            "result": "success",
                            "downstream_patch_content": "commit 6c86b6c926ab527eb88804711beb4bd09e348e06\nAuthor: Steven Moreland <smoreland@google.com>\nDate:   Fri Dec 6 23:55:35 2024 +0000\n\n    servicemanager: set consistent flags for self-reg\n    \n    SM has special flags set to become a context object, but\n    these were not set when it registers as itself.\n    \n    Bug: 382775095\n    Test: boot w/ harsher checks\n    Merged-In: I0fb567cbcca67a2fc6c088f652c8af570b8d7e53\n    Change-Id: I0fb567cbcca67a2fc6c088f652c8af570b8d7e53\n\ndiff --git a/cmds/servicemanager/main.cpp b/cmds/servicemanager/main.cpp\nindex 8c1beaca20..d8cc8e6a20 100644\n--- a/cmds/servicemanager/main.cpp\n+++ b/cmds/servicemanager/main.cpp\n@@ -122,6 +122,7 @@ int main(int argc, char** argv) {\n     ps->setCallRestriction(ProcessState::CallRestriction::FATAL_IF_NOT_ONEWAY);\n \n     sp<ServiceManager> manager = sp<ServiceManager>::make(std::make_unique<Access>());\n+    manager->setRequestingSid(true);\n     if (!manager->addService(\"manager\", manager, false /*allowIsolated*/, IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT).isOk()) {\n         LOG(ERROR) << \"Could not self register servicemanager\";\n     }\n",
                            "downstream_patch_tokens": {
                                "openai": 361,
                                "general": {
                                    "word_based": 127,
                                    "char_based": 280
                                },
                                "gemini": 445
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "6c86b6c926ab527eb88804711beb4bd09e348e06",
                            "repo_path": "android_repos/native",
                            "result": "success",
                            "downstream_patch_content": "commit 6c86b6c926ab527eb88804711beb4bd09e348e06\nAuthor: Steven Moreland <smoreland@google.com>\nDate:   Fri Dec 6 23:55:35 2024 +0000\n\n    servicemanager: set consistent flags for self-reg\n    \n    SM has special flags set to become a context object, but\n    these were not set when it registers as itself.\n    \n    Bug: 382775095\n    Test: boot w/ harsher checks\n    Merged-In: I0fb567cbcca67a2fc6c088f652c8af570b8d7e53\n    Change-Id: I0fb567cbcca67a2fc6c088f652c8af570b8d7e53\n\ndiff --git a/cmds/servicemanager/main.cpp b/cmds/servicemanager/main.cpp\nindex 8c1beaca20..d8cc8e6a20 100644\n--- a/cmds/servicemanager/main.cpp\n+++ b/cmds/servicemanager/main.cpp\n@@ -122,6 +122,7 @@ int main(int argc, char** argv) {\n     ps->setCallRestriction(ProcessState::CallRestriction::FATAL_IF_NOT_ONEWAY);\n \n     sp<ServiceManager> manager = sp<ServiceManager>::make(std::make_unique<Access>());\n+    manager->setRequestingSid(true);\n     if (!manager->addService(\"manager\", manager, false /*allowIsolated*/, IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT).isOk()) {\n         LOG(ERROR) << \"Could not self register servicemanager\";\n     }\n",
                            "downstream_patch_tokens": {
                                "openai": 361,
                                "general": {
                                    "word_based": 127,
                                    "char_based": 280
                                },
                                "gemini": 445
                            }
                        }
                    ]
                }
            ]
        },
        {
            "id": "ASB-A-370831157",
            "aliases": [
                "A-370831157",
                "CVE-2024-49745"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-370831157",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "608524d462278c2c9f6716cd94f126c85e9f2e91"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 608524d462278c2c9f6716cd94f126c85e9f2e91 Mon Sep 17 00:00:00 2001\nFrom: Steven Moreland <smoreland@google.com>\nDate: Wed, 2 Oct 2024 01:00:23 +0000\nSubject: [PATCH] libbinder: Parcel: grow rejects large data pos\n\nThis is unexpected behavior so throw an error.\nAllocating this much memory may cause OOM or\nother issues.\n\nBug: 370831157\nTest: fuzzer\nChange-Id: Iea0884ca61b08e52e6a6e9c66693e427cb5536f4\n---\n libs/binder/Parcel.cpp | 8 ++++++++\n 1 file changed, 8 insertions(+)\n\ndiff --git a/libs/binder/Parcel.cpp b/libs/binder/Parcel.cpp\nindex 37113629a8..3d36f2eed7 100644\n--- a/libs/binder/Parcel.cpp\n+++ b/libs/binder/Parcel.cpp\n@@ -2948,6 +2948,14 @@ status_t Parcel::growData(size_t len)\n         return BAD_VALUE;\n     }\n \n+    if (mDataPos > mDataSize) {\n+        // b/370831157 - this case used to abort. We also don't expect mDataPos < mDataSize, but\n+        // this would only waste a bit of memory, so it's okay.\n+        ALOGE(\"growData only expected at the end of a Parcel. pos: %zu, size: %zu, capacity: %zu\",\n+              mDataPos, len, mDataCapacity);\n+        return BAD_VALUE;\n+    }\n+\n     if (len > SIZE_MAX - mDataSize) return NO_MEMORY; // overflow\n     if (mDataSize + len > SIZE_MAX / 3) return NO_MEMORY; // overflow\n     size_t newSize = ((mDataSize+len)*3)/2;\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 442,
                        "general": {
                            "word_based": 183,
                            "char_based": 330
                        },
                        "gemini": 550
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "0db4fced4d2c8325c93f61ac4ab385b47e041f23",
                            "repo_path": "android_repos/native",
                            "result": "success",
                            "downstream_patch_content": "commit 0db4fced4d2c8325c93f61ac4ab385b47e041f23\nAuthor: Steven Moreland <smoreland@google.com>\nDate:   Wed Oct 2 01:00:23 2024 +0000\n\n    libbinder: Parcel: grow rejects large data pos\n    \n    This is unexpected behavior so throw an error.\n    Allocating this much memory may cause OOM or\n    other issues.\n    \n    Bug: 370831157\n    Test: fuzzer\n    Merged-In: Iea0884ca61b08e52e6a6e9c66693e427cb5536f4\n    Change-Id: Iea0884ca61b08e52e6a6e9c66693e427cb5536f4\n    (cherry picked from commit 608524d462278c2c9f6716cd94f126c85e9f2e91)\n\ndiff --git a/libs/binder/Parcel.cpp b/libs/binder/Parcel.cpp\nindex 617708f3d4..abdd4875af 100644\n--- a/libs/binder/Parcel.cpp\n+++ b/libs/binder/Parcel.cpp\n@@ -2253,6 +2253,14 @@ status_t Parcel::growData(size_t len)\n         return BAD_VALUE;\n     }\n \n+    if (mDataPos > mDataSize) {\n+        // b/370831157 - this case used to abort. We also don't expect mDataPos < mDataSize, but\n+        // this would only waste a bit of memory, so it's okay.\n+        ALOGE(\"growData only expected at the end of a Parcel. pos: %zu, size: %zu, capacity: %zu\",\n+              mDataPos, len, mDataCapacity);\n+        return BAD_VALUE;\n+    }\n+\n     if (len > SIZE_MAX - mDataSize) return NO_MEMORY; // overflow\n     if (mDataSize + len > SIZE_MAX / 3) return NO_MEMORY; // overflow\n     size_t newSize = ((mDataSize+len)*3)/2;\n",
                            "downstream_patch_tokens": {
                                "openai": 459,
                                "general": {
                                    "word_based": 166,
                                    "char_based": 337
                                },
                                "gemini": 580
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "0db4fced4d2c8325c93f61ac4ab385b47e041f23",
                            "repo_path": "android_repos/native",
                            "result": "success",
                            "downstream_patch_content": "commit 0db4fced4d2c8325c93f61ac4ab385b47e041f23\nAuthor: Steven Moreland <smoreland@google.com>\nDate:   Wed Oct 2 01:00:23 2024 +0000\n\n    libbinder: Parcel: grow rejects large data pos\n    \n    This is unexpected behavior so throw an error.\n    Allocating this much memory may cause OOM or\n    other issues.\n    \n    Bug: 370831157\n    Test: fuzzer\n    Merged-In: Iea0884ca61b08e52e6a6e9c66693e427cb5536f4\n    Change-Id: Iea0884ca61b08e52e6a6e9c66693e427cb5536f4\n    (cherry picked from commit 608524d462278c2c9f6716cd94f126c85e9f2e91)\n\ndiff --git a/libs/binder/Parcel.cpp b/libs/binder/Parcel.cpp\nindex 617708f3d4..abdd4875af 100644\n--- a/libs/binder/Parcel.cpp\n+++ b/libs/binder/Parcel.cpp\n@@ -2253,6 +2253,14 @@ status_t Parcel::growData(size_t len)\n         return BAD_VALUE;\n     }\n \n+    if (mDataPos > mDataSize) {\n+        // b/370831157 - this case used to abort. We also don't expect mDataPos < mDataSize, but\n+        // this would only waste a bit of memory, so it's okay.\n+        ALOGE(\"growData only expected at the end of a Parcel. pos: %zu, size: %zu, capacity: %zu\",\n+              mDataPos, len, mDataCapacity);\n+        return BAD_VALUE;\n+    }\n+\n     if (len > SIZE_MAX - mDataSize) return NO_MEMORY; // overflow\n     if (mDataSize + len > SIZE_MAX / 3) return NO_MEMORY; // overflow\n     size_t newSize = ((mDataSize+len)*3)/2;\n",
                            "downstream_patch_tokens": {
                                "openai": 459,
                                "general": {
                                    "word_based": 166,
                                    "char_based": 337
                                },
                                "gemini": 580
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "0db4fced4d2c8325c93f61ac4ab385b47e041f23",
                            "repo_path": "android_repos/native",
                            "result": "success",
                            "downstream_patch_content": "commit 0db4fced4d2c8325c93f61ac4ab385b47e041f23\nAuthor: Steven Moreland <smoreland@google.com>\nDate:   Wed Oct 2 01:00:23 2024 +0000\n\n    libbinder: Parcel: grow rejects large data pos\n    \n    This is unexpected behavior so throw an error.\n    Allocating this much memory may cause OOM or\n    other issues.\n    \n    Bug: 370831157\n    Test: fuzzer\n    Merged-In: Iea0884ca61b08e52e6a6e9c66693e427cb5536f4\n    Change-Id: Iea0884ca61b08e52e6a6e9c66693e427cb5536f4\n    (cherry picked from commit 608524d462278c2c9f6716cd94f126c85e9f2e91)\n\ndiff --git a/libs/binder/Parcel.cpp b/libs/binder/Parcel.cpp\nindex 617708f3d4..abdd4875af 100644\n--- a/libs/binder/Parcel.cpp\n+++ b/libs/binder/Parcel.cpp\n@@ -2253,6 +2253,14 @@ status_t Parcel::growData(size_t len)\n         return BAD_VALUE;\n     }\n \n+    if (mDataPos > mDataSize) {\n+        // b/370831157 - this case used to abort. We also don't expect mDataPos < mDataSize, but\n+        // this would only waste a bit of memory, so it's okay.\n+        ALOGE(\"growData only expected at the end of a Parcel. pos: %zu, size: %zu, capacity: %zu\",\n+              mDataPos, len, mDataCapacity);\n+        return BAD_VALUE;\n+    }\n+\n     if (len > SIZE_MAX - mDataSize) return NO_MEMORY; // overflow\n     if (mDataSize + len > SIZE_MAX / 3) return NO_MEMORY; // overflow\n     size_t newSize = ((mDataSize+len)*3)/2;\n",
                            "downstream_patch_tokens": {
                                "openai": 459,
                                "general": {
                                    "word_based": 166,
                                    "char_based": 337
                                },
                                "gemini": 580
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "0db4fced4d2c8325c93f61ac4ab385b47e041f23",
                            "repo_path": "android_repos/native",
                            "result": "success",
                            "downstream_patch_content": "commit 0db4fced4d2c8325c93f61ac4ab385b47e041f23\nAuthor: Steven Moreland <smoreland@google.com>\nDate:   Wed Oct 2 01:00:23 2024 +0000\n\n    libbinder: Parcel: grow rejects large data pos\n    \n    This is unexpected behavior so throw an error.\n    Allocating this much memory may cause OOM or\n    other issues.\n    \n    Bug: 370831157\n    Test: fuzzer\n    Merged-In: Iea0884ca61b08e52e6a6e9c66693e427cb5536f4\n    Change-Id: Iea0884ca61b08e52e6a6e9c66693e427cb5536f4\n    (cherry picked from commit 608524d462278c2c9f6716cd94f126c85e9f2e91)\n\ndiff --git a/libs/binder/Parcel.cpp b/libs/binder/Parcel.cpp\nindex 617708f3d4..abdd4875af 100644\n--- a/libs/binder/Parcel.cpp\n+++ b/libs/binder/Parcel.cpp\n@@ -2253,6 +2253,14 @@ status_t Parcel::growData(size_t len)\n         return BAD_VALUE;\n     }\n \n+    if (mDataPos > mDataSize) {\n+        // b/370831157 - this case used to abort. We also don't expect mDataPos < mDataSize, but\n+        // this would only waste a bit of memory, so it's okay.\n+        ALOGE(\"growData only expected at the end of a Parcel. pos: %zu, size: %zu, capacity: %zu\",\n+              mDataPos, len, mDataCapacity);\n+        return BAD_VALUE;\n+    }\n+\n     if (len > SIZE_MAX - mDataSize) return NO_MEMORY; // overflow\n     if (mDataSize + len > SIZE_MAX / 3) return NO_MEMORY; // overflow\n     size_t newSize = ((mDataSize+len)*3)/2;\n",
                            "downstream_patch_tokens": {
                                "openai": 459,
                                "general": {
                                    "word_based": 166,
                                    "char_based": 337
                                },
                                "gemini": 580
                            }
                        }
                    ]
                }
            ]
        }
    ],
    "vulnerabilities_skipped": [
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-343129193",
            "skipped": true,
            "error": "[Errno 2] No such file or directory: 'android_repos/native/services/inputflinger/dispatcher/InputDispatcher.h.rej'"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-355461643",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-356117796",
            "skipped": true,
            "error": "[Errno 2] No such file or directory: 'android_repos/Settings/src/com/android/settings/spa/app/appinfo/AppTimeSpentPreference.kt.rej'"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-375623125",
            "skipped": true,
            "error": "503 sendmsg: Broken pipe (32)"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-228837201",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-357870429",
            "skipped": true,
            "error": "Command '['git', 'format-patch', '-1', '7f433dcc4e483fdf93c556b2f5a1455932b9790e', '--stdout']' returned non-zero exit status 128."
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-316578327",
            "skipped": true,
            "error": "No upstream fixes found"
        }
    ],
    "commit_mismatch_vulnerabilities": [
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-376461551",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-376461551",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "12",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12L",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12L",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                }
            ],
            "matched_versions": []
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-251514170",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-251514170",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "12",
                    "upstream_commit_count": 1,
                    "downstream_commit_count": 2
                },
                {
                    "downstream_version": "12L",
                    "upstream_commit_count": 1,
                    "downstream_commit_count": 2
                },
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 1,
                    "downstream_commit_count": 2
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 1,
                    "downstream_commit_count": 2
                }
            ],
            "matched_versions": []
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-376674080",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-376674080",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                }
            ],
            "matched_versions": []
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-372670004",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-372670004",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "12",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12L",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                }
            ],
            "matched_versions": []
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-283962634",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-283962634",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "12",
                    "upstream_commit_count": 3,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12",
                    "upstream_commit_count": 3,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12L",
                    "upstream_commit_count": 3,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12L",
                    "upstream_commit_count": 3,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 3,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 3,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 3,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 3,
                    "downstream_commit_count": 1
                }
            ],
            "matched_versions": []
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-293458004",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-293458004",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 7,
                    "downstream_commit_count": 4
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 7,
                    "downstream_commit_count": 4
                }
            ],
            "matched_versions": []
        }
    ]
}