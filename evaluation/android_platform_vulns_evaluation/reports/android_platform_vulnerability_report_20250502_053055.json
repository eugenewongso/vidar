{
    "summary": {
        "total_vulnerabilities_tested": 11,
        "total_downstream_versions_tested": 36,
        "total_failed_patches": 4,
        "total_unique_downstream_versions_tested": 0,
        "total_unique_downstream_failed_patches": 0,
        "vulnerabilities_with_all_failures": 2,
        "vulnerabilities_with_partial_failures": 1,
        "vulnerabilities_with_all_successful_patches": 8,
        "vulnerabilities_skipped": 2,
        "vulnerabilities_with_commit_mismatch": 5,
        "per_version_stats": {
            "11": {
                "total_downstreams_tested": 2,
                "total_failed_patches": 0
            },
            "12": {
                "total_downstreams_tested": 7,
                "total_failed_patches": 0
            },
            "12L": {
                "total_downstreams_tested": 7,
                "total_failed_patches": 0
            },
            "13": {
                "total_downstreams_tested": 9,
                "total_failed_patches": 2
            },
            "14": {
                "total_downstreams_tested": 11,
                "total_failed_patches": 2
            }
        },
        "total_tokens": {
            "upstream_patch": {
                "gemini": 18497,
                "openai": 14842,
                "general_word": 5743,
                "general_char": 16601
            },
            "downstream_patch": {
                "gemini": 40031,
                "openai": 31761,
                "general_word": 12248,
                "general_char": 33587
            },
            "upstream_source": {
                "gemini": 174987,
                "openai": 148629,
                "general_word": 55645,
                "general_char": 201622
            },
            "downstream_source": {
                "gemini": 167486,
                "openai": 142150,
                "general_word": 53792,
                "general_char": 192265
            },
            "rej_file": {
                "gemini": 1613,
                "openai": 1328,
                "general_word": 504,
                "general_char": 1616
            },
            "inline_merge_conflict": {
                "gemini": 805,
                "openai": 622,
                "general_word": 180,
                "general_char": 892
            }
        },
        "average_tokens_per_downstream_version": {
            "upstream_patch": {
                "gemini": 513.81,
                "openai": 412.28,
                "general_word": 159.53,
                "general_char": 461.14
            },
            "downstream_patch": {
                "gemini": 1111.97,
                "openai": 882.25,
                "general_word": 340.22,
                "general_char": 932.97
            },
            "upstream_source": {
                "gemini": 4860.75,
                "openai": 4128.58,
                "general_word": 1545.69,
                "general_char": 5600.61
            },
            "downstream_source": {
                "gemini": 4652.39,
                "openai": 3948.61,
                "general_word": 1494.22,
                "general_char": 5340.69
            },
            "rej_file": {
                "gemini": 44.81,
                "openai": 36.89,
                "general_word": 14.0,
                "general_char": 44.89
            },
            "inline_merge_conflict": {
                "gemini": 22.36,
                "openai": 17.28,
                "general_word": 5.0,
                "general_char": 24.78
            }
        }
    },
    "vulnerabilities_with_all_failures": [
        {
            "id": "ASB-A-336323279",
            "aliases": [
                "A-336323279",
                "CVE-2024-34738"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-336323279",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "955e78071ec49139583056e21f612edba6439436"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 955e78071ec49139583056e21f612edba6439436 Mon Sep 17 00:00:00 2001\nFrom: Hao Ke <haok@google.com>\nDate: Mon, 22 Apr 2024 15:13:58 +0000\nSubject: [PATCH] Fix READ/WRITE operation access issues on Restricted appOps.\n\nProblems were identified around read and write access to the restricted appOps, this change includes:\n\n- Filter out restricted appOps status for unprivileged readers.\n- Allow additional privileged appOps permission holder reading restricted appOps status.\n\nBug: 336273802\nBug: 336323279\nTest: Local test see b/336273802#comment3\nTest: atest AppOpsTest#testRestrictedSettingsOpsRead\nChange-Id: I09008b365e36b2c20c9a1fe5a1d52699ddb17d35\n---\n core/java/android/app/AppOpInfo.java          |  2 +-\n core/java/android/app/AppOpsManager.java      |  2 +-\n .../android/server/appop/AppOpsService.java   | 31 ++++++++++++++++---\n 3 files changed, 28 insertions(+), 7 deletions(-)\n\ndiff --git a/core/java/android/app/AppOpInfo.java b/core/java/android/app/AppOpInfo.java\nindex 5268ec42e21c..a0f0ccaec58c 100644\n--- a/core/java/android/app/AppOpInfo.java\n+++ b/core/java/android/app/AppOpInfo.java\n@@ -88,7 +88,7 @@ class AppOpInfo {\n \n     /**\n      * This specifies whether each option is only allowed to be read\n-     * by apps with manage appops permission.\n+     * by apps with privileged appops permission.\n      */\n     public final boolean restrictRead;\n \ndiff --git a/core/java/android/app/AppOpsManager.java b/core/java/android/app/AppOpsManager.java\nindex 7ae514ac2491..10e4886b2548 100644\n--- a/core/java/android/app/AppOpsManager.java\n+++ b/core/java/android/app/AppOpsManager.java\n@@ -3269,7 +3269,7 @@ public class AppOpsManager {\n     }\n \n     /**\n-     * Retrieve whether the op can be read by apps with manage appops permission.\n+     * Retrieve whether the op can be read by apps with privileged appops permission.\n      * @hide\n      */\n     public static boolean opRestrictsRead(int op) {\ndiff --git a/services/core/java/com/android/server/appop/AppOpsService.java b/services/core/java/com/android/server/appop/AppOpsService.java\nindex a1f80d05fe1f..1e2a79c9f0f2 100644\n--- a/services/core/java/com/android/server/appop/AppOpsService.java\n+++ b/services/core/java/com/android/server/appop/AppOpsService.java\n@@ -1563,19 +1563,29 @@ public class AppOpsService extends IAppOpsService.Stub {\n     private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops,\n             String persistentDeviceId) {\n         ArrayList<AppOpsManager.OpEntry> resOps = null;\n+        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n+                Manifest.permission.GET_APP_OPS_STATS,\n+                Binder.getCallingPid(), Binder.getCallingUid())\n+                == PackageManager.PERMISSION_GRANTED;\n         if (ops == null) {\n             resOps = new ArrayList<>();\n-            for (int j=0; j<pkgOps.size(); j++) {\n+            for (int j = 0; j < pkgOps.size(); j++) {\n                 Op curOp = pkgOps.valueAt(j);\n+                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                    continue;\n+                }\n                 resOps.add(getOpEntryForResult(curOp, persistentDeviceId));\n             }\n         } else {\n-            for (int j=0; j<ops.length; j++) {\n+            for (int j = 0; j < ops.length; j++) {\n                 Op curOp = pkgOps.get(ops[j]);\n                 if (curOp != null) {\n                     if (resOps == null) {\n                         resOps = new ArrayList<>();\n                     }\n+                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                        continue;\n+                    }\n                     resOps.add(getOpEntryForResult(curOp, persistentDeviceId));\n                 }\n             }\n@@ -4242,10 +4252,21 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n     private void verifyIncomingOp(int op) {\n         if (op >= 0 && op < AppOpsManager._NUM_OP) {\n-            // Enforce manage appops permission if it's a restricted read op.\n+            // Enforce privileged appops permission if it's a restricted read op.\n             if (opRestrictsRead(op)) {\n-                mContext.enforcePermission(Manifest.permission.MANAGE_APPOPS,\n-                        Binder.getCallingPid(), Binder.getCallingUid(), \"verifyIncomingOp\");\n+                if (!(mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n+                        Manifest.permission.GET_APP_OPS_STATS,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n+                        Manifest.permission.MANAGE_APP_OPS_MODES,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED)) {\n+                    throw new SecurityException(\"verifyIncomingOp: uid \" + Binder.getCallingUid()\n+                            + \" does not have any of {MANAGE_APPOPS, GET_APP_OPS_STATS, \"\n+                            + \"MANAGE_APP_OPS_MODES}\");\n+                }\n             }\n             return;\n         }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 1280,
                        "general": {
                            "word_based": 532,
                            "char_based": 1339
                        },
                        "gemini": 1635
                    },
                    "total_downstream_versions_tested": 2,
                    "successful_patches": 0,
                    "failed_patches": 2,
                    "patch_results": [
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "e2471e03e471ed701dd1ac0c6c483f82b0dd22d0",
                            "repo_path": "android_repos/base",
                            "result": "failure",
                            "downstream_patch_content": "commit e2471e03e471ed701dd1ac0c6c483f82b0dd22d0\nAuthor: Hao Ke <haok@google.com>\nDate:   Mon Apr 22 15:13:58 2024 +0000\n\n    RESTRICT AUTOMERGE Fix READ/WRITE operation access issues on Restricted appOps.\n    \n    Problems were identified around read and write access to the restricted appOps, this change includes:\n    \n    - Filter out restricted appOps status for unprivileged readers.\n    - Allow additional privileged appOps permission holder reading restricted appOps status.\n    \n    Bug: 336273802\n    Bug: 336323279\n    Test: Local test see b/336273802#comment3\n    Test: atest AppOpsTest#testRestrictedSettingsOpsRead\n    Change-Id: I09008b365e36b2c20c9a1fe5a1d52699ddb17d35\n\ndiff --git a/core/java/android/app/AppOpsManager.java b/core/java/android/app/AppOpsManager.java\nindex 9344d96d2893..353bb15d0d2e 100644\n--- a/core/java/android/app/AppOpsManager.java\n+++ b/core/java/android/app/AppOpsManager.java\n@@ -3290,7 +3290,7 @@ public class AppOpsManager {\n     }\n \n     /**\n-     * Retrieve whether the op can be read by apps with manage appops permission.\n+     * Retrieve whether the op can be read by apps with privileged appops permission.\n      * @hide\n      */\n     public static boolean opRestrictsRead(int op) {\ndiff --git a/services/core/java/com/android/server/appop/AppOpsService.java b/services/core/java/com/android/server/appop/AppOpsService.java\nindex 1bde4e22428f..b891aeeb527d 100644\n--- a/services/core/java/com/android/server/appop/AppOpsService.java\n+++ b/services/core/java/com/android/server/appop/AppOpsService.java\n@@ -2186,16 +2186,26 @@ public class AppOpsService extends IAppOpsService.Stub {\n     private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops) {\n         ArrayList<AppOpsManager.OpEntry> resOps = null;\n         final long elapsedNow = SystemClock.elapsedRealtime();\n+        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n+                Manifest.permission.GET_APP_OPS_STATS,\n+                Binder.getCallingPid(), Binder.getCallingUid())\n+                == PackageManager.PERMISSION_GRANTED;\n         if (ops == null) {\n             resOps = new ArrayList<>();\n-            for (int j=0; j<pkgOps.size(); j++) {\n+            for (int j = 0; j < pkgOps.size(); j++) {\n                 Op curOp = pkgOps.valueAt(j);\n+                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                    continue;\n+                }\n                 resOps.add(getOpEntryForResult(curOp, elapsedNow));\n             }\n         } else {\n-            for (int j=0; j<ops.length; j++) {\n+            for (int j = 0; j < ops.length; j++) {\n                 Op curOp = pkgOps.get(ops[j]);\n                 if (curOp != null) {\n+                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                        continue;\n+                    }\n                     if (resOps == null) {\n                         resOps = new ArrayList<>();\n                     }\n@@ -4400,10 +4410,21 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n     private void verifyIncomingOp(int op) {\n         if (op >= 0 && op < AppOpsManager._NUM_OP) {\n-            // Enforce manage appops permission if it's a restricted read op.\n+            // Enforce privileged appops permission if it's a restricted read op.\n             if (opRestrictsRead(op)) {\n-                mContext.enforcePermission(Manifest.permission.MANAGE_APPOPS,\n-                        Binder.getCallingPid(), Binder.getCallingUid(), \"verifyIncomingOp\");\n+                if (!(mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n+                        Manifest.permission.GET_APP_OPS_STATS,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n+                        Manifest.permission.MANAGE_APP_OPS_MODES,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED)) {\n+                    throw new SecurityException(\"verifyIncomingOp: uid \" + Binder.getCallingUid()\n+                            + \" does not have any of {MANAGE_APPOPS, GET_APP_OPS_STATS, \"\n+                            + \"MANAGE_APP_OPS_MODES}\");\n+                }\n             }\n             return;\n         }\n",
                            "downstream_patch_tokens": {
                                "openai": 1058,
                                "general": {
                                    "word_based": 423,
                                    "char_based": 1135
                                },
                                "gemini": 1337
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
                                    "total_hunks": 2,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n                if (!(mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n                        Manifest.permission.GET_APP_OPS_STATS,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n                        Manifest.permission.MANAGE_APP_OPS_MODES,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED)) {\n                    throw new SecurityException(\"verifyIncomingOp: uid \" + Binder.getCallingUid()\n                            + \" does not have any of {MANAGE_APPOPS, GET_APP_OPS_STATS, \"\n                            + \"MANAGE_APP_OPS_MODES}\");\n                }\n            }\n            return;\n        }\n>>>>>>> UPSTREAM PATCH (commit 955e78071ec49139583056e21f612edba6439436)",
                                            "merge_conflict_tokens": {
                                                "openai": 193,
                                                "general": {
                                                    "word_based": 57,
                                                    "char_based": 272
                                                },
                                                "gemini": 258
                                            }
                                        }
                                    ],
                                    "inline_merge_token_summary": {
                                        "gemini": 4386,
                                        "openai": 3474,
                                        "general_word": 1026,
                                        "general_char": 4896
                                    },
                                    "rej_file_content": "```diff\n--- services/core/java/com/android/server/appop/AppOpsService.java\n+++ services/core/java/com/android/server/appop/AppOpsService.java\n@@ -1563,19 +1563,29 @@ public class AppOpsService extends IAppOpsService.Stub {\n     private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops,\n             String persistentDeviceId) {\n         ArrayList<AppOpsManager.OpEntry> resOps = null;\n+        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n+                Manifest.permission.GET_APP_OPS_STATS,\n+                Binder.getCallingPid(), Binder.getCallingUid())\n+                == PackageManager.PERMISSION_GRANTED;\n         if (ops == null) {\n             resOps = new ArrayList<>();\n-            for (int j=0; j<pkgOps.size(); j++) {\n+            for (int j = 0; j < pkgOps.size(); j++) {\n                 Op curOp = pkgOps.valueAt(j);\n+                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                    continue;\n+                }\n                 resOps.add(getOpEntryForResult(curOp, persistentDeviceId));\n             }\n         } else {\n-            for (int j=0; j<ops.length; j++) {\n+            for (int j = 0; j < ops.length; j++) {\n                 Op curOp = pkgOps.get(ops[j]);\n                 if (curOp != null) {\n                     if (resOps == null) {\n                         resOps = new ArrayList<>();\n                     }\n+                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                        continue;\n+                    }\n                     resOps.add(getOpEntryForResult(curOp, persistentDeviceId));\n                 }\n             }\n```",
                                    "rej_file_tokens": {
                                        "openai": 368,
                                        "general": {
                                            "word_based": 138,
                                            "char_based": 418
                                        },
                                        "gemini": 450
                                    },
                                    "patch_apply_output": "patching file services/core/java/com/android/server/appop/AppOpsService.java\nHunk #1 FAILED at 1563.\nHunk #2 succeeded at 4400 (offset 158 lines).\n1 out of 2 hunks FAILED -- saving rejects to file services/core/java/com/android/server/appop/AppOpsService.java.rej",
                                    "inline_merge_output": "patching file services/core/java/com/android/server/appop/AppOpsService.java\nHunk #1 already applied at 1566-1569,1572,1574-1576,1580, merged at 1589-1591.\nHunk #2 already applied at 4258, NOT MERGED at 4260-4278.",
                                    "upstream_file_tokens": {
                                        "openai": 63381,
                                        "general": {
                                            "word_based": 23827,
                                            "char_based": 83324
                                        },
                                        "gemini": 74277
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.appop;\n\nimport static android.app.ActivityManager.PROCESS_CAPABILITY_FOREGROUND_CAMERA;\nimport static android.app.ActivityManager.PROCESS_CAPABILITY_FOREGROUND_LOCATION;\nimport static android.app.ActivityManager.PROCESS_CAPABILITY_FOREGROUND_MICROPHONE;\nimport static android.app.AppOpsManager.ATTRIBUTION_CHAIN_ID_NONE;\nimport static android.app.AppOpsManager.ATTRIBUTION_FLAG_TRUSTED;\nimport static android.app.AppOpsManager.CALL_BACK_ON_SWITCHED_OP;\nimport static android.app.AppOpsManager.FILTER_BY_ATTRIBUTION_TAG;\nimport static android.app.AppOpsManager.FILTER_BY_OP_NAMES;\nimport static android.app.AppOpsManager.FILTER_BY_PACKAGE_NAME;\nimport static android.app.AppOpsManager.FILTER_BY_UID;\nimport static android.app.AppOpsManager.HISTORY_FLAG_GET_ATTRIBUTION_CHAINS;\nimport static android.app.AppOpsManager.HistoricalOpsRequestFilter;\nimport static android.app.AppOpsManager.KEY_BG_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.KEY_FG_SERVICE_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.KEY_TOP_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.MODE_ALLOWED;\nimport static android.app.AppOpsManager.MODE_DEFAULT;\nimport static android.app.AppOpsManager.MODE_ERRORED;\nimport static android.app.AppOpsManager.MODE_FOREGROUND;\nimport static android.app.AppOpsManager.MODE_IGNORED;\nimport static android.app.AppOpsManager.NoteOpEvent;\nimport static android.app.AppOpsManager.OP_CAMERA;\nimport static android.app.AppOpsManager.OP_FLAGS_ALL;\nimport static android.app.AppOpsManager.OP_FLAG_SELF;\nimport static android.app.AppOpsManager.OP_FLAG_TRUSTED_PROXIED;\nimport static android.app.AppOpsManager.OP_NONE;\nimport static android.app.AppOpsManager.OP_PLAY_AUDIO;\nimport static android.app.AppOpsManager.OP_RECEIVE_AMBIENT_TRIGGER_AUDIO;\nimport static android.app.AppOpsManager.OP_RECORD_AUDIO;\nimport static android.app.AppOpsManager.OP_RECORD_AUDIO_HOTWORD;\nimport static android.app.AppOpsManager.OnOpStartedListener.START_TYPE_FAILED;\nimport static android.app.AppOpsManager.OnOpStartedListener.START_TYPE_RESUMED;\nimport static android.app.AppOpsManager.OnOpStartedListener.START_TYPE_STARTED;\nimport static android.app.AppOpsManager.OpEventProxyInfo;\nimport static android.app.AppOpsManager.RestrictionBypass;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_BOOT_TIME_SAMPLING;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_RARELY_USED;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_UNIFORM;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_UNIFORM_OPS;\nimport static android.app.AppOpsManager.SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE;\nimport static android.app.AppOpsManager.UID_STATE_BACKGROUND;\nimport static android.app.AppOpsManager.UID_STATE_CACHED;\nimport static android.app.AppOpsManager.UID_STATE_FOREGROUND;\nimport static android.app.AppOpsManager.UID_STATE_FOREGROUND_SERVICE;\nimport static android.app.AppOpsManager.UID_STATE_MAX_LAST_NON_RESTRICTED;\nimport static android.app.AppOpsManager.UID_STATE_PERSISTENT;\nimport static android.app.AppOpsManager.UID_STATE_TOP;\nimport static android.app.AppOpsManager.WATCH_FOREGROUND_CHANGES;\nimport static android.app.AppOpsManager._NUM_OP;\nimport static android.app.AppOpsManager.extractFlagsFromKey;\nimport static android.app.AppOpsManager.extractUidStateFromKey;\nimport static android.app.AppOpsManager.makeKey;\nimport static android.app.AppOpsManager.modeToName;\nimport static android.app.AppOpsManager.opAllowSystemBypassRestriction;\nimport static android.app.AppOpsManager.opRestrictsRead;\nimport static android.app.AppOpsManager.opToName;\nimport static android.app.AppOpsManager.opToPublicName;\nimport static android.app.AppOpsManager.resolveFirstUnrestrictedUidState;\nimport static android.content.Intent.ACTION_PACKAGE_REMOVED;\nimport static android.content.Intent.EXTRA_REPLACING;\nimport static android.content.pm.PermissionInfo.PROTECTION_DANGEROUS;\nimport static android.content.pm.PermissionInfo.PROTECTION_FLAG_APPOP;\n\nimport static com.android.server.appop.AppOpsService.ModeCallback.ALL_OPS;\n\nimport static java.lang.Long.max;\n\nimport android.Manifest;\nimport android.annotation.IntRange;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.UserIdInt;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.AppOpsManager.AttributedOpEntry;\nimport android.app.AppOpsManager.AttributionFlags;\nimport android.app.AppOpsManager.HistoricalOps;\nimport android.app.AppOpsManager.Mode;\nimport android.app.AppOpsManager.OpEntry;\nimport android.app.AppOpsManager.OpFlags;\nimport android.app.AppOpsManagerInternal;\nimport android.app.AppOpsManagerInternal.CheckOpsDelegate;\nimport android.app.AsyncNotedAppOp;\nimport android.app.RuntimeAppOpAccessMessage;\nimport android.app.SyncNotedAppOp;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.content.AttributionSource;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.PermissionInfo;\nimport android.content.pm.UserInfo;\nimport android.database.ContentObserver;\nimport android.hardware.camera2.CameraDevice.CAMERA_AUDIO_RESTRICTION;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.PackageTagsList;\nimport android.os.Process;\nimport android.os.RemoteCallback;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.ServiceManager;\nimport android.os.ShellCallback;\nimport android.os.ShellCommand;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.storage.StorageManagerInternal;\nimport android.permission.PermissionManager;\nimport android.provider.Settings;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.IndentingPrintWriter;\nimport android.util.KeyValueListParser;\nimport android.util.LongSparseArray;\nimport android.util.Pair;\nimport android.util.Pools;\nimport android.util.Pools.SimplePool;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\nimport android.util.SparseIntArray;\nimport android.util.TimeUtils;\nimport android.util.TypedXmlPullParser;\nimport android.util.TypedXmlSerializer;\nimport android.util.Xml;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.Immutable;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.app.IAppOpsActiveCallback;\nimport com.android.internal.app.IAppOpsAsyncNotedCallback;\nimport com.android.internal.app.IAppOpsCallback;\nimport com.android.internal.app.IAppOpsNotedCallback;\nimport com.android.internal.app.IAppOpsService;\nimport com.android.internal.app.IAppOpsStartedCallback;\nimport com.android.internal.app.MessageSamplingConfig;\nimport com.android.internal.compat.IPlatformCompat;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.Preconditions;\nimport com.android.internal.util.XmlUtils;\nimport com.android.internal.util.function.pooled.PooledLambda;\nimport com.android.server.LocalServices;\nimport com.android.server.LockGuard;\nimport com.android.server.SystemServerInitThreadPool;\nimport com.android.server.SystemServiceManager;\nimport com.android.server.pm.PackageList;\nimport com.android.server.pm.parsing.pkg.AndroidPackage;\nimport com.android.server.pm.pkg.component.ParsedAttribution;\nimport com.android.server.policy.AppOpsPolicy;\n\nimport dalvik.annotation.optimization.NeverCompile;\n\nimport libcore.util.EmptyArray;\n\nimport org.json.JSONException;\nimport org.json.JSONObject;\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.text.SimpleDateFormat;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Consumer;\n\npublic class AppOpsService extends IAppOpsService.Stub {\n    static final String TAG = \"AppOps\";\n    static final boolean DEBUG = false;\n\n    /**\n     * Used for data access validation collection, we wish to only log a specific access once\n     */\n    private final ArraySet<NoteOpTrace> mNoteOpCallerStacktraces = new ArraySet<>();\n\n    private static final int NO_VERSION = -1;\n    /** Increment by one every time and add the corresponding upgrade logic in\n     *  {@link #upgradeLocked(int)} below. The first version was 1 */\n    private static final int CURRENT_VERSION = 1;\n\n    // Write at most every 30 minutes.\n    static final long WRITE_DELAY = DEBUG ? 1000 : 30*60*1000;\n\n    // Constant meaning that any UID should be matched when dispatching callbacks\n    private static final int UID_ANY = -2;\n\n    // Map from process states to the uid states we track.\n    private static final int[] PROCESS_STATE_TO_UID_STATE = new int[] {\n        UID_STATE_PERSISTENT,           // ActivityManager.PROCESS_STATE_PERSISTENT\n        UID_STATE_PERSISTENT,           // ActivityManager.PROCESS_STATE_PERSISTENT_UI\n        UID_STATE_TOP,                  // ActivityManager.PROCESS_STATE_TOP\n        UID_STATE_FOREGROUND,           // ActivityManager.PROCESS_STATE_BOUND_TOP\n        UID_STATE_FOREGROUND_SERVICE,   // ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE\n        UID_STATE_FOREGROUND,           // ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE\n        UID_STATE_BACKGROUND,           // ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND\n        UID_STATE_BACKGROUND,           // ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND\n        UID_STATE_BACKGROUND,           // ActivityManager.PROCESS_STATE_TRANSIENT_BACKGROUND\n        UID_STATE_BACKGROUND,           // ActivityManager.PROCESS_STATE_BACKUP\n        UID_STATE_BACKGROUND,           // ActivityManager.PROCESS_STATE_SERVICE\n        UID_STATE_BACKGROUND,           // ActivityManager.PROCESS_STATE_RECEIVER\n        UID_STATE_CACHED,               // ActivityManager.PROCESS_STATE_TOP_SLEEPING\n        UID_STATE_CACHED,               // ActivityManager.PROCESS_STATE_HEAVY_WEIGHT\n        UID_STATE_CACHED,               // ActivityManager.PROCESS_STATE_HOME\n        UID_STATE_CACHED,               // ActivityManager.PROCESS_STATE_LAST_ACTIVITY\n        UID_STATE_CACHED,               // ActivityManager.PROCESS_STATE_CACHED_ACTIVITY\n        UID_STATE_CACHED,               // ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT\n        UID_STATE_CACHED,               // ActivityManager.PROCESS_STATE_CACHED_RECENT\n        UID_STATE_CACHED,               // ActivityManager.PROCESS_STATE_CACHED_EMPTY\n        UID_STATE_CACHED,               // ActivityManager.PROCESS_STATE_NONEXISTENT\n    };\n\n    private static final int[] OPS_RESTRICTED_ON_SUSPEND = {\n            OP_PLAY_AUDIO,\n            OP_RECORD_AUDIO,\n            OP_CAMERA,\n    };\n\n    private static final int MAX_UNFORWARDED_OPS = 10;\n    private static final int MAX_UNUSED_POOLED_OBJECTS = 3;\n    private static final int RARELY_USED_PACKAGES_INITIALIZATION_DELAY_MILLIS = 300000;\n\n    final Context mContext;\n    final AtomicFile mFile;\n    private final @Nullable File mNoteOpCallerStacktracesFile;\n    final Handler mHandler;\n\n    /** Pool for {@link OpEventProxyInfoPool} to avoid to constantly reallocate new objects */\n    @GuardedBy(\"this\")\n    private final OpEventProxyInfoPool mOpEventProxyInfoPool = new OpEventProxyInfoPool();\n\n    /** Pool for {@link InProgressStartOpEventPool} to avoid to constantly reallocate new objects */\n    @GuardedBy(\"this\")\n    private final InProgressStartOpEventPool mInProgressStartOpEventPool =\n            new InProgressStartOpEventPool();\n\n    private final AppOpsManagerInternalImpl mAppOpsManagerInternal\n            = new AppOpsManagerInternalImpl();\n    @Nullable private final DevicePolicyManagerInternal dpmi =\n            LocalServices.getService(DevicePolicyManagerInternal.class);\n\n    private final IPlatformCompat mPlatformCompat = IPlatformCompat.Stub.asInterface(\n            ServiceManager.getService(Context.PLATFORM_COMPAT_SERVICE));\n\n    /**\n     * Registered callbacks, called from {@link #collectAsyncNotedOp}.\n     *\n     * <p>(package name, uid) -> callbacks\n     *\n     * @see #getAsyncNotedOpsKey(String, int)\n     */\n    @GuardedBy(\"this\")\n    private final ArrayMap<Pair<String, Integer>, RemoteCallbackList<IAppOpsAsyncNotedCallback>>\n            mAsyncOpWatchers = new ArrayMap<>();\n\n    /**\n     * Async note-ops collected from {@link #collectAsyncNotedOp} that have not been delivered to a\n     * callback yet.\n     *\n     * <p>(package name, uid) -> list&lt;ops&gt;\n     *\n     * @see #getAsyncNotedOpsKey(String, int)\n     */\n    @GuardedBy(\"this\")\n    private final ArrayMap<Pair<String, Integer>, ArrayList<AsyncNotedAppOp>>\n            mUnforwardedAsyncNotedOps = new ArrayMap<>();\n\n    boolean mWriteNoteOpsScheduled;\n\n    boolean mWriteScheduled;\n    boolean mFastWriteScheduled;\n    final Runnable mWriteRunner = new Runnable() {\n        public void run() {\n            synchronized (AppOpsService.this) {\n                mWriteScheduled = false;\n                mFastWriteScheduled = false;\n                AsyncTask<Void, Void, Void> task = new AsyncTask<Void, Void, Void>() {\n                    @Override protected Void doInBackground(Void... params) {\n                        writeState();\n                        return null;\n                    }\n                };\n                task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void[])null);\n            }\n        }\n    };\n\n    @GuardedBy(\"this\")\n    @VisibleForTesting\n    final SparseArray<UidState> mUidStates = new SparseArray<>();\n\n    volatile @NonNull HistoricalRegistry mHistoricalRegistry = new HistoricalRegistry(this);\n\n    long mLastRealtime;\n\n    /*\n     * These are app op restrictions imposed per user from various parties.\n     */\n    private final ArrayMap<IBinder, ClientUserRestrictionState> mOpUserRestrictions =\n            new ArrayMap<>();\n\n    /*\n     * These are app op restrictions imposed globally from various parties within the system.\n     */\n    private final ArrayMap<IBinder, ClientGlobalRestrictionState> mOpGlobalRestrictions =\n            new ArrayMap<>();\n\n    SparseIntArray mProfileOwners;\n\n    private volatile CheckOpsDelegateDispatcher mCheckOpsDelegateDispatcher =\n            new CheckOpsDelegateDispatcher(/*policy*/ null, /*delegate*/ null);\n\n    /**\n      * Reverse lookup for {@link AppOpsManager#opToSwitch(int)}. Initialized once and never\n      * changed\n      */\n    private final SparseArray<int[]> mSwitchedOps = new SparseArray<>();\n\n    private ActivityManagerInternal mActivityManagerInternal;\n\n    /** Package sampled for message collection in the current session */\n    @GuardedBy(\"this\")\n    private String mSampledPackage = null;\n\n    /** Appop sampled for message collection in the current session */\n    @GuardedBy(\"this\")\n    private int mSampledAppOpCode = OP_NONE;\n\n    /** Maximum distance for appop to be considered for message collection in the current session */\n    @GuardedBy(\"this\")\n    private int mAcceptableLeftDistance = 0;\n\n    /** Number of messages collected for sampled package and appop in the current session */\n    @GuardedBy(\"this\")\n    private float mMessagesCollectedCount;\n\n    /** List of rarely used packages priorities for message collection */\n    @GuardedBy(\"this\")\n    private ArraySet<String> mRarelyUsedPackages = new ArraySet<>();\n\n    /** Sampling strategy used for current session */\n    @GuardedBy(\"this\")\n    @AppOpsManager.SamplingStrategy\n    private int mSamplingStrategy;\n\n    /** Last runtime permission access message collected and ready for reporting */\n    @GuardedBy(\"this\")\n    private RuntimeAppOpAccessMessage mCollectedRuntimePermissionMessage;\n\n    /** Package Manager internal. Access via {@link #getPackageManagerInternal()} */\n    private @Nullable PackageManagerInternal mPackageManagerInternal;\n\n    /**\n     * An unsynchronized pool of {@link OpEventProxyInfo} objects.\n     */\n    private class OpEventProxyInfoPool extends SimplePool<OpEventProxyInfo> {\n        OpEventProxyInfoPool() {\n            super(MAX_UNUSED_POOLED_OBJECTS);\n        }\n\n        OpEventProxyInfo acquire(@IntRange(from = 0) int uid, @Nullable String packageName,\n                @Nullable String attributionTag) {\n            OpEventProxyInfo recycled = acquire();\n            if (recycled != null) {\n                recycled.reinit(uid, packageName, attributionTag);\n                return recycled;\n            }\n\n            return new OpEventProxyInfo(uid, packageName, attributionTag);\n        }\n    }\n\n    /**\n     * An unsynchronized pool of {@link InProgressStartOpEvent} objects.\n     */\n    private class InProgressStartOpEventPool extends SimplePool<InProgressStartOpEvent> {\n        InProgressStartOpEventPool() {\n            super(MAX_UNUSED_POOLED_OBJECTS);\n        }\n\n        InProgressStartOpEvent acquire(long startTime, long elapsedTime, @NonNull IBinder clientId,\n                @Nullable String attributionTag, @NonNull Runnable onDeath, int proxyUid,\n                @Nullable String proxyPackageName, @Nullable String proxyAttributionTag,\n                @AppOpsManager.UidState int uidState, @OpFlags int flags, @AttributionFlags\n                int attributionFlags, int attributionChainId) throws RemoteException {\n\n            InProgressStartOpEvent recycled = acquire();\n\n            OpEventProxyInfo proxyInfo = null;\n            if (proxyUid != Process.INVALID_UID) {\n                proxyInfo = mOpEventProxyInfoPool.acquire(proxyUid, proxyPackageName,\n                        proxyAttributionTag);\n            }\n\n            if (recycled != null) {\n                recycled.reinit(startTime, elapsedTime, clientId, attributionTag, onDeath,\n                        uidState, flags, proxyInfo,  attributionFlags, attributionChainId,\n                        mOpEventProxyInfoPool);\n                return recycled;\n            }\n\n            return new InProgressStartOpEvent(startTime, elapsedTime, clientId, attributionTag,\n                    onDeath, uidState, proxyInfo, flags, attributionFlags, attributionChainId);\n        }\n    }\n\n    /**\n     * All times are in milliseconds. These constants are kept synchronized with the system\n     * global Settings. Any access to this class or its fields should be done while\n     * holding the AppOpsService lock.\n     */\n    @VisibleForTesting\n    final class Constants extends ContentObserver {\n\n        /**\n         * How long we want for a drop in uid state from top to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_TOP_STATE_SETTLE_TIME\n         */\n        public long TOP_STATE_SETTLE_TIME;\n\n        /**\n         * How long we want for a drop in uid state from foreground to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_FG_SERVICE_STATE_SETTLE_TIME\n         */\n        public long FG_SERVICE_STATE_SETTLE_TIME;\n\n        /**\n         * How long we want for a drop in uid state from background to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_BG_STATE_SETTLE_TIME\n         */\n        public long BG_STATE_SETTLE_TIME;\n\n        private final KeyValueListParser mParser = new KeyValueListParser(',');\n        private ContentResolver mResolver;\n\n        public Constants(Handler handler) {\n            super(handler);\n            updateConstants();\n        }\n\n        public void startMonitoring(ContentResolver resolver) {\n            mResolver = resolver;\n            mResolver.registerContentObserver(\n                    Settings.Global.getUriFor(Settings.Global.APP_OPS_CONSTANTS),\n                    false, this);\n            updateConstants();\n        }\n\n        @Override\n        public void onChange(boolean selfChange, Uri uri) {\n            updateConstants();\n        }\n\n        private void updateConstants() {\n            String value = mResolver != null ? Settings.Global.getString(mResolver,\n                    Settings.Global.APP_OPS_CONSTANTS) : \"\";\n\n            synchronized (AppOpsService.this) {\n                try {\n                    mParser.setString(value);\n                } catch (IllegalArgumentException e) {\n                    // Failed to parse the settings string, log this and move on\n                    // with defaults.\n                    Slog.e(TAG, \"Bad app ops settings\", e);\n                }\n                TOP_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_TOP_STATE_SETTLE_TIME, 5 * 1000L);\n                FG_SERVICE_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_FG_SERVICE_STATE_SETTLE_TIME, 5 * 1000L);\n                BG_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_BG_STATE_SETTLE_TIME, 1 * 1000L);\n            }\n        }\n\n        void dump(PrintWriter pw) {\n            pw.println(\"  Settings:\");\n\n            pw.print(\"    \"); pw.print(KEY_TOP_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(TOP_STATE_SETTLE_TIME, pw);\n            pw.println();\n            pw.print(\"    \"); pw.print(KEY_FG_SERVICE_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(FG_SERVICE_STATE_SETTLE_TIME, pw);\n            pw.println();\n            pw.print(\"    \"); pw.print(KEY_BG_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(BG_STATE_SETTLE_TIME, pw);\n            pw.println();\n        }\n    }\n\n    @VisibleForTesting\n    final Constants mConstants;\n\n    @VisibleForTesting\n    final class UidState {\n        public final int uid;\n\n        public int state = UID_STATE_CACHED;\n        public int pendingState = UID_STATE_CACHED;\n        public long pendingStateCommitTime;\n        public int capability;\n        public int pendingCapability;\n        public boolean appWidgetVisible;\n        public boolean pendingAppWidgetVisible;\n\n        public ArrayMap<String, Ops> pkgOps;\n        public SparseIntArray opModes;\n\n        // true indicates there is an interested observer, false there isn't but it has such an op\n        public SparseBooleanArray foregroundOps;\n        public boolean hasForegroundWatchers;\n\n        public UidState(int uid) {\n            this.uid = uid;\n        }\n\n        public void clear() {\n            pkgOps = null;\n            opModes = null;\n        }\n\n        public boolean isDefault() {\n            return (pkgOps == null || pkgOps.isEmpty())\n                    && (opModes == null || opModes.size() <= 0)\n                    && (state == UID_STATE_CACHED\n                    && (pendingState == UID_STATE_CACHED));\n        }\n\n        int evalMode(int op, int mode) {\n            if (mode == MODE_FOREGROUND) {\n                if (appWidgetVisible) {\n                    return MODE_ALLOWED;\n                } else if (mActivityManagerInternal != null\n                        && mActivityManagerInternal.isPendingTopUid(uid)) {\n                    return MODE_ALLOWED;\n                } else if (mActivityManagerInternal != null\n                        && mActivityManagerInternal.isTempAllowlistedForFgsWhileInUse(uid)) {\n                    return MODE_ALLOWED;\n                } else if (state <= UID_STATE_TOP) {\n                    // process is in TOP.\n                    return MODE_ALLOWED;\n                } else if (state <= AppOpsManager.resolveFirstUnrestrictedUidState(op)) {\n                    // process is in foreground, check its capability.\n                    switch (op) {\n                        case AppOpsManager.OP_FINE_LOCATION:\n                        case AppOpsManager.OP_COARSE_LOCATION:\n                        case AppOpsManager.OP_MONITOR_LOCATION:\n                        case AppOpsManager.OP_MONITOR_HIGH_POWER_LOCATION:\n                            if ((capability & PROCESS_CAPABILITY_FOREGROUND_LOCATION) != 0) {\n                                return MODE_ALLOWED;\n                            } else {\n                                return MODE_IGNORED;\n                            }\n                        case OP_CAMERA:\n                            if ((capability & PROCESS_CAPABILITY_FOREGROUND_CAMERA) != 0) {\n                                return MODE_ALLOWED;\n                            } else {\n                                return MODE_IGNORED;\n                            }\n                        case OP_RECORD_AUDIO:\n                            if ((capability & PROCESS_CAPABILITY_FOREGROUND_MICROPHONE) != 0) {\n                                return MODE_ALLOWED;\n                            } else {\n                                return MODE_IGNORED;\n                            }\n                        default:\n                            return MODE_ALLOWED;\n                    }\n                } else {\n                    // process is not in foreground.\n                    return MODE_IGNORED;\n                }\n            }\n            return mode;\n        }\n\n        private void evalForegroundWatchers(int op, SparseArray<ArraySet<ModeCallback>> watchers,\n                SparseBooleanArray which) {\n            boolean curValue = which.get(op, false);\n            ArraySet<ModeCallback> callbacks = watchers.get(op);\n            if (callbacks != null) {\n                for (int cbi = callbacks.size() - 1; !curValue && cbi >= 0; cbi--) {\n                    if ((callbacks.valueAt(cbi).mFlags\n                            & AppOpsManager.WATCH_FOREGROUND_CHANGES) != 0) {\n                        hasForegroundWatchers = true;\n                        curValue = true;\n                    }\n                }\n            }\n            which.put(op, curValue);\n        }\n\n        public void evalForegroundOps(SparseArray<ArraySet<ModeCallback>> watchers) {\n            SparseBooleanArray which = null;\n            hasForegroundWatchers = false;\n            if (opModes != null) {\n                for (int i = opModes.size() - 1; i >= 0; i--) {\n                    if (opModes.valueAt(i) == AppOpsManager.MODE_FOREGROUND) {\n                        if (which == null) {\n                            which = new SparseBooleanArray();\n                        }\n                        evalForegroundWatchers(opModes.keyAt(i), watchers, which);\n                    }\n                }\n            }\n            if (pkgOps != null) {\n                for (int i = pkgOps.size() - 1; i >= 0; i--) {\n                    Ops ops = pkgOps.valueAt(i);\n                    for (int j = ops.size() - 1; j >= 0; j--) {\n                        if (ops.valueAt(j).mode == AppOpsManager.MODE_FOREGROUND) {\n                            if (which == null) {\n                                which = new SparseBooleanArray();\n                            }\n                            evalForegroundWatchers(ops.keyAt(j), watchers, which);\n                        }\n                    }\n                }\n            }\n            foregroundOps = which;\n        }\n    }\n\n    final static class Ops extends SparseArray<Op> {\n        final String packageName;\n        final UidState uidState;\n\n        /**\n         * The restriction properties of the package. If {@code null} it could not have been read\n         * yet and has to be refreshed.\n         */\n        @Nullable RestrictionBypass bypass;\n\n        /** Lazily populated cache of attributionTags of this package */\n        final @NonNull ArraySet<String> knownAttributionTags = new ArraySet<>();\n\n        /**\n         * Lazily populated cache of <b>valid</b> attributionTags of this package, a set smaller\n         * than or equal to {@link #knownAttributionTags}.\n         */\n        final @NonNull ArraySet<String> validAttributionTags = new ArraySet<>();\n\n        Ops(String _packageName, UidState _uidState) {\n            packageName = _packageName;\n            uidState = _uidState;\n        }\n    }\n\n    /** Returned from {@link #verifyAndGetBypass(int, String, String, String, boolean)}. */\n    private static final class PackageVerificationResult {\n\n        final RestrictionBypass bypass;\n        final boolean isAttributionTagValid;\n\n        PackageVerificationResult(RestrictionBypass bypass, boolean isAttributionTagValid) {\n            this.bypass = bypass;\n            this.isAttributionTagValid = isAttributionTagValid;\n        }\n    }\n\n    /** A in progress startOp->finishOp event */\n    private static final class InProgressStartOpEvent implements IBinder.DeathRecipient {\n        /** Wall clock time of startOp event (not monotonic) */\n        private long mStartTime;\n\n        /** Elapsed time since boot of startOp event */\n        private long mStartElapsedTime;\n\n        /** Id of the client that started the event */\n        private @NonNull IBinder mClientId;\n\n        /** The attribution tag for this operation */\n        private @Nullable String mAttributionTag;\n\n        /** To call when client dies */\n        private @NonNull Runnable mOnDeath;\n\n        /** uidstate used when calling startOp */\n        private @AppOpsManager.UidState int mUidState;\n\n        /** Proxy information of the startOp event */\n        private @Nullable OpEventProxyInfo mProxy;\n\n        /** Proxy flag information */\n        private @OpFlags int mFlags;\n\n        /** How many times the op was started but not finished yet */\n        int numUnfinishedStarts;\n\n        /** The attribution flags related to this event */\n        private @AttributionFlags int mAttributionFlags;\n\n        /** The id of the attribution chain this even is a part of */\n        private int mAttributionChainId;\n\n        /**\n         * Create a new {@link InProgressStartOpEvent}.\n         *\n         * @param startTime The time {@link #startOperation} was called\n         * @param startElapsedTime The elapsed time when {@link #startOperation} was called\n         * @param clientId The client id of the caller of {@link #startOperation}\n         * @param attributionTag The attribution tag for the operation.\n         * @param onDeath The code to execute on client death\n         * @param uidState The uidstate of the app {@link #startOperation} was called for\n         * @param attributionFlags the attribution flags for this operation.\n         * @param attributionChainId the unique id of the attribution chain this op is a part of.\n         * @param proxy The proxy information, if {@link #startProxyOperation} was called\n         * @param flags The trusted/nontrusted/self flags.\n         *\n         * @throws RemoteException If the client is dying\n         */\n        private InProgressStartOpEvent(long startTime, long startElapsedTime,\n                @NonNull IBinder clientId, @Nullable String attributionTag,\n                @NonNull Runnable onDeath, @AppOpsManager.UidState int uidState,\n                @Nullable OpEventProxyInfo proxy, @OpFlags int flags,\n                @AttributionFlags int attributionFlags, int attributionChainId)\n                throws RemoteException {\n            mStartTime = startTime;\n            mStartElapsedTime = startElapsedTime;\n            mClientId = clientId;\n            mAttributionTag = attributionTag;\n            mOnDeath = onDeath;\n            mUidState = uidState;\n            mProxy = proxy;\n            mFlags = flags;\n            mAttributionFlags = attributionFlags;\n            mAttributionChainId = attributionChainId;\n\n            clientId.linkToDeath(this, 0);\n        }\n\n        /** Clean up event */\n        public void finish() {\n            try {\n                mClientId.unlinkToDeath(this, 0);\n            } catch (NoSuchElementException e) {\n                // Either not linked, or already unlinked. Either way, nothing to do.\n            }\n        }\n\n        @Override\n        public void binderDied() {\n            mOnDeath.run();\n        }\n\n        /**\n         * Reinit existing object with new state.\n         *\n         * @param startTime The time {@link #startOperation} was called\n         * @param startElapsedTime The elapsed time when {@link #startOperation} was called\n         * @param clientId The client id of the caller of {@link #startOperation}\n         * @param attributionTag The attribution tag for this operation.\n         * @param onDeath The code to execute on client death\n         * @param uidState The uidstate of the app {@link #startOperation} was called for\n         * @param flags The flags relating to the proxy\n         * @param proxy The proxy information, if {@link #startProxyOperation} was called\n         * @param attributionFlags the attribution flags for this operation.\n         * @param attributionChainId the unique id of the attribution chain this op is a part of.\n         * @param proxyPool The pool to release previous {@link OpEventProxyInfo} to\n         *\n         * @throws RemoteException If the client is dying\n         */\n        public void reinit(long startTime, long startElapsedTime, @NonNull IBinder clientId,\n                @Nullable String attributionTag, @NonNull Runnable onDeath,\n                @AppOpsManager.UidState int uidState, @OpFlags int flags,\n                @Nullable OpEventProxyInfo proxy, @AttributionFlags int attributionFlags,\n                int attributionChainId, @NonNull Pools.Pool<OpEventProxyInfo> proxyPool\n        ) throws RemoteException {\n            mStartTime = startTime;\n            mStartElapsedTime = startElapsedTime;\n            mClientId = clientId;\n            mAttributionTag = attributionTag;\n            mOnDeath = onDeath;\n            mUidState = uidState;\n            mFlags = flags;\n\n            if (mProxy != null) {\n                proxyPool.release(mProxy);\n            }\n            mProxy = proxy;\n            mAttributionFlags = attributionFlags;\n            mAttributionChainId = attributionChainId;\n\n            clientId.linkToDeath(this, 0);\n        }\n\n        /** @return Wall clock time of startOp event */\n        public long getStartTime() {\n            return mStartTime;\n        }\n\n        /** @return Elapsed time since boot of startOp event */\n        public long getStartElapsedTime() {\n            return mStartElapsedTime;\n        }\n\n        /** @return Id of the client that started the event */\n        public @NonNull IBinder getClientId() {\n            return mClientId;\n        }\n\n        /** @return uidstate used when calling startOp */\n        public @AppOpsManager.UidState int getUidState() {\n            return mUidState;\n        }\n\n        /** @return proxy tag for the access */\n        public @Nullable OpEventProxyInfo getProxy() {\n            return mProxy;\n        }\n\n        /** @return flags used for the access */\n        public @OpFlags int getFlags() {\n            return mFlags;\n        }\n\n        /** @return attributoin flags used for the access */\n        public @AttributionFlags int getAttributionFlags() {\n            return mAttributionFlags;\n        }\n\n        /** @return attribution chain id for the access */\n        public int getAttributionChainId() {\n            return mAttributionChainId;\n        }\n    }\n\n    private final class AttributedOp {\n        public final @Nullable String tag;\n        public final @NonNull Op parent;\n\n        /**\n         * Last successful accesses (noteOp + finished startOp) for each uidState/opFlag combination\n         *\n         * <p>Key is {@link AppOpsManager#makeKey}\n         */\n        @GuardedBy(\"AppOpsService.this\")\n        private @Nullable LongSparseArray<NoteOpEvent> mAccessEvents;\n\n        /**\n         * Last rejected accesses for each uidState/opFlag combination\n         *\n         * <p>Key is {@link AppOpsManager#makeKey}\n         */\n        @GuardedBy(\"AppOpsService.this\")\n        private @Nullable LongSparseArray<NoteOpEvent> mRejectEvents;\n\n        /**\n         * Currently in progress startOp events\n         *\n         * <p>Key is clientId\n         */\n        @GuardedBy(\"AppOpsService.this\")\n        private @Nullable ArrayMap<IBinder, InProgressStartOpEvent> mInProgressEvents;\n\n        /**\n         * Currently paused startOp events\n         *\n         * <p>Key is clientId\n         */\n        @GuardedBy(\"AppOpsService.this\")\n        private @Nullable ArrayMap<IBinder, InProgressStartOpEvent> mPausedInProgressEvents;\n\n        AttributedOp(@Nullable String tag, @NonNull Op parent) {\n            this.tag = tag;\n            this.parent = parent;\n        }\n\n        /**\n         * Update state when noteOp was rejected or startOp->finishOp event finished\n         *\n         * @param proxyUid The uid of the proxy\n         * @param proxyPackageName The package name of the proxy\n         * @param proxyAttributionTag the attributionTag in the proxies package\n         * @param uidState UID state of the app noteOp/startOp was called for\n         * @param flags OpFlags of the call\n         */\n        public void accessed(int proxyUid, @Nullable String proxyPackageName,\n                @Nullable String proxyAttributionTag, @AppOpsManager.UidState int uidState,\n                @OpFlags int flags) {\n            long accessTime = System.currentTimeMillis();\n            accessed(accessTime, -1, proxyUid, proxyPackageName,\n                    proxyAttributionTag, uidState, flags);\n\n            mHistoricalRegistry.incrementOpAccessedCount(parent.op, parent.uid, parent.packageName,\n                    tag, uidState, flags, accessTime, AppOpsManager.ATTRIBUTION_FLAGS_NONE,\n                    AppOpsManager.ATTRIBUTION_CHAIN_ID_NONE);\n        }\n\n        /**\n         * Add an access that was previously collected.\n         *\n         * @param noteTime The time of the event\n         * @param duration The duration of the event\n         * @param proxyUid The uid of the proxy\n         * @param proxyPackageName The package name of the proxy\n         * @param proxyAttributionTag the attributionTag in the proxies package\n         * @param uidState UID state of the app noteOp/startOp was called for\n         * @param flags OpFlags of the call\n         */\n        public void accessed(long noteTime, long duration, int proxyUid,\n                @Nullable String proxyPackageName, @Nullable String proxyAttributionTag,\n                @AppOpsManager.UidState int uidState, @OpFlags int flags) {\n            long key = makeKey(uidState, flags);\n\n            if (mAccessEvents == null) {\n                mAccessEvents = new LongSparseArray<>(1);\n            }\n\n            OpEventProxyInfo proxyInfo = null;\n            if (proxyUid != Process.INVALID_UID) {\n                proxyInfo = mOpEventProxyInfoPool.acquire(proxyUid, proxyPackageName,\n                        proxyAttributionTag);\n            }\n\n            NoteOpEvent existingEvent = mAccessEvents.get(key);\n            if (existingEvent != null) {\n                existingEvent.reinit(noteTime, duration, proxyInfo, mOpEventProxyInfoPool);\n            } else {\n                mAccessEvents.put(key, new NoteOpEvent(noteTime, duration, proxyInfo));\n            }\n        }\n\n        /**\n         * Update state when noteOp/startOp was rejected.\n         *\n         * @param uidState UID state of the app noteOp is called for\n         * @param flags OpFlags of the call\n         */\n        public void rejected(@AppOpsManager.UidState int uidState, @OpFlags int flags) {\n            rejected(System.currentTimeMillis(), uidState, flags);\n\n            mHistoricalRegistry.incrementOpRejected(parent.op, parent.uid, parent.packageName,\n                    tag, uidState, flags);\n        }\n\n        /**\n         * Add an rejection that was previously collected\n         *\n         * @param noteTime The time of the event\n         * @param uidState UID state of the app noteOp/startOp was called for\n         * @param flags OpFlags of the call\n         */\n        public void rejected(long noteTime, @AppOpsManager.UidState int uidState,\n                @OpFlags int flags) {\n            long key = makeKey(uidState, flags);\n\n            if (mRejectEvents == null) {\n                mRejectEvents = new LongSparseArray<>(1);\n            }\n\n            // We do not collect proxy information for rejections yet\n            NoteOpEvent existingEvent = mRejectEvents.get(key);\n            if (existingEvent != null) {\n                existingEvent.reinit(noteTime, -1, null, mOpEventProxyInfoPool);\n            } else {\n                mRejectEvents.put(key, new NoteOpEvent(noteTime, -1, null));\n            }\n        }\n\n        /**\n         * Update state when start was called\n         *\n         * @param clientId Id of the startOp caller\n         * @param proxyUid The UID of the proxy app\n         * @param proxyPackageName The package name of the proxy app\n         * @param proxyAttributionTag The attribution tag of the proxy app\n         * @param uidState UID state of the app startOp is called for\n         * @param flags The proxy flags\n         * @param attributionFlags The attribution flags associated with this operation.\n         * @param attributionChainId The if of the attribution chain this operations is a part of.\n         */\n        public void started(@NonNull IBinder clientId, int proxyUid,\n                @Nullable String proxyPackageName, @Nullable String proxyAttributionTag,\n                @AppOpsManager.UidState int uidState, @OpFlags int flags, @AttributionFlags\n                int attributionFlags, int attributionChainId) throws RemoteException {\n            started(clientId, proxyUid, proxyPackageName, proxyAttributionTag,\n                    uidState, flags,/*triggerCallbackIfNeeded*/ true, attributionFlags,\n                    attributionChainId);\n        }\n\n        private void started(@NonNull IBinder clientId, int proxyUid,\n                @Nullable String proxyPackageName, @Nullable String proxyAttributionTag,\n                @AppOpsManager.UidState int uidState, @OpFlags int flags,\n                boolean triggerCallbackIfNeeded, @AttributionFlags int attributionFlags,\n                int attributionChainId) throws RemoteException {\n            startedOrPaused(clientId, proxyUid, proxyPackageName,\n                    proxyAttributionTag, uidState, flags, triggerCallbackIfNeeded,\n                    /*triggerCallbackIfNeeded*/ true, attributionFlags, attributionChainId);\n        }\n\n        private void startedOrPaused(@NonNull IBinder clientId, int proxyUid,\n                @Nullable String proxyPackageName, @Nullable String proxyAttributionTag,\n                @AppOpsManager.UidState int uidState, @OpFlags int flags,\n                boolean triggerCallbackIfNeeded, boolean isStarted, @AttributionFlags\n                int attributionFlags, int attributionChainId) throws RemoteException {\n            if (triggerCallbackIfNeeded && !parent.isRunning() && isStarted) {\n                scheduleOpActiveChangedIfNeededLocked(parent.op, parent.uid, parent.packageName,\n                        tag, true, attributionFlags, attributionChainId);\n            }\n\n            if (isStarted && mInProgressEvents == null) {\n                mInProgressEvents = new ArrayMap<>(1);\n            } else if (!isStarted && mPausedInProgressEvents == null) {\n                mPausedInProgressEvents = new ArrayMap<>(1);\n            }\n            ArrayMap<IBinder, InProgressStartOpEvent> events = isStarted\n                    ? mInProgressEvents : mPausedInProgressEvents;\n\n            long startTime = System.currentTimeMillis();\n            InProgressStartOpEvent event = events.get(clientId);\n            if (event == null) {\n                event = mInProgressStartOpEventPool.acquire(startTime,\n                        SystemClock.elapsedRealtime(), clientId, tag,\n                        PooledLambda.obtainRunnable(AppOpsService::onClientDeath, this, clientId),\n                        proxyUid, proxyPackageName, proxyAttributionTag, uidState, flags,\n                        attributionFlags, attributionChainId);\n                events.put(clientId, event);\n            } else {\n                if (uidState != event.mUidState) {\n                    onUidStateChanged(uidState);\n                }\n            }\n\n            event.numUnfinishedStarts++;\n\n            if (isStarted) {\n                mHistoricalRegistry.incrementOpAccessedCount(parent.op, parent.uid,\n                        parent.packageName, tag, uidState, flags, startTime, attributionFlags,\n                        attributionChainId);\n            }\n        }\n\n        /**\n         * Update state when finishOp was called. Will finish started ops, and delete paused ops.\n         *\n         * @param clientId Id of the finishOp caller\n         */\n        public void finished(@NonNull IBinder clientId) {\n            finished(clientId, true);\n        }\n\n        private void finished(@NonNull IBinder clientId, boolean triggerCallbackIfNeeded) {\n            finishOrPause(clientId, triggerCallbackIfNeeded, false);\n        }\n\n        /**\n         * Update state when paused or finished is called. If pausing, it records the op as\n         * stopping in the HistoricalRegistry, but does not delete it.\n         */\n        private void finishOrPause(@NonNull IBinder clientId, boolean triggerCallbackIfNeeded,\n                boolean isPausing) {\n            int indexOfToken = isRunning() ? mInProgressEvents.indexOfKey(clientId) : -1;\n            if (indexOfToken < 0) {\n                finishPossiblyPaused(clientId, isPausing);\n                return;\n            }\n\n            InProgressStartOpEvent event = mInProgressEvents.valueAt(indexOfToken);\n            if (!isPausing) {\n                event.numUnfinishedStarts--;\n            }\n            // If we are pausing, create a NoteOpEvent, but don't change the InProgress event\n            if (event.numUnfinishedStarts == 0 || isPausing) {\n                if (!isPausing) {\n                    event.finish();\n                    mInProgressEvents.removeAt(indexOfToken);\n                }\n\n                if (mAccessEvents == null) {\n                    mAccessEvents = new LongSparseArray<>(1);\n                }\n\n                OpEventProxyInfo proxyCopy = event.getProxy() != null\n                        ? new OpEventProxyInfo(event.getProxy()) : null;\n\n                long accessDurationMillis =\n                        SystemClock.elapsedRealtime() - event.getStartElapsedTime();\n                NoteOpEvent finishedEvent = new NoteOpEvent(event.getStartTime(),\n                        accessDurationMillis, proxyCopy);\n                mAccessEvents.put(makeKey(event.getUidState(), event.getFlags()),\n                        finishedEvent);\n\n                mHistoricalRegistry.increaseOpAccessDuration(parent.op, parent.uid,\n                        parent.packageName, tag, event.getUidState(),\n                        event.getFlags(), finishedEvent.getNoteTime(), finishedEvent.getDuration(),\n                        event.getAttributionFlags(), event.getAttributionChainId());\n\n                if (!isPausing) {\n                    mInProgressStartOpEventPool.release(event);\n                    if (mInProgressEvents.isEmpty()) {\n                        mInProgressEvents = null;\n\n                        // TODO ntmyren: Also callback for single attribution tag activity changes\n                        if (triggerCallbackIfNeeded && !parent.isRunning()) {\n                            scheduleOpActiveChangedIfNeededLocked(parent.op, parent.uid,\n                                    parent.packageName, tag, false, event.getAttributionFlags(),\n                                    event.getAttributionChainId());\n                        }\n                    }\n                }\n            }\n        }\n\n        // Finish or pause (no-op) an already paused op\n        private void finishPossiblyPaused(@NonNull IBinder clientId, boolean isPausing) {\n            if (!isPaused()) {\n                Slog.wtf(TAG, \"No ops running or paused\");\n                return;\n            }\n\n            int indexOfToken = mPausedInProgressEvents.indexOfKey(clientId);\n            if (indexOfToken < 0) {\n                Slog.wtf(TAG, \"No op running or paused for the client\");\n                return;\n            } else if (isPausing) {\n                // already paused\n                return;\n            }\n\n            // no need to record a paused event finishing.\n            InProgressStartOpEvent event = mPausedInProgressEvents.valueAt(indexOfToken);\n            event.numUnfinishedStarts--;\n            if (event.numUnfinishedStarts == 0) {\n                mPausedInProgressEvents.removeAt(indexOfToken);\n                mInProgressStartOpEventPool.release(event);\n                if (mPausedInProgressEvents.isEmpty()) {\n                    mPausedInProgressEvents = null;\n                }\n            }\n        }\n\n        /**\n         * Create an event that will be started, if the op is unpaused.\n         */\n        public void createPaused(@NonNull IBinder clientId, int proxyUid,\n                @Nullable String proxyPackageName, @Nullable String proxyAttributionTag,\n                @AppOpsManager.UidState int uidState, @OpFlags int flags, @AttributionFlags\n                int attributionFlags, int attributionChainId) throws RemoteException {\n            startedOrPaused(clientId, proxyUid, proxyPackageName, proxyAttributionTag,\n                    uidState, flags, true, false, attributionFlags, attributionChainId);\n        }\n\n        /**\n         * Pause all currently started ops. This will create a HistoricalRegistry\n         */\n        public void pause() {\n            if (!isRunning()) {\n                return;\n            }\n\n            if (mPausedInProgressEvents == null) {\n                mPausedInProgressEvents = new ArrayMap<>(1);\n            }\n\n            for (int i = 0; i < mInProgressEvents.size(); i++) {\n                InProgressStartOpEvent event = mInProgressEvents.valueAt(i);\n                mPausedInProgressEvents.put(event.mClientId, event);\n                finishOrPause(event.mClientId, true, true);\n\n                scheduleOpActiveChangedIfNeededLocked(parent.op, parent.uid,\n                        parent.packageName, tag, false,\n                        event.getAttributionFlags(), event.getAttributionChainId());\n            }\n            mInProgressEvents = null;\n        }\n\n        /**\n         * Unpause all currently paused ops. This will reinitialize their start and duration\n         * times, but keep all other values the same\n         */\n        public void resume() {\n            if (!isPaused()) {\n                return;\n            }\n\n            if (mInProgressEvents == null) {\n                mInProgressEvents = new ArrayMap<>(mPausedInProgressEvents.size());\n            }\n            boolean shouldSendActive = !mPausedInProgressEvents.isEmpty()\n                    && mInProgressEvents.isEmpty();\n\n            long startTime = System.currentTimeMillis();\n            for (int i = 0; i < mPausedInProgressEvents.size(); i++) {\n                InProgressStartOpEvent event = mPausedInProgressEvents.valueAt(i);\n                mInProgressEvents.put(event.mClientId, event);\n                event.mStartElapsedTime = SystemClock.elapsedRealtime();\n                event.mStartTime = startTime;\n                mHistoricalRegistry.incrementOpAccessedCount(parent.op, parent.uid,\n                        parent.packageName, tag, event.mUidState, event.mFlags, startTime,\n                        event.getAttributionFlags(), event.getAttributionChainId());\n                if (shouldSendActive) {\n                    scheduleOpActiveChangedIfNeededLocked(parent.op, parent.uid, parent.packageName,\n                            tag, true, event.getAttributionFlags(), event.getAttributionChainId());\n                }\n                // Note: this always sends MODE_ALLOWED, even if the mode is FOREGROUND\n                // TODO ntmyren: figure out how to get the real mode.\n                scheduleOpStartedIfNeededLocked(parent.op, parent.uid, parent.packageName,\n                        tag, event.getFlags(), MODE_ALLOWED, START_TYPE_RESUMED,\n                        event.getAttributionFlags(), event.getAttributionChainId());\n            }\n            mPausedInProgressEvents = null;\n        }\n\n        /**\n         * Called in the case the client dies without calling finish first\n         *\n         * @param clientId The client that died\n         */\n        void onClientDeath(@NonNull IBinder clientId) {\n            synchronized (AppOpsService.this) {\n                if (!isPaused() && !isRunning()) {\n                    return;\n                }\n\n                ArrayMap<IBinder, InProgressStartOpEvent> events = isPaused()\n                        ? mPausedInProgressEvents : mInProgressEvents;\n                InProgressStartOpEvent deadEvent = events.get(clientId);\n                if (deadEvent != null) {\n                    deadEvent.numUnfinishedStarts = 1;\n                }\n\n                finished(clientId);\n            }\n        }\n\n        /**\n         * Notify that the state of the uid changed\n         *\n         * @param newState The new state\n         */\n        public void onUidStateChanged(@AppOpsManager.UidState int newState) {\n            if (!isPaused() && !isRunning()) {\n                return;\n            }\n\n            boolean isRunning = isRunning();\n            ArrayMap<IBinder, AppOpsService.InProgressStartOpEvent> events =\n                    isRunning ? mInProgressEvents : mPausedInProgressEvents;\n\n            int numInProgressEvents = events.size();\n            List<IBinder> binders = new ArrayList<>(events.keySet());\n            for (int i = 0; i < numInProgressEvents; i++) {\n                InProgressStartOpEvent event = events.get(binders.get(i));\n\n                if (event != null && event.getUidState() != newState) {\n                    try {\n                        // Remove all but one unfinished start count and then call finished() to\n                        // remove start event object\n                        int numPreviousUnfinishedStarts = event.numUnfinishedStarts;\n                        event.numUnfinishedStarts = 1;\n                        OpEventProxyInfo proxy = event.getProxy();\n\n                        finished(event.getClientId(), false);\n\n                        // Call started() to add a new start event object and then add the\n                        // previously removed unfinished start counts back\n                        if (proxy != null) {\n                            startedOrPaused(event.getClientId(), proxy.getUid(),\n                                    proxy.getPackageName(), proxy.getAttributionTag(), newState,\n                                    event.getFlags(), false, isRunning,\n                                    event.getAttributionFlags(), event.getAttributionChainId());\n                        } else {\n                            startedOrPaused(event.getClientId(), Process.INVALID_UID, null, null,\n                                    newState, event.getFlags(), false, isRunning,\n                                    event.getAttributionFlags(), event.getAttributionChainId());\n                        }\n\n                        events = isRunning ? mInProgressEvents : mPausedInProgressEvents;\n                        InProgressStartOpEvent newEvent = events.get(binders.get(i));\n                        if (newEvent != null) {\n                            newEvent.numUnfinishedStarts += numPreviousUnfinishedStarts - 1;\n                        }\n                    } catch (RemoteException e) {\n                        if (DEBUG) Slog.e(TAG, \"Cannot switch to new uidState \" + newState);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Combine {@code a} and {@code b} and return the result. The result might be {@code a}\n         * or {@code b}. If there is an event for the same key in both the later event is retained.\n         */\n        private @Nullable LongSparseArray<NoteOpEvent> add(@Nullable LongSparseArray<NoteOpEvent> a,\n                @Nullable LongSparseArray<NoteOpEvent> b) {\n            if (a == null) {\n                return b;\n            }\n\n            if (b == null) {\n                return a;\n            }\n\n            int numEventsToAdd = b.size();\n            for (int i = 0; i < numEventsToAdd; i++) {\n                long keyOfEventToAdd = b.keyAt(i);\n                NoteOpEvent bEvent = b.valueAt(i);\n                NoteOpEvent aEvent = a.get(keyOfEventToAdd);\n\n                if (aEvent == null || bEvent.getNoteTime() > aEvent.getNoteTime()) {\n                    a.put(keyOfEventToAdd, bEvent);\n                }\n            }\n\n            return a;\n        }\n\n        /**\n         * Add all data from the {@code opToAdd} to this op.\n         *\n         * <p>If there is an event for the same key in both the later event is retained.\n         * <p>{@code opToAdd} should not be used after this method is called.\n         *\n         * @param opToAdd The op to add\n         */\n        public void add(@NonNull AttributedOp opToAdd) {\n            if (opToAdd.isRunning() || opToAdd.isPaused()) {\n                ArrayMap<IBinder, InProgressStartOpEvent> ignoredEvents = opToAdd.isRunning()\n                        ? opToAdd.mInProgressEvents : opToAdd.mPausedInProgressEvents;\n                Slog.w(TAG, \"Ignoring \" + ignoredEvents.size() + \" app-ops, running: \"\n                        + opToAdd.isRunning());\n\n                int numInProgressEvents = ignoredEvents.size();\n                for (int i = 0; i < numInProgressEvents; i++) {\n                    InProgressStartOpEvent event = ignoredEvents.valueAt(i);\n\n                    event.finish();\n                    mInProgressStartOpEventPool.release(event);\n                }\n            }\n\n            mAccessEvents = add(mAccessEvents, opToAdd.mAccessEvents);\n            mRejectEvents = add(mRejectEvents, opToAdd.mRejectEvents);\n        }\n\n        public boolean isRunning() {\n            return mInProgressEvents != null && !mInProgressEvents.isEmpty();\n        }\n\n        public boolean isPaused() {\n            return mPausedInProgressEvents != null && !mPausedInProgressEvents.isEmpty();\n        }\n\n        boolean hasAnyTime() {\n            return (mAccessEvents != null && mAccessEvents.size() > 0)\n                    || (mRejectEvents != null && mRejectEvents.size() > 0);\n        }\n\n        /**\n         * Clone a {@link LongSparseArray} and clone all values.\n         */\n        private @Nullable LongSparseArray<NoteOpEvent> deepClone(\n                @Nullable LongSparseArray<NoteOpEvent> original) {\n            if (original == null) {\n                return original;\n            }\n\n            int size = original.size();\n            LongSparseArray<NoteOpEvent> clone = new LongSparseArray<>(size);\n            for (int i = 0; i < size; i++) {\n                clone.put(original.keyAt(i), new NoteOpEvent(original.valueAt(i)));\n            }\n\n            return clone;\n        }\n\n        @NonNull AttributedOpEntry createAttributedOpEntryLocked() {\n            LongSparseArray<NoteOpEvent> accessEvents = deepClone(mAccessEvents);\n\n            // Add in progress events as access events\n            if (isRunning()) {\n                long now = SystemClock.elapsedRealtime();\n                int numInProgressEvents = mInProgressEvents.size();\n\n                if (accessEvents == null) {\n                    accessEvents = new LongSparseArray<>(numInProgressEvents);\n                }\n\n                for (int i = 0; i < numInProgressEvents; i++) {\n                    InProgressStartOpEvent event = mInProgressEvents.valueAt(i);\n\n                    accessEvents.append(makeKey(event.getUidState(), event.getFlags()),\n                            new NoteOpEvent(event.getStartTime(), now - event.getStartElapsedTime(),\n                                    event.getProxy()));\n                }\n            }\n\n            LongSparseArray<NoteOpEvent> rejectEvents = deepClone(mRejectEvents);\n\n            return new AttributedOpEntry(parent.op, isRunning(), accessEvents, rejectEvents);\n        }\n    }\n\n    final class Op {\n        int op;\n        int uid;\n        final UidState uidState;\n        final @NonNull String packageName;\n\n        private @Mode int mode;\n\n        /** attributionTag -> AttributedOp */\n        final ArrayMap<String, AttributedOp> mAttributions = new ArrayMap<>(1);\n\n        Op(UidState uidState, String packageName, int op, int uid) {\n            this.op = op;\n            this.uid = uid;\n            this.uidState = uidState;\n            this.packageName = packageName;\n            this.mode = AppOpsManager.opToDefaultMode(op);\n        }\n\n        int getMode() {\n            return mode;\n        }\n\n        int evalMode() {\n            return uidState.evalMode(op, mode);\n        }\n\n        void removeAttributionsWithNoTime() {\n            for (int i = mAttributions.size() - 1; i >= 0; i--) {\n                if (!mAttributions.valueAt(i).hasAnyTime()) {\n                    mAttributions.removeAt(i);\n                }\n            }\n        }\n\n        private @NonNull AttributedOp getOrCreateAttribution(@NonNull Op parent,\n                @Nullable String attributionTag) {\n            AttributedOp attributedOp;\n\n            attributedOp = mAttributions.get(attributionTag);\n            if (attributedOp == null) {\n                attributedOp = new AttributedOp(attributionTag, parent);\n                mAttributions.put(attributionTag, attributedOp);\n            }\n\n            return attributedOp;\n        }\n\n        @NonNull OpEntry createEntryLocked() {\n            final int numAttributions = mAttributions.size();\n\n            final ArrayMap<String, AppOpsManager.AttributedOpEntry> attributionEntries =\n                    new ArrayMap<>(numAttributions);\n            for (int i = 0; i < numAttributions; i++) {\n                attributionEntries.put(mAttributions.keyAt(i),\n                        mAttributions.valueAt(i).createAttributedOpEntryLocked());\n            }\n\n            return new OpEntry(op, mode, attributionEntries);\n        }\n\n        @NonNull OpEntry createSingleAttributionEntryLocked(@Nullable String attributionTag) {\n            final int numAttributions = mAttributions.size();\n\n            final ArrayMap<String, AttributedOpEntry> attributionEntries = new ArrayMap<>(1);\n            for (int i = 0; i < numAttributions; i++) {\n                if (Objects.equals(mAttributions.keyAt(i), attributionTag)) {\n                    attributionEntries.put(mAttributions.keyAt(i),\n                            mAttributions.valueAt(i).createAttributedOpEntryLocked());\n                    break;\n                }\n            }\n\n            return new OpEntry(op, mode, attributionEntries);\n        }\n\n        boolean isRunning() {\n            final int numAttributions = mAttributions.size();\n            for (int i = 0; i < numAttributions; i++) {\n                if (mAttributions.valueAt(i).isRunning()) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n\n    final SparseArray<ArraySet<ModeCallback>> mOpModeWatchers = new SparseArray<>();\n    final ArrayMap<String, ArraySet<ModeCallback>> mPackageModeWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, ModeCallback> mModeWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<ActiveCallback>> mActiveWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<StartedCallback>> mStartedWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<NotedCallback>> mNotedWatchers = new ArrayMap<>();\n    final AudioRestrictionManager mAudioRestrictionManager = new AudioRestrictionManager();\n\n    final class ModeCallback implements DeathRecipient {\n        /** If mWatchedOpCode==ALL_OPS notify for ops affected by the switch-op */\n        public static final int ALL_OPS = -2;\n\n        final IAppOpsCallback mCallback;\n        final int mWatchingUid;\n        final int mFlags;\n        final int mWatchedOpCode;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        ModeCallback(IAppOpsCallback callback, int watchingUid, int flags, int watchedOp,\n                int callingUid, int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mFlags = flags;\n            mWatchedOpCode = watchedOp;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        public boolean isWatchingUid(int uid) {\n            return uid == UID_ANY || mWatchingUid < 0 || mWatchingUid == uid;\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"ModeCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" flags=0x\");\n            sb.append(Integer.toHexString(mFlags));\n            switch (mWatchedOpCode) {\n                case OP_NONE:\n                    break;\n                case ALL_OPS:\n                    sb.append(\" op=(all)\");\n                    break;\n                default:\n                    sb.append(\" op=\");\n                    sb.append(opToName(mWatchedOpCode));\n                    break;\n            }\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void unlinkToDeath() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingMode(mCallback);\n        }\n    }\n\n    final class ActiveCallback implements DeathRecipient {\n        final IAppOpsActiveCallback mCallback;\n        final int mWatchingUid;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        ActiveCallback(IAppOpsActiveCallback callback, int watchingUid, int callingUid,\n                int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"ActiveCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void destroy() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingActive(mCallback);\n        }\n    }\n\n    final class StartedCallback implements DeathRecipient {\n        final IAppOpsStartedCallback mCallback;\n        final int mWatchingUid;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        StartedCallback(IAppOpsStartedCallback callback, int watchingUid, int callingUid,\n                int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"StartedCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void destroy() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingStarted(mCallback);\n        }\n    }\n\n    final class NotedCallback implements DeathRecipient {\n        final IAppOpsNotedCallback mCallback;\n        final int mWatchingUid;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        NotedCallback(IAppOpsNotedCallback callback, int watchingUid, int callingUid,\n                int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"NotedCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void destroy() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingNoted(mCallback);\n        }\n    }\n\n    /**\n     * Call {@link AttributedOp#onClientDeath attributedOp.onClientDeath(clientId)}.\n     */\n    private static void onClientDeath(@NonNull AttributedOp attributedOp,\n            @NonNull IBinder clientId) {\n        attributedOp.onClientDeath(clientId);\n    }\n\n\n    /**\n     * Loads the OpsValidation file results into a hashmap {@link #mNoteOpCallerStacktraces}\n     * so that we do not log the same operation twice between instances\n     */\n    private void readNoteOpCallerStackTraces() {\n        try {\n            if (!mNoteOpCallerStacktracesFile.exists()) {\n                mNoteOpCallerStacktracesFile.createNewFile();\n                return;\n            }\n\n            try (Scanner read = new Scanner(mNoteOpCallerStacktracesFile)) {\n                read.useDelimiter(\"\\\\},\");\n                while (read.hasNext()) {\n                    String jsonOps = read.next();\n                    mNoteOpCallerStacktraces.add(NoteOpTrace.fromJson(jsonOps));\n                }\n            }\n        } catch (Exception e) {\n            Slog.e(TAG, \"Cannot parse traces noteOps\", e);\n        }\n    }\n\n    public AppOpsService(File storagePath, Handler handler, Context context) {\n        mContext = context;\n\n        LockGuard.installLock(this, LockGuard.INDEX_APP_OPS);\n        mFile = new AtomicFile(storagePath, \"appops\");\n        if (AppOpsManager.NOTE_OP_COLLECTION_ENABLED) {\n            mNoteOpCallerStacktracesFile = new File(SystemServiceManager.ensureSystemDir(),\n                    \"noteOpStackTraces.json\");\n            readNoteOpCallerStackTraces();\n        } else {\n            mNoteOpCallerStacktracesFile = null;\n        }\n        mHandler = handler;\n        mConstants = new Constants(mHandler);\n        readState();\n\n        for (int switchedCode = 0; switchedCode < _NUM_OP; switchedCode++) {\n            int switchCode = AppOpsManager.opToSwitch(switchedCode);\n            mSwitchedOps.put(switchCode,\n                    ArrayUtils.appendInt(mSwitchedOps.get(switchCode), switchedCode));\n        }\n    }\n\n    public void publish() {\n        ServiceManager.addService(Context.APP_OPS_SERVICE, asBinder());\n        LocalServices.addService(AppOpsManagerInternal.class, mAppOpsManagerInternal);\n    }\n\n    /** Handler for work when packages are removed or updated */\n    private BroadcastReceiver mOnPackageUpdatedReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            String pkgName = intent.getData().getEncodedSchemeSpecificPart();\n            int uid = intent.getIntExtra(Intent.EXTRA_UID, Process.INVALID_UID);\n\n            if (action.equals(ACTION_PACKAGE_REMOVED) && !intent.hasExtra(EXTRA_REPLACING)) {\n                synchronized (AppOpsService.this) {\n                    UidState uidState = mUidStates.get(uid);\n                    if (uidState == null || uidState.pkgOps == null) {\n                        return;\n                    }\n\n                    Ops removedOps = uidState.pkgOps.remove(pkgName);\n                    if (removedOps != null) {\n                        scheduleFastWriteLocked();\n                    }\n                }\n            } else if (action.equals(Intent.ACTION_PACKAGE_REPLACED)) {\n                AndroidPackage pkg = getPackageManagerInternal().getPackage(pkgName);\n                if (pkg == null) {\n                    return;\n                }\n\n                ArrayMap<String, String> dstAttributionTags = new ArrayMap<>();\n                ArraySet<String> attributionTags = new ArraySet<>();\n                attributionTags.add(null);\n                if (pkg.getAttributions() != null) {\n                    int numAttributions = pkg.getAttributions().size();\n                    for (int attributionNum = 0; attributionNum < numAttributions;\n                            attributionNum++) {\n                        ParsedAttribution attribution = pkg.getAttributions().get(attributionNum);\n                        attributionTags.add(attribution.getTag());\n\n                        int numInheritFrom = attribution.getInheritFrom().size();\n                        for (int inheritFromNum = 0; inheritFromNum < numInheritFrom;\n                                inheritFromNum++) {\n                            dstAttributionTags.put(attribution.getInheritFrom().get(inheritFromNum),\n                                    attribution.getTag());\n                        }\n                    }\n                }\n\n                synchronized (AppOpsService.this) {\n                    UidState uidState = mUidStates.get(uid);\n                    if (uidState == null || uidState.pkgOps == null) {\n                        return;\n                    }\n\n                    Ops ops = uidState.pkgOps.get(pkgName);\n                    if (ops == null) {\n                        return;\n                    }\n\n                    // Reset cached package properties to re-initialize when needed\n                    ops.bypass = null;\n                    ops.knownAttributionTags.clear();\n\n                    // Merge data collected for removed attributions into their successor\n                    // attributions\n                    int numOps = ops.size();\n                    for (int opNum = 0; opNum < numOps; opNum++) {\n                        Op op = ops.valueAt(opNum);\n\n                        int numAttributions = op.mAttributions.size();\n                        for (int attributionNum = numAttributions - 1; attributionNum >= 0;\n                                attributionNum--) {\n                            String attributionTag = op.mAttributions.keyAt(attributionNum);\n\n                            if (attributionTags.contains(attributionTag)) {\n                                // attribution still exist after upgrade\n                                continue;\n                            }\n\n                            String newAttributionTag = dstAttributionTags.get(attributionTag);\n\n                            AttributedOp newAttributedOp = op.getOrCreateAttribution(op,\n                                    newAttributionTag);\n                            newAttributedOp.add(op.mAttributions.valueAt(attributionNum));\n                            op.mAttributions.removeAt(attributionNum);\n\n                            scheduleFastWriteLocked();\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    public void systemReady() {\n        mConstants.startMonitoring(mContext.getContentResolver());\n        mHistoricalRegistry.systemReady(mContext.getContentResolver());\n\n        IntentFilter packageUpdateFilter = new IntentFilter();\n        packageUpdateFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);\n        packageUpdateFilter.addAction(Intent.ACTION_PACKAGE_REPLACED);\n        packageUpdateFilter.addDataScheme(\"package\");\n\n        mContext.registerReceiverAsUser(mOnPackageUpdatedReceiver, UserHandle.ALL,\n                packageUpdateFilter, null, null);\n\n        synchronized (this) {\n            for (int uidNum = mUidStates.size() - 1; uidNum >= 0; uidNum--) {\n                int uid = mUidStates.keyAt(uidNum);\n                UidState uidState = mUidStates.valueAt(uidNum);\n\n                String[] pkgsInUid = getPackagesForUid(uidState.uid);\n                if (ArrayUtils.isEmpty(pkgsInUid)) {\n                    uidState.clear();\n                    mUidStates.removeAt(uidNum);\n                    scheduleFastWriteLocked();\n                    continue;\n                }\n\n                ArrayMap<String, Ops> pkgs = uidState.pkgOps;\n                if (pkgs == null) {\n                    continue;\n                }\n\n                int numPkgs = pkgs.size();\n                for (int pkgNum = 0; pkgNum < numPkgs; pkgNum++) {\n                    String pkg = pkgs.keyAt(pkgNum);\n\n                    String action;\n                    if (!ArrayUtils.contains(pkgsInUid, pkg)) {\n                        action = Intent.ACTION_PACKAGE_REMOVED;\n                    } else {\n                        action = Intent.ACTION_PACKAGE_REPLACED;\n                    }\n\n                    SystemServerInitThreadPool.submit(\n                            () -> mOnPackageUpdatedReceiver.onReceive(mContext, new Intent(action)\n                                    .setData(Uri.fromParts(\"package\", pkg, null))\n                                    .putExtra(Intent.EXTRA_UID, uid)),\n                            \"Update app-ops uidState in case package \" + pkg + \" changed\");\n                }\n            }\n        }\n\n        final IntentFilter packageSuspendFilter = new IntentFilter();\n        packageSuspendFilter.addAction(Intent.ACTION_PACKAGES_UNSUSPENDED);\n        packageSuspendFilter.addAction(Intent.ACTION_PACKAGES_SUSPENDED);\n        mContext.registerReceiverAsUser(new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                final int[] changedUids = intent.getIntArrayExtra(Intent.EXTRA_CHANGED_UID_LIST);\n                final String[] changedPkgs = intent.getStringArrayExtra(\n                        Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                for (int code : OPS_RESTRICTED_ON_SUSPEND) {\n                    ArraySet<ModeCallback> callbacks;\n                    synchronized (AppOpsService.this) {\n                        callbacks = mOpModeWatchers.get(code);\n                        if (callbacks == null) {\n                            continue;\n                        }\n                        callbacks = new ArraySet<>(callbacks);\n                    }\n                    for (int i = 0; i < changedUids.length; i++) {\n                        final int changedUid = changedUids[i];\n                        final String changedPkg = changedPkgs[i];\n                        // We trust packagemanager to insert matching uid and packageNames in the\n                        // extras\n                        notifyOpChanged(callbacks, code, changedUid, changedPkg);\n                    }\n                }\n            }\n        }, UserHandle.ALL, packageSuspendFilter, null, null);\n\n        final IntentFilter packageAddedFilter = new IntentFilter();\n        packageAddedFilter.addAction(Intent.ACTION_PACKAGE_ADDED);\n        packageAddedFilter.addDataScheme(\"package\");\n        mContext.registerReceiver(new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                final Uri data = intent.getData();\n\n                final String packageName = data.getSchemeSpecificPart();\n                PackageInfo pi = getPackageManagerInternal().getPackageInfo(packageName,\n                        PackageManager.GET_PERMISSIONS, Process.myUid(), mContext.getUserId());\n                if (isSamplingTarget(pi)) {\n                    synchronized (this) {\n                        mRarelyUsedPackages.add(packageName);\n                    }\n                }\n            }\n        }, packageAddedFilter);\n\n        mHandler.postDelayed(new Runnable() {\n            @Override\n            public void run() {\n                List<String> packageNames = getPackageListAndResample();\n                initializeRarelyUsedPackagesList(new ArraySet<>(packageNames));\n            }\n        }, RARELY_USED_PACKAGES_INITIALIZATION_DELAY_MILLIS);\n\n        getPackageManagerInternal().setExternalSourcesPolicy(\n                new PackageManagerInternal.ExternalSourcesPolicy() {\n                    @Override\n                    public int getPackageTrustedToInstallApps(String packageName, int uid) {\n                        int appOpMode = checkOperation(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                                uid, packageName);\n                        switch (appOpMode) {\n                            case AppOpsManager.MODE_ALLOWED:\n                                return PackageManagerInternal.ExternalSourcesPolicy.USER_TRUSTED;\n                            case AppOpsManager.MODE_ERRORED:\n                                return PackageManagerInternal.ExternalSourcesPolicy.USER_BLOCKED;\n                            default:\n                                return PackageManagerInternal.ExternalSourcesPolicy.USER_DEFAULT;\n                        }\n                    }\n                });\n\n        mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);\n    }\n\n    /**\n     * Sets a policy for handling app ops.\n     *\n     * @param policy The policy.\n     */\n    public void setAppOpsPolicy(@Nullable CheckOpsDelegate policy) {\n        final CheckOpsDelegateDispatcher oldDispatcher = mCheckOpsDelegateDispatcher;\n        final CheckOpsDelegate delegate = (oldDispatcher != null)\n                ? oldDispatcher.mCheckOpsDelegate : null;\n        mCheckOpsDelegateDispatcher = new CheckOpsDelegateDispatcher(policy, delegate);\n    }\n\n    public void packageRemoved(int uid, String packageName) {\n        synchronized (this) {\n            UidState uidState = mUidStates.get(uid);\n            if (uidState == null) {\n                return;\n            }\n\n            Ops ops = null;\n\n            // Remove any package state if such.\n            if (uidState.pkgOps != null) {\n                ops = uidState.pkgOps.remove(packageName);\n            }\n\n            // If we just nuked the last package state check if the UID is valid.\n            if (ops != null && uidState.pkgOps.isEmpty()\n                    && getPackagesForUid(uid).length <= 0) {\n                mUidStates.remove(uid);\n            }\n\n            if (ops != null) {\n                scheduleFastWriteLocked();\n\n                final int numOps = ops.size();\n                for (int opNum = 0; opNum < numOps; opNum++) {\n                    final Op op = ops.valueAt(opNum);\n\n                    final int numAttributions = op.mAttributions.size();\n                    for (int attributionNum = 0; attributionNum < numAttributions;\n                            attributionNum++) {\n                        AttributedOp attributedOp = op.mAttributions.valueAt(attributionNum);\n\n                        while (attributedOp.isRunning()) {\n                            attributedOp.finished(attributedOp.mInProgressEvents.keyAt(0));\n                        }\n                        while (attributedOp.isPaused()) {\n                            attributedOp.finished(attributedOp.mPausedInProgressEvents.keyAt(0));\n                        }\n                    }\n                }\n            }\n        }\n\n        mHandler.post(PooledLambda.obtainRunnable(HistoricalRegistry::clearHistory,\n                    mHistoricalRegistry, uid, packageName));\n    }\n\n    public void uidRemoved(int uid) {\n        synchronized (this) {\n            if (mUidStates.indexOfKey(uid) >= 0) {\n                mUidStates.remove(uid);\n                scheduleFastWriteLocked();\n            }\n        }\n    }\n\n    /**\n     * Update the pending state for the uid\n     *\n     * @param currentTime The current elapsed real time\n     * @param uid The uid that has a pending state\n     */\n    private void updatePendingState(long currentTime, int uid) {\n        synchronized (this) {\n            mLastRealtime = max(currentTime, mLastRealtime);\n            updatePendingStateIfNeededLocked(mUidStates.get(uid));\n        }\n    }\n\n    public void updateUidProcState(int uid, int procState,\n            @ActivityManager.ProcessCapability int capability) {\n        synchronized (this) {\n            final UidState uidState = getUidStateLocked(uid, true);\n            final int newState = PROCESS_STATE_TO_UID_STATE[procState];\n            if (uidState != null && (uidState.pendingState != newState\n                    || uidState.pendingCapability != capability)) {\n                final int oldPendingState = uidState.pendingState;\n                uidState.pendingState = newState;\n                uidState.pendingCapability = capability;\n                if (newState < uidState.state\n                        || (newState <= UID_STATE_MAX_LAST_NON_RESTRICTED\n                                && uidState.state > UID_STATE_MAX_LAST_NON_RESTRICTED)) {\n                    // We are moving to a more important state, or the new state may be in the\n                    // foreground and the old state is in the background, then always do it\n                    // immediately.\n                    commitUidPendingStateLocked(uidState);\n                } else if (newState == uidState.state && capability != uidState.capability) {\n                    // No change on process state, but process capability has changed.\n                    commitUidPendingStateLocked(uidState);\n                } else if (uidState.pendingStateCommitTime == 0) {\n                    // We are moving to a less important state for the first time,\n                    // delay the application for a bit.\n                    final long settleTime;\n                    if (uidState.state <= UID_STATE_TOP) {\n                        settleTime = mConstants.TOP_STATE_SETTLE_TIME;\n                    } else if (uidState.state <= UID_STATE_FOREGROUND_SERVICE) {\n                        settleTime = mConstants.FG_SERVICE_STATE_SETTLE_TIME;\n                    } else {\n                        settleTime = mConstants.BG_STATE_SETTLE_TIME;\n                    }\n                    final long commitTime = SystemClock.elapsedRealtime() + settleTime;\n                    uidState.pendingStateCommitTime = commitTime;\n\n                    mHandler.sendMessageDelayed(\n                            PooledLambda.obtainMessage(AppOpsService::updatePendingState, this,\n                                    commitTime + 1, uid), settleTime + 1);\n                }\n\n                if (uidState.pkgOps != null) {\n                    int numPkgs = uidState.pkgOps.size();\n                    for (int pkgNum = 0; pkgNum < numPkgs; pkgNum++) {\n                        Ops ops = uidState.pkgOps.valueAt(pkgNum);\n\n                        int numOps = ops.size();\n                        for (int opNum = 0; opNum < numOps; opNum++) {\n                            Op op = ops.valueAt(opNum);\n\n                            int numAttributions = op.mAttributions.size();\n                            for (int attributionNum = 0; attributionNum < numAttributions;\n                                    attributionNum++) {\n                                AttributedOp attributedOp = op.mAttributions.valueAt(\n                                        attributionNum);\n\n                                attributedOp.onUidStateChanged(newState);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    public void shutdown() {\n        Slog.w(TAG, \"Writing app ops before shutdown...\");\n        boolean doWrite = false;\n        synchronized (this) {\n            if (mWriteScheduled) {\n                mWriteScheduled = false;\n                mFastWriteScheduled = false;\n                mHandler.removeCallbacks(mWriteRunner);\n                doWrite = true;\n            }\n        }\n        if (doWrite) {\n            writeState();\n        }\n        if (AppOpsManager.NOTE_OP_COLLECTION_ENABLED && mWriteNoteOpsScheduled) {\n            writeNoteOps();\n        }\n\n        mHistoricalRegistry.shutdown();\n    }\n\n    private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops) {\n        ArrayList<AppOpsManager.OpEntry> resOps = null;\n        final long elapsedNow = SystemClock.elapsedRealtime();\n        if (ops == null) {\n            resOps = new ArrayList<>();\n            for (int j=0; j<pkgOps.size(); j++) {\n                Op curOp = pkgOps.valueAt(j);\n                resOps.add(getOpEntryForResult(curOp, elapsedNow));\n            }\n        } else {\n            for (int j=0; j<ops.length; j++) {\n                Op curOp = pkgOps.get(ops[j]);\n                if (curOp != null) {\n                    if (resOps == null) {\n                        resOps = new ArrayList<>();\n                    }\n                    resOps.add(getOpEntryForResult(curOp, elapsedNow));\n                }\n            }\n        }\n        return resOps;\n    }\n\n    @Nullable\n    private ArrayList<AppOpsManager.OpEntry> collectUidOps(@NonNull UidState uidState,\n            @Nullable int[] ops) {\n        if (uidState.opModes == null) {\n            return null;\n        }\n\n        int opModeCount = uidState.opModes.size();\n        if (opModeCount == 0) {\n            return null;\n        }\n        ArrayList<AppOpsManager.OpEntry> resOps = null;\n        if (ops == null) {\n            resOps = new ArrayList<>();\n            for (int i = 0; i < opModeCount; i++) {\n                int code = uidState.opModes.keyAt(i);\n                resOps.add(new OpEntry(code, uidState.opModes.get(code), Collections.emptyMap()));\n            }\n        } else {\n            for (int j=0; j<ops.length; j++) {\n                int code = ops[j];\n                if (uidState.opModes.indexOfKey(code) >= 0) {\n                    if (resOps == null) {\n                        resOps = new ArrayList<>();\n                    }\n                    resOps.add(new OpEntry(code, uidState.opModes.get(code),\n                            Collections.emptyMap()));\n                }\n            }\n        }\n        return resOps;\n    }\n\n    private static @NonNull OpEntry getOpEntryForResult(@NonNull Op op, long elapsedNow) {\n        return op.createEntryLocked();\n    }\n\n    @Override\n    public List<AppOpsManager.PackageOps> getPackagesForOps(int[] ops) {\n        final int callingUid = Binder.getCallingUid();\n        final boolean hasAllPackageAccess = mContext.checkPermission(\n                Manifest.permission.GET_APP_OPS_STATS, Binder.getCallingPid(),\n                Binder.getCallingUid(), null) == PackageManager.PERMISSION_GRANTED;\n        ArrayList<AppOpsManager.PackageOps> res = null;\n        synchronized (this) {\n            final int uidStateCount = mUidStates.size();\n            for (int i = 0; i < uidStateCount; i++) {\n                UidState uidState = mUidStates.valueAt(i);\n                if (uidState.pkgOps == null || uidState.pkgOps.isEmpty()) {\n                    continue;\n                }\n                ArrayMap<String, Ops> packages = uidState.pkgOps;\n                final int packageCount = packages.size();\n                for (int j = 0; j < packageCount; j++) {\n                    Ops pkgOps = packages.valueAt(j);\n                    ArrayList<AppOpsManager.OpEntry> resOps = collectOps(pkgOps, ops);\n                    if (resOps != null) {\n                        if (res == null) {\n                            res = new ArrayList<>();\n                        }\n                        AppOpsManager.PackageOps resPackage = new AppOpsManager.PackageOps(\n                                pkgOps.packageName, pkgOps.uidState.uid, resOps);\n                        // Caller can always see their packages and with a permission all.\n                        if (hasAllPackageAccess || callingUid == pkgOps.uidState.uid) {\n                            res.add(resPackage);\n                        }\n                    }\n                }\n            }\n        }\n        return res;\n    }\n\n    @Override\n    public List<AppOpsManager.PackageOps> getOpsForPackage(int uid, String packageName,\n            int[] ops) {\n        enforceGetAppOpsStatsPermissionIfNeeded(uid,packageName);\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return Collections.emptyList();\n        }\n        synchronized (this) {\n            Ops pkgOps = getOpsLocked(uid, resolvedPackageName, null, false, null,\n                    /* edit */ false);\n            if (pkgOps == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.OpEntry> resOps = collectOps(pkgOps, ops);\n            if (resOps == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.PackageOps> res = new ArrayList<AppOpsManager.PackageOps>();\n            AppOpsManager.PackageOps resPackage = new AppOpsManager.PackageOps(\n                    pkgOps.packageName, pkgOps.uidState.uid, resOps);\n            res.add(resPackage);\n            return res;\n        }\n    }\n\n    private void enforceGetAppOpsStatsPermissionIfNeeded(int uid, String packageName) {\n        final int callingUid = Binder.getCallingUid();\n        // We get to access everything\n        if (callingUid == Process.myPid()) {\n            return;\n        }\n        // Apps can access their own data\n        if (uid == callingUid && packageName != null\n                && checkPackage(uid, packageName) == MODE_ALLOWED) {\n            return;\n        }\n        // Otherwise, you need a permission...\n        mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS,\n                Binder.getCallingPid(), callingUid, null);\n    }\n\n    /**\n     * Verify that historical appop request arguments are valid.\n     */\n    private void ensureHistoricalOpRequestIsValid(int uid, String packageName,\n            String attributionTag, List<String> opNames, int filter, long beginTimeMillis,\n            long endTimeMillis, int flags) {\n        if ((filter & FILTER_BY_UID) != 0) {\n            Preconditions.checkArgument(uid != Process.INVALID_UID);\n        } else {\n            Preconditions.checkArgument(uid == Process.INVALID_UID);\n        }\n\n        if ((filter & FILTER_BY_PACKAGE_NAME) != 0) {\n            Objects.requireNonNull(packageName);\n        } else {\n            Preconditions.checkArgument(packageName == null);\n        }\n\n        if ((filter & FILTER_BY_ATTRIBUTION_TAG) == 0) {\n            Preconditions.checkArgument(attributionTag == null);\n        }\n\n        if ((filter & FILTER_BY_OP_NAMES) != 0) {\n            Objects.requireNonNull(opNames);\n        } else {\n            Preconditions.checkArgument(opNames == null);\n        }\n\n        Preconditions.checkFlagsArgument(filter,\n                FILTER_BY_UID | FILTER_BY_PACKAGE_NAME | FILTER_BY_ATTRIBUTION_TAG\n                        | FILTER_BY_OP_NAMES);\n        Preconditions.checkArgumentNonnegative(beginTimeMillis);\n        Preconditions.checkArgument(endTimeMillis > beginTimeMillis);\n        Preconditions.checkFlagsArgument(flags, OP_FLAGS_ALL);\n    }\n\n    @Override\n    public void getHistoricalOps(int uid, String packageName, String attributionTag,\n            List<String> opNames, int dataType, int filter, long beginTimeMillis,\n            long endTimeMillis, int flags, RemoteCallback callback) {\n        PackageManager pm = mContext.getPackageManager();\n\n        ensureHistoricalOpRequestIsValid(uid, packageName, attributionTag, opNames, filter,\n                beginTimeMillis, endTimeMillis, flags);\n        Objects.requireNonNull(callback, \"callback cannot be null\");\n        ActivityManagerInternal ami = LocalServices.getService(ActivityManagerInternal.class);\n        boolean isSelfRequest = (filter & FILTER_BY_UID) != 0 && uid == Binder.getCallingUid();\n        if (!isSelfRequest) {\n            boolean isCallerInstrumented =\n                    ami.getInstrumentationSourceUid(Binder.getCallingUid()) != Process.INVALID_UID;\n            boolean isCallerSystem = Binder.getCallingPid() == Process.myPid();\n            boolean isCallerPermissionController;\n            try {\n                isCallerPermissionController = pm.getPackageUidAsUser(\n                        mContext.getPackageManager().getPermissionControllerPackageName(), 0,\n                        UserHandle.getUserId(Binder.getCallingUid()))\n                        == Binder.getCallingUid();\n            } catch (PackageManager.NameNotFoundException doesNotHappen) {\n                return;\n            }\n\n            boolean doesCallerHavePermission = mContext.checkPermission(\n                    android.Manifest.permission.GET_HISTORICAL_APP_OPS_STATS,\n                    Binder.getCallingPid(), Binder.getCallingUid())\n                    == PackageManager.PERMISSION_GRANTED;\n\n            if (!isCallerSystem && !isCallerInstrumented && !isCallerPermissionController\n                    && !doesCallerHavePermission) {\n                mHandler.post(() -> callback.sendResult(new Bundle()));\n                return;\n            }\n\n            mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS,\n                    Binder.getCallingPid(), Binder.getCallingUid(), \"getHistoricalOps\");\n        }\n\n        final String[] opNamesArray = (opNames != null)\n                ? opNames.toArray(new String[opNames.size()]) : null;\n\n        Set<String> attributionChainExemptPackages = null;\n        if ((dataType & HISTORY_FLAG_GET_ATTRIBUTION_CHAINS) != 0) {\n            attributionChainExemptPackages =\n                    PermissionManager.getIndicatorExemptedPackages(mContext);\n        }\n\n        final String[] chainExemptPkgArray = attributionChainExemptPackages != null\n                ? attributionChainExemptPackages.toArray(\n                        new String[attributionChainExemptPackages.size()]) : null;\n\n        // Must not hold the appops lock\n        mHandler.post(PooledLambda.obtainRunnable(HistoricalRegistry::getHistoricalOps,\n                mHistoricalRegistry, uid, packageName, attributionTag, opNamesArray, dataType,\n                filter, beginTimeMillis, endTimeMillis, flags, chainExemptPkgArray,\n                callback).recycleOnUse());\n    }\n\n    @Override\n    public void getHistoricalOpsFromDiskRaw(int uid, String packageName, String attributionTag,\n            List<String> opNames, int dataType, int filter, long beginTimeMillis,\n            long endTimeMillis, int flags, RemoteCallback callback) {\n        ensureHistoricalOpRequestIsValid(uid, packageName, attributionTag, opNames, filter,\n                beginTimeMillis, endTimeMillis, flags);\n        Objects.requireNonNull(callback, \"callback cannot be null\");\n\n        mContext.enforcePermission(Manifest.permission.MANAGE_APPOPS,\n                Binder.getCallingPid(), Binder.getCallingUid(), \"getHistoricalOps\");\n\n        final String[] opNamesArray = (opNames != null)\n                ? opNames.toArray(new String[opNames.size()]) : null;\n\n        Set<String> attributionChainExemptPackages = null;\n        if ((dataType & HISTORY_FLAG_GET_ATTRIBUTION_CHAINS) != 0) {\n            attributionChainExemptPackages =\n                    PermissionManager.getIndicatorExemptedPackages(mContext);\n        }\n\n        final String[] chainExemptPkgArray = attributionChainExemptPackages != null\n                ? attributionChainExemptPackages.toArray(\n                new String[attributionChainExemptPackages.size()]) : null;\n\n        // Must not hold the appops lock\n        mHandler.post(PooledLambda.obtainRunnable(HistoricalRegistry::getHistoricalOpsFromDiskRaw,\n                mHistoricalRegistry, uid, packageName, attributionTag, opNamesArray, dataType,\n                filter, beginTimeMillis, endTimeMillis, flags, chainExemptPkgArray,\n                callback).recycleOnUse());\n    }\n\n    @Override\n    public void reloadNonHistoricalState() {\n        mContext.enforcePermission(Manifest.permission.MANAGE_APPOPS,\n                Binder.getCallingPid(), Binder.getCallingUid(), \"reloadNonHistoricalState\");\n        writeState();\n        readState();\n    }\n\n    @Override\n    public List<AppOpsManager.PackageOps> getUidOps(int uid, int[] ops) {\n        mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n        synchronized (this) {\n            UidState uidState = getUidStateLocked(uid, false);\n            if (uidState == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.OpEntry> resOps = collectUidOps(uidState, ops);\n            if (resOps == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.PackageOps> res = new ArrayList<AppOpsManager.PackageOps>();\n            AppOpsManager.PackageOps resPackage = new AppOpsManager.PackageOps(\n                    null, uidState.uid, resOps);\n            res.add(resPackage);\n            return res;\n        }\n    }\n\n    private void pruneOpLocked(Op op, int uid, String packageName) {\n        op.removeAttributionsWithNoTime();\n\n        if (op.mAttributions.isEmpty()) {\n            Ops ops = getOpsLocked(uid, packageName, null, false, null, /* edit */ false);\n            if (ops != null) {\n                ops.remove(op.op);\n                if (ops.size() <= 0) {\n                    UidState uidState = ops.uidState;\n                    ArrayMap<String, Ops> pkgOps = uidState.pkgOps;\n                    if (pkgOps != null) {\n                        pkgOps.remove(ops.packageName);\n                        if (pkgOps.isEmpty()) {\n                            uidState.pkgOps = null;\n                        }\n                        if (uidState.isDefault()) {\n                            mUidStates.remove(uid);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    private void enforceManageAppOpsModes(int callingPid, int callingUid, int targetUid) {\n        if (callingPid == Process.myPid()) {\n            return;\n        }\n        final int callingUser = UserHandle.getUserId(callingUid);\n        synchronized (this) {\n            if (mProfileOwners != null && mProfileOwners.get(callingUser, -1) == callingUid) {\n                if (targetUid >= 0 && callingUser == UserHandle.getUserId(targetUid)) {\n                    // Profile owners are allowed to change modes but only for apps\n                    // within their user.\n                    return;\n                }\n            }\n        }\n        mContext.enforcePermission(android.Manifest.permission.MANAGE_APP_OPS_MODES,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n    }\n\n    @Override\n    public void setUidMode(int code, int uid, int mode) {\n        setUidMode(code, uid, mode, null);\n    }\n\n    private void setUidMode(int code, int uid, int mode,\n            @Nullable IAppOpsCallback permissionPolicyCallback) {\n        if (DEBUG) {\n            Slog.i(TAG, \"uid \" + uid + \" OP_\" + opToName(code) + \" := \" + modeToName(mode)\n                    + \" by uid \" + Binder.getCallingUid());\n        }\n\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), uid);\n        verifyIncomingOp(code);\n        code = AppOpsManager.opToSwitch(code);\n\n        if (permissionPolicyCallback == null) {\n            updatePermissionRevokedCompat(uid, code, mode);\n        }\n\n        int previousMode;\n        synchronized (this) {\n            final int defaultMode = AppOpsManager.opToDefaultMode(code);\n\n            UidState uidState = getUidStateLocked(uid, false);\n            if (uidState == null) {\n                if (mode == defaultMode) {\n                    return;\n                }\n                previousMode = MODE_DEFAULT;\n                uidState = new UidState(uid);\n                uidState.opModes = new SparseIntArray();\n                uidState.opModes.put(code, mode);\n                mUidStates.put(uid, uidState);\n                scheduleWriteLocked();\n            } else if (uidState.opModes == null) {\n                previousMode = MODE_DEFAULT;\n                if (mode != defaultMode) {\n                    uidState.opModes = new SparseIntArray();\n                    uidState.opModes.put(code, mode);\n                    scheduleWriteLocked();\n                }\n            } else {\n                if (uidState.opModes.indexOfKey(code) >= 0 && uidState.opModes.get(code) == mode) {\n                    return;\n                }\n                previousMode = uidState.opModes.get(code);\n                if (mode == defaultMode) {\n                    uidState.opModes.delete(code);\n                    if (uidState.opModes.size() <= 0) {\n                        uidState.opModes = null;\n                    }\n                } else {\n                    uidState.opModes.put(code, mode);\n                }\n                scheduleWriteLocked();\n            }\n            uidState.evalForegroundOps(mOpModeWatchers);\n            if (mode != MODE_ERRORED && mode != previousMode) {\n                updateStartedOpModeForUidLocked(code, mode == MODE_IGNORED, uid);\n            }\n        }\n\n        notifyOpChangedForAllPkgsInUid(code, uid, false, permissionPolicyCallback);\n        notifyOpChangedSync(code, uid, null, mode, previousMode);\n    }\n\n    /**\n     * Notify that an op changed for all packages in an uid.\n     *\n     * @param code The op that changed\n     * @param uid The uid the op was changed for\n     * @param onlyForeground Only notify watchers that watch for foreground changes\n     */\n    private void notifyOpChangedForAllPkgsInUid(int code, int uid, boolean onlyForeground,\n            @Nullable IAppOpsCallback callbackToIgnore) {\n        String[] uidPackageNames = getPackagesForUid(uid);\n        ArrayMap<ModeCallback, ArraySet<String>> callbackSpecs = null;\n\n        synchronized (this) {\n            ArraySet<ModeCallback> callbacks = mOpModeWatchers.get(code);\n            if (callbacks != null) {\n                final int callbackCount = callbacks.size();\n                for (int i = 0; i < callbackCount; i++) {\n                    ModeCallback callback = callbacks.valueAt(i);\n                    if (onlyForeground && (callback.mFlags & WATCH_FOREGROUND_CHANGES) == 0) {\n                        continue;\n                    }\n\n                    ArraySet<String> changedPackages = new ArraySet<>();\n                    Collections.addAll(changedPackages, uidPackageNames);\n                    if (callbackSpecs == null) {\n                        callbackSpecs = new ArrayMap<>();\n                    }\n                    callbackSpecs.put(callback, changedPackages);\n                }\n            }\n\n            for (String uidPackageName : uidPackageNames) {\n                callbacks = mPackageModeWatchers.get(uidPackageName);\n                if (callbacks != null) {\n                    if (callbackSpecs == null) {\n                        callbackSpecs = new ArrayMap<>();\n                    }\n                    final int callbackCount = callbacks.size();\n                    for (int i = 0; i < callbackCount; i++) {\n                        ModeCallback callback = callbacks.valueAt(i);\n                        if (onlyForeground && (callback.mFlags & WATCH_FOREGROUND_CHANGES) == 0) {\n                            continue;\n                        }\n\n                        ArraySet<String> changedPackages = callbackSpecs.get(callback);\n                        if (changedPackages == null) {\n                            changedPackages = new ArraySet<>();\n                            callbackSpecs.put(callback, changedPackages);\n                        }\n                        changedPackages.add(uidPackageName);\n                    }\n                }\n            }\n\n            if (callbackSpecs != null && callbackToIgnore != null) {\n                callbackSpecs.remove(mModeWatchers.get(callbackToIgnore.asBinder()));\n            }\n        }\n\n        if (callbackSpecs == null) {\n            return;\n        }\n\n        for (int i = 0; i < callbackSpecs.size(); i++) {\n            final ModeCallback callback = callbackSpecs.keyAt(i);\n            final ArraySet<String> reportedPackageNames = callbackSpecs.valueAt(i);\n            if (reportedPackageNames == null) {\n                mHandler.sendMessage(PooledLambda.obtainMessage(\n                        AppOpsService::notifyOpChanged,\n                        this, callback, code, uid, (String) null));\n\n            } else {\n                final int reportedPackageCount = reportedPackageNames.size();\n                for (int j = 0; j < reportedPackageCount; j++) {\n                    final String reportedPackageName = reportedPackageNames.valueAt(j);\n                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                            AppOpsService::notifyOpChanged,\n                            this, callback, code, uid, reportedPackageName));\n                }\n            }\n        }\n    }\n\n    private void updatePermissionRevokedCompat(int uid, int switchCode, int mode) {\n        PackageManager packageManager = mContext.getPackageManager();\n        if (packageManager == null) {\n            // This can only happen during early boot. At this time the permission state and appop\n            // state are in sync\n            return;\n        }\n\n        String[] packageNames = packageManager.getPackagesForUid(uid);\n        if (ArrayUtils.isEmpty(packageNames)) {\n            return;\n        }\n        String packageName = packageNames[0];\n\n        int[] ops = mSwitchedOps.get(switchCode);\n        for (int code : ops) {\n            String permissionName = AppOpsManager.opToPermission(code);\n            if (permissionName == null) {\n                continue;\n            }\n\n            if (packageManager.checkPermission(permissionName, packageName)\n                    != PackageManager.PERMISSION_GRANTED) {\n                continue;\n            }\n\n            PermissionInfo permissionInfo;\n            try {\n                permissionInfo = packageManager.getPermissionInfo(permissionName, 0);\n            } catch (PackageManager.NameNotFoundException e) {\n                e.printStackTrace();\n                continue;\n            }\n\n            if (!permissionInfo.isRuntime()) {\n                continue;\n            }\n\n            boolean supportsRuntimePermissions = getPackageManagerInternal()\n                    .getUidTargetSdkVersion(uid) >= Build.VERSION_CODES.M;\n\n            UserHandle user = UserHandle.getUserHandleForUid(uid);\n            boolean isRevokedCompat;\n            if (permissionInfo.backgroundPermission != null) {\n                if (packageManager.checkPermission(permissionInfo.backgroundPermission, packageName)\n                        == PackageManager.PERMISSION_GRANTED) {\n                    boolean isBackgroundRevokedCompat = mode != AppOpsManager.MODE_ALLOWED;\n\n                    if (isBackgroundRevokedCompat && supportsRuntimePermissions) {\n                        Slog.w(TAG, \"setUidMode() called with a mode inconsistent with runtime\"\n                                + \" permission state, this is discouraged and you should revoke the\"\n                                + \" runtime permission instead: uid=\" + uid + \", switchCode=\"\n                                + switchCode + \", mode=\" + mode + \", permission=\"\n                                + permissionInfo.backgroundPermission);\n                    }\n\n                    final long identity = Binder.clearCallingIdentity();\n                    try {\n                        packageManager.updatePermissionFlags(permissionInfo.backgroundPermission,\n                                packageName, PackageManager.FLAG_PERMISSION_REVOKED_COMPAT,\n                                isBackgroundRevokedCompat\n                                        ? PackageManager.FLAG_PERMISSION_REVOKED_COMPAT : 0, user);\n                    } finally {\n                        Binder.restoreCallingIdentity(identity);\n                    }\n                }\n\n                isRevokedCompat = mode != AppOpsManager.MODE_ALLOWED\n                        && mode != AppOpsManager.MODE_FOREGROUND;\n            } else {\n                isRevokedCompat = mode != AppOpsManager.MODE_ALLOWED;\n            }\n\n            if (isRevokedCompat && supportsRuntimePermissions) {\n                Slog.w(TAG, \"setUidMode() called with a mode inconsistent with runtime\"\n                        + \" permission state, this is discouraged and you should revoke the\"\n                        + \" runtime permission instead: uid=\" + uid + \", switchCode=\"\n                        + switchCode + \", mode=\" + mode + \", permission=\" + permissionName);\n            }\n\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                packageManager.updatePermissionFlags(permissionName, packageName,\n                        PackageManager.FLAG_PERMISSION_REVOKED_COMPAT, isRevokedCompat\n                                ? PackageManager.FLAG_PERMISSION_REVOKED_COMPAT : 0, user);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n    }\n\n    private void notifyOpChangedSync(int code, int uid, @NonNull String packageName, int mode,\n            int previousMode) {\n        final StorageManagerInternal storageManagerInternal =\n                LocalServices.getService(StorageManagerInternal.class);\n        if (storageManagerInternal != null) {\n            storageManagerInternal.onAppOpsChanged(code, uid, packageName, mode, previousMode);\n        }\n    }\n\n    /**\n     * Sets the mode for a certain op and uid.\n     *\n     * @param code The op code to set\n     * @param uid The UID for which to set\n     * @param packageName The package for which to set\n     * @param mode The new mode to set\n     */\n    @Override\n    public void setMode(int code, int uid, @NonNull String packageName, int mode) {\n        setMode(code, uid, packageName, mode, null);\n    }\n\n    private void setMode(int code, int uid, @NonNull String packageName, int mode,\n            @Nullable IAppOpsCallback permissionPolicyCallback) {\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), uid);\n        verifyIncomingOp(code);\n        verifyIncomingPackage(packageName, UserHandle.getUserId(uid));\n\n        ArraySet<ModeCallback> repCbs = null;\n        code = AppOpsManager.opToSwitch(code);\n\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, null);\n        } catch (SecurityException e) {\n            Slog.e(TAG, \"Cannot setMode\", e);\n            return;\n        }\n\n        int previousMode = MODE_DEFAULT;\n        synchronized (this) {\n            UidState uidState = getUidStateLocked(uid, false);\n            Op op = getOpLocked(code, uid, packageName, null, false, pvr.bypass, /* edit */ true);\n            if (op != null) {\n                if (op.mode != mode) {\n                    previousMode = op.mode;\n                    op.mode = mode;\n                    if (uidState != null) {\n                        uidState.evalForegroundOps(mOpModeWatchers);\n                    }\n                    ArraySet<ModeCallback> cbs = mOpModeWatchers.get(code);\n                    if (cbs != null) {\n                        if (repCbs == null) {\n                            repCbs = new ArraySet<>();\n                        }\n                        repCbs.addAll(cbs);\n                    }\n                    cbs = mPackageModeWatchers.get(packageName);\n                    if (cbs != null) {\n                        if (repCbs == null) {\n                            repCbs = new ArraySet<>();\n                        }\n                        repCbs.addAll(cbs);\n                    }\n                    if (repCbs != null && permissionPolicyCallback != null) {\n                        repCbs.remove(mModeWatchers.get(permissionPolicyCallback.asBinder()));\n                    }\n                    if (mode == AppOpsManager.opToDefaultMode(op.op)) {\n                        // If going into the default mode, prune this op\n                        // if there is nothing else interesting in it.\n                        pruneOpLocked(op, uid, packageName);\n                    }\n                    scheduleFastWriteLocked();\n                    if (mode != MODE_ERRORED) {\n                        updateStartedOpModeForUidLocked(code, mode == MODE_IGNORED, uid);\n                    }\n                }\n            }\n        }\n        if (repCbs != null) {\n            mHandler.sendMessage(PooledLambda.obtainMessage(\n                    AppOpsService::notifyOpChanged,\n                    this, repCbs, code, uid, packageName));\n        }\n\n        notifyOpChangedSync(code, uid, packageName, mode, previousMode);\n    }\n\n    private void notifyOpChanged(ArraySet<ModeCallback> callbacks, int code,\n            int uid, String packageName) {\n        for (int i = 0; i < callbacks.size(); i++) {\n            final ModeCallback callback = callbacks.valueAt(i);\n            notifyOpChanged(callback, code, uid, packageName);\n        }\n    }\n\n    private void notifyOpChanged(ModeCallback callback, int code,\n            int uid, String packageName) {\n        if (uid != UID_ANY && callback.mWatchingUid >= 0 && callback.mWatchingUid != uid) {\n            return;\n        }\n\n        // See CALL_BACK_ON_CHANGED_LISTENER_WITH_SWITCHED_OP_CHANGE\n        int[] switchedCodes;\n        if (callback.mWatchedOpCode == ALL_OPS) {\n            switchedCodes = mSwitchedOps.get(code);\n        } else if (callback.mWatchedOpCode == OP_NONE) {\n            switchedCodes = new int[]{code};\n        } else {\n            switchedCodes = new int[]{callback.mWatchedOpCode};\n        }\n\n        for (int switchedCode : switchedCodes) {\n            // There are features watching for mode changes such as window manager\n            // and location manager which are in our process. The callbacks in these\n            // features may require permissions our remote caller does not have.\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                if (shouldIgnoreCallback(switchedCode, callback.mCallingPid,\n                        callback.mCallingUid)) {\n                    continue;\n                }\n                callback.mCallback.opChanged(switchedCode, uid, packageName);\n            } catch (RemoteException e) {\n                /* ignore */\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n    }\n\n    private static ArrayList<ChangeRec> addChange(ArrayList<ChangeRec> reports,\n            int op, int uid, String packageName, int previousMode) {\n        boolean duplicate = false;\n        if (reports == null) {\n            reports = new ArrayList<>();\n        } else {\n            final int reportCount = reports.size();\n            for (int j = 0; j < reportCount; j++) {\n                ChangeRec report = reports.get(j);\n                if (report.op == op && report.pkg.equals(packageName)) {\n                    duplicate = true;\n                    break;\n                }\n            }\n        }\n        if (!duplicate) {\n            reports.add(new ChangeRec(op, uid, packageName, previousMode));\n        }\n\n        return reports;\n    }\n\n    private static HashMap<ModeCallback, ArrayList<ChangeRec>> addCallbacks(\n            HashMap<ModeCallback, ArrayList<ChangeRec>> callbacks,\n            int op, int uid, String packageName, int previousMode, ArraySet<ModeCallback> cbs) {\n        if (cbs == null) {\n            return callbacks;\n        }\n        if (callbacks == null) {\n            callbacks = new HashMap<>();\n        }\n        final int N = cbs.size();\n        for (int i=0; i<N; i++) {\n            ModeCallback cb = cbs.valueAt(i);\n            ArrayList<ChangeRec> reports = callbacks.get(cb);\n            ArrayList<ChangeRec> changed = addChange(reports, op, uid, packageName, previousMode);\n            if (changed != reports) {\n                callbacks.put(cb, changed);\n            }\n        }\n        return callbacks;\n    }\n\n    static final class ChangeRec {\n        final int op;\n        final int uid;\n        final String pkg;\n        final int previous_mode;\n\n        ChangeRec(int _op, int _uid, String _pkg, int _previous_mode) {\n            op = _op;\n            uid = _uid;\n            pkg = _pkg;\n            previous_mode = _previous_mode;\n        }\n    }\n\n    @Override\n    public void resetAllModes(int reqUserId, String reqPackageName) {\n        final int callingPid = Binder.getCallingPid();\n        final int callingUid = Binder.getCallingUid();\n        reqUserId = ActivityManager.handleIncomingUser(callingPid, callingUid, reqUserId,\n                true, true, \"resetAllModes\", null);\n\n        int reqUid = -1;\n        if (reqPackageName != null) {\n            try {\n                reqUid = AppGlobals.getPackageManager().getPackageUid(\n                        reqPackageName, PackageManager.MATCH_UNINSTALLED_PACKAGES, reqUserId);\n            } catch (RemoteException e) {\n                /* ignore - local call */\n            }\n        }\n\n        enforceManageAppOpsModes(callingPid, callingUid, reqUid);\n\n        HashMap<ModeCallback, ArrayList<ChangeRec>> callbacks = null;\n        ArrayList<ChangeRec> allChanges = new ArrayList<>();\n        synchronized (this) {\n            boolean changed = false;\n            for (int i = mUidStates.size() - 1; i >= 0; i--) {\n                UidState uidState = mUidStates.valueAt(i);\n\n                SparseIntArray opModes = uidState.opModes;\n                if (opModes != null && (uidState.uid == reqUid || reqUid == -1)) {\n                    final int uidOpCount = opModes.size();\n                    for (int j = uidOpCount - 1; j >= 0; j--) {\n                        final int code = opModes.keyAt(j);\n                        if (AppOpsManager.opAllowsReset(code)) {\n                            int previousMode = opModes.valueAt(j);\n                            opModes.removeAt(j);\n                            if (opModes.size() <= 0) {\n                                uidState.opModes = null;\n                            }\n                            for (String packageName : getPackagesForUid(uidState.uid)) {\n                                callbacks = addCallbacks(callbacks, code, uidState.uid, packageName,\n                                        previousMode, mOpModeWatchers.get(code));\n                                callbacks = addCallbacks(callbacks, code, uidState.uid, packageName,\n                                        previousMode, mPackageModeWatchers.get(packageName));\n\n                                allChanges = addChange(allChanges, code, uidState.uid,\n                                        packageName, previousMode);\n                            }\n                        }\n                    }\n                }\n\n                if (uidState.pkgOps == null) {\n                    continue;\n                }\n\n                if (reqUserId != UserHandle.USER_ALL\n                        && reqUserId != UserHandle.getUserId(uidState.uid)) {\n                    // Skip any ops for a different user\n                    continue;\n                }\n\n                Map<String, Ops> packages = uidState.pkgOps;\n                Iterator<Map.Entry<String, Ops>> it = packages.entrySet().iterator();\n                boolean uidChanged = false;\n                while (it.hasNext()) {\n                    Map.Entry<String, Ops> ent = it.next();\n                    String packageName = ent.getKey();\n                    if (reqPackageName != null && !reqPackageName.equals(packageName)) {\n                        // Skip any ops for a different package\n                        continue;\n                    }\n                    Ops pkgOps = ent.getValue();\n                    for (int j=pkgOps.size()-1; j>=0; j--) {\n                        Op curOp = pkgOps.valueAt(j);\n                        if (shouldDeferResetOpToDpm(curOp.op)) {\n                            deferResetOpToDpm(curOp.op, reqPackageName, reqUserId);\n                            continue;\n                        }\n                        if (AppOpsManager.opAllowsReset(curOp.op)\n                                && curOp.mode != AppOpsManager.opToDefaultMode(curOp.op)) {\n                            int previousMode = curOp.mode;\n                            curOp.mode = AppOpsManager.opToDefaultMode(curOp.op);\n                            changed = true;\n                            uidChanged = true;\n                            final int uid = curOp.uidState.uid;\n                            callbacks = addCallbacks(callbacks, curOp.op, uid, packageName,\n                                    previousMode, mOpModeWatchers.get(curOp.op));\n                            callbacks = addCallbacks(callbacks, curOp.op, uid, packageName,\n                                    previousMode, mPackageModeWatchers.get(packageName));\n\n                            allChanges = addChange(allChanges, curOp.op, uid, packageName,\n                                    previousMode);\n                            curOp.removeAttributionsWithNoTime();\n                            if (curOp.mAttributions.isEmpty()) {\n                                pkgOps.removeAt(j);\n                            }\n                        }\n                    }\n                    if (pkgOps.size() == 0) {\n                        it.remove();\n                    }\n                }\n                if (uidState.isDefault()) {\n                    mUidStates.remove(uidState.uid);\n                }\n                if (uidChanged) {\n                    uidState.evalForegroundOps(mOpModeWatchers);\n                }\n            }\n\n            if (changed) {\n                scheduleFastWriteLocked();\n            }\n        }\n        if (callbacks != null) {\n            for (Map.Entry<ModeCallback, ArrayList<ChangeRec>> ent : callbacks.entrySet()) {\n                ModeCallback cb = ent.getKey();\n                ArrayList<ChangeRec> reports = ent.getValue();\n                for (int i=0; i<reports.size(); i++) {\n                    ChangeRec rep = reports.get(i);\n                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                            AppOpsService::notifyOpChanged,\n                            this, cb, rep.op, rep.uid, rep.pkg));\n                }\n            }\n        }\n\n        int numChanges = allChanges.size();\n        for (int i = 0; i < numChanges; i++) {\n            ChangeRec change = allChanges.get(i);\n            notifyOpChangedSync(change.op, change.uid, change.pkg,\n                    AppOpsManager.opToDefaultMode(change.op), change.previous_mode);\n        }\n    }\n\n    private boolean shouldDeferResetOpToDpm(int op) {\n        // TODO(b/174582385): avoid special-casing app-op resets by migrating app-op permission\n        //  pre-grants to a role-based mechanism or another general-purpose mechanism.\n        return dpmi != null && dpmi.supportsResetOp(op);\n    }\n\n    /** Assumes {@link #shouldDeferResetOpToDpm(int)} is true. */\n    private void deferResetOpToDpm(int op, String packageName, @UserIdInt int userId) {\n        // TODO(b/174582385): avoid special-casing app-op resets by migrating app-op permission\n        //  pre-grants to a role-based mechanism or another general-purpose mechanism.\n        dpmi.resetOp(op, packageName, userId);\n    }\n\n    private void evalAllForegroundOpsLocked() {\n        for (int uidi = mUidStates.size() - 1; uidi >= 0; uidi--) {\n            final UidState uidState = mUidStates.valueAt(uidi);\n            if (uidState.foregroundOps != null) {\n                uidState.evalForegroundOps(mOpModeWatchers);\n            }\n        }\n    }\n\n    @Override\n    public void startWatchingMode(int op, String packageName, IAppOpsCallback callback) {\n        startWatchingModeWithFlags(op, packageName, 0, callback);\n    }\n\n    @Override\n    public void startWatchingModeWithFlags(int op, String packageName, int flags,\n            IAppOpsCallback callback) {\n        int watchedUid = -1;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        // TODO: should have a privileged permission to protect this.\n        // Also, if the caller has requested WATCH_FOREGROUND_CHANGES, should we require\n        // the USAGE_STATS permission since this can provide information about when an\n        // app is in the foreground?\n        Preconditions.checkArgumentInRange(op, AppOpsManager.OP_NONE,\n                AppOpsManager._NUM_OP - 1, \"Invalid op code: \" + op);\n        if (callback == null) {\n            return;\n        }\n        final boolean mayWatchPackageName =\n                packageName != null && !filterAppAccessUnlocked(packageName);\n        synchronized (this) {\n            int switchOp = (op != AppOpsManager.OP_NONE) ? AppOpsManager.opToSwitch(op) : op;\n\n            int notifiedOps;\n            if ((flags & CALL_BACK_ON_SWITCHED_OP) == 0) {\n                if (op == OP_NONE) {\n                    notifiedOps = ALL_OPS;\n                } else {\n                    notifiedOps = op;\n                }\n            } else {\n                notifiedOps = switchOp;\n            }\n\n            ModeCallback cb = mModeWatchers.get(callback.asBinder());\n            if (cb == null) {\n                cb = new ModeCallback(callback, watchedUid, flags, notifiedOps, callingUid,\n                        callingPid);\n                mModeWatchers.put(callback.asBinder(), cb);\n            }\n            if (switchOp != AppOpsManager.OP_NONE) {\n                ArraySet<ModeCallback> cbs = mOpModeWatchers.get(switchOp);\n                if (cbs == null) {\n                    cbs = new ArraySet<>();\n                    mOpModeWatchers.put(switchOp, cbs);\n                }\n                cbs.add(cb);\n            }\n            if (mayWatchPackageName) {\n                ArraySet<ModeCallback> cbs = mPackageModeWatchers.get(packageName);\n                if (cbs == null) {\n                    cbs = new ArraySet<>();\n                    mPackageModeWatchers.put(packageName, cbs);\n                }\n                cbs.add(cb);\n            }\n            evalAllForegroundOpsLocked();\n        }\n    }\n\n    @Override\n    public void stopWatchingMode(IAppOpsCallback callback) {\n        if (callback == null) {\n            return;\n        }\n        synchronized (this) {\n            ModeCallback cb = mModeWatchers.remove(callback.asBinder());\n            if (cb != null) {\n                cb.unlinkToDeath();\n                for (int i=mOpModeWatchers.size()-1; i>=0; i--) {\n                    ArraySet<ModeCallback> cbs = mOpModeWatchers.valueAt(i);\n                    cbs.remove(cb);\n                    if (cbs.size() <= 0) {\n                        mOpModeWatchers.removeAt(i);\n                    }\n                }\n                for (int i=mPackageModeWatchers.size()-1; i>=0; i--) {\n                    ArraySet<ModeCallback> cbs = mPackageModeWatchers.valueAt(i);\n                    cbs.remove(cb);\n                    if (cbs.size() <= 0) {\n                        mPackageModeWatchers.removeAt(i);\n                    }\n                }\n            }\n            evalAllForegroundOpsLocked();\n        }\n    }\n\n    public CheckOpsDelegate getAppOpsServiceDelegate() {\n        synchronized (AppOpsService.this) {\n            final CheckOpsDelegateDispatcher dispatcher = mCheckOpsDelegateDispatcher;\n            return (dispatcher != null) ? dispatcher.getCheckOpsDelegate() : null;\n        }\n    }\n\n    public void setAppOpsServiceDelegate(CheckOpsDelegate delegate) {\n        synchronized (AppOpsService.this) {\n            final CheckOpsDelegateDispatcher oldDispatcher = mCheckOpsDelegateDispatcher;\n            final CheckOpsDelegate policy = (oldDispatcher != null) ? oldDispatcher.mPolicy : null;\n            mCheckOpsDelegateDispatcher = new CheckOpsDelegateDispatcher(policy, delegate);\n        }\n    }\n\n    @Override\n    public int checkOperationRaw(int code, int uid, String packageName,\n            @Nullable String attributionTag) {\n        return mCheckOpsDelegateDispatcher.checkOperation(code, uid, packageName, attributionTag,\n                true /*raw*/);\n    }\n\n    @Override\n    public int checkOperation(int code, int uid, String packageName) {\n        return mCheckOpsDelegateDispatcher.checkOperation(code, uid, packageName, null,\n                false /*raw*/);\n    }\n\n    private int checkOperationImpl(int code, int uid, String packageName,\n            @Nullable String attributionTag, boolean raw) {\n        verifyIncomingOp(code);\n        verifyIncomingPackage(packageName, UserHandle.getUserId(uid));\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return AppOpsManager.MODE_IGNORED;\n        }\n        return checkOperationUnchecked(code, uid, resolvedPackageName, attributionTag, raw);\n    }\n\n    /**\n     * Get the mode of an app-op.\n     *\n     * @param code The code of the op\n     * @param uid The uid of the package the op belongs to\n     * @param packageName The package the op belongs to\n     * @param raw If the raw state of eval-ed state should be checked.\n     *\n     * @return The mode of the op\n     */\n    private @Mode int checkOperationUnchecked(int code, int uid, @NonNull String packageName,\n            @Nullable String attributionTag, boolean raw) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, null);\n        } catch (SecurityException e) {\n            Slog.e(TAG, \"checkOperation\", e);\n            return AppOpsManager.opToDefaultMode(code);\n        }\n\n        if (isOpRestrictedDueToSuspend(code, packageName, uid)) {\n            return AppOpsManager.MODE_IGNORED;\n        }\n        synchronized (this) {\n            if (isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass, true)) {\n                return AppOpsManager.MODE_IGNORED;\n            }\n            code = AppOpsManager.opToSwitch(code);\n            UidState uidState = getUidStateLocked(uid, false);\n            if (uidState != null && uidState.opModes != null\n                    && uidState.opModes.indexOfKey(code) >= 0) {\n                final int rawMode = uidState.opModes.get(code);\n                return raw ? rawMode : uidState.evalMode(code, rawMode);\n            }\n            Op op = getOpLocked(code, uid, packageName, null, false, pvr.bypass, /* edit */ false);\n            if (op == null) {\n                return AppOpsManager.opToDefaultMode(code);\n            }\n            return raw ? op.mode : op.evalMode();\n        }\n    }\n\n    @Override\n    public int checkAudioOperation(int code, int usage, int uid, String packageName) {\n        return mCheckOpsDelegateDispatcher.checkAudioOperation(code, usage, uid, packageName);\n    }\n\n    private int checkAudioOperationImpl(int code, int usage, int uid, String packageName) {\n        final int mode = mAudioRestrictionManager.checkAudioOperation(\n                code, usage, uid, packageName);\n        if (mode != AppOpsManager.MODE_ALLOWED) {\n            return mode;\n        }\n        return checkOperation(code, uid, packageName);\n    }\n\n    @Override\n    public void setAudioRestriction(int code, int usage, int uid, int mode,\n            String[] exceptionPackages) {\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), uid);\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n\n        mAudioRestrictionManager.setZenModeAudioRestriction(\n                code, usage, uid, mode, exceptionPackages);\n\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyWatchersOfChange, this, code, UID_ANY));\n    }\n\n\n    @Override\n    public void setCameraAudioRestriction(@CAMERA_AUDIO_RESTRICTION int mode) {\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), -1);\n\n        mAudioRestrictionManager.setCameraAudioRestriction(mode);\n\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyWatchersOfChange, this,\n                AppOpsManager.OP_PLAY_AUDIO, UID_ANY));\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyWatchersOfChange, this,\n                AppOpsManager.OP_VIBRATE, UID_ANY));\n    }\n\n    @Override\n    public int checkPackage(int uid, String packageName) {\n        Objects.requireNonNull(packageName);\n        try {\n            verifyAndGetBypass(uid, packageName, null);\n            // When the caller is the system, it's possible that the packageName is the special\n            // one (e.g., \"root\") which isn't actually existed.\n            if (resolveUid(packageName) == uid\n                    || (isPackageExisted(packageName) && !filterAppAccessUnlocked(packageName))) {\n                return AppOpsManager.MODE_ALLOWED;\n            }\n            return AppOpsManager.MODE_ERRORED;\n        } catch (SecurityException ignored) {\n            return AppOpsManager.MODE_ERRORED;\n        }\n    }\n\n    private boolean isPackageExisted(String packageName) {\n        return LocalServices.getService(PackageManagerInternal.class)\n                .getPackageStateInternal(packageName) != null;\n    }\n\n    /**\n     * This method will check with PackageManager to determine if the package provided should\n     * be visible to the {@link Binder#getCallingUid()}.\n     *\n     * NOTE: This must not be called while synchronized on {@code this} to avoid dead locks\n     */\n    private boolean filterAppAccessUnlocked(String packageName) {\n        final int callingUid = Binder.getCallingUid();\n        return LocalServices.getService(PackageManagerInternal.class)\n                .filterAppAccess(packageName, callingUid, UserHandle.getUserId(callingUid));\n    }\n\n    @Override\n    public SyncNotedAppOp noteProxyOperation(int code, AttributionSource attributionSource,\n            boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n            boolean skipProxyOperation) {\n        return mCheckOpsDelegateDispatcher.noteProxyOperation(code, attributionSource,\n                shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation);\n    }\n\n    private SyncNotedAppOp noteProxyOperationImpl(int code, AttributionSource attributionSource,\n            boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n            boolean skipProxyOperation) {\n        final int proxyUid = attributionSource.getUid();\n        final String proxyPackageName = attributionSource.getPackageName();\n        final String proxyAttributionTag = attributionSource.getAttributionTag();\n        final int proxiedUid = attributionSource.getNextUid();\n        final String proxiedPackageName = attributionSource.getNextPackageName();\n        final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n\n        verifyIncomingProxyUid(attributionSource);\n        verifyIncomingOp(code);\n        verifyIncomingPackage(proxiedPackageName, UserHandle.getUserId(proxiedUid));\n        verifyIncomingPackage(proxyPackageName, UserHandle.getUserId(proxyUid));\n\n        skipProxyOperation = skipProxyOperation\n                && isCallerAndAttributionTrusted(attributionSource);\n\n        String resolveProxyPackageName = AppOpsManager.resolvePackageName(proxyUid,\n                proxyPackageName);\n        if (resolveProxyPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code,\n                    proxiedAttributionTag, proxiedPackageName);\n        }\n\n        final boolean isSelfBlame = Binder.getCallingUid() == proxiedUid;\n        final boolean isProxyTrusted = mContext.checkPermission(\n                Manifest.permission.UPDATE_APP_OPS_STATS, -1, proxyUid)\n                == PackageManager.PERMISSION_GRANTED || isSelfBlame;\n\n        if (!skipProxyOperation) {\n            final int proxyFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXY\n                    : AppOpsManager.OP_FLAG_UNTRUSTED_PROXY;\n\n            final SyncNotedAppOp proxyReturn = noteOperationUnchecked(code, proxyUid,\n                    resolveProxyPackageName, proxyAttributionTag, Process.INVALID_UID, null, null,\n                    proxyFlags, !isProxyTrusted, \"proxy \" + message, shouldCollectMessage);\n            if (proxyReturn.getOpMode() != AppOpsManager.MODE_ALLOWED) {\n                return new SyncNotedAppOp(proxyReturn.getOpMode(), code, proxiedAttributionTag,\n                        proxiedPackageName);\n            }\n        }\n\n        String resolveProxiedPackageName = AppOpsManager.resolvePackageName(proxiedUid,\n                proxiedPackageName);\n        if (resolveProxiedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        final int proxiedFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXIED\n                : AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED;\n        return noteOperationUnchecked(code, proxiedUid, resolveProxiedPackageName,\n                proxiedAttributionTag, proxyUid, resolveProxyPackageName, proxyAttributionTag,\n                proxiedFlags, shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n    }\n\n    @Override\n    public SyncNotedAppOp noteOperation(int code, int uid, String packageName,\n            String attributionTag, boolean shouldCollectAsyncNotedOp, String message,\n            boolean shouldCollectMessage) {\n        return mCheckOpsDelegateDispatcher.noteOperation(code, uid, packageName,\n                attributionTag, shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n    }\n\n    private SyncNotedAppOp noteOperationImpl(int code, int uid, @Nullable String packageName,\n            @Nullable String attributionTag, boolean shouldCollectAsyncNotedOp,\n            @Nullable String message, boolean shouldCollectMessage) {\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n        verifyIncomingPackage(packageName, UserHandle.getUserId(uid));\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, attributionTag,\n                    packageName);\n        }\n        return noteOperationUnchecked(code, uid, resolvedPackageName, attributionTag,\n                Process.INVALID_UID, null, null, AppOpsManager.OP_FLAG_SELF,\n                shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n    }\n\n    private SyncNotedAppOp noteOperationUnchecked(int code, int uid, @NonNull String packageName,\n            @Nullable String attributionTag, int proxyUid, String proxyPackageName,\n            @Nullable String proxyAttributionTag, @OpFlags int flags,\n            boolean shouldCollectAsyncNotedOp, @Nullable String message,\n            boolean shouldCollectMessage) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n            boolean wasNull = attributionTag == null;\n            if (!pvr.isAttributionTagValid) {\n                attributionTag = null;\n            }\n        } catch (SecurityException e) {\n            Slog.e(TAG, \"noteOperation\", e);\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                    packageName);\n        }\n        if (proxyAttributionTag != null\n                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n            proxyAttributionTag = null;\n        }\n\n        synchronized (this) {\n            final Ops ops = getOpsLocked(uid, packageName, attributionTag,\n                    pvr.isAttributionTagValid, pvr.bypass, /* edit */ true);\n            if (ops == null) {\n                scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                        AppOpsManager.MODE_IGNORED);\n                if (DEBUG) Slog.d(TAG, \"noteOperation: no op for code \" + code + \" uid \" + uid\n                        + \" package \" + packageName + \"flags: \" +\n                        AppOpsManager.flagsToString(flags));\n                return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                        packageName);\n            }\n            final Op op = getOpLocked(ops, code, uid, true);\n            final AttributedOp attributedOp = op.getOrCreateAttribution(op, attributionTag);\n            if (attributedOp.isRunning()) {\n                Slog.w(TAG, \"Noting op not finished: uid \" + uid + \" pkg \" + packageName + \" code \"\n                        + code + \" startTime of in progress event=\"\n                        + attributedOp.mInProgressEvents.valueAt(0).getStartTime());\n            }\n\n            final int switchCode = AppOpsManager.opToSwitch(code);\n            final UidState uidState = ops.uidState;\n            if (isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass, false)) {\n                attributedOp.rejected(uidState.state, flags);\n                scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                        AppOpsManager.MODE_IGNORED);\n                return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, attributionTag,\n                        packageName);\n            }\n            // If there is a non-default per UID policy (we set UID op mode only if\n            // non-default) it takes over, otherwise use the per package policy.\n            if (uidState.opModes != null && uidState.opModes.indexOfKey(switchCode) >= 0) {\n                final int uidMode = uidState.evalMode(code, uidState.opModes.get(switchCode));\n                if (uidMode != AppOpsManager.MODE_ALLOWED) {\n                    if (DEBUG) Slog.d(TAG, \"noteOperation: uid reject #\" + uidMode + \" for code \"\n                            + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                            + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    attributedOp.rejected(uidState.state, flags);\n                    scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                            uidMode);\n                    return new SyncNotedAppOp(uidMode, code, attributionTag, packageName);\n                }\n            } else {\n                final Op switchOp = switchCode != code ? getOpLocked(ops, switchCode, uid, true)\n                        : op;\n                final int mode = switchOp.evalMode();\n                if (mode != AppOpsManager.MODE_ALLOWED) {\n                    if (DEBUG) Slog.d(TAG, \"noteOperation: reject #\" + mode + \" for code \"\n                            + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                            + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    attributedOp.rejected(uidState.state, flags);\n                    scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                            mode);\n                    return new SyncNotedAppOp(mode, code, attributionTag, packageName);\n                }\n            }\n            if (DEBUG) {\n                Slog.d(TAG,\n                        \"noteOperation: allowing code \" + code + \" uid \" + uid + \" package \"\n                                + packageName + (attributionTag == null ? \"\"\n                                : \".\" + attributionTag) + \" flags: \"\n                                + AppOpsManager.flagsToString(flags));\n            }\n            scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                    AppOpsManager.MODE_ALLOWED);\n            attributedOp.accessed(proxyUid, proxyPackageName, proxyAttributionTag, uidState.state,\n                    flags);\n\n            if (shouldCollectAsyncNotedOp) {\n                collectAsyncNotedOp(uid, packageName, code, attributionTag, flags, message,\n                        shouldCollectMessage);\n            }\n\n            return new SyncNotedAppOp(AppOpsManager.MODE_ALLOWED, code, attributionTag,\n                    packageName);\n        }\n    }\n\n    // TODO moltmann: Allow watching for attribution ops\n    @Override\n    public void startWatchingActive(int[] ops, IAppOpsActiveCallback callback) {\n        int watchedUid = Process.INVALID_UID;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                != PackageManager.PERMISSION_GRANTED) {\n            watchedUid = callingUid;\n        }\n        if (ops != null) {\n            Preconditions.checkArrayElementsInRange(ops, 0,\n                    AppOpsManager._NUM_OP - 1, \"Invalid op code in: \" + Arrays.toString(ops));\n        }\n        if (callback == null) {\n            return;\n        }\n        synchronized (this) {\n            SparseArray<ActiveCallback> callbacks = mActiveWatchers.get(callback.asBinder());\n            if (callbacks == null) {\n                callbacks = new SparseArray<>();\n                mActiveWatchers.put(callback.asBinder(), callbacks);\n            }\n            final ActiveCallback activeCallback = new ActiveCallback(callback, watchedUid,\n                    callingUid, callingPid);\n            for (int op : ops) {\n                callbacks.put(op, activeCallback);\n            }\n        }\n    }\n\n    @Override\n    public void stopWatchingActive(IAppOpsActiveCallback callback) {\n        if (callback == null) {\n            return;\n        }\n        synchronized (this) {\n            final SparseArray<ActiveCallback> activeCallbacks =\n                    mActiveWatchers.remove(callback.asBinder());\n            if (activeCallbacks == null) {\n                return;\n            }\n            final int callbackCount = activeCallbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                activeCallbacks.valueAt(i).destroy();\n            }\n        }\n    }\n\n    @Override\n    public void startWatchingStarted(int[] ops, @NonNull IAppOpsStartedCallback callback) {\n        int watchedUid = Process.INVALID_UID;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                != PackageManager.PERMISSION_GRANTED) {\n            watchedUid = callingUid;\n        }\n\n        Preconditions.checkArgument(!ArrayUtils.isEmpty(ops), \"Ops cannot be null or empty\");\n        Preconditions.checkArrayElementsInRange(ops, 0, AppOpsManager._NUM_OP - 1,\n                \"Invalid op code in: \" + Arrays.toString(ops));\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n\n        synchronized (this) {\n            SparseArray<StartedCallback> callbacks = mStartedWatchers.get(callback.asBinder());\n            if (callbacks == null) {\n                callbacks = new SparseArray<>();\n                mStartedWatchers.put(callback.asBinder(), callbacks);\n            }\n\n            final StartedCallback startedCallback = new StartedCallback(callback, watchedUid,\n                    callingUid, callingPid);\n            for (int op : ops) {\n                callbacks.put(op, startedCallback);\n            }\n        }\n    }\n\n    @Override\n    public void stopWatchingStarted(IAppOpsStartedCallback callback) {\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n\n        synchronized (this) {\n            final SparseArray<StartedCallback> startedCallbacks =\n                    mStartedWatchers.remove(callback.asBinder());\n            if (startedCallbacks == null) {\n                return;\n            }\n\n            final int callbackCount = startedCallbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                startedCallbacks.valueAt(i).destroy();\n            }\n        }\n    }\n\n    @Override\n    public void startWatchingNoted(@NonNull int[] ops, @NonNull IAppOpsNotedCallback callback) {\n        int watchedUid = Process.INVALID_UID;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                != PackageManager.PERMISSION_GRANTED) {\n            watchedUid = callingUid;\n        }\n        Preconditions.checkArgument(!ArrayUtils.isEmpty(ops), \"Ops cannot be null or empty\");\n        Preconditions.checkArrayElementsInRange(ops, 0, AppOpsManager._NUM_OP - 1,\n                \"Invalid op code in: \" + Arrays.toString(ops));\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n        synchronized (this) {\n            SparseArray<NotedCallback> callbacks = mNotedWatchers.get(callback.asBinder());\n            if (callbacks == null) {\n                callbacks = new SparseArray<>();\n                mNotedWatchers.put(callback.asBinder(), callbacks);\n            }\n            final NotedCallback notedCallback = new NotedCallback(callback, watchedUid,\n                    callingUid, callingPid);\n            for (int op : ops) {\n                callbacks.put(op, notedCallback);\n            }\n        }\n    }\n\n    @Override\n    public void stopWatchingNoted(IAppOpsNotedCallback callback) {\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n        synchronized (this) {\n            final SparseArray<NotedCallback> notedCallbacks =\n                    mNotedWatchers.remove(callback.asBinder());\n            if (notedCallbacks == null) {\n                return;\n            }\n            final int callbackCount = notedCallbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                notedCallbacks.valueAt(i).destroy();\n            }\n        }\n    }\n\n    /**\n     * Collect an {@link AsyncNotedAppOp}.\n     *\n     * @param uid The uid the op was noted for\n     * @param packageName The package the op was noted for\n     * @param opCode The code of the op noted\n     * @param attributionTag attribution tag the op was noted for\n     * @param message The message for the op noting\n     */\n    private void collectAsyncNotedOp(int uid, @NonNull String packageName, int opCode,\n            @Nullable String attributionTag, @OpFlags int flags, @NonNull String message,\n            boolean shouldCollectMessage) {\n        Objects.requireNonNull(message);\n\n        int callingUid = Binder.getCallingUid();\n\n        final long token = Binder.clearCallingIdentity();\n        try {\n            synchronized (this) {\n                Pair<String, Integer> key = getAsyncNotedOpsKey(packageName, uid);\n\n                RemoteCallbackList<IAppOpsAsyncNotedCallback> callbacks = mAsyncOpWatchers.get(key);\n                AsyncNotedAppOp asyncNotedOp = new AsyncNotedAppOp(opCode, callingUid,\n                        attributionTag, message, System.currentTimeMillis());\n                final boolean[] wasNoteForwarded = {false};\n\n                if ((flags & (OP_FLAG_SELF | OP_FLAG_TRUSTED_PROXIED)) != 0\n                        && shouldCollectMessage) {\n                    reportRuntimeAppOpAccessMessageAsyncLocked(uid, packageName, opCode,\n                            attributionTag, message);\n                }\n\n                if (callbacks != null) {\n                    callbacks.broadcast((cb) -> {\n                        try {\n                            cb.opNoted(asyncNotedOp);\n                            wasNoteForwarded[0] = true;\n                        } catch (RemoteException e) {\n                            Slog.e(TAG,\n                                    \"Could not forward noteOp of \" + opCode + \" to \" + packageName\n                                            + \"/\" + uid + \"(\" + attributionTag + \")\", e);\n                        }\n                    });\n                }\n\n                if (!wasNoteForwarded[0]) {\n                    ArrayList<AsyncNotedAppOp> unforwardedOps = mUnforwardedAsyncNotedOps.get(key);\n                    if (unforwardedOps == null) {\n                        unforwardedOps = new ArrayList<>(1);\n                        mUnforwardedAsyncNotedOps.put(key, unforwardedOps);\n                    }\n\n                    unforwardedOps.add(asyncNotedOp);\n                    if (unforwardedOps.size() > MAX_UNFORWARDED_OPS) {\n                        unforwardedOps.remove(0);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Compute a key to be used in {@link #mAsyncOpWatchers} and {@link #mUnforwardedAsyncNotedOps}\n     *\n     * @param packageName The package name of the app\n     * @param uid The uid of the app\n     *\n     * @return They key uniquely identifying the app\n     */\n    private @NonNull Pair<String, Integer> getAsyncNotedOpsKey(@NonNull String packageName,\n            int uid) {\n        return new Pair<>(packageName, uid);\n    }\n\n    @Override\n    public void startWatchingAsyncNoted(String packageName, IAppOpsAsyncNotedCallback callback) {\n        Objects.requireNonNull(packageName);\n        Objects.requireNonNull(callback);\n\n        int uid = Binder.getCallingUid();\n        Pair<String, Integer> key = getAsyncNotedOpsKey(packageName, uid);\n\n        verifyAndGetBypass(uid, packageName, null);\n\n        synchronized (this) {\n            RemoteCallbackList<IAppOpsAsyncNotedCallback> callbacks = mAsyncOpWatchers.get(key);\n            if (callbacks == null) {\n                callbacks = new RemoteCallbackList<IAppOpsAsyncNotedCallback>() {\n                    @Override\n                    public void onCallbackDied(IAppOpsAsyncNotedCallback callback) {\n                        synchronized (AppOpsService.this) {\n                            if (getRegisteredCallbackCount() == 0) {\n                                mAsyncOpWatchers.remove(key);\n                            }\n                        }\n                    }\n                };\n                mAsyncOpWatchers.put(key, callbacks);\n            }\n\n            callbacks.register(callback);\n        }\n    }\n\n    @Override\n    public void stopWatchingAsyncNoted(String packageName, IAppOpsAsyncNotedCallback callback) {\n        Objects.requireNonNull(packageName);\n        Objects.requireNonNull(callback);\n\n        int uid = Binder.getCallingUid();\n        Pair<String, Integer> key = getAsyncNotedOpsKey(packageName, uid);\n\n        verifyAndGetBypass(uid, packageName, null);\n\n        synchronized (this) {\n            RemoteCallbackList<IAppOpsAsyncNotedCallback> callbacks = mAsyncOpWatchers.get(key);\n            if (callbacks != null) {\n                callbacks.unregister(callback);\n                if (callbacks.getRegisteredCallbackCount() == 0) {\n                    mAsyncOpWatchers.remove(key);\n                }\n            }\n        }\n    }\n\n    @Override\n    public List<AsyncNotedAppOp> extractAsyncOps(String packageName) {\n        Objects.requireNonNull(packageName);\n\n        int uid = Binder.getCallingUid();\n\n        verifyAndGetBypass(uid, packageName, null);\n\n        synchronized (this) {\n            return mUnforwardedAsyncNotedOps.remove(getAsyncNotedOpsKey(packageName, uid));\n        }\n    }\n\n    @Override\n    public SyncNotedAppOp startOperation(IBinder token, int code, int uid,\n            @Nullable String packageName, @Nullable String attributionTag,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp,\n            String message, boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n            int attributionChainId) {\n        return mCheckOpsDelegateDispatcher.startOperation(token, code, uid, packageName,\n                attributionTag, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                shouldCollectMessage, attributionFlags, attributionChainId);\n    }\n\n    private SyncNotedAppOp startOperationImpl(@NonNull IBinder clientId, int code, int uid,\n            @Nullable String packageName, @Nullable String attributionTag,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, @NonNull String message,\n            boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n            int attributionChainId) {\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n        verifyIncomingPackage(packageName, UserHandle.getUserId(uid));\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, attributionTag,\n                    packageName);\n        }\n\n        // As a special case for OP_RECORD_AUDIO_HOTWORD, which we use only for attribution\n        // purposes and not as a check, also make sure that the caller is allowed to access\n        // the data gated by OP_RECORD_AUDIO.\n        //\n        // TODO: Revert this change before Android 12.\n        if (code == OP_RECORD_AUDIO_HOTWORD || code == OP_RECEIVE_AMBIENT_TRIGGER_AUDIO) {\n            int result = checkOperation(OP_RECORD_AUDIO, uid, packageName);\n            if (result != AppOpsManager.MODE_ALLOWED) {\n                return new SyncNotedAppOp(result, code, attributionTag, packageName);\n            }\n        }\n        return startOperationUnchecked(clientId, code, uid, packageName, attributionTag,\n                Process.INVALID_UID, null, null, OP_FLAG_SELF, startIfModeDefault,\n                shouldCollectAsyncNotedOp, message, shouldCollectMessage, attributionFlags,\n                attributionChainId, /*dryRun*/ false);\n    }\n\n    @Override\n    public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n            boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n            boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n            @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n        return mCheckOpsDelegateDispatcher.startProxyOperation(clientId, code, attributionSource,\n                startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlags,\n                attributionChainId);\n    }\n\n    private SyncNotedAppOp startProxyOperationImpl(@NonNull IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n            boolean shouldCollectMessage, boolean skipProxyOperation, @AttributionFlags\n            int proxyAttributionFlags, @AttributionFlags int proxiedAttributionFlags,\n            int attributionChainId) {\n        final int proxyUid = attributionSource.getUid();\n        final String proxyPackageName = attributionSource.getPackageName();\n        final String proxyAttributionTag = attributionSource.getAttributionTag();\n        final int proxiedUid = attributionSource.getNextUid();\n        final String proxiedPackageName = attributionSource.getNextPackageName();\n        final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n\n        verifyIncomingProxyUid(attributionSource);\n        verifyIncomingOp(code);\n        verifyIncomingPackage(proxyPackageName, UserHandle.getUserId(proxyUid));\n        verifyIncomingPackage(proxiedPackageName, UserHandle.getUserId(proxiedUid));\n\n        boolean isCallerTrusted = isCallerAndAttributionTrusted(attributionSource);\n        skipProxyOperation = isCallerTrusted && skipProxyOperation;\n\n        String resolvedProxyPackageName = AppOpsManager.resolvePackageName(proxyUid,\n                proxyPackageName);\n        if (resolvedProxyPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        final boolean isChainTrusted = isCallerTrusted\n                && attributionChainId != ATTRIBUTION_CHAIN_ID_NONE\n                && ((proxyAttributionFlags & ATTRIBUTION_FLAG_TRUSTED) != 0\n                || (proxiedAttributionFlags & ATTRIBUTION_FLAG_TRUSTED) != 0);\n        final boolean isSelfBlame = Binder.getCallingUid() == proxiedUid;\n        final boolean isProxyTrusted = mContext.checkPermission(\n                Manifest.permission.UPDATE_APP_OPS_STATS, -1, proxyUid)\n                == PackageManager.PERMISSION_GRANTED || isSelfBlame\n                || isChainTrusted;\n\n        String resolvedProxiedPackageName = AppOpsManager.resolvePackageName(proxiedUid,\n                proxiedPackageName);\n        if (resolvedProxiedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        final int proxiedFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXIED\n                : AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED;\n\n        if (!skipProxyOperation) {\n            // Test if the proxied operation will succeed before starting the proxy operation\n            final SyncNotedAppOp testProxiedOp = startOperationUnchecked(clientId, code,\n                    proxiedUid, resolvedProxiedPackageName, proxiedAttributionTag, proxyUid,\n                    resolvedProxyPackageName, proxyAttributionTag, proxiedFlags, startIfModeDefault,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    proxiedAttributionFlags, attributionChainId, /*dryRun*/ true);\n            if (!shouldStartForMode(testProxiedOp.getOpMode(), startIfModeDefault)) {\n                return testProxiedOp;\n            }\n\n            final int proxyFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXY\n                    : AppOpsManager.OP_FLAG_UNTRUSTED_PROXY;\n\n            final SyncNotedAppOp proxyAppOp = startOperationUnchecked(clientId, code, proxyUid,\n                    resolvedProxyPackageName, proxyAttributionTag, Process.INVALID_UID, null, null,\n                    proxyFlags, startIfModeDefault, !isProxyTrusted, \"proxy \" + message,\n                    shouldCollectMessage, proxyAttributionFlags, attributionChainId,\n                    /*dryRun*/ false);\n            if (!shouldStartForMode(proxyAppOp.getOpMode(), startIfModeDefault)) {\n                return proxyAppOp;\n            }\n        }\n\n        return startOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,\n                proxiedAttributionTag, proxyUid, resolvedProxyPackageName, proxyAttributionTag,\n                proxiedFlags, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                shouldCollectMessage, proxiedAttributionFlags, attributionChainId,\n                /*dryRun*/ false);\n    }\n\n    private boolean shouldStartForMode(int mode, boolean startIfModeDefault) {\n        return (mode == MODE_ALLOWED || (mode == MODE_DEFAULT && startIfModeDefault));\n    }\n\n    private SyncNotedAppOp startOperationUnchecked(IBinder clientId, int code, int uid,\n            @NonNull String packageName, @Nullable String attributionTag, int proxyUid,\n            String proxyPackageName, @Nullable String proxyAttributionTag, @OpFlags int flags,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, @Nullable String message,\n            boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n            int attributionChainId, boolean dryRun) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n            if (!pvr.isAttributionTagValid) {\n                attributionTag = null;\n            }\n        } catch (SecurityException e) {\n            Slog.e(TAG, \"startOperation\", e);\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                    packageName);\n        }\n        if (proxyAttributionTag != null\n                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n            proxyAttributionTag = null;\n        }\n\n        boolean isRestricted = false;\n        int startType = START_TYPE_FAILED;\n        synchronized (this) {\n            final Ops ops = getOpsLocked(uid, packageName, attributionTag,\n                    pvr.isAttributionTagValid, pvr.bypass, /* edit */ true);\n            if (ops == null) {\n                if (!dryRun) {\n                    scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag,\n                            flags, AppOpsManager.MODE_IGNORED, startType, attributionFlags,\n                            attributionChainId);\n                }\n                if (DEBUG) Slog.d(TAG, \"startOperation: no op for code \" + code + \" uid \" + uid\n                        + \" package \" + packageName + \" flags: \"\n                        + AppOpsManager.flagsToString(flags));\n                return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                        packageName);\n            }\n            final Op op = getOpLocked(ops, code, uid, true);\n            final AttributedOp attributedOp = op.getOrCreateAttribution(op, attributionTag);\n            final UidState uidState = ops.uidState;\n            isRestricted = isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass,\n                    false);\n            final int switchCode = AppOpsManager.opToSwitch(code);\n            // If there is a non-default per UID policy (we set UID op mode only if\n            // non-default) it takes over, otherwise use the per package policy.\n            if (uidState.opModes != null && uidState.opModes.indexOfKey(switchCode) >= 0) {\n                final int uidMode = uidState.evalMode(code, uidState.opModes.get(switchCode));\n                if (!shouldStartForMode(uidMode, startIfModeDefault)) {\n                    if (DEBUG) {\n                        Slog.d(TAG, \"startOperation: uid reject #\" + uidMode + \" for code \"\n                                + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                                + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    }\n                    if (!dryRun) {\n                        attributedOp.rejected(uidState.state, flags);\n                        scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag,\n                                flags, uidMode, startType, attributionFlags, attributionChainId);\n                    }\n                    return new SyncNotedAppOp(uidMode, code, attributionTag, packageName);\n                }\n            } else {\n                final Op switchOp = switchCode != code ? getOpLocked(ops, switchCode, uid, true)\n                        : op;\n                final int mode = switchOp.evalMode();\n                if (mode != AppOpsManager.MODE_ALLOWED\n                        && (!startIfModeDefault || mode != MODE_DEFAULT)) {\n                    if (DEBUG) Slog.d(TAG, \"startOperation: reject #\" + mode + \" for code \"\n                            + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                            + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    if (!dryRun) {\n                        attributedOp.rejected(uidState.state, flags);\n                        scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag,\n                                flags, mode, startType, attributionFlags, attributionChainId);\n                    }\n                    return new SyncNotedAppOp(mode, code, attributionTag, packageName);\n                }\n            }\n            if (DEBUG) Slog.d(TAG, \"startOperation: allowing code \" + code + \" uid \" + uid\n                    + \" package \" + packageName + \" restricted: \" + isRestricted\n                    + \" flags: \" + AppOpsManager.flagsToString(flags));\n            if (!dryRun) {\n                try {\n                    if (isRestricted) {\n                        attributedOp.createPaused(clientId, proxyUid, proxyPackageName,\n                                proxyAttributionTag, uidState.state, flags, attributionFlags,\n                                attributionChainId);\n                    } else {\n                        attributedOp.started(clientId, proxyUid, proxyPackageName,\n                                proxyAttributionTag, uidState.state, flags, attributionFlags,\n                                attributionChainId);\n                        startType = START_TYPE_STARTED;\n                    }\n                } catch (RemoteException e) {\n                    throw new RuntimeException(e);\n                }\n                scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                        isRestricted ? MODE_IGNORED : MODE_ALLOWED, startType, attributionFlags,\n                        attributionChainId);\n            }\n        }\n\n        if (shouldCollectAsyncNotedOp && !dryRun && !isRestricted) {\n            collectAsyncNotedOp(uid, packageName, code, attributionTag, AppOpsManager.OP_FLAG_SELF,\n                    message, shouldCollectMessage);\n        }\n\n        return new SyncNotedAppOp(isRestricted ? MODE_IGNORED : MODE_ALLOWED, code, attributionTag,\n                packageName);\n    }\n\n    @Override\n    public void finishOperation(IBinder clientId, int code, int uid, String packageName,\n            String attributionTag) {\n        mCheckOpsDelegateDispatcher.finishOperation(clientId, code, uid, packageName,\n                attributionTag);\n    }\n\n    private void finishOperationImpl(IBinder clientId, int code, int uid, String packageName,\n            String attributionTag) {\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n        verifyIncomingPackage(packageName, UserHandle.getUserId(uid));\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return;\n        }\n\n        finishOperationUnchecked(clientId, code, uid, resolvedPackageName, attributionTag);\n    }\n\n    @Override\n    public void finishProxyOperation(@NonNull IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n        mCheckOpsDelegateDispatcher.finishProxyOperation(clientId, code, attributionSource,\n                skipProxyOperation);\n    }\n\n    private Void finishProxyOperationImpl(IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n        final int proxyUid = attributionSource.getUid();\n        final String proxyPackageName = attributionSource.getPackageName();\n        final String proxyAttributionTag = attributionSource.getAttributionTag();\n        final int proxiedUid = attributionSource.getNextUid();\n        final String proxiedPackageName = attributionSource.getNextPackageName();\n        final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n\n        skipProxyOperation = skipProxyOperation\n                && isCallerAndAttributionTrusted(attributionSource);\n\n        verifyIncomingProxyUid(attributionSource);\n        verifyIncomingOp(code);\n        verifyIncomingPackage(proxyPackageName, UserHandle.getUserId(proxyUid));\n        verifyIncomingPackage(proxiedPackageName, UserHandle.getUserId(proxiedUid));\n\n        String resolvedProxyPackageName = AppOpsManager.resolvePackageName(proxyUid,\n                proxyPackageName);\n        if (resolvedProxyPackageName == null) {\n            return null;\n        }\n\n        if (!skipProxyOperation) {\n            finishOperationUnchecked(clientId, code, proxyUid, resolvedProxyPackageName,\n                    proxyAttributionTag);\n        }\n\n        String resolvedProxiedPackageName = AppOpsManager.resolvePackageName(proxiedUid,\n                proxiedPackageName);\n        if (resolvedProxiedPackageName == null) {\n            return null;\n        }\n\n        finishOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,\n                proxiedAttributionTag);\n\n        return null;\n    }\n\n    private void finishOperationUnchecked(IBinder clientId, int code, int uid, String packageName,\n            String attributionTag) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag);\n            if (!pvr.isAttributionTagValid) {\n                attributionTag = null;\n            }\n        } catch (SecurityException e) {\n            Slog.e(TAG, \"Cannot finishOperation\", e);\n            return;\n        }\n\n        synchronized (this) {\n            Op op = getOpLocked(code, uid, packageName, attributionTag, pvr.isAttributionTagValid,\n                    pvr.bypass, /* edit */ true);\n            if (op == null) {\n                Slog.e(TAG, \"Operation not found: uid=\" + uid + \" pkg=\" + packageName + \"(\"\n                        + attributionTag + \") op=\" + AppOpsManager.opToName(code));\n                return;\n            }\n            final AttributedOp attributedOp = op.mAttributions.get(attributionTag);\n            if (attributedOp == null) {\n                Slog.e(TAG, \"Attribution not found: uid=\" + uid + \" pkg=\" + packageName + \"(\"\n                        + attributionTag + \") op=\" + AppOpsManager.opToName(code));\n                return;\n            }\n\n            if (attributedOp.isRunning() || attributedOp.isPaused()) {\n                attributedOp.finished(clientId);\n            } else {\n                Slog.e(TAG, \"Operation not started: uid=\" + uid + \" pkg=\" + packageName + \"(\"\n                        + attributionTag + \") op=\" + AppOpsManager.opToName(code));\n            }\n        }\n    }\n\n    private void scheduleOpActiveChangedIfNeededLocked(int code, int uid, @NonNull\n            String packageName, @Nullable String attributionTag, boolean active, @AttributionFlags\n            int attributionFlags, int attributionChainId) {\n        ArraySet<ActiveCallback> dispatchedCallbacks = null;\n        final int callbackListCount = mActiveWatchers.size();\n        for (int i = 0; i < callbackListCount; i++) {\n            final SparseArray<ActiveCallback> callbacks = mActiveWatchers.valueAt(i);\n            ActiveCallback callback = callbacks.get(code);\n            if (callback != null) {\n                if (callback.mWatchingUid >= 0 && callback.mWatchingUid != uid) {\n                    continue;\n                }\n                if (dispatchedCallbacks == null) {\n                    dispatchedCallbacks = new ArraySet<>();\n                }\n                dispatchedCallbacks.add(callback);\n            }\n        }\n        if (dispatchedCallbacks == null) {\n            return;\n        }\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyOpActiveChanged,\n                this, dispatchedCallbacks, code, uid, packageName, attributionTag, active,\n                attributionFlags, attributionChainId));\n    }\n\n    private void notifyOpActiveChanged(ArraySet<ActiveCallback> callbacks,\n            int code, int uid, @NonNull String packageName, @Nullable String attributionTag,\n            boolean active, @AttributionFlags int attributionFlags, int attributionChainId) {\n        // There are features watching for mode changes such as window manager\n        // and location manager which are in our process. The callbacks in these\n        // features may require permissions our remote caller does not have.\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int callbackCount = callbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                final ActiveCallback callback = callbacks.valueAt(i);\n                try {\n                    if (shouldIgnoreCallback(code, callback.mCallingPid, callback.mCallingUid)) {\n                        continue;\n                    }\n                    callback.mCallback.opActiveChanged(code, uid, packageName, attributionTag,\n                            active, attributionFlags, attributionChainId);\n                } catch (RemoteException e) {\n                    /* do nothing */\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void scheduleOpStartedIfNeededLocked(int code, int uid, String pkgName,\n            String attributionTag, @OpFlags int flags, @Mode int result,\n            @AppOpsManager.OnOpStartedListener.StartedType int startedType,\n            @AttributionFlags int attributionFlags, int attributionChainId) {\n        ArraySet<StartedCallback> dispatchedCallbacks = null;\n        final int callbackListCount = mStartedWatchers.size();\n        for (int i = 0; i < callbackListCount; i++) {\n            final SparseArray<StartedCallback> callbacks = mStartedWatchers.valueAt(i);\n\n            StartedCallback callback = callbacks.get(code);\n            if (callback != null) {\n                if (callback.mWatchingUid >= 0 && callback.mWatchingUid != uid) {\n                    continue;\n                }\n\n                if (dispatchedCallbacks == null) {\n                    dispatchedCallbacks = new ArraySet<>();\n                }\n                dispatchedCallbacks.add(callback);\n            }\n        }\n\n        if (dispatchedCallbacks == null) {\n            return;\n        }\n\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyOpStarted,\n                this, dispatchedCallbacks, code, uid, pkgName, attributionTag, flags,\n                result, startedType, attributionFlags, attributionChainId));\n    }\n\n    private void notifyOpStarted(ArraySet<StartedCallback> callbacks,\n            int code, int uid, String packageName, String attributionTag, @OpFlags int flags,\n            @Mode int result, @AppOpsManager.OnOpStartedListener.StartedType int startedType,\n            @AttributionFlags int attributionFlags, int attributionChainId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int callbackCount = callbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                final StartedCallback callback = callbacks.valueAt(i);\n                try {\n                    if (shouldIgnoreCallback(code, callback.mCallingPid, callback.mCallingUid)) {\n                        continue;\n                    }\n                    callback.mCallback.opStarted(code, uid, packageName, attributionTag, flags,\n                            result, startedType, attributionFlags, attributionChainId);\n                } catch (RemoteException e) {\n                    /* do nothing */\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void scheduleOpNotedIfNeededLocked(int code, int uid, String packageName,\n            String attributionTag, @OpFlags int flags, @Mode int result) {\n        ArraySet<NotedCallback> dispatchedCallbacks = null;\n        final int callbackListCount = mNotedWatchers.size();\n        for (int i = 0; i < callbackListCount; i++) {\n            final SparseArray<NotedCallback> callbacks = mNotedWatchers.valueAt(i);\n            final NotedCallback callback = callbacks.get(code);\n            if (callback != null) {\n                if (callback.mWatchingUid >= 0 && callback.mWatchingUid != uid) {\n                    continue;\n                }\n                if (dispatchedCallbacks == null) {\n                    dispatchedCallbacks = new ArraySet<>();\n                }\n                dispatchedCallbacks.add(callback);\n            }\n        }\n        if (dispatchedCallbacks == null) {\n            return;\n        }\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyOpChecked,\n                this, dispatchedCallbacks, code, uid, packageName, attributionTag, flags,\n                result));\n    }\n\n    private void notifyOpChecked(ArraySet<NotedCallback> callbacks,\n            int code, int uid, String packageName, String attributionTag, @OpFlags int flags,\n            @Mode int result) {\n        // There are features watching for checks in our process. The callbacks in\n        // these features may require permissions our remote caller does not have.\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int callbackCount = callbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                final NotedCallback callback = callbacks.valueAt(i);\n                try {\n                    if (shouldIgnoreCallback(code, callback.mCallingPid, callback.mCallingUid)) {\n                        continue;\n                    }\n                    callback.mCallback.opNoted(code, uid, packageName, attributionTag, flags,\n                            result);\n                } catch (RemoteException e) {\n                    /* do nothing */\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    @Override\n    public int permissionToOpCode(String permission) {\n        if (permission == null) {\n            return AppOpsManager.OP_NONE;\n        }\n        return AppOpsManager.permissionToOpCode(permission);\n    }\n\n    @Override\n    public boolean shouldCollectNotes(int opCode) {\n        Preconditions.checkArgumentInRange(opCode, 0, _NUM_OP - 1, \"opCode\");\n\n        String perm = AppOpsManager.opToPermission(opCode);\n        if (perm == null) {\n            return false;\n        }\n\n        PermissionInfo permInfo;\n        try {\n            permInfo = mContext.getPackageManager().getPermissionInfo(perm, 0);\n        } catch (PackageManager.NameNotFoundException e) {\n            return false;\n        }\n\n        return permInfo.getProtection() == PROTECTION_DANGEROUS\n                || (permInfo.getProtectionFlags() & PROTECTION_FLAG_APPOP) != 0;\n    }\n\n    private void verifyIncomingProxyUid(@NonNull AttributionSource attributionSource) {\n        if (attributionSource.getUid() == Binder.getCallingUid()) {\n            return;\n        }\n        if (Binder.getCallingPid() == Process.myPid()) {\n            return;\n        }\n        if (attributionSource.isTrusted(mContext)) {\n            return;\n        }\n        mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n    }\n\n    private void verifyIncomingUid(int uid) {\n        if (uid == Binder.getCallingUid()) {\n            return;\n        }\n        if (Binder.getCallingPid() == Process.myPid()) {\n            return;\n        }\n        mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n    }\n\n    private boolean shouldIgnoreCallback(int op, int watcherPid, int watcherUid) {\n        // If it's a restricted read op, ignore it if watcher doesn't have manage ops permission,\n        // as watcher should not use this to signal if the value is changed.\n        return opRestrictsRead(op) && mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n                watcherPid, watcherUid) != PackageManager.PERMISSION_GRANTED;\n    }\n\n    private void verifyIncomingOp(int op) {\n        if (op >= 0 && op < AppOpsManager._NUM_OP) {\n            // Enforce privileged appops permission if it's a restricted read op.\n            if (opRestrictsRead(op)) {\n                if (!(mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n                        Manifest.permission.GET_APP_OPS_STATS,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n                        Manifest.permission.MANAGE_APP_OPS_MODES,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED)) {\n                    throw new SecurityException(\"verifyIncomingOp: uid \" + Binder.getCallingUid()\n                            + \" does not have any of {MANAGE_APPOPS, GET_APP_OPS_STATS, \"\n                            + \"MANAGE_APP_OPS_MODES}\");\n                }\n            }\n            return;\n        }\n        throw new IllegalArgumentException(\"Bad operation #\" + op);\n    }\n\n    private void verifyIncomingPackage(@Nullable String packageName, @UserIdInt int userId) {\n        if (packageName != null && getPackageManagerInternal().filterAppAccess(packageName,\n                Binder.getCallingUid(), userId)) {\n            throw new IllegalArgumentException(\n                    packageName + \" not found from \" + Binder.getCallingUid());\n        }\n    }\n\n    private boolean isCallerAndAttributionTrusted(@NonNull AttributionSource attributionSource) {\n        if (attributionSource.getUid() != Binder.getCallingUid()\n                && attributionSource.isTrusted(mContext)) {\n            return true;\n        }\n        return mContext.checkPermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null)\n                == PackageManager.PERMISSION_GRANTED;\n    }\n\n    private @Nullable UidState getUidStateLocked(int uid, boolean edit) {\n        UidState uidState = mUidStates.get(uid);\n        if (uidState == null) {\n            if (!edit) {\n                return null;\n            }\n            uidState = new UidState(uid);\n            mUidStates.put(uid, uidState);\n        } else {\n            updatePendingStateIfNeededLocked(uidState);\n        }\n        return uidState;\n    }\n\n    /**\n     * Check if the pending state should be updated and do so if needed\n     *\n     * @param uidState The uidState that might have a pending state\n     */\n    private void updatePendingStateIfNeededLocked(@NonNull UidState uidState) {\n        if (uidState != null) {\n            if (uidState.pendingStateCommitTime != 0) {\n                if (uidState.pendingStateCommitTime < mLastRealtime) {\n                    commitUidPendingStateLocked(uidState);\n                } else {\n                    mLastRealtime = SystemClock.elapsedRealtime();\n                    if (uidState.pendingStateCommitTime < mLastRealtime) {\n                        commitUidPendingStateLocked(uidState);\n                    }\n                }\n            }\n        }\n    }\n\n    private void commitUidPendingStateLocked(UidState uidState) {\n        if (uidState.hasForegroundWatchers) {\n            for (int fgi = uidState.foregroundOps.size() - 1; fgi >= 0; fgi--) {\n                if (!uidState.foregroundOps.valueAt(fgi)) {\n                    continue;\n                }\n                final int code = uidState.foregroundOps.keyAt(fgi);\n                // For location ops we consider fg state only if the fg service\n                // is of location type, for all other ops any fg service will do.\n                final long firstUnrestrictedUidState = resolveFirstUnrestrictedUidState(code);\n                final boolean resolvedLastFg = uidState.state <= firstUnrestrictedUidState;\n                final boolean resolvedNowFg = uidState.pendingState <= firstUnrestrictedUidState;\n                if (resolvedLastFg == resolvedNowFg\n                        && uidState.capability == uidState.pendingCapability\n                        && uidState.appWidgetVisible == uidState.pendingAppWidgetVisible) {\n                    continue;\n                }\n\n                if (uidState.opModes != null\n                        && uidState.opModes.indexOfKey(code) >= 0\n                        && uidState.opModes.get(code) == AppOpsManager.MODE_FOREGROUND) {\n                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                            AppOpsService::notifyOpChangedForAllPkgsInUid,\n                            this, code, uidState.uid, true, null));\n                } else if (uidState.pkgOps != null) {\n                    final ArraySet<ModeCallback> callbacks = mOpModeWatchers.get(code);\n                    if (callbacks != null) {\n                        for (int cbi = callbacks.size() - 1; cbi >= 0; cbi--) {\n                            final ModeCallback callback = callbacks.valueAt(cbi);\n                            if ((callback.mFlags & AppOpsManager.WATCH_FOREGROUND_CHANGES) == 0\n                                    || !callback.isWatchingUid(uidState.uid)) {\n                                continue;\n                            }\n                            for (int pkgi = uidState.pkgOps.size() - 1; pkgi >= 0; pkgi--) {\n                                final Op op = uidState.pkgOps.valueAt(pkgi).get(code);\n                                if (op == null) {\n                                    continue;\n                                }\n                                if (op.mode == AppOpsManager.MODE_FOREGROUND) {\n                                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                                            AppOpsService::notifyOpChanged,\n                                            this, callback, code, uidState.uid,\n                                            uidState.pkgOps.keyAt(pkgi)));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        uidState.state = uidState.pendingState;\n        uidState.capability = uidState.pendingCapability;\n        uidState.appWidgetVisible = uidState.pendingAppWidgetVisible;\n        uidState.pendingStateCommitTime = 0;\n    }\n\n    private void updateAppWidgetVisibility(SparseArray<String> uidPackageNames, boolean visible) {\n        synchronized (this) {\n            for (int i = uidPackageNames.size() - 1; i >= 0; i--) {\n                final int uid = uidPackageNames.keyAt(i);\n                final UidState uidState = getUidStateLocked(uid, true);\n                if (uidState != null && (uidState.pendingAppWidgetVisible != visible)) {\n                    uidState.pendingAppWidgetVisible = visible;\n                    if (uidState.pendingAppWidgetVisible != uidState.appWidgetVisible) {\n                        commitUidPendingStateLocked(uidState);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @return {@link PackageManagerInternal}\n     */\n    private @NonNull PackageManagerInternal getPackageManagerInternal() {\n        if (mPackageManagerInternal == null) {\n            mPackageManagerInternal = LocalServices.getService(PackageManagerInternal.class);\n        }\n\n        return mPackageManagerInternal;\n    }\n\n    /**\n     * Create a restriction description matching the properties of the package.\n     *\n     * @param pkg The package to create the restriction description for\n     *\n     * @return The restriction matching the package\n     */\n    private RestrictionBypass getBypassforPackage(@NonNull AndroidPackage pkg) {\n        return new RestrictionBypass(pkg.getUid() == Process.SYSTEM_UID, pkg.isPrivileged(),\n                mContext.checkPermission(android.Manifest.permission\n                        .EXEMPT_FROM_AUDIO_RECORD_RESTRICTIONS, -1, pkg.getUid())\n                == PackageManager.PERMISSION_GRANTED);\n    }\n\n    /**\n     * @see #verifyAndGetBypass(int, String, String, String)\n     */\n    private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n            @Nullable String attributionTag) {\n        return verifyAndGetBypass(uid, packageName, attributionTag, null);\n    }\n\n    /**\n     * Verify that package belongs to uid and return the {@link RestrictionBypass bypass\n     * description} for the package, along with a boolean indicating whether the attribution tag is\n     * valid.\n     *\n     * @param uid The uid the package belongs to\n     * @param packageName The package the might belong to the uid\n     * @param attributionTag attribution tag or {@code null} if no need to verify\n     * @param proxyPackageName The proxy package, from which the attribution tag is to be pulled\n     *\n     * @return PackageVerificationResult containing {@link RestrictionBypass} and whether the\n     *         attribution tag is valid\n     */\n    private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n            @Nullable String attributionTag, @Nullable String proxyPackageName) {\n        if (uid == Process.ROOT_UID) {\n            // For backwards compatibility, don't check package name for root UID.\n            return new PackageVerificationResult(null,\n                    /* isAttributionTagValid */ true);\n        }\n        if (Process.isSdkSandboxUid(uid)) {\n            // SDK sandbox processes run in their own UID range, but their associated\n            // UID for checks should always be the UID of the package implementing SDK sandbox\n            // service.\n            // TODO: We will need to modify the callers of this function instead, so\n            // modifications and checks against the app ops state are done with the\n            // correct UID.\n            try {\n                final PackageManager pm = mContext.getPackageManager();\n                final String supplementalPackageName = pm.getSdkSandboxPackageName();\n                if (Objects.equals(packageName, supplementalPackageName)) {\n                    int supplementalAppId = pm.getPackageUid(supplementalPackageName,\n                            PackageManager.PackageInfoFlags.of(0));\n                    uid = UserHandle.getUid(UserHandle.getUserId(uid), supplementalAppId);\n                }\n            } catch (PackageManager.NameNotFoundException e) {\n                // Shouldn't happen for the supplemental package\n                e.printStackTrace();\n            }\n        }\n\n\n        // Do not check if uid/packageName/attributionTag is already known.\n        synchronized (this) {\n            UidState uidState = mUidStates.get(uid);\n            if (uidState != null && uidState.pkgOps != null) {\n                Ops ops = uidState.pkgOps.get(packageName);\n\n                if (ops != null && (attributionTag == null || ops.knownAttributionTags.contains(\n                        attributionTag)) && ops.bypass != null) {\n                    return new PackageVerificationResult(ops.bypass,\n                            ops.validAttributionTags.contains(attributionTag));\n                }\n            }\n        }\n\n        int callingUid = Binder.getCallingUid();\n\n        // Allow any attribution tag for resolvable uids\n        int pkgUid;\n        if (Objects.equals(packageName, \"com.android.shell\")) {\n            // Special case for the shell which is a package but should be able\n            // to bypass app attribution tag restrictions.\n            pkgUid = Process.SHELL_UID;\n        } else {\n            pkgUid = resolveUid(packageName);\n        }\n        if (pkgUid != Process.INVALID_UID) {\n            if (pkgUid != UserHandle.getAppId(uid)) {\n                Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n                        + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid + \".\");\n                String otherUidMessage = DEBUG ? \" but it is really \" + pkgUid : \" but it is not\";\n                throw new SecurityException(\"Specified package \\\"\" + packageName + \"\\\" under uid \"\n                        +  UserHandle.getAppId(uid) + otherUidMessage);\n            }\n            return new PackageVerificationResult(RestrictionBypass.UNRESTRICTED,\n                    /* isAttributionTagValid */ true);\n        }\n\n        int userId = UserHandle.getUserId(uid);\n        RestrictionBypass bypass = null;\n        boolean isAttributionTagValid = false;\n\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n            AndroidPackage pkg = pmInt.getPackage(packageName);\n            if (pkg != null) {\n                isAttributionTagValid = isAttributionInPackage(pkg, attributionTag);\n                pkgUid = UserHandle.getUid(userId, UserHandle.getAppId(pkg.getUid()));\n                bypass = getBypassforPackage(pkg);\n            }\n            if (!isAttributionTagValid) {\n                AndroidPackage proxyPkg = proxyPackageName != null\n                        ? pmInt.getPackage(proxyPackageName) : null;\n                // Re-check in proxy.\n                isAttributionTagValid = isAttributionInPackage(proxyPkg, attributionTag);\n                String msg;\n                if (pkg != null && isAttributionTagValid) {\n                    msg = \"attributionTag \" + attributionTag + \" declared in manifest of the proxy\"\n                            + \" package \" + proxyPackageName + \", this is not advised\";\n                } else if (pkg != null) {\n                    msg = \"attributionTag \" + attributionTag + \" not declared in manifest of \"\n                            + packageName;\n                } else {\n                    msg = \"package \" + packageName + \" not found, can't check for \"\n                            + \"attributionTag \" + attributionTag;\n                }\n\n                try {\n                    if (!mPlatformCompat.isChangeEnabledByPackageName(\n                            SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE, packageName,\n                            userId) || !mPlatformCompat.isChangeEnabledByUid(\n                                    SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE,\n                            callingUid)) {\n                        // Do not override tags if overriding is not enabled for this package\n                        isAttributionTagValid = true;\n                    }\n                    Slog.e(TAG, msg);\n                } catch (RemoteException neverHappens) {\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n\n        if (pkgUid != uid) {\n            Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n                    + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid + \".\");\n            String otherUidMessage = DEBUG ? \" but it is really \" + pkgUid : \" but it is not\";\n            throw new SecurityException(\"Specified package \\\"\" + packageName + \"\\\" under uid \" + uid\n                    + otherUidMessage);\n        }\n\n        return new PackageVerificationResult(bypass, isAttributionTagValid);\n    }\n\n    private boolean isAttributionInPackage(@Nullable AndroidPackage pkg,\n            @Nullable String attributionTag) {\n        if (pkg == null) {\n            return false;\n        } else if (attributionTag == null) {\n            return true;\n        }\n        if (pkg.getAttributions() != null) {\n            int numAttributions = pkg.getAttributions().size();\n            for (int i = 0; i < numAttributions; i++) {\n                if (pkg.getAttributions().get(i).getTag().equals(attributionTag)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n     * This method is intended for ProxyAttributionTag validation and returns false\n     * if it does not exist in either one of them.\n     *\n     * @param packageName Name of the package\n     * @param proxyPackageName Name of the proxy package\n     * @param attributionTag attribution tag to be checked\n     *\n     * @return boolean specifying if attribution tag is valid or not\n     */\n    private boolean isAttributionTagDefined(@Nullable String packageName,\n                                            @Nullable String proxyPackageName,\n                                            @Nullable String attributionTag) {\n        if (packageName == null) {\n            return false;\n        } else if (attributionTag == null) {\n            return true;\n        }\n        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n        if (proxyPackageName != null) {\n            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n                return true;\n            }\n        }\n        AndroidPackage pkg = pmInt.getPackage(packageName);\n        return isAttributionInPackage(pkg, attributionTag);\n    }\n\n    /**\n     * Get (and potentially create) ops.\n     *\n     * @param uid The uid the package belongs to\n     * @param packageName The name of the package\n     * @param attributionTag attribution tag\n     * @param isAttributionTagValid whether the given attribution tag is valid\n     * @param bypass When to bypass certain op restrictions (can be null if edit == false)\n     * @param edit If an ops does not exist, create the ops?\n\n     * @return The ops\n     */\n    private Ops getOpsLocked(int uid, String packageName, @Nullable String attributionTag,\n            boolean isAttributionTagValid, @Nullable RestrictionBypass bypass, boolean edit) {\n        UidState uidState = getUidStateLocked(uid, edit);\n        if (uidState == null) {\n            return null;\n        }\n\n        if (uidState.pkgOps == null) {\n            if (!edit) {\n                return null;\n            }\n            uidState.pkgOps = new ArrayMap<>();\n        }\n\n        Ops ops = uidState.pkgOps.get(packageName);\n        if (ops == null) {\n            if (!edit) {\n                return null;\n            }\n            ops = new Ops(packageName, uidState);\n            uidState.pkgOps.put(packageName, ops);\n        }\n\n        if (edit) {\n            if (bypass != null) {\n                ops.bypass = bypass;\n            }\n\n            if (attributionTag != null) {\n                ops.knownAttributionTags.add(attributionTag);\n                if (isAttributionTagValid) {\n                    ops.validAttributionTags.add(attributionTag);\n                } else {\n                    ops.validAttributionTags.remove(attributionTag);\n                }\n            }\n        }\n\n        return ops;\n    }\n\n    private void scheduleWriteLocked() {\n        if (!mWriteScheduled) {\n            mWriteScheduled = true;\n            mHandler.postDelayed(mWriteRunner, WRITE_DELAY);\n        }\n    }\n\n    private void scheduleFastWriteLocked() {\n        if (!mFastWriteScheduled) {\n            mWriteScheduled = true;\n            mFastWriteScheduled = true;\n            mHandler.removeCallbacks(mWriteRunner);\n            mHandler.postDelayed(mWriteRunner, 10*1000);\n        }\n    }\n\n    /**\n     * Get the state of an op for a uid.\n     *\n     * @param code The code of the op\n     * @param uid The uid the of the package\n     * @param packageName The package name for which to get the state for\n     * @param attributionTag The attribution tag\n     * @param isAttributionTagValid Whether the given attribution tag is valid\n     * @param bypass When to bypass certain op restrictions (can be null if edit == false)\n     * @param edit Iff {@code true} create the {@link Op} object if not yet created\n     *\n     * @return The {@link Op state} of the op\n     */\n    private @Nullable Op getOpLocked(int code, int uid, @NonNull String packageName,\n            @Nullable String attributionTag, boolean isAttributionTagValid,\n            @Nullable RestrictionBypass bypass, boolean edit) {\n        Ops ops = getOpsLocked(uid, packageName, attributionTag, isAttributionTagValid, bypass,\n                edit);\n        if (ops == null) {\n            return null;\n        }\n        return getOpLocked(ops, code, uid, edit);\n    }\n\n    private Op getOpLocked(Ops ops, int code, int uid, boolean edit) {\n        Op op = ops.get(code);\n        if (op == null) {\n            if (!edit) {\n                return null;\n            }\n            op = new Op(ops.uidState, ops.packageName, code, uid);\n            ops.put(code, op);\n        }\n        if (edit) {\n            scheduleWriteLocked();\n        }\n        return op;\n    }\n\n    private boolean isOpRestrictedDueToSuspend(int code, String packageName, int uid) {\n        if (!ArrayUtils.contains(OPS_RESTRICTED_ON_SUSPEND, code)) {\n            return false;\n        }\n        final PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n        return pmi.isPackageSuspended(packageName, UserHandle.getUserId(uid));\n    }\n\n    private boolean isOpRestrictedLocked(int uid, int code, String packageName,\n            String attributionTag, @Nullable RestrictionBypass appBypass, boolean isCheckOp) {\n        int restrictionSetCount = mOpGlobalRestrictions.size();\n\n        for (int i = 0; i < restrictionSetCount; i++) {\n            ClientGlobalRestrictionState restrictionState = mOpGlobalRestrictions.valueAt(i);\n            if (restrictionState.hasRestriction(code)) {\n                return true;\n            }\n        }\n\n        int userHandle = UserHandle.getUserId(uid);\n        restrictionSetCount = mOpUserRestrictions.size();\n\n        for (int i = 0; i < restrictionSetCount; i++) {\n            // For each client, check that the given op is not restricted, or that the given\n            // package is exempt from the restriction.\n            ClientUserRestrictionState restrictionState = mOpUserRestrictions.valueAt(i);\n            if (restrictionState.hasRestriction(code, packageName, attributionTag, userHandle,\n                    isCheckOp)) {\n                RestrictionBypass opBypass = opAllowSystemBypassRestriction(code);\n                if (opBypass != null) {\n                    // If we are the system, bypass user restrictions for certain codes\n                    synchronized (this) {\n                        if (opBypass.isSystemUid && appBypass != null && appBypass.isSystemUid) {\n                            return false;\n                        }\n                        if (opBypass.isPrivileged && appBypass != null && appBypass.isPrivileged) {\n                            return false;\n                        }\n                        if (opBypass.isRecordAudioRestrictionExcept && appBypass != null\n                                && appBypass.isRecordAudioRestrictionExcept) {\n                            return false;\n                        }\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    void readState() {\n        int oldVersion = NO_VERSION;\n        synchronized (mFile) {\n            synchronized (this) {\n                FileInputStream stream;\n                try {\n                    stream = mFile.openRead();\n                } catch (FileNotFoundException e) {\n                    Slog.i(TAG, \"No existing app ops \" + mFile.getBaseFile() + \"; starting empty\");\n                    return;\n                }\n                boolean success = false;\n                mUidStates.clear();\n                try {\n                    TypedXmlPullParser parser = Xml.resolvePullParser(stream);\n                    int type;\n                    while ((type = parser.next()) != XmlPullParser.START_TAG\n                            && type != XmlPullParser.END_DOCUMENT) {\n                        ;\n                    }\n\n                    if (type != XmlPullParser.START_TAG) {\n                        throw new IllegalStateException(\"no start tag found\");\n                    }\n\n                    oldVersion = parser.getAttributeInt(null, \"v\", NO_VERSION);\n\n                    int outerDepth = parser.getDepth();\n                    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                            && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n                        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                            continue;\n                        }\n\n                        String tagName = parser.getName();\n                        if (tagName.equals(\"pkg\")) {\n                            readPackage(parser);\n                        } else if (tagName.equals(\"uid\")) {\n                            readUidOps(parser);\n                        } else {\n                            Slog.w(TAG, \"Unknown element under <app-ops>: \"\n                                    + parser.getName());\n                            XmlUtils.skipCurrentTag(parser);\n                        }\n                    }\n                    success = true;\n                } catch (IllegalStateException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (NullPointerException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (NumberFormatException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (XmlPullParserException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (IOException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (IndexOutOfBoundsException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } finally {\n                    if (!success) {\n                        mUidStates.clear();\n                    }\n                    try {\n                        stream.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n        synchronized (this) {\n            upgradeLocked(oldVersion);\n        }\n    }\n\n    private void upgradeRunAnyInBackgroundLocked() {\n        for (int i = 0; i < mUidStates.size(); i++) {\n            final UidState uidState = mUidStates.valueAt(i);\n            if (uidState == null) {\n                continue;\n            }\n            if (uidState.opModes != null) {\n                final int idx = uidState.opModes.indexOfKey(AppOpsManager.OP_RUN_IN_BACKGROUND);\n                if (idx >= 0) {\n                    uidState.opModes.put(AppOpsManager.OP_RUN_ANY_IN_BACKGROUND,\n                        uidState.opModes.valueAt(idx));\n                }\n            }\n            if (uidState.pkgOps == null) {\n                continue;\n            }\n            boolean changed = false;\n            for (int j = 0; j < uidState.pkgOps.size(); j++) {\n                Ops ops = uidState.pkgOps.valueAt(j);\n                if (ops != null) {\n                    final Op op = ops.get(AppOpsManager.OP_RUN_IN_BACKGROUND);\n                    if (op != null && op.mode != AppOpsManager.opToDefaultMode(op.op)) {\n                        final Op copy = new Op(op.uidState, op.packageName,\n                                AppOpsManager.OP_RUN_ANY_IN_BACKGROUND, uidState.uid);\n                        copy.mode = op.mode;\n                        ops.put(AppOpsManager.OP_RUN_ANY_IN_BACKGROUND, copy);\n                        changed = true;\n                    }\n                }\n            }\n            if (changed) {\n                uidState.evalForegroundOps(mOpModeWatchers);\n            }\n        }\n    }\n\n    private void upgradeLocked(int oldVersion) {\n        if (oldVersion >= CURRENT_VERSION) {\n            return;\n        }\n        Slog.d(TAG, \"Upgrading app-ops xml from version \" + oldVersion + \" to \" + CURRENT_VERSION);\n        switch (oldVersion) {\n            case NO_VERSION:\n                upgradeRunAnyInBackgroundLocked();\n                // fall through\n            case 1:\n                // for future upgrades\n        }\n        scheduleFastWriteLocked();\n    }\n\n    private void readUidOps(TypedXmlPullParser parser) throws NumberFormatException,\n            XmlPullParserException, IOException {\n        final int uid = parser.getAttributeInt(null, \"n\");\n        int outerDepth = parser.getDepth();\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                continue;\n            }\n\n            String tagName = parser.getName();\n            if (tagName.equals(\"op\")) {\n                final int code = parser.getAttributeInt(null, \"n\");\n                final int mode = parser.getAttributeInt(null, \"m\");\n                setUidMode(code, uid, mode);\n            } else {\n                Slog.w(TAG, \"Unknown element under <uid-ops>: \"\n                        + parser.getName());\n                XmlUtils.skipCurrentTag(parser);\n            }\n        }\n    }\n\n    private void readPackage(TypedXmlPullParser parser)\n            throws NumberFormatException, XmlPullParserException, IOException {\n        String pkgName = parser.getAttributeValue(null, \"n\");\n        int outerDepth = parser.getDepth();\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                continue;\n            }\n\n            String tagName = parser.getName();\n            if (tagName.equals(\"uid\")) {\n                readUid(parser, pkgName);\n            } else {\n                Slog.w(TAG, \"Unknown element under <pkg>: \"\n                        + parser.getName());\n                XmlUtils.skipCurrentTag(parser);\n            }\n        }\n    }\n\n    private void readUid(TypedXmlPullParser parser, String pkgName)\n            throws NumberFormatException, XmlPullParserException, IOException {\n        int uid = parser.getAttributeInt(null, \"n\");\n        final UidState uidState = getUidStateLocked(uid, true);\n        int outerDepth = parser.getDepth();\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                continue;\n            }\n            String tagName = parser.getName();\n            if (tagName.equals(\"op\")) {\n                readOp(parser, uidState, pkgName);\n            } else {\n                Slog.w(TAG, \"Unknown element under <pkg>: \"\n                        + parser.getName());\n                XmlUtils.skipCurrentTag(parser);\n            }\n        }\n        uidState.evalForegroundOps(mOpModeWatchers);\n    }\n\n    private void readAttributionOp(TypedXmlPullParser parser, @NonNull Op parent,\n            @Nullable String attribution)\n            throws NumberFormatException, IOException, XmlPullParserException {\n        final AttributedOp attributedOp = parent.getOrCreateAttribution(parent, attribution);\n\n        final long key = parser.getAttributeLong(null, \"n\");\n        final int uidState = extractUidStateFromKey(key);\n        final int opFlags = extractFlagsFromKey(key);\n\n        final long accessTime = parser.getAttributeLong(null, \"t\", 0);\n        final long rejectTime = parser.getAttributeLong(null, \"r\", 0);\n        final long accessDuration = parser.getAttributeLong(null, \"d\", -1);\n        final String proxyPkg = XmlUtils.readStringAttribute(parser, \"pp\");\n        final int proxyUid = parser.getAttributeInt(null, \"pu\", Process.INVALID_UID);\n        final String proxyAttributionTag = XmlUtils.readStringAttribute(parser, \"pc\");\n\n        if (accessTime > 0) {\n            attributedOp.accessed(accessTime, accessDuration, proxyUid, proxyPkg,\n                    proxyAttributionTag, uidState, opFlags);\n        }\n        if (rejectTime > 0) {\n            attributedOp.rejected(rejectTime, uidState, opFlags);\n        }\n    }\n\n    private void readOp(TypedXmlPullParser parser,\n            @NonNull UidState uidState, @NonNull String pkgName)\n            throws NumberFormatException, XmlPullParserException, IOException {\n        int opCode = parser.getAttributeInt(null, \"n\");\n        Op op = new Op(uidState, pkgName, opCode, uidState.uid);\n\n        final int mode = parser.getAttributeInt(null, \"m\", AppOpsManager.opToDefaultMode(op.op));\n        op.mode = mode;\n\n        int outerDepth = parser.getDepth();\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                continue;\n            }\n            String tagName = parser.getName();\n            if (tagName.equals(\"st\")) {\n                readAttributionOp(parser, op, XmlUtils.readStringAttribute(parser, \"id\"));\n            } else {\n                Slog.w(TAG, \"Unknown element under <op>: \"\n                        + parser.getName());\n                XmlUtils.skipCurrentTag(parser);\n            }\n        }\n\n        if (uidState.pkgOps == null) {\n            uidState.pkgOps = new ArrayMap<>();\n        }\n        Ops ops = uidState.pkgOps.get(pkgName);\n        if (ops == null) {\n            ops = new Ops(pkgName, uidState);\n            uidState.pkgOps.put(pkgName, ops);\n        }\n        ops.put(op.op, op);\n    }\n\n    void writeState() {\n        synchronized (mFile) {\n            FileOutputStream stream;\n            try {\n                stream = mFile.startWrite();\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to write state: \" + e);\n                return;\n            }\n\n            List<AppOpsManager.PackageOps> allOps = getPackagesForOps(null);\n\n            try {\n                TypedXmlSerializer out = Xml.resolveSerializer(stream);\n                out.startDocument(null, true);\n                out.startTag(null, \"app-ops\");\n                out.attributeInt(null, \"v\", CURRENT_VERSION);\n\n                SparseArray<SparseIntArray> uidStatesClone;\n                synchronized (this) {\n                    uidStatesClone = new SparseArray<>(mUidStates.size());\n\n                    final int uidStateCount = mUidStates.size();\n                    for (int uidStateNum = 0; uidStateNum < uidStateCount; uidStateNum++) {\n                        UidState uidState = mUidStates.valueAt(uidStateNum);\n                        int uid = mUidStates.keyAt(uidStateNum);\n\n                        SparseIntArray opModes = uidState.opModes;\n                        if (opModes != null && opModes.size() > 0) {\n                            uidStatesClone.put(uid, new SparseIntArray(opModes.size()));\n\n                            final int opCount = opModes.size();\n                            for (int opCountNum = 0; opCountNum < opCount; opCountNum++) {\n                                uidStatesClone.get(uid).put(\n                                        opModes.keyAt(opCountNum),\n                                        opModes.valueAt(opCountNum));\n                            }\n                        }\n                    }\n                }\n\n                final int uidStateCount = uidStatesClone.size();\n                for (int uidStateNum = 0; uidStateNum < uidStateCount; uidStateNum++) {\n                    SparseIntArray opModes = uidStatesClone.valueAt(uidStateNum);\n                    if (opModes != null && opModes.size() > 0) {\n                        out.startTag(null, \"uid\");\n                        out.attributeInt(null, \"n\", uidStatesClone.keyAt(uidStateNum));\n                        final int opCount = opModes.size();\n                        for (int opCountNum = 0; opCountNum < opCount; opCountNum++) {\n                            final int op = opModes.keyAt(opCountNum);\n                            final int mode = opModes.valueAt(opCountNum);\n                            out.startTag(null, \"op\");\n                            out.attributeInt(null, \"n\", op);\n                            out.attributeInt(null, \"m\", mode);\n                            out.endTag(null, \"op\");\n                        }\n                        out.endTag(null, \"uid\");\n                    }\n                }\n\n                if (allOps != null) {\n                    String lastPkg = null;\n                    for (int i=0; i<allOps.size(); i++) {\n                        AppOpsManager.PackageOps pkg = allOps.get(i);\n                        if (!Objects.equals(pkg.getPackageName(), lastPkg)) {\n                            if (lastPkg != null) {\n                                out.endTag(null, \"pkg\");\n                            }\n                            lastPkg = pkg.getPackageName();\n                            if (lastPkg != null) {\n                                out.startTag(null, \"pkg\");\n                                out.attribute(null, \"n\", lastPkg);\n                            }\n                        }\n                        out.startTag(null, \"uid\");\n                        out.attributeInt(null, \"n\", pkg.getUid());\n                        List<AppOpsManager.OpEntry> ops = pkg.getOps();\n                        for (int j=0; j<ops.size(); j++) {\n                            AppOpsManager.OpEntry op = ops.get(j);\n                            out.startTag(null, \"op\");\n                            out.attributeInt(null, \"n\", op.getOp());\n                            if (op.getMode() != AppOpsManager.opToDefaultMode(op.getOp())) {\n                                out.attributeInt(null, \"m\", op.getMode());\n                            }\n\n                            for (String attributionTag : op.getAttributedOpEntries().keySet()) {\n                                final AttributedOpEntry attribution =\n                                        op.getAttributedOpEntries().get(attributionTag);\n\n                                final ArraySet<Long> keys = attribution.collectKeys();\n\n                                final int keyCount = keys.size();\n                                for (int k = 0; k < keyCount; k++) {\n                                    final long key = keys.valueAt(k);\n\n                                    final int uidState = AppOpsManager.extractUidStateFromKey(key);\n                                    final int flags = AppOpsManager.extractFlagsFromKey(key);\n\n                                    final long accessTime = attribution.getLastAccessTime(uidState,\n                                            uidState, flags);\n                                    final long rejectTime = attribution.getLastRejectTime(uidState,\n                                            uidState, flags);\n                                    final long accessDuration = attribution.getLastDuration(\n                                            uidState, uidState, flags);\n                                    // Proxy information for rejections is not backed up\n                                    final OpEventProxyInfo proxy = attribution.getLastProxyInfo(\n                                            uidState, uidState, flags);\n\n                                    if (accessTime <= 0 && rejectTime <= 0 && accessDuration <= 0\n                                            && proxy == null) {\n                                        continue;\n                                    }\n\n                                    String proxyPkg = null;\n                                    String proxyAttributionTag = null;\n                                    int proxyUid = Process.INVALID_UID;\n                                    if (proxy != null) {\n                                        proxyPkg = proxy.getPackageName();\n                                        proxyAttributionTag = proxy.getAttributionTag();\n                                        proxyUid = proxy.getUid();\n                                    }\n\n                                    out.startTag(null, \"st\");\n                                    if (attributionTag != null) {\n                                        out.attribute(null, \"id\", attributionTag);\n                                    }\n                                    out.attributeLong(null, \"n\", key);\n                                    if (accessTime > 0) {\n                                        out.attributeLong(null, \"t\", accessTime);\n                                    }\n                                    if (rejectTime > 0) {\n                                        out.attributeLong(null, \"r\", rejectTime);\n                                    }\n                                    if (accessDuration > 0) {\n                                        out.attributeLong(null, \"d\", accessDuration);\n                                    }\n                                    if (proxyPkg != null) {\n                                        out.attribute(null, \"pp\", proxyPkg);\n                                    }\n                                    if (proxyAttributionTag != null) {\n                                        out.attribute(null, \"pc\", proxyAttributionTag);\n                                    }\n                                    if (proxyUid >= 0) {\n                                        out.attributeInt(null, \"pu\", proxyUid);\n                                    }\n                                    out.endTag(null, \"st\");\n                                }\n                            }\n\n                            out.endTag(null, \"op\");\n                        }\n                        out.endTag(null, \"uid\");\n                    }\n                    if (lastPkg != null) {\n                        out.endTag(null, \"pkg\");\n                    }\n                }\n\n                out.endTag(null, \"app-ops\");\n                out.endDocument();\n                mFile.finishWrite(stream);\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to write state, restoring backup.\", e);\n                mFile.failWrite(stream);\n            }\n        }\n        mHistoricalRegistry.writeAndClearDiscreteHistory();\n    }\n\n    static class Shell extends ShellCommand {\n        final IAppOpsService mInterface;\n        final AppOpsService mInternal;\n\n        int userId = UserHandle.USER_SYSTEM;\n        String packageName;\n        String attributionTag;\n        String opStr;\n        String modeStr;\n        int op;\n        int mode;\n        int packageUid;\n        int nonpackageUid;\n        final static Binder sBinder = new Binder();\n        IBinder mToken;\n        boolean targetsUid;\n\n        Shell(IAppOpsService iface, AppOpsService internal) {\n            mInterface = iface;\n            mInternal = internal;\n            mToken = AppOpsManager.getClientId();\n        }\n\n        @Override\n        public int onCommand(String cmd) {\n            return onShellCommand(this, cmd);\n        }\n\n        @Override\n        public void onHelp() {\n            PrintWriter pw = getOutPrintWriter();\n            dumpCommandHelp(pw);\n        }\n\n        static private int strOpToOp(String op, PrintWriter err) {\n            try {\n                return AppOpsManager.strOpToOp(op);\n            } catch (IllegalArgumentException e) {\n            }\n            try {\n                return Integer.parseInt(op);\n            } catch (NumberFormatException e) {\n            }\n            try {\n                return AppOpsManager.strDebugOpToOp(op);\n            } catch (IllegalArgumentException e) {\n                err.println(\"Error: \" + e.getMessage());\n                return -1;\n            }\n        }\n\n        static int strModeToMode(String modeStr, PrintWriter err) {\n            for (int i = AppOpsManager.MODE_NAMES.length - 1; i >= 0; i--) {\n                if (AppOpsManager.MODE_NAMES[i].equals(modeStr)) {\n                    return i;\n                }\n            }\n            try {\n                return Integer.parseInt(modeStr);\n            } catch (NumberFormatException e) {\n            }\n            err.println(\"Error: Mode \" + modeStr + \" is not valid\");\n            return -1;\n        }\n\n        int parseUserOpMode(int defMode, PrintWriter err) throws RemoteException {\n            userId = UserHandle.USER_CURRENT;\n            opStr = null;\n            modeStr = null;\n            for (String argument; (argument = getNextArg()) != null;) {\n                if (\"--user\".equals(argument)) {\n                    userId = UserHandle.parseUserArg(getNextArgRequired());\n                } else {\n                    if (opStr == null) {\n                        opStr = argument;\n                    } else if (modeStr == null) {\n                        modeStr = argument;\n                        break;\n                    }\n                }\n            }\n            if (opStr == null) {\n                err.println(\"Error: Operation not specified.\");\n                return -1;\n            }\n            op = strOpToOp(opStr, err);\n            if (op < 0) {\n                return -1;\n            }\n            if (modeStr != null) {\n                if ((mode=strModeToMode(modeStr, err)) < 0) {\n                    return -1;\n                }\n            } else {\n                mode = defMode;\n            }\n            return 0;\n        }\n\n        int parseUserPackageOp(boolean reqOp, PrintWriter err) throws RemoteException {\n            userId = UserHandle.USER_CURRENT;\n            packageName = null;\n            opStr = null;\n            for (String argument; (argument = getNextArg()) != null;) {\n                if (\"--user\".equals(argument)) {\n                    userId = UserHandle.parseUserArg(getNextArgRequired());\n                } else if (\"--uid\".equals(argument)) {\n                    targetsUid = true;\n                } else if (\"--attribution\".equals(argument)) {\n                    attributionTag = getNextArgRequired();\n                } else {\n                    if (packageName == null) {\n                        packageName = argument;\n                    } else if (opStr == null) {\n                        opStr = argument;\n                        break;\n                    }\n                }\n            }\n            if (packageName == null) {\n                err.println(\"Error: Package name not specified.\");\n                return -1;\n            } else if (opStr == null && reqOp) {\n                err.println(\"Error: Operation not specified.\");\n                return -1;\n            }\n            if (opStr != null) {\n                op = strOpToOp(opStr, err);\n                if (op < 0) {\n                    return -1;\n                }\n            } else {\n                op = AppOpsManager.OP_NONE;\n            }\n            if (userId == UserHandle.USER_CURRENT) {\n                userId = ActivityManager.getCurrentUser();\n            }\n            nonpackageUid = -1;\n            try {\n                nonpackageUid = Integer.parseInt(packageName);\n            } catch (NumberFormatException e) {\n            }\n            if (nonpackageUid == -1 && packageName.length() > 1 && packageName.charAt(0) == 'u'\n                    && packageName.indexOf('.') < 0) {\n                int i = 1;\n                while (i < packageName.length() && packageName.charAt(i) >= '0'\n                        && packageName.charAt(i) <= '9') {\n                    i++;\n                }\n                if (i > 1 && i < packageName.length()) {\n                    String userStr = packageName.substring(1, i);\n                    try {\n                        int user = Integer.parseInt(userStr);\n                        char type = packageName.charAt(i);\n                        i++;\n                        int startTypeVal = i;\n                        while (i < packageName.length() && packageName.charAt(i) >= '0'\n                                && packageName.charAt(i) <= '9') {\n                            i++;\n                        }\n                        if (i > startTypeVal) {\n                            String typeValStr = packageName.substring(startTypeVal, i);\n                            try {\n                                int typeVal = Integer.parseInt(typeValStr);\n                                if (type == 'a') {\n                                    nonpackageUid = UserHandle.getUid(user,\n                                            typeVal + Process.FIRST_APPLICATION_UID);\n                                } else if (type == 's') {\n                                    nonpackageUid = UserHandle.getUid(user, typeVal);\n                                }\n                            } catch (NumberFormatException e) {\n                            }\n                        }\n                    } catch (NumberFormatException e) {\n                    }\n                }\n            }\n            if (nonpackageUid != -1) {\n                packageName = null;\n            } else {\n                packageUid = resolveUid(packageName);\n                if (packageUid < 0) {\n                    packageUid = AppGlobals.getPackageManager().getPackageUid(packageName,\n                            PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);\n                }\n                if (packageUid < 0) {\n                    err.println(\"Error: No UID for \" + packageName + \" in user \" + userId);\n                    return -1;\n                }\n            }\n            return 0;\n        }\n    }\n\n    @Override public void onShellCommand(FileDescriptor in, FileDescriptor out,\n            FileDescriptor err, String[] args, ShellCallback callback,\n            ResultReceiver resultReceiver) {\n        (new Shell(this, this)).exec(this, in, out, err, args, callback, resultReceiver);\n    }\n\n    static void dumpCommandHelp(PrintWriter pw) {\n        pw.println(\"AppOps service (appops) commands:\");\n        pw.println(\"  help\");\n        pw.println(\"    Print this help text.\");\n        pw.println(\"  start [--user <USER_ID>] [--attribution <ATTRIBUTION_TAG>] <PACKAGE | UID> \"\n                + \"<OP> \");\n        pw.println(\"    Starts a given operation for a particular application.\");\n        pw.println(\"  stop [--user <USER_ID>] [--attribution <ATTRIBUTION_TAG>] <PACKAGE | UID> \"\n                + \"<OP> \");\n        pw.println(\"    Stops a given operation for a particular application.\");\n        pw.println(\"  set [--user <USER_ID>] <[--uid] PACKAGE | UID> <OP> <MODE>\");\n        pw.println(\"    Set the mode for a particular application and operation.\");\n        pw.println(\"  get [--user <USER_ID>] [--attribution <ATTRIBUTION_TAG>] <PACKAGE | UID> \"\n                + \"[<OP>]\");\n        pw.println(\"    Return the mode for a particular application and optional operation.\");\n        pw.println(\"  query-op [--user <USER_ID>] <OP> [<MODE>]\");\n        pw.println(\"    Print all packages that currently have the given op in the given mode.\");\n        pw.println(\"  reset [--user <USER_ID>] [<PACKAGE>]\");\n        pw.println(\"    Reset the given application or all applications to default modes.\");\n        pw.println(\"  write-settings\");\n        pw.println(\"    Immediately write pending changes to storage.\");\n        pw.println(\"  read-settings\");\n        pw.println(\"    Read the last written settings, replacing current state in RAM.\");\n        pw.println(\"  options:\");\n        pw.println(\"    <PACKAGE> an Android package name or its UID if prefixed by --uid\");\n        pw.println(\"    <OP>      an AppOps operation.\");\n        pw.println(\"    <MODE>    one of allow, ignore, deny, or default\");\n        pw.println(\"    <USER_ID> the user id under which the package is installed. If --user is\");\n        pw.println(\"              not specified, the current user is assumed.\");\n    }\n\n    static int onShellCommand(Shell shell, String cmd) {\n        if (cmd == null) {\n            return shell.handleDefaultCommands(cmd);\n        }\n        PrintWriter pw = shell.getOutPrintWriter();\n        PrintWriter err = shell.getErrPrintWriter();\n        try {\n            switch (cmd) {\n                case \"set\": {\n                    int res = shell.parseUserPackageOp(true, err);\n                    if (res < 0) {\n                        return res;\n                    }\n                    String modeStr = shell.getNextArg();\n                    if (modeStr == null) {\n                        err.println(\"Error: Mode not specified.\");\n                        return -1;\n                    }\n\n                    final int mode = shell.strModeToMode(modeStr, err);\n                    if (mode < 0) {\n                        return -1;\n                    }\n\n                    if (!shell.targetsUid && shell.packageName != null) {\n                        shell.mInterface.setMode(shell.op, shell.packageUid, shell.packageName,\n                                mode);\n                    } else if (shell.targetsUid && shell.packageName != null) {\n                        try {\n                            final int uid = shell.mInternal.mContext.getPackageManager()\n                                    .getPackageUidAsUser(shell.packageName, shell.userId);\n                            shell.mInterface.setUidMode(shell.op, uid, mode);\n                        } catch (PackageManager.NameNotFoundException e) {\n                            return -1;\n                        }\n                    } else {\n                        shell.mInterface.setUidMode(shell.op, shell.nonpackageUid, mode);\n                    }\n                    return 0;\n                }\n                case \"get\": {\n                    int res = shell.parseUserPackageOp(false, err);\n                    if (res < 0) {\n                        return res;\n                    }\n\n                    List<AppOpsManager.PackageOps> ops = new ArrayList<>();\n                    if (shell.packageName != null) {\n                        // Uid mode overrides package mode, so make sure it's also reported\n                        List<AppOpsManager.PackageOps> r = shell.mInterface.getUidOps(\n                                shell.packageUid,\n                                shell.op != AppOpsManager.OP_NONE ? new int[]{shell.op} : null);\n                        if (r != null) {\n                            ops.addAll(r);\n                        }\n                        r = shell.mInterface.getOpsForPackage(\n                                shell.packageUid, shell.packageName,\n                                shell.op != AppOpsManager.OP_NONE ? new int[]{shell.op} : null);\n                        if (r != null) {\n                            ops.addAll(r);\n                        }\n                    } else {\n                        ops = shell.mInterface.getUidOps(\n                                shell.nonpackageUid,\n                                shell.op != AppOpsManager.OP_NONE ? new int[]{shell.op} : null);\n                    }\n                    if (ops == null || ops.size() <= 0) {\n                        pw.println(\"No operations.\");\n                        if (shell.op > AppOpsManager.OP_NONE && shell.op < AppOpsManager._NUM_OP) {\n                            pw.println(\"Default mode: \" + AppOpsManager.modeToName(\n                                    AppOpsManager.opToDefaultMode(shell.op)));\n                        }\n                        return 0;\n                    }\n                    final long now = System.currentTimeMillis();\n                    for (int i=0; i<ops.size(); i++) {\n                        AppOpsManager.PackageOps packageOps = ops.get(i);\n                        if (packageOps.getPackageName() == null) {\n                            pw.print(\"Uid mode: \");\n                        }\n                        List<AppOpsManager.OpEntry> entries = packageOps.getOps();\n                        for (int j=0; j<entries.size(); j++) {\n                            AppOpsManager.OpEntry ent = entries.get(j);\n                            pw.print(AppOpsManager.opToName(ent.getOp()));\n                            pw.print(\": \");\n                            pw.print(AppOpsManager.modeToName(ent.getMode()));\n                            if (shell.attributionTag == null) {\n                                if (ent.getLastAccessTime(OP_FLAGS_ALL) != -1) {\n                                    pw.print(\"; time=\");\n                                    TimeUtils.formatDuration(\n                                            now - ent.getLastAccessTime(OP_FLAGS_ALL), pw);\n                                    pw.print(\" ago\");\n                                }\n                                if (ent.getLastRejectTime(OP_FLAGS_ALL) != -1) {\n                                    pw.print(\"; rejectTime=\");\n                                    TimeUtils.formatDuration(\n                                            now - ent.getLastRejectTime(OP_FLAGS_ALL), pw);\n                                    pw.print(\" ago\");\n                                }\n                                if (ent.isRunning()) {\n                                    pw.print(\" (running)\");\n                                } else if (ent.getLastDuration(OP_FLAGS_ALL) != -1) {\n                                    pw.print(\"; duration=\");\n                                    TimeUtils.formatDuration(ent.getLastDuration(OP_FLAGS_ALL), pw);\n                                }\n                            } else {\n                                final AppOpsManager.AttributedOpEntry attributionEnt =\n                                        ent.getAttributedOpEntries().get(shell.attributionTag);\n                                if (attributionEnt != null) {\n                                    if (attributionEnt.getLastAccessTime(OP_FLAGS_ALL) != -1) {\n                                        pw.print(\"; time=\");\n                                        TimeUtils.formatDuration(\n                                                now - attributionEnt.getLastAccessTime(\n                                                        OP_FLAGS_ALL), pw);\n                                        pw.print(\" ago\");\n                                    }\n                                    if (attributionEnt.getLastRejectTime(OP_FLAGS_ALL) != -1) {\n                                        pw.print(\"; rejectTime=\");\n                                        TimeUtils.formatDuration(\n                                                now - attributionEnt.getLastRejectTime(\n                                                        OP_FLAGS_ALL), pw);\n                                        pw.print(\" ago\");\n                                    }\n                                    if (attributionEnt.isRunning()) {\n                                        pw.print(\" (running)\");\n                                    } else if (attributionEnt.getLastDuration(OP_FLAGS_ALL)\n                                            != -1) {\n                                        pw.print(\"; duration=\");\n                                        TimeUtils.formatDuration(\n                                                attributionEnt.getLastDuration(OP_FLAGS_ALL), pw);\n                                    }\n                                }\n                            }\n                            pw.println();\n                        }\n                    }\n                    return 0;\n                }\n                case \"query-op\": {\n                    int res = shell.parseUserOpMode(AppOpsManager.MODE_IGNORED, err);\n                    if (res < 0) {\n                        return res;\n                    }\n                    List<AppOpsManager.PackageOps> ops = shell.mInterface.getPackagesForOps(\n                            new int[] {shell.op});\n                    if (ops == null || ops.size() <= 0) {\n                        pw.println(\"No operations.\");\n                        return 0;\n                    }\n                    for (int i=0; i<ops.size(); i++) {\n                        final AppOpsManager.PackageOps pkg = ops.get(i);\n                        boolean hasMatch = false;\n                        final List<AppOpsManager.OpEntry> entries = ops.get(i).getOps();\n                        for (int j=0; j<entries.size(); j++) {\n                            AppOpsManager.OpEntry ent = entries.get(j);\n                            if (ent.getOp() == shell.op && ent.getMode() == shell.mode) {\n                                hasMatch = true;\n                                break;\n                            }\n                        }\n                        if (hasMatch) {\n                            pw.println(pkg.getPackageName());\n                        }\n                    }\n                    return 0;\n                }\n                case \"reset\": {\n                    String packageName = null;\n                    int userId = UserHandle.USER_CURRENT;\n                    for (String argument; (argument = shell.getNextArg()) != null;) {\n                        if (\"--user\".equals(argument)) {\n                            String userStr = shell.getNextArgRequired();\n                            userId = UserHandle.parseUserArg(userStr);\n                        } else {\n                            if (packageName == null) {\n                                packageName = argument;\n                            } else {\n                                err.println(\"Error: Unsupported argument: \" + argument);\n                                return -1;\n                            }\n                        }\n                    }\n\n                    if (userId == UserHandle.USER_CURRENT) {\n                        userId = ActivityManager.getCurrentUser();\n                    }\n\n                    shell.mInterface.resetAllModes(userId, packageName);\n                    pw.print(\"Reset all modes for: \");\n                    if (userId == UserHandle.USER_ALL) {\n                        pw.print(\"all users\");\n                    } else {\n                        pw.print(\"user \"); pw.print(userId);\n                    }\n                    pw.print(\", \");\n                    if (packageName == null) {\n                        pw.println(\"all packages\");\n                    } else {\n                        pw.print(\"package \"); pw.println(packageName);\n                    }\n                    return 0;\n                }\n                case \"write-settings\": {\n                    shell.mInternal.enforceManageAppOpsModes(Binder.getCallingPid(),\n                            Binder.getCallingUid(), -1);\n                    final long token = Binder.clearCallingIdentity();\n                    try {\n                        synchronized (shell.mInternal) {\n                            shell.mInternal.mHandler.removeCallbacks(shell.mInternal.mWriteRunner);\n                        }\n                        shell.mInternal.writeState();\n                        pw.println(\"Current settings written.\");\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                    return 0;\n                }\n                case \"read-settings\": {\n                    shell.mInternal.enforceManageAppOpsModes(Binder.getCallingPid(),\n                            Binder.getCallingUid(), -1);\n                    final long token = Binder.clearCallingIdentity();\n                    try {\n                        shell.mInternal.readState();\n                        pw.println(\"Last settings read.\");\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                    return 0;\n                }\n                case \"start\": {\n                    int res = shell.parseUserPackageOp(true, err);\n                    if (res < 0) {\n                        return res;\n                    }\n\n                    if (shell.packageName != null) {\n                        shell.mInterface.startOperation(shell.mToken, shell.op, shell.packageUid,\n                                shell.packageName, shell.attributionTag, true, true,\n                                \"appops start shell command\", true,\n                                AppOpsManager.ATTRIBUTION_FLAG_ACCESSOR, ATTRIBUTION_CHAIN_ID_NONE);\n                    } else {\n                        return -1;\n                    }\n                    return 0;\n                }\n                case \"stop\": {\n                    int res = shell.parseUserPackageOp(true, err);\n                    if (res < 0) {\n                        return res;\n                    }\n\n                    if (shell.packageName != null) {\n                        shell.mInterface.finishOperation(shell.mToken, shell.op, shell.packageUid,\n                                shell.packageName, shell.attributionTag);\n                    } else {\n                        return -1;\n                    }\n                    return 0;\n                }\n                default:\n                    return shell.handleDefaultCommands(cmd);\n            }\n        } catch (RemoteException e) {\n            pw.println(\"Remote exception: \" + e);\n        }\n        return -1;\n    }\n\n    private void dumpHelp(PrintWriter pw) {\n        pw.println(\"AppOps service (appops) dump options:\");\n        pw.println(\"  -h\");\n        pw.println(\"    Print this help text.\");\n        pw.println(\"  --op [OP]\");\n        pw.println(\"    Limit output to data associated with the given app op code.\");\n        pw.println(\"  --mode [MODE]\");\n        pw.println(\"    Limit output to data associated with the given app op mode.\");\n        pw.println(\"  --package [PACKAGE]\");\n        pw.println(\"    Limit output to data associated with the given package name.\");\n        pw.println(\"  --attributionTag [attributionTag]\");\n        pw.println(\"    Limit output to data associated with the given attribution tag.\");\n        pw.println(\"  --include-discrete [n]\");\n        pw.println(\"    Include discrete ops limited to n per dimension. Use zero for no limit.\");\n        pw.println(\"  --watchers\");\n        pw.println(\"    Only output the watcher sections.\");\n        pw.println(\"  --history\");\n        pw.println(\"    Only output history.\");\n    }\n\n    private void dumpStatesLocked(@NonNull PrintWriter pw, @Nullable String filterAttributionTag,\n            @HistoricalOpsRequestFilter int filter, long nowElapsed, @NonNull Op op, long now,\n            @NonNull SimpleDateFormat sdf, @NonNull Date date, @NonNull String prefix) {\n        final int numAttributions = op.mAttributions.size();\n        for (int i = 0; i < numAttributions; i++) {\n            if ((filter & FILTER_BY_ATTRIBUTION_TAG) != 0 && !Objects.equals(\n                    op.mAttributions.keyAt(i), filterAttributionTag)) {\n                continue;\n            }\n\n            pw.print(prefix + op.mAttributions.keyAt(i) + \"=[\\n\");\n            dumpStatesLocked(pw, nowElapsed, op, op.mAttributions.keyAt(i), now, sdf, date,\n                    prefix + \"  \");\n            pw.print(prefix + \"]\\n\");\n        }\n    }\n\n    private void dumpStatesLocked(@NonNull PrintWriter pw, long nowElapsed, @NonNull Op op,\n            @Nullable String attributionTag, long now, @NonNull SimpleDateFormat sdf,\n            @NonNull Date date, @NonNull String prefix) {\n\n        final AttributedOpEntry entry = op.createSingleAttributionEntryLocked(\n                attributionTag).getAttributedOpEntries().get(attributionTag);\n\n        final ArraySet<Long> keys = entry.collectKeys();\n\n        final int keyCount = keys.size();\n        for (int k = 0; k < keyCount; k++) {\n            final long key = keys.valueAt(k);\n\n            final int uidState = AppOpsManager.extractUidStateFromKey(key);\n            final int flags = AppOpsManager.extractFlagsFromKey(key);\n\n            final long accessTime = entry.getLastAccessTime(uidState, uidState, flags);\n            final long rejectTime = entry.getLastRejectTime(uidState, uidState, flags);\n            final long accessDuration = entry.getLastDuration(uidState, uidState, flags);\n            final OpEventProxyInfo proxy = entry.getLastProxyInfo(uidState, uidState, flags);\n\n            String proxyPkg = null;\n            String proxyAttributionTag = null;\n            int proxyUid = Process.INVALID_UID;\n            if (proxy != null) {\n                proxyPkg = proxy.getPackageName();\n                proxyAttributionTag = proxy.getAttributionTag();\n                proxyUid = proxy.getUid();\n            }\n\n            if (accessTime > 0) {\n                pw.print(prefix);\n                pw.print(\"Access: \");\n                pw.print(AppOpsManager.keyToString(key));\n                pw.print(\" \");\n                date.setTime(accessTime);\n                pw.print(sdf.format(date));\n                pw.print(\" (\");\n                TimeUtils.formatDuration(accessTime - now, pw);\n                pw.print(\")\");\n                if (accessDuration > 0) {\n                    pw.print(\" duration=\");\n                    TimeUtils.formatDuration(accessDuration, pw);\n                }\n                if (proxyUid >= 0) {\n                    pw.print(\" proxy[\");\n                    pw.print(\"uid=\");\n                    pw.print(proxyUid);\n                    pw.print(\", pkg=\");\n                    pw.print(proxyPkg);\n                    pw.print(\", attributionTag=\");\n                    pw.print(proxyAttributionTag);\n                    pw.print(\"]\");\n                }\n                pw.println();\n            }\n\n            if (rejectTime > 0) {\n                pw.print(prefix);\n                pw.print(\"Reject: \");\n                pw.print(AppOpsManager.keyToString(key));\n                date.setTime(rejectTime);\n                pw.print(sdf.format(date));\n                pw.print(\" (\");\n                TimeUtils.formatDuration(rejectTime - now, pw);\n                pw.print(\")\");\n                if (proxyUid >= 0) {\n                    pw.print(\" proxy[\");\n                    pw.print(\"uid=\");\n                    pw.print(proxyUid);\n                    pw.print(\", pkg=\");\n                    pw.print(proxyPkg);\n                    pw.print(\", attributionTag=\");\n                    pw.print(proxyAttributionTag);\n                    pw.print(\"]\");\n                }\n                pw.println();\n            }\n        }\n\n        final AttributedOp attributedOp = op.mAttributions.get(attributionTag);\n        if (attributedOp.isRunning()) {\n            long earliestElapsedTime = Long.MAX_VALUE;\n            long maxNumStarts = 0;\n            int numInProgressEvents = attributedOp.mInProgressEvents.size();\n            for (int i = 0; i < numInProgressEvents; i++) {\n                InProgressStartOpEvent event = attributedOp.mInProgressEvents.valueAt(i);\n\n                earliestElapsedTime = Math.min(earliestElapsedTime, event.getStartElapsedTime());\n                maxNumStarts = Math.max(maxNumStarts, event.numUnfinishedStarts);\n            }\n\n            pw.print(prefix + \"Running start at: \");\n            TimeUtils.formatDuration(nowElapsed - earliestElapsedTime, pw);\n            pw.println();\n\n            if (maxNumStarts > 1) {\n                pw.print(prefix + \"startNesting=\");\n                pw.println(maxNumStarts);\n            }\n        }\n    }\n\n    @NeverCompile // Avoid size overhead of debugging code.\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {\n        if (!DumpUtils.checkDumpAndUsageStatsPermission(mContext, TAG, pw)) return;\n\n        int dumpOp = OP_NONE;\n        String dumpPackage = null;\n        String dumpAttributionTag = null;\n        int dumpUid = Process.INVALID_UID;\n        int dumpMode = -1;\n        boolean dumpWatchers = false;\n        // TODO ntmyren: Remove the dumpHistory and dumpFilter\n        boolean dumpHistory = false;\n        boolean includeDiscreteOps = false;\n        int nDiscreteOps = 10;\n        @HistoricalOpsRequestFilter int dumpFilter = 0;\n\n        if (args != null) {\n            for (int i = 0; i < args.length; i++) {\n                String arg = args[i];\n                if (\"-h\".equals(arg)) {\n                    dumpHelp(pw);\n                    return;\n                } else if (\"-a\".equals(arg)) {\n                    // dump all data\n                } else if (\"--op\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --op option\");\n                        return;\n                    }\n                    dumpOp = Shell.strOpToOp(args[i], pw);\n                    dumpFilter |= FILTER_BY_OP_NAMES;\n                    if (dumpOp < 0) {\n                        return;\n                    }\n                } else if (\"--package\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --package option\");\n                        return;\n                    }\n                    dumpPackage = args[i];\n                    dumpFilter |= FILTER_BY_PACKAGE_NAME;\n                    try {\n                        dumpUid = AppGlobals.getPackageManager().getPackageUid(dumpPackage,\n                                PackageManager.MATCH_KNOWN_PACKAGES | PackageManager.MATCH_INSTANT,\n                                0);\n                    } catch (RemoteException e) {\n                    }\n                    if (dumpUid < 0) {\n                        pw.println(\"Unknown package: \" + dumpPackage);\n                        return;\n                    }\n                    dumpUid = UserHandle.getAppId(dumpUid);\n                    dumpFilter |= FILTER_BY_UID;\n                } else if (\"--attributionTag\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --attributionTag option\");\n                        return;\n                    }\n                    dumpAttributionTag = args[i];\n                    dumpFilter |= FILTER_BY_ATTRIBUTION_TAG;\n                } else if (\"--mode\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --mode option\");\n                        return;\n                    }\n                    dumpMode = Shell.strModeToMode(args[i], pw);\n                    if (dumpMode < 0) {\n                        return;\n                    }\n                } else if (\"--watchers\".equals(arg)) {\n                    dumpWatchers = true;\n                } else if (\"--include-discrete\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --include-discrete option\");\n                        return;\n                    }\n                    try {\n                        nDiscreteOps = Integer.valueOf(args[i]);\n                    } catch (NumberFormatException e) {\n                        pw.println(\"Wrong parameter: \" + args[i]);\n                        return;\n                    }\n                    includeDiscreteOps = true;\n                } else if (\"--history\".equals(arg)) {\n                    dumpHistory = true;\n                } else if (arg.length() > 0 && arg.charAt(0) == '-') {\n                    pw.println(\"Unknown option: \" + arg);\n                    return;\n                } else {\n                    pw.println(\"Unknown command: \" + arg);\n                    return;\n                }\n            }\n        }\n\n        final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\");\n        final Date date = new Date();\n        synchronized (this) {\n            pw.println(\"Current AppOps Service state:\");\n            if (!dumpHistory && !dumpWatchers) {\n                mConstants.dump(pw);\n            }\n            pw.println();\n            final long now = System.currentTimeMillis();\n            final long nowElapsed = SystemClock.elapsedRealtime();\n            final long nowUptime = SystemClock.uptimeMillis();\n            boolean needSep = false;\n            if (dumpFilter == 0 && dumpMode < 0 && mProfileOwners != null && !dumpWatchers\n                    && !dumpHistory) {\n                pw.println(\"  Profile owners:\");\n                for (int poi = 0; poi < mProfileOwners.size(); poi++) {\n                    pw.print(\"    User #\");\n                    pw.print(mProfileOwners.keyAt(poi));\n                    pw.print(\": \");\n                    UserHandle.formatUid(pw, mProfileOwners.valueAt(poi));\n                    pw.println();\n                }\n                pw.println();\n            }\n            if (mOpModeWatchers.size() > 0 && !dumpHistory) {\n                boolean printedHeader = false;\n                for (int i=0; i<mOpModeWatchers.size(); i++) {\n                    if (dumpOp >= 0 && dumpOp != mOpModeWatchers.keyAt(i)) {\n                        continue;\n                    }\n                    boolean printedOpHeader = false;\n                    ArraySet<ModeCallback> callbacks = mOpModeWatchers.valueAt(i);\n                    for (int j=0; j<callbacks.size(); j++) {\n                        final ModeCallback cb = callbacks.valueAt(j);\n                        if (dumpPackage != null\n                                && dumpUid != UserHandle.getAppId(cb.mWatchingUid)) {\n                            continue;\n                        }\n                        needSep = true;\n                        if (!printedHeader) {\n                            pw.println(\"  Op mode watchers:\");\n                            printedHeader = true;\n                        }\n                        if (!printedOpHeader) {\n                            pw.print(\"    Op \");\n                            pw.print(AppOpsManager.opToName(mOpModeWatchers.keyAt(i)));\n                            pw.println(\":\");\n                            printedOpHeader = true;\n                        }\n                        pw.print(\"      #\"); pw.print(j); pw.print(\": \");\n                        pw.println(cb);\n                    }\n                }\n            }\n            if (mPackageModeWatchers.size() > 0 && dumpOp < 0 && !dumpHistory) {\n                boolean printedHeader = false;\n                for (int i=0; i<mPackageModeWatchers.size(); i++) {\n                    if (dumpPackage != null && !dumpPackage.equals(mPackageModeWatchers.keyAt(i))) {\n                        continue;\n                    }\n                    needSep = true;\n                    if (!printedHeader) {\n                        pw.println(\"  Package mode watchers:\");\n                        printedHeader = true;\n                    }\n                    pw.print(\"    Pkg \"); pw.print(mPackageModeWatchers.keyAt(i));\n                    pw.println(\":\");\n                    ArraySet<ModeCallback> callbacks = mPackageModeWatchers.valueAt(i);\n                    for (int j=0; j<callbacks.size(); j++) {\n                        pw.print(\"      #\"); pw.print(j); pw.print(\": \");\n                        pw.println(callbacks.valueAt(j));\n                    }\n                }\n            }\n            if (mModeWatchers.size() > 0 && dumpOp < 0 && !dumpHistory) {\n                boolean printedHeader = false;\n                for (int i=0; i<mModeWatchers.size(); i++) {\n                    final ModeCallback cb = mModeWatchers.valueAt(i);\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.mWatchingUid)) {\n                        continue;\n                    }\n                    needSep = true;\n                    if (!printedHeader) {\n                        pw.println(\"  All op mode watchers:\");\n                        printedHeader = true;\n                    }\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(mModeWatchers.keyAt(i))));\n                    pw.print(\": \"); pw.println(cb);\n                }\n            }\n            if (mActiveWatchers.size() > 0 && dumpMode < 0) {\n                needSep = true;\n                boolean printedHeader = false;\n                for (int watcherNum = 0; watcherNum < mActiveWatchers.size(); watcherNum++) {\n                    final SparseArray<ActiveCallback> activeWatchers =\n                            mActiveWatchers.valueAt(watcherNum);\n                    if (activeWatchers.size() <= 0) {\n                        continue;\n                    }\n                    final ActiveCallback cb = activeWatchers.valueAt(0);\n                    if (dumpOp >= 0 && activeWatchers.indexOfKey(dumpOp) < 0) {\n                        continue;\n                    }\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.mWatchingUid)) {\n                        continue;\n                    }\n                    if (!printedHeader) {\n                        pw.println(\"  All op active watchers:\");\n                        printedHeader = true;\n                    }\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(\n                            mActiveWatchers.keyAt(watcherNum))));\n                    pw.println(\" ->\");\n                    pw.print(\"        [\");\n                    final int opCount = activeWatchers.size();\n                    for (int opNum = 0; opNum < opCount; opNum++) {\n                        if (opNum > 0) {\n                            pw.print(' ');\n                        }\n                        pw.print(AppOpsManager.opToName(activeWatchers.keyAt(opNum)));\n                        if (opNum < opCount - 1) {\n                            pw.print(',');\n                        }\n                    }\n                    pw.println(\"]\");\n                    pw.print(\"        \");\n                    pw.println(cb);\n                }\n            }\n            if (mStartedWatchers.size() > 0 && dumpMode < 0) {\n                needSep = true;\n                boolean printedHeader = false;\n\n                final int watchersSize = mStartedWatchers.size();\n                for (int watcherNum = 0; watcherNum < watchersSize; watcherNum++) {\n                    final SparseArray<StartedCallback> startedWatchers =\n                            mStartedWatchers.valueAt(watcherNum);\n                    if (startedWatchers.size() <= 0) {\n                        continue;\n                    }\n\n                    final StartedCallback cb = startedWatchers.valueAt(0);\n                    if (dumpOp >= 0 && startedWatchers.indexOfKey(dumpOp) < 0) {\n                        continue;\n                    }\n\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.mWatchingUid)) {\n                        continue;\n                    }\n\n                    if (!printedHeader) {\n                        pw.println(\"  All op started watchers:\");\n                        printedHeader = true;\n                    }\n\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(\n                            mStartedWatchers.keyAt(watcherNum))));\n                    pw.println(\" ->\");\n\n                    pw.print(\"        [\");\n                    final int opCount = startedWatchers.size();\n                    for (int opNum = 0; opNum < opCount; opNum++) {\n                        if (opNum > 0) {\n                            pw.print(' ');\n                        }\n\n                        pw.print(AppOpsManager.opToName(startedWatchers.keyAt(opNum)));\n                        if (opNum < opCount - 1) {\n                            pw.print(',');\n                        }\n                    }\n                    pw.println(\"]\");\n\n                    pw.print(\"        \");\n                    pw.println(cb);\n                }\n            }\n            if (mNotedWatchers.size() > 0 && dumpMode < 0) {\n                needSep = true;\n                boolean printedHeader = false;\n                for (int watcherNum = 0; watcherNum < mNotedWatchers.size(); watcherNum++) {\n                    final SparseArray<NotedCallback> notedWatchers =\n                            mNotedWatchers.valueAt(watcherNum);\n                    if (notedWatchers.size() <= 0) {\n                        continue;\n                    }\n                    final NotedCallback cb = notedWatchers.valueAt(0);\n                    if (dumpOp >= 0 && notedWatchers.indexOfKey(dumpOp) < 0) {\n                        continue;\n                    }\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.mWatchingUid)) {\n                        continue;\n                    }\n                    if (!printedHeader) {\n                        pw.println(\"  All op noted watchers:\");\n                        printedHeader = true;\n                    }\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(\n                            mNotedWatchers.keyAt(watcherNum))));\n                    pw.println(\" ->\");\n                    pw.print(\"        [\");\n                    final int opCount = notedWatchers.size();\n                    for (int opNum = 0; opNum < opCount; opNum++) {\n                        if (opNum > 0) {\n                            pw.print(' ');\n                        }\n                        pw.print(AppOpsManager.opToName(notedWatchers.keyAt(opNum)));\n                        if (opNum < opCount - 1) {\n                            pw.print(',');\n                        }\n                    }\n                    pw.println(\"]\");\n                    pw.print(\"        \");\n                    pw.println(cb);\n                }\n            }\n            if (mAudioRestrictionManager.hasActiveRestrictions() && dumpOp < 0\n                    && dumpPackage != null && dumpMode < 0 && !dumpWatchers) {\n                needSep = mAudioRestrictionManager.dump(pw) || needSep;\n            }\n            if (needSep) {\n                pw.println();\n            }\n            for (int i=0; i<mUidStates.size(); i++) {\n                UidState uidState = mUidStates.valueAt(i);\n                final SparseIntArray opModes = uidState.opModes;\n                final ArrayMap<String, Ops> pkgOps = uidState.pkgOps;\n\n                if (dumpWatchers || dumpHistory) {\n                    continue;\n                }\n                if (dumpOp >= 0 || dumpPackage != null || dumpMode >= 0) {\n                    boolean hasOp = dumpOp < 0 || (uidState.opModes != null\n                            && uidState.opModes.indexOfKey(dumpOp) >= 0);\n                    boolean hasPackage = dumpPackage == null || dumpUid == mUidStates.keyAt(i);\n                    boolean hasMode = dumpMode < 0;\n                    if (!hasMode && opModes != null) {\n                        for (int opi = 0; !hasMode && opi < opModes.size(); opi++) {\n                            if (opModes.valueAt(opi) == dumpMode) {\n                                hasMode = true;\n                            }\n                        }\n                    }\n                    if (pkgOps != null) {\n                        for (int pkgi = 0;\n                                 (!hasOp || !hasPackage || !hasMode) && pkgi < pkgOps.size();\n                                 pkgi++) {\n                            Ops ops = pkgOps.valueAt(pkgi);\n                            if (!hasOp && ops != null && ops.indexOfKey(dumpOp) >= 0) {\n                                hasOp = true;\n                            }\n                            if (!hasMode) {\n                                for (int opi = 0; !hasMode && opi < ops.size(); opi++) {\n                                    if (ops.valueAt(opi).mode == dumpMode) {\n                                        hasMode = true;\n                                    }\n                                }\n                            }\n                            if (!hasPackage && dumpPackage.equals(ops.packageName)) {\n                                hasPackage = true;\n                            }\n                        }\n                    }\n                    if (uidState.foregroundOps != null && !hasOp) {\n                        if (uidState.foregroundOps.indexOfKey(dumpOp) > 0) {\n                            hasOp = true;\n                        }\n                    }\n                    if (!hasOp || !hasPackage || !hasMode) {\n                        continue;\n                    }\n                }\n\n                pw.print(\"  Uid \"); UserHandle.formatUid(pw, uidState.uid); pw.println(\":\");\n                pw.print(\"    state=\");\n                pw.println(AppOpsManager.getUidStateName(uidState.state));\n                if (uidState.state != uidState.pendingState) {\n                    pw.print(\"    pendingState=\");\n                    pw.println(AppOpsManager.getUidStateName(uidState.pendingState));\n                }\n                pw.print(\"    capability=\");\n                ActivityManager.printCapabilitiesFull(pw, uidState.capability);\n                pw.println();\n                if (uidState.capability != uidState.pendingCapability) {\n                    pw.print(\"    pendingCapability=\");\n                    ActivityManager.printCapabilitiesFull(pw, uidState.pendingCapability);\n                    pw.println();\n                }\n                pw.print(\"    appWidgetVisible=\");\n                pw.println(uidState.appWidgetVisible);\n                if (uidState.appWidgetVisible != uidState.pendingAppWidgetVisible) {\n                    pw.print(\"    pendingAppWidgetVisible=\");\n                    pw.println(uidState.pendingAppWidgetVisible);\n                }\n                if (uidState.pendingStateCommitTime != 0) {\n                    pw.print(\"    pendingStateCommitTime=\");\n                    TimeUtils.formatDuration(uidState.pendingStateCommitTime, nowElapsed, pw);\n                    pw.println();\n                }\n                if (uidState.foregroundOps != null && (dumpMode < 0\n                        || dumpMode == AppOpsManager.MODE_FOREGROUND)) {\n                    pw.println(\"    foregroundOps:\");\n                    for (int j = 0; j < uidState.foregroundOps.size(); j++) {\n                        if (dumpOp >= 0 && dumpOp != uidState.foregroundOps.keyAt(j)) {\n                            continue;\n                        }\n                        pw.print(\"      \");\n                        pw.print(AppOpsManager.opToName(uidState.foregroundOps.keyAt(j)));\n                        pw.print(\": \");\n                        pw.println(uidState.foregroundOps.valueAt(j) ? \"WATCHER\" : \"SILENT\");\n                    }\n                    pw.print(\"    hasForegroundWatchers=\");\n                    pw.println(uidState.hasForegroundWatchers);\n                }\n                needSep = true;\n\n                if (opModes != null) {\n                    final int opModeCount = opModes.size();\n                    for (int j = 0; j < opModeCount; j++) {\n                        final int code = opModes.keyAt(j);\n                        final int mode = opModes.valueAt(j);\n                        if (dumpOp >= 0 && dumpOp != code) {\n                            continue;\n                        }\n                        if (dumpMode >= 0 && dumpMode != mode) {\n                            continue;\n                        }\n                        pw.print(\"      \"); pw.print(AppOpsManager.opToName(code));\n                        pw.print(\": mode=\"); pw.println(AppOpsManager.modeToName(mode));\n                    }\n                }\n\n                if (pkgOps == null) {\n                    continue;\n                }\n\n                for (int pkgi = 0; pkgi < pkgOps.size(); pkgi++) {\n                    final Ops ops = pkgOps.valueAt(pkgi);\n                    if (dumpPackage != null && !dumpPackage.equals(ops.packageName)) {\n                        continue;\n                    }\n                    boolean printedPackage = false;\n                    for (int j=0; j<ops.size(); j++) {\n                        final Op op = ops.valueAt(j);\n                        final int opCode = op.op;\n                        if (dumpOp >= 0 && dumpOp != opCode) {\n                            continue;\n                        }\n                        if (dumpMode >= 0 && dumpMode != op.mode) {\n                            continue;\n                        }\n                        if (!printedPackage) {\n                            pw.print(\"    Package \"); pw.print(ops.packageName); pw.println(\":\");\n                            printedPackage = true;\n                        }\n                        pw.print(\"      \"); pw.print(AppOpsManager.opToName(opCode));\n                        pw.print(\" (\"); pw.print(AppOpsManager.modeToName(op.mode));\n                        final int switchOp = AppOpsManager.opToSwitch(opCode);\n                        if (switchOp != opCode) {\n                            pw.print(\" / switch \");\n                            pw.print(AppOpsManager.opToName(switchOp));\n                            final Op switchObj = ops.get(switchOp);\n                            int mode = switchObj != null ? switchObj.mode\n                                    : AppOpsManager.opToDefaultMode(switchOp);\n                            pw.print(\"=\"); pw.print(AppOpsManager.modeToName(mode));\n                        }\n                        pw.println(\"): \");\n                        dumpStatesLocked(pw, dumpAttributionTag, dumpFilter, nowElapsed, op, now,\n                                sdf, date, \"        \");\n                    }\n                }\n            }\n            if (needSep) {\n                pw.println();\n            }\n\n            final int globalRestrictionCount = mOpGlobalRestrictions.size();\n            for (int i = 0; i < globalRestrictionCount; i++) {\n                IBinder token = mOpGlobalRestrictions.keyAt(i);\n                ClientGlobalRestrictionState restrictionState = mOpGlobalRestrictions.valueAt(i);\n                ArraySet<Integer> restrictedOps = restrictionState.mRestrictedOps;\n\n                pw.println(\"  Global restrictions for token \" + token + \":\");\n                StringBuilder restrictedOpsValue = new StringBuilder();\n                restrictedOpsValue.append(\"[\");\n                final int restrictedOpCount = restrictedOps.size();\n                for (int j = 0; j < restrictedOpCount; j++) {\n                    if (restrictedOpsValue.length() > 1) {\n                        restrictedOpsValue.append(\", \");\n                    }\n                    restrictedOpsValue.append(AppOpsManager.opToName(restrictedOps.valueAt(j)));\n                }\n                restrictedOpsValue.append(\"]\");\n                pw.println(\"      Restricted ops: \" + restrictedOpsValue);\n\n            }\n\n            final int userRestrictionCount = mOpUserRestrictions.size();\n            for (int i = 0; i < userRestrictionCount; i++) {\n                IBinder token = mOpUserRestrictions.keyAt(i);\n                ClientUserRestrictionState restrictionState = mOpUserRestrictions.valueAt(i);\n                boolean printedTokenHeader = false;\n\n                if (dumpMode >= 0 || dumpWatchers || dumpHistory) {\n                    continue;\n                }\n\n                final int restrictionCount = restrictionState.perUserRestrictions != null\n                        ? restrictionState.perUserRestrictions.size() : 0;\n                if (restrictionCount > 0 && dumpPackage == null) {\n                    boolean printedOpsHeader = false;\n                    for (int j = 0; j < restrictionCount; j++) {\n                        int userId = restrictionState.perUserRestrictions.keyAt(j);\n                        boolean[] restrictedOps = restrictionState.perUserRestrictions.valueAt(j);\n                        if (restrictedOps == null) {\n                            continue;\n                        }\n                        if (dumpOp >= 0 && (dumpOp >= restrictedOps.length\n                                || !restrictedOps[dumpOp])) {\n                            continue;\n                        }\n                        if (!printedTokenHeader) {\n                            pw.println(\"  User restrictions for token \" + token + \":\");\n                            printedTokenHeader = true;\n                        }\n                        if (!printedOpsHeader) {\n                            pw.println(\"      Restricted ops:\");\n                            printedOpsHeader = true;\n                        }\n                        StringBuilder restrictedOpsValue = new StringBuilder();\n                        restrictedOpsValue.append(\"[\");\n                        final int restrictedOpCount = restrictedOps.length;\n                        for (int k = 0; k < restrictedOpCount; k++) {\n                            if (restrictedOps[k]) {\n                                if (restrictedOpsValue.length() > 1) {\n                                    restrictedOpsValue.append(\", \");\n                                }\n                                restrictedOpsValue.append(AppOpsManager.opToName(k));\n                            }\n                        }\n                        restrictedOpsValue.append(\"]\");\n                        pw.print(\"        \"); pw.print(\"user: \"); pw.print(userId);\n                                pw.print(\" restricted ops: \"); pw.println(restrictedOpsValue);\n                    }\n                }\n\n                final int excludedPackageCount = restrictionState.perUserExcludedPackageTags != null\n                        ? restrictionState.perUserExcludedPackageTags.size() : 0;\n                if (excludedPackageCount > 0 && dumpOp < 0) {\n                    IndentingPrintWriter ipw = new IndentingPrintWriter(pw);\n                    ipw.increaseIndent();\n                    boolean printedPackagesHeader = false;\n                    for (int j = 0; j < excludedPackageCount; j++) {\n                        int userId = restrictionState.perUserExcludedPackageTags.keyAt(j);\n                        PackageTagsList packageNames =\n                                restrictionState.perUserExcludedPackageTags.valueAt(j);\n                        if (packageNames == null) {\n                            continue;\n                        }\n                        boolean hasPackage;\n                        if (dumpPackage != null) {\n                            hasPackage = packageNames.includes(dumpPackage);\n                        } else {\n                            hasPackage = true;\n                        }\n                        if (!hasPackage) {\n                            continue;\n                        }\n                        if (!printedTokenHeader) {\n                            ipw.println(\"User restrictions for token \" + token + \":\");\n                            printedTokenHeader = true;\n                        }\n\n                        ipw.increaseIndent();\n                        if (!printedPackagesHeader) {\n                            ipw.println(\"Excluded packages:\");\n                            printedPackagesHeader = true;\n                        }\n\n                        ipw.increaseIndent();\n                        ipw.print(\"user: \");\n                        ipw.print(userId);\n                        ipw.println(\" packages: \");\n\n                        ipw.increaseIndent();\n                        packageNames.dump(ipw);\n\n                        ipw.decreaseIndent();\n                        ipw.decreaseIndent();\n                        ipw.decreaseIndent();\n                    }\n                    ipw.decreaseIndent();\n                }\n            }\n\n            if (!dumpHistory && !dumpWatchers) {\n                pw.println();\n                if (mCheckOpsDelegateDispatcher.mPolicy != null\n                        && mCheckOpsDelegateDispatcher.mPolicy instanceof AppOpsPolicy) {\n                    AppOpsPolicy policy = (AppOpsPolicy) mCheckOpsDelegateDispatcher.mPolicy;\n                    policy.dumpTags(pw);\n                } else {\n                    pw.println(\"  AppOps policy not set.\");\n                }\n            }\n        }\n\n        // Must not hold the appops lock\n        if (dumpHistory && !dumpWatchers) {\n            mHistoricalRegistry.dump(\"  \", pw, dumpUid, dumpPackage, dumpAttributionTag, dumpOp,\n                    dumpFilter);\n        }\n        if (includeDiscreteOps) {\n            pw.println(\"Discrete accesses: \");\n            mHistoricalRegistry.dumpDiscreteData(pw, dumpUid, dumpPackage, dumpAttributionTag,\n                    dumpFilter, dumpOp, sdf, date, \"  \", nDiscreteOps);\n        }\n    }\n\n    @Override\n    public void setUserRestrictions(Bundle restrictions, IBinder token, int userHandle) {\n        checkSystemUid(\"setUserRestrictions\");\n        Objects.requireNonNull(restrictions);\n        Objects.requireNonNull(token);\n        for (int i = 0; i < AppOpsManager._NUM_OP; i++) {\n            String restriction = AppOpsManager.opToRestriction(i);\n            if (restriction != null) {\n                setUserRestrictionNoCheck(i, restrictions.getBoolean(restriction, false), token,\n                        userHandle, null);\n            }\n        }\n    }\n\n    @Override\n    public void setUserRestriction(int code, boolean restricted, IBinder token, int userHandle,\n            PackageTagsList excludedPackageTags) {\n        if (Binder.getCallingPid() != Process.myPid()) {\n            mContext.enforcePermission(Manifest.permission.MANAGE_APP_OPS_RESTRICTIONS,\n                    Binder.getCallingPid(), Binder.getCallingUid(), null);\n        }\n        if (userHandle != UserHandle.getCallingUserId()) {\n            if (mContext.checkCallingOrSelfPermission(Manifest.permission\n                    .INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED\n                && mContext.checkCallingOrSelfPermission(Manifest.permission\n                    .INTERACT_ACROSS_USERS) != PackageManager.PERMISSION_GRANTED) {\n                throw new SecurityException(\"Need INTERACT_ACROSS_USERS_FULL or\"\n                        + \" INTERACT_ACROSS_USERS to interact cross user \");\n            }\n        }\n        verifyIncomingOp(code);\n        Objects.requireNonNull(token);\n        setUserRestrictionNoCheck(code, restricted, token, userHandle, excludedPackageTags);\n    }\n\n    private void setUserRestrictionNoCheck(int code, boolean restricted, IBinder token,\n            int userHandle, PackageTagsList excludedPackageTags) {\n        synchronized (AppOpsService.this) {\n            ClientUserRestrictionState restrictionState = mOpUserRestrictions.get(token);\n\n            if (restrictionState == null) {\n                try {\n                    restrictionState = new ClientUserRestrictionState(token);\n                } catch (RemoteException e) {\n                    return;\n                }\n                mOpUserRestrictions.put(token, restrictionState);\n            }\n\n            if (restrictionState.setRestriction(code, restricted, excludedPackageTags,\n                    userHandle)) {\n                mHandler.sendMessage(PooledLambda.obtainMessage(\n                        AppOpsService::notifyWatchersOfChange, this, code, UID_ANY));\n                mHandler.sendMessage(PooledLambda.obtainMessage(\n                        AppOpsService::updateStartedOpModeForUser, this, code, restricted,\n                        userHandle));\n            }\n\n            if (restrictionState.isDefault()) {\n                mOpUserRestrictions.remove(token);\n                restrictionState.destroy();\n            }\n        }\n    }\n\n    private void updateStartedOpModeForUser(int code, boolean restricted, int userId) {\n        synchronized (AppOpsService.this) {\n            int numUids = mUidStates.size();\n            for (int uidNum = 0; uidNum < numUids; uidNum++) {\n                int uid = mUidStates.keyAt(uidNum);\n                if (userId != UserHandle.USER_ALL && UserHandle.getUserId(uid) != userId) {\n                    continue;\n                }\n                updateStartedOpModeForUidLocked(code, restricted, uid);\n            }\n        }\n    }\n\n    private void updateStartedOpModeForUidLocked(int code, boolean restricted, int uid) {\n        UidState uidState = mUidStates.get(uid);\n        if (uidState == null || uidState.pkgOps == null) {\n            return;\n        }\n\n        int numPkgOps = uidState.pkgOps.size();\n        for (int pkgNum = 0; pkgNum < numPkgOps; pkgNum++) {\n            Ops ops = uidState.pkgOps.valueAt(pkgNum);\n            Op op = ops != null ? ops.get(code) : null;\n            if (op == null || (op.mode != MODE_ALLOWED && op.mode != MODE_FOREGROUND)) {\n                continue;\n            }\n            int numAttrTags = op.mAttributions.size();\n            for (int attrNum = 0; attrNum < numAttrTags; attrNum++) {\n                AttributedOp attrOp = op.mAttributions.valueAt(attrNum);\n                if (restricted && attrOp.isRunning()) {\n                    attrOp.pause();\n                } else if (attrOp.isPaused()) {\n                    attrOp.resume();\n                }\n            }\n        }\n    }\n\n    private void notifyWatchersOfChange(int code, int uid) {\n        final ArraySet<ModeCallback> clonedCallbacks;\n        synchronized (this) {\n            ArraySet<ModeCallback> callbacks = mOpModeWatchers.get(code);\n            if (callbacks == null) {\n                return;\n            }\n            clonedCallbacks = new ArraySet<>(callbacks);\n        }\n\n        notifyOpChanged(clonedCallbacks,  code, uid, null);\n    }\n\n    @Override\n    public void removeUser(int userHandle) throws RemoteException {\n        checkSystemUid(\"removeUser\");\n        synchronized (AppOpsService.this) {\n            final int tokenCount = mOpUserRestrictions.size();\n            for (int i = tokenCount - 1; i >= 0; i--) {\n                ClientUserRestrictionState opRestrictions = mOpUserRestrictions.valueAt(i);\n                opRestrictions.removeUser(userHandle);\n            }\n            removeUidsForUserLocked(userHandle);\n        }\n    }\n\n    @Override\n    public boolean isOperationActive(int code, int uid, String packageName) {\n        if (Binder.getCallingUid() != uid) {\n            if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                    != PackageManager.PERMISSION_GRANTED) {\n                return false;\n            }\n        }\n        verifyIncomingOp(code);\n        verifyIncomingPackage(packageName, UserHandle.getUserId(uid));\n\n        final String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return false;\n        }\n        // TODO moltmann: Allow to check for attribution op activeness\n        synchronized (AppOpsService.this) {\n            Ops pkgOps = getOpsLocked(uid, resolvedPackageName, null, false, null, false);\n            if (pkgOps == null) {\n                return false;\n            }\n\n            Op op = pkgOps.get(code);\n            if (op == null) {\n                return false;\n            }\n\n            return op.isRunning();\n        }\n    }\n\n    @Override\n    public boolean isProxying(int op, @NonNull String proxyPackageName,\n            @NonNull String proxyAttributionTag, int proxiedUid,\n            @NonNull String proxiedPackageName) {\n        Objects.requireNonNull(proxyPackageName);\n        Objects.requireNonNull(proxiedPackageName);\n        final long callingUid = Binder.getCallingUid();\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final List<AppOpsManager.PackageOps> packageOps = getOpsForPackage(proxiedUid,\n                    proxiedPackageName, new int[] {op});\n            if (packageOps == null || packageOps.isEmpty()) {\n                return false;\n            }\n            final List<OpEntry> opEntries = packageOps.get(0).getOps();\n            if (opEntries.isEmpty()) {\n                return false;\n            }\n            final OpEntry opEntry = opEntries.get(0);\n            if (!opEntry.isRunning()) {\n                return false;\n            }\n            final OpEventProxyInfo proxyInfo = opEntry.getLastProxyInfo(\n                    OP_FLAG_TRUSTED_PROXIED | AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED);\n            return proxyInfo != null && callingUid == proxyInfo.getUid()\n                    && proxyPackageName.equals(proxyInfo.getPackageName())\n                    && Objects.equals(proxyAttributionTag, proxyInfo.getAttributionTag());\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    @Override\n    public void resetPackageOpsNoHistory(@NonNull String packageName) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"resetPackageOpsNoHistory\");\n        synchronized (AppOpsService.this) {\n            final int uid = mPackageManagerInternal.getPackageUid(packageName, 0,\n                    UserHandle.getCallingUserId());\n            if (uid == Process.INVALID_UID) {\n                return;\n            }\n            UidState uidState = mUidStates.get(uid);\n            if (uidState == null || uidState.pkgOps == null) {\n                return;\n            }\n            Ops removedOps = uidState.pkgOps.remove(packageName);\n            if (removedOps != null) {\n                scheduleFastWriteLocked();\n            }\n        }\n    }\n\n    @Override\n    public void setHistoryParameters(@AppOpsManager.HistoricalMode int mode,\n            long baseSnapshotInterval, int compressionStep) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"setHistoryParameters\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.setHistoryParameters(mode, baseSnapshotInterval, compressionStep);\n    }\n\n    @Override\n    public void offsetHistory(long offsetMillis) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"offsetHistory\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.offsetHistory(offsetMillis);\n        mHistoricalRegistry.offsetDiscreteHistory(offsetMillis);\n    }\n\n    @Override\n    public void addHistoricalOps(HistoricalOps ops) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"addHistoricalOps\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.addHistoricalOps(ops);\n    }\n\n    @Override\n    public void resetHistoryParameters() {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"resetHistoryParameters\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.resetHistoryParameters();\n    }\n\n    @Override\n    public void clearHistory() {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"clearHistory\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.clearAllHistory();\n    }\n\n    @Override\n    public void rebootHistory(long offlineDurationMillis) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"rebootHistory\");\n\n        Preconditions.checkArgument(offlineDurationMillis >= 0);\n\n        // Must not hold the appops lock\n        mHistoricalRegistry.shutdown();\n\n        if (offlineDurationMillis > 0) {\n            SystemClock.sleep(offlineDurationMillis);\n        }\n\n        mHistoricalRegistry = new HistoricalRegistry(mHistoricalRegistry);\n        mHistoricalRegistry.systemReady(mContext.getContentResolver());\n        mHistoricalRegistry.persistPendingHistory();\n    }\n\n    /**\n     * Report runtime access to AppOp together with message (including stack trace)\n     *\n     * @param packageName The package which reported the op\n     * @param notedAppOp contains code of op and attributionTag provided by developer\n     * @param message Message describing AppOp access (can be stack trace)\n     *\n     * @return Config for future sampling to reduce amount of reporting\n     */\n    @Override\n    public MessageSamplingConfig reportRuntimeAppOpAccessMessageAndGetConfig(\n            String packageName, SyncNotedAppOp notedAppOp, String message) {\n        int uid = Binder.getCallingUid();\n        Objects.requireNonNull(packageName);\n        synchronized (this) {\n            switchPackageIfBootTimeOrRarelyUsedLocked(packageName);\n            if (!packageName.equals(mSampledPackage)) {\n                return new MessageSamplingConfig(OP_NONE, 0,\n                        Instant.now().plus(1, ChronoUnit.HOURS).toEpochMilli());\n            }\n\n            Objects.requireNonNull(notedAppOp);\n            Objects.requireNonNull(message);\n\n            reportRuntimeAppOpAccessMessageInternalLocked(uid, packageName,\n                    AppOpsManager.strOpToOp(notedAppOp.getOp()),\n                    notedAppOp.getAttributionTag(), message);\n\n            return new MessageSamplingConfig(mSampledAppOpCode, mAcceptableLeftDistance,\n                    Instant.now().plus(1, ChronoUnit.HOURS).toEpochMilli());\n        }\n    }\n\n    /**\n     * Report runtime access to AppOp together with message (entry point for reporting\n     * asynchronous access)\n     * @param uid Uid of the package which reported the op\n     * @param packageName The package which reported the op\n     * @param opCode Code of AppOp\n     * @param attributionTag FeautreId of AppOp reported\n     * @param message Message describing AppOp access (can be stack trace)\n     */\n    private void reportRuntimeAppOpAccessMessageAsyncLocked(int uid,\n            @NonNull String packageName, int opCode, @Nullable String attributionTag,\n            @NonNull String message) {\n        switchPackageIfBootTimeOrRarelyUsedLocked(packageName);\n        if (!Objects.equals(mSampledPackage, packageName)) {\n            return;\n        }\n        reportRuntimeAppOpAccessMessageInternalLocked(uid, packageName, opCode, attributionTag,\n                message);\n    }\n\n    /**\n     * Decides whether reported message is within the range of watched AppOps and picks it for\n     * reporting uniformly at random across all received messages.\n     */\n    private void reportRuntimeAppOpAccessMessageInternalLocked(int uid,\n            @NonNull String packageName, int opCode, @Nullable String attributionTag,\n            @NonNull String message) {\n        int newLeftDistance = AppOpsManager.leftCircularDistance(opCode,\n                mSampledAppOpCode, _NUM_OP);\n\n        if (mAcceptableLeftDistance < newLeftDistance\n                && mSamplingStrategy != SAMPLING_STRATEGY_UNIFORM_OPS) {\n            return;\n        }\n\n        if (mAcceptableLeftDistance > newLeftDistance\n                && mSamplingStrategy != SAMPLING_STRATEGY_UNIFORM_OPS) {\n            mAcceptableLeftDistance = newLeftDistance;\n            mMessagesCollectedCount = 0.0f;\n        }\n\n        mMessagesCollectedCount += 1.0f;\n        if (ThreadLocalRandom.current().nextFloat() <= 1.0f / mMessagesCollectedCount) {\n            mCollectedRuntimePermissionMessage = new RuntimeAppOpAccessMessage(uid, opCode,\n                    packageName, attributionTag, message, mSamplingStrategy);\n        }\n        return;\n    }\n\n    /** Pulls current AppOps access report and resamples package and app op to watch */\n    @Override\n    public @Nullable RuntimeAppOpAccessMessage collectRuntimeAppOpAccessMessage() {\n        ActivityManagerInternal ami = LocalServices.getService(ActivityManagerInternal.class);\n        boolean isCallerInstrumented =\n                ami.getInstrumentationSourceUid(Binder.getCallingUid()) != Process.INVALID_UID;\n        boolean isCallerSystem = Binder.getCallingPid() == Process.myPid();\n        if (!isCallerSystem && !isCallerInstrumented) {\n            return null;\n        }\n        mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n        RuntimeAppOpAccessMessage result;\n        synchronized (this) {\n            result = mCollectedRuntimePermissionMessage;\n            mCollectedRuntimePermissionMessage = null;\n        }\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::getPackageListAndResample,\n                this));\n        return result;\n    }\n\n    /**\n     * Checks if package is in the list of rarely used package and starts watching the new package\n     * to collect incoming message or if collection is happening in first minutes since boot.\n     * @param packageName\n     */\n    private void switchPackageIfBootTimeOrRarelyUsedLocked(@NonNull String packageName) {\n        if (mSampledPackage == null) {\n            if (ThreadLocalRandom.current().nextFloat() < 0.5f) {\n                mSamplingStrategy = SAMPLING_STRATEGY_BOOT_TIME_SAMPLING;\n                resampleAppOpForPackageLocked(packageName, true);\n            }\n        } else if (mRarelyUsedPackages.contains(packageName)) {\n            mRarelyUsedPackages.remove(packageName);\n            if (ThreadLocalRandom.current().nextFloat() < 0.5f) {\n                mSamplingStrategy = SAMPLING_STRATEGY_RARELY_USED;\n                resampleAppOpForPackageLocked(packageName, true);\n            }\n        }\n    }\n\n    /** Obtains package list and resamples package and appop to watch. */\n    private List<String> getPackageListAndResample() {\n        List<String> packageNames = getPackageNamesForSampling();\n        synchronized (this) {\n            resamplePackageAndAppOpLocked(packageNames);\n        }\n        return packageNames;\n    }\n\n    /** Resamples package and appop to watch from the list provided. */\n    private void resamplePackageAndAppOpLocked(@NonNull List<String> packageNames) {\n        if (!packageNames.isEmpty()) {\n            if (ThreadLocalRandom.current().nextFloat() < 0.5f) {\n                mSamplingStrategy = SAMPLING_STRATEGY_UNIFORM;\n                resampleAppOpForPackageLocked(packageNames.get(\n                        ThreadLocalRandom.current().nextInt(packageNames.size())), true);\n            } else {\n                mSamplingStrategy = SAMPLING_STRATEGY_UNIFORM_OPS;\n                resampleAppOpForPackageLocked(packageNames.get(\n                        ThreadLocalRandom.current().nextInt(packageNames.size())), false);\n            }\n        }\n    }\n\n    /** Resamples appop for the chosen package and initializes sampling state */\n    private void resampleAppOpForPackageLocked(@NonNull String packageName, boolean pickOp) {\n        mMessagesCollectedCount = 0.0f;\n        mSampledAppOpCode = pickOp ? ThreadLocalRandom.current().nextInt(_NUM_OP) : OP_NONE;\n        mAcceptableLeftDistance = _NUM_OP - 1;\n        mSampledPackage = packageName;\n    }\n\n    /**\n     * Creates list of rarely used packages - packages which were not used over last week or\n     * which declared but did not use permissions over last week.\n     *  */\n    private void initializeRarelyUsedPackagesList(@NonNull ArraySet<String> candidates) {\n        AppOpsManager appOps = mContext.getSystemService(AppOpsManager.class);\n        List<String> runtimeAppOpsList = getRuntimeAppOpsList();\n        AppOpsManager.HistoricalOpsRequest histOpsRequest =\n                new AppOpsManager.HistoricalOpsRequest.Builder(\n                        Math.max(Instant.now().minus(7, ChronoUnit.DAYS).toEpochMilli(), 0),\n                        Long.MAX_VALUE).setOpNames(runtimeAppOpsList).setFlags(\n                        OP_FLAG_SELF | OP_FLAG_TRUSTED_PROXIED).build();\n        appOps.getHistoricalOps(histOpsRequest, AsyncTask.THREAD_POOL_EXECUTOR,\n                new Consumer<HistoricalOps>() {\n                    @Override\n                    public void accept(HistoricalOps histOps) {\n                        int uidCount = histOps.getUidCount();\n                        for (int uidIdx = 0; uidIdx < uidCount; uidIdx++) {\n                            final AppOpsManager.HistoricalUidOps uidOps = histOps.getUidOpsAt(\n                                    uidIdx);\n                            int pkgCount = uidOps.getPackageCount();\n                            for (int pkgIdx = 0; pkgIdx < pkgCount; pkgIdx++) {\n                                String packageName = uidOps.getPackageOpsAt(\n                                        pkgIdx).getPackageName();\n                                if (!candidates.contains(packageName)) {\n                                    continue;\n                                }\n                                AppOpsManager.HistoricalPackageOps packageOps =\n                                        uidOps.getPackageOpsAt(pkgIdx);\n                                if (packageOps.getOpCount() != 0) {\n                                    candidates.remove(packageName);\n                                }\n                            }\n                        }\n                        synchronized (this) {\n                            int numPkgs = mRarelyUsedPackages.size();\n                            for (int i = 0; i < numPkgs; i++) {\n                                candidates.add(mRarelyUsedPackages.valueAt(i));\n                            }\n                            mRarelyUsedPackages = candidates;\n                        }\n                    }\n                });\n    }\n\n    /** List of app ops related to runtime permissions */\n    private List<String> getRuntimeAppOpsList() {\n        ArrayList<String> result = new ArrayList();\n        for (int i = 0; i < _NUM_OP; i++) {\n            if (shouldCollectNotes(i)) {\n                result.add(opToPublicName(i));\n            }\n        }\n        return result;\n    }\n\n    /** Returns list of packages to be used for package sampling */\n    private @NonNull List<String> getPackageNamesForSampling() {\n        List<String> packageNames = new ArrayList<>();\n        PackageManagerInternal packageManagerInternal = LocalServices.getService(\n                PackageManagerInternal.class);\n        PackageList packages = packageManagerInternal.getPackageList();\n        for (String packageName : packages.getPackageNames()) {\n            PackageInfo pkg = packageManagerInternal.getPackageInfo(packageName,\n                    PackageManager.GET_PERMISSIONS, Process.myUid(), mContext.getUserId());\n            if (isSamplingTarget(pkg)) {\n                packageNames.add(pkg.packageName);\n            }\n        }\n        return packageNames;\n    }\n\n    /** Checks whether package should be included in sampling pool */\n    private boolean isSamplingTarget(@Nullable PackageInfo pkg) {\n        if (pkg == null) {\n            return false;\n        }\n        String[] requestedPermissions = pkg.requestedPermissions;\n        if (requestedPermissions == null) {\n            return false;\n        }\n        for (String permission : requestedPermissions) {\n            PermissionInfo permissionInfo;\n            try {\n                permissionInfo = mContext.getPackageManager().getPermissionInfo(permission, 0);\n            } catch (PackageManager.NameNotFoundException ignored) {\n                continue;\n            }\n            if (permissionInfo.getProtection() == PROTECTION_DANGEROUS) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void removeUidsForUserLocked(int userHandle) {\n        for (int i = mUidStates.size() - 1; i >= 0; --i) {\n            final int uid = mUidStates.keyAt(i);\n            if (UserHandle.getUserId(uid) == userHandle) {\n                mUidStates.removeAt(i);\n            }\n        }\n    }\n\n    private void checkSystemUid(String function) {\n        int uid = Binder.getCallingUid();\n        if (uid != Process.SYSTEM_UID) {\n            throw new SecurityException(function + \" must by called by the system\");\n        }\n    }\n\n    private static int resolveUid(String packageName)  {\n        if (packageName == null) {\n            return -1;\n        }\n        switch (packageName) {\n            case \"root\":\n                return Process.ROOT_UID;\n            case \"shell\":\n            case \"dumpstate\":\n                return Process.SHELL_UID;\n            case \"media\":\n                return Process.MEDIA_UID;\n            case \"audioserver\":\n                return Process.AUDIOSERVER_UID;\n            case \"cameraserver\":\n                return Process.CAMERASERVER_UID;\n        }\n        return -1;\n    }\n\n    private static String[] getPackagesForUid(int uid) {\n        String[] packageNames = null;\n\n        // Very early during boot the package manager is not yet or not yet fully started. At this\n        // time there are no packages yet.\n        if (AppGlobals.getPackageManager() != null) {\n            try {\n                packageNames = AppGlobals.getPackageManager().getPackagesForUid(uid);\n            } catch (RemoteException e) {\n                /* ignore - local call */\n            }\n        }\n        if (packageNames == null) {\n            return EmptyArray.STRING;\n        }\n        return packageNames;\n    }\n\n    private final class ClientUserRestrictionState implements DeathRecipient {\n        private final IBinder token;\n        SparseArray<boolean[]> perUserRestrictions;\n        SparseArray<PackageTagsList> perUserExcludedPackageTags;\n\n        ClientUserRestrictionState(IBinder token)\n                throws RemoteException {\n            token.linkToDeath(this, 0);\n            this.token = token;\n        }\n\n        public boolean setRestriction(int code, boolean restricted,\n                PackageTagsList excludedPackageTags, int userId) {\n            boolean changed = false;\n\n            if (perUserRestrictions == null && restricted) {\n                perUserRestrictions = new SparseArray<>();\n            }\n\n            int[] users;\n            if (userId == UserHandle.USER_ALL) {\n                // TODO(b/162888972): this call is returning all users, not just live ones - we\n                // need to either fix the method called, or rename the variable\n                List<UserInfo> liveUsers = UserManager.get(mContext).getUsers();\n\n                users = new int[liveUsers.size()];\n                for (int i = 0; i < liveUsers.size(); i++) {\n                    users[i] = liveUsers.get(i).id;\n                }\n            } else {\n                users = new int[]{userId};\n            }\n\n            if (perUserRestrictions != null) {\n                int numUsers = users.length;\n\n                for (int i = 0; i < numUsers; i++) {\n                    int thisUserId = users[i];\n\n                    boolean[] userRestrictions = perUserRestrictions.get(thisUserId);\n                    if (userRestrictions == null && restricted) {\n                        userRestrictions = new boolean[AppOpsManager._NUM_OP];\n                        perUserRestrictions.put(thisUserId, userRestrictions);\n                    }\n                    if (userRestrictions != null && userRestrictions[code] != restricted) {\n                        userRestrictions[code] = restricted;\n                        if (!restricted && isDefault(userRestrictions)) {\n                            perUserRestrictions.remove(thisUserId);\n                            userRestrictions = null;\n                        }\n                        changed = true;\n                    }\n\n                    if (userRestrictions != null) {\n                        final boolean noExcludedPackages =\n                                excludedPackageTags == null || excludedPackageTags.isEmpty();\n                        if (perUserExcludedPackageTags == null && !noExcludedPackages) {\n                            perUserExcludedPackageTags = new SparseArray<>();\n                        }\n                        if (perUserExcludedPackageTags != null) {\n                            if (noExcludedPackages) {\n                                perUserExcludedPackageTags.remove(thisUserId);\n                                if (perUserExcludedPackageTags.size() <= 0) {\n                                    perUserExcludedPackageTags = null;\n                                }\n                            } else {\n                                perUserExcludedPackageTags.put(thisUserId, excludedPackageTags);\n                            }\n                            changed = true;\n                        }\n                    }\n                }\n            }\n\n            return changed;\n        }\n\n        public boolean hasRestriction(int restriction, String packageName, String attributionTag,\n                int userId, boolean isCheckOp) {\n            if (perUserRestrictions == null) {\n                return false;\n            }\n            boolean[] restrictions = perUserRestrictions.get(userId);\n            if (restrictions == null) {\n                return false;\n            }\n            if (!restrictions[restriction]) {\n                return false;\n            }\n            if (perUserExcludedPackageTags == null) {\n                return true;\n            }\n            PackageTagsList perUserExclusions = perUserExcludedPackageTags.get(userId);\n            if (perUserExclusions == null) {\n                return true;\n            }\n\n            if (isCheckOp) {\n                return !perUserExclusions.includes(packageName);\n            }\n            return !perUserExclusions.contains(packageName, attributionTag);\n        }\n\n        public void removeUser(int userId) {\n            if (perUserExcludedPackageTags != null) {\n                perUserExcludedPackageTags.remove(userId);\n                if (perUserExcludedPackageTags.size() <= 0) {\n                    perUserExcludedPackageTags = null;\n                }\n            }\n            if (perUserRestrictions != null) {\n                perUserRestrictions.remove(userId);\n                if (perUserRestrictions.size() <= 0) {\n                    perUserRestrictions = null;\n                }\n            }\n        }\n\n        public boolean isDefault() {\n            return perUserRestrictions == null || perUserRestrictions.size() <= 0;\n        }\n\n        @Override\n        public void binderDied() {\n            synchronized (AppOpsService.this) {\n                mOpUserRestrictions.remove(token);\n                if (perUserRestrictions == null) {\n                    return;\n                }\n                final int userCount = perUserRestrictions.size();\n                for (int i = 0; i < userCount; i++) {\n                    final boolean[] restrictions = perUserRestrictions.valueAt(i);\n                    final int restrictionCount = restrictions.length;\n                    for (int j = 0; j < restrictionCount; j++) {\n                        if (restrictions[j]) {\n                            final int changedCode = j;\n                            mHandler.post(() -> notifyWatchersOfChange(changedCode, UID_ANY));\n                        }\n                    }\n                }\n                destroy();\n            }\n        }\n\n        public void destroy() {\n            token.unlinkToDeath(this, 0);\n        }\n\n        private boolean isDefault(boolean[] array) {\n            if (ArrayUtils.isEmpty(array)) {\n                return true;\n            }\n            for (boolean value : array) {\n                if (value) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    private final class ClientGlobalRestrictionState implements DeathRecipient {\n        final IBinder mToken;\n        final ArraySet<Integer> mRestrictedOps = new ArraySet<>();\n\n        ClientGlobalRestrictionState(IBinder token)\n                throws RemoteException {\n            token.linkToDeath(this, 0);\n            this.mToken = token;\n        }\n\n        boolean setRestriction(int code, boolean restricted) {\n            if (restricted) {\n                return mRestrictedOps.add(code);\n            } else {\n                return mRestrictedOps.remove(code);\n            }\n        }\n\n        boolean hasRestriction(int code) {\n            return mRestrictedOps.contains(code);\n        }\n\n        boolean isDefault() {\n            return mRestrictedOps.isEmpty();\n        }\n\n        @Override\n        public void binderDied() {\n            destroy();\n        }\n\n        void destroy() {\n            mToken.unlinkToDeath(this, 0);\n        }\n    }\n\n    private final class AppOpsManagerInternalImpl extends AppOpsManagerInternal {\n        @Override public void setDeviceAndProfileOwners(SparseIntArray owners) {\n            synchronized (AppOpsService.this) {\n                mProfileOwners = owners;\n            }\n        }\n\n        @Override\n        public void updateAppWidgetVisibility(SparseArray<String> uidPackageNames,\n                boolean visible) {\n            AppOpsService.this.updateAppWidgetVisibility(uidPackageNames, visible);\n        }\n\n        @Override\n        public void setUidModeFromPermissionPolicy(int code, int uid, int mode,\n                @Nullable IAppOpsCallback callback) {\n            setUidMode(code, uid, mode, callback);\n        }\n\n        @Override\n        public void setModeFromPermissionPolicy(int code, int uid, @NonNull String packageName,\n                int mode, @Nullable IAppOpsCallback callback) {\n            setMode(code, uid, packageName, mode, callback);\n        }\n\n\n        @Override\n        public void setGlobalRestriction(int code, boolean restricted, IBinder token) {\n            if (Binder.getCallingPid() != Process.myPid()) {\n                // TODO instead of this enforcement put in AppOpsManagerInternal\n                throw new SecurityException(\"Only the system can set global restrictions\");\n            }\n\n            synchronized (AppOpsService.this) {\n                ClientGlobalRestrictionState restrictionState = mOpGlobalRestrictions.get(token);\n\n                if (restrictionState == null) {\n                    try {\n                        restrictionState = new ClientGlobalRestrictionState(token);\n                    } catch (RemoteException  e) {\n                        return;\n                    }\n                    mOpGlobalRestrictions.put(token, restrictionState);\n                }\n\n                if (restrictionState.setRestriction(code, restricted)) {\n                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                            AppOpsService::notifyWatchersOfChange, AppOpsService.this, code,\n                            UID_ANY));\n                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                            AppOpsService::updateStartedOpModeForUser, AppOpsService.this,\n                            code, restricted, UserHandle.USER_ALL));\n                }\n\n                if (restrictionState.isDefault()) {\n                    mOpGlobalRestrictions.remove(token);\n                    restrictionState.destroy();\n                }\n            }\n        }\n\n        @Override\n        public int getOpRestrictionCount(int code, UserHandle user, String pkg,\n                String attributionTag) {\n            int number = 0;\n            synchronized (AppOpsService.this) {\n                int numRestrictions = mOpUserRestrictions.size();\n                for (int i = 0; i < numRestrictions; i++) {\n                    if (mOpUserRestrictions.valueAt(i)\n                            .hasRestriction(code, pkg, attributionTag, user.getIdentifier(),\n                                    false)) {\n                        number++;\n                    }\n                }\n\n                numRestrictions = mOpGlobalRestrictions.size();\n                for (int i = 0; i < numRestrictions; i++) {\n                    if (mOpGlobalRestrictions.valueAt(i).hasRestriction(code)) {\n                        number++;\n                    }\n                }\n            }\n\n            return number;\n        }\n    }\n\n    /**\n     * Async task for writing note op stack trace, op code, package name and version to file\n     * More specifically, writes all the collected ops from {@link #mNoteOpCallerStacktraces}\n     */\n    private void writeNoteOps() {\n        synchronized (this) {\n            mWriteNoteOpsScheduled = false;\n        }\n        synchronized (mNoteOpCallerStacktracesFile) {\n            try (FileWriter writer = new FileWriter(mNoteOpCallerStacktracesFile)) {\n                int numTraces = mNoteOpCallerStacktraces.size();\n                for (int i = 0; i < numTraces; i++) {\n                    // Writing json formatted string into file\n                    writer.write(mNoteOpCallerStacktraces.valueAt(i).asJson());\n                    // Comma separation, so we can wrap the entire log as a JSON object\n                    // when all results are collected\n                    writer.write(\",\");\n                }\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to load opsValidation file for FileWriter\", e);\n            }\n        }\n    }\n\n    /**\n     * This class represents a NoteOp Trace object amd contains the necessary fields that will\n     * be written to file to use for permissions data validation in JSON format\n     */\n    @Immutable\n    static class NoteOpTrace {\n        static final String STACKTRACE = \"stackTrace\";\n        static final String OP = \"op\";\n        static final String PACKAGENAME = \"packageName\";\n        static final String VERSION = \"version\";\n\n        private final @NonNull String mStackTrace;\n        private final int mOp;\n        private final @Nullable String mPackageName;\n        private final long mVersion;\n\n        /**\n         * Initialize a NoteOp object using a JSON object containing the necessary fields\n         *\n         * @param jsonTrace JSON object represented as a string\n         *\n         * @return NoteOpTrace object initialized with JSON fields\n         */\n        static NoteOpTrace fromJson(String jsonTrace) {\n            try {\n                // Re-add closing bracket which acted as a delimiter by the reader\n                JSONObject obj = new JSONObject(jsonTrace.concat(\"}\"));\n                return new NoteOpTrace(obj.getString(STACKTRACE), obj.getInt(OP),\n                        obj.getString(PACKAGENAME), obj.getLong(VERSION));\n            } catch (JSONException e) {\n                // Swallow error, only meant for logging ops, should not affect flow of the code\n                Slog.e(TAG, \"Error constructing NoteOpTrace object \"\n                        + \"JSON trace format incorrect\", e);\n                return null;\n            }\n        }\n\n        NoteOpTrace(String stackTrace, int op, String packageName, long version) {\n            mStackTrace = stackTrace;\n            mOp = op;\n            mPackageName = packageName;\n            mVersion = version;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            NoteOpTrace that = (NoteOpTrace) o;\n            return mOp == that.mOp\n                    && mVersion == that.mVersion\n                    && mStackTrace.equals(that.mStackTrace)\n                    && Objects.equals(mPackageName, that.mPackageName);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(mStackTrace, mOp, mPackageName, mVersion);\n        }\n\n        /**\n         * The object is formatted as a JSON object and returned as a String\n         *\n         * @return JSON formatted string\n         */\n        public String asJson() {\n            return  \"{\"\n                    + \"\\\"\" + STACKTRACE + \"\\\":\\\"\" + mStackTrace.replace(\"\\n\", \"\\\\n\")\n                    + '\\\"' + \",\\\"\" + OP + \"\\\":\" + mOp\n                    + \",\\\"\" + PACKAGENAME + \"\\\":\\\"\" + mPackageName + '\\\"'\n                    + \",\\\"\" + VERSION + \"\\\":\" + mVersion\n                    + '}';\n        }\n    }\n\n    /**\n     * Collects noteOps, noteProxyOps and startOps from AppOpsManager and writes it into a file\n     * which will be used for permissions data validation, the given parameters to this method\n     * will be logged in json format\n     *\n     * @param stackTrace stacktrace from the most recent call in AppOpsManager\n     * @param op op code\n     * @param packageName package making call\n     * @param version android version for this call\n     */\n    @Override\n    public void collectNoteOpCallsForValidation(String stackTrace, int op, String packageName,\n            long version) {\n        if (!AppOpsManager.NOTE_OP_COLLECTION_ENABLED) {\n            return;\n        }\n\n        Objects.requireNonNull(stackTrace);\n        Preconditions.checkArgument(op >= 0);\n        Preconditions.checkArgument(op < AppOpsManager._NUM_OP);\n        Objects.requireNonNull(version);\n\n        NoteOpTrace noteOpTrace = new NoteOpTrace(stackTrace, op, packageName, version);\n\n        boolean noteOpSetWasChanged;\n        synchronized (this) {\n            noteOpSetWasChanged = mNoteOpCallerStacktraces.add(noteOpTrace);\n            if (noteOpSetWasChanged && !mWriteNoteOpsScheduled) {\n                mWriteNoteOpsScheduled = true;\n                mHandler.postDelayed(PooledLambda.obtainRunnable((that) -> {\n                    AsyncTask.execute(() -> {\n                        that.writeNoteOps();\n                    });\n                }, this), 2500);\n            }\n        }\n    }\n\n    @Immutable\n    private final class CheckOpsDelegateDispatcher {\n        private final @Nullable CheckOpsDelegate mPolicy;\n        private final @Nullable CheckOpsDelegate mCheckOpsDelegate;\n\n        CheckOpsDelegateDispatcher(@Nullable CheckOpsDelegate policy,\n                @Nullable CheckOpsDelegate checkOpsDelegate) {\n            mPolicy = policy;\n            mCheckOpsDelegate = checkOpsDelegate;\n        }\n\n        public @NonNull CheckOpsDelegate getCheckOpsDelegate() {\n            return mCheckOpsDelegate;\n        }\n\n        public int checkOperation(int code, int uid, String packageName,\n                @Nullable String attributionTag, boolean raw) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.checkOperation(code, uid, packageName, attributionTag, raw,\n                            this::checkDelegateOperationImpl);\n                } else {\n                    return mPolicy.checkOperation(code, uid, packageName, attributionTag, raw,\n                            AppOpsService.this::checkOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return checkDelegateOperationImpl(code, uid, packageName, attributionTag, raw);\n            }\n            return checkOperationImpl(code, uid, packageName, attributionTag, raw);\n        }\n\n        private int checkDelegateOperationImpl(int code, int uid, String packageName,\n                @Nullable String attributionTag, boolean raw) {\n            return mCheckOpsDelegate.checkOperation(code, uid, packageName, attributionTag, raw,\n                    AppOpsService.this::checkOperationImpl);\n        }\n\n        public int checkAudioOperation(int code, int usage, int uid, String packageName) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.checkAudioOperation(code, usage, uid, packageName,\n                            this::checkDelegateAudioOperationImpl);\n                } else {\n                    return mPolicy.checkAudioOperation(code, usage, uid, packageName,\n                            AppOpsService.this::checkAudioOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return checkDelegateAudioOperationImpl(code, usage, uid, packageName);\n            }\n            return checkAudioOperationImpl(code, usage, uid, packageName);\n        }\n\n        private int checkDelegateAudioOperationImpl(int code, int usage, int uid,\n                String packageName) {\n            return mCheckOpsDelegate.checkAudioOperation(code, usage, uid, packageName,\n                    AppOpsService.this::checkAudioOperationImpl);\n        }\n\n        public SyncNotedAppOp noteOperation(int code, int uid, String packageName,\n                String attributionTag, boolean shouldCollectAsyncNotedOp, String message,\n                boolean shouldCollectMessage) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.noteOperation(code, uid, packageName, attributionTag,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            this::noteDelegateOperationImpl);\n                } else {\n                    return mPolicy.noteOperation(code, uid, packageName, attributionTag,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            AppOpsService.this::noteOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return noteDelegateOperationImpl(code, uid, packageName,\n                        attributionTag, shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n            }\n            return noteOperationImpl(code, uid, packageName, attributionTag,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n        }\n\n        private SyncNotedAppOp noteDelegateOperationImpl(int code, int uid,\n                @Nullable String packageName, @Nullable String featureId,\n                boolean shouldCollectAsyncNotedOp, @Nullable String message,\n                boolean shouldCollectMessage) {\n            return mCheckOpsDelegate.noteOperation(code, uid, packageName, featureId,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    AppOpsService.this::noteOperationImpl);\n        }\n\n        public SyncNotedAppOp noteProxyOperation(int code, AttributionSource attributionSource,\n                boolean shouldCollectAsyncNotedOp, @Nullable String message,\n                boolean shouldCollectMessage, boolean skipProxyOperation) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.noteProxyOperation(code, attributionSource,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            skipProxyOperation, this::noteDelegateProxyOperationImpl);\n                } else {\n                    return mPolicy.noteProxyOperation(code, attributionSource,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            skipProxyOperation, AppOpsService.this::noteProxyOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return noteDelegateProxyOperationImpl(code,\n                        attributionSource, shouldCollectAsyncNotedOp, message,\n                        shouldCollectMessage, skipProxyOperation);\n            }\n            return noteProxyOperationImpl(code, attributionSource, shouldCollectAsyncNotedOp,\n                    message, shouldCollectMessage,skipProxyOperation);\n        }\n\n        private SyncNotedAppOp noteDelegateProxyOperationImpl(int code,\n                @NonNull AttributionSource attributionSource, boolean shouldCollectAsyncNotedOp,\n                @Nullable String message, boolean shouldCollectMessage,\n                boolean skipProxyOperation) {\n            return mCheckOpsDelegate.noteProxyOperation(code, attributionSource,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n                    AppOpsService.this::noteProxyOperationImpl);\n        }\n\n        public SyncNotedAppOp startOperation(IBinder token, int code, int uid,\n                @Nullable String packageName, @NonNull String attributionTag,\n                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp,\n                @Nullable String message, boolean shouldCollectMessage,\n                @AttributionFlags int attributionFlags, int attributionChainId) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.startOperation(token, code, uid, packageName,\n                            attributionTag, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                            shouldCollectMessage, attributionFlags, attributionChainId,\n                            this::startDelegateOperationImpl);\n                } else {\n                    return mPolicy.startOperation(token, code, uid, packageName, attributionTag,\n                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                            shouldCollectMessage, attributionFlags, attributionChainId,\n                            AppOpsService.this::startOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return startDelegateOperationImpl(token, code, uid, packageName, attributionTag,\n                        startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                        shouldCollectMessage, attributionFlags, attributionChainId);\n            }\n            return startOperationImpl(token, code, uid, packageName, attributionTag,\n                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    attributionFlags, attributionChainId);\n        }\n\n        private SyncNotedAppOp startDelegateOperationImpl(IBinder token, int code, int uid,\n                @Nullable String packageName, @Nullable String attributionTag,\n                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n                boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n                int attributionChainId) {\n            return mCheckOpsDelegate.startOperation(token, code, uid, packageName, attributionTag,\n                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    attributionFlags, attributionChainId, AppOpsService.this::startOperationImpl);\n        }\n\n        public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                            shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                            proxiedAttributionFlags, attributionChainId,\n                            this::startDelegateProxyOperationImpl);\n                } else {\n                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                            shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                            proxiedAttributionFlags, attributionChainId,\n                            AppOpsService.this::startProxyOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return startDelegateProxyOperationImpl(clientId, code, attributionSource,\n                        startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                        shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                        proxiedAttributionFlags, attributionChainId);\n            }\n            return startProxyOperationImpl(clientId, code, attributionSource, startIfModeDefault,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n                    proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n        }\n\n        private SyncNotedAppOp startDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                @AttributionFlags int proxiedAttributionFlsgs, int attributionChainId) {\n            return mCheckOpsDelegate.startProxyOperation(clientId, code, attributionSource,\n                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlsgs,\n                    attributionChainId, AppOpsService.this::startProxyOperationImpl);\n        }\n\n        public void finishOperation(IBinder clientId, int code, int uid, String packageName,\n                String attributionTag) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    mPolicy.finishOperation(clientId, code, uid, packageName, attributionTag,\n                            this::finishDelegateOperationImpl);\n                } else {\n                    mPolicy.finishOperation(clientId, code, uid, packageName, attributionTag,\n                            AppOpsService.this::finishOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                finishDelegateOperationImpl(clientId, code, uid, packageName, attributionTag);\n            } else {\n                finishOperationImpl(clientId, code, uid, packageName, attributionTag);\n            }\n        }\n\n        private void finishDelegateOperationImpl(IBinder clientId, int code, int uid,\n                String packageName, String attributionTag) {\n            mCheckOpsDelegate.finishOperation(clientId, code, uid, packageName, attributionTag,\n                    AppOpsService.this::finishOperationImpl);\n        }\n\n        public void finishProxyOperation(@NonNull IBinder clientId, int code,\n                @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n                            skipProxyOperation, this::finishDelegateProxyOperationImpl);\n                } else {\n                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n                            skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                finishDelegateProxyOperationImpl(clientId, code, attributionSource,\n                        skipProxyOperation);\n            } else {\n                finishProxyOperationImpl(clientId, code, attributionSource, skipProxyOperation);\n            }\n        }\n\n        private Void finishDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n                @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n            mCheckOpsDelegate.finishProxyOperation(clientId, code, attributionSource,\n                    skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n            return null;\n        }\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 66078,
                                        "general": {
                                            "word_based": 25197,
                                            "char_based": 86697
                                        },
                                        "gemini": 77419
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "e31c33ea3586531ca99dd4c6d68a34ce07c1cebb",
                            "repo_path": "android_repos/base",
                            "result": "failure",
                            "downstream_patch_content": "commit e31c33ea3586531ca99dd4c6d68a34ce07c1cebb\nAuthor: Hao Ke <haok@google.com>\nDate:   Mon Apr 22 15:13:58 2024 +0000\n\n    Fix READ/WRITE operation access issues on Restricted appOps.\n    \n    Problems were identified around read and write access to the restricted appOps, this change includes:\n    \n    - Filter out restricted appOps status for unprivileged readers.\n    - Allow additional privileged appOps permission holder reading restricted appOps status.\n    \n    Bug: 336273802\n    Bug: 336323279\n    Test: Local test see b/336273802#comment3\n    Test: atest AppOpsTest#testRestrictedSettingsOpsRead\n    Change-Id: I09008b365e36b2c20c9a1fe5a1d52699ddb17d35\n    Merged-In: I09008b365e36b2c20c9a1fe5a1d52699ddb17d35\n\ndiff --git a/core/java/android/app/AppOpInfo.java b/core/java/android/app/AppOpInfo.java\nindex 5268ec42e21c..a0f0ccaec58c 100644\n--- a/core/java/android/app/AppOpInfo.java\n+++ b/core/java/android/app/AppOpInfo.java\n@@ -88,7 +88,7 @@ class AppOpInfo {\n \n     /**\n      * This specifies whether each option is only allowed to be read\n-     * by apps with manage appops permission.\n+     * by apps with privileged appops permission.\n      */\n     public final boolean restrictRead;\n \ndiff --git a/core/java/android/app/AppOpsManager.java b/core/java/android/app/AppOpsManager.java\nindex ccd83f756730..2ec54535cdb9 100644\n--- a/core/java/android/app/AppOpsManager.java\n+++ b/core/java/android/app/AppOpsManager.java\n@@ -2985,7 +2985,7 @@ public class AppOpsManager {\n     }\n \n     /**\n-     * Retrieve whether the op can be read by apps with manage appops permission.\n+     * Retrieve whether the op can be read by apps with privileged appops permission.\n      * @hide\n      */\n     public static boolean opRestrictsRead(int op) {\ndiff --git a/services/core/java/com/android/server/appop/AppOpsService.java b/services/core/java/com/android/server/appop/AppOpsService.java\nindex 33655f748230..e2388e2918ab 100644\n--- a/services/core/java/com/android/server/appop/AppOpsService.java\n+++ b/services/core/java/com/android/server/appop/AppOpsService.java\n@@ -1430,16 +1430,26 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n     private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops) {\n         ArrayList<AppOpsManager.OpEntry> resOps = null;\n+        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n+                Manifest.permission.GET_APP_OPS_STATS,\n+                Binder.getCallingPid(), Binder.getCallingUid())\n+                == PackageManager.PERMISSION_GRANTED;\n         if (ops == null) {\n             resOps = new ArrayList<>();\n-            for (int j=0; j<pkgOps.size(); j++) {\n+            for (int j = 0; j < pkgOps.size(); j++) {\n                 Op curOp = pkgOps.valueAt(j);\n+                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                    continue;\n+                }\n                 resOps.add(getOpEntryForResult(curOp));\n             }\n         } else {\n-            for (int j=0; j<ops.length; j++) {\n+            for (int j = 0; j < ops.length; j++) {\n                 Op curOp = pkgOps.get(ops[j]);\n                 if (curOp != null) {\n+                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                        continue;\n+                    }\n                     if (resOps == null) {\n                         resOps = new ArrayList<>();\n                     }\n@@ -3615,10 +3625,21 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n     private void verifyIncomingOp(int op) {\n         if (op >= 0 && op < AppOpsManager._NUM_OP) {\n-            // Enforce manage appops permission if it's a restricted read op.\n+            // Enforce privileged appops permission if it's a restricted read op.\n             if (opRestrictsRead(op)) {\n-                mContext.enforcePermission(Manifest.permission.MANAGE_APPOPS,\n-                        Binder.getCallingPid(), Binder.getCallingUid(), \"verifyIncomingOp\");\n+                if (!(mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n+                        Manifest.permission.GET_APP_OPS_STATS,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n+                        Manifest.permission.MANAGE_APP_OPS_MODES,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED)) {\n+                    throw new SecurityException(\"verifyIncomingOp: uid \" + Binder.getCallingUid()\n+                            + \" does not have any of {MANAGE_APPOPS, GET_APP_OPS_STATS, \"\n+                            + \"MANAGE_APP_OPS_MODES}\");\n+                }\n             }\n             return;\n         }\n",
                            "downstream_patch_tokens": {
                                "openai": 1193,
                                "general": {
                                    "word_based": 485,
                                    "char_based": 1247
                                },
                                "gemini": 1534
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
                                    "total_hunks": 2,
                                    "failed_hunks": [
                                        1
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n                if (!(mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n                        Manifest.permission.GET_APP_OPS_STATS,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n                        Manifest.permission.MANAGE_APP_OPS_MODES,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED)) {\n                    throw new SecurityException(\"verifyIncomingOp: uid \" + Binder.getCallingUid()\n                            + \" does not have any of {MANAGE_APPOPS, GET_APP_OPS_STATS, \"\n                            + \"MANAGE_APP_OPS_MODES}\");\n                }\n            }\n            return;\n        }\n>>>>>>> UPSTREAM PATCH (commit 955e78071ec49139583056e21f612edba6439436)",
                                            "merge_conflict_tokens": {
                                                "openai": 193,
                                                "general": {
                                                    "word_based": 57,
                                                    "char_based": 272
                                                },
                                                "gemini": 258
                                            }
                                        }
                                    ],
                                    "inline_merge_token_summary": {
                                        "gemini": 4386,
                                        "openai": 3474,
                                        "general_word": 1026,
                                        "general_char": 4896
                                    },
                                    "rej_file_content": "```diff\n--- services/core/java/com/android/server/appop/AppOpsService.java\n+++ services/core/java/com/android/server/appop/AppOpsService.java\n@@ -1563,19 +1563,29 @@ public class AppOpsService extends IAppOpsService.Stub {\n     private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops,\n             String persistentDeviceId) {\n         ArrayList<AppOpsManager.OpEntry> resOps = null;\n+        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n+                Manifest.permission.GET_APP_OPS_STATS,\n+                Binder.getCallingPid(), Binder.getCallingUid())\n+                == PackageManager.PERMISSION_GRANTED;\n         if (ops == null) {\n             resOps = new ArrayList<>();\n-            for (int j=0; j<pkgOps.size(); j++) {\n+            for (int j = 0; j < pkgOps.size(); j++) {\n                 Op curOp = pkgOps.valueAt(j);\n+                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                    continue;\n+                }\n                 resOps.add(getOpEntryForResult(curOp, persistentDeviceId));\n             }\n         } else {\n-            for (int j=0; j<ops.length; j++) {\n+            for (int j = 0; j < ops.length; j++) {\n                 Op curOp = pkgOps.get(ops[j]);\n                 if (curOp != null) {\n                     if (resOps == null) {\n                         resOps = new ArrayList<>();\n                     }\n+                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                        continue;\n+                    }\n                     resOps.add(getOpEntryForResult(curOp, persistentDeviceId));\n                 }\n             }\n```",
                                    "rej_file_tokens": {
                                        "openai": 368,
                                        "general": {
                                            "word_based": 138,
                                            "char_based": 418
                                        },
                                        "gemini": 450
                                    },
                                    "patch_apply_output": "patching file services/core/java/com/android/server/appop/AppOpsService.java\nHunk #1 FAILED at 1563.\nHunk #2 succeeded at 3615 (offset -627 lines).\n1 out of 2 hunks FAILED -- saving rejects to file services/core/java/com/android/server/appop/AppOpsService.java.rej",
                                    "inline_merge_output": "patching file services/core/java/com/android/server/appop/AppOpsService.java\nHunk #1 already applied at 1566-1569,1572,1574-1576,1580, merged at 1589-1591.\nHunk #2 already applied at 4258, NOT MERGED at 4260-4278.",
                                    "upstream_file_tokens": {
                                        "openai": 63381,
                                        "general": {
                                            "word_based": 23827,
                                            "char_based": 83324
                                        },
                                        "gemini": 74277
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.appop;\n\nimport static android.app.AppOpsManager.ATTRIBUTION_CHAIN_ID_NONE;\nimport static android.app.AppOpsManager.ATTRIBUTION_FLAG_TRUSTED;\nimport static android.app.AppOpsManager.CALL_BACK_ON_SWITCHED_OP;\nimport static android.app.AppOpsManager.FILTER_BY_ATTRIBUTION_TAG;\nimport static android.app.AppOpsManager.FILTER_BY_OP_NAMES;\nimport static android.app.AppOpsManager.FILTER_BY_PACKAGE_NAME;\nimport static android.app.AppOpsManager.FILTER_BY_UID;\nimport static android.app.AppOpsManager.HISTORY_FLAG_GET_ATTRIBUTION_CHAINS;\nimport static android.app.AppOpsManager.HistoricalOpsRequestFilter;\nimport static android.app.AppOpsManager.KEY_BG_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.KEY_FG_SERVICE_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.KEY_TOP_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.MODE_ALLOWED;\nimport static android.app.AppOpsManager.MODE_DEFAULT;\nimport static android.app.AppOpsManager.MODE_ERRORED;\nimport static android.app.AppOpsManager.MODE_FOREGROUND;\nimport static android.app.AppOpsManager.MODE_IGNORED;\nimport static android.app.AppOpsManager.OP_CAMERA;\nimport static android.app.AppOpsManager.OP_CAMERA_SANDBOXED;\nimport static android.app.AppOpsManager.OP_FLAGS_ALL;\nimport static android.app.AppOpsManager.OP_FLAG_SELF;\nimport static android.app.AppOpsManager.OP_FLAG_TRUSTED_PROXIED;\nimport static android.app.AppOpsManager.OP_NONE;\nimport static android.app.AppOpsManager.OP_PLAY_AUDIO;\nimport static android.app.AppOpsManager.OP_RECEIVE_AMBIENT_TRIGGER_AUDIO;\nimport static android.app.AppOpsManager.OP_RECORD_AUDIO;\nimport static android.app.AppOpsManager.OP_RECORD_AUDIO_HOTWORD;\nimport static android.app.AppOpsManager.OP_RECORD_AUDIO_SANDBOXED;\nimport static android.app.AppOpsManager.OP_VIBRATE;\nimport static android.app.AppOpsManager.OnOpStartedListener.START_TYPE_FAILED;\nimport static android.app.AppOpsManager.OnOpStartedListener.START_TYPE_STARTED;\nimport static android.app.AppOpsManager.OpEventProxyInfo;\nimport static android.app.AppOpsManager.RestrictionBypass;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_BOOT_TIME_SAMPLING;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_RARELY_USED;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_UNIFORM;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_UNIFORM_OPS;\nimport static android.app.AppOpsManager.SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE;\nimport static android.app.AppOpsManager._NUM_OP;\nimport static android.app.AppOpsManager.extractFlagsFromKey;\nimport static android.app.AppOpsManager.extractUidStateFromKey;\nimport static android.app.AppOpsManager.modeToName;\nimport static android.app.AppOpsManager.opAllowSystemBypassRestriction;\nimport static android.app.AppOpsManager.opRestrictsRead;\nimport static android.app.AppOpsManager.opToName;\nimport static android.app.AppOpsManager.opToPublicName;\nimport static android.content.pm.PermissionInfo.PROTECTION_DANGEROUS;\nimport static android.content.pm.PermissionInfo.PROTECTION_FLAG_APPOP;\n\nimport static com.android.server.appop.AppOpsService.ModeCallback.ALL_OPS;\n\nimport android.Manifest;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.UserIdInt;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.AppOpsManager.AttributedOpEntry;\nimport android.app.AppOpsManager.AttributionFlags;\nimport android.app.AppOpsManager.HistoricalOps;\nimport android.app.AppOpsManager.Mode;\nimport android.app.AppOpsManager.OpEntry;\nimport android.app.AppOpsManager.OpFlags;\nimport android.app.AppOpsManagerInternal;\nimport android.app.AppOpsManagerInternal.CheckOpsDelegate;\nimport android.app.AsyncNotedAppOp;\nimport android.app.RuntimeAppOpAccessMessage;\nimport android.app.SyncNotedAppOp;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.content.AttributionSource;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.PermissionInfo;\nimport android.content.pm.UserInfo;\nimport android.database.ContentObserver;\nimport android.hardware.camera2.CameraDevice.CAMERA_AUDIO_RESTRICTION;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.HandlerExecutor;\nimport android.os.IBinder;\nimport android.os.PackageTagsList;\nimport android.os.Process;\nimport android.os.RemoteCallback;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.ServiceManager;\nimport android.os.ShellCallback;\nimport android.os.ShellCommand;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.os.storage.StorageManagerInternal;\nimport android.permission.PermissionManager;\nimport android.provider.Settings;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.KeyValueListParser;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\nimport android.util.SparseIntArray;\nimport android.util.TimeUtils;\nimport android.util.Xml;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.Immutable;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.app.IAppOpsActiveCallback;\nimport com.android.internal.app.IAppOpsAsyncNotedCallback;\nimport com.android.internal.app.IAppOpsCallback;\nimport com.android.internal.app.IAppOpsNotedCallback;\nimport com.android.internal.app.IAppOpsService;\nimport com.android.internal.app.IAppOpsStartedCallback;\nimport com.android.internal.app.MessageSamplingConfig;\nimport com.android.internal.compat.IPlatformCompat;\nimport com.android.internal.os.Clock;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.Preconditions;\nimport com.android.internal.util.XmlUtils;\nimport com.android.internal.util.function.pooled.PooledLambda;\nimport com.android.modules.utils.TypedXmlPullParser;\nimport com.android.modules.utils.TypedXmlSerializer;\nimport com.android.server.LocalManagerRegistry;\nimport com.android.server.LocalServices;\nimport com.android.server.LockGuard;\nimport com.android.server.SystemServerInitThreadPool;\nimport com.android.server.SystemServiceManager;\nimport com.android.server.pm.PackageList;\nimport com.android.server.pm.PackageManagerLocal;\nimport com.android.server.pm.UserManagerInternal;\nimport com.android.server.pm.pkg.AndroidPackage;\nimport com.android.server.pm.pkg.PackageState;\nimport com.android.server.pm.pkg.component.ParsedAttribution;\nimport com.android.server.policy.AppOpsPolicy;\n\nimport dalvik.annotation.optimization.NeverCompile;\n\nimport libcore.util.EmptyArray;\n\nimport org.json.JSONException;\nimport org.json.JSONObject;\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.text.SimpleDateFormat;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Consumer;\n\npublic class AppOpsService extends IAppOpsService.Stub {\n    static final String TAG = \"AppOps\";\n    static final boolean DEBUG = false;\n\n    /**\n     * Used for data access validation collection, we wish to only log a specific access once\n     */\n    private final ArraySet<NoteOpTrace> mNoteOpCallerStacktraces = new ArraySet<>();\n\n    /**\n     * Version of the mRecentAccessesFile.\n     * Increment by one every time an upgrade step is added at boot, none currently exists.\n     */\n    private static final int CURRENT_VERSION = 1;\n\n    // Write at most every 30 minutes.\n    static final long WRITE_DELAY = DEBUG ? 1000 : 30*60*1000;\n\n    // Constant meaning that any UID should be matched when dispatching callbacks\n    private static final int UID_ANY = -2;\n\n    private static final int[] OPS_RESTRICTED_ON_SUSPEND = {\n            OP_PLAY_AUDIO,\n            OP_RECORD_AUDIO,\n            OP_CAMERA,\n            OP_VIBRATE,\n    };\n\n    private static final int MAX_UNFORWARDED_OPS = 10;\n    private static final int MAX_UNUSED_POOLED_OBJECTS = 3;\n    private static final int RARELY_USED_PACKAGES_INITIALIZATION_DELAY_MILLIS = 300000;\n\n    final Context mContext;\n    final AtomicFile mStorageFile;\n    final AtomicFile mRecentAccessesFile;\n    private final @Nullable File mNoteOpCallerStacktracesFile;\n    final Handler mHandler;\n\n    /**\n     * Pool for {@link AttributedOp.OpEventProxyInfoPool} to avoid to constantly reallocate new\n     * objects\n     */\n    @GuardedBy(\"this\")\n    final AttributedOp.OpEventProxyInfoPool mOpEventProxyInfoPool =\n            new AttributedOp.OpEventProxyInfoPool(MAX_UNUSED_POOLED_OBJECTS);\n\n    /**\n     * Pool for {@link AttributedOp.InProgressStartOpEventPool} to avoid to constantly reallocate\n     * new objects\n     */\n    @GuardedBy(\"this\")\n    final AttributedOp.InProgressStartOpEventPool mInProgressStartOpEventPool =\n            new AttributedOp.InProgressStartOpEventPool(mOpEventProxyInfoPool,\n                    MAX_UNUSED_POOLED_OBJECTS);\n\n    private final AppOpsManagerInternalImpl mAppOpsManagerInternal\n            = new AppOpsManagerInternalImpl();\n    @Nullable private final DevicePolicyManagerInternal dpmi =\n            LocalServices.getService(DevicePolicyManagerInternal.class);\n\n    private final IPlatformCompat mPlatformCompat = IPlatformCompat.Stub.asInterface(\n            ServiceManager.getService(Context.PLATFORM_COMPAT_SERVICE));\n\n    /**\n     * Registered callbacks, called from {@link #collectAsyncNotedOp}.\n     *\n     * <p>(package name, uid) -> callbacks\n     *\n     * @see #getAsyncNotedOpsKey(String, int)\n     */\n    @GuardedBy(\"this\")\n    private final ArrayMap<Pair<String, Integer>, RemoteCallbackList<IAppOpsAsyncNotedCallback>>\n            mAsyncOpWatchers = new ArrayMap<>();\n\n    /**\n     * Async note-ops collected from {@link #collectAsyncNotedOp} that have not been delivered to a\n     * callback yet.\n     *\n     * <p>(package name, uid) -> list&lt;ops&gt;\n     *\n     * @see #getAsyncNotedOpsKey(String, int)\n     */\n    @GuardedBy(\"this\")\n    private final ArrayMap<Pair<String, Integer>, ArrayList<AsyncNotedAppOp>>\n            mUnforwardedAsyncNotedOps = new ArrayMap<>();\n\n    boolean mWriteNoteOpsScheduled;\n\n    boolean mWriteScheduled;\n    boolean mFastWriteScheduled;\n    final Runnable mWriteRunner = new Runnable() {\n        public void run() {\n            synchronized (AppOpsService.this) {\n                mWriteScheduled = false;\n                mFastWriteScheduled = false;\n                AsyncTask<Void, Void, Void> task = new AsyncTask<Void, Void, Void>() {\n                    @Override protected Void doInBackground(Void... params) {\n                        writeRecentAccesses();\n                        return null;\n                    }\n                };\n                task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void[])null);\n            }\n        }\n    };\n\n    @GuardedBy(\"this\")\n    @VisibleForTesting\n    final SparseArray<UidState> mUidStates = new SparseArray<>();\n\n    volatile @NonNull HistoricalRegistry mHistoricalRegistry = new HistoricalRegistry(this);\n\n    /*\n     * These are app op restrictions imposed per user from various parties.\n     */\n    private final ArrayMap<IBinder, ClientUserRestrictionState> mOpUserRestrictions =\n            new ArrayMap<>();\n\n    /*\n     * These are app op restrictions imposed globally from various parties within the system.\n     */\n    private final ArrayMap<IBinder, ClientGlobalRestrictionState> mOpGlobalRestrictions =\n            new ArrayMap<>();\n\n    SparseIntArray mProfileOwners;\n\n    private volatile CheckOpsDelegateDispatcher mCheckOpsDelegateDispatcher =\n            new CheckOpsDelegateDispatcher(/*policy*/ null, /*delegate*/ null);\n\n    /**\n      * Reverse lookup for {@link AppOpsManager#opToSwitch(int)}. Initialized once and never\n      * changed\n      */\n    private final SparseArray<int[]> mSwitchedOps = new SparseArray<>();\n\n    private ActivityManagerInternal mActivityManagerInternal;\n\n    /** Package sampled for message collection in the current session */\n    @GuardedBy(\"this\")\n    private String mSampledPackage = null;\n\n    /** Appop sampled for message collection in the current session */\n    @GuardedBy(\"this\")\n    private int mSampledAppOpCode = OP_NONE;\n\n    /** Maximum distance for appop to be considered for message collection in the current session */\n    @GuardedBy(\"this\")\n    private int mAcceptableLeftDistance = 0;\n\n    /** Number of messages collected for sampled package and appop in the current session */\n    @GuardedBy(\"this\")\n    private float mMessagesCollectedCount;\n\n    /** List of rarely used packages priorities for message collection */\n    @GuardedBy(\"this\")\n    private ArraySet<String> mRarelyUsedPackages = new ArraySet<>();\n\n    /** Sampling strategy used for current session */\n    @GuardedBy(\"this\")\n    @AppOpsManager.SamplingStrategy\n    private int mSamplingStrategy;\n\n    /** Last runtime permission access message collected and ready for reporting */\n    @GuardedBy(\"this\")\n    private RuntimeAppOpAccessMessage mCollectedRuntimePermissionMessage;\n\n    /** Package Manager internal. Access via {@link #getPackageManagerInternal()} */\n    private @Nullable PackageManagerInternal mPackageManagerInternal;\n\n    /** Package Manager local. Access via {@link #getPackageManagerLocal()} */\n    private @Nullable PackageManagerLocal mPackageManagerLocal;\n\n    /** User Manager internal. Access via {@link #getUserManagerInternal()} */\n    private @Nullable UserManagerInternal mUserManagerInternal;\n\n    /** Interface for app-op modes.*/\n    @VisibleForTesting\n    AppOpsCheckingServiceInterface mAppOpsCheckingService;\n\n    /** Interface for app-op restrictions.*/\n    @VisibleForTesting AppOpsRestrictions mAppOpsRestrictions;\n\n    private AppOpsUidStateTracker mUidStateTracker;\n\n    /** Hands the definition of foreground and uid states */\n    @GuardedBy(\"this\")\n    public AppOpsUidStateTracker getUidStateTracker() {\n        if (mUidStateTracker == null) {\n            mUidStateTracker = new AppOpsUidStateTrackerImpl(\n                    LocalServices.getService(ActivityManagerInternal.class),\n                    mHandler,\n                    r -> {\n                        synchronized (AppOpsService.this) {\n                            r.run();\n                        }\n                    },\n                    Clock.SYSTEM_CLOCK, mConstants);\n\n            mUidStateTracker.addUidStateChangedCallback(new HandlerExecutor(mHandler),\n                    this::onUidStateChanged);\n        }\n        return mUidStateTracker;\n    }\n\n    /**\n     * All times are in milliseconds. These constants are kept synchronized with the system\n     * global Settings. Any access to this class or its fields should be done while\n     * holding the AppOpsService lock.\n     */\n    final class Constants extends ContentObserver {\n\n        /**\n         * How long we want for a drop in uid state from top to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_TOP_STATE_SETTLE_TIME\n         */\n        public long TOP_STATE_SETTLE_TIME;\n\n        /**\n         * How long we want for a drop in uid state from foreground to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_FG_SERVICE_STATE_SETTLE_TIME\n         */\n        public long FG_SERVICE_STATE_SETTLE_TIME;\n\n        /**\n         * How long we want for a drop in uid state from background to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_BG_STATE_SETTLE_TIME\n         */\n        public long BG_STATE_SETTLE_TIME;\n\n        private final KeyValueListParser mParser = new KeyValueListParser(',');\n        private ContentResolver mResolver;\n\n        public Constants(Handler handler) {\n            super(handler);\n            updateConstants();\n        }\n\n        public void startMonitoring(ContentResolver resolver) {\n            mResolver = resolver;\n            mResolver.registerContentObserver(\n                    Settings.Global.getUriFor(Settings.Global.APP_OPS_CONSTANTS),\n                    false, this);\n            updateConstants();\n        }\n\n        @Override\n        public void onChange(boolean selfChange, Uri uri) {\n            updateConstants();\n        }\n\n        private void updateConstants() {\n            String value = mResolver != null ? Settings.Global.getString(mResolver,\n                    Settings.Global.APP_OPS_CONSTANTS) : \"\";\n\n            synchronized (AppOpsService.this) {\n                try {\n                    mParser.setString(value);\n                } catch (IllegalArgumentException e) {\n                    // Failed to parse the settings string, log this and move on\n                    // with defaults.\n                    Slog.e(TAG, \"Bad app ops settings\", e);\n                }\n                TOP_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_TOP_STATE_SETTLE_TIME, 5 * 1000L);\n                FG_SERVICE_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_FG_SERVICE_STATE_SETTLE_TIME, 5 * 1000L);\n                BG_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_BG_STATE_SETTLE_TIME, 1 * 1000L);\n            }\n        }\n\n        void dump(PrintWriter pw) {\n            pw.println(\"  Settings:\");\n\n            pw.print(\"    \"); pw.print(KEY_TOP_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(TOP_STATE_SETTLE_TIME, pw);\n            pw.println();\n            pw.print(\"    \"); pw.print(KEY_FG_SERVICE_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(FG_SERVICE_STATE_SETTLE_TIME, pw);\n            pw.println();\n            pw.print(\"    \"); pw.print(KEY_BG_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(BG_STATE_SETTLE_TIME, pw);\n            pw.println();\n        }\n    }\n\n    @VisibleForTesting\n    final Constants mConstants;\n\n    @VisibleForTesting\n    final class UidState {\n        public final int uid;\n\n        @NonNull\n        public final ArrayMap<String, Ops> pkgOps = new ArrayMap<>();\n\n        // true indicates there is an interested observer, false there isn't but it has such an op\n        //TODO: Move foregroundOps and hasForegroundWatchers into the AppOpsServiceInterface.\n        public SparseBooleanArray foregroundOps;\n        public boolean hasForegroundWatchers;\n\n        public UidState(int uid) {\n            this.uid = uid;\n        }\n\n        public void clear() {\n            mAppOpsCheckingService.removeUid(uid);\n            for (int i = 0; i < pkgOps.size(); i++) {\n                String packageName = pkgOps.keyAt(i);\n                mAppOpsCheckingService.removePackage(packageName, UserHandle.getUserId(uid));\n            }\n        }\n\n        // Functions for uid mode access and manipulation.\n        public SparseIntArray getNonDefaultUidModes() {\n            return mAppOpsCheckingService.getNonDefaultUidModes(uid);\n        }\n\n        public int getUidMode(int op) {\n            return mAppOpsCheckingService.getUidMode(uid, op);\n        }\n\n        public boolean setUidMode(int op, int mode) {\n            return mAppOpsCheckingService.setUidMode(uid, op, mode);\n        }\n\n        @SuppressWarnings(\"GuardedBy\")\n        int evalMode(int op, int mode) {\n            return getUidStateTracker().evalMode(uid, op, mode);\n        }\n\n        public void evalForegroundOps() {\n            foregroundOps = null;\n            foregroundOps = mAppOpsCheckingService.evalForegroundUidOps(uid, foregroundOps);\n            for (int i = pkgOps.size() - 1; i >= 0; i--) {\n                foregroundOps = mAppOpsCheckingService\n                        .evalForegroundPackageOps(pkgOps.valueAt(i).packageName, foregroundOps,\n                                UserHandle.getUserId(uid));\n            }\n            hasForegroundWatchers = false;\n            if (foregroundOps != null) {\n                for (int i = 0;  i < foregroundOps.size(); i++) {\n                    if (foregroundOps.valueAt(i)) {\n                        hasForegroundWatchers = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        @SuppressWarnings(\"GuardedBy\")\n        public int getState() {\n            return getUidStateTracker().getUidState(uid);\n        }\n\n        @SuppressWarnings(\"GuardedBy\")\n        public void dump(PrintWriter pw, long nowElapsed) {\n            getUidStateTracker().dumpUidState(pw, uid, nowElapsed);\n        }\n    }\n\n    final static class Ops extends SparseArray<Op> {\n        final String packageName;\n        final UidState uidState;\n\n        /**\n         * The restriction properties of the package. If {@code null} it could not have been read\n         * yet and has to be refreshed.\n         */\n        @Nullable RestrictionBypass bypass;\n\n        /** Lazily populated cache of attributionTags of this package */\n        final @NonNull ArraySet<String> knownAttributionTags = new ArraySet<>();\n\n        /**\n         * Lazily populated cache of <b>valid</b> attributionTags of this package, a set smaller\n         * than or equal to {@link #knownAttributionTags}.\n         */\n        final @NonNull ArraySet<String> validAttributionTags = new ArraySet<>();\n\n        Ops(String _packageName, UidState _uidState) {\n            packageName = _packageName;\n            uidState = _uidState;\n        }\n    }\n\n    /** Returned from {@link #verifyAndGetBypass(int, String, String, String, boolean)}. */\n    private static final class PackageVerificationResult {\n\n        final RestrictionBypass bypass;\n        final boolean isAttributionTagValid;\n\n        PackageVerificationResult(RestrictionBypass bypass, boolean isAttributionTagValid) {\n            this.bypass = bypass;\n            this.isAttributionTagValid = isAttributionTagValid;\n        }\n    }\n\n    final class Op {\n        int op;\n        int uid;\n        final UidState uidState;\n        final @NonNull String packageName;\n\n        /** attributionTag -> AttributedOp */\n        final ArrayMap<String, AttributedOp> mAttributions = new ArrayMap<>(1);\n\n        Op(UidState uidState, String packageName, int op, int uid) {\n            this.op = op;\n            this.uid = uid;\n            this.uidState = uidState;\n            this.packageName = packageName;\n        }\n\n        @Mode int getMode() {\n            return mAppOpsCheckingService.getPackageMode(packageName, this.op,\n                    UserHandle.getUserId(this.uid));\n        }\n        void setMode(@Mode int mode) {\n            mAppOpsCheckingService.setPackageMode(packageName, this.op, mode,\n                    UserHandle.getUserId(this.uid));\n        }\n\n        void removeAttributionsWithNoTime() {\n            for (int i = mAttributions.size() - 1; i >= 0; i--) {\n                if (!mAttributions.valueAt(i).hasAnyTime()) {\n                    mAttributions.removeAt(i);\n                }\n            }\n        }\n\n        private @NonNull AttributedOp getOrCreateAttribution(@NonNull Op parent,\n                @Nullable String attributionTag) {\n            AttributedOp attributedOp;\n\n            attributedOp = mAttributions.get(attributionTag);\n            if (attributedOp == null) {\n                attributedOp = new AttributedOp(AppOpsService.this, attributionTag, parent);\n                mAttributions.put(attributionTag, attributedOp);\n            }\n\n            return attributedOp;\n        }\n\n        @NonNull OpEntry createEntryLocked() {\n            final int numAttributions = mAttributions.size();\n\n            final ArrayMap<String, AppOpsManager.AttributedOpEntry> attributionEntries =\n                    new ArrayMap<>(numAttributions);\n            for (int i = 0; i < numAttributions; i++) {\n                attributionEntries.put(mAttributions.keyAt(i),\n                        mAttributions.valueAt(i).createAttributedOpEntryLocked());\n            }\n\n            return new OpEntry(op, getMode(), attributionEntries);\n        }\n\n        @NonNull OpEntry createSingleAttributionEntryLocked(@Nullable String attributionTag) {\n            final int numAttributions = mAttributions.size();\n\n            final ArrayMap<String, AttributedOpEntry> attributionEntries = new ArrayMap<>(1);\n            for (int i = 0; i < numAttributions; i++) {\n                if (Objects.equals(mAttributions.keyAt(i), attributionTag)) {\n                    attributionEntries.put(mAttributions.keyAt(i),\n                            mAttributions.valueAt(i).createAttributedOpEntryLocked());\n                    break;\n                }\n            }\n\n            return new OpEntry(op, getMode(), attributionEntries);\n        }\n\n        boolean isRunning() {\n            final int numAttributions = mAttributions.size();\n            for (int i = 0; i < numAttributions; i++) {\n                if (mAttributions.valueAt(i).isRunning()) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n\n    final ArrayMap<IBinder, ModeCallback> mModeWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<ActiveCallback>> mActiveWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<StartedCallback>> mStartedWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<NotedCallback>> mNotedWatchers = new ArrayMap<>();\n    final AudioRestrictionManager mAudioRestrictionManager = new AudioRestrictionManager();\n\n    final class ModeCallback extends OnOpModeChangedListener implements DeathRecipient  {\n        /** If mWatchedOpCode==ALL_OPS notify for ops affected by the switch-op */\n        public static final int ALL_OPS = -2;\n\n        // Need to keep this only because stopWatchingMode needs an IAppOpsCallback.\n        // Otherwise we can just use the IBinder object.\n        private final IAppOpsCallback mCallback;\n\n        ModeCallback(IAppOpsCallback callback, int watchingUid, int flags, int watchedOpCode,\n                int callingUid, int callingPid) {\n            super(watchingUid, flags, watchedOpCode, callingUid, callingPid);\n            this.mCallback = callback;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"ModeCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, getWatchingUid());\n            sb.append(\" flags=0x\");\n            sb.append(Integer.toHexString(getFlags()));\n            switch (getWatchedOpCode()) {\n                case OP_NONE:\n                    break;\n                case ALL_OPS:\n                    sb.append(\" op=(all)\");\n                    break;\n                default:\n                    sb.append(\" op=\");\n                    sb.append(opToName(getWatchedOpCode()));\n                    break;\n            }\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, getCallingUid());\n            sb.append(\" pid=\");\n            sb.append(getCallingPid());\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void unlinkToDeath() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingMode(mCallback);\n        }\n\n        @Override\n        public void onOpModeChanged(int op, int uid, String packageName) throws RemoteException {\n            mCallback.opChanged(op, uid, packageName);\n        }\n    }\n\n    final class ActiveCallback implements DeathRecipient {\n        final IAppOpsActiveCallback mCallback;\n        final int mWatchingUid;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        ActiveCallback(IAppOpsActiveCallback callback, int watchingUid, int callingUid,\n                int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"ActiveCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void destroy() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingActive(mCallback);\n        }\n    }\n\n    final class StartedCallback implements DeathRecipient {\n        final IAppOpsStartedCallback mCallback;\n        final int mWatchingUid;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        StartedCallback(IAppOpsStartedCallback callback, int watchingUid, int callingUid,\n                int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"StartedCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void destroy() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingStarted(mCallback);\n        }\n    }\n\n    final class NotedCallback implements DeathRecipient {\n        final IAppOpsNotedCallback mCallback;\n        final int mWatchingUid;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        NotedCallback(IAppOpsNotedCallback callback, int watchingUid, int callingUid,\n                int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"NotedCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void destroy() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingNoted(mCallback);\n        }\n    }\n\n    /**\n     * Call {@link AttributedOp#onClientDeath attributedOp.onClientDeath(clientId)}.\n     */\n    static void onClientDeath(@NonNull AttributedOp attributedOp,\n            @NonNull IBinder clientId) {\n        attributedOp.onClientDeath(clientId);\n    }\n\n\n    /**\n     * Loads the OpsValidation file results into a hashmap {@link #mNoteOpCallerStacktraces}\n     * so that we do not log the same operation twice between instances\n     */\n    private void readNoteOpCallerStackTraces() {\n        try {\n            if (!mNoteOpCallerStacktracesFile.exists()) {\n                mNoteOpCallerStacktracesFile.createNewFile();\n                return;\n            }\n\n            try (Scanner read = new Scanner(mNoteOpCallerStacktracesFile)) {\n                read.useDelimiter(\"\\\\},\");\n                while (read.hasNext()) {\n                    String jsonOps = read.next();\n                    mNoteOpCallerStacktraces.add(NoteOpTrace.fromJson(jsonOps));\n                }\n            }\n        } catch (Exception e) {\n            Slog.e(TAG, \"Cannot parse traces noteOps\", e);\n        }\n    }\n\n    @VisibleForTesting\n    public AppOpsService(File recentAccessesFile, File storageFile, Handler handler,\n            Context context) {\n        mContext = context;\n\n        for (int switchedCode = 0; switchedCode < _NUM_OP; switchedCode++) {\n            int switchCode = AppOpsManager.opToSwitch(switchedCode);\n            mSwitchedOps.put(switchCode,\n                    ArrayUtils.appendInt(mSwitchedOps.get(switchCode), switchedCode));\n        }\n        mAppOpsCheckingService = new AppOpsCheckingServiceTracingDecorator(\n                new AppOpsCheckingServiceImpl(\n                        storageFile, this, handler, context,  mSwitchedOps));\n        //mAppOpsCheckingService = new AppOpsCheckingServiceLoggingDecorator(\n        //        LocalServices.getService(AppOpsCheckingServiceInterface.class));\n        mAppOpsRestrictions = new AppOpsRestrictionsImpl(context, handler, mAppOpsCheckingService);\n\n        LockGuard.installLock(this, LockGuard.INDEX_APP_OPS);\n        mStorageFile = new AtomicFile(storageFile, \"appops_legacy\");\n        mRecentAccessesFile = new AtomicFile(recentAccessesFile, \"appops_accesses\");\n\n        if (AppOpsManager.NOTE_OP_COLLECTION_ENABLED) {\n            mNoteOpCallerStacktracesFile = new File(SystemServiceManager.ensureSystemDir(),\n                    \"noteOpStackTraces.json\");\n            readNoteOpCallerStackTraces();\n        } else {\n            mNoteOpCallerStacktracesFile = null;\n        }\n        mHandler = handler;\n        mConstants = new Constants(mHandler);\n        // To migrate storageFile to recentAccessesFile, these reads must be called in this order.\n        readRecentAccesses();\n        mAppOpsCheckingService.readState();\n    }\n\n    public void publish() {\n        ServiceManager.addService(Context.APP_OPS_SERVICE, asBinder());\n        LocalServices.addService(AppOpsManagerInternal.class, mAppOpsManagerInternal);\n        LocalManagerRegistry.addManager(AppOpsManagerLocal.class, new AppOpsManagerLocalImpl());\n    }\n\n    /** Handler for work when packages are updated */\n    private BroadcastReceiver mOnPackageUpdatedReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            String pkgName = intent.getData().getEncodedSchemeSpecificPart();\n            int uid = intent.getIntExtra(Intent.EXTRA_UID, Process.INVALID_UID);\n\n            if (action.equals(Intent.ACTION_PACKAGE_REPLACED)) {\n                AndroidPackage pkg = getPackageManagerInternal().getPackage(pkgName);\n                if (pkg == null) {\n                    return;\n                }\n\n                ArrayMap<String, String> dstAttributionTags = new ArrayMap<>();\n                ArraySet<String> attributionTags = new ArraySet<>();\n                attributionTags.add(null);\n                if (pkg.getAttributions() != null) {\n                    int numAttributions = pkg.getAttributions().size();\n                    for (int attributionNum = 0; attributionNum < numAttributions;\n                            attributionNum++) {\n                        ParsedAttribution attribution = pkg.getAttributions().get(attributionNum);\n                        attributionTags.add(attribution.getTag());\n\n                        int numInheritFrom = attribution.getInheritFrom().size();\n                        for (int inheritFromNum = 0; inheritFromNum < numInheritFrom;\n                                inheritFromNum++) {\n                            dstAttributionTags.put(attribution.getInheritFrom().get(inheritFromNum),\n                                    attribution.getTag());\n                        }\n                    }\n                }\n\n                synchronized (AppOpsService.this) {\n                    UidState uidState = mUidStates.get(uid);\n                    if (uidState == null) {\n                        return;\n                    }\n\n                    Ops ops = uidState.pkgOps.get(pkgName);\n                    if (ops == null) {\n                        return;\n                    }\n\n                    // Reset cached package properties to re-initialize when needed\n                    ops.bypass = null;\n                    ops.knownAttributionTags.clear();\n\n                    // Merge data collected for removed attributions into their successor\n                    // attributions\n                    int numOps = ops.size();\n                    for (int opNum = 0; opNum < numOps; opNum++) {\n                        Op op = ops.valueAt(opNum);\n\n                        int numAttributions = op.mAttributions.size();\n                        for (int attributionNum = numAttributions - 1; attributionNum >= 0;\n                                attributionNum--) {\n                            String attributionTag = op.mAttributions.keyAt(attributionNum);\n\n                            if (attributionTags.contains(attributionTag)) {\n                                // attribution still exist after upgrade\n                                continue;\n                            }\n\n                            String newAttributionTag = dstAttributionTags.get(attributionTag);\n\n                            AttributedOp newAttributedOp = op.getOrCreateAttribution(op,\n                                    newAttributionTag);\n                            newAttributedOp.add(op.mAttributions.valueAt(attributionNum));\n                            op.mAttributions.removeAt(attributionNum);\n\n                            scheduleFastWriteLocked();\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    public void systemReady() {\n        mAppOpsCheckingService.systemReady();\n        initializeUidStates();\n\n        mConstants.startMonitoring(mContext.getContentResolver());\n        mHistoricalRegistry.systemReady(mContext.getContentResolver());\n\n        IntentFilter packageUpdateFilter = new IntentFilter();\n        packageUpdateFilter.addAction(Intent.ACTION_PACKAGE_REPLACED);\n        packageUpdateFilter.addDataScheme(\"package\");\n\n        mContext.registerReceiverAsUser(mOnPackageUpdatedReceiver, UserHandle.ALL,\n                packageUpdateFilter, null, null);\n\n        synchronized (this) {\n            for (int uidNum = mUidStates.size() - 1; uidNum >= 0; uidNum--) {\n                int uid = mUidStates.keyAt(uidNum);\n                UidState uidState = mUidStates.valueAt(uidNum);\n\n                String[] pkgsInUid = getPackagesForUid(uidState.uid);\n                if (ArrayUtils.isEmpty(pkgsInUid)) {\n                    uidState.clear();\n                    mUidStates.removeAt(uidNum);\n                    scheduleFastWriteLocked();\n                    continue;\n                }\n\n                ArrayMap<String, Ops> pkgs = uidState.pkgOps;\n\n                int numPkgs = pkgs.size();\n                for (int pkgNum = 0; pkgNum < numPkgs; pkgNum++) {\n                    String pkg = pkgs.keyAt(pkgNum);\n\n                    String action;\n                    if (!ArrayUtils.contains(pkgsInUid, pkg)) {\n                        action = Intent.ACTION_PACKAGE_REMOVED;\n                    } else {\n                        action = Intent.ACTION_PACKAGE_REPLACED;\n                    }\n\n                    SystemServerInitThreadPool.submit(\n                            () -> mOnPackageUpdatedReceiver.onReceive(mContext, new Intent(action)\n                                    .setData(Uri.fromParts(\"package\", pkg, null))\n                                    .putExtra(Intent.EXTRA_UID, uid)),\n                            \"Update app-ops uidState in case package \" + pkg + \" changed\");\n                }\n            }\n        }\n\n        getUserManagerInternal().addUserLifecycleListener(\n                new UserManagerInternal.UserLifecycleListener() {\n                    @Override\n                    public void onUserCreated(UserInfo user, Object token) {\n                        initializeUserUidStates(user.id);\n                    }\n\n                    // onUserRemoved handled by #removeUser\n                });\n\n        getPackageManagerInternal().getPackageList(\n                new PackageManagerInternal.PackageListObserver() {\n                    @Override\n                    public void onPackageAdded(String packageName, int appId) {\n                        PackageInfo pi = getPackageManagerInternal().getPackageInfo(packageName,\n                                PackageManager.GET_PERMISSIONS, Process.myUid(),\n                                mContext.getUserId());\n                        boolean isSamplingTarget = isSamplingTarget(pi);\n                        int[] userIds = getUserManagerInternal().getUserIds();\n                        synchronized (AppOpsService.this) {\n                            if (isSamplingTarget) {\n                                mRarelyUsedPackages.add(packageName);\n                            }\n                            for (int i = 0; i < userIds.length; i++) {\n                                int uid = UserHandle.getUid(userIds[i], appId);\n                                UidState uidState = getUidStateLocked(uid, true);\n                                if (!uidState.pkgOps.containsKey(packageName)) {\n                                    uidState.pkgOps.put(packageName,\n                                            new Ops(packageName, uidState));\n                                }\n                            }\n                        }\n                    }\n\n                    @Override\n                    public void onPackageRemoved(String packageName, int appId) {\n                        int[] userIds = getUserManagerInternal().getUserIds();\n                        synchronized (AppOpsService.this) {\n                            for (int i = 0; i < userIds.length; i++) {\n                                int uid = UserHandle.getUid(userIds[i], appId);\n                                packageRemovedLocked(uid, packageName);\n                            }\n                        }\n                    }\n                });\n\n        final IntentFilter packageSuspendFilter = new IntentFilter();\n        packageSuspendFilter.addAction(Intent.ACTION_PACKAGES_UNSUSPENDED);\n        packageSuspendFilter.addAction(Intent.ACTION_PACKAGES_SUSPENDED);\n        mContext.registerReceiverAsUser(new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                final int[] changedUids = intent.getIntArrayExtra(Intent.EXTRA_CHANGED_UID_LIST);\n                final String[] changedPkgs = intent.getStringArrayExtra(\n                        Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                for (int code : OPS_RESTRICTED_ON_SUSPEND) {\n                    ArraySet<OnOpModeChangedListener> onModeChangedListeners;\n                    synchronized (AppOpsService.this) {\n                        onModeChangedListeners =\n                                mAppOpsCheckingService.getOpModeChangedListeners(code);\n                        if (onModeChangedListeners == null) {\n                            continue;\n                        }\n                    }\n                    for (int i = 0; i < changedUids.length; i++) {\n                        final int changedUid = changedUids[i];\n                        final String changedPkg = changedPkgs[i];\n                        // We trust packagemanager to insert matching uid and packageNames in the\n                        // extras\n                        notifyOpChanged(onModeChangedListeners, code, changedUid, changedPkg);\n                    }\n                }\n            }\n        }, UserHandle.ALL, packageSuspendFilter, null, null);\n\n        mHandler.postDelayed(new Runnable() {\n            @Override\n            public void run() {\n                List<String> packageNames = getPackageListAndResample();\n                initializeRarelyUsedPackagesList(new ArraySet<>(packageNames));\n            }\n        }, RARELY_USED_PACKAGES_INITIALIZATION_DELAY_MILLIS);\n\n        getPackageManagerInternal().setExternalSourcesPolicy(\n                new PackageManagerInternal.ExternalSourcesPolicy() {\n                    @Override\n                    public int getPackageTrustedToInstallApps(String packageName, int uid) {\n                        int appOpMode = checkOperation(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                                uid, packageName);\n                        switch (appOpMode) {\n                            case AppOpsManager.MODE_ALLOWED:\n                                return PackageManagerInternal.ExternalSourcesPolicy.USER_TRUSTED;\n                            case AppOpsManager.MODE_ERRORED:\n                                return PackageManagerInternal.ExternalSourcesPolicy.USER_BLOCKED;\n                            default:\n                                return PackageManagerInternal.ExternalSourcesPolicy.USER_DEFAULT;\n                        }\n                    }\n                });\n\n        mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);\n    }\n\n    /**\n     * Initialize uid state objects for state contained in the checking service.\n     */\n    @VisibleForTesting\n    void initializeUidStates() {\n        UserManagerInternal umi = getUserManagerInternal();\n        synchronized (this) {\n            int[] userIds = umi.getUserIds();\n            try (PackageManagerLocal.UnfilteredSnapshot snapshot =\n                         getPackageManagerLocal().withUnfilteredSnapshot()) {\n                Map<String, PackageState> packageStates = snapshot.getPackageStates();\n                for (int i = 0; i < userIds.length; i++) {\n                    int userId = userIds[i];\n                    initializeUserUidStatesLocked(userId, packageStates);\n                }\n            }\n        }\n    }\n\n    private void initializeUserUidStates(int userId) {\n        synchronized (this) {\n            try (PackageManagerLocal.UnfilteredSnapshot snapshot =\n                    getPackageManagerLocal().withUnfilteredSnapshot()) {\n                initializeUserUidStatesLocked(userId, snapshot.getPackageStates());\n            }\n        }\n    }\n\n    private void initializeUserUidStatesLocked(int userId, Map<String,\n            PackageState> packageStates) {\n        for (Map.Entry<String, PackageState> entry : packageStates.entrySet()) {\n            int appId = entry.getValue().getAppId();\n            String packageName = entry.getKey();\n\n            initializePackageUidStateLocked(userId, appId, packageName);\n        }\n    }\n\n    /*\n      Be careful not to clear any existing data; only want to add objects that don't already exist.\n     */\n    private void initializePackageUidStateLocked(int userId, int appId, String packageName) {\n        int uid = UserHandle.getUid(userId, appId);\n        UidState uidState = getUidStateLocked(uid, true);\n        Ops ops = uidState.pkgOps.get(packageName);\n        if (ops == null) {\n            ops = new Ops(packageName, uidState);\n            uidState.pkgOps.put(packageName, ops);\n        }\n\n        SparseIntArray packageModes =\n                mAppOpsCheckingService.getNonDefaultPackageModes(packageName, userId);\n        for (int k = 0; k < packageModes.size(); k++) {\n            int code = packageModes.keyAt(k);\n\n            if (ops.indexOfKey(code) < 0) {\n                ops.put(code, new Op(uidState, packageName, code, uid));\n            }\n        }\n\n        uidState.evalForegroundOps();\n    }\n\n    /**\n     * Sets a policy for handling app ops.\n     *\n     * @param policy The policy.\n     */\n    public void setAppOpsPolicy(@Nullable CheckOpsDelegate policy) {\n        final CheckOpsDelegateDispatcher oldDispatcher = mCheckOpsDelegateDispatcher;\n        final CheckOpsDelegate delegate = (oldDispatcher != null)\n                ? oldDispatcher.mCheckOpsDelegate : null;\n        mCheckOpsDelegateDispatcher = new CheckOpsDelegateDispatcher(policy, delegate);\n    }\n\n    @VisibleForTesting\n    void packageRemoved(int uid, String packageName) {\n        synchronized (this) {\n            packageRemovedLocked(uid, packageName);\n        }\n    }\n\n    @GuardedBy(\"this\")\n    private void packageRemovedLocked(int uid, String packageName) {\n        UidState uidState = mUidStates.get(uid);\n        if (uidState == null) {\n            return;\n        }\n\n        Ops removedOps = null;\n\n        // Remove any package state if such.\n        removedOps = uidState.pkgOps.remove(packageName);\n        mAppOpsCheckingService.removePackage(packageName, UserHandle.getUserId(uid));\n\n        if (removedOps != null) {\n            scheduleFastWriteLocked();\n\n            final int numOps = removedOps.size();\n            for (int opNum = 0; opNum < numOps; opNum++) {\n                final Op op = removedOps.valueAt(opNum);\n\n                final int numAttributions = op.mAttributions.size();\n                for (int attributionNum = 0; attributionNum < numAttributions;\n                        attributionNum++) {\n                    AttributedOp attributedOp = op.mAttributions.valueAt(attributionNum);\n\n                    while (attributedOp.isRunning()) {\n                        attributedOp.finished(attributedOp.mInProgressEvents.keyAt(0));\n                    }\n                    while (attributedOp.isPaused()) {\n                        attributedOp.finished(attributedOp.mPausedInProgressEvents.keyAt(0));\n                    }\n                }\n            }\n        }\n\n        mHandler.post(PooledLambda.obtainRunnable(HistoricalRegistry::clearHistory,\n                    mHistoricalRegistry, uid, packageName));\n    }\n\n    public void uidRemoved(int uid) {\n        synchronized (this) {\n            if (mUidStates.indexOfKey(uid) >= 0) {\n                mUidStates.get(uid).clear();\n                mUidStates.remove(uid);\n                scheduleFastWriteLocked();\n            }\n        }\n    }\n\n    // The callback method from AppOpsUidStateTracker\n    private void onUidStateChanged(int uid, int state, boolean foregroundModeMayChange) {\n        synchronized (this) {\n            UidState uidState = getUidStateLocked(uid, true);\n\n            if (uidState != null && foregroundModeMayChange && uidState.hasForegroundWatchers) {\n                for (int fgi = uidState.foregroundOps.size() - 1; fgi >= 0; fgi--) {\n                    if (!uidState.foregroundOps.valueAt(fgi)) {\n                        continue;\n                    }\n                    final int code = uidState.foregroundOps.keyAt(fgi);\n\n                    if (uidState.getUidMode(code) != AppOpsManager.opToDefaultMode(code)\n                            && uidState.getUidMode(code) == AppOpsManager.MODE_FOREGROUND) {\n                        mHandler.sendMessage(PooledLambda.obtainMessage(\n                                AppOpsService::notifyOpChangedForAllPkgsInUid,\n                                this, code, uidState.uid, true, null));\n                    } else if (!uidState.pkgOps.isEmpty()) {\n                        final ArraySet<OnOpModeChangedListener> listenerSet =\n                                mAppOpsCheckingService.getOpModeChangedListeners(code);\n                        if (listenerSet != null) {\n                            for (int cbi = listenerSet.size() - 1; cbi >= 0; cbi--) {\n                                final OnOpModeChangedListener listener = listenerSet.valueAt(cbi);\n                                if ((listener.getFlags()\n                                        & AppOpsManager.WATCH_FOREGROUND_CHANGES) == 0\n                                        || !listener.isWatchingUid(uidState.uid)) {\n                                    continue;\n                                }\n                                for (int pkgi = uidState.pkgOps.size() - 1; pkgi >= 0; pkgi--) {\n                                    final Op op = uidState.pkgOps.valueAt(pkgi).get(code);\n                                    if (op == null) {\n                                        continue;\n                                    }\n                                    if (op.getMode() == AppOpsManager.MODE_FOREGROUND) {\n                                        mHandler.sendMessage(PooledLambda.obtainMessage(\n                                                AppOpsService::notifyOpChanged,\n                                                this, listenerSet.valueAt(cbi), code, uidState.uid,\n                                                uidState.pkgOps.keyAt(pkgi)));\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (uidState != null) {\n                int numPkgs = uidState.pkgOps.size();\n                for (int pkgNum = 0; pkgNum < numPkgs; pkgNum++) {\n                    Ops ops = uidState.pkgOps.valueAt(pkgNum);\n\n                    int numOps = ops.size();\n                    for (int opNum = 0; opNum < numOps; opNum++) {\n                        Op op = ops.valueAt(opNum);\n\n                        int numAttributions = op.mAttributions.size();\n                        for (int attributionNum = 0; attributionNum < numAttributions;\n                                attributionNum++) {\n                            AttributedOp attributedOp = op.mAttributions.valueAt(\n                                    attributionNum);\n\n                            attributedOp.onUidStateChanged(state);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Notify the proc state or capability has changed for a certain UID.\n     */\n    public void updateUidProcState(int uid, int procState,\n            @ActivityManager.ProcessCapability int capability) {\n        synchronized (this) {\n            getUidStateTracker().updateUidProcState(uid, procState, capability);\n            if (!mUidStates.contains(uid)) {\n                UidState uidState = new UidState(uid);\n                mUidStates.put(uid, uidState);\n                onUidStateChanged(uid,\n                        AppOpsUidStateTracker.processStateToUidState(procState), false);\n            }\n        }\n    }\n\n    public void shutdown() {\n        Slog.w(TAG, \"Writing app ops before shutdown...\");\n        boolean doWrite = false;\n        synchronized (this) {\n            if (mWriteScheduled) {\n                mWriteScheduled = false;\n                mFastWriteScheduled = false;\n                mHandler.removeCallbacks(mWriteRunner);\n                doWrite = true;\n            }\n        }\n        if (doWrite) {\n            writeRecentAccesses();\n        }\n        mAppOpsCheckingService.shutdown();\n        if (AppOpsManager.NOTE_OP_COLLECTION_ENABLED && mWriteNoteOpsScheduled) {\n            writeNoteOps();\n        }\n        mHistoricalRegistry.shutdown();\n    }\n\n    private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops) {\n        ArrayList<AppOpsManager.OpEntry> resOps = null;\n        if (ops == null) {\n            resOps = new ArrayList<>();\n            for (int j=0; j<pkgOps.size(); j++) {\n                Op curOp = pkgOps.valueAt(j);\n                resOps.add(getOpEntryForResult(curOp));\n            }\n        } else {\n            for (int j=0; j<ops.length; j++) {\n                Op curOp = pkgOps.get(ops[j]);\n                if (curOp != null) {\n                    if (resOps == null) {\n                        resOps = new ArrayList<>();\n                    }\n                    resOps.add(getOpEntryForResult(curOp));\n                }\n            }\n        }\n        return resOps;\n    }\n\n    @Nullable\n    private ArrayList<AppOpsManager.OpEntry> collectUidOps(@NonNull UidState uidState,\n            @Nullable int[] ops) {\n        final SparseIntArray opModes = uidState.getNonDefaultUidModes();\n        if (opModes == null) {\n            return null;\n        }\n\n        int opModeCount = opModes.size();\n        if (opModeCount == 0) {\n            return null;\n        }\n        ArrayList<AppOpsManager.OpEntry> resOps = null;\n        if (ops == null) {\n            resOps = new ArrayList<>();\n            for (int i = 0; i < opModeCount; i++) {\n                int code = opModes.keyAt(i);\n                resOps.add(new OpEntry(code, opModes.get(code), Collections.emptyMap()));\n            }\n        } else {\n            for (int j=0; j<ops.length; j++) {\n                int code = ops[j];\n                if (opModes.indexOfKey(code) >= 0) {\n                    if (resOps == null) {\n                        resOps = new ArrayList<>();\n                    }\n                    resOps.add(new OpEntry(code, opModes.get(code), Collections.emptyMap()));\n                }\n            }\n        }\n        return resOps;\n    }\n\n    private static @NonNull OpEntry getOpEntryForResult(@NonNull Op op) {\n        return op.createEntryLocked();\n    }\n\n    @Override\n    public List<AppOpsManager.PackageOps> getPackagesForOps(int[] ops) {\n        final int callingUid = Binder.getCallingUid();\n        final boolean hasAllPackageAccess = mContext.checkPermission(\n                Manifest.permission.GET_APP_OPS_STATS, Binder.getCallingPid(),\n                Binder.getCallingUid(), null) == PackageManager.PERMISSION_GRANTED;\n        ArrayList<AppOpsManager.PackageOps> res = null;\n        synchronized (this) {\n            final int uidStateCount = mUidStates.size();\n            for (int i = 0; i < uidStateCount; i++) {\n                UidState uidState = mUidStates.valueAt(i);\n                if (uidState.pkgOps.isEmpty()) {\n                    continue;\n                }\n                ArrayMap<String, Ops> packages = uidState.pkgOps;\n                final int packageCount = packages.size();\n                for (int j = 0; j < packageCount; j++) {\n                    Ops pkgOps = packages.valueAt(j);\n                    ArrayList<AppOpsManager.OpEntry> resOps = collectOps(pkgOps, ops);\n                    if (resOps != null) {\n                        if (res == null) {\n                            res = new ArrayList<>();\n                        }\n                        AppOpsManager.PackageOps resPackage = new AppOpsManager.PackageOps(\n                                pkgOps.packageName, pkgOps.uidState.uid, resOps);\n                        // Caller can always see their packages and with a permission all.\n                        if (hasAllPackageAccess || callingUid == pkgOps.uidState.uid) {\n                            res.add(resPackage);\n                        }\n                    }\n                }\n            }\n        }\n        return res;\n    }\n\n    @Override\n    public List<AppOpsManager.PackageOps> getOpsForPackage(int uid, String packageName,\n            int[] ops) {\n        enforceGetAppOpsStatsPermissionIfNeeded(uid,packageName);\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return Collections.emptyList();\n        }\n        synchronized (this) {\n            Ops pkgOps = getOpsLocked(uid, resolvedPackageName, null, false, null,\n                    /* edit */ false);\n            if (pkgOps == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.OpEntry> resOps = collectOps(pkgOps, ops);\n            if (resOps == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.PackageOps> res = new ArrayList<AppOpsManager.PackageOps>();\n            AppOpsManager.PackageOps resPackage = new AppOpsManager.PackageOps(\n                    pkgOps.packageName, pkgOps.uidState.uid, resOps);\n            res.add(resPackage);\n            return res;\n        }\n    }\n\n    private void enforceGetAppOpsStatsPermissionIfNeeded(int uid, String packageName) {\n        // We get to access everything\n        final int callingPid = Binder.getCallingPid();\n        if (callingPid == Process.myPid()) {\n            return;\n        }\n        // Apps can access their own data\n        final int callingUid = Binder.getCallingUid();\n        if (uid == callingUid && packageName != null\n                && checkPackage(uid, packageName) == MODE_ALLOWED) {\n            return;\n        }\n        // Otherwise, you need a permission...\n        mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS, callingPid,\n                callingUid, null);\n    }\n\n    /**\n     * Verify that historical appop request arguments are valid.\n     */\n    private void ensureHistoricalOpRequestIsValid(int uid, String packageName,\n            String attributionTag, List<String> opNames, int filter, long beginTimeMillis,\n            long endTimeMillis, int flags) {\n        if ((filter & FILTER_BY_UID) != 0) {\n            Preconditions.checkArgument(uid != Process.INVALID_UID);\n        } else {\n            Preconditions.checkArgument(uid == Process.INVALID_UID);\n        }\n\n        if ((filter & FILTER_BY_PACKAGE_NAME) != 0) {\n            Objects.requireNonNull(packageName);\n        } else {\n            Preconditions.checkArgument(packageName == null);\n        }\n\n        if ((filter & FILTER_BY_ATTRIBUTION_TAG) == 0) {\n            Preconditions.checkArgument(attributionTag == null);\n        }\n\n        if ((filter & FILTER_BY_OP_NAMES) != 0) {\n            Objects.requireNonNull(opNames);\n        } else {\n            Preconditions.checkArgument(opNames == null);\n        }\n\n        Preconditions.checkFlagsArgument(filter,\n                FILTER_BY_UID | FILTER_BY_PACKAGE_NAME | FILTER_BY_ATTRIBUTION_TAG\n                        | FILTER_BY_OP_NAMES);\n        Preconditions.checkArgumentNonnegative(beginTimeMillis);\n        Preconditions.checkArgument(endTimeMillis > beginTimeMillis);\n        Preconditions.checkFlagsArgument(flags, OP_FLAGS_ALL);\n    }\n\n    @Override\n    public void getHistoricalOps(int uid, String packageName, String attributionTag,\n            List<String> opNames, int dataType, int filter, long beginTimeMillis,\n            long endTimeMillis, int flags, RemoteCallback callback) {\n        PackageManager pm = mContext.getPackageManager();\n\n        ensureHistoricalOpRequestIsValid(uid, packageName, attributionTag, opNames, filter,\n                beginTimeMillis, endTimeMillis, flags);\n        Objects.requireNonNull(callback, \"callback cannot be null\");\n        ActivityManagerInternal ami = LocalServices.getService(ActivityManagerInternal.class);\n        boolean isSelfRequest = (filter & FILTER_BY_UID) != 0 && uid == Binder.getCallingUid();\n        if (!isSelfRequest) {\n            boolean isCallerInstrumented =\n                    ami.getInstrumentationSourceUid(Binder.getCallingUid()) != Process.INVALID_UID;\n            boolean isCallerSystem = Binder.getCallingPid() == Process.myPid();\n            boolean isCallerPermissionController;\n            try {\n                isCallerPermissionController = pm.getPackageUidAsUser(\n                        mContext.getPackageManager().getPermissionControllerPackageName(), 0,\n                        UserHandle.getUserId(Binder.getCallingUid()))\n                        == Binder.getCallingUid();\n            } catch (PackageManager.NameNotFoundException doesNotHappen) {\n                return;\n            }\n\n            boolean doesCallerHavePermission = mContext.checkPermission(\n                    android.Manifest.permission.GET_HISTORICAL_APP_OPS_STATS,\n                    Binder.getCallingPid(), Binder.getCallingUid())\n                    == PackageManager.PERMISSION_GRANTED;\n\n            if (!isCallerSystem && !isCallerInstrumented && !isCallerPermissionController\n                    && !doesCallerHavePermission) {\n                mHandler.post(() -> callback.sendResult(new Bundle()));\n                return;\n            }\n\n            mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS,\n                    Binder.getCallingPid(), Binder.getCallingUid(), \"getHistoricalOps\");\n        }\n\n        final String[] opNamesArray = (opNames != null)\n                ? opNames.toArray(new String[opNames.size()]) : null;\n\n        Set<String> attributionChainExemptPackages = null;\n        if ((dataType & HISTORY_FLAG_GET_ATTRIBUTION_CHAINS) != 0) {\n            attributionChainExemptPackages =\n                    PermissionManager.getIndicatorExemptedPackages(mContext);\n        }\n\n        final String[] chainExemptPkgArray = attributionChainExemptPackages != null\n                ? attributionChainExemptPackages.toArray(\n                        new String[attributionChainExemptPackages.size()]) : null;\n\n        // Must not hold the appops lock\n        mHandler.post(PooledLambda.obtainRunnable(HistoricalRegistry::getHistoricalOps,\n                mHistoricalRegistry, uid, packageName, attributionTag, opNamesArray, dataType,\n                filter, beginTimeMillis, endTimeMillis, flags, chainExemptPkgArray,\n                callback).recycleOnUse());\n    }\n\n    @Override\n    public void getHistoricalOpsFromDiskRaw(int uid, String packageName, String attributionTag,\n            List<String> opNames, int dataType, int filter, long beginTimeMillis,\n            long endTimeMillis, int flags, RemoteCallback callback) {\n        ensureHistoricalOpRequestIsValid(uid, packageName, attributionTag, opNames, filter,\n                beginTimeMillis, endTimeMillis, flags);\n        Objects.requireNonNull(callback, \"callback cannot be null\");\n\n        mContext.enforcePermission(Manifest.permission.MANAGE_APPOPS,\n                Binder.getCallingPid(), Binder.getCallingUid(), \"getHistoricalOps\");\n\n        final String[] opNamesArray = (opNames != null)\n                ? opNames.toArray(new String[opNames.size()]) : null;\n\n        Set<String> attributionChainExemptPackages = null;\n        if ((dataType & HISTORY_FLAG_GET_ATTRIBUTION_CHAINS) != 0) {\n            attributionChainExemptPackages =\n                    PermissionManager.getIndicatorExemptedPackages(mContext);\n        }\n\n        final String[] chainExemptPkgArray = attributionChainExemptPackages != null\n                ? attributionChainExemptPackages.toArray(\n                new String[attributionChainExemptPackages.size()]) : null;\n\n        // Must not hold the appops lock\n        mHandler.post(PooledLambda.obtainRunnable(HistoricalRegistry::getHistoricalOpsFromDiskRaw,\n                mHistoricalRegistry, uid, packageName, attributionTag, opNamesArray, dataType,\n                filter, beginTimeMillis, endTimeMillis, flags, chainExemptPkgArray,\n                callback).recycleOnUse());\n    }\n\n    @Override\n    public void reloadNonHistoricalState() {\n        mContext.enforcePermission(Manifest.permission.MANAGE_APPOPS,\n                Binder.getCallingPid(), Binder.getCallingUid(), \"reloadNonHistoricalState\");\n        mAppOpsCheckingService.writeState();\n        mAppOpsCheckingService.readState();\n    }\n\n    @VisibleForTesting\n    void readState() {\n        mAppOpsCheckingService.readState();\n    }\n\n    @Override\n    public List<AppOpsManager.PackageOps> getUidOps(int uid, int[] ops) {\n        mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n        synchronized (this) {\n            UidState uidState = getUidStateLocked(uid, false);\n            if (uidState == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.OpEntry> resOps = collectUidOps(uidState, ops);\n            if (resOps == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.PackageOps> res = new ArrayList<AppOpsManager.PackageOps>();\n            AppOpsManager.PackageOps resPackage = new AppOpsManager.PackageOps(\n                    null, uidState.uid, resOps);\n            res.add(resPackage);\n            return res;\n        }\n    }\n\n    private void pruneOpLocked(Op op, int uid, String packageName) {\n        op.removeAttributionsWithNoTime();\n\n        if (op.mAttributions.isEmpty()) {\n            Ops ops = getOpsLocked(uid, packageName, null, false, null, /* edit */ false);\n            if (ops != null) {\n                ops.remove(op.op);\n                op.setMode(AppOpsManager.opToDefaultMode(op.op));\n                if (ops.size() <= 0) {\n                    UidState uidState = ops.uidState;\n                    ArrayMap<String, Ops> pkgOps = uidState.pkgOps;\n                    if (pkgOps != null) {\n                        pkgOps.remove(ops.packageName);\n                        mAppOpsCheckingService.removePackage(ops.packageName,\n                                UserHandle.getUserId(uidState.uid));\n                    }\n                }\n            }\n        }\n    }\n\n    private void enforceManageAppOpsModes(int callingPid, int callingUid, int targetUid) {\n        if (callingPid == Process.myPid()) {\n            return;\n        }\n        final int callingUser = UserHandle.getUserId(callingUid);\n        synchronized (this) {\n            if (mProfileOwners != null && mProfileOwners.get(callingUser, -1) == callingUid) {\n                if (targetUid >= 0 && callingUser == UserHandle.getUserId(targetUid)) {\n                    // Profile owners are allowed to change modes but only for apps\n                    // within their user.\n                    return;\n                }\n            }\n        }\n        mContext.enforcePermission(android.Manifest.permission.MANAGE_APP_OPS_MODES,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n    }\n\n    @Override\n    public void setUidMode(int code, int uid, int mode) {\n        setUidMode(code, uid, mode, null);\n    }\n\n    private void setUidMode(int code, int uid, int mode,\n            @Nullable IAppOpsCallback permissionPolicyCallback) {\n        if (DEBUG) {\n            Slog.i(TAG, \"uid \" + uid + \" OP_\" + opToName(code) + \" := \" + modeToName(mode)\n                    + \" by uid \" + Binder.getCallingUid());\n        }\n\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), uid);\n        verifyIncomingOp(code);\n        code = AppOpsManager.opToSwitch(code);\n\n        if (permissionPolicyCallback == null) {\n            updatePermissionRevokedCompat(uid, code, mode);\n        }\n\n        int previousMode;\n        synchronized (this) {\n            final int defaultMode = AppOpsManager.opToDefaultMode(code);\n\n            UidState uidState = getUidStateLocked(uid, false);\n            if (uidState == null) {\n                if (mode == defaultMode) {\n                    return;\n                }\n                uidState = new UidState(uid);\n                mUidStates.put(uid, uidState);\n            }\n            if (uidState.getUidMode(code) != AppOpsManager.opToDefaultMode(code)) {\n                previousMode = uidState.getUidMode(code);\n            } else {\n                // doesn't look right but is legacy behavior.\n                previousMode = MODE_DEFAULT;\n            }\n\n            if (!uidState.setUidMode(code, mode)) {\n                return;\n            }\n            uidState.evalForegroundOps();\n            if (mode != MODE_ERRORED && mode != previousMode) {\n                updateStartedOpModeForUidLocked(code, mode == MODE_IGNORED, uid);\n            }\n        }\n\n        notifyOpChangedForAllPkgsInUid(code, uid, false, permissionPolicyCallback);\n        notifyOpChangedSync(code, uid, null, mode, previousMode);\n    }\n\n    /**\n     * Notify that an op changed for all packages in an uid.\n     *\n     * @param code The op that changed\n     * @param uid The uid the op was changed for\n     * @param onlyForeground Only notify watchers that watch for foreground changes\n     */\n    private void notifyOpChangedForAllPkgsInUid(int code, int uid, boolean onlyForeground,\n            @Nullable IAppOpsCallback callbackToIgnore) {\n        ModeCallback listenerToIgnore = callbackToIgnore != null\n                ? mModeWatchers.get(callbackToIgnore.asBinder()) : null;\n        mAppOpsCheckingService.notifyOpChangedForAllPkgsInUid(code, uid, onlyForeground,\n                listenerToIgnore);\n    }\n\n    private void updatePermissionRevokedCompat(int uid, int switchCode, int mode) {\n        PackageManager packageManager = mContext.getPackageManager();\n        if (packageManager == null) {\n            // This can only happen during early boot. At this time the permission state and appop\n            // state are in sync\n            return;\n        }\n\n        String[] packageNames = packageManager.getPackagesForUid(uid);\n        if (ArrayUtils.isEmpty(packageNames)) {\n            return;\n        }\n        String packageName = packageNames[0];\n\n        int[] ops = mSwitchedOps.get(switchCode);\n        for (int code : ops) {\n            String permissionName = AppOpsManager.opToPermission(code);\n            if (permissionName == null) {\n                continue;\n            }\n\n            if (packageManager.checkPermission(permissionName, packageName)\n                    != PackageManager.PERMISSION_GRANTED) {\n                continue;\n            }\n\n            PermissionInfo permissionInfo;\n            try {\n                permissionInfo = packageManager.getPermissionInfo(permissionName, 0);\n            } catch (PackageManager.NameNotFoundException e) {\n                e.printStackTrace();\n                continue;\n            }\n\n            if (!permissionInfo.isRuntime()) {\n                continue;\n            }\n\n            boolean supportsRuntimePermissions = getPackageManagerInternal()\n                    .getUidTargetSdkVersion(uid) >= Build.VERSION_CODES.M;\n\n            UserHandle user = UserHandle.getUserHandleForUid(uid);\n            boolean isRevokedCompat;\n            if (permissionInfo.backgroundPermission != null) {\n                if (packageManager.checkPermission(permissionInfo.backgroundPermission, packageName)\n                        == PackageManager.PERMISSION_GRANTED) {\n                    boolean isBackgroundRevokedCompat = mode != AppOpsManager.MODE_ALLOWED;\n\n                    if (isBackgroundRevokedCompat && supportsRuntimePermissions) {\n                        Slog.w(TAG, \"setUidMode() called with a mode inconsistent with runtime\"\n                                + \" permission state, this is discouraged and you should revoke the\"\n                                + \" runtime permission instead: uid=\" + uid + \", switchCode=\"\n                                + switchCode + \", mode=\" + mode + \", permission=\"\n                                + permissionInfo.backgroundPermission);\n                    }\n\n                    final long identity = Binder.clearCallingIdentity();\n                    try {\n                        packageManager.updatePermissionFlags(permissionInfo.backgroundPermission,\n                                packageName, PackageManager.FLAG_PERMISSION_REVOKED_COMPAT,\n                                isBackgroundRevokedCompat\n                                        ? PackageManager.FLAG_PERMISSION_REVOKED_COMPAT : 0, user);\n                    } finally {\n                        Binder.restoreCallingIdentity(identity);\n                    }\n                }\n\n                isRevokedCompat = mode != AppOpsManager.MODE_ALLOWED\n                        && mode != AppOpsManager.MODE_FOREGROUND;\n            } else {\n                isRevokedCompat = mode != AppOpsManager.MODE_ALLOWED;\n            }\n\n            if (isRevokedCompat && supportsRuntimePermissions) {\n                Slog.w(TAG, \"setUidMode() called with a mode inconsistent with runtime\"\n                        + \" permission state, this is discouraged and you should revoke the\"\n                        + \" runtime permission instead: uid=\" + uid + \", switchCode=\"\n                        + switchCode + \", mode=\" + mode + \", permission=\" + permissionName);\n            }\n\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                packageManager.updatePermissionFlags(permissionName, packageName,\n                        PackageManager.FLAG_PERMISSION_REVOKED_COMPAT, isRevokedCompat\n                                ? PackageManager.FLAG_PERMISSION_REVOKED_COMPAT : 0, user);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n    }\n\n    private void notifyOpChangedSync(int code, int uid, @NonNull String packageName, int mode,\n            int previousMode) {\n        final StorageManagerInternal storageManagerInternal =\n                LocalServices.getService(StorageManagerInternal.class);\n        if (storageManagerInternal != null) {\n            storageManagerInternal.onAppOpsChanged(code, uid, packageName, mode, previousMode);\n        }\n    }\n\n    /**\n     * Sets the mode for a certain op and uid.\n     *\n     * @param code The op code to set\n     * @param uid The UID for which to set\n     * @param packageName The package for which to set\n     * @param mode The new mode to set\n     */\n    @Override\n    public void setMode(int code, int uid, @NonNull String packageName, int mode) {\n        setMode(code, uid, packageName, mode, null);\n    }\n\n    void setMode(int code, int uid, @NonNull String packageName, int mode,\n            @Nullable IAppOpsCallback permissionPolicyCallback) {\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), uid);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return;\n        }\n\n        ArraySet<OnOpModeChangedListener> repCbs = null;\n        code = AppOpsManager.opToSwitch(code);\n\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, null);\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot setMode: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot setMode\", e);\n            }\n            return;\n        }\n\n        int previousMode = MODE_DEFAULT;\n        synchronized (this) {\n            UidState uidState = getUidStateLocked(uid, false);\n            Op op = getOpLocked(code, uid, packageName, null, false, pvr.bypass, /* edit */ true);\n            if (op != null) {\n                if (op.getMode() != mode) {\n                    previousMode = op.getMode();\n                    op.setMode(mode);\n\n                    if (uidState != null) {\n                        uidState.evalForegroundOps();\n                    }\n                    ArraySet<OnOpModeChangedListener> cbs =\n                            mAppOpsCheckingService.getOpModeChangedListeners(code);\n                    if (cbs != null) {\n                        if (repCbs == null) {\n                            repCbs = new ArraySet<>();\n                        }\n                        repCbs.addAll(cbs);\n                    }\n                    cbs = mAppOpsCheckingService.getPackageModeChangedListeners(packageName);\n                    if (cbs != null) {\n                        if (repCbs == null) {\n                            repCbs = new ArraySet<>();\n                        }\n                        repCbs.addAll(cbs);\n                    }\n                    if (repCbs != null && permissionPolicyCallback != null) {\n                        repCbs.remove(mModeWatchers.get(permissionPolicyCallback.asBinder()));\n                    }\n                    if (mode == AppOpsManager.opToDefaultMode(op.op)) {\n                        // If going into the default mode, prune this op\n                        // if there is nothing else interesting in it.\n                        pruneOpLocked(op, uid, packageName);\n                    }\n                    scheduleFastWriteLocked();\n                    if (mode != MODE_ERRORED) {\n                        updateStartedOpModeForUidLocked(code, mode == MODE_IGNORED, uid);\n                    }\n                }\n            }\n        }\n        if (repCbs != null) {\n            mHandler.sendMessage(PooledLambda.obtainMessage(\n                    AppOpsService::notifyOpChanged,\n                    this, repCbs, code, uid, packageName));\n        }\n\n        notifyOpChangedSync(code, uid, packageName, mode, previousMode);\n    }\n\n    private void notifyOpChanged(ArraySet<OnOpModeChangedListener> callbacks, int code,\n            int uid, String packageName) {\n        for (int i = 0; i < callbacks.size(); i++) {\n            final OnOpModeChangedListener callback = callbacks.valueAt(i);\n            notifyOpChanged(callback, code, uid, packageName);\n        }\n    }\n\n    private void notifyOpChanged(OnOpModeChangedListener callback, int code,\n            int uid, String packageName) {\n        mAppOpsCheckingService.notifyOpChanged(callback, code, uid, packageName);\n    }\n\n    private static ArrayList<ChangeRec> addChange(ArrayList<ChangeRec> reports,\n            int op, int uid, String packageName, int previousMode) {\n        boolean duplicate = false;\n        if (reports == null) {\n            reports = new ArrayList<>();\n        } else {\n            final int reportCount = reports.size();\n            for (int j = 0; j < reportCount; j++) {\n                ChangeRec report = reports.get(j);\n                if (report.op == op && report.pkg.equals(packageName)) {\n                    duplicate = true;\n                    break;\n                }\n            }\n        }\n        if (!duplicate) {\n            reports.add(new ChangeRec(op, uid, packageName, previousMode));\n        }\n\n        return reports;\n    }\n\n    private static HashMap<OnOpModeChangedListener, ArrayList<ChangeRec>> addCallbacks(\n            HashMap<OnOpModeChangedListener, ArrayList<ChangeRec>> callbacks,\n            int op, int uid, String packageName, int previousMode,\n            ArraySet<OnOpModeChangedListener> cbs) {\n        if (cbs == null) {\n            return callbacks;\n        }\n        if (callbacks == null) {\n            callbacks = new HashMap<>();\n        }\n        final int N = cbs.size();\n        for (int i=0; i<N; i++) {\n            OnOpModeChangedListener cb = cbs.valueAt(i);\n            ArrayList<ChangeRec> reports = callbacks.get(cb);\n            ArrayList<ChangeRec> changed = addChange(reports, op, uid, packageName, previousMode);\n            if (changed != reports) {\n                callbacks.put(cb, changed);\n            }\n        }\n        return callbacks;\n    }\n\n    static final class ChangeRec {\n        final int op;\n        final int uid;\n        final String pkg;\n        final int previous_mode;\n\n        ChangeRec(int _op, int _uid, String _pkg, int _previous_mode) {\n            op = _op;\n            uid = _uid;\n            pkg = _pkg;\n            previous_mode = _previous_mode;\n        }\n    }\n\n    @Override\n    public void resetAllModes(int reqUserId, String reqPackageName) {\n        final int callingPid = Binder.getCallingPid();\n        final int callingUid = Binder.getCallingUid();\n        reqUserId = ActivityManager.handleIncomingUser(callingPid, callingUid, reqUserId,\n                true, true, \"resetAllModes\", null);\n\n        int reqUid = -1;\n        if (reqPackageName != null) {\n            try {\n                reqUid = AppGlobals.getPackageManager().getPackageUid(\n                        reqPackageName, PackageManager.MATCH_UNINSTALLED_PACKAGES, reqUserId);\n            } catch (RemoteException e) {\n                /* ignore - local call */\n            }\n        }\n\n        enforceManageAppOpsModes(callingPid, callingUid, reqUid);\n\n        HashMap<OnOpModeChangedListener, ArrayList<ChangeRec>> callbacks = null;\n        ArrayList<ChangeRec> allChanges = new ArrayList<>();\n        synchronized (this) {\n            boolean changed = false;\n            for (int i = mUidStates.size() - 1; i >= 0; i--) {\n                UidState uidState = mUidStates.valueAt(i);\n\n                SparseIntArray opModes = uidState.getNonDefaultUidModes();\n                if (opModes != null && (uidState.uid == reqUid || reqUid == -1)) {\n                    final int uidOpCount = opModes.size();\n                    for (int j = uidOpCount - 1; j >= 0; j--) {\n                        final int code = opModes.keyAt(j);\n                        if (AppOpsManager.opAllowsReset(code)) {\n                            int previousMode = opModes.valueAt(j);\n                            int newMode = isUidOpGrantedByRole(uidState.uid, code) ? MODE_ALLOWED :\n                                    AppOpsManager.opToDefaultMode(code);\n                            uidState.setUidMode(code, newMode);\n                            for (String packageName : getPackagesForUid(uidState.uid)) {\n                                callbacks = addCallbacks(callbacks, code, uidState.uid, packageName,\n                                        previousMode,\n                                        mAppOpsCheckingService.getOpModeChangedListeners(code));\n                                callbacks = addCallbacks(callbacks, code, uidState.uid, packageName,\n                                        previousMode, mAppOpsCheckingService\n                                                .getPackageModeChangedListeners(packageName));\n\n                                allChanges = addChange(allChanges, code, uidState.uid,\n                                        packageName, previousMode);\n                            }\n                        }\n                    }\n                }\n\n                if (uidState.pkgOps.isEmpty()) {\n                    continue;\n                }\n\n                if (reqUserId != UserHandle.USER_ALL\n                        && reqUserId != UserHandle.getUserId(uidState.uid)) {\n                    // Skip any ops for a different user\n                    continue;\n                }\n\n                Map<String, Ops> packages = uidState.pkgOps;\n                Iterator<Map.Entry<String, Ops>> it = packages.entrySet().iterator();\n                boolean uidChanged = false;\n                while (it.hasNext()) {\n                    Map.Entry<String, Ops> ent = it.next();\n                    String packageName = ent.getKey();\n                    if (reqPackageName != null && !reqPackageName.equals(packageName)) {\n                        // Skip any ops for a different package\n                        continue;\n                    }\n                    Ops pkgOps = ent.getValue();\n                    for (int j=pkgOps.size()-1; j>=0; j--) {\n                        Op curOp = pkgOps.valueAt(j);\n                        if (shouldDeferResetOpToDpm(curOp.op)) {\n                            deferResetOpToDpm(curOp.op, reqPackageName, reqUserId);\n                            continue;\n                        }\n                        if (AppOpsManager.opAllowsReset(curOp.op)) {\n                            int previousMode = curOp.getMode();\n                            int newMode = isPackageOpGrantedByRole(packageName, uidState.uid,\n                                    curOp.op) ? MODE_ALLOWED : AppOpsManager.opToDefaultMode(\n                                    curOp.op);\n                            if (previousMode == newMode) {\n                                continue;\n                            }\n                            curOp.setMode(newMode);\n                            changed = true;\n                            uidChanged = true;\n                            final int uid = curOp.uidState.uid;\n                            callbacks = addCallbacks(callbacks, curOp.op, uid, packageName,\n                                    previousMode,\n                                    mAppOpsCheckingService.getOpModeChangedListeners(curOp.op));\n                            callbacks = addCallbacks(callbacks, curOp.op, uid, packageName,\n                                    previousMode, mAppOpsCheckingService\n                                            .getPackageModeChangedListeners(packageName));\n\n                            allChanges = addChange(allChanges, curOp.op, uid, packageName,\n                                    previousMode);\n                            curOp.removeAttributionsWithNoTime();\n                            if (curOp.mAttributions.isEmpty()) {\n                                pkgOps.removeAt(j);\n                            }\n                        }\n                    }\n                    if (pkgOps.size() == 0) {\n                        it.remove();\n                        mAppOpsCheckingService.removePackage(packageName,\n                                UserHandle.getUserId(uidState.uid));\n                    }\n                }\n                if (uidChanged) {\n                    uidState.evalForegroundOps();\n                }\n            }\n\n            if (changed) {\n                scheduleFastWriteLocked();\n            }\n        }\n        if (callbacks != null) {\n            for (Map.Entry<OnOpModeChangedListener, ArrayList<ChangeRec>> ent\n                    : callbacks.entrySet()) {\n                OnOpModeChangedListener cb = ent.getKey();\n                ArrayList<ChangeRec> reports = ent.getValue();\n                for (int i=0; i<reports.size(); i++) {\n                    ChangeRec rep = reports.get(i);\n                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                            AppOpsService::notifyOpChanged,\n                            this, cb, rep.op, rep.uid, rep.pkg));\n                }\n            }\n        }\n\n        int numChanges = allChanges.size();\n        for (int i = 0; i < numChanges; i++) {\n            ChangeRec change = allChanges.get(i);\n            notifyOpChangedSync(change.op, change.uid, change.pkg,\n                    AppOpsManager.opToDefaultMode(change.op), change.previous_mode);\n        }\n    }\n\n    private boolean isUidOpGrantedByRole(int uid, int code) {\n        if (!AppOpsManager.opIsUidAppOpPermission(code)) {\n            return false;\n        }\n        PackageManager packageManager = mContext.getPackageManager();\n        long token = Binder.clearCallingIdentity();\n        try {\n            // Permissions are managed by UIDs, but unfortunately a package name is required in API.\n            String packageName = ArrayUtils.firstOrNull(packageManager.getPackagesForUid(uid));\n            if (packageName == null) {\n                return false;\n            }\n            int permissionFlags = packageManager.getPermissionFlags(AppOpsManager.opToPermission(\n                    code), packageName, UserHandle.getUserHandleForUid(uid));\n            return (permissionFlags & PackageManager.FLAG_PERMISSION_GRANTED_BY_ROLE) != 0;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private boolean isPackageOpGrantedByRole(@NonNull String packageName, int uid, int code) {\n        if (!AppOpsManager.opIsPackageAppOpPermission(code)) {\n            return false;\n        }\n        PackageManager packageManager = mContext.getPackageManager();\n        long token = Binder.clearCallingIdentity();\n        try {\n            int permissionFlags = packageManager.getPermissionFlags(AppOpsManager.opToPermission(\n                    code), packageName, UserHandle.getUserHandleForUid(uid));\n            return (permissionFlags & PackageManager.FLAG_PERMISSION_GRANTED_BY_ROLE) != 0;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private boolean shouldDeferResetOpToDpm(int op) {\n        // TODO(b/174582385): avoid special-casing app-op resets by migrating app-op permission\n        //  pre-grants to a role-based mechanism or another general-purpose mechanism.\n        return dpmi != null && dpmi.supportsResetOp(op);\n    }\n\n    /** Assumes {@link #shouldDeferResetOpToDpm(int)} is true. */\n    private void deferResetOpToDpm(int op, String packageName, @UserIdInt int userId) {\n        // TODO(b/174582385): avoid special-casing app-op resets by migrating app-op permission\n        //  pre-grants to a role-based mechanism or another general-purpose mechanism.\n        dpmi.resetOp(op, packageName, userId);\n    }\n\n    private void evalAllForegroundOpsLocked() {\n        for (int uidi = mUidStates.size() - 1; uidi >= 0; uidi--) {\n            final UidState uidState = mUidStates.valueAt(uidi);\n            if (uidState.foregroundOps != null) {\n                uidState.evalForegroundOps();\n            }\n        }\n    }\n\n    @Override\n    public void startWatchingMode(int op, String packageName, IAppOpsCallback callback) {\n        startWatchingModeWithFlags(op, packageName, 0, callback);\n    }\n\n    @Override\n    public void startWatchingModeWithFlags(int op, String packageName, int flags,\n            IAppOpsCallback callback) {\n        int watchedUid = -1;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        // TODO: should have a privileged permission to protect this.\n        // Also, if the caller has requested WATCH_FOREGROUND_CHANGES, should we require\n        // the USAGE_STATS permission since this can provide information about when an\n        // app is in the foreground?\n        Preconditions.checkArgumentInRange(op, AppOpsManager.OP_NONE,\n                AppOpsManager._NUM_OP - 1, \"Invalid op code: \" + op);\n        if (callback == null) {\n            return;\n        }\n        final boolean mayWatchPackageName = packageName != null\n                && !filterAppAccessUnlocked(packageName, UserHandle.getUserId(callingUid));\n        synchronized (this) {\n            int switchOp = (op != AppOpsManager.OP_NONE) ? AppOpsManager.opToSwitch(op) : op;\n\n            int notifiedOps;\n            if ((flags & CALL_BACK_ON_SWITCHED_OP) == 0) {\n                if (op == OP_NONE) {\n                    notifiedOps = ALL_OPS;\n                } else {\n                    notifiedOps = op;\n                }\n            } else {\n                notifiedOps = switchOp;\n            }\n\n            ModeCallback cb = mModeWatchers.get(callback.asBinder());\n            if (cb == null) {\n                cb = new ModeCallback(callback, watchedUid, flags, notifiedOps, callingUid,\n                        callingPid);\n                mModeWatchers.put(callback.asBinder(), cb);\n            }\n            if (switchOp != AppOpsManager.OP_NONE) {\n                mAppOpsCheckingService.startWatchingOpModeChanged(cb, switchOp);\n            }\n            if (mayWatchPackageName) {\n                mAppOpsCheckingService.startWatchingPackageModeChanged(cb, packageName);\n            }\n            evalAllForegroundOpsLocked();\n        }\n    }\n\n    @Override\n    public void stopWatchingMode(IAppOpsCallback callback) {\n        if (callback == null) {\n            return;\n        }\n        synchronized (this) {\n            ModeCallback cb = mModeWatchers.remove(callback.asBinder());\n            if (cb != null) {\n                cb.unlinkToDeath();\n                mAppOpsCheckingService.removeListener(cb);\n            }\n\n            evalAllForegroundOpsLocked();\n        }\n    }\n\n    public CheckOpsDelegate getAppOpsServiceDelegate() {\n        synchronized (AppOpsService.this) {\n            final CheckOpsDelegateDispatcher dispatcher = mCheckOpsDelegateDispatcher;\n            return (dispatcher != null) ? dispatcher.getCheckOpsDelegate() : null;\n        }\n    }\n\n    public void setAppOpsServiceDelegate(CheckOpsDelegate delegate) {\n        synchronized (AppOpsService.this) {\n            final CheckOpsDelegateDispatcher oldDispatcher = mCheckOpsDelegateDispatcher;\n            final CheckOpsDelegate policy = (oldDispatcher != null) ? oldDispatcher.mPolicy : null;\n            mCheckOpsDelegateDispatcher = new CheckOpsDelegateDispatcher(policy, delegate);\n        }\n    }\n\n    @Override\n    public int checkOperationRaw(int code, int uid, String packageName,\n            @Nullable String attributionTag) {\n        return mCheckOpsDelegateDispatcher.checkOperation(code, uid, packageName, attributionTag,\n                true /*raw*/);\n    }\n\n    @Override\n    public int checkOperation(int code, int uid, String packageName) {\n        return mCheckOpsDelegateDispatcher.checkOperation(code, uid, packageName, null,\n                false /*raw*/);\n    }\n\n    private int checkOperationImpl(int code, int uid, String packageName,\n            @Nullable String attributionTag, boolean raw) {\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return AppOpsManager.opToDefaultMode(code);\n        }\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return AppOpsManager.MODE_IGNORED;\n        }\n        return checkOperationUnchecked(code, uid, resolvedPackageName, attributionTag, raw);\n    }\n\n    /**\n     * Get the mode of an app-op.\n     *\n     * @param code The code of the op\n     * @param uid The uid of the package the op belongs to\n     * @param packageName The package the op belongs to\n     * @param raw If the raw state of eval-ed state should be checked.\n     *\n     * @return The mode of the op\n     */\n    private @Mode int checkOperationUnchecked(int code, int uid, @NonNull String packageName,\n            @Nullable String attributionTag, boolean raw) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, null);\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot checkOperation: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot checkOperation\", e);\n            }\n            return AppOpsManager.opToDefaultMode(code);\n        }\n\n        if (isOpRestrictedDueToSuspend(code, packageName, uid)) {\n            return AppOpsManager.MODE_IGNORED;\n        }\n        synchronized (this) {\n            if (isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass, true)) {\n                return AppOpsManager.MODE_IGNORED;\n            }\n            code = AppOpsManager.opToSwitch(code);\n            UidState uidState = getUidStateLocked(uid, false);\n            if (uidState != null\n                    && uidState.getUidMode(code) != AppOpsManager.opToDefaultMode(code)) {\n                final int rawMode = uidState.getUidMode(code);\n                return raw ? rawMode : uidState.evalMode(code, rawMode);\n            }\n            Op op = getOpLocked(code, uid, packageName, null, false, pvr.bypass, /* edit */ false);\n            if (op == null) {\n                return AppOpsManager.opToDefaultMode(code);\n            }\n            return raw ? op.getMode() : op.uidState.evalMode(op.op, op.getMode());\n        }\n    }\n\n    @Override\n    public int checkAudioOperation(int code, int usage, int uid, String packageName) {\n        return mCheckOpsDelegateDispatcher.checkAudioOperation(code, usage, uid, packageName);\n    }\n\n    private int checkAudioOperationImpl(int code, int usage, int uid, String packageName) {\n        final int mode = mAudioRestrictionManager.checkAudioOperation(\n                code, usage, uid, packageName);\n        if (mode != AppOpsManager.MODE_ALLOWED) {\n            return mode;\n        }\n        return checkOperation(code, uid, packageName);\n    }\n\n    @Override\n    public void setAudioRestriction(int code, int usage, int uid, int mode,\n            String[] exceptionPackages) {\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), uid);\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n\n        mAudioRestrictionManager.setZenModeAudioRestriction(\n                code, usage, uid, mode, exceptionPackages);\n\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyWatchersOfChange, this, code, UID_ANY));\n    }\n\n\n    @Override\n    public void setCameraAudioRestriction(@CAMERA_AUDIO_RESTRICTION int mode) {\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), -1);\n\n        mAudioRestrictionManager.setCameraAudioRestriction(mode);\n\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyWatchersOfChange, this,\n                AppOpsManager.OP_PLAY_AUDIO, UID_ANY));\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyWatchersOfChange, this,\n                AppOpsManager.OP_VIBRATE, UID_ANY));\n    }\n\n    @Override\n    public int checkPackage(int uid, String packageName) {\n        Objects.requireNonNull(packageName);\n        try {\n            verifyAndGetBypass(uid, packageName, null, null, true);\n            // When the caller is the system, it's possible that the packageName is the special\n            // one (e.g., \"root\") which isn't actually existed.\n            if (resolveUid(packageName) == uid\n                    || (isPackageExisted(packageName)\n                            && !filterAppAccessUnlocked(packageName, UserHandle.getUserId(uid)))) {\n                return AppOpsManager.MODE_ALLOWED;\n            }\n            return AppOpsManager.MODE_ERRORED;\n        } catch (SecurityException ignored) {\n            return AppOpsManager.MODE_ERRORED;\n        }\n    }\n\n    private boolean isPackageExisted(String packageName) {\n        return getPackageManagerInternal().getPackageStateInternal(packageName) != null;\n    }\n\n    /**\n     * This method will check with PackageManager to determine if the package provided should\n     * be visible to the {@link Binder#getCallingUid()}.\n     *\n     * NOTE: This must not be called while synchronized on {@code this} to avoid dead locks\n     */\n    private boolean filterAppAccessUnlocked(String packageName, int userId) {\n        final int callingUid = Binder.getCallingUid();\n        return LocalServices.getService(PackageManagerInternal.class)\n                .filterAppAccess(packageName, callingUid, userId);\n    }\n\n    @Override\n    public SyncNotedAppOp noteProxyOperation(int code, AttributionSource attributionSource,\n            boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n            boolean skipProxyOperation) {\n        return mCheckOpsDelegateDispatcher.noteProxyOperation(code, attributionSource,\n                shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation);\n    }\n\n    private SyncNotedAppOp noteProxyOperationImpl(int code, AttributionSource attributionSource,\n            boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n            boolean skipProxyOperation) {\n        final int proxyUid = attributionSource.getUid();\n        final String proxyPackageName = attributionSource.getPackageName();\n        final String proxyAttributionTag = attributionSource.getAttributionTag();\n        final int proxiedUid = attributionSource.getNextUid();\n        final String proxiedPackageName = attributionSource.getNextPackageName();\n        final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n\n        verifyIncomingProxyUid(attributionSource);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(proxiedPackageName, UserHandle.getUserId(proxiedUid))\n                || !isIncomingPackageValid(proxyPackageName, UserHandle.getUserId(proxyUid))) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        skipProxyOperation = skipProxyOperation\n                && isCallerAndAttributionTrusted(attributionSource);\n\n        String resolveProxyPackageName = AppOpsManager.resolvePackageName(proxyUid,\n                proxyPackageName);\n        if (resolveProxyPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code,\n                    proxiedAttributionTag, proxiedPackageName);\n        }\n\n        final boolean isSelfBlame = Binder.getCallingUid() == proxiedUid;\n        final boolean isProxyTrusted = mContext.checkPermission(\n                Manifest.permission.UPDATE_APP_OPS_STATS, -1, proxyUid)\n                == PackageManager.PERMISSION_GRANTED || isSelfBlame;\n\n        if (!skipProxyOperation) {\n            final int proxyFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXY\n                    : AppOpsManager.OP_FLAG_UNTRUSTED_PROXY;\n\n            final SyncNotedAppOp proxyReturn = noteOperationUnchecked(code, proxyUid,\n                    resolveProxyPackageName, proxyAttributionTag, Process.INVALID_UID, null, null,\n                    proxyFlags, !isProxyTrusted, \"proxy \" + message, shouldCollectMessage);\n            if (proxyReturn.getOpMode() != AppOpsManager.MODE_ALLOWED) {\n                return new SyncNotedAppOp(proxyReturn.getOpMode(), code, proxiedAttributionTag,\n                        proxiedPackageName);\n            }\n        }\n\n        String resolveProxiedPackageName = AppOpsManager.resolvePackageName(proxiedUid,\n                proxiedPackageName);\n        if (resolveProxiedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        final int proxiedFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXIED\n                : AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED;\n        return noteOperationUnchecked(code, proxiedUid, resolveProxiedPackageName,\n                proxiedAttributionTag, proxyUid, resolveProxyPackageName, proxyAttributionTag,\n                proxiedFlags, shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n    }\n\n    @Override\n    public SyncNotedAppOp noteOperation(int code, int uid, String packageName,\n            String attributionTag, boolean shouldCollectAsyncNotedOp, String message,\n            boolean shouldCollectMessage) {\n        return mCheckOpsDelegateDispatcher.noteOperation(code, uid, packageName,\n                attributionTag, shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n    }\n\n    private SyncNotedAppOp noteOperationImpl(int code, int uid, @Nullable String packageName,\n            @Nullable String attributionTag, boolean shouldCollectAsyncNotedOp,\n            @Nullable String message, boolean shouldCollectMessage) {\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                    packageName);\n        }\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, attributionTag,\n                    packageName);\n        }\n        return noteOperationUnchecked(code, uid, resolvedPackageName, attributionTag,\n                Process.INVALID_UID, null, null, AppOpsManager.OP_FLAG_SELF,\n                shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n    }\n\n    private SyncNotedAppOp noteOperationUnchecked(int code, int uid, @NonNull String packageName,\n            @Nullable String attributionTag, int proxyUid, String proxyPackageName,\n            @Nullable String proxyAttributionTag, @OpFlags int flags,\n            boolean shouldCollectAsyncNotedOp, @Nullable String message,\n            boolean shouldCollectMessage) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n            boolean wasNull = attributionTag == null;\n            if (!pvr.isAttributionTagValid) {\n                attributionTag = null;\n            }\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot noteOperation: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot noteOperation\", e);\n            }\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                    packageName);\n        }\n        if (proxyAttributionTag != null\n                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n            proxyAttributionTag = null;\n        }\n\n        synchronized (this) {\n            final Ops ops = getOpsLocked(uid, packageName, attributionTag,\n                    pvr.isAttributionTagValid, pvr.bypass, /* edit */ true);\n            if (ops == null) {\n                scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                        AppOpsManager.MODE_IGNORED);\n                if (DEBUG) Slog.d(TAG, \"noteOperation: no op for code \" + code + \" uid \" + uid\n                        + \" package \" + packageName + \"flags: \" +\n                        AppOpsManager.flagsToString(flags));\n                return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                        packageName);\n            }\n            final Op op = getOpLocked(ops, code, uid, true);\n            final AttributedOp attributedOp = op.getOrCreateAttribution(op, attributionTag);\n            if (attributedOp.isRunning()) {\n                Slog.w(TAG, \"Noting op not finished: uid \" + uid + \" pkg \" + packageName + \" code \"\n                        + code + \" startTime of in progress event=\"\n                        + attributedOp.mInProgressEvents.valueAt(0).getStartTime());\n            }\n\n            final int switchCode = AppOpsManager.opToSwitch(code);\n            final UidState uidState = ops.uidState;\n            if (isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass, false)) {\n                attributedOp.rejected(uidState.getState(), flags);\n                scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                        AppOpsManager.MODE_IGNORED);\n                return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, attributionTag,\n                        packageName);\n            }\n            // If there is a non-default per UID policy (we set UID op mode only if\n            // non-default) it takes over, otherwise use the per package policy.\n            if (uidState.getUidMode(switchCode) != AppOpsManager.opToDefaultMode(switchCode)) {\n                final int uidMode = uidState.evalMode(code, uidState.getUidMode(switchCode));\n                if (uidMode != AppOpsManager.MODE_ALLOWED) {\n                    if (DEBUG) Slog.d(TAG, \"noteOperation: uid reject #\" + uidMode + \" for code \"\n                            + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                            + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    attributedOp.rejected(uidState.getState(), flags);\n                    scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                            uidMode);\n                    return new SyncNotedAppOp(uidMode, code, attributionTag, packageName);\n                }\n            } else {\n                final Op switchOp = switchCode != code ? getOpLocked(ops, switchCode, uid, true)\n                        : op;\n                final int mode = switchOp.uidState.evalMode(switchOp.op, switchOp.getMode());\n                if (mode != AppOpsManager.MODE_ALLOWED) {\n                    if (DEBUG) Slog.d(TAG, \"noteOperation: reject #\" + mode + \" for code \"\n                            + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                            + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    attributedOp.rejected(uidState.getState(), flags);\n                    scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                            mode);\n                    return new SyncNotedAppOp(mode, code, attributionTag, packageName);\n                }\n            }\n            if (DEBUG) {\n                Slog.d(TAG,\n                        \"noteOperation: allowing code \" + code + \" uid \" + uid + \" package \"\n                                + packageName + (attributionTag == null ? \"\"\n                                : \".\" + attributionTag) + \" flags: \"\n                                + AppOpsManager.flagsToString(flags));\n            }\n            scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                    AppOpsManager.MODE_ALLOWED);\n            attributedOp.accessed(proxyUid, proxyPackageName, proxyAttributionTag,\n                    uidState.getState(),\n                    flags);\n\n            if (shouldCollectAsyncNotedOp) {\n                collectAsyncNotedOp(uid, packageName, code, attributionTag, flags, message,\n                        shouldCollectMessage);\n            }\n\n            return new SyncNotedAppOp(AppOpsManager.MODE_ALLOWED, code, attributionTag,\n                    packageName);\n        }\n    }\n\n    // TODO moltmann: Allow watching for attribution ops\n    @Override\n    public void startWatchingActive(int[] ops, IAppOpsActiveCallback callback) {\n        int watchedUid = Process.INVALID_UID;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                != PackageManager.PERMISSION_GRANTED) {\n            watchedUid = callingUid;\n        }\n        if (ops != null) {\n            Preconditions.checkArrayElementsInRange(ops, 0,\n                    AppOpsManager._NUM_OP - 1, \"Invalid op code in: \" + Arrays.toString(ops));\n        }\n        if (callback == null) {\n            return;\n        }\n        synchronized (this) {\n            SparseArray<ActiveCallback> callbacks = mActiveWatchers.get(callback.asBinder());\n            if (callbacks == null) {\n                callbacks = new SparseArray<>();\n                mActiveWatchers.put(callback.asBinder(), callbacks);\n            }\n            final ActiveCallback activeCallback = new ActiveCallback(callback, watchedUid,\n                    callingUid, callingPid);\n            for (int op : ops) {\n                callbacks.put(op, activeCallback);\n            }\n        }\n    }\n\n    @Override\n    public void stopWatchingActive(IAppOpsActiveCallback callback) {\n        if (callback == null) {\n            return;\n        }\n        synchronized (this) {\n            final SparseArray<ActiveCallback> activeCallbacks =\n                    mActiveWatchers.remove(callback.asBinder());\n            if (activeCallbacks == null) {\n                return;\n            }\n            final int callbackCount = activeCallbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                activeCallbacks.valueAt(i).destroy();\n            }\n        }\n    }\n\n    @Override\n    public void startWatchingStarted(int[] ops, @NonNull IAppOpsStartedCallback callback) {\n        int watchedUid = Process.INVALID_UID;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                != PackageManager.PERMISSION_GRANTED) {\n            watchedUid = callingUid;\n        }\n\n        Preconditions.checkArgument(!ArrayUtils.isEmpty(ops), \"Ops cannot be null or empty\");\n        Preconditions.checkArrayElementsInRange(ops, 0, AppOpsManager._NUM_OP - 1,\n                \"Invalid op code in: \" + Arrays.toString(ops));\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n\n        synchronized (this) {\n            SparseArray<StartedCallback> callbacks = mStartedWatchers.get(callback.asBinder());\n            if (callbacks == null) {\n                callbacks = new SparseArray<>();\n                mStartedWatchers.put(callback.asBinder(), callbacks);\n            }\n\n            final StartedCallback startedCallback = new StartedCallback(callback, watchedUid,\n                    callingUid, callingPid);\n            for (int op : ops) {\n                callbacks.put(op, startedCallback);\n            }\n        }\n    }\n\n    @Override\n    public void stopWatchingStarted(IAppOpsStartedCallback callback) {\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n\n        synchronized (this) {\n            final SparseArray<StartedCallback> startedCallbacks =\n                    mStartedWatchers.remove(callback.asBinder());\n            if (startedCallbacks == null) {\n                return;\n            }\n\n            final int callbackCount = startedCallbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                startedCallbacks.valueAt(i).destroy();\n            }\n        }\n    }\n\n    @Override\n    public void startWatchingNoted(@NonNull int[] ops, @NonNull IAppOpsNotedCallback callback) {\n        int watchedUid = Process.INVALID_UID;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                != PackageManager.PERMISSION_GRANTED) {\n            watchedUid = callingUid;\n        }\n        Preconditions.checkArgument(!ArrayUtils.isEmpty(ops), \"Ops cannot be null or empty\");\n        Preconditions.checkArrayElementsInRange(ops, 0, AppOpsManager._NUM_OP - 1,\n                \"Invalid op code in: \" + Arrays.toString(ops));\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n        synchronized (this) {\n            SparseArray<NotedCallback> callbacks = mNotedWatchers.get(callback.asBinder());\n            if (callbacks == null) {\n                callbacks = new SparseArray<>();\n                mNotedWatchers.put(callback.asBinder(), callbacks);\n            }\n            final NotedCallback notedCallback = new NotedCallback(callback, watchedUid,\n                    callingUid, callingPid);\n            for (int op : ops) {\n                callbacks.put(op, notedCallback);\n            }\n        }\n    }\n\n    @Override\n    public void stopWatchingNoted(IAppOpsNotedCallback callback) {\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n        synchronized (this) {\n            final SparseArray<NotedCallback> notedCallbacks =\n                    mNotedWatchers.remove(callback.asBinder());\n            if (notedCallbacks == null) {\n                return;\n            }\n            final int callbackCount = notedCallbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                notedCallbacks.valueAt(i).destroy();\n            }\n        }\n    }\n\n    /**\n     * Collect an {@link AsyncNotedAppOp}.\n     *\n     * @param uid The uid the op was noted for\n     * @param packageName The package the op was noted for\n     * @param opCode The code of the op noted\n     * @param attributionTag attribution tag the op was noted for\n     * @param message The message for the op noting\n     */\n    private void collectAsyncNotedOp(int uid, @NonNull String packageName, int opCode,\n            @Nullable String attributionTag, @OpFlags int flags, @NonNull String message,\n            boolean shouldCollectMessage) {\n        Objects.requireNonNull(message);\n\n        int callingUid = Binder.getCallingUid();\n\n        final long token = Binder.clearCallingIdentity();\n        try {\n            synchronized (this) {\n                Pair<String, Integer> key = getAsyncNotedOpsKey(packageName, uid);\n\n                RemoteCallbackList<IAppOpsAsyncNotedCallback> callbacks = mAsyncOpWatchers.get(key);\n                AsyncNotedAppOp asyncNotedOp = new AsyncNotedAppOp(opCode, callingUid,\n                        attributionTag, message, System.currentTimeMillis());\n                final boolean[] wasNoteForwarded = {false};\n\n                if ((flags & (OP_FLAG_SELF | OP_FLAG_TRUSTED_PROXIED)) != 0\n                        && shouldCollectMessage) {\n                    reportRuntimeAppOpAccessMessageAsyncLocked(uid, packageName, opCode,\n                            attributionTag, message);\n                }\n\n                if (callbacks != null) {\n                    callbacks.broadcast((cb) -> {\n                        try {\n                            cb.opNoted(asyncNotedOp);\n                            wasNoteForwarded[0] = true;\n                        } catch (RemoteException e) {\n                            Slog.e(TAG,\n                                    \"Could not forward noteOp of \" + opCode + \" to \" + packageName\n                                            + \"/\" + uid + \"(\" + attributionTag + \")\", e);\n                        }\n                    });\n                }\n\n                if (!wasNoteForwarded[0]) {\n                    ArrayList<AsyncNotedAppOp> unforwardedOps = mUnforwardedAsyncNotedOps.get(key);\n                    if (unforwardedOps == null) {\n                        unforwardedOps = new ArrayList<>(1);\n                        mUnforwardedAsyncNotedOps.put(key, unforwardedOps);\n                    }\n\n                    unforwardedOps.add(asyncNotedOp);\n                    if (unforwardedOps.size() > MAX_UNFORWARDED_OPS) {\n                        unforwardedOps.remove(0);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Compute a key to be used in {@link #mAsyncOpWatchers} and {@link #mUnforwardedAsyncNotedOps}\n     *\n     * @param packageName The package name of the app\n     * @param uid The uid of the app\n     *\n     * @return They key uniquely identifying the app\n     */\n    private @NonNull Pair<String, Integer> getAsyncNotedOpsKey(@NonNull String packageName,\n            int uid) {\n        return new Pair<>(packageName, uid);\n    }\n\n    @Override\n    public void startWatchingAsyncNoted(String packageName, IAppOpsAsyncNotedCallback callback) {\n        Objects.requireNonNull(packageName);\n        Objects.requireNonNull(callback);\n\n        int uid = Binder.getCallingUid();\n        Pair<String, Integer> key = getAsyncNotedOpsKey(packageName, uid);\n\n        verifyAndGetBypass(uid, packageName, null);\n\n        synchronized (this) {\n            RemoteCallbackList<IAppOpsAsyncNotedCallback> callbacks = mAsyncOpWatchers.get(key);\n            if (callbacks == null) {\n                callbacks = new RemoteCallbackList<IAppOpsAsyncNotedCallback>() {\n                    @Override\n                    public void onCallbackDied(IAppOpsAsyncNotedCallback callback) {\n                        synchronized (AppOpsService.this) {\n                            if (getRegisteredCallbackCount() == 0) {\n                                mAsyncOpWatchers.remove(key);\n                            }\n                        }\n                    }\n                };\n                mAsyncOpWatchers.put(key, callbacks);\n            }\n\n            callbacks.register(callback);\n        }\n    }\n\n    @Override\n    public void stopWatchingAsyncNoted(String packageName, IAppOpsAsyncNotedCallback callback) {\n        Objects.requireNonNull(packageName);\n        Objects.requireNonNull(callback);\n\n        int uid = Binder.getCallingUid();\n        Pair<String, Integer> key = getAsyncNotedOpsKey(packageName, uid);\n\n        verifyAndGetBypass(uid, packageName, null);\n\n        synchronized (this) {\n            RemoteCallbackList<IAppOpsAsyncNotedCallback> callbacks = mAsyncOpWatchers.get(key);\n            if (callbacks != null) {\n                callbacks.unregister(callback);\n                if (callbacks.getRegisteredCallbackCount() == 0) {\n                    mAsyncOpWatchers.remove(key);\n                }\n            }\n        }\n    }\n\n    @Override\n    public List<AsyncNotedAppOp> extractAsyncOps(String packageName) {\n        Objects.requireNonNull(packageName);\n\n        int uid = Binder.getCallingUid();\n\n        verifyAndGetBypass(uid, packageName, null);\n\n        synchronized (this) {\n            return mUnforwardedAsyncNotedOps.remove(getAsyncNotedOpsKey(packageName, uid));\n        }\n    }\n\n    @Override\n    public SyncNotedAppOp startOperation(IBinder token, int code, int uid,\n            @Nullable String packageName, @Nullable String attributionTag,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp,\n            String message, boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n            int attributionChainId) {\n        return mCheckOpsDelegateDispatcher.startOperation(token, code, uid, packageName,\n                attributionTag, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                shouldCollectMessage, attributionFlags, attributionChainId);\n    }\n\n    private SyncNotedAppOp startOperationImpl(@NonNull IBinder clientId, int code, int uid,\n            @Nullable String packageName, @Nullable String attributionTag,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, @NonNull String message,\n            boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n            int attributionChainId) {\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                    packageName);\n        }\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, attributionTag,\n                    packageName);\n        }\n\n        // As a special case for OP_RECORD_AUDIO_HOTWORD, OP_RECEIVE_AMBIENT_TRIGGER_AUDIO and\n        // OP_RECORD_AUDIO_SANDBOXED which we use only for attribution purposes and not as a check,\n        // also make sure that the caller is allowed to access the data gated by OP_RECORD_AUDIO.\n        //\n        // TODO: Revert this change before Android 12.\n        int result = MODE_DEFAULT;\n        if (code == OP_RECORD_AUDIO_HOTWORD || code == OP_RECEIVE_AMBIENT_TRIGGER_AUDIO\n                || code == OP_RECORD_AUDIO_SANDBOXED) {\n            result = checkOperation(OP_RECORD_AUDIO, uid, packageName);\n            // Check result\n            if (result != AppOpsManager.MODE_ALLOWED) {\n                return new SyncNotedAppOp(result, code, attributionTag, packageName);\n            }\n        }\n        // As a special case for OP_CAMERA_SANDBOXED.\n        if (code == OP_CAMERA_SANDBOXED) {\n            result = checkOperation(OP_CAMERA, uid, packageName);\n            // Check result\n            if (result != AppOpsManager.MODE_ALLOWED) {\n                return new SyncNotedAppOp(result, code, attributionTag, packageName);\n            }\n        }\n\n        return startOperationUnchecked(clientId, code, uid, packageName, attributionTag,\n                Process.INVALID_UID, null, null, OP_FLAG_SELF, startIfModeDefault,\n                shouldCollectAsyncNotedOp, message, shouldCollectMessage, attributionFlags,\n                attributionChainId, /*dryRun*/ false);\n    }\n\n    @Override\n    public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n            boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n            boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n            @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n        return mCheckOpsDelegateDispatcher.startProxyOperation(clientId, code, attributionSource,\n                startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlags,\n                attributionChainId);\n    }\n\n    private SyncNotedAppOp startProxyOperationImpl(@NonNull IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n            boolean shouldCollectMessage, boolean skipProxyOperation, @AttributionFlags\n            int proxyAttributionFlags, @AttributionFlags int proxiedAttributionFlags,\n            int attributionChainId) {\n        final int proxyUid = attributionSource.getUid();\n        final String proxyPackageName = attributionSource.getPackageName();\n        final String proxyAttributionTag = attributionSource.getAttributionTag();\n        final int proxiedUid = attributionSource.getNextUid();\n        final String proxiedPackageName = attributionSource.getNextPackageName();\n        final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n\n        verifyIncomingProxyUid(attributionSource);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(proxyPackageName, UserHandle.getUserId(proxyUid))\n                || !isIncomingPackageValid(proxiedPackageName, UserHandle.getUserId(proxiedUid))) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        boolean isCallerTrusted = isCallerAndAttributionTrusted(attributionSource);\n        skipProxyOperation = isCallerTrusted && skipProxyOperation;\n\n        String resolvedProxyPackageName = AppOpsManager.resolvePackageName(proxyUid,\n                proxyPackageName);\n        if (resolvedProxyPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        final boolean isChainTrusted = isCallerTrusted\n                && attributionChainId != ATTRIBUTION_CHAIN_ID_NONE\n                && ((proxyAttributionFlags & ATTRIBUTION_FLAG_TRUSTED) != 0\n                || (proxiedAttributionFlags & ATTRIBUTION_FLAG_TRUSTED) != 0);\n        final boolean isSelfBlame = Binder.getCallingUid() == proxiedUid;\n        final boolean isProxyTrusted = mContext.checkPermission(\n                Manifest.permission.UPDATE_APP_OPS_STATS, -1, proxyUid)\n                == PackageManager.PERMISSION_GRANTED || isSelfBlame\n                || isChainTrusted;\n\n        String resolvedProxiedPackageName = AppOpsManager.resolvePackageName(proxiedUid,\n                proxiedPackageName);\n        if (resolvedProxiedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        final int proxiedFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXIED\n                : AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED;\n\n        if (!skipProxyOperation) {\n            // Test if the proxied operation will succeed before starting the proxy operation\n            final SyncNotedAppOp testProxiedOp = startOperationUnchecked(clientId, code,\n                    proxiedUid, resolvedProxiedPackageName, proxiedAttributionTag, proxyUid,\n                    resolvedProxyPackageName, proxyAttributionTag, proxiedFlags, startIfModeDefault,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    proxiedAttributionFlags, attributionChainId, /*dryRun*/ true);\n            if (!shouldStartForMode(testProxiedOp.getOpMode(), startIfModeDefault)) {\n                return testProxiedOp;\n            }\n\n            final int proxyFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXY\n                    : AppOpsManager.OP_FLAG_UNTRUSTED_PROXY;\n\n            final SyncNotedAppOp proxyAppOp = startOperationUnchecked(clientId, code, proxyUid,\n                    resolvedProxyPackageName, proxyAttributionTag, Process.INVALID_UID, null, null,\n                    proxyFlags, startIfModeDefault, !isProxyTrusted, \"proxy \" + message,\n                    shouldCollectMessage, proxyAttributionFlags, attributionChainId,\n                    /*dryRun*/ false);\n            if (!shouldStartForMode(proxyAppOp.getOpMode(), startIfModeDefault)) {\n                return proxyAppOp;\n            }\n        }\n\n        return startOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,\n                proxiedAttributionTag, proxyUid, resolvedProxyPackageName, proxyAttributionTag,\n                proxiedFlags, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                shouldCollectMessage, proxiedAttributionFlags, attributionChainId,\n                /*dryRun*/ false);\n    }\n\n    private boolean shouldStartForMode(int mode, boolean startIfModeDefault) {\n        return (mode == MODE_ALLOWED || (mode == MODE_DEFAULT && startIfModeDefault));\n    }\n\n    private SyncNotedAppOp startOperationUnchecked(IBinder clientId, int code, int uid,\n            @NonNull String packageName, @Nullable String attributionTag, int proxyUid,\n            String proxyPackageName, @Nullable String proxyAttributionTag, @OpFlags int flags,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, @Nullable String message,\n            boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n            int attributionChainId, boolean dryRun) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n            if (!pvr.isAttributionTagValid) {\n                attributionTag = null;\n            }\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot startOperation: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot startOperation\", e);\n            }\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                    packageName);\n        }\n        if (proxyAttributionTag != null\n                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n            proxyAttributionTag = null;\n        }\n\n        boolean isRestricted = false;\n        int startType = START_TYPE_FAILED;\n        synchronized (this) {\n            final Ops ops = getOpsLocked(uid, packageName, attributionTag,\n                    pvr.isAttributionTagValid, pvr.bypass, /* edit */ true);\n            if (ops == null) {\n                if (!dryRun) {\n                    scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag,\n                            flags, AppOpsManager.MODE_IGNORED, startType, attributionFlags,\n                            attributionChainId);\n                }\n                if (DEBUG) Slog.d(TAG, \"startOperation: no op for code \" + code + \" uid \" + uid\n                        + \" package \" + packageName + \" flags: \"\n                        + AppOpsManager.flagsToString(flags));\n                return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                        packageName);\n            }\n            final Op op = getOpLocked(ops, code, uid, true);\n            final AttributedOp attributedOp = op.getOrCreateAttribution(op, attributionTag);\n            final UidState uidState = ops.uidState;\n            isRestricted = isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass,\n                    false);\n            final int switchCode = AppOpsManager.opToSwitch(code);\n            // If there is a non-default per UID policy (we set UID op mode only if\n            // non-default) it takes over, otherwise use the per package policy.\n            if (uidState.getUidMode(switchCode) != AppOpsManager.opToDefaultMode(switchCode)) {\n                final int uidMode = uidState.evalMode(code, uidState.getUidMode(switchCode));\n                if (!shouldStartForMode(uidMode, startIfModeDefault)) {\n                    if (DEBUG) {\n                        Slog.d(TAG, \"startOperation: uid reject #\" + uidMode + \" for code \"\n                                + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                                + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    }\n                    if (!dryRun) {\n                        attributedOp.rejected(uidState.getState(), flags);\n                        scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag,\n                                flags, uidMode, startType, attributionFlags, attributionChainId);\n                    }\n                    return new SyncNotedAppOp(uidMode, code, attributionTag, packageName);\n                }\n            } else {\n                final Op switchOp = switchCode != code ? getOpLocked(ops, switchCode, uid, true)\n                        : op;\n                final int mode = switchOp.uidState.evalMode(switchOp.op, switchOp.getMode());\n                if (mode != AppOpsManager.MODE_ALLOWED\n                        && (!startIfModeDefault || mode != MODE_DEFAULT)) {\n                    if (DEBUG) Slog.d(TAG, \"startOperation: reject #\" + mode + \" for code \"\n                            + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                            + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    if (!dryRun) {\n                        attributedOp.rejected(uidState.getState(), flags);\n                        scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag,\n                                flags, mode, startType, attributionFlags, attributionChainId);\n                    }\n                    return new SyncNotedAppOp(mode, code, attributionTag, packageName);\n                }\n            }\n            if (DEBUG) Slog.d(TAG, \"startOperation: allowing code \" + code + \" uid \" + uid\n                    + \" package \" + packageName + \" restricted: \" + isRestricted\n                    + \" flags: \" + AppOpsManager.flagsToString(flags));\n            if (!dryRun) {\n                try {\n                    if (isRestricted) {\n                        attributedOp.createPaused(clientId, proxyUid, proxyPackageName,\n                                proxyAttributionTag, uidState.getState(), flags,\n                                attributionFlags, attributionChainId);\n                    } else {\n                        attributedOp.started(clientId, proxyUid, proxyPackageName,\n                                proxyAttributionTag, uidState.getState(), flags,\n                                attributionFlags, attributionChainId);\n                        startType = START_TYPE_STARTED;\n                    }\n                } catch (RemoteException e) {\n                    throw new RuntimeException(e);\n                }\n                scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                        isRestricted ? MODE_IGNORED : MODE_ALLOWED, startType, attributionFlags,\n                        attributionChainId);\n            }\n        }\n\n        if (shouldCollectAsyncNotedOp && !dryRun && !isRestricted) {\n            collectAsyncNotedOp(uid, packageName, code, attributionTag, AppOpsManager.OP_FLAG_SELF,\n                    message, shouldCollectMessage);\n        }\n\n        return new SyncNotedAppOp(isRestricted ? MODE_IGNORED : MODE_ALLOWED, code, attributionTag,\n                packageName);\n    }\n\n    @Override\n    public void finishOperation(IBinder clientId, int code, int uid, String packageName,\n            String attributionTag) {\n        mCheckOpsDelegateDispatcher.finishOperation(clientId, code, uid, packageName,\n                attributionTag);\n    }\n\n    private void finishOperationImpl(IBinder clientId, int code, int uid, String packageName,\n            String attributionTag) {\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return;\n        }\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return;\n        }\n\n        finishOperationUnchecked(clientId, code, uid, resolvedPackageName, attributionTag);\n    }\n\n    @Override\n    public void finishProxyOperation(@NonNull IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n        mCheckOpsDelegateDispatcher.finishProxyOperation(clientId, code, attributionSource,\n                skipProxyOperation);\n    }\n\n    private Void finishProxyOperationImpl(IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n        final int proxyUid = attributionSource.getUid();\n        final String proxyPackageName = attributionSource.getPackageName();\n        final String proxyAttributionTag = attributionSource.getAttributionTag();\n        final int proxiedUid = attributionSource.getNextUid();\n        final String proxiedPackageName = attributionSource.getNextPackageName();\n        final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n\n        skipProxyOperation = skipProxyOperation\n                && isCallerAndAttributionTrusted(attributionSource);\n\n        verifyIncomingProxyUid(attributionSource);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(proxyPackageName, UserHandle.getUserId(proxyUid))\n                || !isIncomingPackageValid(proxiedPackageName, UserHandle.getUserId(proxiedUid))) {\n            return null;\n        }\n\n        String resolvedProxyPackageName = AppOpsManager.resolvePackageName(proxyUid,\n                proxyPackageName);\n        if (resolvedProxyPackageName == null) {\n            return null;\n        }\n\n        if (!skipProxyOperation) {\n            finishOperationUnchecked(clientId, code, proxyUid, resolvedProxyPackageName,\n                    proxyAttributionTag);\n        }\n\n        String resolvedProxiedPackageName = AppOpsManager.resolvePackageName(proxiedUid,\n                proxiedPackageName);\n        if (resolvedProxiedPackageName == null) {\n            return null;\n        }\n\n        finishOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,\n                proxiedAttributionTag);\n\n        return null;\n    }\n\n    private void finishOperationUnchecked(IBinder clientId, int code, int uid, String packageName,\n            String attributionTag) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag);\n            if (!pvr.isAttributionTagValid) {\n                attributionTag = null;\n            }\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot finishOperation: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot finishOperation\", e);\n            }\n            return;\n        }\n\n        synchronized (this) {\n            Op op = getOpLocked(code, uid, packageName, attributionTag, pvr.isAttributionTagValid,\n                    pvr.bypass, /* edit */ true);\n            if (op == null) {\n                Slog.e(TAG, \"Operation not found: uid=\" + uid + \" pkg=\" + packageName + \"(\"\n                        + attributionTag + \") op=\" + AppOpsManager.opToName(code));\n                return;\n            }\n            final AttributedOp attributedOp = op.mAttributions.get(attributionTag);\n            if (attributedOp == null) {\n                Slog.e(TAG, \"Attribution not found: uid=\" + uid + \" pkg=\" + packageName + \"(\"\n                        + attributionTag + \") op=\" + AppOpsManager.opToName(code));\n                return;\n            }\n\n            if (attributedOp.isRunning() || attributedOp.isPaused()) {\n                attributedOp.finished(clientId);\n            } else {\n                Slog.e(TAG, \"Operation not started: uid=\" + uid + \" pkg=\" + packageName + \"(\"\n                        + attributionTag + \") op=\" + AppOpsManager.opToName(code));\n            }\n        }\n    }\n\n    void scheduleOpActiveChangedIfNeededLocked(int code, int uid, @NonNull\n            String packageName, @Nullable String attributionTag, boolean active, @AttributionFlags\n            int attributionFlags, int attributionChainId) {\n        ArraySet<ActiveCallback> dispatchedCallbacks = null;\n        final int callbackListCount = mActiveWatchers.size();\n        for (int i = 0; i < callbackListCount; i++) {\n            final SparseArray<ActiveCallback> callbacks = mActiveWatchers.valueAt(i);\n            ActiveCallback callback = callbacks.get(code);\n            if (callback != null) {\n                if (callback.mWatchingUid >= 0 && callback.mWatchingUid != uid) {\n                    continue;\n                }\n                if (dispatchedCallbacks == null) {\n                    dispatchedCallbacks = new ArraySet<>();\n                }\n                dispatchedCallbacks.add(callback);\n            }\n        }\n        if (dispatchedCallbacks == null) {\n            return;\n        }\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyOpActiveChanged,\n                this, dispatchedCallbacks, code, uid, packageName, attributionTag, active,\n                attributionFlags, attributionChainId));\n    }\n\n    private void notifyOpActiveChanged(ArraySet<ActiveCallback> callbacks,\n            int code, int uid, @NonNull String packageName, @Nullable String attributionTag,\n            boolean active, @AttributionFlags int attributionFlags, int attributionChainId) {\n        // There are features watching for mode changes such as window manager\n        // and location manager which are in our process. The callbacks in these\n        // features may require permissions our remote caller does not have.\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int callbackCount = callbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                final ActiveCallback callback = callbacks.valueAt(i);\n                try {\n                    if (shouldIgnoreCallback(code, callback.mCallingPid, callback.mCallingUid)) {\n                        continue;\n                    }\n                    callback.mCallback.opActiveChanged(code, uid, packageName, attributionTag,\n                            active, attributionFlags, attributionChainId);\n                } catch (RemoteException e) {\n                    /* do nothing */\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    void scheduleOpStartedIfNeededLocked(int code, int uid, String pkgName,\n            String attributionTag, @OpFlags int flags, @Mode int result,\n            @AppOpsManager.OnOpStartedListener.StartedType int startedType,\n            @AttributionFlags int attributionFlags, int attributionChainId) {\n        ArraySet<StartedCallback> dispatchedCallbacks = null;\n        final int callbackListCount = mStartedWatchers.size();\n        for (int i = 0; i < callbackListCount; i++) {\n            final SparseArray<StartedCallback> callbacks = mStartedWatchers.valueAt(i);\n\n            StartedCallback callback = callbacks.get(code);\n            if (callback != null) {\n                if (callback.mWatchingUid >= 0 && callback.mWatchingUid != uid) {\n                    continue;\n                }\n\n                if (dispatchedCallbacks == null) {\n                    dispatchedCallbacks = new ArraySet<>();\n                }\n                dispatchedCallbacks.add(callback);\n            }\n        }\n\n        if (dispatchedCallbacks == null) {\n            return;\n        }\n\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyOpStarted,\n                this, dispatchedCallbacks, code, uid, pkgName, attributionTag, flags,\n                result, startedType, attributionFlags, attributionChainId));\n    }\n\n    private void notifyOpStarted(ArraySet<StartedCallback> callbacks,\n            int code, int uid, String packageName, String attributionTag, @OpFlags int flags,\n            @Mode int result, @AppOpsManager.OnOpStartedListener.StartedType int startedType,\n            @AttributionFlags int attributionFlags, int attributionChainId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int callbackCount = callbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                final StartedCallback callback = callbacks.valueAt(i);\n                try {\n                    if (shouldIgnoreCallback(code, callback.mCallingPid, callback.mCallingUid)) {\n                        continue;\n                    }\n                    callback.mCallback.opStarted(code, uid, packageName, attributionTag, flags,\n                            result, startedType, attributionFlags, attributionChainId);\n                } catch (RemoteException e) {\n                    /* do nothing */\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void scheduleOpNotedIfNeededLocked(int code, int uid, String packageName,\n            String attributionTag, @OpFlags int flags, @Mode int result) {\n        ArraySet<NotedCallback> dispatchedCallbacks = null;\n        final int callbackListCount = mNotedWatchers.size();\n        for (int i = 0; i < callbackListCount; i++) {\n            final SparseArray<NotedCallback> callbacks = mNotedWatchers.valueAt(i);\n            final NotedCallback callback = callbacks.get(code);\n            if (callback != null) {\n                if (callback.mWatchingUid >= 0 && callback.mWatchingUid != uid) {\n                    continue;\n                }\n                if (dispatchedCallbacks == null) {\n                    dispatchedCallbacks = new ArraySet<>();\n                }\n                dispatchedCallbacks.add(callback);\n            }\n        }\n        if (dispatchedCallbacks == null) {\n            return;\n        }\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyOpChecked,\n                this, dispatchedCallbacks, code, uid, packageName, attributionTag, flags,\n                result));\n    }\n\n    private void notifyOpChecked(ArraySet<NotedCallback> callbacks,\n            int code, int uid, String packageName, String attributionTag, @OpFlags int flags,\n            @Mode int result) {\n        // There are features watching for checks in our process. The callbacks in\n        // these features may require permissions our remote caller does not have.\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int callbackCount = callbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                final NotedCallback callback = callbacks.valueAt(i);\n                try {\n                    if (shouldIgnoreCallback(code, callback.mCallingPid, callback.mCallingUid)) {\n                        continue;\n                    }\n                    callback.mCallback.opNoted(code, uid, packageName, attributionTag, flags,\n                            result);\n                } catch (RemoteException e) {\n                    /* do nothing */\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    @Override\n    public int permissionToOpCode(String permission) {\n        if (permission == null) {\n            return AppOpsManager.OP_NONE;\n        }\n        return AppOpsManager.permissionToOpCode(permission);\n    }\n\n    @Override\n    public boolean shouldCollectNotes(int opCode) {\n        Preconditions.checkArgumentInRange(opCode, 0, _NUM_OP - 1, \"opCode\");\n\n        if (AppOpsManager.shouldForceCollectNoteForOp(opCode)) {\n            return true;\n        }\n\n        String perm = AppOpsManager.opToPermission(opCode);\n        if (perm == null) {\n            return false;\n        }\n\n        PermissionInfo permInfo;\n        try {\n            permInfo = mContext.getPackageManager().getPermissionInfo(perm, 0);\n        } catch (PackageManager.NameNotFoundException e) {\n            return false;\n        }\n\n        return permInfo.getProtection() == PROTECTION_DANGEROUS\n                || (permInfo.getProtectionFlags() & PROTECTION_FLAG_APPOP) != 0;\n    }\n\n    private void verifyIncomingProxyUid(@NonNull AttributionSource attributionSource) {\n        if (attributionSource.getUid() == Binder.getCallingUid()) {\n            return;\n        }\n        if (Binder.getCallingPid() == Process.myPid()) {\n            return;\n        }\n        if (attributionSource.isTrusted(mContext)) {\n            return;\n        }\n        mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n    }\n\n    private void verifyIncomingUid(int uid) {\n        if (uid == Binder.getCallingUid()) {\n            return;\n        }\n        if (Binder.getCallingPid() == Process.myPid()) {\n            return;\n        }\n        mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n    }\n\n    private boolean shouldIgnoreCallback(int op, int watcherPid, int watcherUid) {\n        // If it's a restricted read op, ignore it if watcher doesn't have manage ops permission,\n        // as watcher should not use this to signal if the value is changed.\n        return opRestrictsRead(op) && mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n                watcherPid, watcherUid) != PackageManager.PERMISSION_GRANTED;\n    }\n\n    private void verifyIncomingOp(int op) {\n        if (op >= 0 && op < AppOpsManager._NUM_OP) {\n            // Enforce privileged appops permission if it's a restricted read op.\n            if (opRestrictsRead(op)) {\n                if (!(mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n                        Manifest.permission.GET_APP_OPS_STATS,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n                        Manifest.permission.MANAGE_APP_OPS_MODES,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED)) {\n                    throw new SecurityException(\"verifyIncomingOp: uid \" + Binder.getCallingUid()\n                            + \" does not have any of {MANAGE_APPOPS, GET_APP_OPS_STATS, \"\n                            + \"MANAGE_APP_OPS_MODES}\");\n                }\n            }\n            return;\n        }\n        throw new IllegalArgumentException(\"Bad operation #\" + op);\n    }\n\n    private boolean isIncomingPackageValid(@Nullable String packageName, @UserIdInt int userId) {\n        final int callingUid = Binder.getCallingUid();\n        // Handle the special UIDs that don't have actual packages (audioserver, cameraserver, etc).\n        if (packageName == null || isSpecialPackage(callingUid, packageName)) {\n            return true;\n        }\n\n        // If the package doesn't exist, #verifyAndGetBypass would throw a SecurityException in\n        // the end. Although that exception would be caught and return, we could make it return\n        // early.\n        if (!isPackageExisted(packageName)) {\n            return false;\n        }\n\n        if (getPackageManagerInternal().filterAppAccess(packageName, callingUid, userId)) {\n            Slog.w(TAG, packageName + \" not found from \" + callingUid);\n            return false;\n        }\n\n        return true;\n    }\n\n    private boolean isSpecialPackage(int callingUid, @Nullable String packageName) {\n        final String resolvedPackage = AppOpsManager.resolvePackageName(callingUid, packageName);\n        return callingUid == Process.SYSTEM_UID\n                || resolveUid(resolvedPackage) != Process.INVALID_UID;\n    }\n\n    private boolean isCallerAndAttributionTrusted(@NonNull AttributionSource attributionSource) {\n        if (attributionSource.getUid() != Binder.getCallingUid()\n                && attributionSource.isTrusted(mContext)) {\n            return true;\n        }\n        return mContext.checkPermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null)\n                == PackageManager.PERMISSION_GRANTED;\n    }\n\n    private @Nullable UidState getUidStateLocked(int uid, boolean edit) {\n        UidState uidState = mUidStates.get(uid);\n        if (uidState == null) {\n            if (!edit) {\n                return null;\n            }\n            uidState = new UidState(uid);\n            mUidStates.put(uid, uidState);\n        }\n\n        return uidState;\n    }\n\n    private void updateAppWidgetVisibility(SparseArray<String> uidPackageNames, boolean visible) {\n        synchronized (this) {\n            getUidStateTracker().updateAppWidgetVisibility(uidPackageNames, visible);\n        }\n    }\n\n    /**\n     * @return {@link PackageManagerInternal}\n     */\n    private @NonNull PackageManagerInternal getPackageManagerInternal() {\n        if (mPackageManagerInternal == null) {\n            mPackageManagerInternal = LocalServices.getService(PackageManagerInternal.class);\n        }\n        if (mPackageManagerInternal == null) {\n            throw new IllegalStateException(\"PackageManagerInternal not loaded\");\n        }\n\n        return mPackageManagerInternal;\n    }\n\n    /**\n     * @return {@link PackageManagerLocal}\n     */\n    private @NonNull PackageManagerLocal getPackageManagerLocal() {\n        if (mPackageManagerLocal == null) {\n            mPackageManagerLocal = LocalManagerRegistry.getManager(PackageManagerLocal.class);\n        }\n        if (mPackageManagerLocal == null) {\n            throw new IllegalStateException(\"PackageManagerLocal not loaded\");\n        }\n\n        return mPackageManagerLocal;\n    }\n\n    /**\n     * @return {@link UserManagerInternal}\n     */\n    private @NonNull UserManagerInternal getUserManagerInternal() {\n        if (mUserManagerInternal == null) {\n            mUserManagerInternal = LocalServices.getService(UserManagerInternal.class);\n        }\n        if (mUserManagerInternal == null) {\n            throw new IllegalStateException(\"UserManagerInternal not loaded\");\n        }\n\n        return mUserManagerInternal;\n    }\n\n    /**\n     * Create a restriction description matching the properties of the package.\n     *\n     * @param pkg The package to create the restriction description for\n     *\n     * @return The restriction matching the package\n     */\n    private RestrictionBypass getBypassforPackage(@NonNull PackageState packageState) {\n        return new RestrictionBypass(packageState.getAppId() == Process.SYSTEM_UID,\n                packageState.isPrivileged(), mContext.checkPermission(\n                android.Manifest.permission.EXEMPT_FROM_AUDIO_RECORD_RESTRICTIONS, -1,\n                packageState.getAppId()) == PackageManager.PERMISSION_GRANTED);\n    }\n\n    /**\n     * @see #verifyAndGetBypass(int, String, String, String, boolean)\n     */\n    private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n            @Nullable String attributionTag) {\n        return verifyAndGetBypass(uid, packageName, attributionTag, null);\n    }\n\n    /**\n     * @see #verifyAndGetBypass(int, String, String, String, boolean)\n     */\n    private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n            @Nullable String attributionTag, @Nullable String proxyPackageName) {\n        return verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName, false);\n    }\n\n    /**\n     * Verify that package belongs to uid and return the {@link RestrictionBypass bypass\n     * description} for the package, along with a boolean indicating whether the attribution tag is\n     * valid.\n     *\n     * @param uid The uid the package belongs to\n     * @param packageName The package the might belong to the uid\n     * @param attributionTag attribution tag or {@code null} if no need to verify\n     * @param proxyPackageName The proxy package, from which the attribution tag is to be pulled\n     * @param suppressErrorLogs Whether to print to logcat about nonmatching parameters\n     *\n     * @return PackageVerificationResult containing {@link RestrictionBypass} and whether the\n     *         attribution tag is valid\n     */\n    private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n            @Nullable String attributionTag, @Nullable String proxyPackageName,\n            boolean suppressErrorLogs) {\n        if (uid == Process.ROOT_UID) {\n            // For backwards compatibility, don't check package name for root UID.\n            return new PackageVerificationResult(null,\n                    /* isAttributionTagValid */ true);\n        }\n        if (Process.isSdkSandboxUid(uid)) {\n            // SDK sandbox processes run in their own UID range, but their associated\n            // UID for checks should always be the UID of the package implementing SDK sandbox\n            // service.\n            // TODO: We will need to modify the callers of this function instead, so\n            // modifications and checks against the app ops state are done with the\n            // correct UID.\n            try {\n                final PackageManager pm = mContext.getPackageManager();\n                final String supplementalPackageName = pm.getSdkSandboxPackageName();\n                if (Objects.equals(packageName, supplementalPackageName)) {\n                    uid = pm.getPackageUidAsUser(supplementalPackageName,\n                            PackageManager.PackageInfoFlags.of(0), UserHandle.getUserId(uid));\n                }\n            } catch (PackageManager.NameNotFoundException e) {\n                // Shouldn't happen for the supplemental package\n                e.printStackTrace();\n            }\n        }\n\n\n        // Do not check if uid/packageName/attributionTag is already known.\n        synchronized (this) {\n            UidState uidState = mUidStates.get(uid);\n            if (uidState != null && !uidState.pkgOps.isEmpty()) {\n                Ops ops = uidState.pkgOps.get(packageName);\n\n                if (ops != null && (attributionTag == null || ops.knownAttributionTags.contains(\n                        attributionTag)) && ops.bypass != null) {\n                    return new PackageVerificationResult(ops.bypass,\n                            ops.validAttributionTags.contains(attributionTag));\n                }\n            }\n        }\n\n        int callingUid = Binder.getCallingUid();\n\n        // Allow any attribution tag for resolvable uids\n        int pkgUid;\n        if (Objects.equals(packageName, \"com.android.shell\")) {\n            // Special case for the shell which is a package but should be able\n            // to bypass app attribution tag restrictions.\n            pkgUid = Process.SHELL_UID;\n        } else {\n            pkgUid = resolveUid(packageName);\n        }\n        if (pkgUid != Process.INVALID_UID) {\n            if (pkgUid != UserHandle.getAppId(uid)) {\n                if (!suppressErrorLogs) {\n                    Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n                            + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid\n                            + \".\");\n                }\n                String otherUidMessage = DEBUG ? \" but it is really \" + pkgUid : \" but it is not\";\n                throw new SecurityException(\"Specified package \\\"\" + packageName + \"\\\" under uid \"\n                        +  UserHandle.getAppId(uid) + otherUidMessage);\n            }\n            return new PackageVerificationResult(RestrictionBypass.UNRESTRICTED,\n                    /* isAttributionTagValid */ true);\n        }\n\n        int userId = UserHandle.getUserId(uid);\n        RestrictionBypass bypass = null;\n        boolean isAttributionTagValid = false;\n\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n            var pkgState = pmInt.getPackageStateInternal(packageName);\n            var pkg = pkgState == null ? null : pkgState.getAndroidPackage();\n            if (pkg != null) {\n                isAttributionTagValid = isAttributionInPackage(pkg, attributionTag);\n                pkgUid = UserHandle.getUid(userId, pkgState.getAppId());\n                bypass = getBypassforPackage(pkgState);\n            }\n            if (!isAttributionTagValid) {\n                AndroidPackage proxyPkg = proxyPackageName != null\n                        ? pmInt.getPackage(proxyPackageName) : null;\n                // Re-check in proxy.\n                isAttributionTagValid = isAttributionInPackage(proxyPkg, attributionTag);\n                String msg;\n                if (pkg != null && isAttributionTagValid) {\n                    msg = \"attributionTag \" + attributionTag + \" declared in manifest of the proxy\"\n                            + \" package \" + proxyPackageName + \", this is not advised\";\n                } else if (pkg != null) {\n                    msg = \"attributionTag \" + attributionTag + \" not declared in manifest of \"\n                            + packageName;\n                } else {\n                    msg = \"package \" + packageName + \" not found, can't check for \"\n                            + \"attributionTag \" + attributionTag;\n                }\n\n                try {\n                    if (!mPlatformCompat.isChangeEnabledByPackageName(\n                            SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE, packageName,\n                            userId) || !mPlatformCompat.isChangeEnabledByUid(\n                                    SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE,\n                            callingUid)) {\n                        // Do not override tags if overriding is not enabled for this package\n                        isAttributionTagValid = true;\n                    }\n                    Slog.e(TAG, msg);\n                } catch (RemoteException neverHappens) {\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n\n        if (pkgUid != uid) {\n            if (!suppressErrorLogs) {\n                Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n                        + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid + \".\");\n            }\n            String otherUidMessage = DEBUG ? \" but it is really \" + pkgUid : \" but it is not\";\n            throw new SecurityException(\"Specified package \\\"\" + packageName + \"\\\" under uid \" + uid\n                    + otherUidMessage);\n        }\n\n        return new PackageVerificationResult(bypass, isAttributionTagValid);\n    }\n\n    private boolean isAttributionInPackage(@Nullable AndroidPackage pkg,\n            @Nullable String attributionTag) {\n        if (pkg == null) {\n            return false;\n        } else if (attributionTag == null) {\n            return true;\n        }\n        if (pkg.getAttributions() != null) {\n            int numAttributions = pkg.getAttributions().size();\n            for (int i = 0; i < numAttributions; i++) {\n                if (pkg.getAttributions().get(i).getTag().equals(attributionTag)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n     * This method is intended for ProxyAttributionTag validation and returns false\n     * if it does not exist in either one of them.\n     *\n     * @param packageName Name of the package\n     * @param proxyPackageName Name of the proxy package\n     * @param attributionTag attribution tag to be checked\n     *\n     * @return boolean specifying if attribution tag is valid or not\n     */\n    private boolean isAttributionTagDefined(@Nullable String packageName,\n                                            @Nullable String proxyPackageName,\n                                            @Nullable String attributionTag) {\n        if (packageName == null) {\n            return false;\n        } else if (attributionTag == null) {\n            return true;\n        }\n        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n        if (proxyPackageName != null) {\n            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n                return true;\n            }\n        }\n        AndroidPackage pkg = pmInt.getPackage(packageName);\n        return isAttributionInPackage(pkg, attributionTag);\n    }\n\n    /**\n     * Get (and potentially create) ops.\n     *\n     * @param uid The uid the package belongs to\n     * @param packageName The name of the package\n     * @param attributionTag attribution tag\n     * @param isAttributionTagValid whether the given attribution tag is valid\n     * @param bypass When to bypass certain op restrictions (can be null if edit == false)\n     * @param edit If an ops does not exist, create the ops?\n\n     * @return The ops\n     */\n    private Ops getOpsLocked(int uid, String packageName, @Nullable String attributionTag,\n            boolean isAttributionTagValid, @Nullable RestrictionBypass bypass, boolean edit) {\n        UidState uidState = getUidStateLocked(uid, edit);\n        if (uidState == null) {\n            return null;\n        }\n\n        Ops ops = uidState.pkgOps.get(packageName);\n        if (ops == null) {\n            if (!edit) {\n                return null;\n            }\n            ops = new Ops(packageName, uidState);\n            uidState.pkgOps.put(packageName, ops);\n        }\n\n        if (edit) {\n            if (bypass != null) {\n                ops.bypass = bypass;\n            }\n\n            if (attributionTag != null) {\n                ops.knownAttributionTags.add(attributionTag);\n                if (isAttributionTagValid) {\n                    ops.validAttributionTags.add(attributionTag);\n                } else {\n                    ops.validAttributionTags.remove(attributionTag);\n                }\n            }\n        }\n\n        return ops;\n    }\n\n    private void scheduleWriteLocked() {\n        if (!mWriteScheduled) {\n            mWriteScheduled = true;\n            mHandler.postDelayed(mWriteRunner, WRITE_DELAY);\n        }\n    }\n\n    private void scheduleFastWriteLocked() {\n        if (!mFastWriteScheduled) {\n            mWriteScheduled = true;\n            mFastWriteScheduled = true;\n            mHandler.removeCallbacks(mWriteRunner);\n            mHandler.postDelayed(mWriteRunner, 10*1000);\n        }\n    }\n\n    /**\n     * Get the state of an op for a uid.\n     *\n     * @param code The code of the op\n     * @param uid The uid the of the package\n     * @param packageName The package name for which to get the state for\n     * @param attributionTag The attribution tag\n     * @param isAttributionTagValid Whether the given attribution tag is valid\n     * @param bypass When to bypass certain op restrictions (can be null if edit == false)\n     * @param edit Iff {@code true} create the {@link Op} object if not yet created\n     *\n     * @return The {@link Op state} of the op\n     */\n    private @Nullable Op getOpLocked(int code, int uid, @NonNull String packageName,\n            @Nullable String attributionTag, boolean isAttributionTagValid,\n            @Nullable RestrictionBypass bypass, boolean edit) {\n        Ops ops = getOpsLocked(uid, packageName, attributionTag, isAttributionTagValid, bypass,\n                edit);\n        if (ops == null) {\n            return null;\n        }\n        return getOpLocked(ops, code, uid, edit);\n    }\n\n    private Op getOpLocked(Ops ops, int code, int uid, boolean edit) {\n        Op op = ops.get(code);\n        if (op == null) {\n            if (!edit) {\n                return null;\n            }\n            op = new Op(ops.uidState, ops.packageName, code, uid);\n            ops.put(code, op);\n        }\n        if (edit) {\n            scheduleWriteLocked();\n        }\n        return op;\n    }\n\n    private boolean isOpRestrictedDueToSuspend(int code, String packageName, int uid) {\n        if (!ArrayUtils.contains(OPS_RESTRICTED_ON_SUSPEND, code)) {\n            return false;\n        }\n        final PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n        return pmi.isPackageSuspended(packageName, UserHandle.getUserId(uid));\n    }\n\n    private boolean isOpRestrictedLocked(int uid, int code, String packageName,\n            String attributionTag, @Nullable RestrictionBypass appBypass, boolean isCheckOp) {\n        int restrictionSetCount = mOpGlobalRestrictions.size();\n\n        for (int i = 0; i < restrictionSetCount; i++) {\n            ClientGlobalRestrictionState restrictionState = mOpGlobalRestrictions.valueAt(i);\n            if (restrictionState.hasRestriction(code)) {\n                return true;\n            }\n        }\n\n        int userHandle = UserHandle.getUserId(uid);\n        restrictionSetCount = mOpUserRestrictions.size();\n\n        for (int i = 0; i < restrictionSetCount; i++) {\n            // For each client, check that the given op is not restricted, or that the given\n            // package is exempt from the restriction.\n            ClientUserRestrictionState restrictionState = mOpUserRestrictions.valueAt(i);\n            if (restrictionState.hasRestriction(code, packageName, attributionTag, userHandle,\n                    isCheckOp)) {\n                RestrictionBypass opBypass = opAllowSystemBypassRestriction(code);\n                if (opBypass != null) {\n                    // If we are the system, bypass user restrictions for certain codes\n                    synchronized (this) {\n                        if (opBypass.isSystemUid && appBypass != null && appBypass.isSystemUid) {\n                            return false;\n                        }\n                        if (opBypass.isPrivileged && appBypass != null && appBypass.isPrivileged) {\n                            return false;\n                        }\n                        if (opBypass.isRecordAudioRestrictionExcept && appBypass != null\n                                && appBypass.isRecordAudioRestrictionExcept) {\n                            return false;\n                        }\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Read recent accesses from persistence (mRecentAccessesFile).\n     * If there is no mRecentAccessesFile yet, we'll need migrate from mStorageFile: first read from\n     * mStorageFile, then all subsequent reads/writes will use mRecentAccessesFile.\n     * If neither file exists, there's nothing to migrate.\n     */\n    private void readRecentAccesses() {\n        if (!mRecentAccessesFile.exists()) {\n            readRecentAccesses(mStorageFile);\n        } else {\n            readRecentAccesses(mRecentAccessesFile);\n        }\n    }\n\n    private void readRecentAccesses(AtomicFile file) {\n        synchronized (file) {\n            synchronized (this) {\n                FileInputStream stream;\n                try {\n                    stream = file.openRead();\n                } catch (FileNotFoundException e) {\n                    Slog.i(TAG, \"No existing app ops \" + file.getBaseFile() + \"; starting empty\");\n                    return;\n                }\n                boolean success = false;\n                mUidStates.clear();\n                mAppOpsCheckingService.clearAllModes();\n                try {\n                    TypedXmlPullParser parser = Xml.resolvePullParser(stream);\n                    int type;\n                    while ((type = parser.next()) != XmlPullParser.START_TAG\n                            && type != XmlPullParser.END_DOCUMENT) {\n                        // Parse next until we reach the start or end\n                    }\n\n                    if (type != XmlPullParser.START_TAG) {\n                        throw new IllegalStateException(\"no start tag found\");\n                    }\n\n                    int outerDepth = parser.getDepth();\n                    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                            && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n                        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                            continue;\n                        }\n\n                        String tagName = parser.getName();\n                        if (tagName.equals(\"pkg\")) {\n                            readPackage(parser);\n                        } else if (tagName.equals(\"uid\")) {\n                            // uid tag may be present during migration, don't print warning.\n                            XmlUtils.skipCurrentTag(parser);\n                        } else {\n                            Slog.w(TAG, \"Unknown element under <app-ops>: \"\n                                    + parser.getName());\n                            XmlUtils.skipCurrentTag(parser);\n                        }\n                    }\n\n                    success = true;\n                } catch (IllegalStateException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (NullPointerException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (NumberFormatException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (XmlPullParserException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (IOException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (IndexOutOfBoundsException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } finally {\n                    if (!success) {\n                        mUidStates.clear();\n                        mAppOpsCheckingService.clearAllModes();\n                    }\n                    try {\n                        stream.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n    }\n\n    private void readPackage(TypedXmlPullParser parser)\n            throws NumberFormatException, XmlPullParserException, IOException {\n        String pkgName = parser.getAttributeValue(null, \"n\");\n        int outerDepth = parser.getDepth();\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                continue;\n            }\n\n            String tagName = parser.getName();\n            if (tagName.equals(\"uid\")) {\n                readUid(parser, pkgName);\n            } else {\n                Slog.w(TAG, \"Unknown element under <pkg>: \"\n                        + parser.getName());\n                XmlUtils.skipCurrentTag(parser);\n            }\n        }\n    }\n\n    private void readUid(TypedXmlPullParser parser, String pkgName)\n            throws NumberFormatException, XmlPullParserException, IOException {\n        int uid = parser.getAttributeInt(null, \"n\");\n        final UidState uidState = getUidStateLocked(uid, true);\n        int outerDepth = parser.getDepth();\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                continue;\n            }\n            String tagName = parser.getName();\n            if (tagName.equals(\"op\")) {\n                readOp(parser, uidState, pkgName);\n            } else {\n                Slog.w(TAG, \"Unknown element under <pkg>: \"\n                        + parser.getName());\n                XmlUtils.skipCurrentTag(parser);\n            }\n        }\n    }\n\n    private void readAttributionOp(TypedXmlPullParser parser, @NonNull Op parent,\n            @Nullable String attribution)\n            throws NumberFormatException, IOException, XmlPullParserException {\n        final AttributedOp attributedOp = parent.getOrCreateAttribution(parent, attribution);\n\n        final long key = parser.getAttributeLong(null, \"n\");\n        final int uidState = extractUidStateFromKey(key);\n        final int opFlags = extractFlagsFromKey(key);\n\n        final long accessTime = parser.getAttributeLong(null, \"t\", 0);\n        final long rejectTime = parser.getAttributeLong(null, \"r\", 0);\n        final long accessDuration = parser.getAttributeLong(null, \"d\", -1);\n        final String proxyPkg = XmlUtils.readStringAttribute(parser, \"pp\");\n        final int proxyUid = parser.getAttributeInt(null, \"pu\", Process.INVALID_UID);\n        final String proxyAttributionTag = XmlUtils.readStringAttribute(parser, \"pc\");\n\n        if (accessTime > 0) {\n            attributedOp.accessed(accessTime, accessDuration, proxyUid, proxyPkg,\n                    proxyAttributionTag, uidState, opFlags);\n        }\n        if (rejectTime > 0) {\n            attributedOp.rejected(rejectTime, uidState, opFlags);\n        }\n    }\n\n    private void readOp(TypedXmlPullParser parser,\n            @NonNull UidState uidState, @NonNull String pkgName)\n            throws NumberFormatException, XmlPullParserException, IOException {\n        int opCode = parser.getAttributeInt(null, \"n\");\n        Op op = new Op(uidState, pkgName, opCode, uidState.uid);\n\n        int outerDepth = parser.getDepth();\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                continue;\n            }\n            String tagName = parser.getName();\n            if (tagName.equals(\"st\")) {\n                readAttributionOp(parser, op, XmlUtils.readStringAttribute(parser, \"id\"));\n            } else {\n                Slog.w(TAG, \"Unknown element under <op>: \"\n                        + parser.getName());\n                XmlUtils.skipCurrentTag(parser);\n            }\n        }\n\n        Ops ops = uidState.pkgOps.get(pkgName);\n        if (ops == null) {\n            ops = new Ops(pkgName, uidState);\n            uidState.pkgOps.put(pkgName, ops);\n        }\n        ops.put(op.op, op);\n    }\n\n    @VisibleForTesting\n    void writeRecentAccesses() {\n        synchronized (mRecentAccessesFile) {\n            FileOutputStream stream;\n            try {\n                stream = mRecentAccessesFile.startWrite();\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to write state: \" + e);\n                return;\n            }\n\n            List<AppOpsManager.PackageOps> allOps = getPackagesForOps(null);\n\n            try {\n                TypedXmlSerializer out = Xml.resolveSerializer(stream);\n                out.startDocument(null, true);\n                out.startTag(null, \"app-ops\");\n                out.attributeInt(null, \"v\", CURRENT_VERSION);\n\n                if (allOps != null) {\n                    String lastPkg = null;\n                    for (int i=0; i<allOps.size(); i++) {\n                        AppOpsManager.PackageOps pkg = allOps.get(i);\n                        if (!Objects.equals(pkg.getPackageName(), lastPkg)) {\n                            if (lastPkg != null) {\n                                out.endTag(null, \"pkg\");\n                            }\n                            lastPkg = pkg.getPackageName();\n                            if (lastPkg != null) {\n                                out.startTag(null, \"pkg\");\n                                out.attribute(null, \"n\", lastPkg);\n                            }\n                        }\n                        out.startTag(null, \"uid\");\n                        out.attributeInt(null, \"n\", pkg.getUid());\n                        List<AppOpsManager.OpEntry> ops = pkg.getOps();\n                        for (int j=0; j<ops.size(); j++) {\n                            AppOpsManager.OpEntry op = ops.get(j);\n                            out.startTag(null, \"op\");\n                            out.attributeInt(null, \"n\", op.getOp());\n                            if (op.getMode() != AppOpsManager.opToDefaultMode(op.getOp())) {\n                                out.attributeInt(null, \"m\", op.getMode());\n                            }\n\n                            for (String attributionTag : op.getAttributedOpEntries().keySet()) {\n                                final AttributedOpEntry attribution =\n                                        op.getAttributedOpEntries().get(attributionTag);\n\n                                final ArraySet<Long> keys = attribution.collectKeys();\n\n                                final int keyCount = keys.size();\n                                for (int k = 0; k < keyCount; k++) {\n                                    final long key = keys.valueAt(k);\n\n                                    final int uidState = AppOpsManager.extractUidStateFromKey(key);\n                                    final int flags = AppOpsManager.extractFlagsFromKey(key);\n\n                                    final long accessTime = attribution.getLastAccessTime(uidState,\n                                            uidState, flags);\n                                    final long rejectTime = attribution.getLastRejectTime(uidState,\n                                            uidState, flags);\n                                    final long accessDuration = attribution.getLastDuration(\n                                            uidState, uidState, flags);\n                                    // Proxy information for rejections is not backed up\n                                    final OpEventProxyInfo proxy = attribution.getLastProxyInfo(\n                                            uidState, uidState, flags);\n\n                                    if (accessTime <= 0 && rejectTime <= 0 && accessDuration <= 0\n                                            && proxy == null) {\n                                        continue;\n                                    }\n\n                                    String proxyPkg = null;\n                                    String proxyAttributionTag = null;\n                                    int proxyUid = Process.INVALID_UID;\n                                    if (proxy != null) {\n                                        proxyPkg = proxy.getPackageName();\n                                        proxyAttributionTag = proxy.getAttributionTag();\n                                        proxyUid = proxy.getUid();\n                                    }\n\n                                    out.startTag(null, \"st\");\n                                    if (attributionTag != null) {\n                                        out.attribute(null, \"id\", attributionTag);\n                                    }\n                                    out.attributeLong(null, \"n\", key);\n                                    if (accessTime > 0) {\n                                        out.attributeLong(null, \"t\", accessTime);\n                                    }\n                                    if (rejectTime > 0) {\n                                        out.attributeLong(null, \"r\", rejectTime);\n                                    }\n                                    if (accessDuration > 0) {\n                                        out.attributeLong(null, \"d\", accessDuration);\n                                    }\n                                    if (proxyPkg != null) {\n                                        out.attribute(null, \"pp\", proxyPkg);\n                                    }\n                                    if (proxyAttributionTag != null) {\n                                        out.attribute(null, \"pc\", proxyAttributionTag);\n                                    }\n                                    if (proxyUid >= 0) {\n                                        out.attributeInt(null, \"pu\", proxyUid);\n                                    }\n                                    out.endTag(null, \"st\");\n                                }\n                            }\n\n                            out.endTag(null, \"op\");\n                        }\n                        out.endTag(null, \"uid\");\n                    }\n                    if (lastPkg != null) {\n                        out.endTag(null, \"pkg\");\n                    }\n                }\n\n                out.endTag(null, \"app-ops\");\n                out.endDocument();\n                mRecentAccessesFile.finishWrite(stream);\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to write state, restoring backup.\", e);\n                mRecentAccessesFile.failWrite(stream);\n            }\n        }\n        mHistoricalRegistry.writeAndClearDiscreteHistory();\n    }\n\n    static class Shell extends ShellCommand {\n        final IAppOpsService mInterface;\n        final AppOpsService mInternal;\n\n        int userId = UserHandle.USER_SYSTEM;\n        String packageName;\n        String attributionTag;\n        String opStr;\n        String modeStr;\n        int op;\n        int mode;\n        int packageUid;\n        int nonpackageUid;\n        final static Binder sBinder = new Binder();\n        IBinder mToken;\n        boolean targetsUid;\n\n        Shell(IAppOpsService iface, AppOpsService internal) {\n            mInterface = iface;\n            mInternal = internal;\n            mToken = AppOpsManager.getClientId();\n        }\n\n        @Override\n        public int onCommand(String cmd) {\n            return onShellCommand(this, cmd);\n        }\n\n        @Override\n        public void onHelp() {\n            PrintWriter pw = getOutPrintWriter();\n            dumpCommandHelp(pw);\n        }\n\n        static private int strOpToOp(String op, PrintWriter err) {\n            try {\n                return AppOpsManager.strOpToOp(op);\n            } catch (IllegalArgumentException e) {\n            }\n            try {\n                return Integer.parseInt(op);\n            } catch (NumberFormatException e) {\n            }\n            try {\n                return AppOpsManager.strDebugOpToOp(op);\n            } catch (IllegalArgumentException e) {\n                err.println(\"Error: \" + e.getMessage());\n                return -1;\n            }\n        }\n\n        static int strModeToMode(String modeStr, PrintWriter err) {\n            for (int i = AppOpsManager.MODE_NAMES.length - 1; i >= 0; i--) {\n                if (AppOpsManager.MODE_NAMES[i].equals(modeStr)) {\n                    return i;\n                }\n            }\n            try {\n                return Integer.parseInt(modeStr);\n            } catch (NumberFormatException e) {\n            }\n            err.println(\"Error: Mode \" + modeStr + \" is not valid\");\n            return -1;\n        }\n\n        int parseUserOpMode(int defMode, PrintWriter err) throws RemoteException {\n            userId = UserHandle.USER_CURRENT;\n            opStr = null;\n            modeStr = null;\n            for (String argument; (argument = getNextArg()) != null;) {\n                if (\"--user\".equals(argument)) {\n                    userId = UserHandle.parseUserArg(getNextArgRequired());\n                } else {\n                    if (opStr == null) {\n                        opStr = argument;\n                    } else if (modeStr == null) {\n                        modeStr = argument;\n                        break;\n                    }\n                }\n            }\n            if (opStr == null) {\n                err.println(\"Error: Operation not specified.\");\n                return -1;\n            }\n            op = strOpToOp(opStr, err);\n            if (op < 0) {\n                return -1;\n            }\n            if (modeStr != null) {\n                if ((mode=strModeToMode(modeStr, err)) < 0) {\n                    return -1;\n                }\n            } else {\n                mode = defMode;\n            }\n            return 0;\n        }\n\n        int parseUserPackageOp(boolean reqOp, PrintWriter err) throws RemoteException {\n            userId = UserHandle.USER_CURRENT;\n            packageName = null;\n            opStr = null;\n            for (String argument; (argument = getNextArg()) != null;) {\n                if (\"--user\".equals(argument)) {\n                    userId = UserHandle.parseUserArg(getNextArgRequired());\n                } else if (\"--uid\".equals(argument)) {\n                    targetsUid = true;\n                } else if (\"--attribution\".equals(argument)) {\n                    attributionTag = getNextArgRequired();\n                } else {\n                    if (packageName == null) {\n                        packageName = argument;\n                    } else if (opStr == null) {\n                        opStr = argument;\n                        break;\n                    }\n                }\n            }\n            if (packageName == null) {\n                err.println(\"Error: Package name not specified.\");\n                return -1;\n            } else if (opStr == null && reqOp) {\n                err.println(\"Error: Operation not specified.\");\n                return -1;\n            }\n            if (opStr != null) {\n                op = strOpToOp(opStr, err);\n                if (op < 0) {\n                    return -1;\n                }\n            } else {\n                op = AppOpsManager.OP_NONE;\n            }\n            if (userId == UserHandle.USER_CURRENT) {\n                userId = ActivityManager.getCurrentUser();\n            }\n            nonpackageUid = -1;\n            try {\n                nonpackageUid = Integer.parseInt(packageName);\n            } catch (NumberFormatException e) {\n            }\n            if (nonpackageUid == -1 && packageName.length() > 1 && packageName.charAt(0) == 'u'\n                    && packageName.indexOf('.') < 0) {\n                int i = 1;\n                while (i < packageName.length() && packageName.charAt(i) >= '0'\n                        && packageName.charAt(i) <= '9') {\n                    i++;\n                }\n                if (i > 1 && i < packageName.length()) {\n                    String userStr = packageName.substring(1, i);\n                    try {\n                        int user = Integer.parseInt(userStr);\n                        char type = packageName.charAt(i);\n                        i++;\n                        int startTypeVal = i;\n                        while (i < packageName.length() && packageName.charAt(i) >= '0'\n                                && packageName.charAt(i) <= '9') {\n                            i++;\n                        }\n                        if (i > startTypeVal) {\n                            String typeValStr = packageName.substring(startTypeVal, i);\n                            try {\n                                int typeVal = Integer.parseInt(typeValStr);\n                                if (type == 'a') {\n                                    nonpackageUid = UserHandle.getUid(user,\n                                            typeVal + Process.FIRST_APPLICATION_UID);\n                                } else if (type == 's') {\n                                    nonpackageUid = UserHandle.getUid(user, typeVal);\n                                }\n                            } catch (NumberFormatException e) {\n                            }\n                        }\n                    } catch (NumberFormatException e) {\n                    }\n                }\n            }\n            if (nonpackageUid != -1) {\n                packageName = null;\n            } else {\n                packageUid = resolveUid(packageName);\n                if (packageUid < 0) {\n                    packageUid = AppGlobals.getPackageManager().getPackageUid(packageName,\n                            PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);\n                }\n                if (packageUid < 0) {\n                    err.println(\"Error: No UID for \" + packageName + \" in user \" + userId);\n                    return -1;\n                }\n            }\n            return 0;\n        }\n    }\n\n    @Override public void onShellCommand(FileDescriptor in, FileDescriptor out,\n            FileDescriptor err, String[] args, ShellCallback callback,\n            ResultReceiver resultReceiver) {\n        (new Shell(this, this)).exec(this, in, out, err, args, callback, resultReceiver);\n    }\n\n    static void dumpCommandHelp(PrintWriter pw) {\n        pw.println(\"AppOps service (appops) commands:\");\n        pw.println(\"  help\");\n        pw.println(\"    Print this help text.\");\n        pw.println(\"  start [--user <USER_ID>] [--attribution <ATTRIBUTION_TAG>] <PACKAGE | UID> \"\n                + \"<OP> \");\n        pw.println(\"    Starts a given operation for a particular application.\");\n        pw.println(\"  stop [--user <USER_ID>] [--attribution <ATTRIBUTION_TAG>] <PACKAGE | UID> \"\n                + \"<OP> \");\n        pw.println(\"    Stops a given operation for a particular application.\");\n        pw.println(\"  set [--user <USER_ID>] <[--uid] PACKAGE | UID> <OP> <MODE>\");\n        pw.println(\"    Set the mode for a particular application and operation.\");\n        pw.println(\"  get [--user <USER_ID>] [--attribution <ATTRIBUTION_TAG>] <PACKAGE | UID> \"\n                + \"[<OP>]\");\n        pw.println(\"    Return the mode for a particular application and optional operation.\");\n        pw.println(\"  query-op [--user <USER_ID>] <OP> [<MODE>]\");\n        pw.println(\"    Print all packages that currently have the given op in the given mode.\");\n        pw.println(\"  reset [--user <USER_ID>] [<PACKAGE>]\");\n        pw.println(\"    Reset the given application or all applications to default modes.\");\n        pw.println(\"  write-settings\");\n        pw.println(\"    Immediately write pending changes to storage.\");\n        pw.println(\"  read-settings\");\n        pw.println(\"    Read the last written settings, replacing current state in RAM.\");\n        pw.println(\"  options:\");\n        pw.println(\"    <PACKAGE> an Android package name or its UID if prefixed by --uid\");\n        pw.println(\"    <OP>      an AppOps operation.\");\n        pw.println(\"    <MODE>    one of allow, ignore, deny, or default\");\n        pw.println(\"    <USER_ID> the user id under which the package is installed. If --user is\");\n        pw.println(\"              not specified, the current user is assumed.\");\n    }\n\n    static int onShellCommand(Shell shell, String cmd) {\n        if (cmd == null) {\n            return shell.handleDefaultCommands(cmd);\n        }\n        PrintWriter pw = shell.getOutPrintWriter();\n        PrintWriter err = shell.getErrPrintWriter();\n        try {\n            switch (cmd) {\n                case \"set\": {\n                    int res = shell.parseUserPackageOp(true, err);\n                    if (res < 0) {\n                        return res;\n                    }\n                    String modeStr = shell.getNextArg();\n                    if (modeStr == null) {\n                        err.println(\"Error: Mode not specified.\");\n                        return -1;\n                    }\n\n                    final int mode = shell.strModeToMode(modeStr, err);\n                    if (mode < 0) {\n                        return -1;\n                    }\n\n                    if (!shell.targetsUid && shell.packageName != null) {\n                        shell.mInterface.setMode(shell.op, shell.packageUid, shell.packageName,\n                                mode);\n                    } else if (shell.targetsUid && shell.packageName != null) {\n                        try {\n                            final int uid = shell.mInternal.mContext.getPackageManager()\n                                    .getPackageUidAsUser(shell.packageName, shell.userId);\n                            shell.mInterface.setUidMode(shell.op, uid, mode);\n                        } catch (PackageManager.NameNotFoundException e) {\n                            return -1;\n                        }\n                    } else {\n                        shell.mInterface.setUidMode(shell.op, shell.nonpackageUid, mode);\n                    }\n                    return 0;\n                }\n                case \"get\": {\n                    int res = shell.parseUserPackageOp(false, err);\n                    if (res < 0) {\n                        return res;\n                    }\n\n                    List<AppOpsManager.PackageOps> ops = new ArrayList<>();\n                    if (shell.packageName != null) {\n                        // Uid mode overrides package mode, so make sure it's also reported\n                        List<AppOpsManager.PackageOps> r = shell.mInterface.getUidOps(\n                                shell.packageUid,\n                                shell.op != AppOpsManager.OP_NONE ? new int[]{shell.op} : null);\n                        if (r != null) {\n                            ops.addAll(r);\n                        }\n                        r = shell.mInterface.getOpsForPackage(\n                                shell.packageUid, shell.packageName,\n                                shell.op != AppOpsManager.OP_NONE ? new int[]{shell.op} : null);\n                        if (r != null) {\n                            ops.addAll(r);\n                        }\n                    } else {\n                        ops = shell.mInterface.getUidOps(\n                                shell.nonpackageUid,\n                                shell.op != AppOpsManager.OP_NONE ? new int[]{shell.op} : null);\n                    }\n                    if (ops == null || ops.size() <= 0) {\n                        pw.println(\"No operations.\");\n                        if (shell.op > AppOpsManager.OP_NONE && shell.op < AppOpsManager._NUM_OP) {\n                            pw.println(\"Default mode: \" + AppOpsManager.modeToName(\n                                    AppOpsManager.opToDefaultMode(shell.op)));\n                        }\n                        return 0;\n                    }\n                    final long now = System.currentTimeMillis();\n                    for (int i=0; i<ops.size(); i++) {\n                        AppOpsManager.PackageOps packageOps = ops.get(i);\n                        if (packageOps.getPackageName() == null) {\n                            pw.print(\"Uid mode: \");\n                        }\n                        List<AppOpsManager.OpEntry> entries = packageOps.getOps();\n                        for (int j=0; j<entries.size(); j++) {\n                            AppOpsManager.OpEntry ent = entries.get(j);\n                            pw.print(AppOpsManager.opToName(ent.getOp()));\n                            pw.print(\": \");\n                            pw.print(AppOpsManager.modeToName(ent.getMode()));\n                            if (shell.attributionTag == null) {\n                                if (ent.getLastAccessTime(OP_FLAGS_ALL) != -1) {\n                                    pw.print(\"; time=\");\n                                    TimeUtils.formatDuration(\n                                            now - ent.getLastAccessTime(OP_FLAGS_ALL), pw);\n                                    pw.print(\" ago\");\n                                }\n                                if (ent.getLastRejectTime(OP_FLAGS_ALL) != -1) {\n                                    pw.print(\"; rejectTime=\");\n                                    TimeUtils.formatDuration(\n                                            now - ent.getLastRejectTime(OP_FLAGS_ALL), pw);\n                                    pw.print(\" ago\");\n                                }\n                                if (ent.isRunning()) {\n                                    pw.print(\" (running)\");\n                                } else if (ent.getLastDuration(OP_FLAGS_ALL) != -1) {\n                                    pw.print(\"; duration=\");\n                                    TimeUtils.formatDuration(ent.getLastDuration(OP_FLAGS_ALL), pw);\n                                }\n                            } else {\n                                final AppOpsManager.AttributedOpEntry attributionEnt =\n                                        ent.getAttributedOpEntries().get(shell.attributionTag);\n                                if (attributionEnt != null) {\n                                    if (attributionEnt.getLastAccessTime(OP_FLAGS_ALL) != -1) {\n                                        pw.print(\"; time=\");\n                                        TimeUtils.formatDuration(\n                                                now - attributionEnt.getLastAccessTime(\n                                                        OP_FLAGS_ALL), pw);\n                                        pw.print(\" ago\");\n                                    }\n                                    if (attributionEnt.getLastRejectTime(OP_FLAGS_ALL) != -1) {\n                                        pw.print(\"; rejectTime=\");\n                                        TimeUtils.formatDuration(\n                                                now - attributionEnt.getLastRejectTime(\n                                                        OP_FLAGS_ALL), pw);\n                                        pw.print(\" ago\");\n                                    }\n                                    if (attributionEnt.isRunning()) {\n                                        pw.print(\" (running)\");\n                                    } else if (attributionEnt.getLastDuration(OP_FLAGS_ALL)\n                                            != -1) {\n                                        pw.print(\"; duration=\");\n                                        TimeUtils.formatDuration(\n                                                attributionEnt.getLastDuration(OP_FLAGS_ALL), pw);\n                                    }\n                                }\n                            }\n                            pw.println();\n                        }\n                    }\n                    return 0;\n                }\n                case \"query-op\": {\n                    int res = shell.parseUserOpMode(AppOpsManager.MODE_IGNORED, err);\n                    if (res < 0) {\n                        return res;\n                    }\n                    List<AppOpsManager.PackageOps> ops = shell.mInterface.getPackagesForOps(\n                            new int[] {shell.op});\n                    if (ops == null || ops.size() <= 0) {\n                        pw.println(\"No operations.\");\n                        return 0;\n                    }\n                    for (int i=0; i<ops.size(); i++) {\n                        final AppOpsManager.PackageOps pkg = ops.get(i);\n                        boolean hasMatch = false;\n                        final List<AppOpsManager.OpEntry> entries = ops.get(i).getOps();\n                        for (int j=0; j<entries.size(); j++) {\n                            AppOpsManager.OpEntry ent = entries.get(j);\n                            if (ent.getOp() == shell.op && ent.getMode() == shell.mode) {\n                                hasMatch = true;\n                                break;\n                            }\n                        }\n                        if (hasMatch) {\n                            pw.println(pkg.getPackageName());\n                        }\n                    }\n                    return 0;\n                }\n                case \"reset\": {\n                    String packageName = null;\n                    int userId = UserHandle.USER_CURRENT;\n                    for (String argument; (argument = shell.getNextArg()) != null;) {\n                        if (\"--user\".equals(argument)) {\n                            String userStr = shell.getNextArgRequired();\n                            userId = UserHandle.parseUserArg(userStr);\n                        } else {\n                            if (packageName == null) {\n                                packageName = argument;\n                            } else {\n                                err.println(\"Error: Unsupported argument: \" + argument);\n                                return -1;\n                            }\n                        }\n                    }\n\n                    if (userId == UserHandle.USER_CURRENT) {\n                        userId = ActivityManager.getCurrentUser();\n                    }\n\n                    shell.mInterface.resetAllModes(userId, packageName);\n                    pw.print(\"Reset all modes for: \");\n                    if (userId == UserHandle.USER_ALL) {\n                        pw.print(\"all users\");\n                    } else {\n                        pw.print(\"user \"); pw.print(userId);\n                    }\n                    pw.print(\", \");\n                    if (packageName == null) {\n                        pw.println(\"all packages\");\n                    } else {\n                        pw.print(\"package \"); pw.println(packageName);\n                    }\n                    return 0;\n                }\n                case \"write-settings\": {\n                    shell.mInternal.enforceManageAppOpsModes(Binder.getCallingPid(),\n                            Binder.getCallingUid(), -1);\n                    final long token = Binder.clearCallingIdentity();\n                    try {\n                        synchronized (shell.mInternal) {\n                            shell.mInternal.mHandler.removeCallbacks(shell.mInternal.mWriteRunner);\n                        }\n                        shell.mInternal.writeRecentAccesses();\n                        shell.mInternal.mAppOpsCheckingService.writeState();\n                        pw.println(\"Current settings written.\");\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                    return 0;\n                }\n                case \"read-settings\": {\n                    shell.mInternal.enforceManageAppOpsModes(Binder.getCallingPid(),\n                            Binder.getCallingUid(), -1);\n                    final long token = Binder.clearCallingIdentity();\n                    try {\n                        shell.mInternal.readRecentAccesses();\n                        shell.mInternal.mAppOpsCheckingService.readState();\n                        pw.println(\"Last settings read.\");\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                    return 0;\n                }\n                case \"start\": {\n                    int res = shell.parseUserPackageOp(true, err);\n                    if (res < 0) {\n                        return res;\n                    }\n\n                    if (shell.packageName != null) {\n                        shell.mInterface.startOperation(shell.mToken, shell.op, shell.packageUid,\n                                shell.packageName, shell.attributionTag, true, true,\n                                \"appops start shell command\", true,\n                                AppOpsManager.ATTRIBUTION_FLAG_ACCESSOR, ATTRIBUTION_CHAIN_ID_NONE);\n                    } else {\n                        return -1;\n                    }\n                    return 0;\n                }\n                case \"stop\": {\n                    int res = shell.parseUserPackageOp(true, err);\n                    if (res < 0) {\n                        return res;\n                    }\n\n                    if (shell.packageName != null) {\n                        shell.mInterface.finishOperation(shell.mToken, shell.op, shell.packageUid,\n                                shell.packageName, shell.attributionTag);\n                    } else {\n                        return -1;\n                    }\n                    return 0;\n                }\n                default:\n                    return shell.handleDefaultCommands(cmd);\n            }\n        } catch (RemoteException e) {\n            pw.println(\"Remote exception: \" + e);\n        }\n        return -1;\n    }\n\n    private void dumpHelp(PrintWriter pw) {\n        pw.println(\"AppOps service (appops) dump options:\");\n        pw.println(\"  -h\");\n        pw.println(\"    Print this help text.\");\n        pw.println(\"  --op [OP]\");\n        pw.println(\"    Limit output to data associated with the given app op code.\");\n        pw.println(\"  --mode [MODE]\");\n        pw.println(\"    Limit output to data associated with the given app op mode.\");\n        pw.println(\"  --package [PACKAGE]\");\n        pw.println(\"    Limit output to data associated with the given package name.\");\n        pw.println(\"  --attributionTag [attributionTag]\");\n        pw.println(\"    Limit output to data associated with the given attribution tag.\");\n        pw.println(\"  --include-discrete [n]\");\n        pw.println(\"    Include discrete ops limited to n per dimension. Use zero for no limit.\");\n        pw.println(\"  --watchers\");\n        pw.println(\"    Only output the watcher sections.\");\n        pw.println(\"  --history\");\n        pw.println(\"    Only output history.\");\n        pw.println(\"  --uid-state-changes\");\n        pw.println(\"    Include logs about uid state changes.\");\n    }\n\n    private void dumpStatesLocked(@NonNull PrintWriter pw, @Nullable String filterAttributionTag,\n            @HistoricalOpsRequestFilter int filter, long nowElapsed, @NonNull Op op, long now,\n            @NonNull SimpleDateFormat sdf, @NonNull Date date, @NonNull String prefix) {\n        final int numAttributions = op.mAttributions.size();\n        for (int i = 0; i < numAttributions; i++) {\n            if ((filter & FILTER_BY_ATTRIBUTION_TAG) != 0 && !Objects.equals(\n                    op.mAttributions.keyAt(i), filterAttributionTag)) {\n                continue;\n            }\n\n            pw.print(prefix + op.mAttributions.keyAt(i) + \"=[\\n\");\n            dumpStatesLocked(pw, nowElapsed, op, op.mAttributions.keyAt(i), now, sdf, date,\n                    prefix + \"  \");\n            pw.print(prefix + \"]\\n\");\n        }\n    }\n\n    private void dumpStatesLocked(@NonNull PrintWriter pw, long nowElapsed, @NonNull Op op,\n            @Nullable String attributionTag, long now, @NonNull SimpleDateFormat sdf,\n            @NonNull Date date, @NonNull String prefix) {\n\n        final AttributedOpEntry entry = op.createSingleAttributionEntryLocked(\n                attributionTag).getAttributedOpEntries().get(attributionTag);\n\n        final ArraySet<Long> keys = entry.collectKeys();\n\n        final int keyCount = keys.size();\n        for (int k = 0; k < keyCount; k++) {\n            final long key = keys.valueAt(k);\n\n            final int uidState = AppOpsManager.extractUidStateFromKey(key);\n            final int flags = AppOpsManager.extractFlagsFromKey(key);\n\n            final long accessTime = entry.getLastAccessTime(uidState, uidState, flags);\n            final long rejectTime = entry.getLastRejectTime(uidState, uidState, flags);\n            final long accessDuration = entry.getLastDuration(uidState, uidState, flags);\n            final OpEventProxyInfo proxy = entry.getLastProxyInfo(uidState, uidState, flags);\n\n            String proxyPkg = null;\n            String proxyAttributionTag = null;\n            int proxyUid = Process.INVALID_UID;\n            if (proxy != null) {\n                proxyPkg = proxy.getPackageName();\n                proxyAttributionTag = proxy.getAttributionTag();\n                proxyUid = proxy.getUid();\n            }\n\n            if (accessTime > 0) {\n                pw.print(prefix);\n                pw.print(\"Access: \");\n                pw.print(AppOpsManager.keyToString(key));\n                pw.print(\" \");\n                date.setTime(accessTime);\n                pw.print(sdf.format(date));\n                pw.print(\" (\");\n                TimeUtils.formatDuration(accessTime - now, pw);\n                pw.print(\")\");\n                if (accessDuration > 0) {\n                    pw.print(\" duration=\");\n                    TimeUtils.formatDuration(accessDuration, pw);\n                }\n                if (proxyUid >= 0) {\n                    pw.print(\" proxy[\");\n                    pw.print(\"uid=\");\n                    pw.print(proxyUid);\n                    pw.print(\", pkg=\");\n                    pw.print(proxyPkg);\n                    pw.print(\", attributionTag=\");\n                    pw.print(proxyAttributionTag);\n                    pw.print(\"]\");\n                }\n                pw.println();\n            }\n\n            if (rejectTime > 0) {\n                pw.print(prefix);\n                pw.print(\"Reject: \");\n                pw.print(AppOpsManager.keyToString(key));\n                date.setTime(rejectTime);\n                pw.print(sdf.format(date));\n                pw.print(\" (\");\n                TimeUtils.formatDuration(rejectTime - now, pw);\n                pw.print(\")\");\n                if (proxyUid >= 0) {\n                    pw.print(\" proxy[\");\n                    pw.print(\"uid=\");\n                    pw.print(proxyUid);\n                    pw.print(\", pkg=\");\n                    pw.print(proxyPkg);\n                    pw.print(\", attributionTag=\");\n                    pw.print(proxyAttributionTag);\n                    pw.print(\"]\");\n                }\n                pw.println();\n            }\n        }\n\n        final AttributedOp attributedOp = op.mAttributions.get(attributionTag);\n        if (attributedOp.isRunning()) {\n            long earliestElapsedTime = Long.MAX_VALUE;\n            long maxNumStarts = 0;\n            int numInProgressEvents = attributedOp.mInProgressEvents.size();\n            for (int i = 0; i < numInProgressEvents; i++) {\n                AttributedOp.InProgressStartOpEvent event =\n                        attributedOp.mInProgressEvents.valueAt(i);\n\n                earliestElapsedTime = Math.min(earliestElapsedTime, event.getStartElapsedTime());\n                maxNumStarts = Math.max(maxNumStarts, event.mNumUnfinishedStarts);\n            }\n\n            pw.print(prefix + \"Running start at: \");\n            TimeUtils.formatDuration(nowElapsed - earliestElapsedTime, pw);\n            pw.println();\n\n            if (maxNumStarts > 1) {\n                pw.print(prefix + \"startNesting=\");\n                pw.println(maxNumStarts);\n            }\n        }\n    }\n\n    @NeverCompile // Avoid size overhead of debugging code.\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {\n        if (!DumpUtils.checkDumpAndUsageStatsPermission(mContext, TAG, pw)) return;\n\n        int dumpOp = OP_NONE;\n        String dumpPackage = null;\n        String dumpAttributionTag = null;\n        int dumpUid = Process.INVALID_UID;\n        int dumpMode = -1;\n        boolean dumpWatchers = false;\n        // TODO ntmyren: Remove the dumpHistory and dumpFilter\n        boolean dumpHistory = false;\n        boolean includeDiscreteOps = false;\n        boolean dumpUidStateChangeLogs = false;\n        int nDiscreteOps = 10;\n        @HistoricalOpsRequestFilter int dumpFilter = 0;\n        boolean dumpAll = false;\n\n        if (args != null) {\n            for (int i = 0; i < args.length; i++) {\n                String arg = args[i];\n                if (\"-h\".equals(arg)) {\n                    dumpHelp(pw);\n                    return;\n                } else if (\"-a\".equals(arg)) {\n                    // dump all data\n                    dumpAll = true;\n                } else if (\"--op\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --op option\");\n                        return;\n                    }\n                    dumpOp = Shell.strOpToOp(args[i], pw);\n                    dumpFilter |= FILTER_BY_OP_NAMES;\n                    if (dumpOp < 0) {\n                        return;\n                    }\n                } else if (\"--package\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --package option\");\n                        return;\n                    }\n                    dumpPackage = args[i];\n                    dumpFilter |= FILTER_BY_PACKAGE_NAME;\n                    try {\n                        dumpUid = AppGlobals.getPackageManager().getPackageUid(dumpPackage,\n                                PackageManager.MATCH_KNOWN_PACKAGES | PackageManager.MATCH_INSTANT,\n                                0);\n                    } catch (RemoteException e) {\n                    }\n                    if (dumpUid < 0) {\n                        pw.println(\"Unknown package: \" + dumpPackage);\n                        return;\n                    }\n                    dumpUid = UserHandle.getAppId(dumpUid);\n                    dumpFilter |= FILTER_BY_UID;\n                } else if (\"--attributionTag\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --attributionTag option\");\n                        return;\n                    }\n                    dumpAttributionTag = args[i];\n                    dumpFilter |= FILTER_BY_ATTRIBUTION_TAG;\n                } else if (\"--mode\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --mode option\");\n                        return;\n                    }\n                    dumpMode = Shell.strModeToMode(args[i], pw);\n                    if (dumpMode < 0) {\n                        return;\n                    }\n                } else if (\"--watchers\".equals(arg)) {\n                    dumpWatchers = true;\n                } else if (\"--include-discrete\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --include-discrete option\");\n                        return;\n                    }\n                    try {\n                        nDiscreteOps = Integer.valueOf(args[i]);\n                    } catch (NumberFormatException e) {\n                        pw.println(\"Wrong parameter: \" + args[i]);\n                        return;\n                    }\n                    includeDiscreteOps = true;\n                } else if (\"--history\".equals(arg)) {\n                    dumpHistory = true;\n                } else if (arg.length() > 0 && arg.charAt(0) == '-') {\n                    pw.println(\"Unknown option: \" + arg);\n                    return;\n                } else if (\"--uid-state-changes\".equals(arg)) {\n                    dumpUidStateChangeLogs = true;\n                } else {\n                    pw.println(\"Unknown command: \" + arg);\n                    return;\n                }\n            }\n        }\n\n        final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\");\n        final Date date = new Date();\n        synchronized (this) {\n            pw.println(\"Current AppOps Service state:\");\n            if (!dumpHistory && !dumpWatchers) {\n                mConstants.dump(pw);\n            }\n            pw.println();\n            final long now = System.currentTimeMillis();\n            final long nowElapsed = SystemClock.elapsedRealtime();\n            final long nowUptime = SystemClock.uptimeMillis();\n            boolean needSep = false;\n            if (dumpFilter == 0 && dumpMode < 0 && mProfileOwners != null && !dumpWatchers\n                    && !dumpHistory) {\n                pw.println(\"  Profile owners:\");\n                for (int poi = 0; poi < mProfileOwners.size(); poi++) {\n                    pw.print(\"    User #\");\n                    pw.print(mProfileOwners.keyAt(poi));\n                    pw.print(\": \");\n                    UserHandle.formatUid(pw, mProfileOwners.valueAt(poi));\n                    pw.println();\n                }\n                pw.println();\n            }\n\n            if (!dumpHistory) {\n                needSep |= mAppOpsCheckingService.dumpListeners(dumpOp, dumpUid, dumpPackage, pw);\n            }\n\n            if (mModeWatchers.size() > 0 && dumpOp < 0 && !dumpHistory) {\n                boolean printedHeader = false;\n                for (int i = 0; i < mModeWatchers.size(); i++) {\n                    final ModeCallback cb = mModeWatchers.valueAt(i);\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.getWatchingUid())) {\n                        continue;\n                    }\n                    needSep = true;\n                    if (!printedHeader) {\n                        pw.println(\"  All op mode watchers:\");\n                        printedHeader = true;\n                    }\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(mModeWatchers.keyAt(i))));\n                    pw.print(\": \"); pw.println(cb);\n                }\n            }\n            if (mActiveWatchers.size() > 0 && dumpMode < 0) {\n                needSep = true;\n                boolean printedHeader = false;\n                for (int watcherNum = 0; watcherNum < mActiveWatchers.size(); watcherNum++) {\n                    final SparseArray<ActiveCallback> activeWatchers =\n                            mActiveWatchers.valueAt(watcherNum);\n                    if (activeWatchers.size() <= 0) {\n                        continue;\n                    }\n                    final ActiveCallback cb = activeWatchers.valueAt(0);\n                    if (dumpOp >= 0 && activeWatchers.indexOfKey(dumpOp) < 0) {\n                        continue;\n                    }\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.mWatchingUid)) {\n                        continue;\n                    }\n                    if (!printedHeader) {\n                        pw.println(\"  All op active watchers:\");\n                        printedHeader = true;\n                    }\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(\n                            mActiveWatchers.keyAt(watcherNum))));\n                    pw.println(\" ->\");\n                    pw.print(\"        [\");\n                    final int opCount = activeWatchers.size();\n                    for (int opNum = 0; opNum < opCount; opNum++) {\n                        if (opNum > 0) {\n                            pw.print(' ');\n                        }\n                        pw.print(AppOpsManager.opToName(activeWatchers.keyAt(opNum)));\n                        if (opNum < opCount - 1) {\n                            pw.print(',');\n                        }\n                    }\n                    pw.println(\"]\");\n                    pw.print(\"        \");\n                    pw.println(cb);\n                }\n            }\n            if (mStartedWatchers.size() > 0 && dumpMode < 0) {\n                needSep = true;\n                boolean printedHeader = false;\n\n                final int watchersSize = mStartedWatchers.size();\n                for (int watcherNum = 0; watcherNum < watchersSize; watcherNum++) {\n                    final SparseArray<StartedCallback> startedWatchers =\n                            mStartedWatchers.valueAt(watcherNum);\n                    if (startedWatchers.size() <= 0) {\n                        continue;\n                    }\n\n                    final StartedCallback cb = startedWatchers.valueAt(0);\n                    if (dumpOp >= 0 && startedWatchers.indexOfKey(dumpOp) < 0) {\n                        continue;\n                    }\n\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.mWatchingUid)) {\n                        continue;\n                    }\n\n                    if (!printedHeader) {\n                        pw.println(\"  All op started watchers:\");\n                        printedHeader = true;\n                    }\n\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(\n                            mStartedWatchers.keyAt(watcherNum))));\n                    pw.println(\" ->\");\n\n                    pw.print(\"        [\");\n                    final int opCount = startedWatchers.size();\n                    for (int opNum = 0; opNum < opCount; opNum++) {\n                        if (opNum > 0) {\n                            pw.print(' ');\n                        }\n\n                        pw.print(AppOpsManager.opToName(startedWatchers.keyAt(opNum)));\n                        if (opNum < opCount - 1) {\n                            pw.print(',');\n                        }\n                    }\n                    pw.println(\"]\");\n\n                    pw.print(\"        \");\n                    pw.println(cb);\n                }\n            }\n            if (mNotedWatchers.size() > 0 && dumpMode < 0) {\n                needSep = true;\n                boolean printedHeader = false;\n                for (int watcherNum = 0; watcherNum < mNotedWatchers.size(); watcherNum++) {\n                    final SparseArray<NotedCallback> notedWatchers =\n                            mNotedWatchers.valueAt(watcherNum);\n                    if (notedWatchers.size() <= 0) {\n                        continue;\n                    }\n                    final NotedCallback cb = notedWatchers.valueAt(0);\n                    if (dumpOp >= 0 && notedWatchers.indexOfKey(dumpOp) < 0) {\n                        continue;\n                    }\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.mWatchingUid)) {\n                        continue;\n                    }\n                    if (!printedHeader) {\n                        pw.println(\"  All op noted watchers:\");\n                        printedHeader = true;\n                    }\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(\n                            mNotedWatchers.keyAt(watcherNum))));\n                    pw.println(\" ->\");\n                    pw.print(\"        [\");\n                    final int opCount = notedWatchers.size();\n                    for (int opNum = 0; opNum < opCount; opNum++) {\n                        if (opNum > 0) {\n                            pw.print(' ');\n                        }\n                        pw.print(AppOpsManager.opToName(notedWatchers.keyAt(opNum)));\n                        if (opNum < opCount - 1) {\n                            pw.print(',');\n                        }\n                    }\n                    pw.println(\"]\");\n                    pw.print(\"        \");\n                    pw.println(cb);\n                }\n            }\n            if (mAudioRestrictionManager.hasActiveRestrictions() && dumpOp < 0\n                    && dumpPackage != null && dumpMode < 0 && !dumpWatchers) {\n                needSep = mAudioRestrictionManager.dump(pw) || needSep;\n            }\n            if (needSep) {\n                pw.println();\n            }\n            for (int i=0; i<mUidStates.size(); i++) {\n                UidState uidState = mUidStates.valueAt(i);\n                final SparseIntArray opModes = uidState.getNonDefaultUidModes();\n                final ArrayMap<String, Ops> pkgOps = uidState.pkgOps;\n\n                if (dumpWatchers || dumpHistory) {\n                    continue;\n                }\n                if (dumpOp >= 0 || dumpPackage != null || dumpMode >= 0) {\n                    boolean hasOp = dumpOp < 0 || (opModes != null\n                            && opModes.indexOfKey(dumpOp) >= 0);\n                    boolean hasPackage = dumpPackage == null || dumpUid == mUidStates.keyAt(i);\n                    boolean hasMode = dumpMode < 0;\n                    if (!hasMode && opModes != null) {\n                        for (int opi = 0; !hasMode && opi < opModes.size(); opi++) {\n                            if (opModes.valueAt(opi) == dumpMode) {\n                                hasMode = true;\n                            }\n                        }\n                    }\n                    if (pkgOps != null) {\n                        for (int pkgi = 0;\n                                 (!hasOp || !hasPackage || !hasMode) && pkgi < pkgOps.size();\n                                 pkgi++) {\n                            Ops ops = pkgOps.valueAt(pkgi);\n                            if (!hasOp && ops != null && ops.indexOfKey(dumpOp) >= 0) {\n                                hasOp = true;\n                            }\n                            if (!hasMode) {\n                                for (int opi = 0; !hasMode && opi < ops.size(); opi++) {\n                                    if (ops.valueAt(opi).getMode() == dumpMode) {\n                                        hasMode = true;\n                                    }\n                                }\n                            }\n                            if (!hasPackage && dumpPackage.equals(ops.packageName)) {\n                                hasPackage = true;\n                            }\n                        }\n                    }\n                    if (uidState.foregroundOps != null && !hasOp) {\n                        if (uidState.foregroundOps.indexOfKey(dumpOp) > 0) {\n                            hasOp = true;\n                        }\n                    }\n                    if (!hasOp || !hasPackage || !hasMode) {\n                        continue;\n                    }\n                }\n\n                pw.print(\"  Uid \"); UserHandle.formatUid(pw, uidState.uid); pw.println(\":\");\n                uidState.dump(pw, nowElapsed);\n                if (uidState.foregroundOps != null && (dumpMode < 0\n                        || dumpMode == AppOpsManager.MODE_FOREGROUND)) {\n                    pw.println(\"    foregroundOps:\");\n                    for (int j = 0; j < uidState.foregroundOps.size(); j++) {\n                        if (dumpOp >= 0 && dumpOp != uidState.foregroundOps.keyAt(j)) {\n                            continue;\n                        }\n                        pw.print(\"      \");\n                        pw.print(AppOpsManager.opToName(uidState.foregroundOps.keyAt(j)));\n                        pw.print(\": \");\n                        pw.println(uidState.foregroundOps.valueAt(j) ? \"WATCHER\" : \"SILENT\");\n                    }\n                    pw.print(\"    hasForegroundWatchers=\");\n                    pw.println(uidState.hasForegroundWatchers);\n                }\n                needSep = true;\n\n                if (opModes != null) {\n                    final int opModeCount = opModes.size();\n                    for (int j = 0; j < opModeCount; j++) {\n                        final int code = opModes.keyAt(j);\n                        final int mode = opModes.valueAt(j);\n                        if (dumpOp >= 0 && dumpOp != code) {\n                            continue;\n                        }\n                        if (dumpMode >= 0 && dumpMode != mode) {\n                            continue;\n                        }\n                        pw.print(\"      \"); pw.print(AppOpsManager.opToName(code));\n                        pw.print(\": mode=\"); pw.println(AppOpsManager.modeToName(mode));\n                    }\n                }\n\n                if (pkgOps == null) {\n                    continue;\n                }\n\n                for (int pkgi = 0; pkgi < pkgOps.size(); pkgi++) {\n                    final Ops ops = pkgOps.valueAt(pkgi);\n                    if (dumpPackage != null && !dumpPackage.equals(ops.packageName)) {\n                        continue;\n                    }\n                    boolean printedPackage = false;\n                    for (int j=0; j<ops.size(); j++) {\n                        final Op op = ops.valueAt(j);\n                        final int opCode = op.op;\n                        if (dumpOp >= 0 && dumpOp != opCode) {\n                            continue;\n                        }\n                        if (dumpMode >= 0 && dumpMode != op.getMode()) {\n                            continue;\n                        }\n                        if (!printedPackage) {\n                            pw.print(\"    Package \"); pw.print(ops.packageName); pw.println(\":\");\n                            printedPackage = true;\n                        }\n                        pw.print(\"      \"); pw.print(AppOpsManager.opToName(opCode));\n                        pw.print(\" (\"); pw.print(AppOpsManager.modeToName(op.getMode()));\n                        final int switchOp = AppOpsManager.opToSwitch(opCode);\n                        if (switchOp != opCode) {\n                            pw.print(\" / switch \");\n                            pw.print(AppOpsManager.opToName(switchOp));\n                            final Op switchObj = ops.get(switchOp);\n                            int mode = switchObj == null\n                                    ? AppOpsManager.opToDefaultMode(switchOp) : switchObj.getMode();\n                            pw.print(\"=\"); pw.print(AppOpsManager.modeToName(mode));\n                        }\n                        pw.println(\"): \");\n                        dumpStatesLocked(pw, dumpAttributionTag, dumpFilter, nowElapsed, op, now,\n                                sdf, date, \"        \");\n                    }\n                }\n            }\n            if (needSep) {\n                pw.println();\n            }\n\n            boolean showUserRestrictions = !(dumpMode < 0 && !dumpWatchers && !dumpHistory);\n            mAppOpsRestrictions.dumpRestrictions(pw, dumpOp, dumpPackage, showUserRestrictions);\n\n            if (!dumpHistory && !dumpWatchers) {\n                pw.println();\n                if (mCheckOpsDelegateDispatcher.mPolicy != null\n                        && mCheckOpsDelegateDispatcher.mPolicy instanceof AppOpsPolicy) {\n                    AppOpsPolicy policy = (AppOpsPolicy) mCheckOpsDelegateDispatcher.mPolicy;\n                    policy.dumpTags(pw);\n                } else {\n                    pw.println(\"  AppOps policy not set.\");\n                }\n            }\n\n            if (dumpAll || dumpUidStateChangeLogs) {\n                pw.println();\n                pw.println(\"Uid State Changes Event Log:\");\n                getUidStateTracker().dumpEvents(pw);\n            }\n        }\n\n        // Must not hold the appops lock\n        if (dumpHistory && !dumpWatchers) {\n            mHistoricalRegistry.dump(\"  \", pw, dumpUid, dumpPackage, dumpAttributionTag, dumpOp,\n                    dumpFilter);\n        }\n        if (includeDiscreteOps) {\n            pw.println(\"Discrete accesses: \");\n            mHistoricalRegistry.dumpDiscreteData(pw, dumpUid, dumpPackage, dumpAttributionTag,\n                    dumpFilter, dumpOp, sdf, date, \"  \", nDiscreteOps);\n        }\n    }\n\n    @Override\n    public void setUserRestrictions(Bundle restrictions, IBinder token, int userHandle) {\n        checkSystemUid(\"setUserRestrictions\");\n        Objects.requireNonNull(restrictions);\n        Objects.requireNonNull(token);\n        for (int i = 0; i < AppOpsManager._NUM_OP; i++) {\n            String restriction = AppOpsManager.opToRestriction(i);\n            if (restriction != null) {\n                setUserRestrictionNoCheck(i, restrictions.getBoolean(restriction, false), token,\n                        userHandle, null);\n            }\n        }\n    }\n\n    @Override\n    public void setUserRestriction(int code, boolean restricted, IBinder token, int userHandle,\n            PackageTagsList excludedPackageTags) {\n        if (Binder.getCallingPid() != Process.myPid()) {\n            mContext.enforcePermission(Manifest.permission.MANAGE_APP_OPS_RESTRICTIONS,\n                    Binder.getCallingPid(), Binder.getCallingUid(), null);\n        }\n        if (userHandle != UserHandle.getCallingUserId()) {\n            if (mContext.checkCallingOrSelfPermission(Manifest.permission\n                    .INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED\n                && mContext.checkCallingOrSelfPermission(Manifest.permission\n                    .INTERACT_ACROSS_USERS) != PackageManager.PERMISSION_GRANTED) {\n                throw new SecurityException(\"Need INTERACT_ACROSS_USERS_FULL or\"\n                        + \" INTERACT_ACROSS_USERS to interact cross user \");\n            }\n        }\n        verifyIncomingOp(code);\n        Objects.requireNonNull(token);\n        setUserRestrictionNoCheck(code, restricted, token, userHandle, excludedPackageTags);\n    }\n\n    private void setUserRestrictionNoCheck(int code, boolean restricted, IBinder token,\n            int userHandle, PackageTagsList excludedPackageTags) {\n        synchronized (AppOpsService.this) {\n            ClientUserRestrictionState restrictionState = mOpUserRestrictions.get(token);\n\n            if (restrictionState == null) {\n                try {\n                    restrictionState = new ClientUserRestrictionState(token);\n                } catch (RemoteException e) {\n                    return;\n                }\n                mOpUserRestrictions.put(token, restrictionState);\n            }\n\n            if (restrictionState.setRestriction(code, restricted, excludedPackageTags,\n                    userHandle)) {\n                mHandler.sendMessage(PooledLambda.obtainMessage(\n                        AppOpsService::notifyWatchersOfChange, this, code, UID_ANY));\n                mHandler.sendMessage(PooledLambda.obtainMessage(\n                        AppOpsService::updateStartedOpModeForUser, this, code, restricted,\n                        userHandle));\n            }\n\n            if (restrictionState.isDefault()) {\n                mOpUserRestrictions.remove(token);\n                restrictionState.destroy();\n            }\n        }\n    }\n\n    private void updateStartedOpModeForUser(int code, boolean restricted, int userId) {\n        synchronized (AppOpsService.this) {\n            int numUids = mUidStates.size();\n            for (int uidNum = 0; uidNum < numUids; uidNum++) {\n                int uid = mUidStates.keyAt(uidNum);\n                if (userId != UserHandle.USER_ALL && UserHandle.getUserId(uid) != userId) {\n                    continue;\n                }\n                updateStartedOpModeForUidLocked(code, restricted, uid);\n            }\n        }\n    }\n\n    private void updateStartedOpModeForUidLocked(int code, boolean restricted, int uid) {\n        UidState uidState = mUidStates.get(uid);\n        if (uidState == null) {\n            return;\n        }\n\n        int numPkgOps = uidState.pkgOps.size();\n        for (int pkgNum = 0; pkgNum < numPkgOps; pkgNum++) {\n            Ops ops = uidState.pkgOps.valueAt(pkgNum);\n            Op op = ops != null ? ops.get(code) : null;\n            if (op == null || (op.getMode() != MODE_ALLOWED && op.getMode() != MODE_FOREGROUND)) {\n                continue;\n            }\n            int numAttrTags = op.mAttributions.size();\n            for (int attrNum = 0; attrNum < numAttrTags; attrNum++) {\n                AttributedOp attrOp = op.mAttributions.valueAt(attrNum);\n                if (restricted && attrOp.isRunning()) {\n                    attrOp.pause();\n                } else if (attrOp.isPaused()) {\n                    attrOp.resume();\n                }\n            }\n        }\n    }\n\n    private void notifyWatchersOfChange(int code, int uid) {\n        final ArraySet<OnOpModeChangedListener> modeChangedListenerSet;\n        synchronized (this) {\n            modeChangedListenerSet = mAppOpsCheckingService.getOpModeChangedListeners(code);\n            if (modeChangedListenerSet == null) {\n                return;\n            }\n        }\n\n        notifyOpChanged(modeChangedListenerSet,  code, uid, null);\n    }\n\n    @Override\n    public void removeUser(int userHandle) throws RemoteException {\n        checkSystemUid(\"removeUser\");\n        synchronized (AppOpsService.this) {\n            final int tokenCount = mOpUserRestrictions.size();\n            for (int i = tokenCount - 1; i >= 0; i--) {\n                ClientUserRestrictionState opRestrictions = mOpUserRestrictions.valueAt(i);\n                opRestrictions.removeUser(userHandle);\n            }\n            removeUidsForUserLocked(userHandle);\n        }\n    }\n\n    @Override\n    public boolean isOperationActive(int code, int uid, String packageName) {\n        if (Binder.getCallingUid() != uid) {\n            if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                    != PackageManager.PERMISSION_GRANTED) {\n                return false;\n            }\n        }\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return false;\n        }\n\n        final String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return false;\n        }\n        // TODO moltmann: Allow to check for attribution op activeness\n        synchronized (AppOpsService.this) {\n            Ops pkgOps = getOpsLocked(uid, resolvedPackageName, null, false, null, false);\n            if (pkgOps == null) {\n                return false;\n            }\n\n            Op op = pkgOps.get(code);\n            if (op == null) {\n                return false;\n            }\n\n            return op.isRunning();\n        }\n    }\n\n    @Override\n    public boolean isProxying(int op, @NonNull String proxyPackageName,\n            @NonNull String proxyAttributionTag, int proxiedUid,\n            @NonNull String proxiedPackageName) {\n        Objects.requireNonNull(proxyPackageName);\n        Objects.requireNonNull(proxiedPackageName);\n        final long callingUid = Binder.getCallingUid();\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final List<AppOpsManager.PackageOps> packageOps = getOpsForPackage(proxiedUid,\n                    proxiedPackageName, new int[] {op});\n            if (packageOps == null || packageOps.isEmpty()) {\n                return false;\n            }\n            final List<OpEntry> opEntries = packageOps.get(0).getOps();\n            if (opEntries.isEmpty()) {\n                return false;\n            }\n            final OpEntry opEntry = opEntries.get(0);\n            if (!opEntry.isRunning()) {\n                return false;\n            }\n            final OpEventProxyInfo proxyInfo = opEntry.getLastProxyInfo(\n                    OP_FLAG_TRUSTED_PROXIED | AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED);\n            return proxyInfo != null && callingUid == proxyInfo.getUid()\n                    && proxyPackageName.equals(proxyInfo.getPackageName())\n                    && Objects.equals(proxyAttributionTag, proxyInfo.getAttributionTag());\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    @Override\n    public void resetPackageOpsNoHistory(@NonNull String packageName) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"resetPackageOpsNoHistory\");\n        synchronized (AppOpsService.this) {\n            final int uid = mPackageManagerInternal.getPackageUid(packageName, 0,\n                    UserHandle.getCallingUserId());\n            if (uid == Process.INVALID_UID) {\n                return;\n            }\n            UidState uidState = mUidStates.get(uid);\n            if (uidState == null) {\n                return;\n            }\n            Ops removedOps = uidState.pkgOps.remove(packageName);\n            mAppOpsCheckingService.removePackage(packageName, UserHandle.getUserId(uid));\n            if (removedOps != null) {\n                scheduleFastWriteLocked();\n            }\n        }\n    }\n\n    @Override\n    public void setHistoryParameters(@AppOpsManager.HistoricalMode int mode,\n            long baseSnapshotInterval, int compressionStep) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"setHistoryParameters\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.setHistoryParameters(mode, baseSnapshotInterval, compressionStep);\n    }\n\n    @Override\n    public void offsetHistory(long offsetMillis) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"offsetHistory\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.offsetHistory(offsetMillis);\n        mHistoricalRegistry.offsetDiscreteHistory(offsetMillis);\n    }\n\n    @Override\n    public void addHistoricalOps(HistoricalOps ops) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"addHistoricalOps\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.addHistoricalOps(ops);\n    }\n\n    @Override\n    public void resetHistoryParameters() {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"resetHistoryParameters\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.resetHistoryParameters();\n    }\n\n    @Override\n    public void clearHistory() {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"clearHistory\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.clearAllHistory();\n    }\n\n    @Override\n    public void rebootHistory(long offlineDurationMillis) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"rebootHistory\");\n\n        Preconditions.checkArgument(offlineDurationMillis >= 0);\n\n        // Must not hold the appops lock\n        mHistoricalRegistry.shutdown();\n\n        if (offlineDurationMillis > 0) {\n            SystemClock.sleep(offlineDurationMillis);\n        }\n\n        mHistoricalRegistry = new HistoricalRegistry(mHistoricalRegistry);\n        mHistoricalRegistry.systemReady(mContext.getContentResolver());\n        mHistoricalRegistry.persistPendingHistory();\n    }\n\n    /**\n     * Report runtime access to AppOp together with message (including stack trace)\n     *\n     * @param packageName The package which reported the op\n     * @param notedAppOp contains code of op and attributionTag provided by developer\n     * @param message Message describing AppOp access (can be stack trace)\n     *\n     * @return Config for future sampling to reduce amount of reporting\n     */\n    @Override\n    public MessageSamplingConfig reportRuntimeAppOpAccessMessageAndGetConfig(\n            String packageName, SyncNotedAppOp notedAppOp, String message) {\n        int uid = Binder.getCallingUid();\n        Objects.requireNonNull(packageName);\n        synchronized (this) {\n            switchPackageIfBootTimeOrRarelyUsedLocked(packageName);\n            if (!packageName.equals(mSampledPackage)) {\n                return new MessageSamplingConfig(OP_NONE, 0,\n                        Instant.now().plus(1, ChronoUnit.HOURS).toEpochMilli());\n            }\n\n            Objects.requireNonNull(notedAppOp);\n            Objects.requireNonNull(message);\n\n            reportRuntimeAppOpAccessMessageInternalLocked(uid, packageName,\n                    AppOpsManager.strOpToOp(notedAppOp.getOp()),\n                    notedAppOp.getAttributionTag(), message);\n\n            return new MessageSamplingConfig(mSampledAppOpCode, mAcceptableLeftDistance,\n                    Instant.now().plus(1, ChronoUnit.HOURS).toEpochMilli());\n        }\n    }\n\n    /**\n     * Report runtime access to AppOp together with message (entry point for reporting\n     * asynchronous access)\n     * @param uid Uid of the package which reported the op\n     * @param packageName The package which reported the op\n     * @param opCode Code of AppOp\n     * @param attributionTag FeautreId of AppOp reported\n     * @param message Message describing AppOp access (can be stack trace)\n     */\n    private void reportRuntimeAppOpAccessMessageAsyncLocked(int uid,\n            @NonNull String packageName, int opCode, @Nullable String attributionTag,\n            @NonNull String message) {\n        switchPackageIfBootTimeOrRarelyUsedLocked(packageName);\n        if (!Objects.equals(mSampledPackage, packageName)) {\n            return;\n        }\n        reportRuntimeAppOpAccessMessageInternalLocked(uid, packageName, opCode, attributionTag,\n                message);\n    }\n\n    /**\n     * Decides whether reported message is within the range of watched AppOps and picks it for\n     * reporting uniformly at random across all received messages.\n     */\n    private void reportRuntimeAppOpAccessMessageInternalLocked(int uid,\n            @NonNull String packageName, int opCode, @Nullable String attributionTag,\n            @NonNull String message) {\n        int newLeftDistance = AppOpsManager.leftCircularDistance(opCode,\n                mSampledAppOpCode, _NUM_OP);\n\n        if (mAcceptableLeftDistance < newLeftDistance\n                && mSamplingStrategy != SAMPLING_STRATEGY_UNIFORM_OPS) {\n            return;\n        }\n\n        if (mAcceptableLeftDistance > newLeftDistance\n                && mSamplingStrategy != SAMPLING_STRATEGY_UNIFORM_OPS) {\n            mAcceptableLeftDistance = newLeftDistance;\n            mMessagesCollectedCount = 0.0f;\n        }\n\n        mMessagesCollectedCount += 1.0f;\n        if (ThreadLocalRandom.current().nextFloat() <= 1.0f / mMessagesCollectedCount) {\n            mCollectedRuntimePermissionMessage = new RuntimeAppOpAccessMessage(uid, opCode,\n                    packageName, attributionTag, message, mSamplingStrategy);\n        }\n        return;\n    }\n\n    /** Pulls current AppOps access report and resamples package and app op to watch */\n    @Override\n    public @Nullable RuntimeAppOpAccessMessage collectRuntimeAppOpAccessMessage() {\n        ActivityManagerInternal ami = LocalServices.getService(ActivityManagerInternal.class);\n        boolean isCallerInstrumented =\n                ami.getInstrumentationSourceUid(Binder.getCallingUid()) != Process.INVALID_UID;\n        boolean isCallerSystem = Binder.getCallingPid() == Process.myPid();\n        if (!isCallerSystem && !isCallerInstrumented) {\n            return null;\n        }\n        mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n        RuntimeAppOpAccessMessage result;\n        synchronized (this) {\n            result = mCollectedRuntimePermissionMessage;\n            mCollectedRuntimePermissionMessage = null;\n        }\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::getPackageListAndResample,\n                this));\n        return result;\n    }\n\n    /**\n     * Checks if package is in the list of rarely used package and starts watching the new package\n     * to collect incoming message or if collection is happening in first minutes since boot.\n     * @param packageName\n     */\n    private void switchPackageIfBootTimeOrRarelyUsedLocked(@NonNull String packageName) {\n        if (mSampledPackage == null) {\n            if (ThreadLocalRandom.current().nextFloat() < 0.5f) {\n                mSamplingStrategy = SAMPLING_STRATEGY_BOOT_TIME_SAMPLING;\n                resampleAppOpForPackageLocked(packageName, true);\n            }\n        } else if (mRarelyUsedPackages.contains(packageName)) {\n            mRarelyUsedPackages.remove(packageName);\n            if (ThreadLocalRandom.current().nextFloat() < 0.5f) {\n                mSamplingStrategy = SAMPLING_STRATEGY_RARELY_USED;\n                resampleAppOpForPackageLocked(packageName, true);\n            }\n        }\n    }\n\n    /** Obtains package list and resamples package and appop to watch. */\n    private List<String> getPackageListAndResample() {\n        List<String> packageNames = getPackageNamesForSampling();\n        synchronized (this) {\n            resamplePackageAndAppOpLocked(packageNames);\n        }\n        return packageNames;\n    }\n\n    /** Resamples package and appop to watch from the list provided. */\n    private void resamplePackageAndAppOpLocked(@NonNull List<String> packageNames) {\n        if (!packageNames.isEmpty()) {\n            if (ThreadLocalRandom.current().nextFloat() < 0.5f) {\n                mSamplingStrategy = SAMPLING_STRATEGY_UNIFORM;\n                resampleAppOpForPackageLocked(packageNames.get(\n                        ThreadLocalRandom.current().nextInt(packageNames.size())), true);\n            } else {\n                mSamplingStrategy = SAMPLING_STRATEGY_UNIFORM_OPS;\n                resampleAppOpForPackageLocked(packageNames.get(\n                        ThreadLocalRandom.current().nextInt(packageNames.size())), false);\n            }\n        }\n    }\n\n    /** Resamples appop for the chosen package and initializes sampling state */\n    private void resampleAppOpForPackageLocked(@NonNull String packageName, boolean pickOp) {\n        mMessagesCollectedCount = 0.0f;\n        mSampledAppOpCode = pickOp ? ThreadLocalRandom.current().nextInt(_NUM_OP) : OP_NONE;\n        mAcceptableLeftDistance = _NUM_OP - 1;\n        mSampledPackage = packageName;\n    }\n\n    /**\n     * Creates list of rarely used packages - packages which were not used over last week or\n     * which declared but did not use permissions over last week.\n     *  */\n    private void initializeRarelyUsedPackagesList(@NonNull ArraySet<String> candidates) {\n        AppOpsManager appOps = mContext.getSystemService(AppOpsManager.class);\n        List<String> runtimeAppOpsList = getRuntimeAppOpsList();\n        AppOpsManager.HistoricalOpsRequest histOpsRequest =\n                new AppOpsManager.HistoricalOpsRequest.Builder(\n                        Math.max(Instant.now().minus(7, ChronoUnit.DAYS).toEpochMilli(), 0),\n                        Long.MAX_VALUE).setOpNames(runtimeAppOpsList).setFlags(\n                        OP_FLAG_SELF | OP_FLAG_TRUSTED_PROXIED).build();\n        appOps.getHistoricalOps(histOpsRequest, AsyncTask.THREAD_POOL_EXECUTOR,\n                new Consumer<HistoricalOps>() {\n                    @Override\n                    public void accept(HistoricalOps histOps) {\n                        int uidCount = histOps.getUidCount();\n                        for (int uidIdx = 0; uidIdx < uidCount; uidIdx++) {\n                            final AppOpsManager.HistoricalUidOps uidOps = histOps.getUidOpsAt(\n                                    uidIdx);\n                            int pkgCount = uidOps.getPackageCount();\n                            for (int pkgIdx = 0; pkgIdx < pkgCount; pkgIdx++) {\n                                String packageName = uidOps.getPackageOpsAt(\n                                        pkgIdx).getPackageName();\n                                if (!candidates.contains(packageName)) {\n                                    continue;\n                                }\n                                AppOpsManager.HistoricalPackageOps packageOps =\n                                        uidOps.getPackageOpsAt(pkgIdx);\n                                if (packageOps.getOpCount() != 0) {\n                                    candidates.remove(packageName);\n                                }\n                            }\n                        }\n                        synchronized (this) {\n                            int numPkgs = mRarelyUsedPackages.size();\n                            for (int i = 0; i < numPkgs; i++) {\n                                candidates.add(mRarelyUsedPackages.valueAt(i));\n                            }\n                            mRarelyUsedPackages = candidates;\n                        }\n                    }\n                });\n    }\n\n    /** List of app ops related to runtime permissions */\n    private List<String> getRuntimeAppOpsList() {\n        ArrayList<String> result = new ArrayList();\n        for (int i = 0; i < _NUM_OP; i++) {\n            if (shouldCollectNotes(i)) {\n                result.add(opToPublicName(i));\n            }\n        }\n        return result;\n    }\n\n    /** Returns list of packages to be used for package sampling */\n    private @NonNull List<String> getPackageNamesForSampling() {\n        List<String> packageNames = new ArrayList<>();\n        PackageManagerInternal packageManagerInternal = LocalServices.getService(\n                PackageManagerInternal.class);\n        PackageList packages = packageManagerInternal.getPackageList();\n        for (String packageName : packages.getPackageNames()) {\n            PackageInfo pkg = packageManagerInternal.getPackageInfo(packageName,\n                    PackageManager.GET_PERMISSIONS, Process.myUid(), mContext.getUserId());\n            if (isSamplingTarget(pkg)) {\n                packageNames.add(pkg.packageName);\n            }\n        }\n        return packageNames;\n    }\n\n    /** Checks whether package should be included in sampling pool */\n    private boolean isSamplingTarget(@Nullable PackageInfo pkg) {\n        if (pkg == null) {\n            return false;\n        }\n        String[] requestedPermissions = pkg.requestedPermissions;\n        if (requestedPermissions == null) {\n            return false;\n        }\n        for (String permission : requestedPermissions) {\n            PermissionInfo permissionInfo;\n            try {\n                permissionInfo = mContext.getPackageManager().getPermissionInfo(permission, 0);\n            } catch (PackageManager.NameNotFoundException ignored) {\n                continue;\n            }\n            if (permissionInfo.getProtection() == PROTECTION_DANGEROUS) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @GuardedBy(\"this\")\n    private void removeUidsForUserLocked(int userHandle) {\n        for (int i = mUidStates.size() - 1; i >= 0; --i) {\n            final int uid = mUidStates.keyAt(i);\n            if (UserHandle.getUserId(uid) == userHandle) {\n                mUidStates.valueAt(i).clear();\n                mUidStates.removeAt(i);\n            }\n        }\n    }\n\n    private void checkSystemUid(String function) {\n        int uid = Binder.getCallingUid();\n        if (uid != Process.SYSTEM_UID) {\n            throw new SecurityException(function + \" must by called by the system\");\n        }\n    }\n\n    private static int resolveUid(String packageName)  {\n        if (packageName == null) {\n            return Process.INVALID_UID;\n        }\n        switch (packageName) {\n            case \"root\":\n                return Process.ROOT_UID;\n            case \"shell\":\n            case \"dumpstate\":\n                return Process.SHELL_UID;\n            case \"media\":\n                return Process.MEDIA_UID;\n            case \"audioserver\":\n                return Process.AUDIOSERVER_UID;\n            case \"cameraserver\":\n                return Process.CAMERASERVER_UID;\n        }\n        return Process.INVALID_UID;\n    }\n\n    private static String[] getPackagesForUid(int uid) {\n        String[] packageNames = null;\n\n        // Very early during boot the package manager is not yet or not yet fully started. At this\n        // time there are no packages yet.\n        if (AppGlobals.getPackageManager() != null) {\n            try {\n                packageNames = AppGlobals.getPackageManager().getPackagesForUid(uid);\n            } catch (RemoteException e) {\n                /* ignore - local call */\n            }\n        }\n        if (packageNames == null) {\n            return EmptyArray.STRING;\n        }\n        return packageNames;\n    }\n\n    private final class ClientUserRestrictionState implements DeathRecipient {\n        private final IBinder token;\n\n        ClientUserRestrictionState(IBinder token)\n                throws RemoteException {\n            token.linkToDeath(this, 0);\n            this.token = token;\n        }\n\n        public boolean setRestriction(int code, boolean restricted,\n                PackageTagsList excludedPackageTags, int userId) {\n            return mAppOpsRestrictions.setUserRestriction(token, userId, code,\n                    restricted, excludedPackageTags);\n        }\n\n        public boolean hasRestriction(int code, String packageName, String attributionTag,\n                int userId, boolean isCheckOp) {\n            return mAppOpsRestrictions.getUserRestriction(token, userId, code, packageName,\n                    attributionTag, isCheckOp);\n        }\n\n        public void removeUser(int userId) {\n            mAppOpsRestrictions.clearUserRestrictions(token, userId);\n        }\n\n        public boolean isDefault() {\n            return !mAppOpsRestrictions.hasUserRestrictions(token);\n        }\n\n        @Override\n        public void binderDied() {\n            synchronized (AppOpsService.this) {\n                mAppOpsRestrictions.clearUserRestrictions(token);\n                mOpUserRestrictions.remove(token);\n                destroy();\n            }\n        }\n\n        public void destroy() {\n            token.unlinkToDeath(this, 0);\n        }\n    }\n\n    private final class ClientGlobalRestrictionState implements DeathRecipient {\n        final IBinder mToken;\n\n        ClientGlobalRestrictionState(IBinder token)\n                throws RemoteException {\n            token.linkToDeath(this, 0);\n            this.mToken = token;\n        }\n\n        boolean setRestriction(int code, boolean restricted) {\n            return mAppOpsRestrictions.setGlobalRestriction(mToken, code, restricted);\n        }\n\n        boolean hasRestriction(int code) {\n            return mAppOpsRestrictions.getGlobalRestriction(mToken, code);\n        }\n\n        boolean isDefault() {\n            return !mAppOpsRestrictions.hasGlobalRestrictions(mToken);\n        }\n\n        @Override\n        public void binderDied() {\n            mAppOpsRestrictions.clearGlobalRestrictions(mToken);\n            mOpGlobalRestrictions.remove(mToken);\n            destroy();\n        }\n\n        void destroy() {\n            mToken.unlinkToDeath(this, 0);\n        }\n    }\n\n    private final class AppOpsManagerLocalImpl implements AppOpsManagerLocal {\n        @Override\n        public boolean isUidInForeground(int uid) {\n            synchronized (AppOpsService.this) {\n                return mUidStateTracker.isUidInForeground(uid);\n            }\n        }\n    }\n\n    private final class AppOpsManagerInternalImpl extends AppOpsManagerInternal {\n        @Override public void setDeviceAndProfileOwners(SparseIntArray owners) {\n            synchronized (AppOpsService.this) {\n                mProfileOwners = owners;\n            }\n        }\n\n        @Override\n        public void updateAppWidgetVisibility(SparseArray<String> uidPackageNames,\n                boolean visible) {\n            AppOpsService.this.updateAppWidgetVisibility(uidPackageNames, visible);\n        }\n\n        @Override\n        public void setUidModeFromPermissionPolicy(int code, int uid, int mode,\n                @Nullable IAppOpsCallback callback) {\n            setUidMode(code, uid, mode, callback);\n        }\n\n        @Override\n        public void setModeFromPermissionPolicy(int code, int uid, @NonNull String packageName,\n                int mode, @Nullable IAppOpsCallback callback) {\n            setMode(code, uid, packageName, mode, callback);\n        }\n\n\n        @Override\n        public void setGlobalRestriction(int code, boolean restricted, IBinder token) {\n            if (Binder.getCallingPid() != Process.myPid()) {\n                // TODO instead of this enforcement put in AppOpsManagerInternal\n                throw new SecurityException(\"Only the system can set global restrictions\");\n            }\n\n            synchronized (AppOpsService.this) {\n                ClientGlobalRestrictionState restrictionState = mOpGlobalRestrictions.get(token);\n\n                if (restrictionState == null) {\n                    try {\n                        restrictionState = new ClientGlobalRestrictionState(token);\n                    } catch (RemoteException  e) {\n                        return;\n                    }\n                    mOpGlobalRestrictions.put(token, restrictionState);\n                }\n\n                if (restrictionState.setRestriction(code, restricted)) {\n                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                            AppOpsService::notifyWatchersOfChange, AppOpsService.this, code,\n                            UID_ANY));\n                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                            AppOpsService::updateStartedOpModeForUser, AppOpsService.this,\n                            code, restricted, UserHandle.USER_ALL));\n                }\n\n                if (restrictionState.isDefault()) {\n                    mOpGlobalRestrictions.remove(token);\n                    restrictionState.destroy();\n                }\n            }\n        }\n\n        @Override\n        public int getOpRestrictionCount(int code, UserHandle user, String pkg,\n                String attributionTag) {\n            int number = 0;\n            synchronized (AppOpsService.this) {\n                int numRestrictions = mOpUserRestrictions.size();\n                for (int i = 0; i < numRestrictions; i++) {\n                    if (mOpUserRestrictions.valueAt(i)\n                            .hasRestriction(code, pkg, attributionTag, user.getIdentifier(),\n                                    false)) {\n                        number++;\n                    }\n                }\n\n                numRestrictions = mOpGlobalRestrictions.size();\n                for (int i = 0; i < numRestrictions; i++) {\n                    if (mOpGlobalRestrictions.valueAt(i).hasRestriction(code)) {\n                        number++;\n                    }\n                }\n            }\n\n            return number;\n        }\n    }\n\n    /**\n     * Async task for writing note op stack trace, op code, package name and version to file\n     * More specifically, writes all the collected ops from {@link #mNoteOpCallerStacktraces}\n     */\n    private void writeNoteOps() {\n        synchronized (this) {\n            mWriteNoteOpsScheduled = false;\n        }\n        synchronized (mNoteOpCallerStacktracesFile) {\n            try (FileWriter writer = new FileWriter(mNoteOpCallerStacktracesFile)) {\n                int numTraces = mNoteOpCallerStacktraces.size();\n                for (int i = 0; i < numTraces; i++) {\n                    // Writing json formatted string into file\n                    writer.write(mNoteOpCallerStacktraces.valueAt(i).asJson());\n                    // Comma separation, so we can wrap the entire log as a JSON object\n                    // when all results are collected\n                    writer.write(\",\");\n                }\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to load opsValidation file for FileWriter\", e);\n            }\n        }\n    }\n\n    /**\n     * This class represents a NoteOp Trace object amd contains the necessary fields that will\n     * be written to file to use for permissions data validation in JSON format\n     */\n    @Immutable\n    static class NoteOpTrace {\n        static final String STACKTRACE = \"stackTrace\";\n        static final String OP = \"op\";\n        static final String PACKAGENAME = \"packageName\";\n        static final String VERSION = \"version\";\n\n        private final @NonNull String mStackTrace;\n        private final int mOp;\n        private final @Nullable String mPackageName;\n        private final long mVersion;\n\n        /**\n         * Initialize a NoteOp object using a JSON object containing the necessary fields\n         *\n         * @param jsonTrace JSON object represented as a string\n         *\n         * @return NoteOpTrace object initialized with JSON fields\n         */\n        static NoteOpTrace fromJson(String jsonTrace) {\n            try {\n                // Re-add closing bracket which acted as a delimiter by the reader\n                JSONObject obj = new JSONObject(jsonTrace.concat(\"}\"));\n                return new NoteOpTrace(obj.getString(STACKTRACE), obj.getInt(OP),\n                        obj.getString(PACKAGENAME), obj.getLong(VERSION));\n            } catch (JSONException e) {\n                // Swallow error, only meant for logging ops, should not affect flow of the code\n                Slog.e(TAG, \"Error constructing NoteOpTrace object \"\n                        + \"JSON trace format incorrect\", e);\n                return null;\n            }\n        }\n\n        NoteOpTrace(String stackTrace, int op, String packageName, long version) {\n            mStackTrace = stackTrace;\n            mOp = op;\n            mPackageName = packageName;\n            mVersion = version;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            NoteOpTrace that = (NoteOpTrace) o;\n            return mOp == that.mOp\n                    && mVersion == that.mVersion\n                    && mStackTrace.equals(that.mStackTrace)\n                    && Objects.equals(mPackageName, that.mPackageName);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(mStackTrace, mOp, mPackageName, mVersion);\n        }\n\n        /**\n         * The object is formatted as a JSON object and returned as a String\n         *\n         * @return JSON formatted string\n         */\n        public String asJson() {\n            return  \"{\"\n                    + \"\\\"\" + STACKTRACE + \"\\\":\\\"\" + mStackTrace.replace(\"\\n\", \"\\\\n\")\n                    + '\\\"' + \",\\\"\" + OP + \"\\\":\" + mOp\n                    + \",\\\"\" + PACKAGENAME + \"\\\":\\\"\" + mPackageName + '\\\"'\n                    + \",\\\"\" + VERSION + \"\\\":\" + mVersion\n                    + '}';\n        }\n    }\n\n    /**\n     * Collects noteOps, noteProxyOps and startOps from AppOpsManager and writes it into a file\n     * which will be used for permissions data validation, the given parameters to this method\n     * will be logged in json format\n     *\n     * @param stackTrace stacktrace from the most recent call in AppOpsManager\n     * @param op op code\n     * @param packageName package making call\n     * @param version android version for this call\n     */\n    @Override\n    public void collectNoteOpCallsForValidation(String stackTrace, int op, String packageName,\n            long version) {\n        if (!AppOpsManager.NOTE_OP_COLLECTION_ENABLED) {\n            return;\n        }\n\n        Objects.requireNonNull(stackTrace);\n        Preconditions.checkArgument(op >= 0);\n        Preconditions.checkArgument(op < AppOpsManager._NUM_OP);\n\n        NoteOpTrace noteOpTrace = new NoteOpTrace(stackTrace, op, packageName, version);\n\n        boolean noteOpSetWasChanged;\n        synchronized (this) {\n            noteOpSetWasChanged = mNoteOpCallerStacktraces.add(noteOpTrace);\n            if (noteOpSetWasChanged && !mWriteNoteOpsScheduled) {\n                mWriteNoteOpsScheduled = true;\n                mHandler.postDelayed(PooledLambda.obtainRunnable((that) -> {\n                    AsyncTask.execute(() -> {\n                        that.writeNoteOps();\n                    });\n                }, this), 2500);\n            }\n        }\n    }\n\n    @Immutable\n    private final class CheckOpsDelegateDispatcher {\n        private final @Nullable CheckOpsDelegate mPolicy;\n        private final @Nullable CheckOpsDelegate mCheckOpsDelegate;\n\n        CheckOpsDelegateDispatcher(@Nullable CheckOpsDelegate policy,\n                @Nullable CheckOpsDelegate checkOpsDelegate) {\n            mPolicy = policy;\n            mCheckOpsDelegate = checkOpsDelegate;\n        }\n\n        public @NonNull CheckOpsDelegate getCheckOpsDelegate() {\n            return mCheckOpsDelegate;\n        }\n\n        public int checkOperation(int code, int uid, String packageName,\n                @Nullable String attributionTag, boolean raw) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.checkOperation(code, uid, packageName, attributionTag, raw,\n                            this::checkDelegateOperationImpl);\n                } else {\n                    return mPolicy.checkOperation(code, uid, packageName, attributionTag, raw,\n                            AppOpsService.this::checkOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return checkDelegateOperationImpl(code, uid, packageName, attributionTag, raw);\n            }\n            return checkOperationImpl(code, uid, packageName, attributionTag, raw);\n        }\n\n        private int checkDelegateOperationImpl(int code, int uid, String packageName,\n                @Nullable String attributionTag, boolean raw) {\n            return mCheckOpsDelegate.checkOperation(code, uid, packageName, attributionTag, raw,\n                    AppOpsService.this::checkOperationImpl);\n        }\n\n        public int checkAudioOperation(int code, int usage, int uid, String packageName) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.checkAudioOperation(code, usage, uid, packageName,\n                            this::checkDelegateAudioOperationImpl);\n                } else {\n                    return mPolicy.checkAudioOperation(code, usage, uid, packageName,\n                            AppOpsService.this::checkAudioOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return checkDelegateAudioOperationImpl(code, usage, uid, packageName);\n            }\n            return checkAudioOperationImpl(code, usage, uid, packageName);\n        }\n\n        private int checkDelegateAudioOperationImpl(int code, int usage, int uid,\n                String packageName) {\n            return mCheckOpsDelegate.checkAudioOperation(code, usage, uid, packageName,\n                    AppOpsService.this::checkAudioOperationImpl);\n        }\n\n        public SyncNotedAppOp noteOperation(int code, int uid, String packageName,\n                String attributionTag, boolean shouldCollectAsyncNotedOp, String message,\n                boolean shouldCollectMessage) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.noteOperation(code, uid, packageName, attributionTag,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            this::noteDelegateOperationImpl);\n                } else {\n                    return mPolicy.noteOperation(code, uid, packageName, attributionTag,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            AppOpsService.this::noteOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return noteDelegateOperationImpl(code, uid, packageName,\n                        attributionTag, shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n            }\n            return noteOperationImpl(code, uid, packageName, attributionTag,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n        }\n\n        private SyncNotedAppOp noteDelegateOperationImpl(int code, int uid,\n                @Nullable String packageName, @Nullable String featureId,\n                boolean shouldCollectAsyncNotedOp, @Nullable String message,\n                boolean shouldCollectMessage) {\n            return mCheckOpsDelegate.noteOperation(code, uid, packageName, featureId,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    AppOpsService.this::noteOperationImpl);\n        }\n\n        public SyncNotedAppOp noteProxyOperation(int code, AttributionSource attributionSource,\n                boolean shouldCollectAsyncNotedOp, @Nullable String message,\n                boolean shouldCollectMessage, boolean skipProxyOperation) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.noteProxyOperation(code, attributionSource,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            skipProxyOperation, this::noteDelegateProxyOperationImpl);\n                } else {\n                    return mPolicy.noteProxyOperation(code, attributionSource,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            skipProxyOperation, AppOpsService.this::noteProxyOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return noteDelegateProxyOperationImpl(code,\n                        attributionSource, shouldCollectAsyncNotedOp, message,\n                        shouldCollectMessage, skipProxyOperation);\n            }\n            return noteProxyOperationImpl(code, attributionSource, shouldCollectAsyncNotedOp,\n                    message, shouldCollectMessage,skipProxyOperation);\n        }\n\n        private SyncNotedAppOp noteDelegateProxyOperationImpl(int code,\n                @NonNull AttributionSource attributionSource, boolean shouldCollectAsyncNotedOp,\n                @Nullable String message, boolean shouldCollectMessage,\n                boolean skipProxyOperation) {\n            return mCheckOpsDelegate.noteProxyOperation(code, attributionSource,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n                    AppOpsService.this::noteProxyOperationImpl);\n        }\n\n        public SyncNotedAppOp startOperation(IBinder token, int code, int uid,\n                @Nullable String packageName, @NonNull String attributionTag,\n                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp,\n                @Nullable String message, boolean shouldCollectMessage,\n                @AttributionFlags int attributionFlags, int attributionChainId) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.startOperation(token, code, uid, packageName,\n                            attributionTag, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                            shouldCollectMessage, attributionFlags, attributionChainId,\n                            this::startDelegateOperationImpl);\n                } else {\n                    return mPolicy.startOperation(token, code, uid, packageName, attributionTag,\n                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                            shouldCollectMessage, attributionFlags, attributionChainId,\n                            AppOpsService.this::startOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return startDelegateOperationImpl(token, code, uid, packageName, attributionTag,\n                        startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                        shouldCollectMessage, attributionFlags, attributionChainId);\n            }\n            return startOperationImpl(token, code, uid, packageName, attributionTag,\n                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    attributionFlags, attributionChainId);\n        }\n\n        private SyncNotedAppOp startDelegateOperationImpl(IBinder token, int code, int uid,\n                @Nullable String packageName, @Nullable String attributionTag,\n                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n                boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n                int attributionChainId) {\n            return mCheckOpsDelegate.startOperation(token, code, uid, packageName, attributionTag,\n                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    attributionFlags, attributionChainId, AppOpsService.this::startOperationImpl);\n        }\n\n        public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                            shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                            proxiedAttributionFlags, attributionChainId,\n                            this::startDelegateProxyOperationImpl);\n                } else {\n                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                            shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                            proxiedAttributionFlags, attributionChainId,\n                            AppOpsService.this::startProxyOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return startDelegateProxyOperationImpl(clientId, code, attributionSource,\n                        startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                        shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                        proxiedAttributionFlags, attributionChainId);\n            }\n            return startProxyOperationImpl(clientId, code, attributionSource, startIfModeDefault,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n                    proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n        }\n\n        private SyncNotedAppOp startDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                @AttributionFlags int proxiedAttributionFlsgs, int attributionChainId) {\n            return mCheckOpsDelegate.startProxyOperation(clientId, code, attributionSource,\n                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlsgs,\n                    attributionChainId, AppOpsService.this::startProxyOperationImpl);\n        }\n\n        public void finishOperation(IBinder clientId, int code, int uid, String packageName,\n                String attributionTag) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    mPolicy.finishOperation(clientId, code, uid, packageName, attributionTag,\n                            this::finishDelegateOperationImpl);\n                } else {\n                    mPolicy.finishOperation(clientId, code, uid, packageName, attributionTag,\n                            AppOpsService.this::finishOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                finishDelegateOperationImpl(clientId, code, uid, packageName, attributionTag);\n            } else {\n                finishOperationImpl(clientId, code, uid, packageName, attributionTag);\n            }\n        }\n\n        private void finishDelegateOperationImpl(IBinder clientId, int code, int uid,\n                String packageName, String attributionTag) {\n            mCheckOpsDelegate.finishOperation(clientId, code, uid, packageName, attributionTag,\n                    AppOpsService.this::finishOperationImpl);\n        }\n\n        public void finishProxyOperation(@NonNull IBinder clientId, int code,\n                @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n                            skipProxyOperation, this::finishDelegateProxyOperationImpl);\n                } else {\n                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n                            skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                finishDelegateProxyOperationImpl(clientId, code, attributionSource,\n                        skipProxyOperation);\n            } else {\n                finishProxyOperationImpl(clientId, code, attributionSource, skipProxyOperation);\n            }\n        }\n\n        private Void finishDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n                @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n            mCheckOpsDelegate.finishProxyOperation(clientId, code, attributionSource,\n                    skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n            return null;\n        }\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 55811,
                                        "general": {
                                            "word_based": 21179,
                                            "char_based": 73071
                                        },
                                        "gemini": 65511
                                    }
                                }
                            ]
                        }
                    ]
                }
            ],
            "cross_patch_attempts": [
                {
                    "from": "14",
                    "to": "13",
                    "result": "failure",
                    "patch_output": "can't find file to patch at input line 27\nPerhaps you used the wrong -p or --strip option?\nThe text leading up to this was:\n--------------------------\n|From e31c33ea3586531ca99dd4c6d68a34ce07c1cebb Mon Sep 17 00:00:00 2001\n|From: Hao Ke <haok@google.com>\n|Date: Mon, 22 Apr 2024 15:13:58 +0000\n|Subject: [PATCH] Fix READ/WRITE operation access issues on Restricted appOps.\n|\n|Problems were identified around read and write access to the restricted appOps, this change includes:\n|\n|- Filter out restricted appOps status for unprivileged readers.\n|- Allow additional privileged appOps permission holder reading restricted appOps status.\n|\n|Bug: 336273802\n|Bug: 336323279\n|Test: Local test see b/336273802#comment3\n|Test: atest AppOpsTest#testRestrictedSettingsOpsRead\n|Change-Id: I09008b365e36b2c20c9a1fe5a1d52699ddb17d35\n|Merged-In: I09008b365e36b2c20c9a1fe5a1d52699ddb17d35\n|---\n| core/java/android/app/AppOpInfo.java          |  2 +-\n| core/java/android/app/AppOpsManager.java      |  2 +-\n| .../android/server/appop/AppOpsService.java   | 31 ++++++++++++++++---\n| 3 files changed, 28 insertions(+), 7 deletions(-)\n|\n|diff --git a/core/java/android/app/AppOpInfo.java b/core/java/android/app/AppOpInfo.java\n|index 5268ec42e21c..a0f0ccaec58c 100644\n|--- a/core/java/android/app/AppOpInfo.java\n|+++ b/core/java/android/app/AppOpInfo.java\n--------------------------\nFile to patch: \nSkip this patch? [y] \nSkipping patch.\n1 out of 1 hunk ignored\npatching file core/java/android/app/AppOpsManager.java\nHunk #1 succeeded at 3290 (offset 305 lines).\npatching file services/core/java/com/android/server/appop/AppOpsService.java\nHunk #1 FAILED at 1430.\nHunk #2 succeeded at 4400 (offset 785 lines).\n1 out of 2 hunks FAILED -- saving rejects to file services/core/java/com/android/server/appop/AppOpsService.java.rej"
                }
            ]
        },
        {
            "id": "ASB-A-328068777",
            "aliases": [
                "A-328068777",
                "CVE-2024-23706"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-328068777",
            "severity": "Critical",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "dcb9791c2ed95b06a2ab9656f10fba3a35933ac5"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From dcb9791c2ed95b06a2ab9656f10fba3a35933ac5 Mon Sep 17 00:00:00 2001\nFrom: Pratyush More <pratyushmore@google.com>\nDate: Tue, 27 Feb 2024 18:38:29 +0000\nSubject: [PATCH] Throw exception when trying to instantiate a change log token\n with no record types.\n\nNote that this does mean that any developers that were previously\nrequesting change logs without specifying record types will no longer be\nable to. However, the APK doesn't allow this anyway, so it is likely ok.\n\nTest: atest CtsHealthFitnessDeviceTestCases:HealthConnectChangeLogsTests#testGetChangeLogToken_emptyRecordTypes_throwsException\nBug: 327332482\nChange-Id: I5dd49131fbe5eaa8bc138be03550f7fc739786d9\n---\n .../changelog/ChangeLogTokenRequest.java      |  7 ++-\n .../HealthConnectServiceImpl.java             | 16 +++++\n .../HealthConnectServiceLogsTests.java        |  6 +-\n .../cts/device/HealthConnectDeviceTest.java   |  8 +++\n .../cts/HealthConnectManagerTest.java         |  3 +-\n .../healthconnect/cts/SharedMemoryTest.java   |  7 ++-\n .../HealthConnectChangeLogsTests.java         | 61 ++++++++++++-------\n .../HistoricAccessLimitTest.java              |  7 ++-\n ...HistoricAccessLimitWithPermissionTest.java |  7 ++-\n .../healthconnect/cts/utils/DataFactory.java  |  9 +++\n 10 files changed, 102 insertions(+), 29 deletions(-)\n\ndiff --git a/framework/java/android/health/connect/changelog/ChangeLogTokenRequest.java b/framework/java/android/health/connect/changelog/ChangeLogTokenRequest.java\nindex 28241f88a..e630e3c53 100644\n--- a/framework/java/android/health/connect/changelog/ChangeLogTokenRequest.java\n+++ b/framework/java/android/health/connect/changelog/ChangeLogTokenRequest.java\n@@ -49,6 +49,9 @@ public final class ChangeLogTokenRequest implements Parcelable {\n     private ChangeLogTokenRequest(\n             @NonNull Set<DataOrigin> dataOriginFilters,\n             @NonNull Set<Class<? extends Record>> recordTypes) {\n+        if (recordTypes.isEmpty()) {\n+            throw new IllegalArgumentException(\"Requested record types must not be empty\");\n+        }\n         Objects.requireNonNull(recordTypes);\n         Objects.requireNonNull(dataOriginFilters);\n \n@@ -161,8 +164,8 @@ public final class ChangeLogTokenRequest implements Parcelable {\n         private final Set<DataOrigin> mDataOriginFilters = new ArraySet<>();\n \n         /**\n-         * @param recordType type of record for which change log is required. If not set includes\n-         *     all record types\n+         * @param recordType type of record for which change log is required. At least one record\n+         *     type must be set.\n          */\n         @NonNull\n         public Builder addRecordType(@NonNull Class<? extends Record> recordType) {\ndiff --git a/service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java b/service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java\nindex 439c97d87..c1c1ada78 100644\n--- a/service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java\n+++ b/service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java\n@@ -939,6 +939,10 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n                                 mAppOpsManagerLocal.isUidInForeground(uid),\n                                 logger);\n                         throwExceptionIfDataSyncInProgress();\n+                        if (request.getRecordTypes().isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Requested record types must not be empty.\");\n+                        }\n                         mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                 request.getRecordTypesList(), attributionSource);\n                         callback.onResult(\n@@ -957,6 +961,14 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n                         logger.setHealthDataServiceApiStatusError(ERROR_SECURITY);\n                         Slog.e(TAG, \"SecurityException: \", securityException);\n                         tryAndThrowException(callback, securityException, ERROR_SECURITY);\n+                    } catch (IllegalArgumentException illegalArgumentException) {\n+                        logger.setHealthDataServiceApiStatusError(\n+                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n+                        Slog.e(TAG, \"IllegalArgumentException: \", illegalArgumentException);\n+                        tryAndThrowException(\n+                                callback,\n+                                illegalArgumentException,\n+                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n                     } catch (HealthConnectException healthConnectException) {\n                         logger.setHealthDataServiceApiStatusError(\n                                 healthConnectException.getErrorCode());\n@@ -1019,6 +1031,10 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n                                         callerPackageName, request.getToken());\n                         tryAcquireApiCallQuota(\n                                 uid, QuotaCategory.QUOTA_CATEGORY_READ, isInForeground, logger);\n+                        if (changeLogsTokenRequest.getRecordTypes().isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Requested record types must not be empty.\");\n+                        }\n                         mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                 changeLogsTokenRequest.getRecordTypes(), attributionSource);\n                         long startDateAccessEpochMilli = DEFAULT_LONG;\ndiff --git a/tests/cts/hostsidetests/healthconnect/HealthConnectTestHelper/src/android/healthconnect/cts/testhelper/HealthConnectServiceLogsTests.java b/tests/cts/hostsidetests/healthconnect/HealthConnectTestHelper/src/android/healthconnect/cts/testhelper/HealthConnectServiceLogsTests.java\nindex 9bb194785..409153316 100644\n--- a/tests/cts/hostsidetests/healthconnect/HealthConnectTestHelper/src/android/healthconnect/cts/testhelper/HealthConnectServiceLogsTests.java\n+++ b/tests/cts/hostsidetests/healthconnect/HealthConnectTestHelper/src/android/healthconnect/cts/testhelper/HealthConnectServiceLogsTests.java\n@@ -45,6 +45,7 @@ import android.health.connect.changelog.ChangeLogsRequest;\n import android.health.connect.changelog.ChangeLogsResponse;\n import android.health.connect.datatypes.BloodPressureRecord;\n import android.health.connect.datatypes.DataOrigin;\n+import android.health.connect.datatypes.HeartRateRecord;\n import android.health.connect.datatypes.HeightRecord;\n import android.health.connect.datatypes.Record;\n import android.health.connect.datatypes.StepsRecord;\n@@ -360,7 +361,10 @@ public class HealthConnectServiceLogsTests {\n         CountDownLatch latch = new CountDownLatch(1);\n         assertThat(mHealthConnectManager).isNotNull();\n         mHealthConnectManager.getChangeLogToken(\n-                new ChangeLogTokenRequest.Builder().build(),\n+                new ChangeLogTokenRequest.Builder()\n+                        .addRecordType(BloodPressureRecord.class)\n+                        .addRecordType(HeartRateRecord.class)\n+                        .build(),\n                 Executors.newSingleThreadExecutor(),\n                 new OutcomeReceiver<>() {\n \ndiff --git a/tests/cts/hostsidetests/healthconnect/device/src/android/healthconnect/cts/device/HealthConnectDeviceTest.java b/tests/cts/hostsidetests/healthconnect/device/src/android/healthconnect/cts/device/HealthConnectDeviceTest.java\nindex 74b7e4120..6bc5e8c48 100644\n--- a/tests/cts/hostsidetests/healthconnect/device/src/android/healthconnect/cts/device/HealthConnectDeviceTest.java\n+++ b/tests/cts/hostsidetests/healthconnect/device/src/android/healthconnect/cts/device/HealthConnectDeviceTest.java\n@@ -572,12 +572,20 @@ public class HealthConnectDeviceTest {\n         String changeLogTokenForAppB =\n                 APP_B_WITH_READ_WRITE_PERMS.getChangeLogToken(\n                         new ChangeLogTokenRequest.Builder()\n+                                .addRecordType(StepsRecord.class)\n+                                .addRecordType(HeartRateRecord.class)\n+                                .addRecordType(BasalMetabolicRateRecord.class)\n+                                .addRecordType(ExerciseSessionRecord.class)\n                                 .addDataOriginFilter(\n                                         getDataOrigin(APP_A_WITH_READ_WRITE_PERMS.getPackageName()))\n                                 .build());\n         String changeLogTokenForAppA =\n                 APP_A_WITH_READ_WRITE_PERMS.getChangeLogToken(\n                         new ChangeLogTokenRequest.Builder()\n+                                .addRecordType(StepsRecord.class)\n+                                .addRecordType(HeartRateRecord.class)\n+                                .addRecordType(BasalMetabolicRateRecord.class)\n+                                .addRecordType(ExerciseSessionRecord.class)\n                                 .addDataOriginFilter(\n                                         getDataOrigin(APP_B_WITH_READ_WRITE_PERMS.getPackageName()))\n                                 .build());\ndiff --git a/tests/cts/src/android/healthconnect/cts/HealthConnectManagerTest.java b/tests/cts/src/android/healthconnect/cts/HealthConnectManagerTest.java\nindex c0a16d3f3..5cda01ca4 100644\n--- a/tests/cts/src/android/healthconnect/cts/HealthConnectManagerTest.java\n+++ b/tests/cts/src/android/healthconnect/cts/HealthConnectManagerTest.java\n@@ -1633,7 +1633,8 @@ public class HealthConnectManagerTest {\n         }\n \n         try {\n-            TestUtils.getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+            TestUtils.getChangeLogToken(\n+                    new ChangeLogTokenRequest.Builder().addRecordType(StepsRecord.class).build());\n             Assert.fail();\n         } catch (HealthConnectException exception) {\n             assertThat(exception).isNotNull();\ndiff --git a/tests/cts/src/android/healthconnect/cts/SharedMemoryTest.java b/tests/cts/src/android/healthconnect/cts/SharedMemoryTest.java\nindex b4ec367d0..5e46888b6 100644\n--- a/tests/cts/src/android/healthconnect/cts/SharedMemoryTest.java\n+++ b/tests/cts/src/android/healthconnect/cts/SharedMemoryTest.java\n@@ -234,7 +234,12 @@ public class SharedMemoryTest {\n         Instant now = Instant.now();\n \n         String changeLogToken =\n-                TestUtils.getChangeLogToken(new ChangeLogTokenRequest.Builder().build()).getToken();\n+                TestUtils.getChangeLogToken(\n+                                new ChangeLogTokenRequest.Builder()\n+                                        .addRecordType(HeightRecord.class)\n+                                        .addRecordType(WeightRecord.class)\n+                                        .build())\n+                        .getToken();\n \n         List<HeightRecord> heightRecords = new ArrayList<>(recordsToDeleteCount);\n         for (int i = 0; i < recordsToDeleteCount; i++) {\ndiff --git a/tests/cts/src/android/healthconnect/cts/changelogs/HealthConnectChangeLogsTests.java b/tests/cts/src/android/healthconnect/cts/changelogs/HealthConnectChangeLogsTests.java\nindex 5300e40c7..df6f2d586 100644\n--- a/tests/cts/src/android/healthconnect/cts/changelogs/HealthConnectChangeLogsTests.java\n+++ b/tests/cts/src/android/healthconnect/cts/changelogs/HealthConnectChangeLogsTests.java\n@@ -25,6 +25,7 @@ import static android.healthconnect.cts.utils.DataFactory.getHeartRateRecord;\n import static android.healthconnect.cts.utils.DataFactory.getMetadataForId;\n import static android.healthconnect.cts.utils.DataFactory.getStepsRecord;\n import static android.healthconnect.cts.utils.DataFactory.getTestRecords;\n+import static android.healthconnect.cts.utils.DataFactory.getChangeLogTokenRequestForTestRecordTypes;\n import static android.healthconnect.cts.utils.TestUtils.deleteAllStagedRemoteData;\n import static android.healthconnect.cts.utils.TestUtils.deleteRecords;\n import static android.healthconnect.cts.utils.TestUtils.deleteRecordsByIdFilter;\n@@ -38,6 +39,8 @@ import static android.healthconnect.cts.utils.TestUtils.verifyDeleteRecords;\n \n import static com.google.common.truth.Truth.assertThat;\n \n+import static org.junit.Assert.assertThrows;\n+\n import static java.time.temporal.ChronoUnit.HOURS;\n import static java.time.temporal.ChronoUnit.MILLIS;\n import static java.time.temporal.ChronoUnit.MINUTES;\n@@ -127,16 +130,17 @@ public class HealthConnectChangeLogsTests {\n \n     @Test\n     public void testBuildChangeLogTokenRequest_hasFieldsSet() {\n-        ChangeLogTokenRequest changeLogTokenRequest = new ChangeLogTokenRequest.Builder().build();\n+        ChangeLogTokenRequest changeLogTokenRequest =\n+                new ChangeLogTokenRequest.Builder().addRecordType(StepsRecord.class).build();\n \n-        assertThat(changeLogTokenRequest.getRecordTypes()).isEmpty();\n+        assertThat(changeLogTokenRequest.getRecordTypes()).containsExactly(StepsRecord.class);\n         assertThat(changeLogTokenRequest.getDataOriginFilters()).isEmpty();\n     }\n \n     @Test\n     public void testBuildChangeLogsRequest_hasFieldsSet() throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n \n@@ -147,7 +151,7 @@ public class HealthConnectChangeLogsTests {\n     @Test\n     public void testChangeLogs_noOperations_returnsEmptyChangelogs() throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n \n@@ -160,7 +164,7 @@ public class HealthConnectChangeLogsTests {\n     @Test\n     public void testChangeLogs_insert_returnsUpsertedLogsOnly() throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n \n@@ -176,7 +180,7 @@ public class HealthConnectChangeLogsTests {\n             throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n                 getChangeLogToken(\n-                        new ChangeLogTokenRequest.Builder()\n+                        getChangeLogTokenRequestForTestRecordTypes()\n                                 .addDataOriginFilter(\n                                         new DataOrigin.Builder().setPackageName(\"random\").build())\n                                 .build());\n@@ -196,7 +200,7 @@ public class HealthConnectChangeLogsTests {\n         Context context = ApplicationProvider.getApplicationContext();\n         ChangeLogTokenResponse tokenResponse =\n                 getChangeLogToken(\n-                        new ChangeLogTokenRequest.Builder()\n+                        getChangeLogTokenRequestForTestRecordTypes()\n                                 .addDataOriginFilter(\n                                         new DataOrigin.Builder()\n                                                 .setPackageName(context.getPackageName())\n@@ -238,7 +242,7 @@ public class HealthConnectChangeLogsTests {\n     public void testChangeLogs_insertAndDeleteDataById_returnsDeletedLogsOnly()\n             throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n \n@@ -256,7 +260,7 @@ public class HealthConnectChangeLogsTests {\n     public void testChangeLogs_insertAndDeleteByClientId_returnsDeletedLogsOnly()\n             throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n \n@@ -276,7 +280,7 @@ public class HealthConnectChangeLogsTests {\n     public void testChangeLogs_insertOldRecords_onlyReturnsUpsertedLogsAfterHistoricalAccess()\n             throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n \n@@ -302,7 +306,7 @@ public class HealthConnectChangeLogsTests {\n     public void testChangeLogs_insertAndDeleteOldRecords_returnsAllDeletedLogs()\n             throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n \n@@ -325,7 +329,7 @@ public class HealthConnectChangeLogsTests {\n             throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n                 getChangeLogToken(\n-                        new ChangeLogTokenRequest.Builder()\n+                        getChangeLogTokenRequestForTestRecordTypes()\n                                 .addDataOriginFilter(\n                                         new DataOrigin.Builder().setPackageName(\"random\").build())\n                                 .build());\n@@ -348,7 +352,7 @@ public class HealthConnectChangeLogsTests {\n         Context context = ApplicationProvider.getApplicationContext();\n         ChangeLogTokenResponse tokenResponse =\n                 getChangeLogToken(\n-                        new ChangeLogTokenRequest.Builder()\n+                        getChangeLogTokenRequestForTestRecordTypes()\n                                 .addDataOriginFilter(\n                                         new DataOrigin.Builder()\n                                                 .setPackageName(context.getPackageName())\n@@ -400,7 +404,7 @@ public class HealthConnectChangeLogsTests {\n     public void testChangeLogs_insertAndUpdateById_returnsUpdateChangeLogOnly()\n             throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n \n@@ -425,7 +429,7 @@ public class HealthConnectChangeLogsTests {\n     public void testChangeLogs_insertAndUpdateByClientId_returnsUpdateChangeLogOnly()\n             throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n \n@@ -446,7 +450,7 @@ public class HealthConnectChangeLogsTests {\n     public void testChangeLogs_insertUpdateAndDeleteById_returnsDeleteChangeLogOnly()\n             throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n \n@@ -472,7 +476,7 @@ public class HealthConnectChangeLogsTests {\n     public void testChangeLogs_insertUpdateAndDeleteByClientId_returnsDeleteChangeLogOnly()\n             throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n \n@@ -492,7 +496,7 @@ public class HealthConnectChangeLogsTests {\n     public void testChangeLogs_noOperations_withPageSize_returnsEmptyChangeLogs()\n             throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).setPageSize(1).build();\n \n@@ -505,7 +509,7 @@ public class HealthConnectChangeLogsTests {\n     public void testChangeLogs_insert_withPageSize_doesNotExceedPageSize()\n             throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).setPageSize(1).build();\n \n@@ -519,7 +523,7 @@ public class HealthConnectChangeLogsTests {\n     public void testChangeLogs_insert_withPageSize_paginatesThroughAllChangeLogs()\n             throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).setPageSize(1).build();\n \n@@ -560,7 +564,7 @@ public class HealthConnectChangeLogsTests {\n     @Test\n     public void testChangeLogs_checkToken_hasMorePages_False() throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                getChangeLogToken(getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n \n@@ -582,6 +586,15 @@ public class HealthConnectChangeLogsTests {\n         assertThat(newResponse.getNextChangesToken()).isEqualTo(newChangeLogsRequest.getToken());\n     }\n \n+    @Test\n+    public void testGetChangeLogToken_emptyRecordTypes_throwsException() throws Exception {\n+        Throwable thrown =\n+                assertThrows(\n+                        IllegalArgumentException.class,\n+                        () -> getChangeLogToken(new ChangeLogTokenRequest.Builder().build()));\n+        assertThat(thrown).hasMessageThat().contains(\"Requested record types must not be empty\");\n+    }\n+\n     @Test\n     public void testChangeLogs_operationCombinations_expectCorrectChangeLogs() throws Exception {\n         Instant yesterday = Instant.now().minus(1, ChronoUnit.DAYS).truncatedTo(MILLIS);\n@@ -605,7 +618,11 @@ public class HealthConnectChangeLogsTests {\n         String preExistingRecordId = insertRecordAndGetId(getDistanceRecord());\n         // then get changes token. The above records shouldn't be included in the change logs.\n         String changeToken =\n-                getChangeLogToken(new ChangeLogTokenRequest.Builder().build()).getToken();\n+                getChangeLogToken(\n+                                getChangeLogTokenRequestForTestRecordTypes()\n+                                        .addRecordType(DistanceRecord.class)\n+                                        .build())\n+                        .getToken();\n \n         ImmutableList.Builder<Record> recordBuilder = ImmutableList.builder();\n         for (int i = 0; i < 50; i++) {\ndiff --git a/tests/cts/src/android/healthconnect/cts/historicaccess/HistoricAccessLimitTest.java b/tests/cts/src/android/healthconnect/cts/historicaccess/HistoricAccessLimitTest.java\nindex b8ba29062..4b6f520fd 100644\n--- a/tests/cts/src/android/healthconnect/cts/historicaccess/HistoricAccessLimitTest.java\n+++ b/tests/cts/src/android/healthconnect/cts/historicaccess/HistoricAccessLimitTest.java\n@@ -264,7 +264,12 @@ public class HistoricAccessLimitTest {\n \n     @Test\n     public void testGetChangeLogs_expectCorrectResponse() throws InterruptedException {\n-        String token = getChangeLogToken(new ChangeLogTokenRequest.Builder().build()).getToken();\n+        String token =\n+                getChangeLogToken(\n+                                new ChangeLogTokenRequest.Builder()\n+                                        .addRecordType(WeightRecord.class)\n+                                        .build())\n+                        .getToken();\n         List<String> insertedRecentRecordIds =\n                 List.of(\n                         insertWeightRecord(daysBeforeNow(10), 10),\ndiff --git a/tests/cts/src/android/healthconnect/cts/historicaccess/HistoricAccessLimitWithPermissionTest.java b/tests/cts/src/android/healthconnect/cts/historicaccess/HistoricAccessLimitWithPermissionTest.java\nindex eea88db12..5f971e649 100644\n--- a/tests/cts/src/android/healthconnect/cts/historicaccess/HistoricAccessLimitWithPermissionTest.java\n+++ b/tests/cts/src/android/healthconnect/cts/historicaccess/HistoricAccessLimitWithPermissionTest.java\n@@ -251,7 +251,12 @@ public class HistoricAccessLimitWithPermissionTest {\n \n     @Test\n     public void testGetChangeLogs_expectCorrectResponse() throws InterruptedException {\n-        String token = getChangeLogToken(new ChangeLogTokenRequest.Builder().build()).getToken();\n+        String token =\n+                getChangeLogToken(\n+                                new ChangeLogTokenRequest.Builder()\n+                                        .addRecordType(WeightRecord.class)\n+                                        .build())\n+                        .getToken();\n         List<String> insertedRecordIds =\n                 List.of(\n                         insertWeightRecord(daysBeforeNow(10), 10),\ndiff --git a/tests/cts/utils/HealthConnectTestUtils/src/android/healthconnect/cts/utils/DataFactory.java b/tests/cts/utils/HealthConnectTestUtils/src/android/healthconnect/cts/utils/DataFactory.java\nindex e44e3f7ef..519c07143 100644\n--- a/tests/cts/utils/HealthConnectTestUtils/src/android/healthconnect/cts/utils/DataFactory.java\n+++ b/tests/cts/utils/HealthConnectTestUtils/src/android/healthconnect/cts/utils/DataFactory.java\n@@ -24,6 +24,7 @@ import static android.health.connect.datatypes.RecordTypeIdentifier.RECORD_TYPE_\n import static com.google.common.truth.Truth.assertThat;\n \n import android.content.Context;\n+import android.health.connect.changelog.ChangeLogTokenRequest;\n import android.health.connect.datatypes.BasalMetabolicRateRecord;\n import android.health.connect.datatypes.DataOrigin;\n import android.health.connect.datatypes.Device;\n@@ -469,6 +470,14 @@ public final class DataFactory {\n                 buildExerciseSession());\n     }\n \n+    public static ChangeLogTokenRequest.Builder getChangeLogTokenRequestForTestRecordTypes() {\n+        return new ChangeLogTokenRequest.Builder()\n+                .addRecordType(StepsRecord.class)\n+                .addRecordType(HeartRateRecord.class)\n+                .addRecordType(BasalMetabolicRateRecord.class)\n+                .addRecordType(ExerciseSessionRecord.class);\n+    }\n+\n     public static List<RecordAndIdentifier> getRecordsAndIdentifiers() {\n         return Arrays.asList(\n                 new RecordAndIdentifier(RECORD_TYPE_STEPS, getStepsRecord()),\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 5701,
                        "general": {
                            "word_based": 2049,
                            "char_based": 7199
                        },
                        "gemini": 6985
                    },
                    "total_downstream_versions_tested": 1,
                    "successful_patches": 0,
                    "failed_patches": 1,
                    "patch_results": [
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "cd228a3e21c9c8df83bc3851736d6f4e19956e46",
                            "repo_path": "android_repos/HealthFitness",
                            "result": "failure",
                            "downstream_patch_content": "commit cd228a3e21c9c8df83bc3851736d6f4e19956e46\nAuthor: Pratyush More <pratyushmore@google.com>\nDate:   Tue Feb 27 18:38:29 2024 +0000\n\n    Throw exception when trying to instantiate a change log token with no\n    record types.\n    \n    Note that this does mean that any developers that were previously\n    requesting change logs without specifying record types will no longer be\n    able to. However, the APK doesn't allow this anyway, so it is likely ok.\n    \n    \n    Test: atest CtsHealthFitnessDeviceTestCases:HealthConnectChangeLogsTests#testGetChangeLogToken_emptyRecordTypes_throwsException\n    Bug: 327332482\n    Change-Id: I5dd49131fbe5eaa8bc138be03550f7fc739786d9\n    Merged-In: I5dd49131fbe5eaa8bc138be03550f7fc739786d9\n\ndiff --git a/framework/java/android/health/connect/changelog/ChangeLogTokenRequest.java b/framework/java/android/health/connect/changelog/ChangeLogTokenRequest.java\nindex 28241f88a..e630e3c53 100644\n--- a/framework/java/android/health/connect/changelog/ChangeLogTokenRequest.java\n+++ b/framework/java/android/health/connect/changelog/ChangeLogTokenRequest.java\n@@ -49,6 +49,9 @@ public final class ChangeLogTokenRequest implements Parcelable {\n     private ChangeLogTokenRequest(\n             @NonNull Set<DataOrigin> dataOriginFilters,\n             @NonNull Set<Class<? extends Record>> recordTypes) {\n+        if (recordTypes.isEmpty()) {\n+            throw new IllegalArgumentException(\"Requested record types must not be empty\");\n+        }\n         Objects.requireNonNull(recordTypes);\n         Objects.requireNonNull(dataOriginFilters);\n \n@@ -161,8 +164,8 @@ public final class ChangeLogTokenRequest implements Parcelable {\n         private final Set<DataOrigin> mDataOriginFilters = new ArraySet<>();\n \n         /**\n-         * @param recordType type of record for which change log is required. If not set includes\n-         *     all record types\n+         * @param recordType type of record for which change log is required. At least one record\n+         *     type must be set.\n          */\n         @NonNull\n         public Builder addRecordType(@NonNull Class<? extends Record> recordType) {\ndiff --git a/service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java b/service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java\nindex 578db3397..9becd0c39 100644\n--- a/service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java\n+++ b/service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java\n@@ -798,6 +798,10 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n                                 mAppOpsManagerLocal.isUidInForeground(uid),\n                                 builder);\n                         throwExceptionIfDataSyncInProgress();\n+                        if (request.getRecordTypes().isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Requested record types must not be empty.\");\n+                        }\n                         mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                 request.getRecordTypesList(), attributionSource);\n                         callback.onResult(\n@@ -816,6 +820,14 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n                         builder.setHealthDataServiceApiStatusError(ERROR_SECURITY);\n                         Slog.e(TAG, \"SecurityException: \", securityException);\n                         tryAndThrowException(callback, securityException, ERROR_SECURITY);\n+                    } catch (IllegalArgumentException illegalArgumentException) {\n+                        builder.setHealthDataServiceApiStatusError(\n+                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n+                        Slog.e(TAG, \"IllegalArgumentException: \", illegalArgumentException);\n+                        tryAndThrowException(\n+                                callback,\n+                                illegalArgumentException,\n+                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n                     } catch (HealthConnectException healthConnectException) {\n                         builder.setHealthDataServiceApiStatusError(\n                                 healthConnectException.getErrorCode());\n@@ -862,6 +874,10 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n                         ChangeLogsRequestHelper.TokenRequest changeLogsTokenRequest =\n                                 ChangeLogsRequestHelper.getRequest(\n                                         attributionSource.getPackageName(), token.getToken());\n+                        if (changeLogsTokenRequest.getRecordTypes().isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Requested record types must not be empty.\");\n+                        }\n                         mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                 changeLogsTokenRequest.getRecordTypes(), attributionSource);\n                         boolean isInForeground = mAppOpsManagerLocal.isUidInForeground(uid);\ndiff --git a/tests/cts/hostsidetests/healthconnect/HealthConnectTestHelper/src/android/healthconnect/cts/testhelper/HealthConnectServiceLogsTests.java b/tests/cts/hostsidetests/healthconnect/HealthConnectTestHelper/src/android/healthconnect/cts/testhelper/HealthConnectServiceLogsTests.java\nindex 4c55b2b71..502e7990d 100644\n--- a/tests/cts/hostsidetests/healthconnect/HealthConnectTestHelper/src/android/healthconnect/cts/testhelper/HealthConnectServiceLogsTests.java\n+++ b/tests/cts/hostsidetests/healthconnect/HealthConnectTestHelper/src/android/healthconnect/cts/testhelper/HealthConnectServiceLogsTests.java\n@@ -44,6 +44,7 @@ import android.health.connect.changelog.ChangeLogsRequest;\n import android.health.connect.changelog.ChangeLogsResponse;\n import android.health.connect.datatypes.BloodPressureRecord;\n import android.health.connect.datatypes.DataOrigin;\n+import android.health.connect.datatypes.HeartRateRecord;\n import android.health.connect.datatypes.HeightRecord;\n import android.health.connect.datatypes.Record;\n import android.health.connect.datatypes.StepsRecord;\n@@ -359,7 +360,10 @@ public class HealthConnectServiceLogsTests {\n         CountDownLatch latch = new CountDownLatch(1);\n         assertThat(mHealthConnectManager).isNotNull();\n         mHealthConnectManager.getChangeLogToken(\n-                new ChangeLogTokenRequest.Builder().build(),\n+                new ChangeLogTokenRequest.Builder()\n+                        .addRecordType(BloodPressureRecord.class)\n+                        .addRecordType(HeartRateRecord.class)\n+                        .build(),\n                 Executors.newSingleThreadExecutor(),\n                 new OutcomeReceiver<>() {\n \ndiff --git a/tests/cts/hostsidetests/healthconnect/device/src/android/healthconnect/cts/device/HealthConnectDeviceTest.java b/tests/cts/hostsidetests/healthconnect/device/src/android/healthconnect/cts/device/HealthConnectDeviceTest.java\nindex da31eb241..f9ff1120c 100644\n--- a/tests/cts/hostsidetests/healthconnect/device/src/android/healthconnect/cts/device/HealthConnectDeviceTest.java\n+++ b/tests/cts/hostsidetests/healthconnect/device/src/android/healthconnect/cts/device/HealthConnectDeviceTest.java\n@@ -266,70 +266,4 @@ public class HealthConnectDeviceTest {\n                         APP_A_WITH_READ_WRITE_PERMS, recordClassesToRead);\n         assertThat(bundle.getInt(READ_RECORDS_SIZE)).isEqualTo(noOfRecordsInsertedByAppA);\n     }\n-\n-    @Test\n-    public void testAppCanReadChangeLogsUsingDataOriginFilters() throws Exception {\n-        Bundle bundle =\n-                getChangeLogTokenAs(\n-                        APP_B_WITH_READ_WRITE_PERMS, APP_A_WITH_READ_WRITE_PERMS.getPackageName());\n-        String changeLogTokenForAppB = bundle.getString(CHANGE_LOG_TOKEN);\n-\n-        bundle =\n-                getChangeLogTokenAs(\n-                        APP_A_WITH_READ_WRITE_PERMS, APP_B_WITH_READ_WRITE_PERMS.getPackageName());\n-        String changeLogTokenForAppA = bundle.getString(CHANGE_LOG_TOKEN);\n-\n-        bundle = insertRecordAs(APP_A_WITH_READ_WRITE_PERMS);\n-        assertThat(bundle.getBoolean(SUCCESS)).isTrue();\n-\n-        List<TestUtils.RecordTypeAndRecordIds> listOfRecordIdsAndClass =\n-                (List<TestUtils.RecordTypeAndRecordIds>) bundle.getSerializable(RECORD_IDS);\n-\n-        List<String> listOfRecordIdsInsertedByAppA = new ArrayList<>();\n-        int noOfRecordsInsertedByAppA = 0;\n-        for (TestUtils.RecordTypeAndRecordIds recordTypeAndRecordIds : listOfRecordIdsAndClass) {\n-            noOfRecordsInsertedByAppA += recordTypeAndRecordIds.getRecordIds().size();\n-            listOfRecordIdsInsertedByAppA.addAll(recordTypeAndRecordIds.getRecordIds());\n-        }\n-\n-        updateRecordsAs(APP_A_WITH_READ_WRITE_PERMS, listOfRecordIdsAndClass);\n-\n-        bundle = insertRecordAs(APP_B_WITH_READ_WRITE_PERMS);\n-        assertThat(bundle.getBoolean(SUCCESS)).isTrue();\n-\n-        listOfRecordIdsAndClass =\n-                (List<TestUtils.RecordTypeAndRecordIds>) bundle.getSerializable(RECORD_IDS);\n-\n-        int noOfRecordsInsertedByAppB = 0;\n-        for (TestUtils.RecordTypeAndRecordIds recordTypeAndRecordIds : listOfRecordIdsAndClass) {\n-            noOfRecordsInsertedByAppB += recordTypeAndRecordIds.getRecordIds().size();\n-        }\n-\n-        deleteRecordsAs(APP_B_WITH_READ_WRITE_PERMS, listOfRecordIdsAndClass);\n-\n-        bundle =\n-                readChangeLogsUsingDataOriginFiltersAs(\n-                        APP_B_WITH_READ_WRITE_PERMS, changeLogTokenForAppB);\n-\n-        ChangeLogsResponse response = bundle.getParcelable(CHANGE_LOGS_RESPONSE);\n-\n-        assertThat(response.getUpsertedRecords().size()).isEqualTo(noOfRecordsInsertedByAppA);\n-        assertThat(\n-                        response.getUpsertedRecords().stream()\n-                                .map(Record::getMetadata)\n-                                .map(Metadata::getId)\n-                                .toList())\n-                .containsExactlyElementsIn(listOfRecordIdsInsertedByAppA);\n-\n-        assertThat(response.getDeletedLogs().size()).isEqualTo(0);\n-\n-        bundle =\n-                readChangeLogsUsingDataOriginFiltersAs(\n-                        APP_A_WITH_READ_WRITE_PERMS, changeLogTokenForAppA);\n-\n-        response = bundle.getParcelable(CHANGE_LOGS_RESPONSE);\n-\n-        assertThat(response.getUpsertedRecords().size()).isEqualTo(0);\n-        assertThat(response.getDeletedLogs().size()).isEqualTo(noOfRecordsInsertedByAppB);\n-    }\n }\ndiff --git a/tests/cts/src/android/healthconnect/cts/HealthConnectChangeLogsTests.java b/tests/cts/src/android/healthconnect/cts/HealthConnectChangeLogsTests.java\nindex 71e38ef57..c58bae239 100644\n--- a/tests/cts/src/android/healthconnect/cts/HealthConnectChangeLogsTests.java\n+++ b/tests/cts/src/android/healthconnect/cts/HealthConnectChangeLogsTests.java\n@@ -18,6 +18,8 @@ package android.healthconnect.cts;\n \n import static com.google.common.truth.Truth.assertThat;\n \n+import static org.junit.Assert.assertThrows;\n+\n import android.content.Context;\n import android.health.connect.changelog.ChangeLogTokenRequest;\n import android.health.connect.changelog.ChangeLogTokenResponse;\n@@ -53,7 +55,8 @@ public class HealthConnectChangeLogsTests {\n \n     @Test\n     public void testGetChangeLogToken() throws InterruptedException {\n-        ChangeLogTokenRequest changeLogTokenRequest = new ChangeLogTokenRequest.Builder().build();\n+        ChangeLogTokenRequest changeLogTokenRequest =\n+                new ChangeLogTokenRequest.Builder().addRecordType(StepsRecord.class).build();\n         assertThat(TestUtils.getChangeLogToken(changeLogTokenRequest)).isNotNull();\n         assertThat(changeLogTokenRequest.getRecordTypes()).isNotNull();\n         assertThat(changeLogTokenRequest.getDataOriginFilters()).isNotNull();\n@@ -62,7 +65,8 @@ public class HealthConnectChangeLogsTests {\n     @Test\n     public void testChangeLogs_insert_default() throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                TestUtils.getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                TestUtils.getChangeLogToken(\n+                        TestUtils.getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n         assertThat(changeLogsRequest.getToken()).isNotNull();\n@@ -82,7 +86,7 @@ public class HealthConnectChangeLogsTests {\n     public void testChangeLogs_insert_dataOrigin_filter_incorrect() throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n                 TestUtils.getChangeLogToken(\n-                        new ChangeLogTokenRequest.Builder()\n+                        TestUtils.getChangeLogTokenRequestForTestRecordTypes()\n                                 .addDataOriginFilter(\n                                         new DataOrigin.Builder().setPackageName(\"random\").build())\n                                 .build());\n@@ -106,7 +110,7 @@ public class HealthConnectChangeLogsTests {\n         Context context = ApplicationProvider.getApplicationContext();\n         ChangeLogTokenResponse tokenResponse =\n                 TestUtils.getChangeLogToken(\n-                        new ChangeLogTokenRequest.Builder()\n+                        TestUtils.getChangeLogTokenRequestForTestRecordTypes()\n                                 .addDataOriginFilter(\n                                         new DataOrigin.Builder()\n                                                 .setPackageName(context.getPackageName())\n@@ -160,7 +164,8 @@ public class HealthConnectChangeLogsTests {\n     @Test\n     public void testChangeLogs_insertAndDelete_default() throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                TestUtils.getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                TestUtils.getChangeLogToken(\n+                        TestUtils.getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n         ChangeLogsResponse response = TestUtils.getChangeLogs(changeLogsRequest);\n@@ -186,7 +191,8 @@ public class HealthConnectChangeLogsTests {\n     @Test\n     public void testChangeLogs_insertAndDelete_beforePermission() throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                TestUtils.getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                TestUtils.getChangeLogToken(new ChangeLogTokenRequest.Builder().addRecordType(\n+                        StepsRecord.class).build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n         ChangeLogsResponse response = TestUtils.getChangeLogs(changeLogsRequest);\n@@ -212,7 +218,7 @@ public class HealthConnectChangeLogsTests {\n             throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n                 TestUtils.getChangeLogToken(\n-                        new ChangeLogTokenRequest.Builder()\n+                        TestUtils.getChangeLogTokenRequestForTestRecordTypes()\n                                 .addDataOriginFilter(\n                                         new DataOrigin.Builder().setPackageName(\"random\").build())\n                                 .build());\n@@ -237,7 +243,7 @@ public class HealthConnectChangeLogsTests {\n         Context context = ApplicationProvider.getApplicationContext();\n         ChangeLogTokenResponse tokenResponse =\n                 TestUtils.getChangeLogToken(\n-                        new ChangeLogTokenRequest.Builder()\n+                        TestUtils.getChangeLogTokenRequestForTestRecordTypes()\n                                 .addDataOriginFilter(\n                                         new DataOrigin.Builder()\n                                                 .setPackageName(context.getPackageName())\n@@ -295,7 +301,8 @@ public class HealthConnectChangeLogsTests {\n     @Test\n     public void testChangeLogs_insert_default_withPageSize() throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                TestUtils.getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                TestUtils.getChangeLogToken(\n+                        TestUtils.getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).setPageSize(1).build();\n         ChangeLogsResponse response = TestUtils.getChangeLogs(changeLogsRequest);\n@@ -310,7 +317,8 @@ public class HealthConnectChangeLogsTests {\n     @Test\n     public void testChangeLogs_insert_default_withNextPageToken() throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                TestUtils.getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                TestUtils.getChangeLogToken(\n+                        TestUtils.getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).setPageSize(1).build();\n         ChangeLogsResponse response = TestUtils.getChangeLogs(changeLogsRequest);\n@@ -340,7 +348,8 @@ public class HealthConnectChangeLogsTests {\n     @Test\n     public void testChangeLogs_insert_default_withSamePageToken() throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                TestUtils.getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                TestUtils.getChangeLogToken(\n+                        TestUtils.getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n         ChangeLogsResponse response = TestUtils.getChangeLogs(changeLogsRequest);\n@@ -358,7 +367,8 @@ public class HealthConnectChangeLogsTests {\n     @Test\n     public void testChangeLogs_checkToken_hasMorePages_False() throws InterruptedException {\n         ChangeLogTokenResponse tokenResponse =\n-                TestUtils.getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+                TestUtils.getChangeLogToken(\n+                        TestUtils.getChangeLogTokenRequestForTestRecordTypes().build());\n         ChangeLogsRequest changeLogsRequest =\n                 new ChangeLogsRequest.Builder(tokenResponse.getToken()).build();\n         ChangeLogsResponse response = TestUtils.getChangeLogs(changeLogsRequest);\ndiff --git a/tests/cts/src/android/healthconnect/cts/HealthConnectManagerTest.java b/tests/cts/src/android/healthconnect/cts/HealthConnectManagerTest.java\nindex c76dd1e2e..ca8d225cf 100644\n--- a/tests/cts/src/android/healthconnect/cts/HealthConnectManagerTest.java\n+++ b/tests/cts/src/android/healthconnect/cts/HealthConnectManagerTest.java\n@@ -1560,7 +1560,8 @@ public class HealthConnectManagerTest {\n         }\n \n         try {\n-            TestUtils.getChangeLogToken(new ChangeLogTokenRequest.Builder().build());\n+            TestUtils.getChangeLogToken(\n+                    new ChangeLogTokenRequest.Builder().addRecordType(StepsRecord.class).build());\n             Assert.fail();\n         } catch (HealthConnectException exception) {\n             assertThat(exception).isNotNull();\ndiff --git a/tests/cts/src/android/healthconnect/cts/TestUtils.java b/tests/cts/src/android/healthconnect/cts/TestUtils.java\nindex 2fcbbd0b9..552756ffb 100644\n--- a/tests/cts/src/android/healthconnect/cts/TestUtils.java\n+++ b/tests/cts/src/android/healthconnect/cts/TestUtils.java\n@@ -305,6 +305,14 @@ public class TestUtils {\n                 buildExerciseSession());\n     }\n \n+    public static ChangeLogTokenRequest.Builder getChangeLogTokenRequestForTestRecordTypes() {\n+        return new ChangeLogTokenRequest.Builder()\n+                .addRecordType(StepsRecord.class)\n+                .addRecordType(HeartRateRecord.class)\n+                .addRecordType(BasalMetabolicRateRecord.class)\n+                .addRecordType(ExerciseSessionRecord.class);\n+    }\n+\n     public static List<RecordAndIdentifier> getRecordsAndIdentifiers() {\n         return Arrays.asList(\n                 new RecordAndIdentifier(RECORD_TYPE_STEPS, getStepsRecord()),\n",
                            "downstream_patch_tokens": {
                                "openai": 4079,
                                "general": {
                                    "word_based": 1431,
                                    "char_based": 5169
                                },
                                "gemini": 5056
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java",
                                    "total_hunks": 3,
                                    "failed_hunks": [
                                        3
                                    ],
                                    "inline_merge_conflicts": [
                                        {
                                            "hunk_number": 1,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n                        if (request.getRecordTypes().isEmpty()) {\n                            throw new IllegalArgumentException(\n                                    \"Requested record types must not be empty.\");\n                        }\n                        mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                request.getRecordTypesList(), attributionSource);\n                        callback.onResult(\n>>>>>>> UPSTREAM PATCH (commit dcb9791c2ed95b06a2ab9656f10fba3a35933ac5)",
                                            "merge_conflict_tokens": {
                                                "openai": 96,
                                                "general": {
                                                    "word_based": 28,
                                                    "char_based": 139
                                                },
                                                "gemini": 121
                                            }
                                        },
                                        {
                                            "hunk_number": 2,
                                            "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n                                        callerPackageName, request.getToken());\n                        tryAcquireApiCallQuota(\n                                uid, QuotaCategory.QUOTA_CATEGORY_READ, isInForeground, logger);\n                        if (changeLogsTokenRequest.getRecordTypes().isEmpty()) {\n                            throw new IllegalArgumentException(\n                                    \"Requested record types must not be empty.\");\n                        }\n                        mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                changeLogsTokenRequest.getRecordTypes(), attributionSource);\n                        long startDateAccessEpochMilli = DEFAULT_LONG;\n>>>>>>> UPSTREAM PATCH (commit dcb9791c2ed95b06a2ab9656f10fba3a35933ac5)",
                                            "merge_conflict_tokens": {
                                                "openai": 140,
                                                "general": {
                                                    "word_based": 38,
                                                    "char_based": 209
                                                },
                                                "gemini": 168
                                            }
                                        }
                                    ],
                                    "inline_merge_token_summary": {
                                        "gemini": 3757,
                                        "openai": 3304,
                                        "general_word": 924,
                                        "general_char": 4872
                                    },
                                    "rej_file_content": "```diff\n--- service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java\n+++ service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java\n@@ -1031,6 +1043,10 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n                                         callerPackageName, request.getToken());\n                         tryAcquireApiCallQuota(\n                                 uid, QuotaCategory.QUOTA_CATEGORY_READ, isInForeground, logger);\n+                        if (changeLogsTokenRequest.getRecordTypes().isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Requested record types must not be empty.\");\n+                        }\n                         mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                 changeLogsTokenRequest.getRecordTypes(), attributionSource);\n                         long startDateAccessEpochMilli = DEFAULT_LONG;\n```",
                                    "rej_file_tokens": {
                                        "openai": 158,
                                        "general": {
                                            "word_based": 57,
                                            "char_based": 247
                                        },
                                        "gemini": 191
                                    },
                                    "patch_apply_output": "patching file framework/java/android/health/connect/changelog/ChangeLogTokenRequest.java\npatching file service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java\nHunk #1 succeeded at 798 with fuzz 2 (offset -141 lines).\nHunk #2 succeeded at 820 with fuzz 2 (offset -141 lines).\nHunk #3 FAILED at 1031.\n1 out of 3 hunks FAILED -- saving rejects to file service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java.rej\ncan't find file to patch at input line 71\nPerhaps you used the wrong -p or --strip option?\nThe text leading up to this was:\n--------------------------\n|diff --git a/tests/cts/utils/HealthConnectTestUtils/src/android/healthconnect/cts/utils/DataFactory.java b/tests/cts/utils/HealthConnectTestUtils/src/android/healthconnect/cts/utils/DataFactory.java\n|index e44e3f7ef..519c07143 100644\n|--- a/tests/cts/utils/HealthConnectTestUtils/src/android/healthconnect/cts/utils/DataFactory.java\n|+++ b/tests/cts/utils/HealthConnectTestUtils/src/android/healthconnect/cts/utils/DataFactory.java\n--------------------------\nFile to patch: \nSkip this patch? [y] \nSkipping patch.\n2 out of 2 hunks ignored",
                                    "inline_merge_output": "patching file service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java\nHunk #1 NOT MERGED at 942-951.\nHunk #3 NOT MERGED at 1276-1288.",
                                    "upstream_file_tokens": {
                                        "openai": 20596,
                                        "general": {
                                            "word_based": 7441,
                                            "char_based": 33394
                                        },
                                        "gemini": 24937
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2023 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.healthconnect;\n\nimport static android.Manifest.permission.MIGRATE_HEALTH_CONNECT_DATA;\nimport static android.content.pm.PackageManager.PERMISSION_GRANTED;\nimport static android.health.connect.Constants.DEFAULT_LONG;\nimport static android.health.connect.Constants.READ;\nimport static android.health.connect.HealthConnectException.ERROR_INTERNAL;\nimport static android.health.connect.HealthConnectException.ERROR_SECURITY;\nimport static android.health.connect.HealthPermissions.MANAGE_HEALTH_DATA_PERMISSION;\n\nimport static com.android.server.healthconnect.logging.HealthConnectServiceLogger.ApiMethods.DELETE_DATA;\nimport static com.android.server.healthconnect.logging.HealthConnectServiceLogger.ApiMethods.GET_CHANGES;\nimport static com.android.server.healthconnect.logging.HealthConnectServiceLogger.ApiMethods.GET_CHANGES_TOKEN;\nimport static com.android.server.healthconnect.logging.HealthConnectServiceLogger.ApiMethods.INSERT_DATA;\nimport static com.android.server.healthconnect.logging.HealthConnectServiceLogger.ApiMethods.READ_AGGREGATED_DATA;\nimport static com.android.server.healthconnect.logging.HealthConnectServiceLogger.ApiMethods.READ_DATA;\nimport static com.android.server.healthconnect.logging.HealthConnectServiceLogger.ApiMethods.UPDATE_DATA;\n\nimport android.Manifest;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.content.AttributionSource;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.database.sqlite.SQLiteException;\nimport android.health.connect.Constants;\nimport android.health.connect.FetchDataOriginsPriorityOrderResponse;\nimport android.health.connect.HealthConnectDataState;\nimport android.health.connect.HealthConnectException;\nimport android.health.connect.HealthConnectManager;\nimport android.health.connect.HealthConnectManager.DataDownloadState;\nimport android.health.connect.HealthDataCategory;\nimport android.health.connect.HealthPermissions;\nimport android.health.connect.RecordTypeInfoResponse;\nimport android.health.connect.accesslog.AccessLog;\nimport android.health.connect.accesslog.AccessLogsResponseParcel;\nimport android.health.connect.aidl.ActivityDatesRequestParcel;\nimport android.health.connect.aidl.ActivityDatesResponseParcel;\nimport android.health.connect.aidl.AggregateDataRequestParcel;\nimport android.health.connect.aidl.ApplicationInfoResponseParcel;\nimport android.health.connect.aidl.DeleteUsingFiltersRequestParcel;\nimport android.health.connect.aidl.GetPriorityResponseParcel;\nimport android.health.connect.aidl.HealthConnectExceptionParcel;\nimport android.health.connect.aidl.IAccessLogsResponseCallback;\nimport android.health.connect.aidl.IActivityDatesResponseCallback;\nimport android.health.connect.aidl.IAggregateRecordsResponseCallback;\nimport android.health.connect.aidl.IApplicationInfoResponseCallback;\nimport android.health.connect.aidl.IChangeLogsResponseCallback;\nimport android.health.connect.aidl.IDataStagingFinishedCallback;\nimport android.health.connect.aidl.IEmptyResponseCallback;\nimport android.health.connect.aidl.IGetChangeLogTokenCallback;\nimport android.health.connect.aidl.IGetHealthConnectDataStateCallback;\nimport android.health.connect.aidl.IGetHealthConnectMigrationUiStateCallback;\nimport android.health.connect.aidl.IGetPriorityResponseCallback;\nimport android.health.connect.aidl.IHealthConnectService;\nimport android.health.connect.aidl.IInsertRecordsResponseCallback;\nimport android.health.connect.aidl.IMigrationCallback;\nimport android.health.connect.aidl.IReadRecordsResponseCallback;\nimport android.health.connect.aidl.IRecordTypeInfoResponseCallback;\nimport android.health.connect.aidl.InsertRecordsResponseParcel;\nimport android.health.connect.aidl.ReadRecordsRequestParcel;\nimport android.health.connect.aidl.ReadRecordsResponseParcel;\nimport android.health.connect.aidl.RecordIdFiltersParcel;\nimport android.health.connect.aidl.RecordTypeInfoResponseParcel;\nimport android.health.connect.aidl.RecordsParcel;\nimport android.health.connect.aidl.UpdatePriorityRequestParcel;\nimport android.health.connect.changelog.ChangeLogTokenRequest;\nimport android.health.connect.changelog.ChangeLogTokenResponse;\nimport android.health.connect.changelog.ChangeLogsRequest;\nimport android.health.connect.changelog.ChangeLogsResponse;\nimport android.health.connect.changelog.ChangeLogsResponse.DeletedLog;\nimport android.health.connect.datatypes.AppInfo;\nimport android.health.connect.datatypes.DataOrigin;\nimport android.health.connect.datatypes.Record;\nimport android.health.connect.internal.datatypes.RecordInternal;\nimport android.health.connect.internal.datatypes.utils.AggregationTypeIdMapper;\nimport android.health.connect.internal.datatypes.utils.RecordMapper;\nimport android.health.connect.internal.datatypes.utils.RecordTypePermissionCategoryMapper;\nimport android.health.connect.migration.HealthConnectMigrationUiState;\nimport android.health.connect.migration.MigrationEntityParcel;\nimport android.health.connect.migration.MigrationException;\nimport android.health.connect.ratelimiter.RateLimiter;\nimport android.health.connect.ratelimiter.RateLimiter.QuotaCategory;\nimport android.health.connect.ratelimiter.RateLimiterException;\nimport android.health.connect.restore.BackupFileNamesSet;\nimport android.health.connect.restore.StageRemoteDataException;\nimport android.health.connect.restore.StageRemoteDataRequest;\nimport android.os.Binder;\nimport android.os.ParcelFileDescriptor;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.permission.PermissionManager;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.Log;\nimport android.util.Pair;\nimport android.util.Slog;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.server.LocalManagerRegistry;\nimport com.android.server.appop.AppOpsManagerLocal;\nimport com.android.server.healthconnect.backuprestore.BackupRestore;\nimport com.android.server.healthconnect.logging.HealthConnectServiceLogger;\nimport com.android.server.healthconnect.migration.DataMigrationManager;\nimport com.android.server.healthconnect.migration.MigrationCleaner;\nimport com.android.server.healthconnect.migration.MigrationStateManager;\nimport com.android.server.healthconnect.migration.MigrationUiStateManager;\nimport com.android.server.healthconnect.migration.PriorityMigrationHelper;\nimport com.android.server.healthconnect.permission.DataPermissionEnforcer;\nimport com.android.server.healthconnect.permission.FirstGrantTimeManager;\nimport com.android.server.healthconnect.permission.HealthConnectPermissionHelper;\nimport com.android.server.healthconnect.storage.AutoDeleteService;\nimport com.android.server.healthconnect.storage.TransactionManager;\nimport com.android.server.healthconnect.storage.datatypehelpers.AccessLogsHelper;\nimport com.android.server.healthconnect.storage.datatypehelpers.ActivityDateHelper;\nimport com.android.server.healthconnect.storage.datatypehelpers.AppInfoHelper;\nimport com.android.server.healthconnect.storage.datatypehelpers.ChangeLogsHelper;\nimport com.android.server.healthconnect.storage.datatypehelpers.ChangeLogsRequestHelper;\nimport com.android.server.healthconnect.storage.datatypehelpers.DeviceInfoHelper;\nimport com.android.server.healthconnect.storage.datatypehelpers.HealthDataCategoryPriorityHelper;\nimport com.android.server.healthconnect.storage.datatypehelpers.MigrationEntityHelper;\nimport com.android.server.healthconnect.storage.datatypehelpers.RecordHelper;\nimport com.android.server.healthconnect.storage.request.AggregateTransactionRequest;\nimport com.android.server.healthconnect.storage.request.DeleteTransactionRequest;\nimport com.android.server.healthconnect.storage.request.ReadTransactionRequest;\nimport com.android.server.healthconnect.storage.request.UpsertTransactionRequest;\nimport com.android.server.healthconnect.storage.utils.RecordHelperProvider;\n\nimport java.io.IOException;\nimport java.time.Instant;\nimport java.time.LocalDate;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.stream.Collectors;\n\n/**\n * IHealthConnectService's implementation\n *\n * @hide\n */\nfinal class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n    private static final String TAG = \"HealthConnectService\";\n    // Permission for test api for deleting staged data\n    private static final String DELETE_STAGED_HEALTH_CONNECT_REMOTE_DATA_PERMISSION =\n            \"android.permission.DELETE_STAGED_HEALTH_CONNECT_REMOTE_DATA\";\n    // Allows an application to act as a backup inter-agent to send and receive HealthConnect data\n    private static final String HEALTH_CONNECT_BACKUP_INTER_AGENT_PERMISSION =\n            \"android.permission.HEALTH_CONNECT_BACKUP_INTER_AGENT\";\n\n    private static final String TAG_INSERT = \"HealthConnectInsert\";\n    private static final String TAG_READ = \"HealthConnectRead\";\n    private static final String TAG_GRANT_PERMISSION = \"HealthConnectGrantReadPermissions\";\n    private static final String TAG_READ_PERMISSION = \"HealthConnectReadPermission\";\n    private static final String TAG_INSERT_SUBTASKS = \"HealthConnectInsertSubtasks\";\n\n    private static final String TAG_DELETE_SUBTASKS = \"HealthConnectDeleteSubtasks\";\n    private static final String TAG_READ_SUBTASKS = \"HealthConnectReadSubtasks\";\n    private static final int TRACE_TAG_INSERT = TAG_INSERT.hashCode();\n    private static final int TRACE_TAG_READ = TAG_READ.hashCode();\n    private static final int TRACE_TAG_GRANT_PERMISSION = TAG_GRANT_PERMISSION.hashCode();\n    private static final int TRACE_TAG_READ_PERMISSION = TAG_READ_PERMISSION.hashCode();\n    private static final int TRACE_TAG_INSERT_SUBTASKS = TAG_INSERT_SUBTASKS.hashCode();\n    private static final int TRACE_TAG_DELETE_SUBTASKS = TAG_DELETE_SUBTASKS.hashCode();\n    private static final int TRACE_TAG_READ_SUBTASKS = TAG_READ_SUBTASKS.hashCode();\n\n    private final TransactionManager mTransactionManager;\n    private final HealthConnectPermissionHelper mPermissionHelper;\n    private final FirstGrantTimeManager mFirstGrantTimeManager;\n    private final Context mContext;\n    private final PermissionManager mPermissionManager;\n\n    private final BackupRestore mBackupRestore;\n    private final MigrationStateManager mMigrationStateManager;\n\n    private final DataPermissionEnforcer mDataPermissionEnforcer;\n\n    private final AppOpsManagerLocal mAppOpsManagerLocal;\n    private final MigrationUiStateManager mMigrationUiStateManager;\n\n    private volatile UserHandle mCurrentForegroundUser;\n\n    HealthConnectServiceImpl(\n            TransactionManager transactionManager,\n            HealthConnectPermissionHelper permissionHelper,\n            MigrationCleaner migrationCleaner,\n            FirstGrantTimeManager firstGrantTimeManager,\n            MigrationStateManager migrationStateManager,\n            MigrationUiStateManager migrationUiStateManager,\n            Context context) {\n        mTransactionManager = transactionManager;\n        mPermissionHelper = permissionHelper;\n        mFirstGrantTimeManager = firstGrantTimeManager;\n        mContext = context;\n        mCurrentForegroundUser = context.getUser();\n        mPermissionManager = mContext.getSystemService(PermissionManager.class);\n        mMigrationStateManager = migrationStateManager;\n        mDataPermissionEnforcer = new DataPermissionEnforcer(mPermissionManager, mContext);\n        mAppOpsManagerLocal = LocalManagerRegistry.getManager(AppOpsManagerLocal.class);\n        mBackupRestore =\n                new BackupRestore(mFirstGrantTimeManager, mMigrationStateManager, mContext);\n        mMigrationUiStateManager = migrationUiStateManager;\n        migrationCleaner.attachTo(migrationStateManager);\n        mMigrationUiStateManager.attachTo(migrationStateManager);\n    }\n\n    public void onUserSwitching(UserHandle currentForegroundUser) {\n        mCurrentForegroundUser = currentForegroundUser;\n        mBackupRestore.setupForUser(currentForegroundUser);\n    }\n\n    @Override\n    public void grantHealthPermission(\n            @NonNull String packageName, @NonNull String permissionName, @NonNull UserHandle user) {\n        throwIllegalStateExceptionIfDataSyncInProgress();\n        Trace.traceBegin(TRACE_TAG_GRANT_PERMISSION, TAG_GRANT_PERMISSION);\n        mPermissionHelper.grantHealthPermission(packageName, permissionName, user);\n        Trace.traceEnd(TRACE_TAG_GRANT_PERMISSION);\n    }\n\n    @Override\n    public void revokeHealthPermission(\n            @NonNull String packageName,\n            @NonNull String permissionName,\n            @Nullable String reason,\n            @NonNull UserHandle user) {\n        throwIllegalStateExceptionIfDataSyncInProgress();\n        mPermissionHelper.revokeHealthPermission(packageName, permissionName, reason, user);\n    }\n\n    @Override\n    public void revokeAllHealthPermissions(\n            @NonNull String packageName, @Nullable String reason, @NonNull UserHandle user) {\n        throwIllegalStateExceptionIfDataSyncInProgress();\n        mPermissionHelper.revokeAllHealthPermissions(packageName, reason, user);\n    }\n\n    @Override\n    public List<String> getGrantedHealthPermissions(\n            @NonNull String packageName, @NonNull UserHandle user) {\n        throwIllegalStateExceptionIfDataSyncInProgress();\n        Trace.traceBegin(TRACE_TAG_READ_PERMISSION, TAG_READ_PERMISSION);\n        List<String> grantedPermissions =\n                mPermissionHelper.getGrantedHealthPermissions(packageName, user);\n        Trace.traceEnd(TRACE_TAG_READ_PERMISSION);\n        return grantedPermissions;\n    }\n\n    @Override\n    public long getHistoricalAccessStartDateInMilliseconds(\n            @NonNull String packageName, @NonNull UserHandle userHandle) {\n        throwIllegalStateExceptionIfDataSyncInProgress();\n        Instant date = mPermissionHelper.getHealthDataStartDateAccess(packageName, userHandle);\n        if (date == null) {\n            return Constants.DEFAULT_LONG;\n        } else {\n            return date.toEpochMilli();\n        }\n    }\n\n    /**\n     * Inserts {@code recordsParcel} into the HealthConnect database.\n     *\n     * @param recordsParcel parcel for list of records to be inserted.\n     * @param callback Callback to receive result of performing this operation. The keys returned in\n     *     {@link InsertRecordsResponseParcel} are the unique IDs of the input records. The values\n     *     are in same order as {@code record}. In case of an error or a permission failure the\n     *     HealthConnect service, {@link IInsertRecordsResponseCallback#onError} will be invoked\n     *     with a {@link HealthConnectExceptionParcel}.\n     */\n    @Override\n    public void insertRecords(\n            @NonNull AttributionSource attributionSource,\n            @NonNull RecordsParcel recordsParcel,\n            @NonNull IInsertRecordsResponseCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n        final HealthConnectServiceLogger.Builder builder =\n                new HealthConnectServiceLogger.Builder(false, INSERT_DATA)\n                        .setPackageName(attributionSource.getPackageName());\n\n        HealthConnectThreadScheduler.schedule(\n                mContext,\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        verifyPackageNameFromUid(uid, attributionSource);\n                        if (hasDataManagementPermission(uid, pid)) {\n                            throw new SecurityException(\n                                    \"Apps with android.permission.MANAGE_HEALTH_DATA permission are\"\n                                            + \" not allowed to insert records\");\n                        }\n                        enforceMemoryRateLimit(\n                                recordsParcel.getRecordsSize(),\n                                recordsParcel.getRecordsChunkSize());\n                        final List<RecordInternal<?>> recordInternals = recordsParcel.getRecords();\n                        builder.setNumberOfRecords(recordInternals.size());\n                        throwExceptionIfDataSyncInProgress();\n                        mDataPermissionEnforcer.enforceRecordsWritePermissions(\n                                recordInternals, attributionSource);\n                        boolean isInForeground = mAppOpsManagerLocal.isUidInForeground(uid);\n                        tryAcquireApiCallQuota(\n                                uid, QuotaCategory.QUOTA_CATEGORY_WRITE, isInForeground, builder);\n                        Trace.traceBegin(TRACE_TAG_INSERT, TAG_INSERT);\n                        UpsertTransactionRequest insertRequest =\n                                new UpsertTransactionRequest(\n                                        attributionSource.getPackageName(),\n                                        recordInternals,\n                                        mContext,\n                                        /* isInsertRequest */ true,\n                                        mDataPermissionEnforcer\n                                                .collectExtraWritePermissionStateMapping(\n                                                        recordInternals, attributionSource));\n                        List<String> uuids = mTransactionManager.insertAll(insertRequest);\n                        tryAndReturnResult(callback, uuids, builder);\n\n                        HealthConnectThreadScheduler.scheduleInternalTask(\n                                () -> postInsertTasks(attributionSource, recordsParcel));\n\n                        finishDataDeliveryWriteRecords(recordInternals, attributionSource);\n                        logRecordTypeSpecificUpsertMetrics(\n                                recordInternals, attributionSource.getPackageName());\n                        builder.setDataTypesFromRecordInternals(recordInternals);\n                    } catch (SQLiteException sqLiteException) {\n                        builder.setHealthDataServiceApiStatusError(HealthConnectException.ERROR_IO);\n                        Slog.e(TAG, \"SQLiteException: \", sqLiteException);\n                        tryAndThrowException(\n                                callback, sqLiteException, HealthConnectException.ERROR_IO);\n                    } catch (SecurityException securityException) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_SECURITY);\n                        Slog.e(TAG, \"SecurityException: \", securityException);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (HealthConnectException healthConnectException) {\n                        builder.setHealthDataServiceApiStatusError(\n                                healthConnectException.getErrorCode());\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception e) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n                        Slog.e(TAG, \"Exception: \", e);\n                        tryAndThrowException(callback, e, ERROR_INTERNAL);\n                    } finally {\n                        Trace.traceEnd(TRACE_TAG_INSERT);\n                        builder.build().log();\n                    }\n                },\n                uid,\n                false);\n    }\n\n    private void postInsertTasks(\n            @NonNull AttributionSource attributionSource, @NonNull RecordsParcel recordsParcel) {\n        Trace.traceBegin(TRACE_TAG_INSERT_SUBTASKS, TAG_INSERT.concat(\"PostInsertTasks\"));\n\n        ActivityDateHelper.getInstance().insertRecordDate(recordsParcel.getRecords());\n        Set<Integer> recordsTypesInsertedSet =\n                recordsParcel.getRecords().stream()\n                        .map(RecordInternal::getRecordType)\n                        .collect(Collectors.toSet());\n        // Update AppInfo table with the record types of records inserted in the request for the\n        // current package.\n        AppInfoHelper.getInstance()\n                .updateAppInfoRecordTypesUsedOnInsert(\n                        recordsTypesInsertedSet, attributionSource.getPackageName());\n\n        Trace.traceEnd(TRACE_TAG_INSERT_SUBTASKS);\n    }\n\n    /**\n     * Returns aggregation results based on the {@code request} into the HealthConnect database.\n     *\n     * @param request represents the request using which the aggregation is to be performed.\n     * @param callback Callback to receive result of performing this operation.\n     */\n    public void aggregateRecords(\n            @NonNull AttributionSource attributionSource,\n            AggregateDataRequestParcel request,\n            IAggregateRecordsResponseCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n        final boolean holdsDataManagementPermission = hasDataManagementPermission(uid, pid);\n        final HealthConnectServiceLogger.Builder builder =\n                new HealthConnectServiceLogger.Builder(\n                                holdsDataManagementPermission, READ_AGGREGATED_DATA)\n                        .setPackageName(attributionSource.getPackageName());\n\n        HealthConnectThreadScheduler.schedule(\n                mContext,\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        verifyPackageNameFromUid(uid, attributionSource);\n                        builder.setNumberOfRecords(request.getAggregateIds().length);\n                        throwExceptionIfDataSyncInProgress();\n                        List<Integer> recordTypesToTest = new ArrayList<>();\n                        for (int aggregateId : request.getAggregateIds()) {\n                            recordTypesToTest.addAll(\n                                    AggregationTypeIdMapper.getInstance()\n                                            .getAggregationTypeFor(aggregateId)\n                                            .getApplicableRecordTypeIds());\n                        }\n\n                        if (!holdsDataManagementPermission) {\n                            boolean isInForeground = mAppOpsManagerLocal.isUidInForeground(uid);\n                            if (!isInForeground) {\n                                throwSecurityException(\n                                        attributionSource.getPackageName()\n                                                + \"must be in foreground to call aggregate method\");\n                            }\n                            mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                    recordTypesToTest, attributionSource);\n                            tryAcquireApiCallQuota(\n                                    uid,\n                                    RateLimiter.QuotaCategory.QUOTA_CATEGORY_READ,\n                                    isInForeground,\n                                    builder);\n                        }\n                        callback.onResult(\n                                new AggregateTransactionRequest(\n                                                attributionSource.getPackageName(), request)\n                                        .getAggregateDataResponseParcel());\n                        finishDataDeliveryRead(recordTypesToTest, attributionSource);\n                        builder.setDataTypesFromRecordTypes(recordTypesToTest)\n                                .setHealthDataServiceApiStatusSuccess();\n                    } catch (SQLiteException sqLiteException) {\n                        builder.setHealthDataServiceApiStatusError(HealthConnectException.ERROR_IO);\n                        Slog.e(TAG, \"SQLiteException: \", sqLiteException);\n                        tryAndThrowException(\n                                callback, sqLiteException, HealthConnectException.ERROR_IO);\n                    } catch (SecurityException securityException) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_SECURITY);\n                        Slog.e(TAG, \"SecurityException: \", securityException);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (HealthConnectException healthConnectException) {\n                        builder.setHealthDataServiceApiStatusError(\n                                healthConnectException.getErrorCode());\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception e) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n                        Slog.e(TAG, \"Exception: \", e);\n                        tryAndThrowException(callback, e, ERROR_INTERNAL);\n                    } finally {\n                        builder.build().log();\n                    }\n                },\n                uid,\n                holdsDataManagementPermission);\n    }\n\n    /**\n     * Read records {@code recordsParcel} from HealthConnect database.\n     *\n     * @param request ReadRecordsRequestParcel is parcel for the request object containing {@link\n     *     RecordIdFiltersParcel}.\n     * @param callback Callback to receive result of performing this operation. The records are\n     *     returned in {@link RecordsParcel} . In case of an error or a permission failure the\n     *     HealthConnect service, {@link IReadRecordsResponseCallback#onError} will be invoked with\n     *     a {@link HealthConnectExceptionParcel}.\n     */\n    @Override\n    public void readRecords(\n            @NonNull AttributionSource attributionSource,\n            @NonNull ReadRecordsRequestParcel request,\n            @NonNull IReadRecordsResponseCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n        final boolean holdsDataManagementPermission = hasDataManagementPermission(uid, pid);\n        final HealthConnectServiceLogger.Builder builder =\n                new HealthConnectServiceLogger.Builder(holdsDataManagementPermission, READ_DATA)\n                        .setPackageName(attributionSource.getPackageName());\n\n        HealthConnectThreadScheduler.schedule(\n                mContext,\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        verifyPackageNameFromUid(uid, attributionSource);\n                        throwExceptionIfDataSyncInProgress();\n                        AtomicBoolean enforceSelfRead = new AtomicBoolean();\n                        if (!holdsDataManagementPermission) {\n                            boolean isInForeground = mAppOpsManagerLocal.isUidInForeground(uid);\n                            // If requesting app has only write permission allowed but no read\n                            // permission for the record type or if app is not in foreground then\n                            // allow to read its own records.\n                            enforceSelfRead.set(\n                                    mDataPermissionEnforcer.enforceReadAccessAndGetEnforceSelfRead(\n                                                    request.getRecordType(), attributionSource)\n                                            || !isInForeground);\n                            if (Constants.DEBUG) {\n                                Slog.d(\n                                        TAG,\n                                        \"Enforce self read for package \"\n                                                + attributionSource.getPackageName()\n                                                + \":\"\n                                                + enforceSelfRead.get());\n                            }\n                            tryAcquireApiCallQuota(\n                                    uid,\n                                    QuotaCategory.QUOTA_CATEGORY_READ,\n                                    isInForeground,\n                                    builder);\n                        }\n                        final Map<String, Boolean> extraReadPermsToGrantState =\n                                Collections.unmodifiableMap(\n                                        mDataPermissionEnforcer\n                                                .collectExtraReadPermissionToStateMapping(\n                                                        Set.of(request.getRecordType()),\n                                                        attributionSource));\n\n                        Trace.traceBegin(TRACE_TAG_READ, TAG_READ);\n                        try {\n                            long startDateAccess = request.getStartTime();\n                            if (!holdsDataManagementPermission) {\n                                Instant startInstant =\n                                        mPermissionHelper.getHealthDataStartDateAccess(\n                                                attributionSource.getPackageName(), userHandle);\n                                if (startInstant == null) {\n                                    throwExceptionIncorrectPermissionState();\n                                }\n\n                                // Always set the startDateAccess for local time filter, as for\n                                // local date time we use it in conjunction with the time filter\n                                // start-time\n                                if (request.usesLocalTimeFilter()\n                                        || startInstant.toEpochMilli() > startDateAccess) {\n                                    startDateAccess = startInstant.toEpochMilli();\n                                }\n                            }\n                            Pair<List<RecordInternal<?>>, Long> readRecordsResponse =\n                                    mTransactionManager.readRecordsAndGetNextToken(\n                                            new ReadTransactionRequest(\n                                                    attributionSource.getPackageName(),\n                                                    request,\n                                                    startDateAccess,\n                                                    enforceSelfRead.get(),\n                                                    extraReadPermsToGrantState));\n                            builder.setNumberOfRecords(readRecordsResponse.first.size());\n                            long pageToken =\n                                    request.getRecordIdFiltersParcel() == null\n                                            ? readRecordsResponse.second\n                                            : DEFAULT_LONG;\n                            if (pageToken != DEFAULT_LONG) {\n                                // pagetoken is used here to store sorting order of the result.\n                                // An even pagetoken indicate ascending and Odd page token indicate\n                                // descending sort order. This detail from page token will be used\n                                // in next read request to have same sort order.\n                                pageToken =\n                                        request.isAscending() ? pageToken * 2 : pageToken * 2 + 1;\n                            }\n\n                            if (Constants.DEBUG) {\n                                Slog.d(TAG, \"pageToken: \" + pageToken);\n                            }\n\n                            final String packageName = attributionSource.getPackageName();\n                            final List<Integer> recordTypes =\n                                    Collections.singletonList(request.getRecordType());\n                            // Calls from controller APK should not be recorded in access logs\n                            // If an app is reading only its own data then it is not recorded in\n                            // access logs.\n                            boolean requiresLogging =\n                                    !holdsDataManagementPermission && !enforceSelfRead.get();\n                            if (requiresLogging) {\n                                Trace.traceBegin(\n                                        TRACE_TAG_READ_SUBTASKS, TAG_READ.concat(\"AddAccessLog\"));\n                                AccessLogsHelper.getInstance()\n                                        .addAccessLog(packageName, recordTypes, READ);\n                                Trace.traceEnd(TRACE_TAG_READ_SUBTASKS);\n                            }\n                            callback.onResult(\n                                    new ReadRecordsResponseParcel(\n                                            new RecordsParcel(readRecordsResponse.first),\n                                            pageToken));\n                            finishDataDeliveryRead(request.getRecordType(), attributionSource);\n                            if (requiresLogging) {\n                                logRecordTypeSpecificReadMetrics(\n                                        readRecordsResponse.first, packageName);\n                            }\n                            builder.setDataTypesFromRecordInternals(readRecordsResponse.first)\n                                    .setHealthDataServiceApiStatusSuccess();\n                        } catch (TypeNotPresentException exception) {\n                            // All the requested package names are not present, so simply\n                            // return an empty list\n                            if (ReadTransactionRequest.TYPE_NOT_PRESENT_PACKAGE_NAME.equals(\n                                    exception.typeName())) {\n                                if (Constants.DEBUG) {\n                                    Slog.d(\n                                            TAG,\n                                            \"No app info recorded for \"\n                                                    + attributionSource.getPackageName());\n                                }\n                                callback.onResult(\n                                        new ReadRecordsResponseParcel(\n                                                new RecordsParcel(new ArrayList<>()),\n                                                DEFAULT_LONG));\n                                builder.setHealthDataServiceApiStatusSuccess();\n                            } else {\n                                builder.setHealthDataServiceApiStatusError(\n                                        HealthConnectException.ERROR_UNKNOWN);\n                                throw exception;\n                            }\n                        }\n                    } catch (SQLiteException sqLiteException) {\n                        builder.setHealthDataServiceApiStatusError(HealthConnectException.ERROR_IO);\n                        Slog.e(TAG, \"SQLiteException: \", sqLiteException);\n                        tryAndThrowException(\n                                callback, sqLiteException, HealthConnectException.ERROR_IO);\n                    } catch (SecurityException securityException) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_SECURITY);\n                        Slog.e(TAG, \"SecurityException: \", securityException);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (IllegalStateException illegalStateException) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n                        Slog.e(TAG, \"IllegalStateException: \", illegalStateException);\n                        tryAndThrowException(callback, illegalStateException, ERROR_INTERNAL);\n                    } catch (HealthConnectException healthConnectException) {\n                        builder.setHealthDataServiceApiStatusError(\n                                healthConnectException.getErrorCode());\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception e) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n                        Slog.e(TAG, \"Exception: \", e);\n                        tryAndThrowException(callback, e, ERROR_INTERNAL);\n                    } finally {\n                        Trace.traceEnd(TRACE_TAG_READ);\n                        builder.build().log();\n                    }\n                },\n                uid,\n                holdsDataManagementPermission);\n    }\n\n    /**\n     * Updates {@code recordsParcel} into the HealthConnect database.\n     *\n     * @param recordsParcel parcel for list of records to be updated.\n     * @param callback Callback to receive result of performing this operation. In case of an error\n     *     or a permission failure the HealthConnect service, {@link IEmptyResponseCallback#onError}\n     *     will be invoked with a {@link HealthConnectException}.\n     */\n    @Override\n    public void updateRecords(\n            @NonNull AttributionSource attributionSource,\n            @NonNull RecordsParcel recordsParcel,\n            @NonNull IEmptyResponseCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n        final HealthConnectServiceLogger.Builder builder =\n                new HealthConnectServiceLogger.Builder(false, UPDATE_DATA)\n                        .setPackageName(attributionSource.getPackageName());\n        HealthConnectThreadScheduler.schedule(\n                mContext,\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        verifyPackageNameFromUid(uid, attributionSource);\n                        if (hasDataManagementPermission(uid, pid)) {\n                            throw new SecurityException(\n                                    \"Apps with android.permission.MANAGE_HEALTH_DATA permission are\"\n                                            + \" not allowed to insert records\");\n                        }\n                        enforceMemoryRateLimit(\n                                recordsParcel.getRecordsSize(),\n                                recordsParcel.getRecordsChunkSize());\n                        final List<RecordInternal<?>> recordInternals = recordsParcel.getRecords();\n                        builder.setNumberOfRecords(recordInternals.size());\n                        throwExceptionIfDataSyncInProgress();\n                        mDataPermissionEnforcer.enforceRecordsWritePermissions(\n                                recordInternals, attributionSource);\n                        boolean isInForeground = mAppOpsManagerLocal.isUidInForeground(uid);\n                        tryAcquireApiCallQuota(\n                                uid, QuotaCategory.QUOTA_CATEGORY_WRITE, isInForeground, builder);\n                        UpsertTransactionRequest request =\n                                new UpsertTransactionRequest(\n                                        attributionSource.getPackageName(),\n                                        recordInternals,\n                                        mContext,\n                                        /* isInsertRequest */ false,\n                                        mDataPermissionEnforcer\n                                                .collectExtraWritePermissionStateMapping(\n                                                        recordInternals, attributionSource));\n                        mTransactionManager.updateAll(request);\n                        tryAndReturnResult(callback, builder);\n                        finishDataDeliveryWriteRecords(recordInternals, attributionSource);\n                        logRecordTypeSpecificUpsertMetrics(\n                                recordInternals, attributionSource.getPackageName());\n                        builder.setDataTypesFromRecordInternals(recordInternals);\n                        // Update activity dates table\n                        HealthConnectThreadScheduler.scheduleInternalTask(\n                                () ->\n                                        ActivityDateHelper.getInstance()\n                                                .reSyncByRecordTypeIds(\n                                                        recordInternals.stream()\n                                                                .map(RecordInternal::getRecordType)\n                                                                .toList()));\n                    } catch (SecurityException securityException) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_SECURITY);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (SQLiteException sqLiteException) {\n                        builder.setHealthDataServiceApiStatusError(HealthConnectException.ERROR_IO);\n                        Slog.e(TAG, \"SqlException: \", sqLiteException);\n                        tryAndThrowException(\n                                callback, sqLiteException, HealthConnectException.ERROR_IO);\n                    } catch (IllegalArgumentException illegalArgumentException) {\n                        builder.setHealthDataServiceApiStatusError(\n                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n\n                        Slog.e(TAG, \"IllegalArgumentException: \", illegalArgumentException);\n                        tryAndThrowException(\n                                callback,\n                                illegalArgumentException,\n                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n                    } catch (HealthConnectException healthConnectException) {\n                        builder.setHealthDataServiceApiStatusError(\n                                healthConnectException.getErrorCode());\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception e) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n\n                        Slog.e(TAG, \"Exception: \", e);\n                        tryAndThrowException(callback, e, ERROR_INTERNAL);\n                    } finally {\n                        builder.build().log();\n                    }\n                },\n                uid,\n                false);\n    }\n\n    /**\n     * @see HealthConnectManager#getChangeLogToken\n     */\n    @Override\n    public void getChangeLogToken(\n            @NonNull AttributionSource attributionSource,\n            @NonNull ChangeLogTokenRequest request,\n            @NonNull IGetChangeLogTokenCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n        final HealthConnectServiceLogger.Builder builder =\n                new HealthConnectServiceLogger.Builder(false, GET_CHANGES_TOKEN)\n                        .setPackageName(attributionSource.getPackageName());\n        HealthConnectThreadScheduler.schedule(\n                mContext,\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        verifyPackageNameFromUid(uid, attributionSource);\n                        tryAcquireApiCallQuota(\n                                uid,\n                                QuotaCategory.QUOTA_CATEGORY_READ,\n                                mAppOpsManagerLocal.isUidInForeground(uid),\n                                builder);\n                        throwExceptionIfDataSyncInProgress();\n                        if (request.getRecordTypes().isEmpty()) {\n                            throw new IllegalArgumentException(\n                                    \"Requested record types must not be empty.\");\n                        }\n                        mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                request.getRecordTypesList(), attributionSource);\n                        callback.onResult(\n                                new ChangeLogTokenResponse(\n                                        ChangeLogsRequestHelper.getInstance()\n                                                .getToken(\n                                                        attributionSource.getPackageName(),\n                                                        request)));\n                        builder.setHealthDataServiceApiStatusSuccess();\n                    } catch (SQLiteException sqLiteException) {\n                        builder.setHealthDataServiceApiStatusError(HealthConnectException.ERROR_IO);\n                        Slog.e(TAG, \"SQLiteException: \", sqLiteException);\n                        tryAndThrowException(\n                                callback, sqLiteException, HealthConnectException.ERROR_IO);\n                    } catch (SecurityException securityException) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_SECURITY);\n                        Slog.e(TAG, \"SecurityException: \", securityException);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (IllegalArgumentException illegalArgumentException) {\n                        logger.setHealthDataServiceApiStatusError(\n                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n                        Slog.e(TAG, \"IllegalArgumentException: \", illegalArgumentException);\n                        tryAndThrowException(\n                                callback,\n                                illegalArgumentException,\n                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n                    } catch (HealthConnectException healthConnectException) {\n                        builder.setHealthDataServiceApiStatusError(\n                                healthConnectException.getErrorCode());\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception e) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n                        tryAndThrowException(callback, e, ERROR_INTERNAL);\n                    }\n                    {\n                        builder.build().log();\n                    }\n                },\n                uid,\n                false);\n    }\n\n    /**\n     * @hide\n     * @see HealthConnectManager#getChangeLogs\n     */\n    @Override\n    public void getChangeLogs(\n            @NonNull AttributionSource attributionSource,\n            @NonNull ChangeLogsRequest token,\n            IChangeLogsResponseCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n        final String callerPackageName = Objects.requireNonNull(attributionSource.getPackageName());\n        final HealthConnectServiceLogger.Builder builder =\n                new HealthConnectServiceLogger.Builder(false, GET_CHANGES)\n                        .setPackageName(callerPackageName);\n\n        HealthConnectThreadScheduler.schedule(\n                mContext,\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        verifyPackageNameFromUid(uid, attributionSource);\n                        throwExceptionIfDataSyncInProgress();\n                        ChangeLogsRequestHelper.TokenRequest changeLogsTokenRequest =\n                                ChangeLogsRequestHelper.getRequest(\n                                        attributionSource.getPackageName(), token.getToken());\n                        mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                changeLogsTokenRequest.getRecordTypes(), attributionSource);\n                        boolean isInForeground = mAppOpsManagerLocal.isUidInForeground(uid);\n                        if (!isInForeground) {\n                            throwSecurityException(\n                                    attributionSource.getPackageName()\n                                            + \" must be in foreground to read the change logs\");\n                        }\n                        tryAcquireApiCallQuota(\n                                uid, QuotaCategory.QUOTA_CATEGORY_READ, isInForeground, builder);\n                        Instant startDateInstant =\n                                mPermissionHelper.getHealthDataStartDateAccess(\n                                        attributionSource.getPackageName(), userHandle);\n                        if (startDateInstant == null) {\n                            throwExceptionIncorrectPermissionState();\n                        }\n                        long startDateAccess = startDateInstant.toEpochMilli();\n                        final ChangeLogsHelper.ChangeLogsResponse changeLogsResponse =\n                                ChangeLogsHelper.getInstance()\n                                        .getChangeLogs(changeLogsTokenRequest, token);\n\n                        Map<Integer, List<UUID>> recordTypeToInsertedUuids =\n                                ChangeLogsHelper.getRecordTypeToInsertedUuids(\n                                        changeLogsResponse.getChangeLogsMap());\n\n                        Map<String, Boolean> extraReadPermsToGrantState =\n                                mDataPermissionEnforcer.collectExtraReadPermissionToStateMapping(\n                                        recordTypeToInsertedUuids.keySet(), attributionSource);\n\n                        List<RecordInternal<?>> recordInternals =\n                                mTransactionManager.readRecords(\n                                        new ReadTransactionRequest(\n                                                callerPackageName,\n                                                recordTypeToInsertedUuids,\n                                                startDateAccess,\n                                                extraReadPermsToGrantState));\n\n                        List<DeletedLog> deletedLogs =\n                                ChangeLogsHelper.getDeletedLogs(\n                                        changeLogsResponse.getChangeLogsMap());\n\n                        callback.onResult(\n                                new ChangeLogsResponse(\n                                        new RecordsParcel(recordInternals),\n                                        deletedLogs,\n                                        changeLogsResponse.getNextPageToken(),\n                                        changeLogsResponse.hasMorePages()));\n                        finishDataDeliveryRead(\n                                changeLogsTokenRequest.getRecordTypes(), attributionSource);\n                        builder.setHealthDataServiceApiStatusSuccess()\n                                .setNumberOfRecords(recordInternals.size() + deletedLogs.size())\n                                .setDataTypesFromRecordInternals(recordInternals);\n                    } catch (IllegalArgumentException illegalArgumentException) {\n                        builder.setHealthDataServiceApiStatusError(\n                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n                        Slog.e(TAG, \"IllegalArgumentException: \", illegalArgumentException);\n                        tryAndThrowException(\n                                callback,\n                                illegalArgumentException,\n                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n                    } catch (SQLiteException sqLiteException) {\n                        builder.setHealthDataServiceApiStatusError(HealthConnectException.ERROR_IO);\n                        Slog.e(TAG, \"SQLiteException: \", sqLiteException);\n                        tryAndThrowException(\n                                callback, sqLiteException, HealthConnectException.ERROR_IO);\n                    } catch (SecurityException securityException) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_SECURITY);\n                        Slog.e(TAG, \"SecurityException: \", securityException);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (IllegalStateException illegalStateException) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n                        Slog.e(TAG, \"IllegalStateException: \", illegalStateException);\n                        tryAndThrowException(callback, illegalStateException, ERROR_INTERNAL);\n                    } catch (HealthConnectException healthConnectException) {\n                        builder.setHealthDataServiceApiStatusError(\n                                healthConnectException.getErrorCode());\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception exception) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n                        Slog.e(TAG, \"Exception: \", exception);\n                        tryAndThrowException(callback, exception, ERROR_INTERNAL);\n                    } finally {\n                        builder.build().log();\n                    }\n                },\n                uid,\n                false);\n    }\n\n    /**\n     * API to delete records based on {@code request}\n     *\n     * <p>NOTE: Though internally we only need a single API to handle deletes as SDK code transform\n     * all its delete requests to {@link DeleteUsingFiltersRequestParcel}, we have this separation\n     * to make sure no non-controller APIs can use {@link\n     * HealthConnectServiceImpl#deleteUsingFilters} API\n     */\n    @Override\n    public void deleteUsingFiltersForSelf(\n            @NonNull AttributionSource attributionSource,\n            @NonNull DeleteUsingFiltersRequestParcel request,\n            @NonNull IEmptyResponseCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n        final boolean holdsDataManagementPermission = hasDataManagementPermission(uid, pid);\n        final HealthConnectServiceLogger.Builder builder =\n                new HealthConnectServiceLogger.Builder(holdsDataManagementPermission, DELETE_DATA)\n                        .setPackageName(attributionSource.getPackageName());\n\n        HealthConnectThreadScheduler.schedule(\n                mContext,\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        verifyPackageNameFromUid(uid, attributionSource);\n                        throwExceptionIfDataSyncInProgress();\n                        List<Integer> recordTypeIdsToDelete =\n                                (!request.getRecordTypeFilters().isEmpty())\n                                        ? request.getRecordTypeFilters()\n                                        : new ArrayList<>(\n                                                RecordMapper.getInstance()\n                                                        .getRecordIdToExternalRecordClassMap()\n                                                        .keySet());\n                        // Requests from non controller apps are not allowed to use non-id\n                        // filters\n                        request.setPackageNameFilters(\n                                Collections.singletonList(attributionSource.getPackageName()));\n\n                        if (!holdsDataManagementPermission) {\n                            mDataPermissionEnforcer.enforceRecordIdsWritePermissions(\n                                    recordTypeIdsToDelete, attributionSource);\n                            tryAcquireApiCallQuota(\n                                    uid,\n                                    QuotaCategory.QUOTA_CATEGORY_WRITE,\n                                    mAppOpsManagerLocal.isUidInForeground(uid),\n                                    builder);\n                        }\n\n                        deleteUsingFiltersInternal(\n                                attributionSource,\n                                request,\n                                callback,\n                                builder,\n                                recordTypeIdsToDelete,\n                                uid,\n                                pid);\n                    } catch (SQLiteException sqLiteException) {\n                        builder.setHealthDataServiceApiStatusError(HealthConnectException.ERROR_IO);\n                        tryAndThrowException(\n                                callback, sqLiteException, HealthConnectException.ERROR_IO);\n                    } catch (IllegalArgumentException illegalArgumentException) {\n                        builder.setHealthDataServiceApiStatusError(\n                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n                        Slog.e(TAG, \"IllegalArgumentException: \", illegalArgumentException);\n                        tryAndThrowException(\n                                callback,\n                                illegalArgumentException,\n                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n                    } catch (SecurityException securityException) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_SECURITY);\n                        Slog.e(TAG, \"SecurityException: \", securityException);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (HealthConnectException healthConnectException) {\n                        builder.setHealthDataServiceApiStatusError(\n                                healthConnectException.getErrorCode());\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception exception) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n                        Slog.e(TAG, \"Exception: \", exception);\n                        tryAndThrowException(callback, exception, ERROR_INTERNAL);\n                    } finally {\n                        builder.build().log();\n                    }\n                },\n                uid,\n                holdsDataManagementPermission);\n    }\n\n    /**\n     * API to delete records based on {@code request}\n     *\n     * <p>NOTE: Though internally we only need a single API to handle deletes as SDK code transform\n     * all its delete requests to {@link DeleteUsingFiltersRequestParcel}, we have this separation\n     * to make sure no non-controller APIs can use this API\n     */\n    @Override\n    public void deleteUsingFilters(\n            @NonNull AttributionSource attributionSource,\n            @NonNull DeleteUsingFiltersRequestParcel request,\n            @NonNull IEmptyResponseCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n        final boolean holdsDataManagementPermission = hasDataManagementPermission(uid, pid);\n        final HealthConnectServiceLogger.Builder builder =\n                new HealthConnectServiceLogger.Builder(holdsDataManagementPermission, DELETE_DATA)\n                        .setPackageName(attributionSource.getPackageName());\n\n        HealthConnectThreadScheduler.schedule(\n                mContext,\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        verifyPackageNameFromUid(uid, attributionSource);\n                        throwExceptionIfDataSyncInProgress();\n                        mContext.enforcePermission(MANAGE_HEALTH_DATA_PERMISSION, pid, uid, null);\n                        List<Integer> recordTypeIdsToDelete =\n                                (!request.getRecordTypeFilters().isEmpty())\n                                        ? request.getRecordTypeFilters()\n                                        : new ArrayList<>(\n                                                RecordMapper.getInstance()\n                                                        .getRecordIdToExternalRecordClassMap()\n                                                        .keySet());\n\n                        deleteUsingFiltersInternal(\n                                attributionSource,\n                                request,\n                                callback,\n                                builder,\n                                recordTypeIdsToDelete,\n                                uid,\n                                pid);\n                    } catch (SQLiteException sqLiteException) {\n                        builder.setHealthDataServiceApiStatusError(HealthConnectException.ERROR_IO);\n                        tryAndThrowException(\n                                callback, sqLiteException, HealthConnectException.ERROR_IO);\n                    } catch (IllegalArgumentException illegalArgumentException) {\n                        builder.setHealthDataServiceApiStatusError(\n                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n                        Slog.e(TAG, \"IllegalArgumentException: \", illegalArgumentException);\n                        tryAndThrowException(\n                                callback,\n                                illegalArgumentException,\n                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n                    } catch (SecurityException securityException) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_SECURITY);\n                        Slog.e(TAG, \"SecurityException: \", securityException);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (HealthConnectException healthConnectException) {\n                        builder.setHealthDataServiceApiStatusError(\n                                healthConnectException.getErrorCode());\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception exception) {\n                        builder.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n                        Slog.e(TAG, \"Exception: \", exception);\n                        tryAndThrowException(callback, exception, ERROR_INTERNAL);\n                    } finally {\n                        builder.build().log();\n                    }\n                },\n                uid,\n                holdsDataManagementPermission);\n    }\n\n    private void deleteUsingFiltersInternal(\n            @NonNull AttributionSource attributionSource,\n            @NonNull DeleteUsingFiltersRequestParcel request,\n            @NonNull IEmptyResponseCallback callback,\n            @NonNull HealthConnectServiceLogger.Builder builder,\n            List<Integer> recordTypeIdsToDelete,\n            int uid,\n            int pid) {\n        if (request.usesIdFilters() && request.usesNonIdFilters()) {\n            throw new IllegalArgumentException(\n                    \"Requests with both id and non-id filters are not\" + \" supported\");\n        }\n        int numberOfRecordsDeleted =\n                mTransactionManager.deleteAll(\n                        new DeleteTransactionRequest(attributionSource.getPackageName(), request)\n                                .setHasManageHealthDataPermission(\n                                        hasDataManagementPermission(uid, pid)));\n        tryAndReturnResult(callback, builder);\n        finishDataDeliveryWrite(recordTypeIdsToDelete, attributionSource);\n        HealthConnectThreadScheduler.scheduleInternalTask(\n                () -> postDeleteTasks(recordTypeIdsToDelete));\n\n        builder.setNumberOfRecords(numberOfRecordsDeleted)\n                .setDataTypesFromRecordTypes(recordTypeIdsToDelete);\n    }\n\n    /** API to get Priority for {@code dataCategory} */\n    @Override\n    public void getCurrentPriority(\n            @NonNull String packageName,\n            @HealthDataCategory.Type int dataCategory,\n            @NonNull IGetPriorityResponseCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n        HealthConnectThreadScheduler.scheduleControllerTask(\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        mContext.enforcePermission(MANAGE_HEALTH_DATA_PERMISSION, pid, uid, null);\n                        throwExceptionIfDataSyncInProgress();\n                        List<DataOrigin> dataOriginInPriorityOrder =\n                                HealthDataCategoryPriorityHelper.getInstance()\n                                        .getPriorityOrder(dataCategory)\n                                        .stream()\n                                        .map(\n                                                (name) ->\n                                                        new DataOrigin.Builder()\n                                                                .setPackageName(name)\n                                                                .build())\n                                        .collect(Collectors.toList());\n                        callback.onResult(\n                                new GetPriorityResponseParcel(\n                                        new FetchDataOriginsPriorityOrderResponse(\n                                                dataOriginInPriorityOrder)));\n                    } catch (SQLiteException sqLiteException) {\n                        Slog.e(TAG, \"SQLiteException: \", sqLiteException);\n                        tryAndThrowException(\n                                callback, sqLiteException, HealthConnectException.ERROR_IO);\n                    } catch (SecurityException securityException) {\n                        Slog.e(TAG, \"SecurityException: \", securityException);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (HealthConnectException healthConnectException) {\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception exception) {\n                        Slog.e(TAG, \"Exception: \", exception);\n                        tryAndThrowException(callback, exception, ERROR_INTERNAL);\n                    }\n                });\n    }\n\n    /** API to update priority for permission category(ies) */\n    @Override\n    public void updatePriority(\n            @NonNull String packageName,\n            @NonNull UpdatePriorityRequestParcel updatePriorityRequest,\n            @NonNull IEmptyResponseCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n        HealthConnectThreadScheduler.scheduleControllerTask(\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        mContext.enforcePermission(MANAGE_HEALTH_DATA_PERMISSION, pid, uid, null);\n                        throwExceptionIfDataSyncInProgress();\n                        HealthDataCategoryPriorityHelper.getInstance()\n                                .setPriorityOrder(\n                                        updatePriorityRequest.getDataCategory(),\n                                        updatePriorityRequest.getPackagePriorityOrder());\n                        callback.onResult();\n                    } catch (SQLiteException sqLiteException) {\n                        Slog.e(TAG, \"SQLiteException: \", sqLiteException);\n                        tryAndThrowException(\n                                callback, sqLiteException, HealthConnectException.ERROR_IO);\n                    } catch (SecurityException securityException) {\n                        Slog.e(TAG, \"SecurityException: \", securityException);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (HealthConnectException healthConnectException) {\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception exception) {\n                        Slog.e(TAG, \"Exception: \", exception);\n                        tryAndThrowException(callback, exception, ERROR_INTERNAL);\n                    }\n                });\n    }\n\n    @Override\n    public void setRecordRetentionPeriodInDays(\n            int days, @NonNull UserHandle user, IEmptyResponseCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n        HealthConnectThreadScheduler.scheduleControllerTask(\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        mContext.enforcePermission(MANAGE_HEALTH_DATA_PERMISSION, pid, uid, null);\n                        throwExceptionIfDataSyncInProgress();\n                        AutoDeleteService.setRecordRetentionPeriodInDays(days);\n                        callback.onResult();\n                    } catch (SQLiteException sqLiteException) {\n                        Slog.e(TAG, \"SQLiteException: \", sqLiteException);\n                        tryAndThrowException(\n                                callback, sqLiteException, HealthConnectException.ERROR_IO);\n                    } catch (SecurityException securityException) {\n                        Slog.e(TAG, \"SecurityException: \", securityException);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (HealthConnectException healthConnectException) {\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception exception) {\n                        Slog.e(TAG, \"Exception: \", exception);\n                        tryAndThrowException(callback, exception, ERROR_INTERNAL);\n                    }\n                });\n    }\n\n    @Override\n    public int getRecordRetentionPeriodInDays(@NonNull UserHandle user) {\n        enforceIsForegroundUser(getCallingUserHandle());\n        throwExceptionIfDataSyncInProgress();\n        try {\n            mContext.enforceCallingPermission(MANAGE_HEALTH_DATA_PERMISSION, null);\n            return AutoDeleteService.getRecordRetentionPeriodInDays();\n        } catch (Exception e) {\n            if (e instanceof SecurityException) {\n                throw e;\n            }\n            Slog.e(TAG, \"Unable to get record retention period for \" + user);\n        }\n\n        throw new RuntimeException();\n    }\n\n    /**\n     * Returns information, represented by {@code ApplicationInfoResponse}, for all the packages\n     * that have contributed to the health connect DB.\n     *\n     * @param callback Callback to receive result of performing this operation. In case of an error\n     *     or a permission failure the HealthConnect service, {@link IEmptyResponseCallback#onError}\n     *     will be invoked with a {@link HealthConnectException}.\n     */\n    @Override\n    public void getContributorApplicationsInfo(@NonNull IApplicationInfoResponseCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n        HealthConnectThreadScheduler.scheduleControllerTask(\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        mContext.enforcePermission(MANAGE_HEALTH_DATA_PERMISSION, pid, uid, null);\n                        throwExceptionIfDataSyncInProgress();\n                        List<AppInfo> applicationInfos =\n                                AppInfoHelper.getInstance().getApplicationInfosWithRecordTypes();\n\n                        callback.onResult(new ApplicationInfoResponseParcel(applicationInfos));\n                    } catch (SQLiteException sqLiteException) {\n                        Slog.e(TAG, \"SqlException: \", sqLiteException);\n                        tryAndThrowException(\n                                callback, sqLiteException, HealthConnectException.ERROR_IO);\n                    } catch (SecurityException securityException) {\n                        Slog.e(TAG, \"SecurityException: \", securityException);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (HealthConnectException healthConnectException) {\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception e) {\n                        Slog.e(TAG, \"Exception: \", e);\n                        tryAndThrowException(callback, e, ERROR_INTERNAL);\n                    }\n                });\n    }\n\n    /** Retrieves {@link RecordTypeInfoResponse} for each RecordType. */\n    @Override\n    public void queryAllRecordTypesInfo(@NonNull IRecordTypeInfoResponseCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n        HealthConnectThreadScheduler.scheduleControllerTask(\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        mContext.enforcePermission(MANAGE_HEALTH_DATA_PERMISSION, pid, uid, null);\n                        throwExceptionIfDataSyncInProgress();\n                        callback.onResult(\n                                new RecordTypeInfoResponseParcel(\n                                        getPopulatedRecordTypeInfoResponses()));\n                    } catch (SQLiteException sqLiteException) {\n                        tryAndThrowException(\n                                callback, sqLiteException, HealthConnectException.ERROR_IO);\n                    } catch (SecurityException securityException) {\n                        Slog.e(TAG, \"SecurityException: \", securityException);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (HealthConnectException healthConnectException) {\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception exception) {\n                        tryAndThrowException(callback, exception, ERROR_INTERNAL);\n                    }\n                });\n    }\n\n    /**\n     * @see HealthConnectManager#queryAccessLogs\n     */\n    @Override\n    public void queryAccessLogs(@NonNull String packageName, IAccessLogsResponseCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n\n        HealthConnectThreadScheduler.scheduleControllerTask(\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        mContext.enforcePermission(MANAGE_HEALTH_DATA_PERMISSION, pid, uid, null);\n                        throwExceptionIfDataSyncInProgress();\n                        final List<AccessLog> accessLogsList =\n                                AccessLogsHelper.getInstance().queryAccessLogs();\n                        callback.onResult(new AccessLogsResponseParcel(accessLogsList));\n                    } catch (SecurityException securityException) {\n                        Slog.e(TAG, \"SecurityException: \", securityException);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (HealthConnectException healthConnectException) {\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception exception) {\n                        Slog.e(TAG, \"Exception: \", exception);\n                        tryAndThrowException(callback, exception, ERROR_INTERNAL);\n                    }\n                });\n    }\n\n    /**\n     * Returns a list of unique dates for which the database has at least one entry\n     *\n     * @param activityDatesRequestParcel Parcel request containing records classes\n     * @param callback Callback to receive result of performing this operation. The results are\n     *     returned in {@link List<LocalDate>} . In case of an error or a permission failure the\n     *     HealthConnect service, {@link IActivityDatesResponseCallback#onError} will be invoked\n     *     with a {@link HealthConnectExceptionParcel}.\n     */\n    @Override\n    public void getActivityDates(\n            @NonNull ActivityDatesRequestParcel activityDatesRequestParcel,\n            IActivityDatesResponseCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n\n        HealthConnectThreadScheduler.scheduleControllerTask(\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        mContext.enforcePermission(MANAGE_HEALTH_DATA_PERMISSION, pid, uid, null);\n                        throwExceptionIfDataSyncInProgress();\n                        List<LocalDate> localDates =\n                                ActivityDateHelper.getInstance()\n                                        .getActivityDates(\n                                                activityDatesRequestParcel.getRecordTypes());\n\n                        callback.onResult(new ActivityDatesResponseParcel(localDates));\n                    } catch (SQLiteException sqLiteException) {\n                        Slog.e(TAG, \"SqlException: \", sqLiteException);\n                        tryAndThrowException(\n                                callback, sqLiteException, HealthConnectException.ERROR_IO);\n                    } catch (SecurityException securityException) {\n                        Slog.e(TAG, \"SecurityException: \", securityException);\n                        tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                    } catch (HealthConnectException healthConnectException) {\n                        Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                        tryAndThrowException(\n                                callback,\n                                healthConnectException,\n                                healthConnectException.getErrorCode());\n                    } catch (Exception e) {\n                        Slog.e(TAG, \"Exception: \", e);\n                        tryAndThrowException(callback, e, ERROR_INTERNAL);\n                    }\n                });\n    }\n\n    // TODO(b/265780725): Update javadocs and ensure that the caller handles SHOW_MIGRATION_INFO\n    // intent.\n    @Override\n    public void startMigration(@NonNull String packageName, IMigrationCallback callback) {\n        int uid = Binder.getCallingUid();\n        int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n\n        HealthConnectThreadScheduler.scheduleInternalTask(\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        mContext.enforcePermission(\n                                MIGRATE_HEALTH_CONNECT_DATA,\n                                pid,\n                                uid,\n                                \"Caller does not have \" + MIGRATE_HEALTH_CONNECT_DATA);\n                        enforceShowMigrationInfoIntent(packageName, uid);\n                        mBackupRestore.runWithStatesReadLock(\n                                () -> {\n                                    if (mBackupRestore.isRestoreMergingInProgress()) {\n                                        throw new MigrationException(\n                                                \"Cannot start data migration. Backup and restore in\"\n                                                        + \" progress.\",\n                                                MigrationException.ERROR_INTERNAL,\n                                                null);\n                                    }\n                                    mMigrationStateManager.startMigration(mContext);\n                                });\n                        PriorityMigrationHelper.getInstance().populatePreMigrationPriority();\n                        callback.onSuccess();\n                    } catch (Exception e) {\n                        Slog.e(TAG, \"Exception: \", e);\n                        tryAndThrowException(callback, e, MigrationException.ERROR_INTERNAL, null);\n                    }\n                });\n    }\n\n    // TODO(b/265780725): Update javadocs and ensure that the caller handles SHOW_MIGRATION_INFO\n    // intent.\n    @Override\n    public void finishMigration(@NonNull String packageName, IMigrationCallback callback) {\n        int uid = Binder.getCallingUid();\n        int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n\n        HealthConnectThreadScheduler.scheduleInternalTask(\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        mContext.enforcePermission(\n                                MIGRATE_HEALTH_CONNECT_DATA,\n                                pid,\n                                uid,\n                                \"Caller does not have \" + MIGRATE_HEALTH_CONNECT_DATA);\n                        enforceShowMigrationInfoIntent(packageName, uid);\n                        mMigrationStateManager.finishMigration(mContext);\n                        AppInfoHelper.getInstance().syncAppInfoRecordTypesUsed();\n                        callback.onSuccess();\n                    } catch (Exception e) {\n                        Slog.e(TAG, \"Exception: \", e);\n                        // TODO(b/263897830): Verify migration state and send errors properly\n                        tryAndThrowException(callback, e, MigrationException.ERROR_INTERNAL, null);\n                    }\n                });\n    }\n\n    // TODO(b/265780725): Update javadocs and ensure that the caller handles SHOW_MIGRATION_INFO\n    // intent.\n    @Override\n    public void writeMigrationData(\n            @NonNull String packageName,\n            MigrationEntityParcel parcel,\n            IMigrationCallback callback) {\n        int uid = Binder.getCallingUid();\n        int pid = Binder.getCallingPid();\n        UserHandle callingUserHandle = getCallingUserHandle();\n\n        HealthConnectThreadScheduler.scheduleInternalTask(\n                () -> {\n                    try {\n                        enforceIsForegroundUser(callingUserHandle);\n                        mContext.enforcePermission(\n                                MIGRATE_HEALTH_CONNECT_DATA,\n                                pid,\n                                uid,\n                                \"Caller does not have \" + MIGRATE_HEALTH_CONNECT_DATA);\n                        enforceShowMigrationInfoIntent(packageName, uid);\n                        mMigrationStateManager.validateWriteMigrationData();\n                        getDataMigrationManager(callingUserHandle)\n                                .apply(parcel.getMigrationEntities());\n                        callback.onSuccess();\n                    } catch (DataMigrationManager.EntityWriteException e) {\n                        Slog.e(TAG, \"Exception: \", e);\n                        tryAndThrowException(\n                                callback,\n                                e,\n                                MigrationException.ERROR_MIGRATE_ENTITY,\n                                e.getEntityId());\n                    } catch (Exception e) {\n                        Slog.e(TAG, \"Exception: \", e);\n                        tryAndThrowException(callback, e, MigrationException.ERROR_INTERNAL, null);\n                    }\n                });\n    }\n\n    public void insertMinDataMigrationSdkExtensionVersion(\n            @NonNull String packageName, int requiredSdkExtension, IMigrationCallback callback) {\n        int uid = Binder.getCallingUid();\n        int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n\n        HealthConnectThreadScheduler.scheduleInternalTask(\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        mContext.enforcePermission(\n                                MIGRATE_HEALTH_CONNECT_DATA,\n                                pid,\n                                uid,\n                                \"Caller does not have \" + MIGRATE_HEALTH_CONNECT_DATA);\n                        enforceShowMigrationInfoIntent(packageName, uid);\n                        mMigrationStateManager.validateSetMinSdkVersion();\n                        mMigrationStateManager.setMinDataMigrationSdkExtensionVersion(\n                                mContext, requiredSdkExtension);\n\n                        callback.onSuccess();\n                    } catch (Exception e) {\n                        Slog.e(TAG, \"Exception: \", e);\n                        tryAndThrowException(callback, e, MigrationException.ERROR_INTERNAL, null);\n                    }\n                });\n    }\n\n    /**\n     * @see HealthConnectManager#stageAllHealthConnectRemoteData\n     */\n    @Override\n    public void stageAllHealthConnectRemoteData(\n            @NonNull StageRemoteDataRequest stageRemoteDataRequest,\n            @NonNull UserHandle userHandle,\n            @NonNull IDataStagingFinishedCallback callback) {\n        Map<String, ParcelFileDescriptor> origPfdsByFileName =\n                stageRemoteDataRequest.getPfdsByFileName();\n        Map<String, HealthConnectException> exceptionsByFileName =\n                new ArrayMap<>(origPfdsByFileName.size());\n        Map<String, ParcelFileDescriptor> pfdsByFileName =\n                new ArrayMap<>(origPfdsByFileName.size());\n\n        try {\n            mDataPermissionEnforcer.enforceAnyOfPermissions(\n                    Manifest.permission.STAGE_HEALTH_CONNECT_REMOTE_DATA,\n                    HEALTH_CONNECT_BACKUP_INTER_AGENT_PERMISSION);\n\n            enforceIsForegroundUser(Binder.getCallingUserHandle());\n\n            for (Entry<String, ParcelFileDescriptor> entry : origPfdsByFileName.entrySet()) {\n                try {\n                    pfdsByFileName.put(entry.getKey(), entry.getValue().dup());\n                } catch (IOException e) {\n                    Slog.e(TAG, \"IOException: \", e);\n                    exceptionsByFileName.put(\n                            entry.getKey(),\n                            new HealthConnectException(\n                                    HealthConnectException.ERROR_IO, e.getMessage()));\n                }\n            }\n\n            HealthConnectThreadScheduler.scheduleInternalTask(\n                    () -> {\n                        if (!mBackupRestore.prepForStagingIfNotAlreadyDone()) {\n                            try {\n                                callback.onResult();\n                            } catch (RemoteException e) {\n                                Log.e(TAG, \"Restore response could not be sent to the caller.\", e);\n                            }\n                            return;\n                        }\n                        mBackupRestore.stageAllHealthConnectRemoteData(\n                                pfdsByFileName,\n                                exceptionsByFileName,\n                                userHandle.getIdentifier(),\n                                callback);\n                    });\n        } catch (SecurityException | IllegalStateException e) {\n            Log.e(TAG, \"Exception encountered while staging\", e);\n            try {\n                @HealthConnectException.ErrorCode\n                int errorCode = (e instanceof SecurityException) ? ERROR_SECURITY : ERROR_INTERNAL;\n                exceptionsByFileName.put(\"\", new HealthConnectException(errorCode, e.getMessage()));\n\n                callback.onError(new StageRemoteDataException(exceptionsByFileName));\n            } catch (RemoteException remoteException) {\n                Log.e(TAG, \"Restore permission response could not be sent to the caller.\", e);\n            }\n        }\n    }\n\n    /**\n     * @see HealthConnectManager#getAllDataForBackup\n     */\n    @Override\n    public void getAllDataForBackup(\n            @NonNull StageRemoteDataRequest stageRemoteDataRequest,\n            @NonNull UserHandle userHandle) {\n        mContext.enforceCallingPermission(HEALTH_CONNECT_BACKUP_INTER_AGENT_PERMISSION, null);\n        mBackupRestore.getAllDataForBackup(stageRemoteDataRequest, userHandle);\n    }\n\n    /**\n     * @see HealthConnectManager#getAllBackupFileNames\n     */\n    @Override\n    public BackupFileNamesSet getAllBackupFileNames(boolean forDeviceToDevice) {\n        mContext.enforceCallingPermission(HEALTH_CONNECT_BACKUP_INTER_AGENT_PERMISSION, null);\n        return mBackupRestore.getAllBackupFileNames(forDeviceToDevice);\n    }\n\n    /**\n     * @see HealthConnectManager#deleteAllStagedRemoteData\n     */\n    @Override\n    public void deleteAllStagedRemoteData(@NonNull UserHandle userHandle) {\n        mContext.enforceCallingPermission(\n                DELETE_STAGED_HEALTH_CONNECT_REMOTE_DATA_PERMISSION, null);\n        mBackupRestore.deleteAndResetEverything(userHandle);\n        mMigrationStateManager.clearCaches(mContext);\n        AppInfoHelper.getInstance().clearData(mTransactionManager);\n        ActivityDateHelper.getInstance().clearData(mTransactionManager);\n        MigrationEntityHelper.getInstance().clearData(mTransactionManager);\n        HealthDataCategoryPriorityHelper.getInstance().clearData(mTransactionManager);\n        PriorityMigrationHelper.getInstance().clearData(mTransactionManager);\n        RateLimiter.clearCache();\n        String[] packageNames = mContext.getPackageManager().getPackagesForUid(getCallingUid());\n        for (String packageName : packageNames) {\n            mFirstGrantTimeManager.setFirstGrantTime(packageName, Instant.now(), userHandle);\n        }\n    }\n\n    /**\n     * @see HealthConnectManager#updateDataDownloadState\n     */\n    @Override\n    public void updateDataDownloadState(@DataDownloadState int downloadState) {\n        mContext.enforceCallingPermission(\n                Manifest.permission.STAGE_HEALTH_CONNECT_REMOTE_DATA, null);\n        enforceIsForegroundUser(getCallingUserHandle());\n        mBackupRestore.updateDataDownloadState(downloadState);\n    }\n\n    /**\n     * @see HealthConnectManager#getHealthConnectDataState\n     */\n    @Override\n    public void getHealthConnectDataState(@NonNull IGetHealthConnectDataStateCallback callback) {\n        try {\n            mDataPermissionEnforcer.enforceAnyOfPermissions(\n                    MANAGE_HEALTH_DATA_PERMISSION, Manifest.permission.MIGRATE_HEALTH_CONNECT_DATA);\n            final UserHandle userHandle = Binder.getCallingUserHandle();\n            enforceIsForegroundUser(userHandle);\n            HealthConnectThreadScheduler.scheduleInternalTask(\n                    () -> {\n                        try {\n                            @HealthConnectDataState.DataRestoreError\n                            int dataRestoreError = mBackupRestore.getDataRestoreError();\n                            @HealthConnectDataState.DataRestoreState\n                            int dataRestoreState = mBackupRestore.getDataRestoreState();\n\n                            try {\n                                callback.onResult(\n                                        new HealthConnectDataState(\n                                                dataRestoreState,\n                                                dataRestoreError,\n                                                mMigrationStateManager.getMigrationState()));\n                            } catch (RemoteException remoteException) {\n                                Log.e(\n                                        TAG,\n                                        \"HealthConnectDataState could not be sent to the caller.\",\n                                        remoteException);\n                            }\n                        } catch (RuntimeException e) {\n                            // exception getting the state from the disk\n                            try {\n                                callback.onError(\n                                        new HealthConnectExceptionParcel(\n                                                new HealthConnectException(\n                                                        HealthConnectException.ERROR_IO,\n                                                        e.getMessage())));\n                            } catch (RemoteException remoteException) {\n                                Log.e(\n                                        TAG,\n                                        \"Exception for getHealthConnectDataState could not be sent\"\n                                                + \" to the caller.\",\n                                        remoteException);\n                            }\n                        }\n                    });\n        } catch (SecurityException | IllegalStateException e) {\n            Log.e(TAG, \"getHealthConnectDataState: Exception encountered\", e);\n            @HealthConnectException.ErrorCode\n            int errorCode = (e instanceof SecurityException) ? ERROR_SECURITY : ERROR_INTERNAL;\n            try {\n                callback.onError(\n                        new HealthConnectExceptionParcel(\n                                new HealthConnectException(errorCode, e.getMessage())));\n            } catch (RemoteException remoteException) {\n                Log.e(TAG, \"getHealthConnectDataState error could not be sent\", e);\n            }\n        }\n    }\n\n    /**\n     * @see HealthConnectManager#getHealthConnectMigrationUiState\n     */\n    @Override\n    public void getHealthConnectMigrationUiState(\n            @NonNull IGetHealthConnectMigrationUiStateCallback callback) {\n        final int uid = Binder.getCallingUid();\n        final int pid = Binder.getCallingPid();\n        final UserHandle userHandle = Binder.getCallingUserHandle();\n        HealthConnectThreadScheduler.scheduleInternalTask(\n                () -> {\n                    try {\n                        enforceIsForegroundUser(userHandle);\n                        mContext.enforcePermission(MANAGE_HEALTH_DATA_PERMISSION, pid, uid, null);\n\n                        try {\n                            callback.onResult(\n                                    new HealthConnectMigrationUiState(\n                                            mMigrationUiStateManager\n                                                    .getHealthConnectMigrationUiState()));\n                        } catch (RemoteException remoteException) {\n                            Log.e(\n                                    TAG,\n                                    \"HealthConnectMigrationUiState could not be sent to the\"\n                                            + \" caller.\",\n                                    remoteException);\n                        }\n                    } catch (SecurityException securityException) {\n                        try {\n                            callback.onError(\n                                    new HealthConnectExceptionParcel(\n                                            new HealthConnectException(\n                                                    ERROR_SECURITY,\n                                                    securityException.getMessage())));\n                        } catch (RemoteException remoteException) {\n                            Log.e(\n                                    TAG,\n                                    \"Exception for HealthConnectMigrationUiState could not be sent\"\n                                            + \" to the caller.\",\n                                    remoteException);\n                        }\n                    } catch (RuntimeException e) {\n                        // exception getting the state from the disk\n                        try {\n                            callback.onError(\n                                    new HealthConnectExceptionParcel(\n                                            new HealthConnectException(\n                                                    HealthConnectException.ERROR_IO,\n                                                    e.getMessage())));\n                        } catch (RemoteException remoteException) {\n                            Log.e(\n                                    TAG,\n                                    \"Exception for HealthConnectMigrationUiState could not be sent\"\n                                            + \" to the caller.\",\n                                    remoteException);\n                        }\n                    }\n                });\n    }\n\n    // Cancel BR timeouts - this might be needed when a user is going into background.\n    void cancelBackupRestoreTimeouts() {\n        mBackupRestore.cancelAllJobs();\n    }\n\n    private void tryAcquireApiCallQuota(\n            int uid,\n            @QuotaCategory.Type int quotaCategory,\n            boolean isInForeground,\n            HealthConnectServiceLogger.Builder builder) {\n        try {\n            RateLimiter.tryAcquireApiCallQuota(uid, quotaCategory, isInForeground);\n        } catch (RateLimiterException rateLimiterException) {\n            builder.setRateLimit(\n                    rateLimiterException.getRateLimiterQuotaBucket(),\n                    rateLimiterException.getRateLimiterQuotaLimit());\n            throw new HealthConnectException(\n                    rateLimiterException.getErrorCode(), rateLimiterException.getMessage());\n        }\n    }\n\n    private void enforceMemoryRateLimit(List<Long> recordsSize, long recordsChunkSize) {\n        recordsSize.forEach(RateLimiter::checkMaxRecordMemoryUsage);\n        RateLimiter.checkMaxChunkMemoryUsage(recordsChunkSize);\n    }\n\n    private void enforceIsForegroundUser(UserHandle callingUserHandle) {\n        if (!callingUserHandle.equals(mCurrentForegroundUser)) {\n            throw new IllegalStateException(\n                    \"Calling user: \"\n                            + callingUserHandle.getIdentifier()\n                            + \"is not the current foreground user: \"\n                            + mCurrentForegroundUser.getIdentifier()\n                            + \". HC request must be called\"\n                            + \" from the current foreground user.\");\n        }\n    }\n\n    private boolean isDataSyncInProgress() {\n        return mMigrationStateManager.isMigrationInProgress()\n                || mBackupRestore.isRestoreMergingInProgress();\n    }\n\n    @VisibleForTesting\n    Set<String> getStagedRemoteFileNames(int userId) {\n        return mBackupRestore.getStagedRemoteFileNames(userId);\n    }\n\n    @NonNull\n    private DataMigrationManager getDataMigrationManager(@NonNull UserHandle userHandle) {\n        final Context userContext = mContext.createContextAsUser(userHandle, 0);\n\n        return new DataMigrationManager(\n                userContext,\n                mTransactionManager,\n                mPermissionHelper,\n                mFirstGrantTimeManager,\n                DeviceInfoHelper.getInstance(),\n                AppInfoHelper.getInstance(),\n                MigrationEntityHelper.getInstance(),\n                RecordHelperProvider.getInstance(),\n                HealthDataCategoryPriorityHelper.getInstance(),\n                PriorityMigrationHelper.getInstance(),\n                ActivityDateHelper.getInstance());\n    }\n\n    private void enforceCallingPackageBelongsToUid(String packageName, int callingUid) {\n        int packageUid;\n        try {\n            packageUid =\n                    mContext.getPackageManager()\n                            .getPackageUid(\n                                    packageName, /* flags */ PackageManager.PackageInfoFlags.of(0));\n        } catch (PackageManager.NameNotFoundException e) {\n            throw new IllegalStateException(packageName + \" not found\");\n        }\n        if (UserHandle.getAppId(packageUid) != UserHandle.getAppId(callingUid)) {\n            throwSecurityException(packageName + \" does not belong to uid \" + callingUid);\n        }\n    }\n\n    /**\n     * Verify various aspects of the calling user.\n     *\n     * @param callingUid Uid of the caller, usually retrieved from Binder for authenticity.\n     * @param callerAttributionSource The permission identity of the caller\n     */\n    private void verifyPackageNameFromUid(\n            int callingUid, @NonNull AttributionSource callerAttributionSource) {\n        // Check does the attribution source is one for the calling app.\n        callerAttributionSource.enforceCallingUid();\n        // Obtain the user where the client is running in.\n        UserHandle callingUserHandle = UserHandle.getUserHandleForUid(callingUid);\n        Context callingUserContext = mContext.createContextAsUser(callingUserHandle, 0);\n        String callingPackageName =\n                Objects.requireNonNull(callerAttributionSource.getPackageName());\n        verifyCallingPackage(callingUserContext, callingUid, callingPackageName);\n    }\n\n    /**\n     * Check that the caller's supposed package name matches the uid making the call.\n     *\n     * @throws SecurityException if the package name and uid don't match.\n     */\n    private void verifyCallingPackage(\n            @NonNull Context actualCallingUserContext,\n            int actualCallingUid,\n            @NonNull String claimedCallingPackage) {\n        int claimedCallingUid = getPackageUid(actualCallingUserContext, claimedCallingPackage);\n        if (claimedCallingUid != actualCallingUid) {\n            throwSecurityException(\n                    claimedCallingPackage + \" does not belong to uid \" + actualCallingUid);\n        }\n    }\n\n    /** Finds the UID of the {@code packageName} in the given {@code context}. */\n    private int getPackageUid(@NonNull Context context, @NonNull String packageName) {\n        try {\n            return context.getPackageManager().getPackageUid(packageName, /* flags= */ 0);\n        } catch (PackageManager.NameNotFoundException e) {\n            return Process.INVALID_UID;\n        }\n    }\n\n    private void enforceShowMigrationInfoIntent(String packageName, int callingUid) {\n        enforceCallingPackageBelongsToUid(packageName, callingUid);\n\n        Intent intentToCheck =\n                new Intent(HealthConnectManager.ACTION_SHOW_MIGRATION_INFO).setPackage(packageName);\n\n        ResolveInfo resolveResult =\n                mContext.getPackageManager()\n                        .resolveActivity(\n                                intentToCheck,\n                                PackageManager.ResolveInfoFlags.of(PackageManager.MATCH_ALL));\n\n        if (Objects.isNull(resolveResult)) {\n            throw new IllegalArgumentException(\n                    packageName\n                            + \" does not handle intent \"\n                            + HealthConnectManager.ACTION_SHOW_MIGRATION_INFO);\n        }\n    }\n\n    private Map<Integer, List<DataOrigin>> getPopulatedRecordTypeInfoResponses() {\n        Map<Integer, Class<? extends Record>> recordIdToExternalRecordClassMap =\n                RecordMapper.getInstance().getRecordIdToExternalRecordClassMap();\n        AppInfoHelper appInfoHelper = AppInfoHelper.getInstance();\n        Map<Integer, List<DataOrigin>> recordTypeInfoResponses =\n                new ArrayMap<>(recordIdToExternalRecordClassMap.size());\n        Map<Integer, Set<String>> recordTypeToContributingPackagesMap =\n                appInfoHelper.getRecordTypesToContributingPackagesMap();\n        recordIdToExternalRecordClassMap\n                .keySet()\n                .forEach(\n                        (recordType) -> {\n                            if (recordTypeToContributingPackagesMap.containsKey(recordType)) {\n                                List<DataOrigin> packages =\n                                        recordTypeToContributingPackagesMap.get(recordType).stream()\n                                                .map(\n                                                        (packageName) ->\n                                                                new DataOrigin.Builder()\n                                                                        .setPackageName(packageName)\n                                                                        .build())\n                                                .toList();\n                                recordTypeInfoResponses.put(recordType, packages);\n                            } else {\n                                recordTypeInfoResponses.put(recordType, Collections.emptyList());\n                            }\n                        });\n        return recordTypeInfoResponses;\n    }\n\n    private boolean hasDataManagementPermission(int uid, int pid) {\n        return mContext.checkPermission(MANAGE_HEALTH_DATA_PERMISSION, pid, uid)\n                == PERMISSION_GRANTED;\n    }\n\n    private void finishDataDeliveryRead(int recordTypeId, AttributionSource attributionSource) {\n        finishDataDeliveryRead(Collections.singletonList(recordTypeId), attributionSource);\n    }\n\n    private void finishDataDeliveryRead(\n            List<Integer> recordTypeIds, AttributionSource attributionSource) {\n        Trace.traceBegin(TRACE_TAG_READ_SUBTASKS, TAG_READ.concat(\"FinishDataDeliveryRead\"));\n\n        try {\n            for (Integer recordTypeId : recordTypeIds) {\n                String permissionName =\n                        HealthPermissions.getHealthReadPermission(\n                                RecordTypePermissionCategoryMapper\n                                        .getHealthPermissionCategoryForRecordType(recordTypeId));\n                mPermissionManager.finishDataDelivery(permissionName, attributionSource);\n            }\n        } catch (Exception exception) {\n            // Ignore: HC API has already fulfilled the result, ignore any exception we hit here\n        }\n        Trace.traceEnd(TRACE_TAG_READ_SUBTASKS);\n    }\n\n    private void finishDataDeliveryWriteRecords(\n            List<RecordInternal<?>> recordInternals, AttributionSource attributionSource) {\n        Trace.traceBegin(TRACE_TAG_READ_SUBTASKS, TAG_READ.concat(\".FinishDataDeliveryWrite\"));\n        Set<Integer> recordTypeIdsToEnforce = new ArraySet<>();\n        for (RecordInternal<?> recordInternal : recordInternals) {\n            recordTypeIdsToEnforce.add(recordInternal.getRecordType());\n        }\n\n        finishDataDeliveryWrite(recordTypeIdsToEnforce.stream().toList(), attributionSource);\n        Trace.traceEnd(TRACE_TAG_READ_SUBTASKS);\n    }\n\n    private void finishDataDeliveryWrite(\n            List<Integer> recordTypeIds, AttributionSource attributionSource) {\n        try {\n            for (Integer recordTypeId : recordTypeIds) {\n                String permissionName =\n                        HealthPermissions.getHealthWritePermission(\n                                RecordTypePermissionCategoryMapper\n                                        .getHealthPermissionCategoryForRecordType(recordTypeId));\n                mPermissionManager.finishDataDelivery(permissionName, attributionSource);\n            }\n        } catch (Exception exception) {\n            // Ignore: HC API has already fulfilled the result, ignore any exception we hit here\n        }\n    }\n\n    private void enforceBinderUidIsSameAsAttributionSourceUid(\n            int binderUid, int attributionSourceUid) {\n        if (binderUid != attributionSourceUid) {\n            throw new SecurityException(\"Binder uid must be equal to attribution source uid.\");\n        }\n    }\n\n    private void throwExceptionIncorrectPermissionState() {\n        throw new IllegalStateException(\n                \"Incorrect health permission state, likely\"\n                        + \" because the calling application's manifest does not specify handling \"\n                        + Intent.ACTION_VIEW_PERMISSION_USAGE\n                        + \" with \"\n                        + HealthConnectManager.CATEGORY_HEALTH_PERMISSIONS);\n    }\n\n    private void logRecordTypeSpecificUpsertMetrics(\n            @NonNull List<RecordInternal<?>> recordInternals, @NonNull String packageName) {\n        Objects.requireNonNull(recordInternals);\n        Objects.requireNonNull(packageName);\n\n        Map<Integer, List<RecordInternal<?>>> recordTypeToRecordInternals =\n                getRecordTypeToListOfRecords(recordInternals);\n        for (Entry<Integer, List<RecordInternal<?>>> recordTypeToRecordInternalsEntry :\n                recordTypeToRecordInternals.entrySet()) {\n            RecordHelper<?> recordHelper =\n                    RecordHelperProvider.getInstance()\n                            .getRecordHelper(recordTypeToRecordInternalsEntry.getKey());\n            recordHelper.logUpsertMetrics(recordTypeToRecordInternalsEntry.getValue(), packageName);\n        }\n    }\n\n    private void logRecordTypeSpecificReadMetrics(\n            @NonNull List<RecordInternal<?>> recordInternals, @NonNull String packageName) {\n        Objects.requireNonNull(recordInternals);\n        Objects.requireNonNull(packageName);\n\n        Map<Integer, List<RecordInternal<?>>> recordTypeToRecordInternals =\n                getRecordTypeToListOfRecords(recordInternals);\n        for (Entry<Integer, List<RecordInternal<?>>> recordTypeToRecordInternalsEntry :\n                recordTypeToRecordInternals.entrySet()) {\n            RecordHelper<?> recordHelper =\n                    RecordHelperProvider.getInstance()\n                            .getRecordHelper(recordTypeToRecordInternalsEntry.getKey());\n            recordHelper.logReadMetrics(recordTypeToRecordInternalsEntry.getValue(), packageName);\n        }\n    }\n\n    private Map<Integer, List<RecordInternal<?>>> getRecordTypeToListOfRecords(\n            List<RecordInternal<?>> recordInternals) {\n\n        return recordInternals.stream()\n                .collect(Collectors.groupingBy(RecordInternal::getRecordType));\n    }\n\n    private void throwSecurityException(String message) {\n        throw new SecurityException(message);\n    }\n\n    private void throwExceptionIfDataSyncInProgress() {\n        if (isDataSyncInProgress()) {\n            throw new HealthConnectException(\n                    HealthConnectException.ERROR_DATA_SYNC_IN_PROGRESS,\n                    \"Storage data sync in progress. API calls are blocked\");\n        }\n    }\n\n    /**\n     * Throws an IllegalState Exception if data migration or restore is in process. This is only\n     * used by HealthConnect synchronous APIs as {@link HealthConnectException} is lost between\n     * processes on synchronous APIs and can only be returned to the caller for the APIs with a\n     * callback.\n     */\n    private void throwIllegalStateExceptionIfDataSyncInProgress() {\n        if (isDataSyncInProgress()) {\n            throw new IllegalStateException(\"Storage data sync in progress. API calls are blocked\");\n        }\n    }\n\n    private static void postDeleteTasks(List<Integer> recordTypeIdsToDelete) {\n        Trace.traceBegin(TRACE_TAG_DELETE_SUBTASKS, TAG_INSERT.concat(\"PostDeleteTasks\"));\n        if (recordTypeIdsToDelete != null && !recordTypeIdsToDelete.isEmpty()) {\n            AppInfoHelper.getInstance()\n                    .syncAppInfoRecordTypesUsed(new HashSet<>(recordTypeIdsToDelete));\n            ActivityDateHelper.getInstance().reSyncByRecordTypeIds(recordTypeIdsToDelete);\n        }\n        Trace.traceEnd(TRACE_TAG_DELETE_SUBTASKS);\n    }\n\n    private static void tryAndReturnResult(\n            IEmptyResponseCallback callback, HealthConnectServiceLogger.Builder builder) {\n        try {\n            callback.onResult();\n            builder.setHealthDataServiceApiStatusSuccess();\n        } catch (RemoteException e) {\n            Slog.e(TAG, \"Remote call failed\", e);\n            builder.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n        }\n    }\n\n    private static void tryAndReturnResult(\n            IInsertRecordsResponseCallback callback,\n            List<String> uuids,\n            HealthConnectServiceLogger.Builder builder) {\n        try {\n            callback.onResult(new InsertRecordsResponseParcel(uuids));\n            builder.setHealthDataServiceApiStatusSuccess();\n        } catch (RemoteException e) {\n            Slog.e(TAG, \"Remote call failed\", e);\n            builder.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n        }\n    }\n\n    private static void tryAndThrowException(\n            @NonNull IInsertRecordsResponseCallback callback,\n            @NonNull Exception exception,\n            @HealthConnectException.ErrorCode int errorCode) {\n        try {\n            callback.onError(\n                    new HealthConnectExceptionParcel(\n                            new HealthConnectException(errorCode, exception.toString())));\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Unable to send result to the callback\", e);\n        }\n    }\n\n    private static void tryAndThrowException(\n            @NonNull IAggregateRecordsResponseCallback callback,\n            @NonNull Exception exception,\n            @HealthConnectException.ErrorCode int errorCode) {\n        try {\n            callback.onError(\n                    new HealthConnectExceptionParcel(\n                            new HealthConnectException(errorCode, exception.toString())));\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Unable to send result to the callback\", e);\n        }\n    }\n\n    private static void tryAndThrowException(\n            @NonNull IReadRecordsResponseCallback callback,\n            @NonNull Exception exception,\n            @HealthConnectException.ErrorCode int errorCode) {\n        try {\n            callback.onError(\n                    new HealthConnectExceptionParcel(\n                            new HealthConnectException(errorCode, exception.toString())));\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Unable to send result to the callback\", e);\n        }\n    }\n\n    private static void tryAndThrowException(\n            @NonNull IActivityDatesResponseCallback callback,\n            @NonNull Exception exception,\n            @HealthConnectException.ErrorCode int errorCode) {\n        try {\n            callback.onError(\n                    new HealthConnectExceptionParcel(\n                            new HealthConnectException(errorCode, exception.toString())));\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Unable to send result to the callback\", e);\n        }\n    }\n\n    private static void tryAndThrowException(\n            @NonNull IGetChangeLogTokenCallback callback,\n            @NonNull Exception exception,\n            @HealthConnectException.ErrorCode int errorCode) {\n        try {\n            callback.onError(\n                    new HealthConnectExceptionParcel(\n                            new HealthConnectException(errorCode, exception.toString())));\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Unable to send result to the callback\", e);\n        }\n    }\n\n    private static void tryAndThrowException(\n            @NonNull IAccessLogsResponseCallback callback,\n            @NonNull Exception exception,\n            @HealthConnectException.ErrorCode int errorCode) {\n        try {\n            callback.onError(\n                    new HealthConnectExceptionParcel(\n                            new HealthConnectException(errorCode, exception.toString())));\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Unable to send result to the callback\", e);\n        }\n    }\n\n    private static void tryAndThrowException(\n            @NonNull IEmptyResponseCallback callback,\n            @NonNull Exception exception,\n            @HealthConnectException.ErrorCode int errorCode) {\n        try {\n            callback.onError(\n                    new HealthConnectExceptionParcel(\n                            new HealthConnectException(errorCode, exception.toString())));\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Unable to send result to the callback\", e);\n        }\n    }\n\n    private static void tryAndThrowException(\n            @NonNull IApplicationInfoResponseCallback callback,\n            @NonNull Exception exception,\n            @HealthConnectException.ErrorCode int errorCode) {\n        try {\n            callback.onError(\n                    new HealthConnectExceptionParcel(\n                            new HealthConnectException(errorCode, exception.toString())));\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Unable to send result to the callback\", e);\n        }\n    }\n\n    private static void tryAndThrowException(\n            @NonNull IChangeLogsResponseCallback callback,\n            @NonNull Exception exception,\n            @HealthConnectException.ErrorCode int errorCode) {\n        try {\n            callback.onError(\n                    new HealthConnectExceptionParcel(\n                            new HealthConnectException(errorCode, exception.toString())));\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Unable to send result to the callback\", e);\n        }\n    }\n\n    private static void tryAndThrowException(\n            @NonNull IRecordTypeInfoResponseCallback callback,\n            @NonNull Exception exception,\n            @HealthConnectException.ErrorCode int errorCode) {\n        try {\n            callback.onError(\n                    new HealthConnectExceptionParcel(\n                            new HealthConnectException(errorCode, exception.toString())));\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Unable to send result to the callback\", e);\n        }\n    }\n\n    private static void tryAndThrowException(\n            @NonNull IGetPriorityResponseCallback callback,\n            @NonNull Exception exception,\n            @HealthConnectException.ErrorCode int errorCode) {\n        try {\n            callback.onError(\n                    new HealthConnectExceptionParcel(\n                            new HealthConnectException(errorCode, exception.toString())));\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Unable to send result to the callback\", e);\n        }\n    }\n\n    private static void tryAndThrowException(\n            @NonNull IMigrationCallback callback,\n            @NonNull Exception exception,\n            @MigrationException.ErrorCode int errorCode,\n            @Nullable String failedEntityId) {\n        try {\n            callback.onError(\n                    new MigrationException(exception.toString(), errorCode, failedEntityId));\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Unable to send result to the callback\", e);\n        }\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 19007,
                                        "general": {
                                            "word_based": 6872,
                                            "char_based": 30932
                                        },
                                        "gemini": 23071
                                    }
                                }
                            ]
                        }
                    ]
                }
            ],
            "cross_patch_attempts": []
        }
    ],
    "vulnerabilities_with_partial_failures": [
        {
            "id": "ASB-A-317048495",
            "aliases": [
                "A-317048495",
                "CVE-2024-43764"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-317048495",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "2976ca86d5c5be558191a1fe706d4cd0d7ccdecb"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 2976ca86d5c5be558191a1fe706d4cd0d7ccdecb Mon Sep 17 00:00:00 2001\nFrom: Miranda Kephart <mkephart@google.com>\nDate: Fri, 16 Feb 2024 10:14:15 -0500\nSubject: [PATCH] Block clipboard UI when device is locked\n\nIn some situations (see bug for details) it's possible to enter the\nclipboard even while the device is locked, and from there access the\nprovided intents. Users should not be able to access intents from this\nstate; this change adds an additional check before showing the interactive UI.\n\nThe behavior is identical to what we do when user setup is not complete\n(b/251778420): we show a toast to note that content has been copied, but no interactive UI.\n\nInteractive UI is only blocked when device is locked (i.e. requiring pin\nentry/password/biometric/etc), not if the keyguard is up but trivially\ndismissable.\n\nBug: 317048495\nFlag: ACONFIG com.android.systemui.clipboard_noninteractive_on_lockscreen DEVELOPMENT\nTest: atest ClipboardListenerTest; verification using steps in linked\nbug as well as forcing text content to appear client-side, to verify\nthat even if text content is received in the ClipboardListener, no\ninteractive UI appears.\n\nChange-Id: I1a48cbe64852dce3fba69915ca11dad8878f66eb\n---\n packages/SystemUI/aconfig/systemui.aconfig    | 10 ++++++\n .../clipboardoverlay/ClipboardListener.java   |  9 ++++-\n .../ClipboardListenerTest.java                | 36 ++++++++++++++++++-\n 3 files changed, 53 insertions(+), 2 deletions(-)\n\ndiff --git a/packages/SystemUI/aconfig/systemui.aconfig b/packages/SystemUI/aconfig/systemui.aconfig\nindex 4ed1965d1b33..7df8f03fe6ac 100644\n--- a/packages/SystemUI/aconfig/systemui.aconfig\n+++ b/packages/SystemUI/aconfig/systemui.aconfig\n@@ -489,3 +489,13 @@ flag {\n         purpose: PURPOSE_BUGFIX\n     }\n }\n+\n+flag {\n+    name: \"clipboard_noninteractive_on_lockscreen\"\n+    namespace: \"systemui\"\n+    description: \"Prevents the interactive clipboard UI from appearing when device is locked\"\n+    bug: \"317048495\"\n+    metadata {\n+        purpose: PURPOSE_BUGFIX\n+    }\n+}\ndiff --git a/packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java b/packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\nindex e0ce3db39403..c7a47b18f467 100644\n--- a/packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\n+++ b/packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\n@@ -18,12 +18,14 @@ package com.android.systemui.clipboardoverlay;\n \n import static android.content.ClipDescription.CLASSIFICATION_COMPLETE;\n \n+import static com.android.systemui.Flags.clipboardNoninteractiveOnLockscreen;\n import static com.android.systemui.clipboardoverlay.ClipboardOverlayEvent.CLIPBOARD_OVERLAY_ENTERED;\n import static com.android.systemui.clipboardoverlay.ClipboardOverlayEvent.CLIPBOARD_OVERLAY_UPDATED;\n import static com.android.systemui.clipboardoverlay.ClipboardOverlayEvent.CLIPBOARD_TOAST_SHOWN;\n \n import static com.google.android.setupcompat.util.WizardManagerHelper.SETTINGS_SECURE_USER_SETUP_COMPLETE;\n \n+import android.app.KeyguardManager;\n import android.content.ClipData;\n import android.content.ClipboardManager;\n import android.content.Context;\n@@ -57,6 +59,7 @@ public class ClipboardListener implements\n     private final Provider<ClipboardOverlayController> mOverlayProvider;\n     private final ClipboardToast mClipboardToast;\n     private final ClipboardManager mClipboardManager;\n+    private final KeyguardManager mKeyguardManager;\n     private final UiEventLogger mUiEventLogger;\n     private ClipboardOverlay mClipboardOverlay;\n \n@@ -65,11 +68,13 @@ public class ClipboardListener implements\n             Provider<ClipboardOverlayController> clipboardOverlayControllerProvider,\n             ClipboardToast clipboardToast,\n             ClipboardManager clipboardManager,\n+            KeyguardManager keyguardManager,\n             UiEventLogger uiEventLogger) {\n         mContext = context;\n         mOverlayProvider = clipboardOverlayControllerProvider;\n         mClipboardToast = clipboardToast;\n         mClipboardManager = clipboardManager;\n+        mKeyguardManager = keyguardManager;\n         mUiEventLogger = uiEventLogger;\n     }\n \n@@ -92,7 +97,9 @@ public class ClipboardListener implements\n             return;\n         }\n \n-        if (!isUserSetupComplete() // user should not access intents from this state\n+        // user should not access intents before setup or while device is locked\n+        if ((clipboardNoninteractiveOnLockscreen() && mKeyguardManager.isDeviceLocked())\n+                || !isUserSetupComplete()\n                 || clipData == null // shouldn't happen, but just in case\n                 || clipData.getItemCount() == 0) {\n             if (shouldShowToast(clipData)) {\ndiff --git a/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardListenerTest.java b/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardListenerTest.java\nindex 18515825967f..c65a1176a55b 100644\n--- a/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardListenerTest.java\n+++ b/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardListenerTest.java\n@@ -27,16 +27,20 @@ import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.verifyZeroInteractions;\n import static org.mockito.Mockito.when;\n \n+import android.app.KeyguardManager;\n import android.content.ClipData;\n import android.content.ClipDescription;\n import android.content.ClipboardManager;\n import android.os.PersistableBundle;\n+import android.platform.test.annotations.DisableFlags;\n+import android.platform.test.annotations.EnableFlags;\n import android.provider.Settings;\n \n import androidx.test.filters.SmallTest;\n import androidx.test.runner.AndroidJUnit4;\n \n import com.android.internal.logging.UiEventLogger;\n+import com.android.systemui.Flags;\n import com.android.systemui.SysuiTestCase;\n \n import org.junit.Before;\n@@ -59,6 +63,8 @@ public class ClipboardListenerTest extends SysuiTestCase {\n     @Mock\n     private ClipboardManager mClipboardManager;\n     @Mock\n+    private KeyguardManager mKeyguardManager;\n+    @Mock\n     private ClipboardOverlayController mOverlayController;\n     @Mock\n     private ClipboardToast mClipboardToast;\n@@ -96,7 +102,7 @@ public class ClipboardListenerTest extends SysuiTestCase {\n         when(mClipboardManager.getPrimaryClipSource()).thenReturn(mSampleSource);\n \n         mClipboardListener = new ClipboardListener(getContext(), mOverlayControllerProvider,\n-                mClipboardToast, mClipboardManager, mUiEventLogger);\n+                mClipboardToast, mClipboardManager, mKeyguardManager, mUiEventLogger);\n     }\n \n \n@@ -190,6 +196,34 @@ public class ClipboardListenerTest extends SysuiTestCase {\n         verifyZeroInteractions(mOverlayControllerProvider);\n     }\n \n+    @Test\n+    @EnableFlags(Flags.FLAG_CLIPBOARD_NONINTERACTIVE_ON_LOCKSCREEN)\n+    public void test_deviceLocked_showsToast() {\n+        when(mKeyguardManager.isDeviceLocked()).thenReturn(true);\n+\n+        mClipboardListener.start();\n+        mClipboardListener.onPrimaryClipChanged();\n+\n+        verify(mUiEventLogger, times(1)).log(\n+                ClipboardOverlayEvent.CLIPBOARD_TOAST_SHOWN, 0, mSampleSource);\n+        verify(mClipboardToast, times(1)).showCopiedToast();\n+        verifyZeroInteractions(mOverlayControllerProvider);\n+    }\n+\n+    @Test\n+    @DisableFlags(Flags.FLAG_CLIPBOARD_NONINTERACTIVE_ON_LOCKSCREEN)\n+    public void test_deviceLocked_legacyBehavior_showsInteractiveUI() {\n+        when(mKeyguardManager.isDeviceLocked()).thenReturn(true);\n+\n+        mClipboardListener.start();\n+        mClipboardListener.onPrimaryClipChanged();\n+\n+        verify(mUiEventLogger, times(1)).log(\n+                ClipboardOverlayEvent.CLIPBOARD_OVERLAY_ENTERED, 0, mSampleSource);\n+        verify(mOverlayController).setClipData(mSampleClipData, mSampleSource);\n+        verifyZeroInteractions(mClipboardToast);\n+    }\n+\n     @Test\n     public void test_nullClipData_showsNothing() {\n         when(mClipboardManager.getPrimaryClip()).thenReturn(null);\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 1871,
                        "general": {
                            "word_based": 775,
                            "char_based": 2040
                        },
                        "gemini": 2327
                    },
                    "total_downstream_versions_tested": 2,
                    "successful_patches": 1,
                    "failed_patches": 1,
                    "patch_results": [
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "c7d1402707ea106b58fa9297585ae22d5c09d7f9",
                            "repo_path": "android_repos/base",
                            "result": "failure",
                            "downstream_patch_content": "commit c7d1402707ea106b58fa9297585ae22d5c09d7f9\nAuthor: Miranda Kephart <mkephart@google.com>\nDate:   Fri Feb 16 10:14:15 2024 -0500\n\n    Block clipboard UI when device is locked\n    \n    In some situations (see bug for details) it's possible to enter the\n    clipboard even while the device is locked, and from there access the\n    provided intents. Users should not be able to access intents from this\n    state; this change adds an additional check before showing the interactive UI.\n    \n    The behavior is identical to what we do when user setup is not complete\n    (b/251778420): we show a toast to note that content has been copied, but no interactive UI.\n    \n    Interactive UI is only blocked when device is locked (i.e. requiring pin\n    entry/password/biometric/etc), not if the keyguard is up but trivially\n    dismissable.\n    \n    Bug: 317048495\n    Test: atest ClipboardListenerTest; verification using steps in linked\n    bug as well as forcing text content to appear client-side, to verify\n    that even if text content is received in the ClipboardListener, no\n    interactive UI appears.\n    \n    Change-Id: I1a48cbe64852dce3fba69915ca11dad8878f66eb\n    Merged-In: I1a48cbe64852dce3fba69915ca11dad8878f66eb\n    (cherry picked from commit 2976ca86d5c5be558191a1fe706d4cd0d7ccdecb)\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java b/packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\nindex da602caac0dc..cdf58db58a15 100644\n--- a/packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\n+++ b/packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\n@@ -25,6 +25,7 @@ import static com.android.systemui.clipboardoverlay.ClipboardOverlayEvent.CLIPBO\n \n import static com.google.android.setupcompat.util.WizardManagerHelper.SETTINGS_SECURE_USER_SETUP_COMPLETE;\n \n+import android.app.KeyguardManager;\n import android.content.ClipData;\n import android.content.ClipboardManager;\n import android.content.Context;\n@@ -59,18 +60,21 @@ public class ClipboardListener extends CoreStartable\n     private final ClipboardOverlayControllerFactory mOverlayFactory;\n     private final ClipboardToast mClipboardToast;\n     private final ClipboardManager mClipboardManager;\n+    private final KeyguardManager mKeyguardManager;\n     private final UiEventLogger mUiEventLogger;\n     private ClipboardOverlayController mClipboardOverlayController;\n \n     @Inject\n     public ClipboardListener(Context context, DeviceConfigProxy deviceConfigProxy,\n             ClipboardOverlayControllerFactory overlayFactory, ClipboardManager clipboardManager,\n-            ClipboardToast clipboardToast,UiEventLogger uiEventLogger) {\n+            ClipboardToast clipboardToast, KeyguardManager keyguardManager,\n+            UiEventLogger uiEventLogger) {\n         super(context);\n         mDeviceConfig = deviceConfigProxy;\n         mOverlayFactory = overlayFactory;\n         mClipboardToast = clipboardToast;\n         mClipboardManager = clipboardManager;\n+        mKeyguardManager = keyguardManager;\n         mUiEventLogger = uiEventLogger;\n     }\n \n@@ -96,8 +100,11 @@ public class ClipboardListener extends CoreStartable\n             return;\n         }\n \n-        if (!isUserSetupComplete()) {\n-            // just show a toast, user should not access intents from this state\n+        // user should not access intents before setup or while device is locked\n+        if (mKeyguardManager.isDeviceLocked()\n+                || !isUserSetupComplete()\n+                || clipData == null // shouldn't happen, but just in case\n+                || clipData.getItemCount() == 0) {\n             if (shouldShowToast(clipData)) {\n                 mUiEventLogger.log(CLIPBOARD_TOAST_SHOWN, 0, clipSource);\n                 mClipboardToast.showCopiedToast();\ndiff --git a/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardListenerTest.java b/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardListenerTest.java\nindex 86402b3202d4..11803d68d5ac 100644\n--- a/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardListenerTest.java\n+++ b/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardListenerTest.java\n@@ -29,6 +29,7 @@ import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.verifyZeroInteractions;\n import static org.mockito.Mockito.when;\n \n+import android.app.KeyguardManager;\n import android.content.ClipData;\n import android.content.ClipDescription;\n import android.content.ClipboardManager;\n@@ -51,6 +52,8 @@ import org.mockito.Captor;\n import org.mockito.Mock;\n import org.mockito.MockitoAnnotations;\n \n+import java.util.ArrayList;\n+\n @SmallTest\n @RunWith(AndroidJUnit4.class)\n public class ClipboardListenerTest extends SysuiTestCase {\n@@ -60,6 +63,8 @@ public class ClipboardListenerTest extends SysuiTestCase {\n     @Mock\n     private ClipboardOverlayControllerFactory mClipboardOverlayControllerFactory;\n     @Mock\n+    private KeyguardManager mKeyguardManager;\n+    @Mock\n     private ClipboardOverlayController mOverlayController;\n     @Mock\n     private ClipboardToast mClipboardToast;\n@@ -97,7 +102,7 @@ public class ClipboardListenerTest extends SysuiTestCase {\n \n         mClipboardListener = new ClipboardListener(getContext(), mDeviceConfigProxy,\n                 mClipboardOverlayControllerFactory, mClipboardManager,mClipboardToast,\n-                mUiEventLogger);\n+                mKeyguardManager, mUiEventLogger);\n     }\n \n     @Test\n@@ -201,4 +206,44 @@ public class ClipboardListenerTest extends SysuiTestCase {\n         verify(mClipboardToast, times(1)).showCopiedToast();\n         verifyZeroInteractions(mClipboardOverlayControllerFactory);\n     }\n+\n+    @Test\n+    public void test_deviceLocked_showsToast() {\n+        when(mKeyguardManager.isDeviceLocked()).thenReturn(true);\n+\n+        mClipboardListener.start();\n+        mClipboardListener.onPrimaryClipChanged();\n+\n+        verify(mUiEventLogger, times(1)).log(\n+                ClipboardOverlayEvent.CLIPBOARD_TOAST_SHOWN, 0, mSampleSource);\n+        verify(mClipboardToast, times(1)).showCopiedToast();\n+        verifyZeroInteractions(mClipboardOverlayControllerFactory);\n+    }\n+\n+    @Test\n+    public void test_nullClipData_showsNothing() {\n+        when(mClipboardManager.getPrimaryClip()).thenReturn(null);\n+\n+        mClipboardListener.start();\n+        mClipboardListener.onPrimaryClipChanged();\n+\n+        verifyZeroInteractions(mUiEventLogger);\n+        verifyZeroInteractions(mClipboardToast);\n+        verifyZeroInteractions(mClipboardOverlayControllerFactory);\n+    }\n+\n+    @Test\n+    public void test_emptyClipData_showsToast() {\n+        ClipDescription description = new ClipDescription(\"Test\", new String[0]);\n+        ClipData noItems = new ClipData(description, new ArrayList<>());\n+        when(mClipboardManager.getPrimaryClip()).thenReturn(noItems);\n+\n+        mClipboardListener.start();\n+        mClipboardListener.onPrimaryClipChanged();\n+\n+        verify(mUiEventLogger, times(1)).log(\n+                ClipboardOverlayEvent.CLIPBOARD_TOAST_SHOWN, 0, mSampleSource);\n+        verify(mClipboardToast, times(1)).showCopiedToast();\n+        verifyZeroInteractions(mClipboardOverlayControllerFactory);\n+    }\n }\ndiff --git a/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardOverlayEventTest.java b/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardOverlayEventTest.java\nindex 5e2f6a0f7a70..022d1a2b411b 100644\n--- a/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardOverlayEventTest.java\n+++ b/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardOverlayEventTest.java\n@@ -23,6 +23,7 @@ import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n+import android.app.KeyguardManager;\n import android.content.ClipData;\n import android.content.ClipboardManager;\n import android.provider.DeviceConfig;\n@@ -51,6 +52,8 @@ public class ClipboardOverlayEventTest extends SysuiTestCase {\n     @Mock\n     private ClipboardOverlayController mOverlayController;\n     @Mock\n+    private KeyguardManager mKeyguardManager;\n+    @Mock\n     private ClipboardToast mClipboardToast;\n     @Mock\n     private UiEventLogger mUiEventLogger;\n@@ -78,7 +81,7 @@ public class ClipboardOverlayEventTest extends SysuiTestCase {\n \n         mClipboardListener = new ClipboardListener(getContext(), deviceConfigProxy,\n                 mClipboardOverlayControllerFactory, mClipboardManager, mClipboardToast,\n-                mUiEventLogger);\n+                mKeyguardManager, mUiEventLogger);\n     }\n \n     @Test\n",
                            "downstream_patch_tokens": {
                                "openai": 2006,
                                "general": {
                                    "word_based": 795,
                                    "char_based": 2195
                                },
                                "gemini": 2447
                            },
                            "file_conflicts": [
                                {
                                    "file_name": "packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java",
                                    "total_hunks": 4,
                                    "failed_hunks": [
                                        1,
                                        3,
                                        4
                                    ],
                                    "inline_merge_conflicts": [],
                                    "inline_merge_token_summary": {
                                        "gemini": 0,
                                        "openai": 0,
                                        "general_word": 0,
                                        "general_char": 0
                                    },
                                    "rej_file_content": "```diff\n--- packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\n+++ packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\n@@ -18,12 +18,14 @@ package com.android.systemui.clipboardoverlay;\n \n import static android.content.ClipDescription.CLASSIFICATION_COMPLETE;\n \n+import static com.android.systemui.Flags.clipboardNoninteractiveOnLockscreen;\n import static com.android.systemui.clipboardoverlay.ClipboardOverlayEvent.CLIPBOARD_OVERLAY_ENTERED;\n import static com.android.systemui.clipboardoverlay.ClipboardOverlayEvent.CLIPBOARD_OVERLAY_UPDATED;\n import static com.android.systemui.clipboardoverlay.ClipboardOverlayEvent.CLIPBOARD_TOAST_SHOWN;\n \n import static com.google.android.setupcompat.util.WizardManagerHelper.SETTINGS_SECURE_USER_SETUP_COMPLETE;\n \n+import android.app.KeyguardManager;\n import android.content.ClipData;\n import android.content.ClipboardManager;\n import android.content.Context;\n@@ -66,11 +69,13 @@ public class ClipboardListener implements\n             Provider<ClipboardOverlayController> clipboardOverlayControllerProvider,\n             ClipboardToast clipboardToast,\n             ClipboardManager clipboardManager,\n+            KeyguardManager keyguardManager,\n             UiEventLogger uiEventLogger) {\n         mContext = context;\n         mOverlayProvider = clipboardOverlayControllerProvider;\n         mClipboardToast = clipboardToast;\n         mClipboardManager = clipboardManager;\n+        mKeyguardManager = keyguardManager;\n         mUiEventLogger = uiEventLogger;\n     }\n \n@@ -93,7 +98,9 @@ public class ClipboardListener implements\n             return;\n         }\n \n-        if (!isUserSetupComplete() // user should not access intents from this state\n+        // user should not access intents before setup or while device is locked\n+        if ((clipboardNoninteractiveOnLockscreen() && mKeyguardManager.isDeviceLocked())\n+                || !isUserSetupComplete()\n                 || clipData == null // shouldn't happen, but just in case\n                 || clipData.getItemCount() == 0) {\n             if (shouldShowToast(clipData)) {\n```",
                                    "rej_file_tokens": {
                                        "openai": 434,
                                        "general": {
                                            "word_based": 171,
                                            "char_based": 533
                                        },
                                        "gemini": 522
                                    },
                                    "patch_apply_output": "patching file packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\nHunk #1 FAILED at 18.\nHunk #2 succeeded at 59 with fuzz 2 (offset 2 lines).\nHunk #3 FAILED at 66.\nHunk #4 FAILED at 93.\n3 out of 4 hunks FAILED -- saving rejects to file packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java.rej",
                                    "inline_merge_output": "patching file packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\nHunk #1 already applied at 21,28.\nHunk #2 already applied at 62.\nHunk #3 already applied at 71,77.\nHunk #4 already applied at 100-102.",
                                    "upstream_file_tokens": {
                                        "openai": 1271,
                                        "general": {
                                            "word_based": 550,
                                            "char_based": 1580
                                        },
                                        "gemini": 1496
                                    },
                                    "downstream_file_content": "```java\n/*\n * Copyright (C) 2021 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.systemui.clipboardoverlay;\n\nimport static android.content.ClipDescription.CLASSIFICATION_COMPLETE;\n\nimport static com.android.internal.config.sysui.SystemUiDeviceConfigFlags.CLIPBOARD_OVERLAY_ENABLED;\nimport static com.android.systemui.clipboardoverlay.ClipboardOverlayEvent.CLIPBOARD_OVERLAY_ENTERED;\nimport static com.android.systemui.clipboardoverlay.ClipboardOverlayEvent.CLIPBOARD_OVERLAY_UPDATED;\nimport static com.android.systemui.clipboardoverlay.ClipboardOverlayEvent.CLIPBOARD_TOAST_SHOWN;\n\nimport static com.google.android.setupcompat.util.WizardManagerHelper.SETTINGS_SECURE_USER_SETUP_COMPLETE;\n\nimport android.content.ClipData;\nimport android.content.ClipboardManager;\nimport android.content.Context;\nimport android.os.SystemProperties;\nimport android.provider.DeviceConfig;\nimport android.provider.Settings;\nimport android.util.Log;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.logging.UiEventLogger;\nimport com.android.systemui.CoreStartable;\nimport com.android.systemui.dagger.SysUISingleton;\nimport com.android.systemui.util.DeviceConfigProxy;\n\nimport javax.inject.Inject;\n\n/**\n * ClipboardListener brings up a clipboard overlay when something is copied to the clipboard.\n */\n@SysUISingleton\npublic class ClipboardListener extends CoreStartable\n        implements ClipboardManager.OnPrimaryClipChangedListener {\n    private static final String TAG = \"ClipboardListener\";\n\n    @VisibleForTesting\n    static final String SHELL_PACKAGE = \"com.android.shell\";\n    @VisibleForTesting\n    static final String EXTRA_SUPPRESS_OVERLAY =\n            \"com.android.systemui.SUPPRESS_CLIPBOARD_OVERLAY\";\n\n    private final DeviceConfigProxy mDeviceConfig;\n    private final ClipboardOverlayControllerFactory mOverlayFactory;\n    private final ClipboardToast mClipboardToast;\n    private final ClipboardManager mClipboardManager;\n    private final KeyguardManager mKeyguardManager;\n    private final UiEventLogger mUiEventLogger;\n    private ClipboardOverlayController mClipboardOverlayController;\n\n    @Inject\n    public ClipboardListener(Context context, DeviceConfigProxy deviceConfigProxy,\n            ClipboardOverlayControllerFactory overlayFactory, ClipboardManager clipboardManager,\n            ClipboardToast clipboardToast,UiEventLogger uiEventLogger) {\n        super(context);\n        mDeviceConfig = deviceConfigProxy;\n        mOverlayFactory = overlayFactory;\n        mClipboardToast = clipboardToast;\n        mClipboardManager = clipboardManager;\n        mUiEventLogger = uiEventLogger;\n    }\n\n    @Override\n    public void start() {\n        if (mDeviceConfig.getBoolean(\n                DeviceConfig.NAMESPACE_SYSTEMUI, CLIPBOARD_OVERLAY_ENABLED, true)) {\n            mClipboardManager.addPrimaryClipChangedListener(this);\n        }\n    }\n\n    @Override\n    public void onPrimaryClipChanged() {\n        if (!mClipboardManager.hasPrimaryClip()) {\n            return;\n        }\n\n        String clipSource = mClipboardManager.getPrimaryClipSource();\n        ClipData clipData = mClipboardManager.getPrimaryClip();\n\n        if (shouldSuppressOverlay(clipData, clipSource, isEmulator())) {\n            Log.i(TAG, \"Clipboard overlay suppressed.\");\n            return;\n        }\n\n        if (!isUserSetupComplete()) {\n            // just show a toast, user should not access intents from this state\n            if (shouldShowToast(clipData)) {\n                mUiEventLogger.log(CLIPBOARD_TOAST_SHOWN, 0, clipSource);\n                mClipboardToast.showCopiedToast();\n            }\n            return;\n        }\n\n        if (mClipboardOverlayController == null) {\n            mClipboardOverlayController = mOverlayFactory.create(mContext);\n            mUiEventLogger.log(CLIPBOARD_OVERLAY_ENTERED, 0, clipSource);\n        } else {\n            mUiEventLogger.log(CLIPBOARD_OVERLAY_UPDATED, 0, clipSource);\n        }\n        mClipboardOverlayController.setClipData(clipData, clipSource);\n        mClipboardOverlayController.setOnSessionCompleteListener(() -> {\n            // Session is complete, free memory until it's needed again.\n            mClipboardOverlayController = null;\n        });\n    }\n\n    // The overlay is suppressed if EXTRA_SUPPRESS_OVERLAY is true and the device is an emulator or\n    // the source package is SHELL_PACKAGE. This is meant to suppress the overlay when the emulator\n    // or a mirrored device is syncing the clipboard.\n    @VisibleForTesting\n    static boolean shouldSuppressOverlay(ClipData clipData, String clipSource,\n            boolean isEmulator) {\n        if (!(isEmulator || SHELL_PACKAGE.equals(clipSource))) {\n            return false;\n        }\n        if (clipData == null || clipData.getDescription().getExtras() == null) {\n            return false;\n        }\n        return clipData.getDescription().getExtras().getBoolean(EXTRA_SUPPRESS_OVERLAY, false);\n    }\n\n    boolean shouldShowToast(ClipData clipData) {\n        if (clipData == null) {\n            return false;\n        } else if (clipData.getDescription().getClassificationStatus() == CLASSIFICATION_COMPLETE) {\n            // only show for classification complete if we aren't already showing a toast, to ignore\n            // the duplicate ClipData with classification\n            return !mClipboardToast.isShowing();\n        }\n        return true;\n    }\n\n    private static boolean isEmulator() {\n        return SystemProperties.getBoolean(\"ro.boot.qemu\", false);\n    }\n\n    private boolean isUserSetupComplete() {\n        return Settings.Secure.getInt(mContext.getContentResolver(),\n                SETTINGS_SECURE_USER_SETUP_COMPLETE, 0) == 1;\n    }\n}\n```",
                                    "downstream_file_tokens": {
                                        "openai": 1254,
                                        "general": {
                                            "word_based": 544,
                                            "char_based": 1565
                                        },
                                        "gemini": 1485
                                    }
                                }
                            ]
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "b156c582347ad55a592eb364c8c86aee915195bf",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit b156c582347ad55a592eb364c8c86aee915195bf\nAuthor: Miranda Kephart <mkephart@google.com>\nDate:   Fri Feb 16 10:14:15 2024 -0500\n\n    Block clipboard UI when device is locked\n    \n    In some situations (see bug for details) it's possible to enter the\n    clipboard even while the device is locked, and from there access the\n    provided intents. Users should not be able to access intents from this\n    state; this change adds an additional check before showing the interactive UI.\n    \n    The behavior is identical to what we do when user setup is not complete\n    (b/251778420): we show a toast to note that content has been copied, but no interactive UI.\n    \n    Interactive UI is only blocked when device is locked (i.e. requiring pin\n    entry/password/biometric/etc), not if the keyguard is up but trivially\n    dismissable.\n    \n    Bug: 317048495\n    Test: atest ClipboardListenerTest; verification using steps in linked\n    bug as well as forcing text content to appear client-side, to verify\n    that even if text content is received in the ClipboardListener, no\n    interactive UI appears.\n    \n    Change-Id: I1a48cbe64852dce3fba69915ca11dad8878f66eb\n    Merged-In: I1a48cbe64852dce3fba69915ca11dad8878f66eb\n    (cherry picked from commit 2976ca86d5c5be558191a1fe706d4cd0d7ccdecb)\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java b/packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\nindex 63b4288ce055..f0a980e0a30c 100644\n--- a/packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\n+++ b/packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\n@@ -24,6 +24,7 @@ import static com.android.systemui.clipboardoverlay.ClipboardOverlayEvent.CLIPBO\n \n import static com.google.android.setupcompat.util.WizardManagerHelper.SETTINGS_SECURE_USER_SETUP_COMPLETE;\n \n+import android.app.KeyguardManager;\n import android.content.ClipData;\n import android.content.ClipboardManager;\n import android.content.Context;\n@@ -57,6 +58,7 @@ public class ClipboardListener implements\n     private final Provider<ClipboardOverlayController> mOverlayProvider;\n     private final ClipboardToast mClipboardToast;\n     private final ClipboardManager mClipboardManager;\n+    private final KeyguardManager mKeyguardManager;\n     private final UiEventLogger mUiEventLogger;\n     private ClipboardOverlay mClipboardOverlay;\n \n@@ -65,11 +67,13 @@ public class ClipboardListener implements\n             Provider<ClipboardOverlayController> clipboardOverlayControllerProvider,\n             ClipboardToast clipboardToast,\n             ClipboardManager clipboardManager,\n+            KeyguardManager keyguardManager,\n             UiEventLogger uiEventLogger) {\n         mContext = context;\n         mOverlayProvider = clipboardOverlayControllerProvider;\n         mClipboardToast = clipboardToast;\n         mClipboardManager = clipboardManager;\n+        mKeyguardManager = keyguardManager;\n         mUiEventLogger = uiEventLogger;\n     }\n \n@@ -92,7 +96,9 @@ public class ClipboardListener implements\n             return;\n         }\n \n-        if (!isUserSetupComplete() // user should not access intents from this state\n+        // user should not access intents before setup or while device is locked\n+        if (mKeyguardManager.isDeviceLocked()\n+                || !isUserSetupComplete()\n                 || clipData == null // shouldn't happen, but just in case\n                 || clipData.getItemCount() == 0) {\n             if (shouldShowToast(clipData)) {\ndiff --git a/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardListenerTest.java b/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardListenerTest.java\nindex 18515825967f..9d02c86cfa7a 100644\n--- a/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardListenerTest.java\n+++ b/packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardListenerTest.java\n@@ -27,6 +27,7 @@ import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.verifyZeroInteractions;\n import static org.mockito.Mockito.when;\n \n+import android.app.KeyguardManager;\n import android.content.ClipData;\n import android.content.ClipDescription;\n import android.content.ClipboardManager;\n@@ -59,6 +60,8 @@ public class ClipboardListenerTest extends SysuiTestCase {\n     @Mock\n     private ClipboardManager mClipboardManager;\n     @Mock\n+    private KeyguardManager mKeyguardManager;\n+    @Mock\n     private ClipboardOverlayController mOverlayController;\n     @Mock\n     private ClipboardToast mClipboardToast;\n@@ -96,7 +99,7 @@ public class ClipboardListenerTest extends SysuiTestCase {\n         when(mClipboardManager.getPrimaryClipSource()).thenReturn(mSampleSource);\n \n         mClipboardListener = new ClipboardListener(getContext(), mOverlayControllerProvider,\n-                mClipboardToast, mClipboardManager, mUiEventLogger);\n+                mClipboardToast, mClipboardManager, mKeyguardManager, mUiEventLogger);\n     }\n \n \n@@ -190,6 +193,19 @@ public class ClipboardListenerTest extends SysuiTestCase {\n         verifyZeroInteractions(mOverlayControllerProvider);\n     }\n \n+    @Test\n+    public void test_deviceLocked_showsToast() {\n+        when(mKeyguardManager.isDeviceLocked()).thenReturn(true);\n+\n+        mClipboardListener.start();\n+        mClipboardListener.onPrimaryClipChanged();\n+\n+        verify(mUiEventLogger, times(1)).log(\n+                ClipboardOverlayEvent.CLIPBOARD_TOAST_SHOWN, 0, mSampleSource);\n+        verify(mClipboardToast, times(1)).showCopiedToast();\n+        verifyZeroInteractions(mOverlayControllerProvider);\n+    }\n+\n     @Test\n     public void test_nullClipData_showsNothing() {\n         when(mClipboardManager.getPrimaryClip()).thenReturn(null);\n",
                            "downstream_patch_tokens": {
                                "openai": 1346,
                                "general": {
                                    "word_based": 562,
                                    "char_based": 1461
                                },
                                "gemini": 1650
                            }
                        }
                    ]
                }
            ],
            "cross_patch_attempts": [
                {
                    "from": "14",
                    "to": "13",
                    "result": "failure",
                    "patch_output": "patching file packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\nHunk #1 succeeded at 25 (offset 1 line).\nHunk #2 succeeded at 60 with fuzz 2 (offset 2 lines).\nHunk #3 FAILED at 67.\nHunk #4 FAILED at 94.\n2 out of 4 hunks FAILED -- saving rejects to file packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java.rej\npatching file packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardListenerTest.java\nHunk #1 succeeded at 29 (offset 2 lines).\nHunk #2 succeeded at 61 with fuzz 2 (offset 1 line).\nHunk #3 FAILED at 99.\nHunk #4 succeeded at 191 with fuzz 2 (offset -2 lines).\n1 out of 4 hunks FAILED -- saving rejects to file packages/SystemUI/tests/src/com/android/systemui/clipboardoverlay/ClipboardListenerTest.java.rej"
                }
            ]
        }
    ],
    "vulnerabilities_with_all_successful_patches": [
        {
            "id": "ASB-A-300476626",
            "aliases": [
                "A-300476626",
                "CVE-2024-0018"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-300476626",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "de2ad0fad97d6d97d1e01f0e8d8309536eb268b4"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From de2ad0fad97d6d97d1e01f0e8d8309536eb268b4 Mon Sep 17 00:00:00 2001\nFrom: Songyue Han <songyueh@google.com>\nDate: Tue, 3 Oct 2023 22:40:14 +0000\nSubject: [PATCH] Fix convertYUV420Planar16ToY410 overflow issue for\n unsupported cropwidth.\n\nBug: 300476626\nTest: color_conversion_fuzzer\nChange-Id: I8631426188af3c5f9b6c1ff6a0039254c252f733\n---\n media/libstagefright/colorconversion/ColorConverter.cpp | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\ndiff --git a/media/libstagefright/colorconversion/ColorConverter.cpp b/media/libstagefright/colorconversion/ColorConverter.cpp\nindex 6c26c284ad..e079765d6d 100644\n--- a/media/libstagefright/colorconversion/ColorConverter.cpp\n+++ b/media/libstagefright/colorconversion/ColorConverter.cpp\n@@ -1550,7 +1550,8 @@ status_t ColorConverter::convertYUV420Planar16ToY410(\n \n         uint32_t u01, v01, y01, y23, y45, y67, uv0, uv1;\n         size_t x = 0;\n-        for (; x < src.cropWidth() - 3; x += 4) {\n+        // x % 4 is always 0 so x + 3 will never overflow.\n+        for (; x + 3 < src.cropWidth(); x += 4) {\n             u01 = *((uint32_t*)ptr_u); ptr_u += 2;\n             v01 = *((uint32_t*)ptr_v); ptr_v += 2;\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 426,
                        "general": {
                            "word_based": 143,
                            "char_based": 299
                        },
                        "gemini": 551
                    },
                    "total_downstream_versions_tested": 5,
                    "successful_patches": 5,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "11",
                            "branch_used": "android11-release",
                            "downstream_patch": "aa8298ec8eb903e1e3dd915fa24f32e1aea1f76c",
                            "repo_path": "android_repos/av",
                            "result": "success",
                            "downstream_patch_content": "commit aa8298ec8eb903e1e3dd915fa24f32e1aea1f76c\nAuthor: Songyue Han <songyueh@google.com>\nDate:   Tue Oct 3 22:40:14 2023 +0000\n\n    Fix convertYUV420Planar16ToY410 overflow issue for unsupported cropwidth.\n    \n    Bug: 300476626\n    Test: color_conversion_fuzzer\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:de2ad0fad97d6d97d1e01f0e8d8309536eb268b4)\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:745ab99f7343bc236b88b9d63cd7b06ab192f9e9)\n    Merged-In: I8631426188af3c5f9b6c1ff6a0039254c252f733\n    Change-Id: I8631426188af3c5f9b6c1ff6a0039254c252f733\n\ndiff --git a/media/libstagefright/colorconversion/ColorConverter.cpp b/media/libstagefright/colorconversion/ColorConverter.cpp\nindex c7dc415d8b..9804887144 100644\n--- a/media/libstagefright/colorconversion/ColorConverter.cpp\n+++ b/media/libstagefright/colorconversion/ColorConverter.cpp\n@@ -648,7 +648,8 @@ status_t ColorConverter::convertYUV420Planar16ToY410(\n \n         uint32_t u01, v01, y01, y23, y45, y67, uv0, uv1;\n         size_t x = 0;\n-        for (; x < src.cropWidth() - 3; x += 4) {\n+        // x % 4 is always 0 so x + 3 will never overflow.\n+        for (; x + 3 < src.cropWidth(); x += 4) {\n             u01 = *((uint32_t*)ptr_u); ptr_u += 2;\n             v01 = *((uint32_t*)ptr_v); ptr_v += 2;\n \n",
                            "downstream_patch_tokens": {
                                "openai": 485,
                                "general": {
                                    "word_based": 142,
                                    "char_based": 336
                                },
                                "gemini": 641
                            }
                        },
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "aa8298ec8eb903e1e3dd915fa24f32e1aea1f76c",
                            "repo_path": "android_repos/av",
                            "result": "success",
                            "downstream_patch_content": "commit aa8298ec8eb903e1e3dd915fa24f32e1aea1f76c\nAuthor: Songyue Han <songyueh@google.com>\nDate:   Tue Oct 3 22:40:14 2023 +0000\n\n    Fix convertYUV420Planar16ToY410 overflow issue for unsupported cropwidth.\n    \n    Bug: 300476626\n    Test: color_conversion_fuzzer\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:de2ad0fad97d6d97d1e01f0e8d8309536eb268b4)\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:745ab99f7343bc236b88b9d63cd7b06ab192f9e9)\n    Merged-In: I8631426188af3c5f9b6c1ff6a0039254c252f733\n    Change-Id: I8631426188af3c5f9b6c1ff6a0039254c252f733\n\ndiff --git a/media/libstagefright/colorconversion/ColorConverter.cpp b/media/libstagefright/colorconversion/ColorConverter.cpp\nindex c7dc415d8b..9804887144 100644\n--- a/media/libstagefright/colorconversion/ColorConverter.cpp\n+++ b/media/libstagefright/colorconversion/ColorConverter.cpp\n@@ -648,7 +648,8 @@ status_t ColorConverter::convertYUV420Planar16ToY410(\n \n         uint32_t u01, v01, y01, y23, y45, y67, uv0, uv1;\n         size_t x = 0;\n-        for (; x < src.cropWidth() - 3; x += 4) {\n+        // x % 4 is always 0 so x + 3 will never overflow.\n+        for (; x + 3 < src.cropWidth(); x += 4) {\n             u01 = *((uint32_t*)ptr_u); ptr_u += 2;\n             v01 = *((uint32_t*)ptr_v); ptr_v += 2;\n \n",
                            "downstream_patch_tokens": {
                                "openai": 485,
                                "general": {
                                    "word_based": 142,
                                    "char_based": 336
                                },
                                "gemini": 641
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "aa8298ec8eb903e1e3dd915fa24f32e1aea1f76c",
                            "repo_path": "android_repos/av",
                            "result": "success",
                            "downstream_patch_content": "commit aa8298ec8eb903e1e3dd915fa24f32e1aea1f76c\nAuthor: Songyue Han <songyueh@google.com>\nDate:   Tue Oct 3 22:40:14 2023 +0000\n\n    Fix convertYUV420Planar16ToY410 overflow issue for unsupported cropwidth.\n    \n    Bug: 300476626\n    Test: color_conversion_fuzzer\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:de2ad0fad97d6d97d1e01f0e8d8309536eb268b4)\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:745ab99f7343bc236b88b9d63cd7b06ab192f9e9)\n    Merged-In: I8631426188af3c5f9b6c1ff6a0039254c252f733\n    Change-Id: I8631426188af3c5f9b6c1ff6a0039254c252f733\n\ndiff --git a/media/libstagefright/colorconversion/ColorConverter.cpp b/media/libstagefright/colorconversion/ColorConverter.cpp\nindex c7dc415d8b..9804887144 100644\n--- a/media/libstagefright/colorconversion/ColorConverter.cpp\n+++ b/media/libstagefright/colorconversion/ColorConverter.cpp\n@@ -648,7 +648,8 @@ status_t ColorConverter::convertYUV420Planar16ToY410(\n \n         uint32_t u01, v01, y01, y23, y45, y67, uv0, uv1;\n         size_t x = 0;\n-        for (; x < src.cropWidth() - 3; x += 4) {\n+        // x % 4 is always 0 so x + 3 will never overflow.\n+        for (; x + 3 < src.cropWidth(); x += 4) {\n             u01 = *((uint32_t*)ptr_u); ptr_u += 2;\n             v01 = *((uint32_t*)ptr_v); ptr_v += 2;\n \n",
                            "downstream_patch_tokens": {
                                "openai": 485,
                                "general": {
                                    "word_based": 142,
                                    "char_based": 336
                                },
                                "gemini": 641
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "aa8298ec8eb903e1e3dd915fa24f32e1aea1f76c",
                            "repo_path": "android_repos/av",
                            "result": "success",
                            "downstream_patch_content": "commit aa8298ec8eb903e1e3dd915fa24f32e1aea1f76c\nAuthor: Songyue Han <songyueh@google.com>\nDate:   Tue Oct 3 22:40:14 2023 +0000\n\n    Fix convertYUV420Planar16ToY410 overflow issue for unsupported cropwidth.\n    \n    Bug: 300476626\n    Test: color_conversion_fuzzer\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:de2ad0fad97d6d97d1e01f0e8d8309536eb268b4)\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:745ab99f7343bc236b88b9d63cd7b06ab192f9e9)\n    Merged-In: I8631426188af3c5f9b6c1ff6a0039254c252f733\n    Change-Id: I8631426188af3c5f9b6c1ff6a0039254c252f733\n\ndiff --git a/media/libstagefright/colorconversion/ColorConverter.cpp b/media/libstagefright/colorconversion/ColorConverter.cpp\nindex c7dc415d8b..9804887144 100644\n--- a/media/libstagefright/colorconversion/ColorConverter.cpp\n+++ b/media/libstagefright/colorconversion/ColorConverter.cpp\n@@ -648,7 +648,8 @@ status_t ColorConverter::convertYUV420Planar16ToY410(\n \n         uint32_t u01, v01, y01, y23, y45, y67, uv0, uv1;\n         size_t x = 0;\n-        for (; x < src.cropWidth() - 3; x += 4) {\n+        // x % 4 is always 0 so x + 3 will never overflow.\n+        for (; x + 3 < src.cropWidth(); x += 4) {\n             u01 = *((uint32_t*)ptr_u); ptr_u += 2;\n             v01 = *((uint32_t*)ptr_v); ptr_v += 2;\n \n",
                            "downstream_patch_tokens": {
                                "openai": 485,
                                "general": {
                                    "word_based": 142,
                                    "char_based": 336
                                },
                                "gemini": 641
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "aa8298ec8eb903e1e3dd915fa24f32e1aea1f76c",
                            "repo_path": "android_repos/av",
                            "result": "success",
                            "downstream_patch_content": "commit aa8298ec8eb903e1e3dd915fa24f32e1aea1f76c\nAuthor: Songyue Han <songyueh@google.com>\nDate:   Tue Oct 3 22:40:14 2023 +0000\n\n    Fix convertYUV420Planar16ToY410 overflow issue for unsupported cropwidth.\n    \n    Bug: 300476626\n    Test: color_conversion_fuzzer\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:de2ad0fad97d6d97d1e01f0e8d8309536eb268b4)\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:745ab99f7343bc236b88b9d63cd7b06ab192f9e9)\n    Merged-In: I8631426188af3c5f9b6c1ff6a0039254c252f733\n    Change-Id: I8631426188af3c5f9b6c1ff6a0039254c252f733\n\ndiff --git a/media/libstagefright/colorconversion/ColorConverter.cpp b/media/libstagefright/colorconversion/ColorConverter.cpp\nindex c7dc415d8b..9804887144 100644\n--- a/media/libstagefright/colorconversion/ColorConverter.cpp\n+++ b/media/libstagefright/colorconversion/ColorConverter.cpp\n@@ -648,7 +648,8 @@ status_t ColorConverter::convertYUV420Planar16ToY410(\n \n         uint32_t u01, v01, y01, y23, y45, y67, uv0, uv1;\n         size_t x = 0;\n-        for (; x < src.cropWidth() - 3; x += 4) {\n+        // x % 4 is always 0 so x + 3 will never overflow.\n+        for (; x + 3 < src.cropWidth(); x += 4) {\n             u01 = *((uint32_t*)ptr_u); ptr_u += 2;\n             v01 = *((uint32_t*)ptr_v); ptr_v += 2;\n \n",
                            "downstream_patch_tokens": {
                                "openai": 485,
                                "general": {
                                    "word_based": 142,
                                    "char_based": 336
                                },
                                "gemini": 641
                            }
                        }
                    ]
                }
            ],
            "cross_patch_attempts": [
                {
                    "from": "14",
                    "to": "13",
                    "result": "success",
                    "patch_output": "patching file media/libstagefright/colorconversion/ColorConverter.cpp"
                },
                {
                    "from": "14",
                    "to": "12L",
                    "result": "success",
                    "patch_output": "patching file media/libstagefright/colorconversion/ColorConverter.cpp"
                },
                {
                    "from": "14",
                    "to": "12",
                    "result": "success",
                    "patch_output": "patching file media/libstagefright/colorconversion/ColorConverter.cpp"
                },
                {
                    "from": "14",
                    "to": "11",
                    "result": "success",
                    "patch_output": "patching file media/libstagefright/colorconversion/ColorConverter.cpp"
                },
                {
                    "from": "13",
                    "to": "12L",
                    "result": "success",
                    "patch_output": "patching file media/libstagefright/colorconversion/ColorConverter.cpp"
                },
                {
                    "from": "13",
                    "to": "12",
                    "result": "success",
                    "patch_output": "patching file media/libstagefright/colorconversion/ColorConverter.cpp"
                },
                {
                    "from": "13",
                    "to": "11",
                    "result": "success",
                    "patch_output": "patching file media/libstagefright/colorconversion/ColorConverter.cpp"
                },
                {
                    "from": "12L",
                    "to": "12",
                    "result": "success",
                    "patch_output": "patching file media/libstagefright/colorconversion/ColorConverter.cpp"
                },
                {
                    "from": "12L",
                    "to": "11",
                    "result": "success",
                    "patch_output": "patching file media/libstagefright/colorconversion/ColorConverter.cpp"
                },
                {
                    "from": "12",
                    "to": "11",
                    "result": "success",
                    "patch_output": "patching file media/libstagefright/colorconversion/ColorConverter.cpp"
                }
            ]
        },
        {
            "id": "ASB-A-300903792",
            "aliases": [
                "A-300903792",
                "CVE-2024-0035"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-300903792",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "b9807f01748a669d738c94d6ad5319abea8608f5"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From b9807f01748a669d738c94d6ad5319abea8608f5 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Fabi=C3=A1n=20Kozynski?= <kozynski@google.com>\nDate: Fri, 13 Oct 2023 11:58:10 -0400\nSubject: [PATCH] Unbind TileService onNullBinding\n\nTest: atest TileLifecycleManagerTest\nTest: manual: adb shell dumpsys activity service\nTest: sts test\nBug: 300903792\nChange-Id: Ia8126ac65432b124683960e3ebf47301ba6172a1\n---\n .../qs/external/TileLifecycleManager.java     |  5 ++++\n .../qs/external/TileLifecycleManagerTest.java | 25 +++++++++++++++++++\n 2 files changed, 30 insertions(+)\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java b/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\nindex 78f2da53cd43..789a1e401ae6 100644\n--- a/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\n+++ b/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\n@@ -278,6 +278,11 @@ public class TileLifecycleManager extends BroadcastReceiver implements\n         handlePendingMessages();\n     }\n \n+    @Override\n+    public void onNullBinding(ComponentName name) {\n+        executeSetBindService(false);\n+    }\n+\n     @Override\n     public void onServiceDisconnected(ComponentName name) {\n         if (DEBUG) Log.d(TAG, \"onServiceDisconnected \" + name);\ndiff --git a/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java b/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\nindex 6cc52d70611a..fbd63c6bbdae 100644\n--- a/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\n+++ b/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\n@@ -403,6 +403,31 @@ public class TileLifecycleManagerTest extends SysuiTestCase {\n         verify(falseContext).bindServiceAsUser(any(), any(), eq(flags), any());\n     }\n \n+    @Test\n+    public void testNullBindingCallsUnbind() {\n+        Context mockContext = mock(Context.class);\n+        // Binding has to succeed\n+        when(mockContext.bindServiceAsUser(any(), any(), anyInt(), any())).thenReturn(true);\n+        TileLifecycleManager manager = new TileLifecycleManager(mHandler, mockContext,\n+                mock(IQSService.class),\n+                mMockPackageManagerAdapter,\n+                mMockBroadcastDispatcher,\n+                mTileServiceIntent,\n+                mUser,\n+                mActivityManager,\n+                mExecutor);\n+\n+        manager.executeSetBindService(true);\n+        mExecutor.runAllReady();\n+\n+        ArgumentCaptor<ServiceConnection> captor = ArgumentCaptor.forClass(ServiceConnection.class);\n+        verify(mockContext).bindServiceAsUser(any(), captor.capture(), anyInt(), any());\n+\n+        captor.getValue().onNullBinding(mTileServiceComponentName);\n+        mExecutor.runAllReady();\n+        verify(mockContext).unbindService(captor.getValue());\n+    }\n+\n     private void mockChangeEnabled(long changeId, boolean enabled) {\n         doReturn(enabled).when(() -> CompatChanges.isChangeEnabled(eq(changeId), anyString(),\n                 any(UserHandle.class)));\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 820,
                        "general": {
                            "word_based": 312,
                            "char_based": 804
                        },
                        "gemini": 1044
                    },
                    "total_downstream_versions_tested": 5,
                    "successful_patches": 5,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "11",
                            "branch_used": "android11-release",
                            "downstream_patch": "7bf830ca0df71496cd47563e138b8712918e0476",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 7bf830ca0df71496cd47563e138b8712918e0476\nAuthor: Fabi\u00e1n Kozynski <kozynski@google.com>\nDate:   Fri Oct 13 16:19:27 2023 -0400\n\n    Unbind TileService onNullBinding\n    \n    Test: atest TileLifecycleManagerTest\n    Test: manual: adb shell dumpsys activity service\n    Test: sts test\n    Bug: 300903792\n    Change-Id: Ia8126ac65432b124683960e3ebf47301ba6172a1\n    Merged-In: Ia8126ac65432b124683960e3ebf47301ba6172a1\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java b/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\nindex aa51771864b2..68a83f872983 100644\n--- a/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\n+++ b/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\n@@ -220,6 +220,11 @@ public class TileLifecycleManager extends BroadcastReceiver implements\n         handlePendingMessages();\n     }\n \n+    @Override\n+    public void onNullBinding(ComponentName name) {\n+        setBindService(false);\n+    }\n+\n     @Override\n     public void onServiceDisconnected(ComponentName name) {\n         if (DEBUG) Log.d(TAG, \"onServiceDisconnected \" + name);\ndiff --git a/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java b/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\nindex 42fd288d94ee..c03b2eeee577 100644\n--- a/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\n+++ b/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\n@@ -22,13 +22,16 @@ import static org.junit.Assert.assertEquals;\n import static org.mockito.Mockito.any;\n import static org.mockito.Mockito.anyInt;\n import static org.mockito.Mockito.anyString;\n+import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.never;\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n import android.content.ComponentName;\n+import android.content.Context;\n import android.content.Intent;\n+import android.content.ServiceConnection;\n import android.content.pm.PackageInfo;\n import android.content.pm.ServiceInfo;\n import android.net.Uri;\n@@ -51,7 +54,7 @@ import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n-import org.mockito.Mockito;\n+import org.mockito.ArgumentCaptor;\n \n @SmallTest\n @RunWith(AndroidJUnit4.class)\n@@ -59,10 +62,10 @@ public class TileLifecycleManagerTest extends SysuiTestCase {\n     private static final int TEST_FAIL_TIMEOUT = 5000;\n \n     private final PackageManagerAdapter mMockPackageManagerAdapter =\n-            Mockito.mock(PackageManagerAdapter.class);\n+            mock(PackageManagerAdapter.class);\n     private final BroadcastDispatcher mMockBroadcastDispatcher =\n-            Mockito.mock(BroadcastDispatcher.class);\n-    private final IQSTileService.Stub mMockTileService = Mockito.mock(IQSTileService.Stub.class);\n+            mock(BroadcastDispatcher.class);\n+    private final IQSTileService.Stub mMockTileService = mock(IQSTileService.Stub.class);\n     private ComponentName mTileServiceComponentName;\n     private Intent mTileServiceIntent;\n     private UserHandle mUser;\n@@ -87,7 +90,7 @@ public class TileLifecycleManagerTest extends SysuiTestCase {\n         mThread.start();\n         mHandler = Handler.createAsync(mThread.getLooper());\n         mStateManager = new TileLifecycleManager(mHandler, mContext,\n-                Mockito.mock(IQSService.class), new Tile(),\n+                mock(IQSService.class), new Tile(),\n                 mTileServiceIntent,\n                 mUser,\n                 mMockPackageManagerAdapter,\n@@ -247,4 +250,26 @@ public class TileLifecycleManagerTest extends SysuiTestCase {\n     public void testToggleableTile() throws Exception {\n         assertTrue(mStateManager.isToggleableTile());\n     }\n+\n+    @Test\n+    public void testNullBindingCallsUnbind() {\n+        Context mockContext = mock(Context.class);\n+        // Binding has to succeed\n+        when(mockContext.bindServiceAsUser(any(), any(), anyInt(), any())).thenReturn(true);\n+        TileLifecycleManager manager = new TileLifecycleManager(mHandler, mockContext,\n+                mock(IQSService.class),\n+                new Tile(),\n+                mTileServiceIntent,\n+                mUser,\n+                mMockPackageManagerAdapter,\n+                mMockBroadcastDispatcher);\n+\n+        manager.setBindService(true);\n+\n+        ArgumentCaptor<ServiceConnection> captor = ArgumentCaptor.forClass(ServiceConnection.class);\n+        verify(mockContext).bindServiceAsUser(any(), captor.capture(), anyInt(), any());\n+\n+        captor.getValue().onNullBinding(mTileServiceComponentName);\n+        verify(mockContext).unbindService(captor.getValue());\n+    }\n }\n",
                            "downstream_patch_tokens": {
                                "openai": 1129,
                                "general": {
                                    "word_based": 479,
                                    "char_based": 1226
                                },
                                "gemini": 1474
                            }
                        },
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "7bf830ca0df71496cd47563e138b8712918e0476",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 7bf830ca0df71496cd47563e138b8712918e0476\nAuthor: Fabi\u00e1n Kozynski <kozynski@google.com>\nDate:   Fri Oct 13 16:19:27 2023 -0400\n\n    Unbind TileService onNullBinding\n    \n    Test: atest TileLifecycleManagerTest\n    Test: manual: adb shell dumpsys activity service\n    Test: sts test\n    Bug: 300903792\n    Change-Id: Ia8126ac65432b124683960e3ebf47301ba6172a1\n    Merged-In: Ia8126ac65432b124683960e3ebf47301ba6172a1\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java b/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\nindex aa51771864b2..68a83f872983 100644\n--- a/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\n+++ b/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\n@@ -220,6 +220,11 @@ public class TileLifecycleManager extends BroadcastReceiver implements\n         handlePendingMessages();\n     }\n \n+    @Override\n+    public void onNullBinding(ComponentName name) {\n+        setBindService(false);\n+    }\n+\n     @Override\n     public void onServiceDisconnected(ComponentName name) {\n         if (DEBUG) Log.d(TAG, \"onServiceDisconnected \" + name);\ndiff --git a/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java b/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\nindex 42fd288d94ee..c03b2eeee577 100644\n--- a/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\n+++ b/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\n@@ -22,13 +22,16 @@ import static org.junit.Assert.assertEquals;\n import static org.mockito.Mockito.any;\n import static org.mockito.Mockito.anyInt;\n import static org.mockito.Mockito.anyString;\n+import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.never;\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n import android.content.ComponentName;\n+import android.content.Context;\n import android.content.Intent;\n+import android.content.ServiceConnection;\n import android.content.pm.PackageInfo;\n import android.content.pm.ServiceInfo;\n import android.net.Uri;\n@@ -51,7 +54,7 @@ import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n-import org.mockito.Mockito;\n+import org.mockito.ArgumentCaptor;\n \n @SmallTest\n @RunWith(AndroidJUnit4.class)\n@@ -59,10 +62,10 @@ public class TileLifecycleManagerTest extends SysuiTestCase {\n     private static final int TEST_FAIL_TIMEOUT = 5000;\n \n     private final PackageManagerAdapter mMockPackageManagerAdapter =\n-            Mockito.mock(PackageManagerAdapter.class);\n+            mock(PackageManagerAdapter.class);\n     private final BroadcastDispatcher mMockBroadcastDispatcher =\n-            Mockito.mock(BroadcastDispatcher.class);\n-    private final IQSTileService.Stub mMockTileService = Mockito.mock(IQSTileService.Stub.class);\n+            mock(BroadcastDispatcher.class);\n+    private final IQSTileService.Stub mMockTileService = mock(IQSTileService.Stub.class);\n     private ComponentName mTileServiceComponentName;\n     private Intent mTileServiceIntent;\n     private UserHandle mUser;\n@@ -87,7 +90,7 @@ public class TileLifecycleManagerTest extends SysuiTestCase {\n         mThread.start();\n         mHandler = Handler.createAsync(mThread.getLooper());\n         mStateManager = new TileLifecycleManager(mHandler, mContext,\n-                Mockito.mock(IQSService.class), new Tile(),\n+                mock(IQSService.class), new Tile(),\n                 mTileServiceIntent,\n                 mUser,\n                 mMockPackageManagerAdapter,\n@@ -247,4 +250,26 @@ public class TileLifecycleManagerTest extends SysuiTestCase {\n     public void testToggleableTile() throws Exception {\n         assertTrue(mStateManager.isToggleableTile());\n     }\n+\n+    @Test\n+    public void testNullBindingCallsUnbind() {\n+        Context mockContext = mock(Context.class);\n+        // Binding has to succeed\n+        when(mockContext.bindServiceAsUser(any(), any(), anyInt(), any())).thenReturn(true);\n+        TileLifecycleManager manager = new TileLifecycleManager(mHandler, mockContext,\n+                mock(IQSService.class),\n+                new Tile(),\n+                mTileServiceIntent,\n+                mUser,\n+                mMockPackageManagerAdapter,\n+                mMockBroadcastDispatcher);\n+\n+        manager.setBindService(true);\n+\n+        ArgumentCaptor<ServiceConnection> captor = ArgumentCaptor.forClass(ServiceConnection.class);\n+        verify(mockContext).bindServiceAsUser(any(), captor.capture(), anyInt(), any());\n+\n+        captor.getValue().onNullBinding(mTileServiceComponentName);\n+        verify(mockContext).unbindService(captor.getValue());\n+    }\n }\n",
                            "downstream_patch_tokens": {
                                "openai": 1129,
                                "general": {
                                    "word_based": 479,
                                    "char_based": 1226
                                },
                                "gemini": 1474
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "7bf830ca0df71496cd47563e138b8712918e0476",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 7bf830ca0df71496cd47563e138b8712918e0476\nAuthor: Fabi\u00e1n Kozynski <kozynski@google.com>\nDate:   Fri Oct 13 16:19:27 2023 -0400\n\n    Unbind TileService onNullBinding\n    \n    Test: atest TileLifecycleManagerTest\n    Test: manual: adb shell dumpsys activity service\n    Test: sts test\n    Bug: 300903792\n    Change-Id: Ia8126ac65432b124683960e3ebf47301ba6172a1\n    Merged-In: Ia8126ac65432b124683960e3ebf47301ba6172a1\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java b/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\nindex aa51771864b2..68a83f872983 100644\n--- a/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\n+++ b/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\n@@ -220,6 +220,11 @@ public class TileLifecycleManager extends BroadcastReceiver implements\n         handlePendingMessages();\n     }\n \n+    @Override\n+    public void onNullBinding(ComponentName name) {\n+        setBindService(false);\n+    }\n+\n     @Override\n     public void onServiceDisconnected(ComponentName name) {\n         if (DEBUG) Log.d(TAG, \"onServiceDisconnected \" + name);\ndiff --git a/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java b/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\nindex 42fd288d94ee..c03b2eeee577 100644\n--- a/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\n+++ b/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\n@@ -22,13 +22,16 @@ import static org.junit.Assert.assertEquals;\n import static org.mockito.Mockito.any;\n import static org.mockito.Mockito.anyInt;\n import static org.mockito.Mockito.anyString;\n+import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.never;\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n import android.content.ComponentName;\n+import android.content.Context;\n import android.content.Intent;\n+import android.content.ServiceConnection;\n import android.content.pm.PackageInfo;\n import android.content.pm.ServiceInfo;\n import android.net.Uri;\n@@ -51,7 +54,7 @@ import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n-import org.mockito.Mockito;\n+import org.mockito.ArgumentCaptor;\n \n @SmallTest\n @RunWith(AndroidJUnit4.class)\n@@ -59,10 +62,10 @@ public class TileLifecycleManagerTest extends SysuiTestCase {\n     private static final int TEST_FAIL_TIMEOUT = 5000;\n \n     private final PackageManagerAdapter mMockPackageManagerAdapter =\n-            Mockito.mock(PackageManagerAdapter.class);\n+            mock(PackageManagerAdapter.class);\n     private final BroadcastDispatcher mMockBroadcastDispatcher =\n-            Mockito.mock(BroadcastDispatcher.class);\n-    private final IQSTileService.Stub mMockTileService = Mockito.mock(IQSTileService.Stub.class);\n+            mock(BroadcastDispatcher.class);\n+    private final IQSTileService.Stub mMockTileService = mock(IQSTileService.Stub.class);\n     private ComponentName mTileServiceComponentName;\n     private Intent mTileServiceIntent;\n     private UserHandle mUser;\n@@ -87,7 +90,7 @@ public class TileLifecycleManagerTest extends SysuiTestCase {\n         mThread.start();\n         mHandler = Handler.createAsync(mThread.getLooper());\n         mStateManager = new TileLifecycleManager(mHandler, mContext,\n-                Mockito.mock(IQSService.class), new Tile(),\n+                mock(IQSService.class), new Tile(),\n                 mTileServiceIntent,\n                 mUser,\n                 mMockPackageManagerAdapter,\n@@ -247,4 +250,26 @@ public class TileLifecycleManagerTest extends SysuiTestCase {\n     public void testToggleableTile() throws Exception {\n         assertTrue(mStateManager.isToggleableTile());\n     }\n+\n+    @Test\n+    public void testNullBindingCallsUnbind() {\n+        Context mockContext = mock(Context.class);\n+        // Binding has to succeed\n+        when(mockContext.bindServiceAsUser(any(), any(), anyInt(), any())).thenReturn(true);\n+        TileLifecycleManager manager = new TileLifecycleManager(mHandler, mockContext,\n+                mock(IQSService.class),\n+                new Tile(),\n+                mTileServiceIntent,\n+                mUser,\n+                mMockPackageManagerAdapter,\n+                mMockBroadcastDispatcher);\n+\n+        manager.setBindService(true);\n+\n+        ArgumentCaptor<ServiceConnection> captor = ArgumentCaptor.forClass(ServiceConnection.class);\n+        verify(mockContext).bindServiceAsUser(any(), captor.capture(), anyInt(), any());\n+\n+        captor.getValue().onNullBinding(mTileServiceComponentName);\n+        verify(mockContext).unbindService(captor.getValue());\n+    }\n }\n",
                            "downstream_patch_tokens": {
                                "openai": 1129,
                                "general": {
                                    "word_based": 479,
                                    "char_based": 1226
                                },
                                "gemini": 1474
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "3b93880c0b0052fe03c781a9768b81b098a353c0",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 3b93880c0b0052fe03c781a9768b81b098a353c0\nAuthor: Fabi\u00e1n Kozynski <kozynski@google.com>\nDate:   Fri Oct 13 16:19:27 2023 -0400\n\n    Unbind TileService onNullBinding\n    \n    Test: atest TileLifecycleManagerTest\n    Test: manual: adb shell dumpsys activity service\n    Test: sts test\n    Bug: 300903792\n    Change-Id: Ia8126ac65432b124683960e3ebf47301ba6172a1\n    Merged-In: Ia8126ac65432b124683960e3ebf47301ba6172a1\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java b/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\nindex a49d3fd16591..ea49c7006100 100644\n--- a/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\n+++ b/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\n@@ -242,6 +242,11 @@ public class TileLifecycleManager extends BroadcastReceiver implements\n         handlePendingMessages();\n     }\n \n+    @Override\n+    public void onNullBinding(ComponentName name) {\n+        setBindService(false);\n+    }\n+\n     @Override\n     public void onServiceDisconnected(ComponentName name) {\n         if (DEBUG) Log.d(TAG, \"onServiceDisconnected \" + name);\ndiff --git a/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java b/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\nindex 04b50d8d98c1..09f612fff16b 100644\n--- a/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\n+++ b/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\n@@ -290,6 +290,27 @@ public class TileLifecycleManagerTest extends SysuiTestCase {\n         verify(falseContext).unbindService(captor.getValue());\n     }\n \n+    @Test\n+    public void testNullBindingCallsUnbind() {\n+        Context mockContext = mock(Context.class);\n+        // Binding has to succeed\n+        when(mockContext.bindServiceAsUser(any(), any(), anyInt(), any())).thenReturn(true);\n+        TileLifecycleManager manager = new TileLifecycleManager(mHandler, mockContext,\n+                mock(IQSService.class),\n+                mMockPackageManagerAdapter,\n+                mMockBroadcastDispatcher,\n+                mTileServiceIntent,\n+                mUser);\n+\n+        manager.setBindService(true);\n+\n+        ArgumentCaptor<ServiceConnection> captor = ArgumentCaptor.forClass(ServiceConnection.class);\n+        verify(mockContext).bindServiceAsUser(any(), captor.capture(), anyInt(), any());\n+\n+        captor.getValue().onNullBinding(mTileServiceComponentName);\n+        verify(mockContext).unbindService(captor.getValue());\n+    }\n+\n     private static class TestContextWrapper extends ContextWrapper {\n         private IntentFilter mLastIntentFilter;\n         private int mLastFlag;\n",
                            "downstream_patch_tokens": {
                                "openai": 715,
                                "general": {
                                    "word_based": 265,
                                    "char_based": 708
                                },
                                "gemini": 927
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "7cf363d1fe7c474120ae1c4a96c6adc4c8946d9f",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 7cf363d1fe7c474120ae1c4a96c6adc4c8946d9f\nAuthor: Fabi\u00e1n Kozynski <kozynski@google.com>\nDate:   Fri Oct 13 11:58:10 2023 -0400\n\n    Unbind TileService onNullBinding\n    \n    Test: atest TileLifecycleManagerTest\n    Test: manual: adb shell dumpsys activity service\n    Test: sts test\n    Bug: 300903792\n    Change-Id: Ia8126ac65432b124683960e3ebf47301ba6172a1\n    Merged-In: Ia8126ac65432b124683960e3ebf47301ba6172a1\n\ndiff --git a/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java b/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\nindex 2469a98140e3..3750c44a4923 100644\n--- a/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\n+++ b/packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\n@@ -280,6 +280,11 @@ public class TileLifecycleManager extends BroadcastReceiver implements\n         handlePendingMessages();\n     }\n \n+    @Override\n+    public void onNullBinding(ComponentName name) {\n+        executeSetBindService(false);\n+    }\n+\n     @Override\n     public void onServiceDisconnected(ComponentName name) {\n         if (DEBUG) Log.d(TAG, \"onServiceDisconnected \" + name);\ndiff --git a/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java b/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\nindex 67587e3a8914..37df93e4c809 100644\n--- a/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\n+++ b/packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\n@@ -373,6 +373,30 @@ public class TileLifecycleManagerTest extends SysuiTestCase {\n         verify(falseContext).bindServiceAsUser(any(), any(), eq(flags), any());\n     }\n \n+    @Test\n+    public void testNullBindingCallsUnbind() {\n+        Context mockContext = mock(Context.class);\n+        // Binding has to succeed\n+        when(mockContext.bindServiceAsUser(any(), any(), anyInt(), any())).thenReturn(true);\n+        TileLifecycleManager manager = new TileLifecycleManager(mHandler, mockContext,\n+                mock(IQSService.class),\n+                mMockPackageManagerAdapter,\n+                mMockBroadcastDispatcher,\n+                mTileServiceIntent,\n+                mUser,\n+                mExecutor);\n+\n+        manager.executeSetBindService(true);\n+        mExecutor.runAllReady();\n+\n+        ArgumentCaptor<ServiceConnection> captor = ArgumentCaptor.forClass(ServiceConnection.class);\n+        verify(mockContext).bindServiceAsUser(any(), captor.capture(), anyInt(), any());\n+\n+        captor.getValue().onNullBinding(mTileServiceComponentName);\n+        mExecutor.runAllReady();\n+        verify(mockContext).unbindService(captor.getValue());\n+    }\n+\n     private void mockChangeEnabled(long changeId, boolean enabled) {\n         doReturn(enabled).when(() -> CompatChanges.isChangeEnabled(eq(changeId), anyString(),\n                 any(UserHandle.class)));\n",
                            "downstream_patch_tokens": {
                                "openai": 762,
                                "general": {
                                    "word_based": 279,
                                    "char_based": 754
                                },
                                "gemini": 984
                            }
                        }
                    ]
                }
            ],
            "cross_patch_attempts": [
                {
                    "from": "14",
                    "to": "13",
                    "result": "failure",
                    "patch_output": "patching file packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\nHunk #1 succeeded at 242 (offset -38 lines).\npatching file packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\nHunk #1 FAILED at 373.\n1 out of 1 hunk FAILED -- saving rejects to file packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java.rej"
                },
                {
                    "from": "14",
                    "to": "12L",
                    "result": "failure",
                    "patch_output": "patching file packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\nHunk #1 succeeded at 220 (offset -60 lines).\npatching file packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\nHunk #1 FAILED at 373.\n1 out of 1 hunk FAILED -- saving rejects to file packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java.rej"
                },
                {
                    "from": "14",
                    "to": "12",
                    "result": "failure",
                    "patch_output": "patching file packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\nHunk #1 succeeded at 220 (offset -60 lines).\npatching file packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\nHunk #1 FAILED at 373.\n1 out of 1 hunk FAILED -- saving rejects to file packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java.rej"
                },
                {
                    "from": "14",
                    "to": "11",
                    "result": "failure",
                    "patch_output": "patching file packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\nHunk #1 succeeded at 220 (offset -60 lines).\npatching file packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\nHunk #1 FAILED at 373.\n1 out of 1 hunk FAILED -- saving rejects to file packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java.rej"
                },
                {
                    "from": "13",
                    "to": "12L",
                    "result": "failure",
                    "patch_output": "patching file packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\nHunk #1 succeeded at 220 (offset -22 lines).\npatching file packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\nHunk #1 FAILED at 290.\n1 out of 1 hunk FAILED -- saving rejects to file packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java.rej"
                },
                {
                    "from": "13",
                    "to": "12",
                    "result": "failure",
                    "patch_output": "patching file packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\nHunk #1 succeeded at 220 (offset -22 lines).\npatching file packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\nHunk #1 FAILED at 290.\n1 out of 1 hunk FAILED -- saving rejects to file packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java.rej"
                },
                {
                    "from": "13",
                    "to": "11",
                    "result": "failure",
                    "patch_output": "patching file packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\nHunk #1 succeeded at 220 (offset -22 lines).\npatching file packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java\nHunk #1 FAILED at 290.\n1 out of 1 hunk FAILED -- saving rejects to file packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java.rej"
                },
                {
                    "from": "12L",
                    "to": "12",
                    "result": "success",
                    "patch_output": "patching file packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\npatching file packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java"
                },
                {
                    "from": "12L",
                    "to": "11",
                    "result": "success",
                    "patch_output": "patching file packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\npatching file packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java"
                },
                {
                    "from": "12",
                    "to": "11",
                    "result": "success",
                    "patch_output": "patching file packages/SystemUI/src/com/android/systemui/qs/external/TileLifecycleManager.java\npatching file packages/SystemUI/tests/src/com/android/systemui/qs/external/TileLifecycleManagerTest.java"
                }
            ]
        },
        {
            "id": "ASB-A-281525042",
            "aliases": [
                "A-281525042",
                "CVE-2024-0053"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-281525042",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "df127e12b95a6c499b6fe1c4876eb54b90cd6327"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From df127e12b95a6c499b6fe1c4876eb54b90cd6327 Mon Sep 17 00:00:00 2001\nFrom: kumarashishg <kumarashishg@google.com>\nDate: Mon, 17 Jul 2023 12:01:18 +0000\nSubject: [PATCH] Resolve custom printer icon boundary exploit.\n\nBecause Settings grants the INTERACT_ACROSS_USERS_FULL permission, an exploit is possible where the third party print plugin service can pass other's User Icon URI. This CL provides a lightweight solution for parsing the image URI to detect profile exploitation.\n\nBug: 281525042\nTest: Build and flash the code. Try to reproduce the issue with\nmentioned steps in the bug\n\nChange-Id: Iaaa6fe2a627a265c4d1d7b843a033a132e1fe2ce\nMerged-In: Iaaa6fe2a627a265c4d1d7b843a033a132e1fe2ce\n---\n .../server/print/PrintManagerService.java     | 35 ++++++++++++++++++-\n 1 file changed, 34 insertions(+), 1 deletion(-)\n\ndiff --git a/services/print/java/com/android/server/print/PrintManagerService.java b/services/print/java/com/android/server/print/PrintManagerService.java\nindex 35b9bc3b1e06..4a8d73d23904 100644\n--- a/services/print/java/com/android/server/print/PrintManagerService.java\n+++ b/services/print/java/com/android/server/print/PrintManagerService.java\n@@ -254,12 +254,45 @@ public final class PrintManagerService extends SystemService {\n             }\n             final long identity = Binder.clearCallingIdentity();\n             try {\n-                return userState.getCustomPrinterIcon(printerId);\n+                Icon icon = userState.getCustomPrinterIcon(printerId);\n+                return validateIconUserBoundary(icon);\n             } finally {\n                 Binder.restoreCallingIdentity(identity);\n             }\n         }\n \n+        /**\n+         * Validates the custom printer icon to see if it's not in the calling user space.\n+         * If the condition is not met, return null. Otherwise, return the original icon.\n+         *\n+         * @param icon\n+         * @return icon (validated)\n+         */\n+        private Icon validateIconUserBoundary(Icon icon) {\n+            // Refer to Icon#getUriString for context. The URI string is invalid for icons of\n+            // incompatible types.\n+            if (icon != null && (icon.getType() == Icon.TYPE_URI\n+                    || icon.getType() == Icon.TYPE_URI_ADAPTIVE_BITMAP)) {\n+                String encodedUser = icon.getUri().getEncodedUserInfo();\n+\n+                // If there is no encoded user, the URI is calling into the calling user space\n+                if (encodedUser != null) {\n+                    int userId = Integer.parseInt(encodedUser);\n+                    // resolve encoded user\n+                    final int resolvedUserId = resolveCallingUserEnforcingPermissions(userId);\n+\n+                    synchronized (mLock) {\n+                        // Only the current group members can get the printer icons.\n+                        if (resolveCallingProfileParentLocked(resolvedUserId)\n+                                != getCurrentUserId()) {\n+                            return null;\n+                        }\n+                    }\n+                }\n+            }\n+            return icon;\n+        }\n+\n         @Override\n         public void cancelPrintJob(PrintJobId printJobId, int appId, int userId) {\n             if (printJobId == null) {\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 762,
                        "general": {
                            "word_based": 326,
                            "char_based": 825
                        },
                        "gemini": 940
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "0e0693ca9cb408d0dc82f6c6b3feb453fc8ddd83",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 0e0693ca9cb408d0dc82f6c6b3feb453fc8ddd83\nAuthor: kumarashishg <kumarashishg@google.com>\nDate:   Mon Jul 17 12:01:18 2023 +0000\n\n    Resolve custom printer icon boundary exploit.\n    \n    Because Settings grants the INTERACT_ACROSS_USERS_FULL permission, an exploit is possible where the third party print plugin service can pass other's User Icon URI. This CL provides a lightweight solution for parsing the image URI to detect profile exploitation.\n    \n    Bug: 281525042\n    Test: Build and flash the code. Try to reproduce the issue with\n    mentioned steps in the bug\n    \n    Change-Id: Iaaa6fe2a627a265c4d1d7b843a033a132e1fe2ce\n    Merged-In: Iaaa6fe2a627a265c4d1d7b843a033a132e1fe2ce\n\ndiff --git a/services/print/java/com/android/server/print/PrintManagerService.java b/services/print/java/com/android/server/print/PrintManagerService.java\nindex 1cdcbd87c1f5..1302b905573b 100644\n--- a/services/print/java/com/android/server/print/PrintManagerService.java\n+++ b/services/print/java/com/android/server/print/PrintManagerService.java\n@@ -254,12 +254,45 @@ public final class PrintManagerService extends SystemService {\n             }\n             final long identity = Binder.clearCallingIdentity();\n             try {\n-                return userState.getCustomPrinterIcon(printerId);\n+                Icon icon = userState.getCustomPrinterIcon(printerId);\n+                return validateIconUserBoundary(icon);\n             } finally {\n                 Binder.restoreCallingIdentity(identity);\n             }\n         }\n \n+        /**\n+         * Validates the custom printer icon to see if it's not in the calling user space.\n+         * If the condition is not met, return null. Otherwise, return the original icon.\n+         *\n+         * @param icon\n+         * @return icon (validated)\n+         */\n+        private Icon validateIconUserBoundary(Icon icon) {\n+            // Refer to Icon#getUriString for context. The URI string is invalid for icons of\n+            // incompatible types.\n+            if (icon != null && (icon.getType() == Icon.TYPE_URI\n+                    || icon.getType() == Icon.TYPE_URI_ADAPTIVE_BITMAP)) {\n+                String encodedUser = icon.getUri().getEncodedUserInfo();\n+\n+                // If there is no encoded user, the URI is calling into the calling user space\n+                if (encodedUser != null) {\n+                    int userId = Integer.parseInt(encodedUser);\n+                    // resolve encoded user\n+                    final int resolvedUserId = resolveCallingUserEnforcingPermissions(userId);\n+\n+                    synchronized (mLock) {\n+                        // Only the current group members can get the printer icons.\n+                        if (resolveCallingProfileParentLocked(resolvedUserId)\n+                                != getCurrentUserId()) {\n+                            return null;\n+                        }\n+                    }\n+                }\n+            }\n+            return icon;\n+        }\n+\n         @Override\n         public void cancelPrintJob(PrintJobId printJobId, int appId, int userId) {\n             if (printJobId == null) {\n",
                            "downstream_patch_tokens": {
                                "openai": 704,
                                "general": {
                                    "word_based": 299,
                                    "char_based": 787
                                },
                                "gemini": 868
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "7cfc47271c77b2fa5e9fa05fcf5c315dfb778dec",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 7cfc47271c77b2fa5e9fa05fcf5c315dfb778dec\nAuthor: kumarashishg <kumarashishg@google.com>\nDate:   Mon Jul 17 12:01:18 2023 +0000\n\n    Resolve custom printer icon boundary exploit.\n    \n    Because Settings grants the INTERACT_ACROSS_USERS_FULL permission, an exploit is possible where the third party print plugin service can pass other's User Icon URI. This CL provides a lightweight solution for parsing the image URI to detect profile exploitation.\n    \n    Bug: 281525042\n    Test: Build and flash the code. Try to reproduce the issue with\n    mentioned steps in the bug\n    \n    Change-Id: Iaaa6fe2a627a265c4d1d7b843a033a132e1fe2ce\n    Merged-In: Iaaa6fe2a627a265c4d1d7b843a033a132e1fe2ce\n\ndiff --git a/services/print/java/com/android/server/print/PrintManagerService.java b/services/print/java/com/android/server/print/PrintManagerService.java\nindex 1cdcbd87c1f5..1302b905573b 100644\n--- a/services/print/java/com/android/server/print/PrintManagerService.java\n+++ b/services/print/java/com/android/server/print/PrintManagerService.java\n@@ -254,12 +254,45 @@ public final class PrintManagerService extends SystemService {\n             }\n             final long identity = Binder.clearCallingIdentity();\n             try {\n-                return userState.getCustomPrinterIcon(printerId);\n+                Icon icon = userState.getCustomPrinterIcon(printerId);\n+                return validateIconUserBoundary(icon);\n             } finally {\n                 Binder.restoreCallingIdentity(identity);\n             }\n         }\n \n+        /**\n+         * Validates the custom printer icon to see if it's not in the calling user space.\n+         * If the condition is not met, return null. Otherwise, return the original icon.\n+         *\n+         * @param icon\n+         * @return icon (validated)\n+         */\n+        private Icon validateIconUserBoundary(Icon icon) {\n+            // Refer to Icon#getUriString for context. The URI string is invalid for icons of\n+            // incompatible types.\n+            if (icon != null && (icon.getType() == Icon.TYPE_URI\n+                    || icon.getType() == Icon.TYPE_URI_ADAPTIVE_BITMAP)) {\n+                String encodedUser = icon.getUri().getEncodedUserInfo();\n+\n+                // If there is no encoded user, the URI is calling into the calling user space\n+                if (encodedUser != null) {\n+                    int userId = Integer.parseInt(encodedUser);\n+                    // resolve encoded user\n+                    final int resolvedUserId = resolveCallingUserEnforcingPermissions(userId);\n+\n+                    synchronized (mLock) {\n+                        // Only the current group members can get the printer icons.\n+                        if (resolveCallingProfileParentLocked(resolvedUserId)\n+                                != getCurrentUserId()) {\n+                            return null;\n+                        }\n+                    }\n+                }\n+            }\n+            return icon;\n+        }\n+\n         @Override\n         public void cancelPrintJob(PrintJobId printJobId, int appId, int userId) {\n             if (printJobId == null) {\n",
                            "downstream_patch_tokens": {
                                "openai": 704,
                                "general": {
                                    "word_based": 299,
                                    "char_based": 787
                                },
                                "gemini": 869
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "39f5737626ca644f41fda890c12518ce51875835",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 39f5737626ca644f41fda890c12518ce51875835\nAuthor: kumarashishg <kumarashishg@google.com>\nDate:   Mon Jul 17 12:01:18 2023 +0000\n\n    Resolve custom printer icon boundary exploit.\n    \n    Because Settings grants the INTERACT_ACROSS_USERS_FULL permission, an exploit is possible where the third party print plugin service can pass other's User Icon URI. This CL provides a lightweight solution for parsing the image URI to detect profile exploitation.\n    \n    Bug: 281525042\n    Test: Build and flash the code. Try to reproduce the issue with\n    mentioned steps in the bug\n    \n    Change-Id: Iaaa6fe2a627a265c4d1d7b843a033a132e1fe2ce\n    Merged-In: Iaaa6fe2a627a265c4d1d7b843a033a132e1fe2ce\n\ndiff --git a/services/print/java/com/android/server/print/PrintManagerService.java b/services/print/java/com/android/server/print/PrintManagerService.java\nindex 66524edf61ed..1386bbff6cab 100644\n--- a/services/print/java/com/android/server/print/PrintManagerService.java\n+++ b/services/print/java/com/android/server/print/PrintManagerService.java\n@@ -254,12 +254,45 @@ public final class PrintManagerService extends SystemService {\n             }\n             final long identity = Binder.clearCallingIdentity();\n             try {\n-                return userState.getCustomPrinterIcon(printerId);\n+                Icon icon = userState.getCustomPrinterIcon(printerId);\n+                return validateIconUserBoundary(icon);\n             } finally {\n                 Binder.restoreCallingIdentity(identity);\n             }\n         }\n \n+        /**\n+         * Validates the custom printer icon to see if it's not in the calling user space.\n+         * If the condition is not met, return null. Otherwise, return the original icon.\n+         *\n+         * @param icon\n+         * @return icon (validated)\n+         */\n+        private Icon validateIconUserBoundary(Icon icon) {\n+            // Refer to Icon#getUriString for context. The URI string is invalid for icons of\n+            // incompatible types.\n+            if (icon != null && (icon.getType() == Icon.TYPE_URI\n+                    || icon.getType() == Icon.TYPE_URI_ADAPTIVE_BITMAP)) {\n+                String encodedUser = icon.getUri().getEncodedUserInfo();\n+\n+                // If there is no encoded user, the URI is calling into the calling user space\n+                if (encodedUser != null) {\n+                    int userId = Integer.parseInt(encodedUser);\n+                    // resolve encoded user\n+                    final int resolvedUserId = resolveCallingUserEnforcingPermissions(userId);\n+\n+                    synchronized (mLock) {\n+                        // Only the current group members can get the printer icons.\n+                        if (resolveCallingProfileParentLocked(resolvedUserId)\n+                                != getCurrentUserId()) {\n+                            return null;\n+                        }\n+                    }\n+                }\n+            }\n+            return icon;\n+        }\n+\n         @Override\n         public void cancelPrintJob(PrintJobId printJobId, int appId, int userId) {\n             if (printJobId == null) {\n",
                            "downstream_patch_tokens": {
                                "openai": 697,
                                "general": {
                                    "word_based": 299,
                                    "char_based": 787
                                },
                                "gemini": 868
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "c58f2b7b262eee49130f47d72247615f07af4a81",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit c58f2b7b262eee49130f47d72247615f07af4a81\nAuthor: kumarashishg <kumarashishg@google.com>\nDate:   Mon Jul 17 12:01:18 2023 +0000\n\n    Resolve custom printer icon boundary exploit.\n    \n    Because Settings grants the INTERACT_ACROSS_USERS_FULL permission, an exploit is possible where the third party print plugin service can pass other's User Icon URI. This CL provides a lightweight solution for parsing the image URI to detect profile exploitation.\n    \n    Bug: 281525042\n    Test: Build and flash the code. Try to reproduce the issue with\n    mentioned steps in the bug\n    \n    Change-Id: Iaaa6fe2a627a265c4d1d7b843a033a132e1fe2ce\n    Merged-In: Iaaa6fe2a627a265c4d1d7b843a033a132e1fe2ce\n\ndiff --git a/services/print/java/com/android/server/print/PrintManagerService.java b/services/print/java/com/android/server/print/PrintManagerService.java\nindex 35b9bc3b1e06..4a8d73d23904 100644\n--- a/services/print/java/com/android/server/print/PrintManagerService.java\n+++ b/services/print/java/com/android/server/print/PrintManagerService.java\n@@ -254,12 +254,45 @@ public final class PrintManagerService extends SystemService {\n             }\n             final long identity = Binder.clearCallingIdentity();\n             try {\n-                return userState.getCustomPrinterIcon(printerId);\n+                Icon icon = userState.getCustomPrinterIcon(printerId);\n+                return validateIconUserBoundary(icon);\n             } finally {\n                 Binder.restoreCallingIdentity(identity);\n             }\n         }\n \n+        /**\n+         * Validates the custom printer icon to see if it's not in the calling user space.\n+         * If the condition is not met, return null. Otherwise, return the original icon.\n+         *\n+         * @param icon\n+         * @return icon (validated)\n+         */\n+        private Icon validateIconUserBoundary(Icon icon) {\n+            // Refer to Icon#getUriString for context. The URI string is invalid for icons of\n+            // incompatible types.\n+            if (icon != null && (icon.getType() == Icon.TYPE_URI\n+                    || icon.getType() == Icon.TYPE_URI_ADAPTIVE_BITMAP)) {\n+                String encodedUser = icon.getUri().getEncodedUserInfo();\n+\n+                // If there is no encoded user, the URI is calling into the calling user space\n+                if (encodedUser != null) {\n+                    int userId = Integer.parseInt(encodedUser);\n+                    // resolve encoded user\n+                    final int resolvedUserId = resolveCallingUserEnforcingPermissions(userId);\n+\n+                    synchronized (mLock) {\n+                        // Only the current group members can get the printer icons.\n+                        if (resolveCallingProfileParentLocked(resolvedUserId)\n+                                != getCurrentUserId()) {\n+                            return null;\n+                        }\n+                    }\n+                }\n+            }\n+            return icon;\n+        }\n+\n         @Override\n         public void cancelPrintJob(PrintJobId printJobId, int appId, int userId) {\n             if (printJobId == null) {\n",
                            "downstream_patch_tokens": {
                                "openai": 705,
                                "general": {
                                    "word_based": 299,
                                    "char_based": 787
                                },
                                "gemini": 874
                            }
                        }
                    ]
                }
            ],
            "cross_patch_attempts": [
                {
                    "from": "14",
                    "to": "13",
                    "result": "success",
                    "patch_output": "patching file services/print/java/com/android/server/print/PrintManagerService.java"
                },
                {
                    "from": "14",
                    "to": "12L",
                    "result": "success",
                    "patch_output": "patching file services/print/java/com/android/server/print/PrintManagerService.java"
                },
                {
                    "from": "14",
                    "to": "12",
                    "result": "success",
                    "patch_output": "patching file services/print/java/com/android/server/print/PrintManagerService.java"
                },
                {
                    "from": "13",
                    "to": "12L",
                    "result": "success",
                    "patch_output": "patching file services/print/java/com/android/server/print/PrintManagerService.java"
                },
                {
                    "from": "13",
                    "to": "12",
                    "result": "success",
                    "patch_output": "patching file services/print/java/com/android/server/print/PrintManagerService.java"
                },
                {
                    "from": "12L",
                    "to": "12",
                    "result": "success",
                    "patch_output": "patching file services/print/java/com/android/server/print/PrintManagerService.java"
                }
            ]
        },
        {
            "id": "ASB-A-321326147",
            "aliases": [
                "A-321326147",
                "CVE-2024-31327"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-321326147",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "db9028d6eead72c9cd45da48087ec6d5f1ac9c5a"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From db9028d6eead72c9cd45da48087ec6d5f1ac9c5a Mon Sep 17 00:00:00 2001\nFrom: Devin Moore <devinmoore@google.com>\nDate: Mon, 22 Jan 2024 17:52:16 +0000\nSubject: [PATCH] Use the values of the ptrs that we check\n\nTest: fmq_fuzzer\nBug: 321326147\nBug: 321341508\nBug: 321383085\n(cherry picked from https://android-review.googlesource.com/q/commit:38963310ad5789b625ca0bca9f9c2c8e24666651)\nMerged-In: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\nChange-Id: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\n---\n include/fmq/MessageQueueBase.h | 24 ++++++++++++++++++++----\n 1 file changed, 20 insertions(+), 4 deletions(-)\n\ndiff --git a/include/fmq/MessageQueueBase.h b/include/fmq/MessageQueueBase.h\nindex f99e335..7a027ec 100644\n--- a/include/fmq/MessageQueueBase.h\n+++ b/include/fmq/MessageQueueBase.h\n@@ -1044,8 +1044,16 @@ bool MessageQueueBase<MQDescriptorType, T, flavor>::readBlocking(T* data, size_t\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n-    return mDesc->getSize() - availableToReadBytes();\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n+    size_t queueSizeBytes = mDesc->getSize();\n+    size_t availableBytes = availableToReadBytes();\n+    if (queueSizeBytes < availableBytes) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return queueSizeBytes - availableBytes;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n@@ -1127,13 +1135,21 @@ MessageQueueBase<MQDescriptorType, T, flavor>::commitWrite(size_t nMessages) {\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n     /*\n      * This method is invoked by implementations of both read() and write() and\n      * hence requires a memory_order_acquired load for both mReadPtr and\n      * mWritePtr.\n      */\n-    return mWritePtr->load(std::memory_order_acquire) - mReadPtr->load(std::memory_order_acquire);\n+    uint64_t writePtr = mWritePtr->load(std::memory_order_acquire);\n+    uint64_t readPtr = mReadPtr->load(std::memory_order_acquire);\n+    if (writePtr < readPtr) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return writePtr - readPtr;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 848,
                        "general": {
                            "word_based": 306,
                            "char_based": 730
                        },
                        "gemini": 1025
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "af19e0ef034174afd794563552f91303fd9f1529",
                            "repo_path": "android_repos/libfmq",
                            "result": "success",
                            "downstream_patch_content": "commit af19e0ef034174afd794563552f91303fd9f1529\nAuthor: Devin Moore <devinmoore@google.com>\nDate:   Mon Jan 22 17:52:16 2024 +0000\n\n    Use the values of the ptrs that we check\n    \n    Test: fmq_fuzzer\n    Bug: 321326147\n    Bug: 321341508\n    Bug: 321383085\n    (cherry picked from https://android-review.googlesource.com/q/commit:38963310ad5789b625ca0bca9f9c2c8e24666651)\n    Merged-In: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\n    Change-Id: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\n\ndiff --git a/include/fmq/MessageQueueBase.h b/include/fmq/MessageQueueBase.h\nindex b932317..d3c80bb 100644\n--- a/include/fmq/MessageQueueBase.h\n+++ b/include/fmq/MessageQueueBase.h\n@@ -1042,8 +1042,16 @@ bool MessageQueueBase<MQDescriptorType, T, flavor>::readBlocking(T* data, size_t\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n-    return mDesc->getSize() - availableToReadBytes();\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n+    size_t queueSizeBytes = mDesc->getSize();\n+    size_t availableBytes = availableToReadBytes();\n+    if (queueSizeBytes < availableBytes) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return queueSizeBytes - availableBytes;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n@@ -1125,13 +1133,21 @@ MessageQueueBase<MQDescriptorType, T, flavor>::commitWrite(size_t nMessages) {\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n     /*\n      * This method is invoked by implementations of both read() and write() and\n      * hence requires a memory_order_acquired load for both mReadPtr and\n      * mWritePtr.\n      */\n-    return mWritePtr->load(std::memory_order_acquire) - mReadPtr->load(std::memory_order_acquire);\n+    uint64_t writePtr = mWritePtr->load(std::memory_order_acquire);\n+    uint64_t readPtr = mReadPtr->load(std::memory_order_acquire);\n+    if (writePtr < readPtr) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return writePtr - readPtr;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n",
                            "downstream_patch_tokens": {
                                "openai": 786,
                                "general": {
                                    "word_based": 279,
                                    "char_based": 694
                                },
                                "gemini": 958
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "b923a7c0d0d25de7b0c9ba7a7c2a3e917819d95a",
                            "repo_path": "android_repos/libfmq",
                            "result": "success",
                            "downstream_patch_content": "commit b923a7c0d0d25de7b0c9ba7a7c2a3e917819d95a\nAuthor: Devin Moore <devinmoore@google.com>\nDate:   Mon Jan 22 17:52:16 2024 +0000\n\n    Use the values of the ptrs that we check\n    \n    Test: fmq_fuzzer\n    Bug: 321326147\n    Bug: 321341508\n    Bug: 321383085\n    (cherry picked from https://android-review.googlesource.com/q/commit:38963310ad5789b625ca0bca9f9c2c8e24666651)\n    Merged-In: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\n    Change-Id: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\n\ndiff --git a/include/fmq/MessageQueueBase.h b/include/fmq/MessageQueueBase.h\nindex b932317..d3c80bb 100644\n--- a/include/fmq/MessageQueueBase.h\n+++ b/include/fmq/MessageQueueBase.h\n@@ -1042,8 +1042,16 @@ bool MessageQueueBase<MQDescriptorType, T, flavor>::readBlocking(T* data, size_t\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n-    return mDesc->getSize() - availableToReadBytes();\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n+    size_t queueSizeBytes = mDesc->getSize();\n+    size_t availableBytes = availableToReadBytes();\n+    if (queueSizeBytes < availableBytes) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return queueSizeBytes - availableBytes;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n@@ -1125,13 +1133,21 @@ MessageQueueBase<MQDescriptorType, T, flavor>::commitWrite(size_t nMessages) {\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n     /*\n      * This method is invoked by implementations of both read() and write() and\n      * hence requires a memory_order_acquired load for both mReadPtr and\n      * mWritePtr.\n      */\n-    return mWritePtr->load(std::memory_order_acquire) - mReadPtr->load(std::memory_order_acquire);\n+    uint64_t writePtr = mWritePtr->load(std::memory_order_acquire);\n+    uint64_t readPtr = mReadPtr->load(std::memory_order_acquire);\n+    if (writePtr < readPtr) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return writePtr - readPtr;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n",
                            "downstream_patch_tokens": {
                                "openai": 797,
                                "general": {
                                    "word_based": 279,
                                    "char_based": 694
                                },
                                "gemini": 961
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "050952bf5f9bd035e469ce005300115d563e524a",
                            "repo_path": "android_repos/libfmq",
                            "result": "success",
                            "downstream_patch_content": "commit 050952bf5f9bd035e469ce005300115d563e524a\nAuthor: Devin Moore <devinmoore@google.com>\nDate:   Mon Jan 22 17:52:16 2024 +0000\n\n    Use the values of the ptrs that we check\n    \n    Test: fmq_fuzzer\n    Bug: 321326147\n    Bug: 321341508\n    Bug: 321383085\n    (cherry picked from https://android-review.googlesource.com/q/commit:38963310ad5789b625ca0bca9f9c2c8e24666651)\n    Merged-In: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\n    Change-Id: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\n\ndiff --git a/include/fmq/MessageQueueBase.h b/include/fmq/MessageQueueBase.h\nindex c34a4ff..652487b 100644\n--- a/include/fmq/MessageQueueBase.h\n+++ b/include/fmq/MessageQueueBase.h\n@@ -1022,8 +1022,16 @@ bool MessageQueueBase<MQDescriptorType, T, flavor>::readBlocking(T* data, size_t\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n-    return mDesc->getSize() - availableToReadBytes();\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n+    size_t queueSizeBytes = mDesc->getSize();\n+    size_t availableBytes = availableToReadBytes();\n+    if (queueSizeBytes < availableBytes) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return queueSizeBytes - availableBytes;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n@@ -1105,13 +1113,21 @@ MessageQueueBase<MQDescriptorType, T, flavor>::commitWrite(size_t nMessages) {\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n     /*\n      * This method is invoked by implementations of both read() and write() and\n      * hence requires a memory_order_acquired load for both mReadPtr and\n      * mWritePtr.\n      */\n-    return mWritePtr->load(std::memory_order_acquire) - mReadPtr->load(std::memory_order_acquire);\n+    uint64_t writePtr = mWritePtr->load(std::memory_order_acquire);\n+    uint64_t readPtr = mReadPtr->load(std::memory_order_acquire);\n+    if (writePtr < readPtr) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return writePtr - readPtr;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n",
                            "downstream_patch_tokens": {
                                "openai": 787,
                                "general": {
                                    "word_based": 279,
                                    "char_based": 694
                                },
                                "gemini": 961
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "da080aa565f0cd1158bde3b8100dc73604959035",
                            "repo_path": "android_repos/libfmq",
                            "result": "success",
                            "downstream_patch_content": "commit da080aa565f0cd1158bde3b8100dc73604959035\nAuthor: Devin Moore <devinmoore@google.com>\nDate:   Mon Jan 22 17:52:16 2024 +0000\n\n    Use the values of the ptrs that we check\n    \n    Test: fmq_fuzzer\n    Bug: 321326147\n    Bug: 321341508\n    Bug: 321383085\n    (cherry picked from https://android-review.googlesource.com/q/commit:38963310ad5789b625ca0bca9f9c2c8e24666651)\n    Merged-In: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\n    Change-Id: I56fe4fe72180e39ecef066353969c1ae9fbcd44e\n\ndiff --git a/include/fmq/MessageQueueBase.h b/include/fmq/MessageQueueBase.h\nindex f99e335..7a027ec 100644\n--- a/include/fmq/MessageQueueBase.h\n+++ b/include/fmq/MessageQueueBase.h\n@@ -1044,8 +1044,16 @@ bool MessageQueueBase<MQDescriptorType, T, flavor>::readBlocking(T* data, size_t\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n-    return mDesc->getSize() - availableToReadBytes();\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToWriteBytes() const {\n+    size_t queueSizeBytes = mDesc->getSize();\n+    size_t availableBytes = availableToReadBytes();\n+    if (queueSizeBytes < availableBytes) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return queueSizeBytes - availableBytes;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n@@ -1127,13 +1135,21 @@ MessageQueueBase<MQDescriptorType, T, flavor>::commitWrite(size_t nMessages) {\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n-size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n+inline size_t MessageQueueBase<MQDescriptorType, T, flavor>::availableToReadBytes() const {\n     /*\n      * This method is invoked by implementations of both read() and write() and\n      * hence requires a memory_order_acquired load for both mReadPtr and\n      * mWritePtr.\n      */\n-    return mWritePtr->load(std::memory_order_acquire) - mReadPtr->load(std::memory_order_acquire);\n+    uint64_t writePtr = mWritePtr->load(std::memory_order_acquire);\n+    uint64_t readPtr = mReadPtr->load(std::memory_order_acquire);\n+    if (writePtr < readPtr) {\n+        hardware::details::logError(\n+                \"The write or read pointer has become corrupted. Reading from the queue is no \"\n+                \"longer possible.\");\n+        return 0;\n+    }\n+    return writePtr - readPtr;\n }\n \n template <template <typename, MQFlavor> typename MQDescriptorType, typename T, MQFlavor flavor>\n",
                            "downstream_patch_tokens": {
                                "openai": 787,
                                "general": {
                                    "word_based": 279,
                                    "char_based": 694
                                },
                                "gemini": 957
                            }
                        }
                    ]
                }
            ],
            "cross_patch_attempts": [
                {
                    "from": "14",
                    "to": "13",
                    "result": "success",
                    "patch_output": "patching file include/fmq/MessageQueueBase.h\nHunk #1 succeeded at 1022 (offset -22 lines).\nHunk #2 succeeded at 1113 (offset -22 lines)."
                },
                {
                    "from": "14",
                    "to": "12L",
                    "result": "success",
                    "patch_output": "patching file include/fmq/MessageQueueBase.h\nHunk #1 succeeded at 1042 (offset -2 lines).\nHunk #2 succeeded at 1133 (offset -2 lines)."
                },
                {
                    "from": "14",
                    "to": "12",
                    "result": "success",
                    "patch_output": "patching file include/fmq/MessageQueueBase.h\nHunk #1 succeeded at 1042 (offset -2 lines).\nHunk #2 succeeded at 1133 (offset -2 lines)."
                },
                {
                    "from": "13",
                    "to": "12L",
                    "result": "success",
                    "patch_output": "patching file include/fmq/MessageQueueBase.h\nHunk #1 succeeded at 1042 (offset 20 lines).\nHunk #2 succeeded at 1133 (offset 20 lines)."
                },
                {
                    "from": "13",
                    "to": "12",
                    "result": "success",
                    "patch_output": "patching file include/fmq/MessageQueueBase.h\nHunk #1 succeeded at 1042 (offset 20 lines).\nHunk #2 succeeded at 1133 (offset 20 lines)."
                },
                {
                    "from": "12L",
                    "to": "12",
                    "result": "success",
                    "patch_output": "patching file include/fmq/MessageQueueBase.h"
                }
            ]
        },
        {
            "id": "ASB-A-335232744",
            "aliases": [
                "A-335232744",
                "CVE-2024-34742"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-335232744",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "aaa86cdfb79003fd66aae1132b9c06cfe80d7d08"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From aaa86cdfb79003fd66aae1132b9c06cfe80d7d08 Mon Sep 17 00:00:00 2001\nFrom: Pavel Grafov <pgrafov@google.com>\nDate: Tue, 16 Apr 2024 18:28:16 +0100\nSubject: [PATCH] Ensure device_owners2.xml is always written.\n\nBug: 335232744\nTest: Manual, upgrading from T-QPR3\nChange-Id: I7a7dba56f2951e7e3699b19d2517d198dc8f9d35\n---\n core/java/android/app/admin/flags/flags.aconfig        | 10 ++++++++++\n .../com/android/server/devicepolicy/OwnersData.java    |  3 ++-\n 2 files changed, 12 insertions(+), 1 deletion(-)\n\ndiff --git a/core/java/android/app/admin/flags/flags.aconfig b/core/java/android/app/admin/flags/flags.aconfig\nindex 6a07484eebc6..0eb67d16436c 100644\n--- a/core/java/android/app/admin/flags/flags.aconfig\n+++ b/core/java/android/app/admin/flags/flags.aconfig\n@@ -227,6 +227,16 @@ flag {\n   bug: \"323894620\"\n }\n \n+flag {\n+  name: \"always_persist_do\"\n+  namespace: \"enterprise\"\n+  description: \"Always write device_owners2.xml so that migration flags aren't lost\"\n+  bug: \"335232744\"\n+  metadata {\n+    purpose: PURPOSE_BUGFIX\n+  }\n+}\n+\n flag {\n   name: \"is_recursive_required_app_merging_enabled\"\n   namespace: \"enterprise\"\ndiff --git a/services/devicepolicy/java/com/android/server/devicepolicy/OwnersData.java b/services/devicepolicy/java/com/android/server/devicepolicy/OwnersData.java\nindex 42ac998bf96c..d02cfee72aa2 100644\n--- a/services/devicepolicy/java/com/android/server/devicepolicy/OwnersData.java\n+++ b/services/devicepolicy/java/com/android/server/devicepolicy/OwnersData.java\n@@ -357,7 +357,8 @@ class OwnersData {\n \n         @Override\n         boolean shouldWrite() {\n-            return (mDeviceOwner != null) || (mSystemUpdatePolicy != null)\n+            return Flags.alwaysPersistDo()\n+                    || (mDeviceOwner != null) || (mSystemUpdatePolicy != null)\n                     || (mSystemUpdateInfo != null);\n         }\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 558,
                        "general": {
                            "word_based": 217,
                            "char_based": 471
                        },
                        "gemini": 752
                    },
                    "total_downstream_versions_tested": 1,
                    "successful_patches": 1,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "3abc07421d5bed187589d6deb48da07e4c407203",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 3abc07421d5bed187589d6deb48da07e4c407203\nAuthor: Pavel Grafov <pgrafov@google.com>\nDate:   Tue Apr 16 18:28:16 2024 +0100\n\n    Ensure device_owners2.xml is always written.\n    \n    Bug: 335232744\n    Test: Manual, upgrading from T-QPR3\n    Change-Id: I7a7dba56f2951e7e3699b19d2517d198dc8f9d35\n    Merged-In: I7a7dba56f2951e7e3699b19d2517d198dc8f9d35\n\ndiff --git a/services/devicepolicy/java/com/android/server/devicepolicy/OwnersData.java b/services/devicepolicy/java/com/android/server/devicepolicy/OwnersData.java\nindex 608ae140450e..2ced224091a0 100644\n--- a/services/devicepolicy/java/com/android/server/devicepolicy/OwnersData.java\n+++ b/services/devicepolicy/java/com/android/server/devicepolicy/OwnersData.java\n@@ -354,8 +354,7 @@ class OwnersData {\n \n         @Override\n         boolean shouldWrite() {\n-            return (mDeviceOwner != null) || (mSystemUpdatePolicy != null)\n-                    || (mSystemUpdateInfo != null);\n+            return true;\n         }\n \n         @Override\n",
                            "downstream_patch_tokens": {
                                "openai": 303,
                                "general": {
                                    "word_based": 102,
                                    "char_based": 251
                                },
                                "gemini": 416
                            }
                        }
                    ]
                }
            ],
            "cross_patch_attempts": []
        },
        {
            "id": "ASB-A-324874908",
            "aliases": [
                "A-324874908",
                "CVE-2024-31310"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-324874908",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "141d9d050346bfc4673c429382deb1b3d210f6ad"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 141d9d050346bfc4673c429382deb1b3d210f6ad Mon Sep 17 00:00:00 2001\nFrom: Haoran Zhang <haoranzhang@google.com>\nDate: Wed, 13 Mar 2024 17:08:00 +0000\nSubject: [PATCH] [Autofill Framework] Add in check for intent filter when\n setting/updating service\n\nFor test, I registered two tests around on ABTD. CtsAutoFillServiceTestCases module is passing except three known failures:\n\nTest run link:\n- https://android-build.corp.google.com/builds/abtd/run/L33300030002610600\n- https://android-build.corp.google.com/builds/abtd/run/L58100030002616607\n\n\nBug: b/324874908\nTest: atest CtsAutoFillServiceTestCases\nChange-Id: I51c2e3788ac29ff4d6b86aa2a735ff2ea1463a77\n---\n .../autofill/AutofillManagerServiceImpl.java  | 27 +++++++++++++++++++\n 1 file changed, 27 insertions(+)\n\ndiff --git a/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java b/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\nindex e1291e5f75ec..3ed32fc03e7d 100644\n--- a/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\n+++ b/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\n@@ -33,8 +33,10 @@ import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.ActivityManagerInternal;\n import android.content.ComponentName;\n+import android.content.Intent;\n import android.content.pm.PackageManager;\n import android.content.pm.PackageManager.NameNotFoundException;\n+import android.content.pm.ResolveInfo;\n import android.content.pm.ServiceInfo;\n import android.graphics.Rect;\n import android.metrics.LogMaker;\n@@ -251,6 +253,31 @@ final class AutofillManagerServiceImpl\n     @Override // from PerUserSystemService\n     protected ServiceInfo newServiceInfoLocked(@NonNull ComponentName serviceComponent)\n             throws NameNotFoundException {\n+        final List<ResolveInfo> resolveInfos =\n+                getContext().getPackageManager().queryIntentServicesAsUser(\n+                    new Intent(AutofillService.SERVICE_INTERFACE),\n+                    // The MATCH_INSTANT flag is added because curret autofill CTS module is\n+                    // defined in one apk, which makes the test autofill service installed in a\n+                    // instant app when the CTS tests are running in instant app mode.\n+                    // TODO: Remove MATCH_INSTANT flag after completing refactoring the CTS module\n+                    //       to make the test autofill service a separate apk.\n+                    PackageManager.GET_META_DATA | PackageManager.MATCH_INSTANT,\n+                    mUserId);\n+        boolean serviceHasAutofillIntentFilter = false;\n+        for (ResolveInfo resolveInfo : resolveInfos) {\n+            final ServiceInfo serviceInfo = resolveInfo.serviceInfo;\n+            if (serviceInfo.getComponentName().equals(serviceComponent)) {\n+                serviceHasAutofillIntentFilter = true;\n+                break;\n+            }\n+        }\n+        if (!serviceHasAutofillIntentFilter) {\n+            Slog.w(TAG,\n+                    \"Autofill service from '\" + serviceComponent.getPackageName() + \"' does\"\n+                            + \"not have intent filter \" + AutofillService.SERVICE_INTERFACE);\n+            throw new SecurityException(\"Service does not declare intent filter \"\n+                            + AutofillService.SERVICE_INTERFACE);\n+        }\n         mInfo = new AutofillServiceInfo(getContext(), serviceComponent, mUserId);\n         return mInfo.getServiceInfo();\n     }\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 835,
                        "general": {
                            "word_based": 347,
                            "char_based": 893
                        },
                        "gemini": 1021
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "51d64705ab70788a536c26d4df5e63f0952ec98f",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 51d64705ab70788a536c26d4df5e63f0952ec98f\nAuthor: Haoran Zhang <haoranzhang@google.com>\nDate:   Wed Mar 13 17:08:00 2024 +0000\n\n    [DO NOT MERGE][Autofill Framework] Add in check for intent filter when\n    setting/updating service\n    \n    For test, I registered two tests around on ABTD. CtsAutoFillServiceTestCases module is passing except three known failures:\n    \n    Test run link:\n    - https://android-build.corp.google.com/builds/abtd/run/L33300030002610600\n    - https://android-build.corp.google.com/builds/abtd/run/L58100030002616607\n    \n    \n    Bug: b/324874908\n    Test: atest CtsAutoFillServiceTestCases\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:141d9d050346bfc4673c429382deb1b3d210f6ad)\n    Merged-In: I51c2e3788ac29ff4d6b86aa2a735ff2ea1463a77\n    Change-Id: I51c2e3788ac29ff4d6b86aa2a735ff2ea1463a77\n\ndiff --git a/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java b/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\nindex aa42e8deb581..0420d7f7f68e 100644\n--- a/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\n+++ b/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\n@@ -30,8 +30,10 @@ import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.ActivityManagerInternal;\n import android.content.ComponentName;\n+import android.content.Intent;\n import android.content.pm.PackageManager;\n import android.content.pm.PackageManager.NameNotFoundException;\n+import android.content.pm.ResolveInfo;\n import android.content.pm.ServiceInfo;\n import android.graphics.Rect;\n import android.metrics.LogMaker;\n@@ -236,6 +238,31 @@ final class AutofillManagerServiceImpl\n     @Override // from PerUserSystemService\n     protected ServiceInfo newServiceInfoLocked(@NonNull ComponentName serviceComponent)\n             throws NameNotFoundException {\n+        final List<ResolveInfo> resolveInfos =\n+                getContext().getPackageManager().queryIntentServicesAsUser(\n+                    new Intent(AutofillService.SERVICE_INTERFACE),\n+                    // The MATCH_INSTANT flag is added because curret autofill CTS module is\n+                    // defined in one apk, which makes the test autofill service installed in a\n+                    // instant app when the CTS tests are running in instant app mode.\n+                    // TODO: Remove MATCH_INSTANT flag after completing refactoring the CTS module\n+                    //       to make the test autofill service a separate apk.\n+                    PackageManager.GET_META_DATA | PackageManager.MATCH_INSTANT,\n+                    mUserId);\n+        boolean serviceHasAutofillIntentFilter = false;\n+        for (ResolveInfo resolveInfo : resolveInfos) {\n+            final ServiceInfo serviceInfo = resolveInfo.serviceInfo;\n+            if (serviceInfo.getComponentName().equals(serviceComponent)) {\n+                serviceHasAutofillIntentFilter = true;\n+                break;\n+            }\n+        }\n+        if (!serviceHasAutofillIntentFilter) {\n+            Slog.w(TAG,\n+                    \"Autofill service from '\" + serviceComponent.getPackageName() + \"' does\"\n+                            + \"not have intent filter \" + AutofillService.SERVICE_INTERFACE);\n+            throw new SecurityException(\"Service does not declare intent filter \"\n+                            + AutofillService.SERVICE_INTERFACE);\n+        }\n         mInfo = new AutofillServiceInfo(getContext(), serviceComponent, mUserId);\n         return mInfo.getServiceInfo();\n     }\n",
                            "downstream_patch_tokens": {
                                "openai": 864,
                                "general": {
                                    "word_based": 341,
                                    "char_based": 912
                                },
                                "gemini": 1073
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "bedc0ff2bfa8c5faf336ba5e87d80b3a85fde53d",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit bedc0ff2bfa8c5faf336ba5e87d80b3a85fde53d\nAuthor: Haoran Zhang <haoranzhang@google.com>\nDate:   Wed Mar 13 17:08:00 2024 +0000\n\n    [DO NOT MERGE][Autofill Framework] Add in check for intent filter when\n    setting/updating service\n    \n    For test, I registered two tests around on ABTD. CtsAutoFillServiceTestCases module is passing except three known failures:\n    \n    Test run link:\n    - https://android-build.corp.google.com/builds/abtd/run/L33300030002610600\n    - https://android-build.corp.google.com/builds/abtd/run/L58100030002616607\n    \n    \n    Bug: b/324874908\n    Test: atest CtsAutoFillServiceTestCases\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:141d9d050346bfc4673c429382deb1b3d210f6ad)\n    Merged-In: I51c2e3788ac29ff4d6b86aa2a735ff2ea1463a77\n    Change-Id: I51c2e3788ac29ff4d6b86aa2a735ff2ea1463a77\n\ndiff --git a/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java b/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\nindex aa42e8deb581..0420d7f7f68e 100644\n--- a/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\n+++ b/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\n@@ -30,8 +30,10 @@ import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.ActivityManagerInternal;\n import android.content.ComponentName;\n+import android.content.Intent;\n import android.content.pm.PackageManager;\n import android.content.pm.PackageManager.NameNotFoundException;\n+import android.content.pm.ResolveInfo;\n import android.content.pm.ServiceInfo;\n import android.graphics.Rect;\n import android.metrics.LogMaker;\n@@ -236,6 +238,31 @@ final class AutofillManagerServiceImpl\n     @Override // from PerUserSystemService\n     protected ServiceInfo newServiceInfoLocked(@NonNull ComponentName serviceComponent)\n             throws NameNotFoundException {\n+        final List<ResolveInfo> resolveInfos =\n+                getContext().getPackageManager().queryIntentServicesAsUser(\n+                    new Intent(AutofillService.SERVICE_INTERFACE),\n+                    // The MATCH_INSTANT flag is added because curret autofill CTS module is\n+                    // defined in one apk, which makes the test autofill service installed in a\n+                    // instant app when the CTS tests are running in instant app mode.\n+                    // TODO: Remove MATCH_INSTANT flag after completing refactoring the CTS module\n+                    //       to make the test autofill service a separate apk.\n+                    PackageManager.GET_META_DATA | PackageManager.MATCH_INSTANT,\n+                    mUserId);\n+        boolean serviceHasAutofillIntentFilter = false;\n+        for (ResolveInfo resolveInfo : resolveInfos) {\n+            final ServiceInfo serviceInfo = resolveInfo.serviceInfo;\n+            if (serviceInfo.getComponentName().equals(serviceComponent)) {\n+                serviceHasAutofillIntentFilter = true;\n+                break;\n+            }\n+        }\n+        if (!serviceHasAutofillIntentFilter) {\n+            Slog.w(TAG,\n+                    \"Autofill service from '\" + serviceComponent.getPackageName() + \"' does\"\n+                            + \"not have intent filter \" + AutofillService.SERVICE_INTERFACE);\n+            throw new SecurityException(\"Service does not declare intent filter \"\n+                            + AutofillService.SERVICE_INTERFACE);\n+        }\n         mInfo = new AutofillServiceInfo(getContext(), serviceComponent, mUserId);\n         return mInfo.getServiceInfo();\n     }\n",
                            "downstream_patch_tokens": {
                                "openai": 866,
                                "general": {
                                    "word_based": 341,
                                    "char_based": 912
                                },
                                "gemini": 1066
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "ee20adb4b4b2065e040167a4354c4fabaf06e35d",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit ee20adb4b4b2065e040167a4354c4fabaf06e35d\nAuthor: Haoran Zhang <haoranzhang@google.com>\nDate:   Wed Mar 13 17:08:00 2024 +0000\n\n    [DO NOT MERGE][Autofill Framework] Add in check for intent filter when\n    setting/updating service\n    \n    For test, I registered two tests around on ABTD. CtsAutoFillServiceTestCases module is passing except three known failures:\n    \n    Test run link:\n    - https://android-build.corp.google.com/builds/abtd/run/L33300030002610600\n    - https://android-build.corp.google.com/builds/abtd/run/L58100030002616607\n    \n    \n    Bug: b/324874908\n    Test: atest CtsAutoFillServiceTestCases\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:141d9d050346bfc4673c429382deb1b3d210f6ad)\n    Merged-In: I51c2e3788ac29ff4d6b86aa2a735ff2ea1463a77\n    Change-Id: I51c2e3788ac29ff4d6b86aa2a735ff2ea1463a77\n\ndiff --git a/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java b/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\nindex fe85db286fa8..abe68c47b050 100644\n--- a/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\n+++ b/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\n@@ -32,8 +32,10 @@ import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.ActivityManagerInternal;\n import android.content.ComponentName;\n+import android.content.Intent;\n import android.content.pm.PackageManager;\n import android.content.pm.PackageManager.NameNotFoundException;\n+import android.content.pm.ResolveInfo;\n import android.content.pm.ServiceInfo;\n import android.graphics.Rect;\n import android.metrics.LogMaker;\n@@ -239,6 +241,31 @@ final class AutofillManagerServiceImpl\n     @Override // from PerUserSystemService\n     protected ServiceInfo newServiceInfoLocked(@NonNull ComponentName serviceComponent)\n             throws NameNotFoundException {\n+        final List<ResolveInfo> resolveInfos =\n+                getContext().getPackageManager().queryIntentServicesAsUser(\n+                    new Intent(AutofillService.SERVICE_INTERFACE),\n+                    // The MATCH_INSTANT flag is added because curret autofill CTS module is\n+                    // defined in one apk, which makes the test autofill service installed in a\n+                    // instant app when the CTS tests are running in instant app mode.\n+                    // TODO: Remove MATCH_INSTANT flag after completing refactoring the CTS module\n+                    //       to make the test autofill service a separate apk.\n+                    PackageManager.GET_META_DATA | PackageManager.MATCH_INSTANT,\n+                    mUserId);\n+        boolean serviceHasAutofillIntentFilter = false;\n+        for (ResolveInfo resolveInfo : resolveInfos) {\n+            final ServiceInfo serviceInfo = resolveInfo.serviceInfo;\n+            if (serviceInfo.getComponentName().equals(serviceComponent)) {\n+                serviceHasAutofillIntentFilter = true;\n+                break;\n+            }\n+        }\n+        if (!serviceHasAutofillIntentFilter) {\n+            Slog.w(TAG,\n+                    \"Autofill service from '\" + serviceComponent.getPackageName() + \"' does\"\n+                            + \"not have intent filter \" + AutofillService.SERVICE_INTERFACE);\n+            throw new SecurityException(\"Service does not declare intent filter \"\n+                            + AutofillService.SERVICE_INTERFACE);\n+        }\n         mInfo = new AutofillServiceInfo(getContext(), serviceComponent, mUserId);\n         return mInfo.getServiceInfo();\n     }\n",
                            "downstream_patch_tokens": {
                                "openai": 860,
                                "general": {
                                    "word_based": 341,
                                    "char_based": 912
                                },
                                "gemini": 1067
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "e8a448f855ef6ba9ae4b655e6824631f8023c0a0",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit e8a448f855ef6ba9ae4b655e6824631f8023c0a0\nAuthor: Haoran Zhang <haoranzhang@google.com>\nDate:   Wed Mar 13 17:08:00 2024 +0000\n\n    [DO NOT MERGE][Autofill Framework] Add in check for intent filter when\n    setting/updating service\n    \n    For test, I registered two tests around on ABTD. CtsAutoFillServiceTestCases module is passing except three known failures:\n    \n    Test run link:\n    - https://android-build.corp.google.com/builds/abtd/run/L33300030002610600\n    - https://android-build.corp.google.com/builds/abtd/run/L58100030002616607\n    \n    \n    Bug: b/324874908\n    Test: atest CtsAutoFillServiceTestCases\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:141d9d050346bfc4673c429382deb1b3d210f6ad)\n    Merged-In: I51c2e3788ac29ff4d6b86aa2a735ff2ea1463a77\n    Change-Id: I51c2e3788ac29ff4d6b86aa2a735ff2ea1463a77\n\ndiff --git a/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java b/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\nindex 63a607c8d0d4..7be2dea3c2f6 100644\n--- a/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\n+++ b/services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\n@@ -32,8 +32,10 @@ import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.ActivityManagerInternal;\n import android.content.ComponentName;\n+import android.content.Intent;\n import android.content.pm.PackageManager;\n import android.content.pm.PackageManager.NameNotFoundException;\n+import android.content.pm.ResolveInfo;\n import android.content.pm.ServiceInfo;\n import android.graphics.Rect;\n import android.metrics.LogMaker;\n@@ -250,6 +252,31 @@ final class AutofillManagerServiceImpl\n     @Override // from PerUserSystemService\n     protected ServiceInfo newServiceInfoLocked(@NonNull ComponentName serviceComponent)\n             throws NameNotFoundException {\n+        final List<ResolveInfo> resolveInfos =\n+                getContext().getPackageManager().queryIntentServicesAsUser(\n+                    new Intent(AutofillService.SERVICE_INTERFACE),\n+                    // The MATCH_INSTANT flag is added because curret autofill CTS module is\n+                    // defined in one apk, which makes the test autofill service installed in a\n+                    // instant app when the CTS tests are running in instant app mode.\n+                    // TODO: Remove MATCH_INSTANT flag after completing refactoring the CTS module\n+                    //       to make the test autofill service a separate apk.\n+                    PackageManager.GET_META_DATA | PackageManager.MATCH_INSTANT,\n+                    mUserId);\n+        boolean serviceHasAutofillIntentFilter = false;\n+        for (ResolveInfo resolveInfo : resolveInfos) {\n+            final ServiceInfo serviceInfo = resolveInfo.serviceInfo;\n+            if (serviceInfo.getComponentName().equals(serviceComponent)) {\n+                serviceHasAutofillIntentFilter = true;\n+                break;\n+            }\n+        }\n+        if (!serviceHasAutofillIntentFilter) {\n+            Slog.w(TAG,\n+                    \"Autofill service from '\" + serviceComponent.getPackageName() + \"' does\"\n+                            + \"not have intent filter \" + AutofillService.SERVICE_INTERFACE);\n+            throw new SecurityException(\"Service does not declare intent filter \"\n+                            + AutofillService.SERVICE_INTERFACE);\n+        }\n         mInfo = new AutofillServiceInfo(getContext(), serviceComponent, mUserId);\n         return mInfo.getServiceInfo();\n     }\n",
                            "downstream_patch_tokens": {
                                "openai": 869,
                                "general": {
                                    "word_based": 341,
                                    "char_based": 912
                                },
                                "gemini": 1073
                            }
                        }
                    ]
                }
            ],
            "cross_patch_attempts": [
                {
                    "from": "14",
                    "to": "13",
                    "result": "success",
                    "patch_output": "patching file services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\nHunk #2 succeeded at 241 (offset -11 lines)."
                },
                {
                    "from": "14",
                    "to": "12L",
                    "result": "success",
                    "patch_output": "patching file services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\nHunk #1 succeeded at 30 (offset -2 lines).\nHunk #2 succeeded at 238 (offset -14 lines)."
                },
                {
                    "from": "14",
                    "to": "12",
                    "result": "success",
                    "patch_output": "patching file services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\nHunk #1 succeeded at 30 (offset -2 lines).\nHunk #2 succeeded at 238 (offset -14 lines)."
                },
                {
                    "from": "13",
                    "to": "12L",
                    "result": "success",
                    "patch_output": "patching file services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\nHunk #1 succeeded at 30 (offset -2 lines).\nHunk #2 succeeded at 238 (offset -3 lines)."
                },
                {
                    "from": "13",
                    "to": "12",
                    "result": "success",
                    "patch_output": "patching file services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java\nHunk #1 succeeded at 30 (offset -2 lines).\nHunk #2 succeeded at 238 (offset -3 lines)."
                },
                {
                    "from": "12L",
                    "to": "12",
                    "result": "success",
                    "patch_output": "patching file services/autofill/java/com/android/server/autofill/AutofillManagerServiceImpl.java"
                }
            ]
        },
        {
            "id": "ASB-A-326485767",
            "aliases": [
                "A-326485767",
                "CVE-2024-31322"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-326485767",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "74ab528e54558b5a78a9b0f32a2e3f0a61714ae5"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From 74ab528e54558b5a78a9b0f32a2e3f0a61714ae5 Mon Sep 17 00:00:00 2001\nFrom: Ameer Armaly <aarmaly@google.com>\nDate: Tue, 12 Mar 2024 13:45:37 +0000\nSubject: [PATCH] AccessibilityManagerService: remove uninstalled services from\n enabled list after service update.\n\nBug: 326485767\nTest: atest AccessibilityEndToEndTest#testUpdateServiceWithoutIntent_disablesService\nChange-Id: I2d986dc8f09a3cf2f31713237e69e15dcef84514\n---\n .../AccessibilityManagerService.java          | 22 +++++++++++++++++++\n 1 file changed, 22 insertions(+)\n\ndiff --git a/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java b/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\nindex 940379699ee6..a4f998c3ebc1 100644\n--- a/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\n+++ b/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\n@@ -2722,10 +2722,13 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub\n                 userState.mComponentNameToServiceMap;\n         boolean isUnlockingOrUnlocked = mUmi.isUserUnlockingOrUnlocked(userState.mUserId);\n \n+        // Store the list of installed services.\n+        mTempComponentNameSet.clear();\n         for (int i = 0, count = userState.mInstalledServices.size(); i < count; i++) {\n             AccessibilityServiceInfo installedService = userState.mInstalledServices.get(i);\n             ComponentName componentName = ComponentName.unflattenFromString(\n                     installedService.getId());\n+            mTempComponentNameSet.add(componentName);\n \n             AccessibilityServiceConnection service = componentNameToServiceMap.get(componentName);\n \n@@ -2785,6 +2788,25 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub\n             audioManager.setAccessibilityServiceUids(mTempIntArray);\n         }\n         mActivityTaskManagerService.setAccessibilityServiceUids(mTempIntArray);\n+\n+        // If any services have been removed, remove them from the enabled list and the touch\n+        // exploration granted list.\n+        boolean anyServiceRemoved =\n+                userState.mEnabledServices.removeIf((comp) -> !mTempComponentNameSet.contains(comp))\n+                        || userState.mTouchExplorationGrantedServices.removeIf(\n+                                (comp) -> !mTempComponentNameSet.contains(comp));\n+        if (anyServiceRemoved) {\n+            // Update the enabled services setting.\n+            persistComponentNamesToSettingLocked(\n+                    Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,\n+                    userState.mEnabledServices,\n+                    userState.mUserId);\n+            // Update the touch exploration granted services setting.\n+            persistComponentNamesToSettingLocked(\n+                    Settings.Secure.TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,\n+                    userState.mTouchExplorationGrantedServices,\n+                    userState.mUserId);\n+        }\n         updateAccessibilityEnabledSettingLocked(userState);\n     }\n \n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 702,
                        "general": {
                            "word_based": 244,
                            "char_based": 799
                        },
                        "gemini": 868
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "5405514a23edcba0cf30e6ec78189e3f4e7d95cf",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 5405514a23edcba0cf30e6ec78189e3f4e7d95cf\nAuthor: Ameer Armaly <aarmaly@google.com>\nDate:   Fri Mar 8 19:41:06 2024 +0000\n\n    [RESTRICT AUTOMERGE] AccessibilityManagerService: remove uninstalled services from enabled list after service update.\n    \n    Bug: 326485767\n    Test: atest AccessibilityEndToEndTest#testUpdateServiceWithoutIntent_disablesService\n    Change-Id: I5e59296fcad68e62b34c74ee5fd80b6ad6b46fa1\n\ndiff --git a/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java b/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\nindex 0b2a91a4524f..cc9adc772683 100644\n--- a/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\n+++ b/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\n@@ -1906,10 +1906,13 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub\n         boolean isUnlockingOrUnlocked = LocalServices.getService(UserManagerInternal.class)\n                     .isUserUnlockingOrUnlocked(userState.mUserId);\n \n+        // Store the list of installed services.\n+        mTempComponentNameSet.clear();\n         for (int i = 0, count = userState.mInstalledServices.size(); i < count; i++) {\n             AccessibilityServiceInfo installedService = userState.mInstalledServices.get(i);\n             ComponentName componentName = ComponentName.unflattenFromString(\n                     installedService.getId());\n+            mTempComponentNameSet.add(componentName);\n \n             AccessibilityServiceConnection service = componentNameToServiceMap.get(componentName);\n \n@@ -1960,6 +1963,25 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub\n             audioManager.setAccessibilityServiceUids(mTempIntArray);\n         }\n         mActivityTaskManagerService.setAccessibilityServiceUids(mTempIntArray);\n+        // If any services have been removed, remove them from the enabled list and the touch\n+        // exploration granted list.\n+        boolean anyServiceRemoved =\n+                userState.mEnabledServices.removeIf((comp) -> !mTempComponentNameSet.contains(comp))\n+                        || userState.mTouchExplorationGrantedServices.removeIf(\n+                                (comp) -> !mTempComponentNameSet.contains(comp));\n+        if (anyServiceRemoved) {\n+            // Update the enabled services setting.\n+            persistComponentNamesToSettingLocked(\n+                    Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,\n+                    userState.mEnabledServices,\n+                    userState.mUserId);\n+            // Update the touch exploration granted services setting.\n+            persistComponentNamesToSettingLocked(\n+                    Settings.Secure.TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,\n+                    userState.mTouchExplorationGrantedServices,\n+                    userState.mUserId);\n+        }\n+        mTempComponentNameSet.clear();\n         updateAccessibilityEnabledSettingLocked(userState);\n     }\n \n",
                            "downstream_patch_tokens": {
                                "openai": 662,
                                "general": {
                                    "word_based": 226,
                                    "char_based": 778
                                },
                                "gemini": 805
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "412427d7a8c99fd0470483a5a20b50ba8642a1db",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 412427d7a8c99fd0470483a5a20b50ba8642a1db\nAuthor: Ameer Armaly <aarmaly@google.com>\nDate:   Fri Mar 8 19:41:06 2024 +0000\n\n    [RESTRICT AUTOMERGE] AccessibilityManagerService: remove uninstalled services from enabled list after service update.\n    \n    Bug: 326485767\n    Test: atest AccessibilityEndToEndTest#testUpdateServiceWithoutIntent_disablesService\n    Change-Id: I3b778e8f41ace30e09b93a39580993ef5ac52ace\n\ndiff --git a/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java b/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\nindex 05dcea265763..4a28a123c8d1 100644\n--- a/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\n+++ b/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\n@@ -1919,10 +1919,13 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub\n         boolean isUnlockingOrUnlocked = LocalServices.getService(UserManagerInternal.class)\n                     .isUserUnlockingOrUnlocked(userState.mUserId);\n \n+        // Store the list of installed services.\n+        mTempComponentNameSet.clear();\n         for (int i = 0, count = userState.mInstalledServices.size(); i < count; i++) {\n             AccessibilityServiceInfo installedService = userState.mInstalledServices.get(i);\n             ComponentName componentName = ComponentName.unflattenFromString(\n                     installedService.getId());\n+            mTempComponentNameSet.add(componentName);\n \n             AccessibilityServiceConnection service = componentNameToServiceMap.get(componentName);\n \n@@ -1973,6 +1976,25 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub\n             audioManager.setAccessibilityServiceUids(mTempIntArray);\n         }\n         mActivityTaskManagerService.setAccessibilityServiceUids(mTempIntArray);\n+        // If any services have been removed, remove them from the enabled list and the touch\n+        // exploration granted list.\n+        boolean anyServiceRemoved =\n+                userState.mEnabledServices.removeIf((comp) -> !mTempComponentNameSet.contains(comp))\n+                        || userState.mTouchExplorationGrantedServices.removeIf(\n+                                (comp) -> !mTempComponentNameSet.contains(comp));\n+        if (anyServiceRemoved) {\n+            // Update the enabled services setting.\n+            persistComponentNamesToSettingLocked(\n+                    Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,\n+                    userState.mEnabledServices,\n+                    userState.mUserId);\n+            // Update the touch exploration granted services setting.\n+            persistComponentNamesToSettingLocked(\n+                    Settings.Secure.TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,\n+                    userState.mTouchExplorationGrantedServices,\n+                    userState.mUserId);\n+        }\n+        mTempComponentNameSet.clear();\n         updateAccessibilityEnabledSettingLocked(userState);\n     }\n \n",
                            "downstream_patch_tokens": {
                                "openai": 659,
                                "general": {
                                    "word_based": 226,
                                    "char_based": 778
                                },
                                "gemini": 809
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "766911c3312573196b33efd1c3c29ccece806846",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit 766911c3312573196b33efd1c3c29ccece806846\nAuthor: Ameer Armaly <aarmaly@google.com>\nDate:   Fri Mar 8 19:41:06 2024 +0000\n\n    [RESTRICT AUTOMERGE] AccessibilityManagerService: remove uninstalled services from enabled list after service update.\n    \n    Bug: 326485767\n    Test: atest AccessibilityEndToEndTest#testUpdateServiceWithoutIntent_disablesService\n    Change-Id: I958d58953b300c8093335a22e207baac471ae9f9\n\ndiff --git a/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java b/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\nindex 3818a884c94a..8271aed181c9 100644\n--- a/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\n+++ b/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\n@@ -2161,10 +2161,13 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub\n         boolean isUnlockingOrUnlocked = LocalServices.getService(UserManagerInternal.class)\n                     .isUserUnlockingOrUnlocked(userState.mUserId);\n \n+        // Store the list of installed services.\n+        mTempComponentNameSet.clear();\n         for (int i = 0, count = userState.mInstalledServices.size(); i < count; i++) {\n             AccessibilityServiceInfo installedService = userState.mInstalledServices.get(i);\n             ComponentName componentName = ComponentName.unflattenFromString(\n                     installedService.getId());\n+            mTempComponentNameSet.add(componentName);\n \n             AccessibilityServiceConnection service = componentNameToServiceMap.get(componentName);\n \n@@ -2215,6 +2218,25 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub\n             audioManager.setAccessibilityServiceUids(mTempIntArray);\n         }\n         mActivityTaskManagerService.setAccessibilityServiceUids(mTempIntArray);\n+        // If any services have been removed, remove them from the enabled list and the touch\n+        // exploration granted list.\n+        boolean anyServiceRemoved =\n+                userState.mEnabledServices.removeIf((comp) -> !mTempComponentNameSet.contains(comp))\n+                        || userState.mTouchExplorationGrantedServices.removeIf(\n+                                (comp) -> !mTempComponentNameSet.contains(comp));\n+        if (anyServiceRemoved) {\n+            // Update the enabled services setting.\n+            persistComponentNamesToSettingLocked(\n+                    Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,\n+                    userState.mEnabledServices,\n+                    userState.mUserId);\n+            // Update the touch exploration granted services setting.\n+            persistComponentNamesToSettingLocked(\n+                    Settings.Secure.TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,\n+                    userState.mTouchExplorationGrantedServices,\n+                    userState.mUserId);\n+        }\n+        mTempComponentNameSet.clear();\n         updateAccessibilityEnabledSettingLocked(userState);\n     }\n \n",
                            "downstream_patch_tokens": {
                                "openai": 652,
                                "general": {
                                    "word_based": 226,
                                    "char_based": 778
                                },
                                "gemini": 810
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "f6192d3a77520d40b6a93de8f45400e19f5ba29f",
                            "repo_path": "android_repos/base",
                            "result": "success",
                            "downstream_patch_content": "commit f6192d3a77520d40b6a93de8f45400e19f5ba29f\nAuthor: Ameer Armaly <aarmaly@google.com>\nDate:   Fri Mar 8 19:41:06 2024 +0000\n\n    [RESTRICT AUTOMERGE] AccessibilityManagerService: remove uninstalled services from enabled list after service update.\n    \n    Bug: 326485767\n    Test: atest AccessibilityEndToEndTest#testUpdateServiceWithoutIntent_disablesService\n    Change-Id: Ia86857d58ebab925ec6e55f9e5fa64e265326ec0\n\ndiff --git a/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java b/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\nindex 531227947ba0..7bb7c4a81a7d 100644\n--- a/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\n+++ b/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\n@@ -2398,10 +2398,13 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub\n                 userState.mComponentNameToServiceMap;\n         boolean isUnlockingOrUnlocked = mUmi.isUserUnlockingOrUnlocked(userState.mUserId);\n \n+        // Store the list of installed services.\n+        mTempComponentNameSet.clear();\n         for (int i = 0, count = userState.mInstalledServices.size(); i < count; i++) {\n             AccessibilityServiceInfo installedService = userState.mInstalledServices.get(i);\n             ComponentName componentName = ComponentName.unflattenFromString(\n                     installedService.getId());\n+            mTempComponentNameSet.add(componentName);\n \n             AccessibilityServiceConnection service = componentNameToServiceMap.get(componentName);\n \n@@ -2461,6 +2464,25 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub\n             audioManager.setAccessibilityServiceUids(mTempIntArray);\n         }\n         mActivityTaskManagerService.setAccessibilityServiceUids(mTempIntArray);\n+        // If any services have been removed, remove them from the enabled list and the touch\n+        // exploration granted list.\n+        boolean anyServiceRemoved =\n+                userState.mEnabledServices.removeIf((comp) -> !mTempComponentNameSet.contains(comp))\n+                        || userState.mTouchExplorationGrantedServices.removeIf(\n+                                (comp) -> !mTempComponentNameSet.contains(comp));\n+        if (anyServiceRemoved) {\n+            // Update the enabled services setting.\n+            persistComponentNamesToSettingLocked(\n+                    Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,\n+                    userState.mEnabledServices,\n+                    userState.mUserId);\n+            // Update the touch exploration granted services setting.\n+            persistComponentNamesToSettingLocked(\n+                    Settings.Secure.TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,\n+                    userState.mTouchExplorationGrantedServices,\n+                    userState.mUserId);\n+        }\n+        mTempComponentNameSet.clear();\n         updateAccessibilityEnabledSettingLocked(userState);\n     }\n \n",
                            "downstream_patch_tokens": {
                                "openai": 664,
                                "general": {
                                    "word_based": 225,
                                    "char_based": 775
                                },
                                "gemini": 810
                            }
                        }
                    ]
                }
            ],
            "cross_patch_attempts": [
                {
                    "from": "14",
                    "to": "13",
                    "result": "success",
                    "patch_output": "patching file services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\nHunk #1 succeeded at 2161 with fuzz 2 (offset -237 lines).\nHunk #2 succeeded at 2218 (offset -246 lines)."
                },
                {
                    "from": "14",
                    "to": "12L",
                    "result": "success",
                    "patch_output": "patching file services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\nHunk #1 succeeded at 1919 with fuzz 2 (offset -479 lines).\nHunk #2 succeeded at 1976 (offset -488 lines)."
                },
                {
                    "from": "14",
                    "to": "12",
                    "result": "success",
                    "patch_output": "patching file services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\nHunk #1 succeeded at 1906 with fuzz 2 (offset -492 lines).\nHunk #2 succeeded at 1963 (offset -501 lines)."
                },
                {
                    "from": "13",
                    "to": "12L",
                    "result": "success",
                    "patch_output": "patching file services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\nHunk #1 succeeded at 1919 (offset -242 lines).\nHunk #2 succeeded at 1976 (offset -242 lines)."
                },
                {
                    "from": "13",
                    "to": "12",
                    "result": "success",
                    "patch_output": "patching file services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\nHunk #1 succeeded at 1906 (offset -255 lines).\nHunk #2 succeeded at 1963 (offset -255 lines)."
                },
                {
                    "from": "12L",
                    "to": "12",
                    "result": "success",
                    "patch_output": "patching file services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java\nHunk #1 succeeded at 1906 (offset -13 lines).\nHunk #2 succeeded at 1963 (offset -13 lines)."
                }
            ]
        },
        {
            "id": "ASB-A-294406604",
            "aliases": [
                "A-294406604",
                "CVE-2024-34721"
            ],
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-294406604",
            "severity": "High",
            "patch_attempts": [
                {
                    "upstream_commits": [
                        "a296a6520bef303faedbe8b4489f36e0e2b09d16"
                    ],
                    "upstream_branch_used": "main",
                    "upstream_patch_content": "From a296a6520bef303faedbe8b4489f36e0e2b09d16 Mon Sep 17 00:00:00 2001\nFrom: Omar Eissa <oeissa@google.com>\nDate: Mon, 15 Apr 2024 12:04:56 +0000\nSubject: [PATCH] Prevent insertion in other users storage volumes\n\nDon't allow file insertion in other users storage volumes.\nThis was already handled if DATA was explicitly set in content values,\nbut was allowed if DATA was generated based on other values like RELATIVE_PATH and DISPLAY_NAME.\n\nInsertion of files in other users storage volumes can be used by malicious apps\nto get access to other users files, since the same file would exist in both users MP databases\nwhich would lead to MP falsely assuming that the user has access to this file.\n\nBug: 294406604\nTest: atest MediaProviderTests\nChange-Id: Ie219bbdbe28819421040e4c083b65ab47d8ebde6\n---\n .../providers/media/MediaProvider.java        |  1 +\n .../providers/media/MediaProviderTest.java    | 33 +++++++++++++++++--\n 2 files changed, 31 insertions(+), 3 deletions(-)\n\ndiff --git a/src/com/android/providers/media/MediaProvider.java b/src/com/android/providers/media/MediaProvider.java\nindex dd662e58d..f4bb62a53 100644\n--- a/src/com/android/providers/media/MediaProvider.java\n+++ b/src/com/android/providers/media/MediaProvider.java\n@@ -4487,6 +4487,7 @@ public class MediaProvider extends ContentProvider {\n \n             FileUtils.sanitizeValues(values, /*rewriteHiddenFileName*/ !isFuseThread());\n             FileUtils.computeDataFromValues(values, volumePath, isFuseThread());\n+            assertFileColumnsConsistent(match, uri, values);\n \n             // Create result file\n             File res = new File(values.getAsString(MediaColumns.DATA));\ndiff --git a/tests/src/com/android/providers/media/MediaProviderTest.java b/tests/src/com/android/providers/media/MediaProviderTest.java\nindex a8191a17e..819bdfd2f 100644\n--- a/tests/src/com/android/providers/media/MediaProviderTest.java\n+++ b/tests/src/com/android/providers/media/MediaProviderTest.java\n@@ -54,6 +54,7 @@ import android.os.Bundle;\n import android.os.CancellationSignal;\n import android.os.Environment;\n import android.os.UserHandle;\n+import android.os.UserManager;\n import android.provider.MediaStore;\n import android.provider.MediaStore.Audio.AudioColumns;\n import android.provider.MediaStore.Files.FileColumns;\n@@ -77,6 +78,7 @@ import com.android.providers.media.photopicker.data.ItemsProvider;\n import com.android.providers.media.util.FileUtils;\n import com.android.providers.media.util.FileUtilsTest;\n import com.android.providers.media.util.SQLiteQueryBuilder;\n+import com.android.providers.media.util.UserCache;\n \n import org.junit.AfterClass;\n import org.junit.Assert;\n@@ -500,11 +502,36 @@ public class MediaProviderTest {\n     }\n \n     @Test\n-    public void testInsertionWithInvalidFilePath_throwsIllegalArgumentException() {\n+    public void testInsertionWithFilePathOnAnotherUserVolume_throwsIllegalArgumentException() {\n+        final UserCache userCache = new UserCache(sContext);\n+        UserHandle otherUserHandle = sContext.getSystemService(UserManager.class)\n+                .getUserHandles(true).stream()\n+                .filter(uH -> !userCache.getUsersCached().contains(uH))\n+                .findFirst()\n+                .orElse(null);\n+        Assume.assumeNotNull(otherUserHandle);\n+\n         final ContentValues values = new ContentValues();\n-        values.put(MediaStore.MediaColumns.RELATIVE_PATH, \"Android/media/com.example\");\n+        values.put(MediaStore.MediaColumns.RELATIVE_PATH, \"Download\");\n+        final String filePath = \"/storage/emulated/\"\n+                + otherUserHandle.getIdentifier() + \"/Pictures/test.jpg\";\n         values.put(MediaStore.Images.Media.DISPLAY_NAME,\n-                \"./../../../../../../../../../../../data/media/test.txt\");\n+                \"./../../../../../../../../../../../\" + filePath);\n+\n+        IllegalArgumentException illegalArgumentException = Assert.assertThrows(\n+                IllegalArgumentException.class, () -> sIsolatedResolver.insert(\n+                        MediaStore.Files.getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY),\n+                        values));\n+\n+        assertThat(illegalArgumentException).hasMessageThat().contains(\n+                \"Requested path \" + filePath + \" doesn't appear\");\n+    }\n+\n+    @Test\n+    public void testInsertionWithInvalidFilePath_throwsIllegalArgumentException() {\n+        final ContentValues values = new ContentValues();\n+        values.put(MediaStore.MediaColumns.RELATIVE_PATH, \"Android/media/com.example/\");\n+        values.put(MediaStore.Images.Media.DISPLAY_NAME, \"data/media/test.txt\");\n \n         IllegalArgumentException illegalArgumentException = Assert.assertThrows(\n                 IllegalArgumentException.class, () -> sIsolatedResolver.insert(\n-- \n2.39.5 (Apple Git-154)\n\n",
                    "upstream_patch_tokens": {
                        "openai": 1039,
                        "general": {
                            "word_based": 492,
                            "char_based": 1202
                        },
                        "gemini": 1349
                    },
                    "total_downstream_versions_tested": 4,
                    "successful_patches": 4,
                    "failed_patches": 0,
                    "patch_results": [
                        {
                            "downstream_version": "12",
                            "branch_used": "android12-release",
                            "downstream_patch": "df39f8486b25473d0bdbeed896ad917e3c793bf9",
                            "repo_path": "android_repos/MediaProvider",
                            "result": "success",
                            "downstream_patch_content": "commit df39f8486b25473d0bdbeed896ad917e3c793bf9\nAuthor: Omar Eissa <oeissa@google.com>\nDate:   Mon Apr 15 12:04:56 2024 +0000\n\n    Prevent insertion in other users storage volumes\n    \n    Don't allow file insertion in other users storage volumes.\n    This was already handled if DATA was explicitly set in content values,\n    but was allowed if DATA was generated based on other values like RELATIVE_PATH and DISPLAY_NAME.\n    \n    Insertion of files in other users storage volumes can be used by malicious apps\n    to get access to other users files, since the same file would exist in both users MP databases\n    which would lead to MP falsely assuming that the user has access to this file.\n    \n    Bug: 294406604\n    Test: atest MediaProviderTests\n    Merged-In: Ie219bbdbe28819421040e4c083b65ab47d8ebde6\n    Change-Id: Ie219bbdbe28819421040e4c083b65ab47d8ebde6\n\ndiff --git a/src/com/android/providers/media/MediaProvider.java b/src/com/android/providers/media/MediaProvider.java\nindex 31bdf893f..97b6b3015 100644\n--- a/src/com/android/providers/media/MediaProvider.java\n+++ b/src/com/android/providers/media/MediaProvider.java\n@@ -3275,6 +3275,7 @@ public class MediaProvider extends ContentProvider {\n \n             FileUtils.sanitizeValues(values, /*rewriteHiddenFileName*/ !isFuseThread());\n             FileUtils.computeDataFromValues(values, volumePath, isFuseThread());\n+            assertFileColumnsConsistent(match, uri, values);\n \n             // Create result file\n             File res = new File(values.getAsString(MediaColumns.DATA));\ndiff --git a/tests/src/com/android/providers/media/MediaProviderTest.java b/tests/src/com/android/providers/media/MediaProviderTest.java\nindex 11fc327bd..284634772 100644\n--- a/tests/src/com/android/providers/media/MediaProviderTest.java\n+++ b/tests/src/com/android/providers/media/MediaProviderTest.java\n@@ -377,9 +377,8 @@ public class MediaProviderTest {\n     @Test\n     public void testInsertionWithInvalidFilePath_throwsIllegalArgumentException() {\n         final ContentValues values = new ContentValues();\n-        values.put(MediaStore.MediaColumns.RELATIVE_PATH, \"Android/media/com.example\");\n-        values.put(MediaStore.Images.Media.DISPLAY_NAME,\n-                \"./../../../../../../../../../../../data/media/test.txt\");\n+        values.put(MediaStore.MediaColumns.RELATIVE_PATH, \"Android/media/com.example/\");\n+        values.put(MediaStore.Images.Media.DISPLAY_NAME, \"data/media/test.txt\");\n \n         IllegalArgumentException illegalArgumentException = Assert.assertThrows(\n                 IllegalArgumentException.class, () -> sIsolatedResolver.insert(\n",
                            "downstream_patch_tokens": {
                                "openai": 606,
                                "general": {
                                    "word_based": 295,
                                    "char_based": 657
                                },
                                "gemini": 806
                            }
                        },
                        {
                            "downstream_version": "12L",
                            "branch_used": "android12L-release",
                            "downstream_patch": "df39f8486b25473d0bdbeed896ad917e3c793bf9",
                            "repo_path": "android_repos/MediaProvider",
                            "result": "success",
                            "downstream_patch_content": "commit df39f8486b25473d0bdbeed896ad917e3c793bf9\nAuthor: Omar Eissa <oeissa@google.com>\nDate:   Mon Apr 15 12:04:56 2024 +0000\n\n    Prevent insertion in other users storage volumes\n    \n    Don't allow file insertion in other users storage volumes.\n    This was already handled if DATA was explicitly set in content values,\n    but was allowed if DATA was generated based on other values like RELATIVE_PATH and DISPLAY_NAME.\n    \n    Insertion of files in other users storage volumes can be used by malicious apps\n    to get access to other users files, since the same file would exist in both users MP databases\n    which would lead to MP falsely assuming that the user has access to this file.\n    \n    Bug: 294406604\n    Test: atest MediaProviderTests\n    Merged-In: Ie219bbdbe28819421040e4c083b65ab47d8ebde6\n    Change-Id: Ie219bbdbe28819421040e4c083b65ab47d8ebde6\n\ndiff --git a/src/com/android/providers/media/MediaProvider.java b/src/com/android/providers/media/MediaProvider.java\nindex 31bdf893f..97b6b3015 100644\n--- a/src/com/android/providers/media/MediaProvider.java\n+++ b/src/com/android/providers/media/MediaProvider.java\n@@ -3275,6 +3275,7 @@ public class MediaProvider extends ContentProvider {\n \n             FileUtils.sanitizeValues(values, /*rewriteHiddenFileName*/ !isFuseThread());\n             FileUtils.computeDataFromValues(values, volumePath, isFuseThread());\n+            assertFileColumnsConsistent(match, uri, values);\n \n             // Create result file\n             File res = new File(values.getAsString(MediaColumns.DATA));\ndiff --git a/tests/src/com/android/providers/media/MediaProviderTest.java b/tests/src/com/android/providers/media/MediaProviderTest.java\nindex 11fc327bd..284634772 100644\n--- a/tests/src/com/android/providers/media/MediaProviderTest.java\n+++ b/tests/src/com/android/providers/media/MediaProviderTest.java\n@@ -377,9 +377,8 @@ public class MediaProviderTest {\n     @Test\n     public void testInsertionWithInvalidFilePath_throwsIllegalArgumentException() {\n         final ContentValues values = new ContentValues();\n-        values.put(MediaStore.MediaColumns.RELATIVE_PATH, \"Android/media/com.example\");\n-        values.put(MediaStore.Images.Media.DISPLAY_NAME,\n-                \"./../../../../../../../../../../../data/media/test.txt\");\n+        values.put(MediaStore.MediaColumns.RELATIVE_PATH, \"Android/media/com.example/\");\n+        values.put(MediaStore.Images.Media.DISPLAY_NAME, \"data/media/test.txt\");\n \n         IllegalArgumentException illegalArgumentException = Assert.assertThrows(\n                 IllegalArgumentException.class, () -> sIsolatedResolver.insert(\n",
                            "downstream_patch_tokens": {
                                "openai": 606,
                                "general": {
                                    "word_based": 295,
                                    "char_based": 657
                                },
                                "gemini": 806
                            }
                        },
                        {
                            "downstream_version": "13",
                            "branch_used": "android13-release",
                            "downstream_patch": "df39f8486b25473d0bdbeed896ad917e3c793bf9",
                            "repo_path": "android_repos/MediaProvider",
                            "result": "success",
                            "downstream_patch_content": "commit df39f8486b25473d0bdbeed896ad917e3c793bf9\nAuthor: Omar Eissa <oeissa@google.com>\nDate:   Mon Apr 15 12:04:56 2024 +0000\n\n    Prevent insertion in other users storage volumes\n    \n    Don't allow file insertion in other users storage volumes.\n    This was already handled if DATA was explicitly set in content values,\n    but was allowed if DATA was generated based on other values like RELATIVE_PATH and DISPLAY_NAME.\n    \n    Insertion of files in other users storage volumes can be used by malicious apps\n    to get access to other users files, since the same file would exist in both users MP databases\n    which would lead to MP falsely assuming that the user has access to this file.\n    \n    Bug: 294406604\n    Test: atest MediaProviderTests\n    Merged-In: Ie219bbdbe28819421040e4c083b65ab47d8ebde6\n    Change-Id: Ie219bbdbe28819421040e4c083b65ab47d8ebde6\n\ndiff --git a/src/com/android/providers/media/MediaProvider.java b/src/com/android/providers/media/MediaProvider.java\nindex 31bdf893f..97b6b3015 100644\n--- a/src/com/android/providers/media/MediaProvider.java\n+++ b/src/com/android/providers/media/MediaProvider.java\n@@ -3275,6 +3275,7 @@ public class MediaProvider extends ContentProvider {\n \n             FileUtils.sanitizeValues(values, /*rewriteHiddenFileName*/ !isFuseThread());\n             FileUtils.computeDataFromValues(values, volumePath, isFuseThread());\n+            assertFileColumnsConsistent(match, uri, values);\n \n             // Create result file\n             File res = new File(values.getAsString(MediaColumns.DATA));\ndiff --git a/tests/src/com/android/providers/media/MediaProviderTest.java b/tests/src/com/android/providers/media/MediaProviderTest.java\nindex 11fc327bd..284634772 100644\n--- a/tests/src/com/android/providers/media/MediaProviderTest.java\n+++ b/tests/src/com/android/providers/media/MediaProviderTest.java\n@@ -377,9 +377,8 @@ public class MediaProviderTest {\n     @Test\n     public void testInsertionWithInvalidFilePath_throwsIllegalArgumentException() {\n         final ContentValues values = new ContentValues();\n-        values.put(MediaStore.MediaColumns.RELATIVE_PATH, \"Android/media/com.example\");\n-        values.put(MediaStore.Images.Media.DISPLAY_NAME,\n-                \"./../../../../../../../../../../../data/media/test.txt\");\n+        values.put(MediaStore.MediaColumns.RELATIVE_PATH, \"Android/media/com.example/\");\n+        values.put(MediaStore.Images.Media.DISPLAY_NAME, \"data/media/test.txt\");\n \n         IllegalArgumentException illegalArgumentException = Assert.assertThrows(\n                 IllegalArgumentException.class, () -> sIsolatedResolver.insert(\n",
                            "downstream_patch_tokens": {
                                "openai": 606,
                                "general": {
                                    "word_based": 295,
                                    "char_based": 657
                                },
                                "gemini": 806
                            }
                        },
                        {
                            "downstream_version": "14",
                            "branch_used": "android14-release",
                            "downstream_patch": "df39f8486b25473d0bdbeed896ad917e3c793bf9",
                            "repo_path": "android_repos/MediaProvider",
                            "result": "success",
                            "downstream_patch_content": "commit df39f8486b25473d0bdbeed896ad917e3c793bf9\nAuthor: Omar Eissa <oeissa@google.com>\nDate:   Mon Apr 15 12:04:56 2024 +0000\n\n    Prevent insertion in other users storage volumes\n    \n    Don't allow file insertion in other users storage volumes.\n    This was already handled if DATA was explicitly set in content values,\n    but was allowed if DATA was generated based on other values like RELATIVE_PATH and DISPLAY_NAME.\n    \n    Insertion of files in other users storage volumes can be used by malicious apps\n    to get access to other users files, since the same file would exist in both users MP databases\n    which would lead to MP falsely assuming that the user has access to this file.\n    \n    Bug: 294406604\n    Test: atest MediaProviderTests\n    Merged-In: Ie219bbdbe28819421040e4c083b65ab47d8ebde6\n    Change-Id: Ie219bbdbe28819421040e4c083b65ab47d8ebde6\n\ndiff --git a/src/com/android/providers/media/MediaProvider.java b/src/com/android/providers/media/MediaProvider.java\nindex 31bdf893f..97b6b3015 100644\n--- a/src/com/android/providers/media/MediaProvider.java\n+++ b/src/com/android/providers/media/MediaProvider.java\n@@ -3275,6 +3275,7 @@ public class MediaProvider extends ContentProvider {\n \n             FileUtils.sanitizeValues(values, /*rewriteHiddenFileName*/ !isFuseThread());\n             FileUtils.computeDataFromValues(values, volumePath, isFuseThread());\n+            assertFileColumnsConsistent(match, uri, values);\n \n             // Create result file\n             File res = new File(values.getAsString(MediaColumns.DATA));\ndiff --git a/tests/src/com/android/providers/media/MediaProviderTest.java b/tests/src/com/android/providers/media/MediaProviderTest.java\nindex 11fc327bd..284634772 100644\n--- a/tests/src/com/android/providers/media/MediaProviderTest.java\n+++ b/tests/src/com/android/providers/media/MediaProviderTest.java\n@@ -377,9 +377,8 @@ public class MediaProviderTest {\n     @Test\n     public void testInsertionWithInvalidFilePath_throwsIllegalArgumentException() {\n         final ContentValues values = new ContentValues();\n-        values.put(MediaStore.MediaColumns.RELATIVE_PATH, \"Android/media/com.example\");\n-        values.put(MediaStore.Images.Media.DISPLAY_NAME,\n-                \"./../../../../../../../../../../../data/media/test.txt\");\n+        values.put(MediaStore.MediaColumns.RELATIVE_PATH, \"Android/media/com.example/\");\n+        values.put(MediaStore.Images.Media.DISPLAY_NAME, \"data/media/test.txt\");\n \n         IllegalArgumentException illegalArgumentException = Assert.assertThrows(\n                 IllegalArgumentException.class, () -> sIsolatedResolver.insert(\n",
                            "downstream_patch_tokens": {
                                "openai": 606,
                                "general": {
                                    "word_based": 295,
                                    "char_based": 657
                                },
                                "gemini": 806
                            }
                        }
                    ]
                }
            ],
            "cross_patch_attempts": [
                {
                    "from": "14",
                    "to": "13",
                    "result": "success",
                    "patch_output": "patching file src/com/android/providers/media/MediaProvider.java\npatching file tests/src/com/android/providers/media/MediaProviderTest.java"
                },
                {
                    "from": "14",
                    "to": "12L",
                    "result": "success",
                    "patch_output": "patching file src/com/android/providers/media/MediaProvider.java\npatching file tests/src/com/android/providers/media/MediaProviderTest.java"
                },
                {
                    "from": "14",
                    "to": "12",
                    "result": "success",
                    "patch_output": "patching file src/com/android/providers/media/MediaProvider.java\npatching file tests/src/com/android/providers/media/MediaProviderTest.java"
                },
                {
                    "from": "13",
                    "to": "12L",
                    "result": "success",
                    "patch_output": "patching file src/com/android/providers/media/MediaProvider.java\npatching file tests/src/com/android/providers/media/MediaProviderTest.java"
                },
                {
                    "from": "13",
                    "to": "12",
                    "result": "success",
                    "patch_output": "patching file src/com/android/providers/media/MediaProvider.java\npatching file tests/src/com/android/providers/media/MediaProviderTest.java"
                },
                {
                    "from": "12L",
                    "to": "12",
                    "result": "success",
                    "patch_output": "patching file src/com/android/providers/media/MediaProvider.java\npatching file tests/src/com/android/providers/media/MediaProviderTest.java"
                }
            ]
        }
    ],
    "vulnerabilities_skipped": [
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-326057017",
            "skipped": true,
            "error": "No upstream fixes found"
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-344620577",
            "skipped": true,
            "error": "Filtered patch is empty"
        }
    ],
    "commit_mismatch_vulnerabilities": [
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-313425281",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-313425281",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                }
            ],
            "matched_versions": []
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-279428283",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-279428283",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "12",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12L",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                }
            ],
            "matched_versions": []
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-284297452",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-284297452",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "12",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12L",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                }
            ],
            "matched_versions": []
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-294609150",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-294609150",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "11",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12L",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                }
            ],
            "matched_versions": []
        },
        {
            "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-297517712",
            "skipped": true,
            "commit_mismatch": true,
            "id": "ASB-A-297517712",
            "severity": "High",
            "mismatch_versions": [
                {
                    "downstream_version": "12",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "12L",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "13",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                },
                {
                    "downstream_version": "14",
                    "upstream_commit_count": 2,
                    "downstream_commit_count": 1
                }
            ],
            "matched_versions": []
        }
    ]
}