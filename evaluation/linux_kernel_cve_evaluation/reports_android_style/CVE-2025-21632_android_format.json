{
  "cve_id": "CVE-2025-21632",
  "upstream_commit": "5cc2db37124bb33914996d6fdbb2ddb3811f2945",
  "upstream_patch_content": "From a9d9c33132d49329ada647e4514d210d15e31d81 Mon Sep 17 00:00:00 2001\nFrom: Rick Edgecombe <rick.p.edgecombe@intel.com>\nDate: Tue, 7 Jan 2025 15:30:56 -0800\nSubject: [PATCH] x86/fpu: Ensure shadow stack is active before \"getting\"\n registers\n\nThe x86 shadow stack support has its own set of registers. Those registers\nare XSAVE-managed, but they are \"supervisor state components\" which means\nthat userspace can not touch them with XSAVE/XRSTOR.  It also means that\nthey are not accessible from the existing ptrace ABI for XSAVE state.\nThus, there is a new ptrace get/set interface for it.\n\nThe regset code that ptrace uses provides an ->active() handler in\naddition to the get/set ones. For shadow stack this ->active() handler\nverifies that shadow stack is enabled via the ARCH_SHSTK_SHSTK bit in the\nthread struct. The ->active() handler is checked from some call sites of\nthe regset get/set handlers, but not the ptrace ones. This was not\nunderstood when shadow stack support was put in place.\n\nAs a result, both the set/get handlers can be called with\nXFEATURE_CET_USER in its init state, which would cause get_xsave_addr() to\nreturn NULL and trigger a WARN_ON(). The ssp_set() handler luckily has an\nssp_active() check to avoid surprising the kernel with shadow stack\nbehavior when the kernel is not ready for it (ARCH_SHSTK_SHSTK==0). That\ncheck just happened to avoid the warning.\n\nBut the ->get() side wasn't so lucky. It can be called with shadow stacks\ndisabled, triggering the warning in practice, as reported by Christina\nSchimpe:\n\nWARNING: CPU: 5 PID: 1773 at arch/x86/kernel/fpu/regset.c:198 ssp_get+0x89/0xa0\n[...]\nCall Trace:\n<TASK>\n? show_regs+0x6e/0x80\n? ssp_get+0x89/0xa0\n? __warn+0x91/0x150\n? ssp_get+0x89/0xa0\n? report_bug+0x19d/0x1b0\n? handle_bug+0x46/0x80\n? exc_invalid_op+0x1d/0x80\n? asm_exc_invalid_op+0x1f/0x30\n? __pfx_ssp_get+0x10/0x10\n? ssp_get+0x89/0xa0\n? ssp_get+0x52/0xa0\n__regset_get+0xad/0xf0\ncopy_regset_to_user+0x52/0xc0\nptrace_regset+0x119/0x140\nptrace_request+0x13c/0x850\n? wait_task_inactive+0x142/0x1d0\n? do_syscall_64+0x6d/0x90\narch_ptrace+0x102/0x300\n[...]\n\nEnsure that shadow stacks are active in a thread before looking them up\nin the XSAVE buffer. Since ARCH_SHSTK_SHSTK and user_ssp[SHSTK_EN] are\nset at the same time, the active check ensures that there will be\nsomething to find in the XSAVE buffer.\n\n[ dhansen: changelog/subject tweaks ]\n\nFixes: 2fab02b25ae7 (\"x86: Add PTRACE interface for shadow stack\")\nReported-by: Christina Schimpe <christina.schimpe@intel.com>\nSigned-off-by: Rick Edgecombe <rick.p.edgecombe@intel.com>\nSigned-off-by: Dave Hansen <dave.hansen@linux.intel.com>\nTested-by: Christina Schimpe <christina.schimpe@intel.com>\nCc:stable@vger.kernel.org\nLink: https://lore.kernel.org/all/20250107233056.235536-1-rick.p.edgecombe%40intel.com\n---\n arch/x86/kernel/fpu/regset.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\ndiff --git a/arch/x86/kernel/fpu/regset.c b/arch/x86/kernel/fpu/regset.c\nindex 6bc1eb2a21bd..887b0b8e21e3 100644\n--- a/arch/x86/kernel/fpu/regset.c\n+++ b/arch/x86/kernel/fpu/regset.c\n@@ -190,7 +190,8 @@ int ssp_get(struct task_struct *target, const struct user_regset *regset,\n \tstruct fpu *fpu = &target->thread.fpu;\n \tstruct cet_user_state *cetregs;\n \n-\tif (!cpu_feature_enabled(X86_FEATURE_USER_SHSTK))\n+\tif (!cpu_feature_enabled(X86_FEATURE_USER_SHSTK) ||\n+\t    !ssp_active(target, regset))\n \t\treturn -ENODEV;\n \n \tsync_fpstate(fpu);\n-- \n2.39.5 (Apple Git-154)\n\n",
  "successes": [
    {
      "downstream_version": "0c50f00cc29948184af05bda31392fff5821f4f3",
      "downstream_patch": "0a3a872214188e4268d31581ed0cd44508e038cf",
      "commit_date": "2025-01-17 13:36:21 +0100",
      "result": "success",
      "downstream_patch_content": "commit 0a3a872214188e4268d31581ed0cd44508e038cf\nAuthor: Rick Edgecombe <rick.p.edgecombe@intel.com>\nDate:   Tue Jan 7 15:30:56 2025 -0800\n\n    x86/fpu: Ensure shadow stack is active before \"getting\" registers\n    \n    commit a9d9c33132d49329ada647e4514d210d15e31d81 upstream.\n    \n    The x86 shadow stack support has its own set of registers. Those registers\n    are XSAVE-managed, but they are \"supervisor state components\" which means\n    that userspace can not touch them with XSAVE/XRSTOR.  It also means that\n    they are not accessible from the existing ptrace ABI for XSAVE state.\n    Thus, there is a new ptrace get/set interface for it.\n    \n    The regset code that ptrace uses provides an ->active() handler in\n    addition to the get/set ones. For shadow stack this ->active() handler\n    verifies that shadow stack is enabled via the ARCH_SHSTK_SHSTK bit in the\n    thread struct. The ->active() handler is checked from some call sites of\n    the regset get/set handlers, but not the ptrace ones. This was not\n    understood when shadow stack support was put in place.\n    \n    As a result, both the set/get handlers can be called with\n    XFEATURE_CET_USER in its init state, which would cause get_xsave_addr() to\n    return NULL and trigger a WARN_ON(). The ssp_set() handler luckily has an\n    ssp_active() check to avoid surprising the kernel with shadow stack\n    behavior when the kernel is not ready for it (ARCH_SHSTK_SHSTK==0). That\n    check just happened to avoid the warning.\n    \n    But the ->get() side wasn't so lucky. It can be called with shadow stacks\n    disabled, triggering the warning in practice, as reported by Christina\n    Schimpe:\n    \n    WARNING: CPU: 5 PID: 1773 at arch/x86/kernel/fpu/regset.c:198 ssp_get+0x89/0xa0\n    [...]\n    Call Trace:\n    <TASK>\n    ? show_regs+0x6e/0x80\n    ? ssp_get+0x89/0xa0\n    ? __warn+0x91/0x150\n    ? ssp_get+0x89/0xa0\n    ? report_bug+0x19d/0x1b0\n    ? handle_bug+0x46/0x80\n    ? exc_invalid_op+0x1d/0x80\n    ? asm_exc_invalid_op+0x1f/0x30\n    ? __pfx_ssp_get+0x10/0x10\n    ? ssp_get+0x89/0xa0\n    ? ssp_get+0x52/0xa0\n    __regset_get+0xad/0xf0\n    copy_regset_to_user+0x52/0xc0\n    ptrace_regset+0x119/0x140\n    ptrace_request+0x13c/0x850\n    ? wait_task_inactive+0x142/0x1d0\n    ? do_syscall_64+0x6d/0x90\n    arch_ptrace+0x102/0x300\n    [...]\n    \n    Ensure that shadow stacks are active in a thread before looking them up\n    in the XSAVE buffer. Since ARCH_SHSTK_SHSTK and user_ssp[SHSTK_EN] are\n    set at the same time, the active check ensures that there will be\n    something to find in the XSAVE buffer.\n    \n    [ dhansen: changelog/subject tweaks ]\n    \n    Fixes: 2fab02b25ae7 (\"x86: Add PTRACE interface for shadow stack\")\n    Reported-by: Christina Schimpe <christina.schimpe@intel.com>\n    Signed-off-by: Rick Edgecombe <rick.p.edgecombe@intel.com>\n    Signed-off-by: Dave Hansen <dave.hansen@linux.intel.com>\n    Tested-by: Christina Schimpe <christina.schimpe@intel.com>\n    Cc:stable@vger.kernel.org\n    Link: https://lore.kernel.org/all/20250107233056.235536-1-rick.p.edgecombe%40intel.com\n    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n\ndiff --git a/arch/x86/kernel/fpu/regset.c b/arch/x86/kernel/fpu/regset.c\nindex 6bc1eb2a21bd..887b0b8e21e3 100644\n--- a/arch/x86/kernel/fpu/regset.c\n+++ b/arch/x86/kernel/fpu/regset.c\n@@ -190,7 +190,8 @@ int ssp_get(struct task_struct *target, const struct user_regset *regset,\n \tstruct fpu *fpu = &target->thread.fpu;\n \tstruct cet_user_state *cetregs;\n \n-\tif (!cpu_feature_enabled(X86_FEATURE_USER_SHSTK))\n+\tif (!cpu_feature_enabled(X86_FEATURE_USER_SHSTK) ||\n+\t    !ssp_active(target, regset))\n \t\treturn -ENODEV;\n \n \tsync_fpstate(fpu);\n"
    },
    {
      "downstream_version": "8e122d780a0f19aefd700dbd0b0e3ed3af0ae97f",
      "downstream_patch": "6bfe1fc22f462bec87422cdcbec4d7a2f43ff01d",
      "commit_date": "2025-01-17 13:40:54 +0100",
      "result": "success",
      "downstream_patch_content": "commit 6bfe1fc22f462bec87422cdcbec4d7a2f43ff01d\nAuthor: Rick Edgecombe <rick.p.edgecombe@intel.com>\nDate:   Tue Jan 7 15:30:56 2025 -0800\n\n    x86/fpu: Ensure shadow stack is active before \"getting\" registers\n    \n    commit a9d9c33132d49329ada647e4514d210d15e31d81 upstream.\n    \n    The x86 shadow stack support has its own set of registers. Those registers\n    are XSAVE-managed, but they are \"supervisor state components\" which means\n    that userspace can not touch them with XSAVE/XRSTOR.  It also means that\n    they are not accessible from the existing ptrace ABI for XSAVE state.\n    Thus, there is a new ptrace get/set interface for it.\n    \n    The regset code that ptrace uses provides an ->active() handler in\n    addition to the get/set ones. For shadow stack this ->active() handler\n    verifies that shadow stack is enabled via the ARCH_SHSTK_SHSTK bit in the\n    thread struct. The ->active() handler is checked from some call sites of\n    the regset get/set handlers, but not the ptrace ones. This was not\n    understood when shadow stack support was put in place.\n    \n    As a result, both the set/get handlers can be called with\n    XFEATURE_CET_USER in its init state, which would cause get_xsave_addr() to\n    return NULL and trigger a WARN_ON(). The ssp_set() handler luckily has an\n    ssp_active() check to avoid surprising the kernel with shadow stack\n    behavior when the kernel is not ready for it (ARCH_SHSTK_SHSTK==0). That\n    check just happened to avoid the warning.\n    \n    But the ->get() side wasn't so lucky. It can be called with shadow stacks\n    disabled, triggering the warning in practice, as reported by Christina\n    Schimpe:\n    \n    WARNING: CPU: 5 PID: 1773 at arch/x86/kernel/fpu/regset.c:198 ssp_get+0x89/0xa0\n    [...]\n    Call Trace:\n    <TASK>\n    ? show_regs+0x6e/0x80\n    ? ssp_get+0x89/0xa0\n    ? __warn+0x91/0x150\n    ? ssp_get+0x89/0xa0\n    ? report_bug+0x19d/0x1b0\n    ? handle_bug+0x46/0x80\n    ? exc_invalid_op+0x1d/0x80\n    ? asm_exc_invalid_op+0x1f/0x30\n    ? __pfx_ssp_get+0x10/0x10\n    ? ssp_get+0x89/0xa0\n    ? ssp_get+0x52/0xa0\n    __regset_get+0xad/0xf0\n    copy_regset_to_user+0x52/0xc0\n    ptrace_regset+0x119/0x140\n    ptrace_request+0x13c/0x850\n    ? wait_task_inactive+0x142/0x1d0\n    ? do_syscall_64+0x6d/0x90\n    arch_ptrace+0x102/0x300\n    [...]\n    \n    Ensure that shadow stacks are active in a thread before looking them up\n    in the XSAVE buffer. Since ARCH_SHSTK_SHSTK and user_ssp[SHSTK_EN] are\n    set at the same time, the active check ensures that there will be\n    something to find in the XSAVE buffer.\n    \n    [ dhansen: changelog/subject tweaks ]\n    \n    Fixes: 2fab02b25ae7 (\"x86: Add PTRACE interface for shadow stack\")\n    Reported-by: Christina Schimpe <christina.schimpe@intel.com>\n    Signed-off-by: Rick Edgecombe <rick.p.edgecombe@intel.com>\n    Signed-off-by: Dave Hansen <dave.hansen@linux.intel.com>\n    Tested-by: Christina Schimpe <christina.schimpe@intel.com>\n    Cc:stable@vger.kernel.org\n    Link: https://lore.kernel.org/all/20250107233056.235536-1-rick.p.edgecombe%40intel.com\n    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n\ndiff --git a/arch/x86/kernel/fpu/regset.c b/arch/x86/kernel/fpu/regset.c\nindex 6bc1eb2a21bd..887b0b8e21e3 100644\n--- a/arch/x86/kernel/fpu/regset.c\n+++ b/arch/x86/kernel/fpu/regset.c\n@@ -190,7 +190,8 @@ int ssp_get(struct task_struct *target, const struct user_regset *regset,\n \tstruct fpu *fpu = &target->thread.fpu;\n \tstruct cet_user_state *cetregs;\n \n-\tif (!cpu_feature_enabled(X86_FEATURE_USER_SHSTK))\n+\tif (!cpu_feature_enabled(X86_FEATURE_USER_SHSTK) ||\n+\t    !ssp_active(target, regset))\n \t\treturn -ENODEV;\n \n \tsync_fpstate(fpu);\n"
    }
  ],
  "failures": []
}