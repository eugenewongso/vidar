{
  "cve_id": "CVE-2025-21634",
  "upstream_commit": "9b496a8bbed9cc292b0dfd796f38ec58b6d0375f",
  "upstream_patch_content": "From 3cb97a927fffe443e1e7e8eddbfebfdb062e86ed Mon Sep 17 00:00:00 2001\nFrom: Chen Ridong <chenridong@huawei.com>\nDate: Mon, 6 Jan 2025 08:19:04 +0000\nSubject: [PATCH] cgroup/cpuset: remove kernfs active break\n\nA warning was found:\n\nWARNING: CPU: 10 PID: 3486953 at fs/kernfs/file.c:828\nCPU: 10 PID: 3486953 Comm: rmdir Kdump: loaded Tainted: G\nRIP: 0010:kernfs_should_drain_open_files+0x1a1/0x1b0\nRSP: 0018:ffff8881107ef9e0 EFLAGS: 00010202\nRAX: 0000000080000002 RBX: ffff888154738c00 RCX: dffffc0000000000\nRDX: 0000000000000007 RSI: 0000000000000004 RDI: ffff888154738c04\nRBP: ffff888154738c04 R08: ffffffffaf27fa15 R09: ffffed102a8e7180\nR10: ffff888154738c07 R11: 0000000000000000 R12: ffff888154738c08\nR13: ffff888750f8c000 R14: ffff888750f8c0e8 R15: ffff888154738ca0\nFS:  00007f84cd0be740(0000) GS:ffff8887ddc00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000555f9fbe00c8 CR3: 0000000153eec001 CR4: 0000000000370ee0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n kernfs_drain+0x15e/0x2f0\n __kernfs_remove+0x165/0x300\n kernfs_remove_by_name_ns+0x7b/0xc0\n cgroup_rm_file+0x154/0x1c0\n cgroup_addrm_files+0x1c2/0x1f0\n css_clear_dir+0x77/0x110\n kill_css+0x4c/0x1b0\n cgroup_destroy_locked+0x194/0x380\n cgroup_rmdir+0x2a/0x140\n\nIt can be explained by:\nrmdir \t\t\t\techo 1 > cpuset.cpus\n\t\t\t\tkernfs_fop_write_iter // active=0\ncgroup_rm_file\nkernfs_remove_by_name_ns\tkernfs_get_active // active=1\n__kernfs_remove\t\t\t\t\t  // active=0x80000002\nkernfs_drain\t\t\tcpuset_write_resmask\nwait_event\n//waiting (active == 0x80000001)\n\t\t\t\tkernfs_break_active_protection\n\t\t\t\t// active = 0x80000001\n// continue\n\t\t\t\tkernfs_unbreak_active_protection\n\t\t\t\t// active = 0x80000002\n...\nkernfs_should_drain_open_files\n// warning occurs\n\t\t\t\tkernfs_put_active\n\nThis warning is caused by 'kernfs_break_active_protection' when it is\nwriting to cpuset.cpus, and the cgroup is removed concurrently.\n\nThe commit 3a5a6d0c2b03 (\"cpuset: don't nest cgroup_mutex inside\nget_online_cpus()\") made cpuset_hotplug_workfn asynchronous, This change\ninvolves calling flush_work(), which can create a multiple processes\ncircular locking dependency that involve cgroup_mutex, potentially leading\nto a deadlock. To avoid deadlock. the commit 76bb5ab8f6e3 (\"cpuset: break\nkernfs active protection in cpuset_write_resmask()\") added\n'kernfs_break_active_protection' in the cpuset_write_resmask. This could\nlead to this warning.\n\nAfter the commit 2125c0034c5d (\"cgroup/cpuset: Make cpuset hotplug\nprocessing synchronous\"), the cpuset_write_resmask no longer needs to\nwait the hotplug to finish, which means that concurrent hotplug and cpuset\noperations are no longer possible. Therefore, the deadlock doesn't exist\nanymore and it does not have to 'break active protection' now. To fix this\nwarning, just remove kernfs_break_active_protection operation in the\n'cpuset_write_resmask'.\n\nFixes: bdb2fd7fc56e (\"kernfs: Skip kernfs_drain_open_files() more aggressively\")\nFixes: 76bb5ab8f6e3 (\"cpuset: break kernfs active protection in cpuset_write_resmask()\")\nReported-by: Ji Fa <jifa@huawei.com>\nSigned-off-by: Chen Ridong <chenridong@huawei.com>\nAcked-by: Waiman Long <longman@redhat.com>\nSigned-off-by: Tejun Heo <tj@kernel.org>\n---\n kernel/cgroup/cpuset.c | 25 -------------------------\n 1 file changed, 25 deletions(-)\n\ndiff --git a/kernel/cgroup/cpuset.c b/kernel/cgroup/cpuset.c\nindex 7ea559fb0cbf..0f910c828973 100644\n--- a/kernel/cgroup/cpuset.c\n+++ b/kernel/cgroup/cpuset.c\n@@ -3124,29 +3124,6 @@ ssize_t cpuset_write_resmask(struct kernfs_open_file *of,\n \tint retval = -ENODEV;\n \n \tbuf = strstrip(buf);\n-\n-\t/*\n-\t * CPU or memory hotunplug may leave @cs w/o any execution\n-\t * resources, in which case the hotplug code asynchronously updates\n-\t * configuration and transfers all tasks to the nearest ancestor\n-\t * which can execute.\n-\t *\n-\t * As writes to \"cpus\" or \"mems\" may restore @cs's execution\n-\t * resources, wait for the previously scheduled operations before\n-\t * proceeding, so that we don't end up keep removing tasks added\n-\t * after execution capability is restored.\n-\t *\n-\t * cpuset_handle_hotplug may call back into cgroup core asynchronously\n-\t * via cgroup_transfer_tasks() and waiting for it from a cgroupfs\n-\t * operation like this one can lead to a deadlock through kernfs\n-\t * active_ref protection.  Let's break the protection.  Losing the\n-\t * protection is okay as we check whether @cs is online after\n-\t * grabbing cpuset_mutex anyway.  This only happens on the legacy\n-\t * hierarchies.\n-\t */\n-\tcss_get(&cs->css);\n-\tkernfs_break_active_protection(of->kn);\n-\n \tcpus_read_lock();\n \tmutex_lock(&cpuset_mutex);\n \tif (!is_cpuset_online(cs))\n@@ -3179,8 +3156,6 @@ ssize_t cpuset_write_resmask(struct kernfs_open_file *of,\n out_unlock:\n \tmutex_unlock(&cpuset_mutex);\n \tcpus_read_unlock();\n-\tkernfs_unbreak_active_protection(of->kn);\n-\tcss_put(&cs->css);\n \tflush_workqueue(cpuset_migrate_mm_wq);\n \treturn retval ?: nbytes;\n }\n-- \n2.39.5 (Apple Git-154)\n\n",
  "successes": [
    {
      "downstream_version": "e7960da6f2f438d907c17d463364dae6d242f775",
      "downstream_patch": "11cb1d643a74665a4e14749414f48f82cbc15c64",
      "commit_date": "2025-01-17 13:40:49 +0100",
      "result": "success",
      "downstream_patch_content": "commit 11cb1d643a74665a4e14749414f48f82cbc15c64\nAuthor: Chen Ridong <chenridong@huawei.com>\nDate:   Mon Jan 6 08:19:04 2025 +0000\n\n    cgroup/cpuset: remove kernfs active break\n    \n    [ Upstream commit 3cb97a927fffe443e1e7e8eddbfebfdb062e86ed ]\n    \n    A warning was found:\n    \n    WARNING: CPU: 10 PID: 3486953 at fs/kernfs/file.c:828\n    CPU: 10 PID: 3486953 Comm: rmdir Kdump: loaded Tainted: G\n    RIP: 0010:kernfs_should_drain_open_files+0x1a1/0x1b0\n    RSP: 0018:ffff8881107ef9e0 EFLAGS: 00010202\n    RAX: 0000000080000002 RBX: ffff888154738c00 RCX: dffffc0000000000\n    RDX: 0000000000000007 RSI: 0000000000000004 RDI: ffff888154738c04\n    RBP: ffff888154738c04 R08: ffffffffaf27fa15 R09: ffffed102a8e7180\n    R10: ffff888154738c07 R11: 0000000000000000 R12: ffff888154738c08\n    R13: ffff888750f8c000 R14: ffff888750f8c0e8 R15: ffff888154738ca0\n    FS:  00007f84cd0be740(0000) GS:ffff8887ddc00000(0000) knlGS:0000000000000000\n    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n    CR2: 0000555f9fbe00c8 CR3: 0000000153eec001 CR4: 0000000000370ee0\n    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n    DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n    Call Trace:\n     kernfs_drain+0x15e/0x2f0\n     __kernfs_remove+0x165/0x300\n     kernfs_remove_by_name_ns+0x7b/0xc0\n     cgroup_rm_file+0x154/0x1c0\n     cgroup_addrm_files+0x1c2/0x1f0\n     css_clear_dir+0x77/0x110\n     kill_css+0x4c/0x1b0\n     cgroup_destroy_locked+0x194/0x380\n     cgroup_rmdir+0x2a/0x140\n    \n    It can be explained by:\n    rmdir                           echo 1 > cpuset.cpus\n                                    kernfs_fop_write_iter // active=0\n    cgroup_rm_file\n    kernfs_remove_by_name_ns        kernfs_get_active // active=1\n    __kernfs_remove                                   // active=0x80000002\n    kernfs_drain                    cpuset_write_resmask\n    wait_event\n    //waiting (active == 0x80000001)\n                                    kernfs_break_active_protection\n                                    // active = 0x80000001\n    // continue\n                                    kernfs_unbreak_active_protection\n                                    // active = 0x80000002\n    ...\n    kernfs_should_drain_open_files\n    // warning occurs\n                                    kernfs_put_active\n    \n    This warning is caused by 'kernfs_break_active_protection' when it is\n    writing to cpuset.cpus, and the cgroup is removed concurrently.\n    \n    The commit 3a5a6d0c2b03 (\"cpuset: don't nest cgroup_mutex inside\n    get_online_cpus()\") made cpuset_hotplug_workfn asynchronous, This change\n    involves calling flush_work(), which can create a multiple processes\n    circular locking dependency that involve cgroup_mutex, potentially leading\n    to a deadlock. To avoid deadlock. the commit 76bb5ab8f6e3 (\"cpuset: break\n    kernfs active protection in cpuset_write_resmask()\") added\n    'kernfs_break_active_protection' in the cpuset_write_resmask. This could\n    lead to this warning.\n    \n    After the commit 2125c0034c5d (\"cgroup/cpuset: Make cpuset hotplug\n    processing synchronous\"), the cpuset_write_resmask no longer needs to\n    wait the hotplug to finish, which means that concurrent hotplug and cpuset\n    operations are no longer possible. Therefore, the deadlock doesn't exist\n    anymore and it does not have to 'break active protection' now. To fix this\n    warning, just remove kernfs_break_active_protection operation in the\n    'cpuset_write_resmask'.\n    \n    Fixes: bdb2fd7fc56e (\"kernfs: Skip kernfs_drain_open_files() more aggressively\")\n    Fixes: 76bb5ab8f6e3 (\"cpuset: break kernfs active protection in cpuset_write_resmask()\")\n    Reported-by: Ji Fa <jifa@huawei.com>\n    Signed-off-by: Chen Ridong <chenridong@huawei.com>\n    Acked-by: Waiman Long <longman@redhat.com>\n    Signed-off-by: Tejun Heo <tj@kernel.org>\n    Signed-off-by: Sasha Levin <sashal@kernel.org>\n\ndiff --git a/kernel/cgroup/cpuset.c b/kernel/cgroup/cpuset.c\nindex c431c50512bd..24ece85fd3b1 100644\n--- a/kernel/cgroup/cpuset.c\n+++ b/kernel/cgroup/cpuset.c\n@@ -3110,29 +3110,6 @@ ssize_t cpuset_write_resmask(struct kernfs_open_file *of,\n \tint retval = -ENODEV;\n \n \tbuf = strstrip(buf);\n-\n-\t/*\n-\t * CPU or memory hotunplug may leave @cs w/o any execution\n-\t * resources, in which case the hotplug code asynchronously updates\n-\t * configuration and transfers all tasks to the nearest ancestor\n-\t * which can execute.\n-\t *\n-\t * As writes to \"cpus\" or \"mems\" may restore @cs's execution\n-\t * resources, wait for the previously scheduled operations before\n-\t * proceeding, so that we don't end up keep removing tasks added\n-\t * after execution capability is restored.\n-\t *\n-\t * cpuset_handle_hotplug may call back into cgroup core asynchronously\n-\t * via cgroup_transfer_tasks() and waiting for it from a cgroupfs\n-\t * operation like this one can lead to a deadlock through kernfs\n-\t * active_ref protection.  Let's break the protection.  Losing the\n-\t * protection is okay as we check whether @cs is online after\n-\t * grabbing cpuset_mutex anyway.  This only happens on the legacy\n-\t * hierarchies.\n-\t */\n-\tcss_get(&cs->css);\n-\tkernfs_break_active_protection(of->kn);\n-\n \tcpus_read_lock();\n \tmutex_lock(&cpuset_mutex);\n \tif (!is_cpuset_online(cs))\n@@ -3163,8 +3140,6 @@ ssize_t cpuset_write_resmask(struct kernfs_open_file *of,\n out_unlock:\n \tmutex_unlock(&cpuset_mutex);\n \tcpus_read_unlock();\n-\tkernfs_unbreak_active_protection(of->kn);\n-\tcss_put(&cs->css);\n \tflush_workqueue(cpuset_migrate_mm_wq);\n \treturn retval ?: nbytes;\n }\n"
    }
  ],
  "failures": []
}