{
  "cve_id": "CVE-2025-21635",
  "upstream_commit": "6259d2484d0ceff42245d1f09cc8cb6ee72d847a",
  "upstream_patch_content": "From 7f5611cbc4871c7fb1ad36c2e5a9edad63dca95c Mon Sep 17 00:00:00 2001\nFrom: \"Matthieu Baerts (NGI0)\" <matttbe@kernel.org>\nDate: Wed, 8 Jan 2025 16:34:37 +0100\nSubject: [PATCH] rds: sysctl: rds_tcp_{rcv,snd}buf: avoid using\n current->nsproxy\n\nAs mentioned in a previous commit of this series, using the 'net'\nstructure via 'current' is not recommended for different reasons:\n\n- Inconsistency: getting info from the reader's/writer's netns vs only\n  from the opener's netns.\n\n- current->nsproxy can be NULL in some cases, resulting in an 'Oops'\n  (null-ptr-deref), e.g. when the current task is exiting, as spotted by\n  syzbot [1] using acct(2).\n\nThe per-netns structure can be obtained from the table->data using\ncontainer_of(), then the 'net' one can be retrieved from the listen\nsocket (if available).\n\nFixes: c6a58ffed536 (\"RDS: TCP: Add sysctl tunables for sndbuf/rcvbuf on rds-tcp socket\")\nCc: stable@vger.kernel.org\nLink: https://lore.kernel.org/67769ecb.050a0220.3a8527.003f.GAE@google.com [1]\nSuggested-by: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Matthieu Baerts (NGI0) <matttbe@kernel.org>\nLink: https://patch.msgid.link/20250108-net-sysctl-current-nsproxy-v1-9-5df34b2083e8@kernel.org\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>\n---\n net/rds/tcp.c | 39 ++++++++++++++++++++++++++++++++-------\n 1 file changed, 32 insertions(+), 7 deletions(-)\n\ndiff --git a/net/rds/tcp.c b/net/rds/tcp.c\nindex 351ac1747224..0581c53e6517 100644\n--- a/net/rds/tcp.c\n+++ b/net/rds/tcp.c\n@@ -61,8 +61,10 @@ static atomic_t rds_tcp_unloading = ATOMIC_INIT(0);\n \n static struct kmem_cache *rds_tcp_conn_slab;\n \n-static int rds_tcp_skbuf_handler(const struct ctl_table *ctl, int write,\n-\t\t\t\t void *buffer, size_t *lenp, loff_t *fpos);\n+static int rds_tcp_sndbuf_handler(const struct ctl_table *ctl, int write,\n+\t\t\t\t  void *buffer, size_t *lenp, loff_t *fpos);\n+static int rds_tcp_rcvbuf_handler(const struct ctl_table *ctl, int write,\n+\t\t\t\t  void *buffer, size_t *lenp, loff_t *fpos);\n \n static int rds_tcp_min_sndbuf = SOCK_MIN_SNDBUF;\n static int rds_tcp_min_rcvbuf = SOCK_MIN_RCVBUF;\n@@ -74,7 +76,7 @@ static struct ctl_table rds_tcp_sysctl_table[] = {\n \t\t/* data is per-net pointer */\n \t\t.maxlen         = sizeof(int),\n \t\t.mode           = 0644,\n-\t\t.proc_handler   = rds_tcp_skbuf_handler,\n+\t\t.proc_handler   = rds_tcp_sndbuf_handler,\n \t\t.extra1\t\t= &rds_tcp_min_sndbuf,\n \t},\n #define\tRDS_TCP_RCVBUF\t1\n@@ -83,7 +85,7 @@ static struct ctl_table rds_tcp_sysctl_table[] = {\n \t\t/* data is per-net pointer */\n \t\t.maxlen         = sizeof(int),\n \t\t.mode           = 0644,\n-\t\t.proc_handler   = rds_tcp_skbuf_handler,\n+\t\t.proc_handler   = rds_tcp_rcvbuf_handler,\n \t\t.extra1\t\t= &rds_tcp_min_rcvbuf,\n \t},\n };\n@@ -682,10 +684,10 @@ static void rds_tcp_sysctl_reset(struct net *net)\n \tspin_unlock_irq(&rds_tcp_conn_lock);\n }\n \n-static int rds_tcp_skbuf_handler(const struct ctl_table *ctl, int write,\n+static int rds_tcp_skbuf_handler(struct rds_tcp_net *rtn,\n+\t\t\t\t const struct ctl_table *ctl, int write,\n \t\t\t\t void *buffer, size_t *lenp, loff_t *fpos)\n {\n-\tstruct net *net = current->nsproxy->net_ns;\n \tint err;\n \n \terr = proc_dointvec_minmax(ctl, write, buffer, lenp, fpos);\n@@ -694,11 +696,34 @@ static int rds_tcp_skbuf_handler(const struct ctl_table *ctl, int write,\n \t\t\t*(int *)(ctl->extra1));\n \t\treturn err;\n \t}\n-\tif (write)\n+\n+\tif (write && rtn->rds_tcp_listen_sock && rtn->rds_tcp_listen_sock->sk) {\n+\t\tstruct net *net = sock_net(rtn->rds_tcp_listen_sock->sk);\n+\n \t\trds_tcp_sysctl_reset(net);\n+\t}\n+\n \treturn 0;\n }\n \n+static int rds_tcp_sndbuf_handler(const struct ctl_table *ctl, int write,\n+\t\t\t\t  void *buffer, size_t *lenp, loff_t *fpos)\n+{\n+\tstruct rds_tcp_net *rtn = container_of(ctl->data, struct rds_tcp_net,\n+\t\t\t\t\t       sndbuf_size);\n+\n+\treturn rds_tcp_skbuf_handler(rtn, ctl, write, buffer, lenp, fpos);\n+}\n+\n+static int rds_tcp_rcvbuf_handler(const struct ctl_table *ctl, int write,\n+\t\t\t\t  void *buffer, size_t *lenp, loff_t *fpos)\n+{\n+\tstruct rds_tcp_net *rtn = container_of(ctl->data, struct rds_tcp_net,\n+\t\t\t\t\t       rcvbuf_size);\n+\n+\treturn rds_tcp_skbuf_handler(rtn, ctl, write, buffer, lenp, fpos);\n+}\n+\n static void rds_tcp_exit(void)\n {\n \trds_tcp_set_unloading();\n-- \n2.39.5 (Apple Git-154)\n\n",
  "successes": [
    {
      "downstream_version": "bcf8c60074e81ed2ac2d35130917175a3949c917",
      "downstream_patch": "de8d6de0ee27be4b2b1e5b06f04aeacbabbba492",
      "commit_date": "2025-01-17 13:40:47 +0100",
      "result": "success",
      "downstream_patch_content": "commit de8d6de0ee27be4b2b1e5b06f04aeacbabbba492\nAuthor: Matthieu Baerts (NGI0) <matttbe@kernel.org>\nDate:   Wed Jan 8 16:34:37 2025 +0100\n\n    rds: sysctl: rds_tcp_{rcv,snd}buf: avoid using current->nsproxy\n    \n    commit 7f5611cbc4871c7fb1ad36c2e5a9edad63dca95c upstream.\n    \n    As mentioned in a previous commit of this series, using the 'net'\n    structure via 'current' is not recommended for different reasons:\n    \n    - Inconsistency: getting info from the reader's/writer's netns vs only\n      from the opener's netns.\n    \n    - current->nsproxy can be NULL in some cases, resulting in an 'Oops'\n      (null-ptr-deref), e.g. when the current task is exiting, as spotted by\n      syzbot [1] using acct(2).\n    \n    The per-netns structure can be obtained from the table->data using\n    container_of(), then the 'net' one can be retrieved from the listen\n    socket (if available).\n    \n    Fixes: c6a58ffed536 (\"RDS: TCP: Add sysctl tunables for sndbuf/rcvbuf on rds-tcp socket\")\n    Cc: stable@vger.kernel.org\n    Link: https://lore.kernel.org/67769ecb.050a0220.3a8527.003f.GAE@google.com [1]\n    Suggested-by: Al Viro <viro@zeniv.linux.org.uk>\n    Signed-off-by: Matthieu Baerts (NGI0) <matttbe@kernel.org>\n    Link: https://patch.msgid.link/20250108-net-sysctl-current-nsproxy-v1-9-5df34b2083e8@kernel.org\n    Signed-off-by: Jakub Kicinski <kuba@kernel.org>\n    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n\ndiff --git a/net/rds/tcp.c b/net/rds/tcp.c\nindex 351ac1747224..0581c53e6517 100644\n--- a/net/rds/tcp.c\n+++ b/net/rds/tcp.c\n@@ -61,8 +61,10 @@ static atomic_t rds_tcp_unloading = ATOMIC_INIT(0);\n \n static struct kmem_cache *rds_tcp_conn_slab;\n \n-static int rds_tcp_skbuf_handler(const struct ctl_table *ctl, int write,\n-\t\t\t\t void *buffer, size_t *lenp, loff_t *fpos);\n+static int rds_tcp_sndbuf_handler(const struct ctl_table *ctl, int write,\n+\t\t\t\t  void *buffer, size_t *lenp, loff_t *fpos);\n+static int rds_tcp_rcvbuf_handler(const struct ctl_table *ctl, int write,\n+\t\t\t\t  void *buffer, size_t *lenp, loff_t *fpos);\n \n static int rds_tcp_min_sndbuf = SOCK_MIN_SNDBUF;\n static int rds_tcp_min_rcvbuf = SOCK_MIN_RCVBUF;\n@@ -74,7 +76,7 @@ static struct ctl_table rds_tcp_sysctl_table[] = {\n \t\t/* data is per-net pointer */\n \t\t.maxlen         = sizeof(int),\n \t\t.mode           = 0644,\n-\t\t.proc_handler   = rds_tcp_skbuf_handler,\n+\t\t.proc_handler   = rds_tcp_sndbuf_handler,\n \t\t.extra1\t\t= &rds_tcp_min_sndbuf,\n \t},\n #define\tRDS_TCP_RCVBUF\t1\n@@ -83,7 +85,7 @@ static struct ctl_table rds_tcp_sysctl_table[] = {\n \t\t/* data is per-net pointer */\n \t\t.maxlen         = sizeof(int),\n \t\t.mode           = 0644,\n-\t\t.proc_handler   = rds_tcp_skbuf_handler,\n+\t\t.proc_handler   = rds_tcp_rcvbuf_handler,\n \t\t.extra1\t\t= &rds_tcp_min_rcvbuf,\n \t},\n };\n@@ -682,10 +684,10 @@ static void rds_tcp_sysctl_reset(struct net *net)\n \tspin_unlock_irq(&rds_tcp_conn_lock);\n }\n \n-static int rds_tcp_skbuf_handler(const struct ctl_table *ctl, int write,\n+static int rds_tcp_skbuf_handler(struct rds_tcp_net *rtn,\n+\t\t\t\t const struct ctl_table *ctl, int write,\n \t\t\t\t void *buffer, size_t *lenp, loff_t *fpos)\n {\n-\tstruct net *net = current->nsproxy->net_ns;\n \tint err;\n \n \terr = proc_dointvec_minmax(ctl, write, buffer, lenp, fpos);\n@@ -694,11 +696,34 @@ static int rds_tcp_skbuf_handler(const struct ctl_table *ctl, int write,\n \t\t\t*(int *)(ctl->extra1));\n \t\treturn err;\n \t}\n-\tif (write)\n+\n+\tif (write && rtn->rds_tcp_listen_sock && rtn->rds_tcp_listen_sock->sk) {\n+\t\tstruct net *net = sock_net(rtn->rds_tcp_listen_sock->sk);\n+\n \t\trds_tcp_sysctl_reset(net);\n+\t}\n+\n \treturn 0;\n }\n \n+static int rds_tcp_sndbuf_handler(const struct ctl_table *ctl, int write,\n+\t\t\t\t  void *buffer, size_t *lenp, loff_t *fpos)\n+{\n+\tstruct rds_tcp_net *rtn = container_of(ctl->data, struct rds_tcp_net,\n+\t\t\t\t\t       sndbuf_size);\n+\n+\treturn rds_tcp_skbuf_handler(rtn, ctl, write, buffer, lenp, fpos);\n+}\n+\n+static int rds_tcp_rcvbuf_handler(const struct ctl_table *ctl, int write,\n+\t\t\t\t  void *buffer, size_t *lenp, loff_t *fpos)\n+{\n+\tstruct rds_tcp_net *rtn = container_of(ctl->data, struct rds_tcp_net,\n+\t\t\t\t\t       rcvbuf_size);\n+\n+\treturn rds_tcp_skbuf_handler(rtn, ctl, write, buffer, lenp, fpos);\n+}\n+\n static void rds_tcp_exit(void)\n {\n \trds_tcp_set_unloading();\n"
    }
  ],
  "failures": []
}