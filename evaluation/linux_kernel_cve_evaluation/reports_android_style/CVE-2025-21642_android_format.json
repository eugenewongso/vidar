{
  "cve_id": "CVE-2025-21642",
  "upstream_commit": "771ec78dc8b48d562e6015bb535ed3cd37043d78",
  "upstream_patch_content": "From d38e26e36206ae3d544d496513212ae931d1da0a Mon Sep 17 00:00:00 2001\nFrom: \"Matthieu Baerts (NGI0)\" <matttbe@kernel.org>\nDate: Wed, 8 Jan 2025 16:34:30 +0100\nSubject: [PATCH] mptcp: sysctl: sched: avoid using current->nsproxy\n\nUsing the 'net' structure via 'current' is not recommended for different\nreasons.\n\nFirst, if the goal is to use it to read or write per-netns data, this is\ninconsistent with how the \"generic\" sysctl entries are doing: directly\nby only using pointers set to the table entry, e.g. table->data. Linked\nto that, the per-netns data should always be obtained from the table\nlinked to the netns it had been created for, which may not coincide with\nthe reader's or writer's netns.\n\nAnother reason is that access to current->nsproxy->netns can oops if\nattempted when current->nsproxy had been dropped when the current task\nis exiting. This is what syzbot found, when using acct(2):\n\n  Oops: general protection fault, probably for non-canonical address 0xdffffc0000000005: 0000 [#1] PREEMPT SMP KASAN PTI\n  KASAN: null-ptr-deref in range [0x0000000000000028-0x000000000000002f]\n  CPU: 1 UID: 0 PID: 5924 Comm: syz-executor Not tainted 6.13.0-rc5-syzkaller-00004-gccb98ccef0e5 #0\n  Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024\n  RIP: 0010:proc_scheduler+0xc6/0x3c0 net/mptcp/ctrl.c:125\n  Code: 03 42 80 3c 38 00 0f 85 fe 02 00 00 4d 8b a4 24 08 09 00 00 48 b8 00 00 00 00 00 fc ff df 49 8d 7c 24 28 48 89 fa 48 c1 ea 03 <80> 3c 02 00 0f 85 cc 02 00 00 4d 8b 7c 24 28 48 8d 84 24 c8 00 00\n  RSP: 0018:ffffc900034774e8 EFLAGS: 00010206\n\n  RAX: dffffc0000000000 RBX: 1ffff9200068ee9e RCX: ffffc90003477620\n  RDX: 0000000000000005 RSI: ffffffff8b08f91e RDI: 0000000000000028\n  RBP: 0000000000000001 R08: ffffc90003477710 R09: 0000000000000040\n  R10: 0000000000000040 R11: 00000000726f7475 R12: 0000000000000000\n  R13: ffffc90003477620 R14: ffffc90003477710 R15: dffffc0000000000\n  FS:  0000000000000000(0000) GS:ffff8880b8700000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 00007fee3cd452d8 CR3: 000000007d116000 CR4: 00000000003526f0\n  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n  Call Trace:\n   <TASK>\n   proc_sys_call_handler+0x403/0x5d0 fs/proc/proc_sysctl.c:601\n   __kernel_write_iter+0x318/0xa80 fs/read_write.c:612\n   __kernel_write+0xf6/0x140 fs/read_write.c:632\n   do_acct_process+0xcb0/0x14a0 kernel/acct.c:539\n   acct_pin_kill+0x2d/0x100 kernel/acct.c:192\n   pin_kill+0x194/0x7c0 fs/fs_pin.c:44\n   mnt_pin_kill+0x61/0x1e0 fs/fs_pin.c:81\n   cleanup_mnt+0x3ac/0x450 fs/namespace.c:1366\n   task_work_run+0x14e/0x250 kernel/task_work.c:239\n   exit_task_work include/linux/task_work.h:43 [inline]\n   do_exit+0xad8/0x2d70 kernel/exit.c:938\n   do_group_exit+0xd3/0x2a0 kernel/exit.c:1087\n   get_signal+0x2576/0x2610 kernel/signal.c:3017\n   arch_do_signal_or_restart+0x90/0x7e0 arch/x86/kernel/signal.c:337\n   exit_to_user_mode_loop kernel/entry/common.c:111 [inline]\n   exit_to_user_mode_prepare include/linux/entry-common.h:329 [inline]\n   __syscall_exit_to_user_mode_work kernel/entry/common.c:207 [inline]\n   syscall_exit_to_user_mode+0x150/0x2a0 kernel/entry/common.c:218\n   do_syscall_64+0xda/0x250 arch/x86/entry/common.c:89\n   entry_SYSCALL_64_after_hwframe+0x77/0x7f\n  RIP: 0033:0x7fee3cb87a6a\n  Code: Unable to access opcode bytes at 0x7fee3cb87a40.\n  RSP: 002b:00007fffcccac688 EFLAGS: 00000202 ORIG_RAX: 0000000000000037\n  RAX: 0000000000000000 RBX: 00007fffcccac710 RCX: 00007fee3cb87a6a\n  RDX: 0000000000000041 RSI: 0000000000000000 RDI: 0000000000000003\n  RBP: 0000000000000003 R08: 00007fffcccac6ac R09: 00007fffcccacac7\n  R10: 00007fffcccac710 R11: 0000000000000202 R12: 00007fee3cd49500\n  R13: 00007fffcccac6ac R14: 0000000000000000 R15: 00007fee3cd4b000\n   </TASK>\n  Modules linked in:\n  ---[ end trace 0000000000000000 ]---\n  RIP: 0010:proc_scheduler+0xc6/0x3c0 net/mptcp/ctrl.c:125\n  Code: 03 42 80 3c 38 00 0f 85 fe 02 00 00 4d 8b a4 24 08 09 00 00 48 b8 00 00 00 00 00 fc ff df 49 8d 7c 24 28 48 89 fa 48 c1 ea 03 <80> 3c 02 00 0f 85 cc 02 00 00 4d 8b 7c 24 28 48 8d 84 24 c8 00 00\n  RSP: 0018:ffffc900034774e8 EFLAGS: 00010206\n  RAX: dffffc0000000000 RBX: 1ffff9200068ee9e RCX: ffffc90003477620\n  RDX: 0000000000000005 RSI: ffffffff8b08f91e RDI: 0000000000000028\n  RBP: 0000000000000001 R08: ffffc90003477710 R09: 0000000000000040\n  R10: 0000000000000040 R11: 00000000726f7475 R12: 0000000000000000\n  R13: ffffc90003477620 R14: ffffc90003477710 R15: dffffc0000000000\n  FS:  0000000000000000(0000) GS:ffff8880b8700000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 00007fee3cd452d8 CR3: 000000007d116000 CR4: 00000000003526f0\n  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n  ----------------\n  Code disassembly (best guess), 1 bytes skipped:\n     0:\t42 80 3c 38 00       \tcmpb   $0x0,(%rax,%r15,1)\n     5:\t0f 85 fe 02 00 00    \tjne    0x309\n     b:\t4d 8b a4 24 08 09 00 \tmov    0x908(%r12),%r12\n    12:\t00\n    13:\t48 b8 00 00 00 00 00 \tmovabs $0xdffffc0000000000,%rax\n    1a:\tfc ff df\n    1d:\t49 8d 7c 24 28       \tlea    0x28(%r12),%rdi\n    22:\t48 89 fa             \tmov    %rdi,%rdx\n    25:\t48 c1 ea 03          \tshr    $0x3,%rdx\n  * 29:\t80 3c 02 00          \tcmpb   $0x0,(%rdx,%rax,1) <-- trapping instruction\n    2d:\t0f 85 cc 02 00 00    \tjne    0x2ff\n    33:\t4d 8b 7c 24 28       \tmov    0x28(%r12),%r15\n    38:\t48                   \trex.W\n    39:\t8d                   \t.byte 0x8d\n    3a:\t84 24 c8             \ttest   %ah,(%rax,%rcx,8)\n\nHere with 'net.mptcp.scheduler', the 'net' structure is not really\nneeded, because the table->data already has a pointer to the current\nscheduler, the only thing needed from the per-netns data.\nSimply use 'data', instead of getting (most of the time) the same thing,\nbut from a longer and indirect way.\n\nFixes: 6963c508fd7a (\"mptcp: only allow set existing scheduler for net.mptcp.scheduler\")\nCc: stable@vger.kernel.org\nReported-by: syzbot+e364f774c6f57f2c86d1@syzkaller.appspotmail.com\nCloses: https://lore.kernel.org/67769ecb.050a0220.3a8527.003f.GAE@google.com\nSuggested-by: Al Viro <viro@zeniv.linux.org.uk>\nReviewed-by: Mat Martineau <martineau@kernel.org>\nSigned-off-by: Matthieu Baerts (NGI0) <matttbe@kernel.org>\nLink: https://patch.msgid.link/20250108-net-sysctl-current-nsproxy-v1-2-5df34b2083e8@kernel.org\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>\n---\n net/mptcp/ctrl.c | 11 +++++------\n 1 file changed, 5 insertions(+), 6 deletions(-)\n\ndiff --git a/net/mptcp/ctrl.c b/net/mptcp/ctrl.c\nindex d9b57fab2a13..81c30aa02196 100644\n--- a/net/mptcp/ctrl.c\n+++ b/net/mptcp/ctrl.c\n@@ -102,16 +102,15 @@ static void mptcp_pernet_set_defaults(struct mptcp_pernet *pernet)\n }\n \n #ifdef CONFIG_SYSCTL\n-static int mptcp_set_scheduler(const struct net *net, const char *name)\n+static int mptcp_set_scheduler(char *scheduler, const char *name)\n {\n-\tstruct mptcp_pernet *pernet = mptcp_get_pernet(net);\n \tstruct mptcp_sched_ops *sched;\n \tint ret = 0;\n \n \trcu_read_lock();\n \tsched = mptcp_sched_find(name);\n \tif (sched)\n-\t\tstrscpy(pernet->scheduler, name, MPTCP_SCHED_NAME_MAX);\n+\t\tstrscpy(scheduler, name, MPTCP_SCHED_NAME_MAX);\n \telse\n \t\tret = -ENOENT;\n \trcu_read_unlock();\n@@ -122,7 +121,7 @@ static int mptcp_set_scheduler(const struct net *net, const char *name)\n static int proc_scheduler(const struct ctl_table *ctl, int write,\n \t\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n {\n-\tconst struct net *net = current->nsproxy->net_ns;\n+\tchar (*scheduler)[MPTCP_SCHED_NAME_MAX] = ctl->data;\n \tchar val[MPTCP_SCHED_NAME_MAX];\n \tstruct ctl_table tbl = {\n \t\t.data = val,\n@@ -130,11 +129,11 @@ static int proc_scheduler(const struct ctl_table *ctl, int write,\n \t};\n \tint ret;\n \n-\tstrscpy(val, mptcp_get_scheduler(net), MPTCP_SCHED_NAME_MAX);\n+\tstrscpy(val, *scheduler, MPTCP_SCHED_NAME_MAX);\n \n \tret = proc_dostring(&tbl, write, buffer, lenp, ppos);\n \tif (write && ret == 0)\n-\t\tret = mptcp_set_scheduler(net, val);\n+\t\tret = mptcp_set_scheduler(*scheduler, val);\n \n \treturn ret;\n }\n-- \n2.39.5 (Apple Git-154)\n\n",
  "successes": [
    {
      "downstream_version": "a57ce97c1978c65d102581282e040b1fb4af82ae",
      "downstream_patch": "c0e394fd6b887e84da17e38aaa6c1c104f9c86c2",
      "commit_date": "2025-01-17 13:36:17 +0100",
      "result": "success",
      "downstream_patch_content": "commit c0e394fd6b887e84da17e38aaa6c1c104f9c86c2\nAuthor: Matthieu Baerts (NGI0) <matttbe@kernel.org>\nDate:   Wed Jan 8 16:34:30 2025 +0100\n\n    mptcp: sysctl: sched: avoid using current->nsproxy\n    \n    commit d38e26e36206ae3d544d496513212ae931d1da0a upstream.\n    \n    Using the 'net' structure via 'current' is not recommended for different\n    reasons.\n    \n    First, if the goal is to use it to read or write per-netns data, this is\n    inconsistent with how the \"generic\" sysctl entries are doing: directly\n    by only using pointers set to the table entry, e.g. table->data. Linked\n    to that, the per-netns data should always be obtained from the table\n    linked to the netns it had been created for, which may not coincide with\n    the reader's or writer's netns.\n    \n    Another reason is that access to current->nsproxy->netns can oops if\n    attempted when current->nsproxy had been dropped when the current task\n    is exiting. This is what syzbot found, when using acct(2):\n    \n      Oops: general protection fault, probably for non-canonical address 0xdffffc0000000005: 0000 [#1] PREEMPT SMP KASAN PTI\n      KASAN: null-ptr-deref in range [0x0000000000000028-0x000000000000002f]\n      CPU: 1 UID: 0 PID: 5924 Comm: syz-executor Not tainted 6.13.0-rc5-syzkaller-00004-gccb98ccef0e5 #0\n      Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024\n      RIP: 0010:proc_scheduler+0xc6/0x3c0 net/mptcp/ctrl.c:125\n      Code: 03 42 80 3c 38 00 0f 85 fe 02 00 00 4d 8b a4 24 08 09 00 00 48 b8 00 00 00 00 00 fc ff df 49 8d 7c 24 28 48 89 fa 48 c1 ea 03 <80> 3c 02 00 0f 85 cc 02 00 00 4d 8b 7c 24 28 48 8d 84 24 c8 00 00\n      RSP: 0018:ffffc900034774e8 EFLAGS: 00010206\n    \n      RAX: dffffc0000000000 RBX: 1ffff9200068ee9e RCX: ffffc90003477620\n      RDX: 0000000000000005 RSI: ffffffff8b08f91e RDI: 0000000000000028\n      RBP: 0000000000000001 R08: ffffc90003477710 R09: 0000000000000040\n      R10: 0000000000000040 R11: 00000000726f7475 R12: 0000000000000000\n      R13: ffffc90003477620 R14: ffffc90003477710 R15: dffffc0000000000\n      FS:  0000000000000000(0000) GS:ffff8880b8700000(0000) knlGS:0000000000000000\n      CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n      CR2: 00007fee3cd452d8 CR3: 000000007d116000 CR4: 00000000003526f0\n      DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n      DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n      Call Trace:\n       <TASK>\n       proc_sys_call_handler+0x403/0x5d0 fs/proc/proc_sysctl.c:601\n       __kernel_write_iter+0x318/0xa80 fs/read_write.c:612\n       __kernel_write+0xf6/0x140 fs/read_write.c:632\n       do_acct_process+0xcb0/0x14a0 kernel/acct.c:539\n       acct_pin_kill+0x2d/0x100 kernel/acct.c:192\n       pin_kill+0x194/0x7c0 fs/fs_pin.c:44\n       mnt_pin_kill+0x61/0x1e0 fs/fs_pin.c:81\n       cleanup_mnt+0x3ac/0x450 fs/namespace.c:1366\n       task_work_run+0x14e/0x250 kernel/task_work.c:239\n       exit_task_work include/linux/task_work.h:43 [inline]\n       do_exit+0xad8/0x2d70 kernel/exit.c:938\n       do_group_exit+0xd3/0x2a0 kernel/exit.c:1087\n       get_signal+0x2576/0x2610 kernel/signal.c:3017\n       arch_do_signal_or_restart+0x90/0x7e0 arch/x86/kernel/signal.c:337\n       exit_to_user_mode_loop kernel/entry/common.c:111 [inline]\n       exit_to_user_mode_prepare include/linux/entry-common.h:329 [inline]\n       __syscall_exit_to_user_mode_work kernel/entry/common.c:207 [inline]\n       syscall_exit_to_user_mode+0x150/0x2a0 kernel/entry/common.c:218\n       do_syscall_64+0xda/0x250 arch/x86/entry/common.c:89\n       entry_SYSCALL_64_after_hwframe+0x77/0x7f\n      RIP: 0033:0x7fee3cb87a6a\n      Code: Unable to access opcode bytes at 0x7fee3cb87a40.\n      RSP: 002b:00007fffcccac688 EFLAGS: 00000202 ORIG_RAX: 0000000000000037\n      RAX: 0000000000000000 RBX: 00007fffcccac710 RCX: 00007fee3cb87a6a\n      RDX: 0000000000000041 RSI: 0000000000000000 RDI: 0000000000000003\n      RBP: 0000000000000003 R08: 00007fffcccac6ac R09: 00007fffcccacac7\n      R10: 00007fffcccac710 R11: 0000000000000202 R12: 00007fee3cd49500\n      R13: 00007fffcccac6ac R14: 0000000000000000 R15: 00007fee3cd4b000\n       </TASK>\n      Modules linked in:\n      ---[ end trace 0000000000000000 ]---\n      RIP: 0010:proc_scheduler+0xc6/0x3c0 net/mptcp/ctrl.c:125\n      Code: 03 42 80 3c 38 00 0f 85 fe 02 00 00 4d 8b a4 24 08 09 00 00 48 b8 00 00 00 00 00 fc ff df 49 8d 7c 24 28 48 89 fa 48 c1 ea 03 <80> 3c 02 00 0f 85 cc 02 00 00 4d 8b 7c 24 28 48 8d 84 24 c8 00 00\n      RSP: 0018:ffffc900034774e8 EFLAGS: 00010206\n      RAX: dffffc0000000000 RBX: 1ffff9200068ee9e RCX: ffffc90003477620\n      RDX: 0000000000000005 RSI: ffffffff8b08f91e RDI: 0000000000000028\n      RBP: 0000000000000001 R08: ffffc90003477710 R09: 0000000000000040\n      R10: 0000000000000040 R11: 00000000726f7475 R12: 0000000000000000\n      R13: ffffc90003477620 R14: ffffc90003477710 R15: dffffc0000000000\n      FS:  0000000000000000(0000) GS:ffff8880b8700000(0000) knlGS:0000000000000000\n      CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n      CR2: 00007fee3cd452d8 CR3: 000000007d116000 CR4: 00000000003526f0\n      DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n      DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n      ----------------\n      Code disassembly (best guess), 1 bytes skipped:\n         0: 42 80 3c 38 00          cmpb   $0x0,(%rax,%r15,1)\n         5: 0f 85 fe 02 00 00       jne    0x309\n         b: 4d 8b a4 24 08 09 00    mov    0x908(%r12),%r12\n        12: 00\n        13: 48 b8 00 00 00 00 00    movabs $0xdffffc0000000000,%rax\n        1a: fc ff df\n        1d: 49 8d 7c 24 28          lea    0x28(%r12),%rdi\n        22: 48 89 fa                mov    %rdi,%rdx\n        25: 48 c1 ea 03             shr    $0x3,%rdx\n      * 29: 80 3c 02 00             cmpb   $0x0,(%rdx,%rax,1) <-- trapping instruction\n        2d: 0f 85 cc 02 00 00       jne    0x2ff\n        33: 4d 8b 7c 24 28          mov    0x28(%r12),%r15\n        38: 48                      rex.W\n        39: 8d                      .byte 0x8d\n        3a: 84 24 c8                test   %ah,(%rax,%rcx,8)\n    \n    Here with 'net.mptcp.scheduler', the 'net' structure is not really\n    needed, because the table->data already has a pointer to the current\n    scheduler, the only thing needed from the per-netns data.\n    Simply use 'data', instead of getting (most of the time) the same thing,\n    but from a longer and indirect way.\n    \n    Fixes: 6963c508fd7a (\"mptcp: only allow set existing scheduler for net.mptcp.scheduler\")\n    Cc: stable@vger.kernel.org\n    Reported-by: syzbot+e364f774c6f57f2c86d1@syzkaller.appspotmail.com\n    Closes: https://lore.kernel.org/67769ecb.050a0220.3a8527.003f.GAE@google.com\n    Suggested-by: Al Viro <viro@zeniv.linux.org.uk>\n    Reviewed-by: Mat Martineau <martineau@kernel.org>\n    Signed-off-by: Matthieu Baerts (NGI0) <matttbe@kernel.org>\n    Link: https://patch.msgid.link/20250108-net-sysctl-current-nsproxy-v1-2-5df34b2083e8@kernel.org\n    Signed-off-by: Jakub Kicinski <kuba@kernel.org>\n    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n\ndiff --git a/net/mptcp/ctrl.c b/net/mptcp/ctrl.c\nindex de75df904a00..34ae0ef4f9f3 100644\n--- a/net/mptcp/ctrl.c\n+++ b/net/mptcp/ctrl.c\n@@ -87,16 +87,15 @@ static void mptcp_pernet_set_defaults(struct mptcp_pernet *pernet)\n }\n \n #ifdef CONFIG_SYSCTL\n-static int mptcp_set_scheduler(const struct net *net, const char *name)\n+static int mptcp_set_scheduler(char *scheduler, const char *name)\n {\n-\tstruct mptcp_pernet *pernet = mptcp_get_pernet(net);\n \tstruct mptcp_sched_ops *sched;\n \tint ret = 0;\n \n \trcu_read_lock();\n \tsched = mptcp_sched_find(name);\n \tif (sched)\n-\t\tstrscpy(pernet->scheduler, name, MPTCP_SCHED_NAME_MAX);\n+\t\tstrscpy(scheduler, name, MPTCP_SCHED_NAME_MAX);\n \telse\n \t\tret = -ENOENT;\n \trcu_read_unlock();\n@@ -107,7 +106,7 @@ static int mptcp_set_scheduler(const struct net *net, const char *name)\n static int proc_scheduler(struct ctl_table *ctl, int write,\n \t\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n {\n-\tconst struct net *net = current->nsproxy->net_ns;\n+\tchar (*scheduler)[MPTCP_SCHED_NAME_MAX] = ctl->data;\n \tchar val[MPTCP_SCHED_NAME_MAX];\n \tstruct ctl_table tbl = {\n \t\t.data = val,\n@@ -115,11 +114,11 @@ static int proc_scheduler(struct ctl_table *ctl, int write,\n \t};\n \tint ret;\n \n-\tstrscpy(val, mptcp_get_scheduler(net), MPTCP_SCHED_NAME_MAX);\n+\tstrscpy(val, *scheduler, MPTCP_SCHED_NAME_MAX);\n \n \tret = proc_dostring(&tbl, write, buffer, lenp, ppos);\n \tif (write && ret == 0)\n-\t\tret = mptcp_set_scheduler(net, val);\n+\t\tret = mptcp_set_scheduler(*scheduler, val);\n \n \treturn ret;\n }\n"
    },
    {
      "downstream_version": "8d242069660aefdc7175b7fef8e20c2d3fde7868",
      "downstream_patch": "6035702381c35a8f16757332381e58b348a9eaf9",
      "commit_date": "2025-01-17 13:40:46 +0100",
      "result": "success",
      "downstream_patch_content": "commit 6035702381c35a8f16757332381e58b348a9eaf9\nAuthor: Matthieu Baerts (NGI0) <matttbe@kernel.org>\nDate:   Wed Jan 8 16:34:30 2025 +0100\n\n    mptcp: sysctl: sched: avoid using current->nsproxy\n    \n    commit d38e26e36206ae3d544d496513212ae931d1da0a upstream.\n    \n    Using the 'net' structure via 'current' is not recommended for different\n    reasons.\n    \n    First, if the goal is to use it to read or write per-netns data, this is\n    inconsistent with how the \"generic\" sysctl entries are doing: directly\n    by only using pointers set to the table entry, e.g. table->data. Linked\n    to that, the per-netns data should always be obtained from the table\n    linked to the netns it had been created for, which may not coincide with\n    the reader's or writer's netns.\n    \n    Another reason is that access to current->nsproxy->netns can oops if\n    attempted when current->nsproxy had been dropped when the current task\n    is exiting. This is what syzbot found, when using acct(2):\n    \n      Oops: general protection fault, probably for non-canonical address 0xdffffc0000000005: 0000 [#1] PREEMPT SMP KASAN PTI\n      KASAN: null-ptr-deref in range [0x0000000000000028-0x000000000000002f]\n      CPU: 1 UID: 0 PID: 5924 Comm: syz-executor Not tainted 6.13.0-rc5-syzkaller-00004-gccb98ccef0e5 #0\n      Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024\n      RIP: 0010:proc_scheduler+0xc6/0x3c0 net/mptcp/ctrl.c:125\n      Code: 03 42 80 3c 38 00 0f 85 fe 02 00 00 4d 8b a4 24 08 09 00 00 48 b8 00 00 00 00 00 fc ff df 49 8d 7c 24 28 48 89 fa 48 c1 ea 03 <80> 3c 02 00 0f 85 cc 02 00 00 4d 8b 7c 24 28 48 8d 84 24 c8 00 00\n      RSP: 0018:ffffc900034774e8 EFLAGS: 00010206\n    \n      RAX: dffffc0000000000 RBX: 1ffff9200068ee9e RCX: ffffc90003477620\n      RDX: 0000000000000005 RSI: ffffffff8b08f91e RDI: 0000000000000028\n      RBP: 0000000000000001 R08: ffffc90003477710 R09: 0000000000000040\n      R10: 0000000000000040 R11: 00000000726f7475 R12: 0000000000000000\n      R13: ffffc90003477620 R14: ffffc90003477710 R15: dffffc0000000000\n      FS:  0000000000000000(0000) GS:ffff8880b8700000(0000) knlGS:0000000000000000\n      CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n      CR2: 00007fee3cd452d8 CR3: 000000007d116000 CR4: 00000000003526f0\n      DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n      DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n      Call Trace:\n       <TASK>\n       proc_sys_call_handler+0x403/0x5d0 fs/proc/proc_sysctl.c:601\n       __kernel_write_iter+0x318/0xa80 fs/read_write.c:612\n       __kernel_write+0xf6/0x140 fs/read_write.c:632\n       do_acct_process+0xcb0/0x14a0 kernel/acct.c:539\n       acct_pin_kill+0x2d/0x100 kernel/acct.c:192\n       pin_kill+0x194/0x7c0 fs/fs_pin.c:44\n       mnt_pin_kill+0x61/0x1e0 fs/fs_pin.c:81\n       cleanup_mnt+0x3ac/0x450 fs/namespace.c:1366\n       task_work_run+0x14e/0x250 kernel/task_work.c:239\n       exit_task_work include/linux/task_work.h:43 [inline]\n       do_exit+0xad8/0x2d70 kernel/exit.c:938\n       do_group_exit+0xd3/0x2a0 kernel/exit.c:1087\n       get_signal+0x2576/0x2610 kernel/signal.c:3017\n       arch_do_signal_or_restart+0x90/0x7e0 arch/x86/kernel/signal.c:337\n       exit_to_user_mode_loop kernel/entry/common.c:111 [inline]\n       exit_to_user_mode_prepare include/linux/entry-common.h:329 [inline]\n       __syscall_exit_to_user_mode_work kernel/entry/common.c:207 [inline]\n       syscall_exit_to_user_mode+0x150/0x2a0 kernel/entry/common.c:218\n       do_syscall_64+0xda/0x250 arch/x86/entry/common.c:89\n       entry_SYSCALL_64_after_hwframe+0x77/0x7f\n      RIP: 0033:0x7fee3cb87a6a\n      Code: Unable to access opcode bytes at 0x7fee3cb87a40.\n      RSP: 002b:00007fffcccac688 EFLAGS: 00000202 ORIG_RAX: 0000000000000037\n      RAX: 0000000000000000 RBX: 00007fffcccac710 RCX: 00007fee3cb87a6a\n      RDX: 0000000000000041 RSI: 0000000000000000 RDI: 0000000000000003\n      RBP: 0000000000000003 R08: 00007fffcccac6ac R09: 00007fffcccacac7\n      R10: 00007fffcccac710 R11: 0000000000000202 R12: 00007fee3cd49500\n      R13: 00007fffcccac6ac R14: 0000000000000000 R15: 00007fee3cd4b000\n       </TASK>\n      Modules linked in:\n      ---[ end trace 0000000000000000 ]---\n      RIP: 0010:proc_scheduler+0xc6/0x3c0 net/mptcp/ctrl.c:125\n      Code: 03 42 80 3c 38 00 0f 85 fe 02 00 00 4d 8b a4 24 08 09 00 00 48 b8 00 00 00 00 00 fc ff df 49 8d 7c 24 28 48 89 fa 48 c1 ea 03 <80> 3c 02 00 0f 85 cc 02 00 00 4d 8b 7c 24 28 48 8d 84 24 c8 00 00\n      RSP: 0018:ffffc900034774e8 EFLAGS: 00010206\n      RAX: dffffc0000000000 RBX: 1ffff9200068ee9e RCX: ffffc90003477620\n      RDX: 0000000000000005 RSI: ffffffff8b08f91e RDI: 0000000000000028\n      RBP: 0000000000000001 R08: ffffc90003477710 R09: 0000000000000040\n      R10: 0000000000000040 R11: 00000000726f7475 R12: 0000000000000000\n      R13: ffffc90003477620 R14: ffffc90003477710 R15: dffffc0000000000\n      FS:  0000000000000000(0000) GS:ffff8880b8700000(0000) knlGS:0000000000000000\n      CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n      CR2: 00007fee3cd452d8 CR3: 000000007d116000 CR4: 00000000003526f0\n      DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n      DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n      ----------------\n      Code disassembly (best guess), 1 bytes skipped:\n         0: 42 80 3c 38 00          cmpb   $0x0,(%rax,%r15,1)\n         5: 0f 85 fe 02 00 00       jne    0x309\n         b: 4d 8b a4 24 08 09 00    mov    0x908(%r12),%r12\n        12: 00\n        13: 48 b8 00 00 00 00 00    movabs $0xdffffc0000000000,%rax\n        1a: fc ff df\n        1d: 49 8d 7c 24 28          lea    0x28(%r12),%rdi\n        22: 48 89 fa                mov    %rdi,%rdx\n        25: 48 c1 ea 03             shr    $0x3,%rdx\n      * 29: 80 3c 02 00             cmpb   $0x0,(%rdx,%rax,1) <-- trapping instruction\n        2d: 0f 85 cc 02 00 00       jne    0x2ff\n        33: 4d 8b 7c 24 28          mov    0x28(%r12),%r15\n        38: 48                      rex.W\n        39: 8d                      .byte 0x8d\n        3a: 84 24 c8                test   %ah,(%rax,%rcx,8)\n    \n    Here with 'net.mptcp.scheduler', the 'net' structure is not really\n    needed, because the table->data already has a pointer to the current\n    scheduler, the only thing needed from the per-netns data.\n    Simply use 'data', instead of getting (most of the time) the same thing,\n    but from a longer and indirect way.\n    \n    Fixes: 6963c508fd7a (\"mptcp: only allow set existing scheduler for net.mptcp.scheduler\")\n    Cc: stable@vger.kernel.org\n    Reported-by: syzbot+e364f774c6f57f2c86d1@syzkaller.appspotmail.com\n    Closes: https://lore.kernel.org/67769ecb.050a0220.3a8527.003f.GAE@google.com\n    Suggested-by: Al Viro <viro@zeniv.linux.org.uk>\n    Reviewed-by: Mat Martineau <martineau@kernel.org>\n    Signed-off-by: Matthieu Baerts (NGI0) <matttbe@kernel.org>\n    Link: https://patch.msgid.link/20250108-net-sysctl-current-nsproxy-v1-2-5df34b2083e8@kernel.org\n    Signed-off-by: Jakub Kicinski <kuba@kernel.org>\n    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n\ndiff --git a/net/mptcp/ctrl.c b/net/mptcp/ctrl.c\nindex d9b57fab2a13..81c30aa02196 100644\n--- a/net/mptcp/ctrl.c\n+++ b/net/mptcp/ctrl.c\n@@ -102,16 +102,15 @@ static void mptcp_pernet_set_defaults(struct mptcp_pernet *pernet)\n }\n \n #ifdef CONFIG_SYSCTL\n-static int mptcp_set_scheduler(const struct net *net, const char *name)\n+static int mptcp_set_scheduler(char *scheduler, const char *name)\n {\n-\tstruct mptcp_pernet *pernet = mptcp_get_pernet(net);\n \tstruct mptcp_sched_ops *sched;\n \tint ret = 0;\n \n \trcu_read_lock();\n \tsched = mptcp_sched_find(name);\n \tif (sched)\n-\t\tstrscpy(pernet->scheduler, name, MPTCP_SCHED_NAME_MAX);\n+\t\tstrscpy(scheduler, name, MPTCP_SCHED_NAME_MAX);\n \telse\n \t\tret = -ENOENT;\n \trcu_read_unlock();\n@@ -122,7 +121,7 @@ static int mptcp_set_scheduler(const struct net *net, const char *name)\n static int proc_scheduler(const struct ctl_table *ctl, int write,\n \t\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n {\n-\tconst struct net *net = current->nsproxy->net_ns;\n+\tchar (*scheduler)[MPTCP_SCHED_NAME_MAX] = ctl->data;\n \tchar val[MPTCP_SCHED_NAME_MAX];\n \tstruct ctl_table tbl = {\n \t\t.data = val,\n@@ -130,11 +129,11 @@ static int proc_scheduler(const struct ctl_table *ctl, int write,\n \t};\n \tint ret;\n \n-\tstrscpy(val, mptcp_get_scheduler(net), MPTCP_SCHED_NAME_MAX);\n+\tstrscpy(val, *scheduler, MPTCP_SCHED_NAME_MAX);\n \n \tret = proc_dostring(&tbl, write, buffer, lenp, ppos);\n \tif (write && ret == 0)\n-\t\tret = mptcp_set_scheduler(net, val);\n+\t\tret = mptcp_set_scheduler(*scheduler, val);\n \n \treturn ret;\n }\n"
    }
  ],
  "failures": []
}