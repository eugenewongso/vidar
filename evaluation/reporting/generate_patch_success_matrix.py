# generate_cross_patch_matrix.py
r"""Generates a matrix and heatmap visualizing patch success rates across versions.

This script is part of the reporting stage of the evaluation framework. It consumes
the detailed JSON report generated by an evaluation script (e.g.,
`evaluate_llm_patch_success.py`) and produces a high-level summary of how
patches from one source (like the 'main' branch or a specific Android release)
apply to other target Android releases.

The process is as follows:
1.  Loads a JSON report containing detailed patch attempt results.
2.  Parses through both standard patch attempts (from 'main' to downstream) and
    "cross-patch" attempts (from one downstream version to another).
3.  Aggregates the number of successful, failed, and errored attempts for each
    source-target pair.
4.  Calculates a success rate percentage for each pair.
5.  Displays a pivot table of the success rates in the console.
6.  Optionally saves the full data matrix (including raw counts) to a CSV file.
7.  Optionally generates a PNG heatmap visualizing the success rates. The cells
    in the heatmap are color-coded from red (low success) to green (high success)
    and are annotated with both the success rate and the total number of attempts.

Usage:
  python generate_patch_success_matrix.py \
      --report <path_to_input_report.json> \
      --csv [path_to_output.csv] \
      --heatmap [path_to_output.png]
"""
import json
import pandas as pd
import argparse
import seaborn as sns
import matplotlib.pyplot as plt
from collections import defaultdict

def load_report(path):
    with open(path, "r") as f:
        return json.load(f)

def build_cross_patch_matrix(report_data):
    matrix = defaultdict(lambda: defaultdict(lambda: {"success": 0, "fail": 0, "error": 0}))
    for entry in report_data:
        # Add main ‚Üí downstream entries
        for patch_summary in entry.get("patch_attempts", []):
            for attempt in patch_summary.get("patch_results", []):
                src = "main"
                tgt = attempt.get("downstream_version")
                status = attempt.get("result")
                if not tgt or not status:
                    continue
                if status == "success":
                    matrix[src][tgt]["success"] += 1
                elif status == "failure":
                    matrix[src][tgt]["fail"] += 1
                else:
                    matrix[src][tgt]["error"] += 1

        # Add cross-version entries
        for result in entry.get("cross_patch_attempts", []):
            src = result.get("from")
            tgt = result.get("to")
            status = result.get("result")
            if not src or not tgt:
                continue
            if status == "success":
                matrix[src][tgt]["success"] += 1
            elif status == "failure":
                matrix[src][tgt]["fail"] += 1
            else:
                matrix[src][tgt]["error"] += 1
    return matrix

def matrix_to_dataframe(matrix):
    rows = []
    for src, tgts in matrix.items():
        for tgt, stats in tgts.items():
            total = stats["success"] + stats["fail"] + stats["error"]
            if total == 0:
                continue
            success_rate = round(stats["success"] / total * 100, 2)
            rows.append({
                "From": src,
                "To": tgt,
                "Success Rate (%)": success_rate,
                "Successes": stats["success"],
                "Failures": stats["fail"],
                "Errors": stats["error"],
                "Total Attempts": total
            })
    df = pd.DataFrame(rows)
    pivot = df.pivot(index="From", columns="To", values="Success Rate (%)").fillna("-")
    return df, pivot

def save_heatmap(pivot, out_file, raw_counts):
    plt.figure(figsize=(10, 8))

    # Convert data to float for coloring
    annotated_data = pivot.replace("-", 0)
    annotated_data = annotated_data.applymap(
        lambda x: float(x) if isinstance(x, (int, float)) or str(x).replace(".", "", 1).isdigit() else 0
    )

    # Create annotation labels
    annotations = annotated_data.astype("object")
    for i in annotations.index:
        for j in annotations.columns:
            rate = annotated_data.loc[i, j]
            total = raw_counts.get((i, j), 0)
            annotations.loc[i, j] = f"{rate:.1f}%\n({total})"

    # Plot the heatmap
    ax = sns.heatmap(
        annotated_data.astype(float),
        annot=annotations,
        fmt="",
        cmap="RdYlGn",
        cbar_kws={'label': 'Success Rate (%)'}
    )
    ax.invert_xaxis()  # Higher versions appear on the left
    plt.title("Patch Success Rate + Total Attempts")
    plt.xlabel("To Version")
    plt.ylabel("From Version")
    plt.tight_layout()
    plt.savefig(out_file)
    print(f"‚úÖ Heatmap saved to {out_file}")




def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--report", type=str, required=True)
    parser.add_argument("--csv", type=str)
    parser.add_argument("--heatmap", type=str)
    args = parser.parse_args()

    data = load_report(args.report)
    relevant_groups = [
    "vulnerabilities_with_all_failures",
    "vulnerabilities_with_partial_failures",
    "vulnerabilities_with_all_successful_patches"
    ]

    all_entries = []
    for group in relevant_groups:
        all_entries.extend(data.get(group, []))

    matrix = build_cross_patch_matrix(all_entries)

    df, pivot = matrix_to_dataframe(matrix)

    print("\nüìã Cross-Version Patch Matrix:")
    print(pivot)

    if args.csv:
        df.to_csv(args.csv, index=False)
        print(f"üìÑ CSV saved to {args.csv}")

    # Build raw count lookup
    raw_counts = {(row["From"], row["To"]): row["Total Attempts"] for row in df.to_dict("records")}

    if args.heatmap:
        total_attempts = len(df)
        unique_from_versions = df["From"].nunique()
        unique_to_versions = df["To"].nunique()
        print(f"\nüìä Total patch attempts: {total_attempts}")
        print(f"üîÅ Unique 'From' versions: {unique_from_versions}")
        print(f"‚û°Ô∏è Unique 'To' versions: {unique_to_versions}")

        save_heatmap(pivot, args.heatmap, raw_counts)


if __name__ == "__main__":
    main()
