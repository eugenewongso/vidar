{
  "cves_with_all_failures": [
    {
      "cve_url": "https://web.git.kernel.org/pub/scm/linux/security/vulns.git/plain/cve/published/2025/CVE-2025-21655.json",
      "patch_attempts": [
        {
          "upstream_commit": "60495b08cf7a6920035c5172a22655ca2001270b",
          "upstream_commit_date": "2025-01-09 07:16:45 -0700",
          "upstream_patch": "c9a40292a44e78f71258b8522655bffaf5753bdb",
          "total_versions_tested": 3,
          "successful_patches": 0,
          "failed_patches": 3,
          "patch_results": [
            {
              "downstream_patch": "6b63308c28987c6010b1180c72a6db4df6c68033",
              "downstream_commit": "3e871c1d51f9ffea70065c36a2d8615ffc3f05aa",
              "commit_date": "2025-01-17 13:34:47 +0100",
              "result": "failure",
              "error": "can't find file to patch at input line 31\nPerhaps you used the wrong -p or --strip option?\nThe text leading up to this was:\n--------------------------\n|From c9a40292a44e78f71258b8522655bffaf5753bdb Mon Sep 17 00:00:00 2001\n|From: Jens Axboe <axboe@kernel.dk>\n|Date: Wed, 8 Jan 2025 10:28:05 -0700\n|Subject: [PATCH] io_uring/eventfd: ensure io_eventfd_signal() defers another\n| RCU period\n|\n|io_eventfd_do_signal() is invoked from an RCU callback, but when\n|dropping the reference to the io_ev_fd, it calls io_eventfd_free()\n|directly if the refcount drops to zero. This isn't correct, as any\n|potential freeing of the io_ev_fd should be deferred another RCU grace\n|period.\n|\n|Just call io_eventfd_put() rather than open-code the dec-and-test and\n|free, which will correctly defer it another RCU grace period.\n|\n|Fixes: 21a091b970cd (\"io_uring: signal registered eventfd to process deferred task work\")\n|Reported-by: Jann Horn <jannh@google.com>\n|Cc: stable@vger.kernel.org\n|Tested-by: Li Zetao <lizetao1@huawei.com>\n|Reviewed-by: Li Zetao<lizetao1@huawei.com>\n|Reviewed-by: Prasanna Kumar T S M <ptsm@linux.microsoft.com>\n|Signed-off-by: Jens Axboe <axboe@kernel.dk>\n|---\n| io_uring/eventfd.c | 16 +++++++---------\n| 1 file changed, 7 insertions(+), 9 deletions(-)\n|\n|diff --git a/io_uring/eventfd.c b/io_uring/eventfd.c\n|index fab936d31ba8..100d5da94cb9 100644\n|--- a/io_uring/eventfd.c\n|+++ b/io_uring/eventfd.c\n--------------------------\nFile to patch: \nSkip this patch? [y] \nSkipping patch.\n1 out of 1 hunk ignored",
              "total_hunks": 0,
              "total_failed_hunks": 0,
              "failed_hunks": [],
              "rej_file_content": "No rejected diff content found.",
              "inline_merge_conflict": "No conflict markers found."
            },
            {
              "downstream_patch": "8efff2aa2d95dc437ab67c5b4a9f1d3f367baa10",
              "downstream_commit": "03753bfacbc6039fce7cc7585287589b87895199",
              "commit_date": "2025-01-17 13:36:24 +0100",
              "result": "failure",
              "error": "can't find file to patch at input line 31\nPerhaps you used the wrong -p or --strip option?\nThe text leading up to this was:\n--------------------------\n|From c9a40292a44e78f71258b8522655bffaf5753bdb Mon Sep 17 00:00:00 2001\n|From: Jens Axboe <axboe@kernel.dk>\n|Date: Wed, 8 Jan 2025 10:28:05 -0700\n|Subject: [PATCH] io_uring/eventfd: ensure io_eventfd_signal() defers another\n| RCU period\n|\n|io_eventfd_do_signal() is invoked from an RCU callback, but when\n|dropping the reference to the io_ev_fd, it calls io_eventfd_free()\n|directly if the refcount drops to zero. This isn't correct, as any\n|potential freeing of the io_ev_fd should be deferred another RCU grace\n|period.\n|\n|Just call io_eventfd_put() rather than open-code the dec-and-test and\n|free, which will correctly defer it another RCU grace period.\n|\n|Fixes: 21a091b970cd (\"io_uring: signal registered eventfd to process deferred task work\")\n|Reported-by: Jann Horn <jannh@google.com>\n|Cc: stable@vger.kernel.org\n|Tested-by: Li Zetao <lizetao1@huawei.com>\n|Reviewed-by: Li Zetao<lizetao1@huawei.com>\n|Reviewed-by: Prasanna Kumar T S M <ptsm@linux.microsoft.com>\n|Signed-off-by: Jens Axboe <axboe@kernel.dk>\n|---\n| io_uring/eventfd.c | 16 +++++++---------\n| 1 file changed, 7 insertions(+), 9 deletions(-)\n|\n|diff --git a/io_uring/eventfd.c b/io_uring/eventfd.c\n|index fab936d31ba8..100d5da94cb9 100644\n|--- a/io_uring/eventfd.c\n|+++ b/io_uring/eventfd.c\n--------------------------\nFile to patch: \nSkip this patch? [y] \nSkipping patch.\n1 out of 1 hunk ignored",
              "total_hunks": 0,
              "total_failed_hunks": 0,
              "failed_hunks": [],
              "rej_file_content": "No rejected diff content found.",
              "inline_merge_conflict": "No conflict markers found."
            },
            {
              "downstream_patch": "a7085c3ae43b86d4b3d1b8275e6a67f14257e3b7",
              "downstream_commit": "cbb64f5d757fe18e5ac7a6ffb67e8264f2992996",
              "commit_date": "2025-01-17 13:40:58 +0100",
              "result": "failure",
              "error": "patching file io_uring/eventfd.c\nHunk #1 FAILED at 33.\n1 out of 1 hunk FAILED -- saving rejects to file io_uring/eventfd.c.rej",
              "total_hunks": 0,
              "total_failed_hunks": 1,
              "failed_hunks": [1],
              "rej_file_content": "```diff\n--- io_uring/eventfd.c.rej ---\n--- io_uring/eventfd.c\n+++ io_uring/eventfd.c\n@@ -33,20 +33,18 @@ static void io_eventfd_free(struct rcu_head *rcu)\n \tkfree(ev_fd);\n }\n \n-static void io_eventfd_do_signal(struct rcu_head *rcu)\n+static void io_eventfd_put(struct io_ev_fd *ev_fd)\n {\n-\tstruct io_ev_fd *ev_fd = container_of(rcu, struct io_ev_fd, rcu);\n-\n-\teventfd_signal_mask(ev_fd->cq_ev_fd, EPOLL_URING_WAKE);\n-\n \tif (refcount_dec_and_test(&ev_fd->refs))\n-\t\tio_eventfd_free(rcu);\n+\t\tcall_rcu(&ev_fd->rcu, io_eventfd_free);\n }\n \n-static void io_eventfd_put(struct io_ev_fd *ev_fd)\n+static void io_eventfd_do_signal(struct rcu_head *rcu)\n {\n-\tif (refcount_dec_and_test(&ev_fd->refs))\n-\t\tcall_rcu(&ev_fd->rcu, io_eventfd_free);\n+\tstruct io_ev_fd *ev_fd = container_of(rcu, struct io_ev_fd, rcu);\n+\n+\teventfd_signal_mask(ev_fd->cq_ev_fd, EPOLL_URING_WAKE);\n+\tio_eventfd_put(ev_fd);\n }\n \n static void io_eventfd_release(struct io_ev_fd *ev_fd, bool put_ref)\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- void io_eventfd_signal(struct io_ring_ctx *ctx)\n=======\n+ static void io_eventfd_do_signal(struct rcu_head *rcu)\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tstruct io_ev_fd *ev_fd = NULL;\n=======\n+ \tstruct io_ev_fd *ev_fd = container_of(rcu, struct io_ev_fd, rcu);\n+ \n+ \teventfd_signal_mask(ev_fd->cq_ev_fd, EPOLL_URING_WAKE);\n+ \tio_eventfd_put(ev_fd);\n+ }\n>>>>>>> INCOMING PATCH\n```"
            }
          ]
        }
      ]
    },
    {
      "cve_url": "https://web.git.kernel.org/pub/scm/linux/security/vulns.git/plain/cve/published/2025/CVE-2025-21659.json",
      "patch_attempts": [
        {
          "upstream_commit": "db78475ba0d3c66d430f7ded2388cc041078a542",
          "upstream_commit_date": "2025-01-08 10:21:00 -0800",
          "upstream_patch": "d1cacd74776895f6435941f86a1130e58f6dd226",
          "total_versions_tested": 1,
          "successful_patches": 0,
          "failed_patches": 1,
          "patch_results": [
            {
              "downstream_patch": "b683ba0df11ff563cc237eb1b74d6adfa77226bf",
              "downstream_commit": "c08d7fcce7cc01f77087d18cd60f317244436548",
              "commit_date": "2025-01-17 13:41:00 +0100",
              "result": "failure",
              "error": "patching file net/core/dev.c\nHunk #2 succeeded at 6321 (offset -2 lines).\npatching file net/core/dev.h\nHunk #2 succeeded at 148 (offset -123 lines).\npatching file net/core/netdev-genl.c\nHunk #1 succeeded at 164 (offset -3 lines).\nHunk #2 succeeded at 214 (offset -18 lines).\nHunk #3 FAILED at 353.\n1 out of 3 hunks FAILED -- saving rejects to file net/core/netdev-genl.c.rej",
              "total_hunks": 3,
              "total_failed_hunks": 1,
              "failed_hunks": [3],
              "rej_file_content": "```diff\n--- net/core/netdev-genl.c.rej ---\n--- net/core/netdev-genl.c\n+++ net/core/netdev-genl.c\n@@ -353,7 +351,7 @@ int netdev_nl_napi_set_doit(struct sk_buff *skb, struct genl_info *info)\n \trtnl_lock();\n \trcu_read_lock();\n \n-\tnapi = napi_by_id(napi_id);\n+\tnapi = netdev_napi_by_id(genl_info_net(info), napi_id);\n \tif (napi) {\n \t\terr = netdev_nl_napi_set_config(napi, info);\n \t} else {\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n\n=======\n+ }\n+ EXPORT_SYMBOL(napi_complete_done);\n+ \n+ static void skb_defer_free_flush(struct softnet_data *sd)\n+ {\n+ \tstruct sk_buff *skb, *next;\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n\n=======\n+ \tnapi = netdev_napi_by_id(genl_info_net(info), napi_id);\n+ \tif (napi) {\n+ \t\terr = netdev_nl_napi_set_config(napi, info);\n+ \t} else {\n>>>>>>> INCOMING PATCH\n```"
            }
          ]
        }
      ]
    },
    {
      "cve_url": "https://web.git.kernel.org/pub/scm/linux/security/vulns.git/plain/cve/published/2025/CVE-2025-21693.json",
      "patch_attempts": [
        {
          "upstream_commit": "4dff389c9f1dd787e8058930b3fbd3248a6238c5",
          "upstream_commit_date": "2025-01-12 19:03:36 -0800",
          "upstream_patch": "12dcb0ef540629a281533f9dedc1b6b8e14cfb65",
          "total_versions_tested": 1,
          "successful_patches": 0,
          "failed_patches": 1,
          "patch_results": [
            {
              "downstream_patch": "8d29ff5d50304daa41dc3cfdda4a9d1e46cf5be1",
              "downstream_commit": "f5712784c9886d197e8616d149890b9d1cc6ea8e",
              "commit_date": "2025-02-01 18:39:36 +0100",
              "result": "failure",
              "error": "patching file mm/zswap.c\nHunk #3 succeeded at 819 (offset -5 lines).\nHunk #4 succeeded at 854 (offset -5 lines).\nHunk #5 FAILED at 876.\nHunk #6 FAILED at 900.\nHunk #7 succeeded at 950 (offset -6 lines).\nHunk #8 succeeded at 961 (offset -6 lines).\nHunk #9 succeeded at 985 (offset -6 lines).\n2 out of 9 hunks FAILED -- saving rejects to file mm/zswap.c.rej",
              "total_hunks": 9,
              "total_failed_hunks": 2,
              "failed_hunks": [5, 6],
              "rej_file_content": "```diff\n--- mm/zswap.c.rej ---\n--- mm/zswap.c\n+++ mm/zswap.c\n@@ -876,17 +883,45 @@ static int zswap_cpu_comp_dead(unsigned int cpu, struct hlist_node *node)\n \tstruct zswap_pool *pool = hlist_entry(node, struct zswap_pool, node);\n \tstruct crypto_acomp_ctx *acomp_ctx = per_cpu_ptr(pool->acomp_ctx, cpu);\n \n+\tmutex_lock(&acomp_ctx->mutex);\n \tif (!IS_ERR_OR_NULL(acomp_ctx)) {\n \t\tif (!IS_ERR_OR_NULL(acomp_ctx->req))\n \t\t\tacomp_request_free(acomp_ctx->req);\n+\t\tacomp_ctx->req = NULL;\n \t\tif (!IS_ERR_OR_NULL(acomp_ctx->acomp))\n \t\t\tcrypto_free_acomp(acomp_ctx->acomp);\n \t\tkfree(acomp_ctx->buffer);\n \t}\n+\tmutex_unlock(&acomp_ctx->mutex);\n \n \treturn 0;\n }\n \n+static struct crypto_acomp_ctx *acomp_ctx_get_cpu_lock(struct zswap_pool *pool)\n+{\n+\tstruct crypto_acomp_ctx *acomp_ctx;\n+\n+\tfor (;;) {\n+\t\tacomp_ctx = raw_cpu_ptr(pool->acomp_ctx);\n+\t\tmutex_lock(&acomp_ctx->mutex);\n+\t\tif (likely(acomp_ctx->req))\n+\t\t\treturn acomp_ctx;\n+\t\t/*\n+\t\t * It is possible that we were migrated to a different CPU after\n+\t\t * getting the per-CPU ctx but before the mutex was acquired. If\n+\t\t * the old CPU got offlined, zswap_cpu_comp_dead() could have\n+\t\t * already freed ctx->req (among other things) and set it to\n+\t\t * NULL. Just try again on the new CPU that we ended up on.\n+\t\t */\n+\t\tmutex_unlock(&acomp_ctx->mutex);\n+\t}\n+}\n+\n+static void acomp_ctx_put_unlock(struct crypto_acomp_ctx *acomp_ctx)\n+{\n+\tmutex_unlock(&acomp_ctx->mutex);\n+}\n+\n static bool zswap_compress(struct page *page, struct zswap_entry *entry,\n \t\t\t   struct zswap_pool *pool)\n {\n@@ -900,10 +935,7 @@ static bool zswap_compress(struct page *page, struct zswap_entry *entry,\n \tgfp_t gfp;\n \tu8 *dst;\n \n-\tacomp_ctx = raw_cpu_ptr(pool->acomp_ctx);\n-\n-\tmutex_lock(&acomp_ctx->mutex);\n-\n+\tacomp_ctx = acomp_ctx_get_cpu_lock(pool);\n \tdst = acomp_ctx->buffer;\n \tsg_init_table(&input, 1);\n \tsg_set_page(&input, page, PAGE_SIZE, 0);\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- static bool zswap_compress(struct folio *folio, struct zswap_entry *entry)\n=======\n+ static struct crypto_acomp_ctx *acomp_ctx_get_cpu_lock(struct zswap_pool *pool)\n+ {\n+ \tstruct crypto_acomp_ctx *acomp_ctx;\n+ \n+ \tfor (;;) {\n+ \t\tacomp_ctx = raw_cpu_ptr(pool->acomp_ctx);\n+ \t\tmutex_lock(&acomp_ctx->mutex);\n+ \t\tif (likely(acomp_ctx->req))\n+ \t\t\treturn acomp_ctx;\n+ \t\t/*\n+ \t\t * It is possible that we were migrated to a different CPU after\n+ \t\t * getting the per-CPU ctx but before the mutex was acquired. If\n+ \t\t * the old CPU got offlined, zswap_cpu_comp_dead() could have\n+ \t\t * already freed ctx->req (among other things) and set it to\n+ \t\t * NULL. Just try again on the new CPU that we ended up on.\n+ \t\t */\n+ \t\tmutex_unlock(&acomp_ctx->mutex);\n+ \t}\n+ }\n+ \n+ static void acomp_ctx_put_unlock(struct crypto_acomp_ctx *acomp_ctx)\n+ {\n+ \tmutex_unlock(&acomp_ctx->mutex);\n+ }\n+ \n+ static bool zswap_compress(struct page *page, struct zswap_entry *entry,\n+ \t\t\t   struct zswap_pool *pool)\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tacomp_ctx = raw_cpu_ptr(entry->pool->acomp_ctx);\n- \n- \tmutex_lock(&acomp_ctx->mutex);\n- \n=======\n+ \tacomp_ctx = acomp_ctx_get_cpu_lock(pool);\n>>>>>>> INCOMING PATCH\n```"
            }
          ]
        }
      ]
    },
    {
      "cve_url": "https://web.git.kernel.org/pub/scm/linux/security/vulns.git/plain/cve/published/2025/CVE-2025-21836.json",
      "patch_attempts": [
        {
          "upstream_commit": "06521ac0485effdcc9c792cb0b40ed8e6f2f5fb8",
          "upstream_commit_date": "2025-02-12 07:30:52 -0700",
          "upstream_patch": "8802766324e1f5d414a81ac43365c20142e85603",
          "total_versions_tested": 3,
          "successful_patches": 0,
          "failed_patches": 3,
          "patch_results": [
            {
              "downstream_patch": "146a185f6c05ee263db715f860620606303c4633",
              "downstream_commit": "4c8f958a07ffb6c076985980fc512f8853790943",
              "commit_date": "2025-02-21 13:57:27 +0100",
              "result": "failure",
              "error": "patching file io_uring/kbuf.c\nHunk #1 succeeded at 301 (offset -114 lines).\nHunk #2 FAILED at 643.\n1 out of 2 hunks FAILED -- saving rejects to file io_uring/kbuf.c.rej",
              "total_hunks": 2,
              "total_failed_hunks": 1,
              "failed_hunks": [2],
              "rej_file_content": "```diff\n--- io_uring/kbuf.c.rej ---\n--- io_uring/kbuf.c\n+++ io_uring/kbuf.c\n@@ -643,12 +650,13 @@ int io_register_pbuf_ring(struct io_ring_ctx *ctx, void __user *arg)\n \t\t/* if mapped buffer ring OR classic exists, don't allow */\n \t\tif (bl->flags & IOBL_BUF_RING || !list_empty(&bl->buf_list))\n \t\t\treturn -EEXIST;\n-\t} else {\n-\t\tfree_bl = bl = kzalloc(sizeof(*bl), GFP_KERNEL);\n-\t\tif (!bl)\n-\t\t\treturn -ENOMEM;\n+\t\tio_destroy_bl(ctx, bl);\n \t}\n \n+\tfree_bl = bl = kzalloc(sizeof(*bl), GFP_KERNEL);\n+\tif (!bl)\n+\t\treturn -ENOMEM;\n+\n \tmmap_offset = (unsigned long)reg.bgid << IORING_OFF_PBUF_SHIFT;\n \tring_size = flex_array_size(br, bufs, reg.ring_entries);\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tif (!(reg.flags & IOU_PBUF_RING_MMAP))\n- \t\tret = io_pin_pbuf_ring(&reg, bl);\n- \telse\n- \t\tret = io_alloc_pbuf_ring(ctx, &reg, bl);\n=======\n+ \tfree_bl = bl = kzalloc(sizeof(*bl), GFP_KERNEL);\n+ \tif (!bl)\n+ \t\treturn -ENOMEM;\n+ \n+ \tmmap_offset = (unsigned long)reg.bgid << IORING_OFF_PBUF_SHIFT;\n+ \tring_size = flex_array_size(br, bufs, reg.ring_entries);\n>>>>>>> INCOMING PATCH\n```"
            },
            {
              "downstream_patch": "7d0dc28dae836caf7645fef62a10befc624dd17b",
              "downstream_commit": "13129b1fbfff5f94291f98c8fec7875e099a2ae6",
              "commit_date": "2025-02-21 14:01:47 +0100",
              "result": "failure",
              "error": "patching file io_uring/kbuf.c\nHunk #1 succeeded at 420 (offset 5 lines).\nHunk #2 FAILED at 643.\n1 out of 2 hunks FAILED -- saving rejects to file io_uring/kbuf.c.rej",
              "total_hunks": 2,
              "total_failed_hunks": 1,
              "failed_hunks": [2],
              "rej_file_content": "```diff\n--- io_uring/kbuf.c.rej ---\n--- io_uring/kbuf.c\n+++ io_uring/kbuf.c\n@@ -643,12 +650,13 @@ int io_register_pbuf_ring(struct io_ring_ctx *ctx, void __user *arg)\n \t\t/* if mapped buffer ring OR classic exists, don't allow */\n \t\tif (bl->flags & IOBL_BUF_RING || !list_empty(&bl->buf_list))\n \t\t\treturn -EEXIST;\n-\t} else {\n-\t\tfree_bl = bl = kzalloc(sizeof(*bl), GFP_KERNEL);\n-\t\tif (!bl)\n-\t\t\treturn -ENOMEM;\n+\t\tio_destroy_bl(ctx, bl);\n \t}\n \n+\tfree_bl = bl = kzalloc(sizeof(*bl), GFP_KERNEL);\n+\tif (!bl)\n+\t\treturn -ENOMEM;\n+\n \tmmap_offset = (unsigned long)reg.bgid << IORING_OFF_PBUF_SHIFT;\n \tring_size = flex_array_size(br, bufs, reg.ring_entries);\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tif (!(reg.flags & IOU_PBUF_RING_MMAP))\n- \t\tret = io_pin_pbuf_ring(&reg, bl);\n- \telse\n- \t\tret = io_alloc_pbuf_ring(ctx, &reg, bl);\n=======\n+ \tfree_bl = bl = kzalloc(sizeof(*bl), GFP_KERNEL);\n+ \tif (!bl)\n+ \t\treturn -ENOMEM;\n+ \n+ \tmmap_offset = (unsigned long)reg.bgid << IORING_OFF_PBUF_SHIFT;\n+ \tring_size = flex_array_size(br, bufs, reg.ring_entries);\n>>>>>>> INCOMING PATCH\n```"
            },
            {
              "downstream_patch": "2a5febbef40ce968e295a7aeaa5d5cbd9e3e5ad4",
              "downstream_commit": "cda72d861dd3f6299a6045ded5360d01eeb67625",
              "commit_date": "2025-02-21 14:11:20 +0100",
              "result": "failure",
              "error": "patching file io_uring/kbuf.c\nHunk #1 succeeded at 420 (offset 5 lines).\nHunk #2 FAILED at 643.\n1 out of 2 hunks FAILED -- saving rejects to file io_uring/kbuf.c.rej",
              "total_hunks": 2,
              "total_failed_hunks": 1,
              "failed_hunks": [2],
              "rej_file_content": "```diff\n--- io_uring/kbuf.c.rej ---\n--- io_uring/kbuf.c\n+++ io_uring/kbuf.c\n@@ -643,12 +650,13 @@ int io_register_pbuf_ring(struct io_ring_ctx *ctx, void __user *arg)\n \t\t/* if mapped buffer ring OR classic exists, don't allow */\n \t\tif (bl->flags & IOBL_BUF_RING || !list_empty(&bl->buf_list))\n \t\t\treturn -EEXIST;\n-\t} else {\n-\t\tfree_bl = bl = kzalloc(sizeof(*bl), GFP_KERNEL);\n-\t\tif (!bl)\n-\t\t\treturn -ENOMEM;\n+\t\tio_destroy_bl(ctx, bl);\n \t}\n \n+\tfree_bl = bl = kzalloc(sizeof(*bl), GFP_KERNEL);\n+\tif (!bl)\n+\t\treturn -ENOMEM;\n+\n \tmmap_offset = (unsigned long)reg.bgid << IORING_OFF_PBUF_SHIFT;\n \tring_size = flex_array_size(br, bufs, reg.ring_entries);\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tif (!(reg.flags & IOU_PBUF_RING_MMAP))\n- \t\tret = io_pin_pbuf_ring(&reg, bl);\n- \telse\n- \t\tret = io_alloc_pbuf_ring(ctx, &reg, bl);\n=======\n+ \tfree_bl = bl = kzalloc(sizeof(*bl), GFP_KERNEL);\n+ \tif (!bl)\n+ \t\treturn -ENOMEM;\n+ \n+ \tmmap_offset = (unsigned long)reg.bgid << IORING_OFF_PBUF_SHIFT;\n+ \tring_size = flex_array_size(br, bufs, reg.ring_entries);\n>>>>>>> INCOMING PATCH\n```"
            }
          ]
        }
      ]
    }
  ],
  "cves_with_partial_failures": [
    {
      "cve_url": "https://web.git.kernel.org/pub/scm/linux/security/vulns.git/plain/cve/published/2025/CVE-2025-21639.json",
      "patch_attempts": [
        {
          "upstream_commit": "ea62dd1383913b5999f3d16ae99d411f41b528d4",
          "upstream_commit_date": "2025-01-09 08:53:34 -0800",
          "upstream_patch": "9fc17b76fc70763780aa78b38fcf4742384044a5",
          "total_versions_tested": 6,
          "successful_patches": 4,
          "failed_patches": 2,
          "patch_results": [
            {
              "downstream_patch": "c8d179f3b1c1d60bf4484f50aa67b4c70f91bff9",
              "downstream_commit": "58f9e20e2a7602e1dd649a1ec4790077c251cb6c",
              "commit_date": "2025-02-01 18:18:49 +0100",
              "result": "failure",
              "error": "patching file net/sctp/sysctl.c\nHunk #1 succeeded at 401 with fuzz 2 (offset -32 lines).\nHunk #2 FAILED at 461.\n1 out of 2 hunks FAILED -- saving rejects to file net/sctp/sysctl.c.rej",
              "total_hunks": 2,
              "total_failed_hunks": 1,
              "failed_hunks": [2],
              "rej_file_content": "```diff\n--- net/sctp/sysctl.c.rej ---\n--- net/sctp/sysctl.c\n+++ net/sctp/sysctl.c\n@@ -461,7 +461,7 @@ static int proc_sctp_do_rto_min(const struct ctl_table *ctl, int write,\n static int proc_sctp_do_rto_max(const struct ctl_table *ctl, int write,\n \t\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n {\n-\tstruct net *net = current->nsproxy->net_ns;\n+\tstruct net *net = container_of(ctl->data, struct net, sctp.rto_max);\n \tunsigned int min = *(unsigned int *) ctl->extra1;\n \tunsigned int max = *(unsigned int *) ctl->extra2;\n \tstruct ctl_table tbl;\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n\n=======\n+ static int proc_sctp_do_rto_max(const struct ctl_table *ctl, int write,\n+ \t\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n+ {\n+ \tstruct net *net = container_of(ctl->data, struct net, sctp.rto_max);\n>>>>>>> INCOMING PATCH\n```"
            },
            {
              "downstream_patch": "246428bfb9e7db15c5cd08e1d0eca41b65af2b06",
              "downstream_commit": "acec80d9f126cd3fa764bbe3d96bc0cb5cd2b087",
              "commit_date": "2025-02-01 18:22:26 +0100",
              "result": "failure",
              "error": "patching file net/sctp/sysctl.c\nHunk #1 succeeded at 424 with fuzz 1 (offset -9 lines).\nHunk #2 FAILED at 461.\n1 out of 2 hunks FAILED -- saving rejects to file net/sctp/sysctl.c.rej",
              "total_hunks": 2,
              "total_failed_hunks": 1,
              "failed_hunks": [2],
              "rej_file_content": "```diff\n--- net/sctp/sysctl.c.rej ---\n--- net/sctp/sysctl.c\n+++ net/sctp/sysctl.c\n@@ -461,7 +461,7 @@ static int proc_sctp_do_rto_min(const struct ctl_table *ctl, int write,\n static int proc_sctp_do_rto_max(const struct ctl_table *ctl, int write,\n \t\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n {\n-\tstruct net *net = current->nsproxy->net_ns;\n+\tstruct net *net = container_of(ctl->data, struct net, sctp.rto_max);\n \tunsigned int min = *(unsigned int *) ctl->extra1;\n \tunsigned int max = *(unsigned int *) ctl->extra2;\n \tstruct ctl_table tbl;\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tstruct net *net = container_of(ctl->data, struct net, sctp.rto_min);\n=======\n+ \tstruct net *net = container_of(ctl->data, struct net, sctp.rto_max);\n>>>>>>> INCOMING PATCH\n```"
            }
          ]
        }
      ]
    },
    {
      "cve_url": "https://web.git.kernel.org/pub/scm/linux/security/vulns.git/plain/cve/published/2025/CVE-2025-21647.json",
      "patch_attempts": [
        {
          "upstream_commit": "2d2d4f60ed266a8f340a721102d035252606980b",
          "upstream_commit_date": "2025-01-09 08:18:41 -0800",
          "upstream_patch": "737d4d91d35b5f7fa5bb442651472277318b0bfd",
          "total_versions_tested": 6,
          "successful_patches": 3,
          "failed_patches": 3,
          "patch_results": [
            {
              "downstream_patch": "44fe1efb4961c1a5ccab16bb579dfc6b308ad58b",
              "downstream_commit": "2a29413ace64627e178fd422dd8a5d95219a2c0b",
              "commit_date": "2025-03-13 12:43:04 +0100",
              "result": "failure",
              "error": "patching file net/sched/sch_cake.c\nHunk #1 succeeded at 622 (offset -5 lines).\nHunk #2 succeeded at 810 (offset -20 lines).\nHunk #3 succeeded at 836 (offset -20 lines).\nHunk #4 succeeded at 860 (offset -20 lines).\nHunk #5 succeeded at 1878 (offset -18 lines).\nHunk #6 succeeded at 1887 (offset -18 lines).\nHunk #7 succeeded at 1896 (offset -18 lines).\nHunk #8 succeeded at 1954 (offset -18 lines).\nHunk #9 succeeded at 2058 (offset -18 lines).\nHunk #10 succeeded at 2069 (offset -18 lines).\nHunk #11 FAILED at 2100.\nHunk #12 succeeded at 2118 (offset -18 lines).\nHunk #13 succeeded at 2137 (offset -18 lines).\n1 out of 13 hunks FAILED -- saving rejects to file net/sched/sch_cake.c.rej",
              "total_hunks": 13,
              "total_failed_hunks": 1,
              "failed_hunks": [11],
              "rej_file_content": "```diff\n--- net/sched/sch_cake.c.rej ---\n--- net/sched/sch_cake.c\n+++ net/sched/sch_cake.c\n@@ -2100,19 +2129,7 @@ static struct sk_buff *cake_dequeue(struct Qdisc *sch)\n \t\t\t}\n \t\t}\n \n-\t\tif (cake_dsrc(q->flow_mode))\n-\t\t\thost_load = max(host_load, srchost->srchost_bulk_flow_count);\n-\n-\t\tif (cake_ddst(q->flow_mode))\n-\t\t\thost_load = max(host_load, dsthost->dsthost_bulk_flow_count);\n-\n-\t\tWARN_ON(host_load > CAKE_QUEUES);\n-\n-\t\t/* The get_random_u16() is a way to apply dithering to avoid\n-\t\t * accumulating roundoff errors\n-\t\t */\n-\t\tflow->deficit += (b->flow_quantum * quantum_div[host_load] +\n-\t\t\t\t  get_random_u16()) >> 16;\n+\t\tflow->deficit += cake_get_flow_quantum(b, flow, q->flow_mode);\n \t\tlist_move_tail(&flow->flowchain, &b->old_flows);\n \n \t\tgoto retry;\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t\tif (cake_dsrc(q->flow_mode))\n- \t\t\thost_load = max(host_load, srchost->srchost_bulk_flow_count);\n- \n- \t\tif (cake_ddst(q->flow_mode))\n- \t\t\thost_load = max(host_load, dsthost->dsthost_bulk_flow_count);\n- \n- \t\tWARN_ON(host_load > CAKE_QUEUES);\n- \n- \t\t/* The shifted prandom_u32() is a way to apply dithering to\n- \t\t * avoid accumulating roundoff errors\n=======\n+ \t\tflow->deficit = cake_get_flow_quantum(b, flow, q->flow_mode);\n+ \t} else if (flow->set == CAKE_SET_SPARSE_WAIT) {\n+ \t\t/* this flow was empty, accounted as a sparse flow, but actually\n+ \t\t * in the bulk rotation.\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t\tflow->deficit += (b->flow_quantum * quantum_div[host_load] +\n- \t\t\t\t  (prandom_u32() >> 16)) >> 16;\n- \t\tlist_move_tail(&flow->flowchain, &b->old_flows);\n- \n- \t\tgoto retry;\n=======\n+ \t\tb->sparse_flow_count--;\n+ \t\tb->bulk_flow_count++;\n+ \n+ \t\tcake_inc_srchost_bulk_flow_count(b, flow, q->flow_mode);\n+ \t\tcake_inc_dsthost_bulk_flow_count(b, flow, q->flow_mode);\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t/* Retrieve a packet via the AQM */\n- \twhile (1) {\n- \t\tskb = cake_dequeue_one(sch);\n- \t\tif (!skb) {\n- \t\t\t/* this queue was actually empty */\n- \t\t\tif (cobalt_queue_empty(&flow->cvars, &b->cparams, now))\n- \t\t\t\tb->unresponsive_flow_count--;\n=======\n+ {\n+ \tstruct cake_sched_data *q = qdisc_priv(sch);\n+ \tstruct cake_tin_data *b = &q->tins[q->cur_tin];\n+ \tktime_t now = ktime_get();\n+ \tstruct cake_flow *flow;\n+ \tstruct list_head *head;\n+ \tbool first_flow = true;\n+ \tstruct sk_buff *skb;\n+ \tu64 delay;\n+ \tu32 len;\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t\t\t\t\tcake_dec_srchost_bulk_flow_count(b, flow, q->flow_mode);\n- \t\t\t\t\tcake_dec_dsthost_bulk_flow_count(b, flow, q->flow_mode);\n- \n=======\n+ \t/* flow isolation (DRR++) */\n+ \tif (flow->deficit <= 0) {\n+ \t\t/* Keep all flows with deficits out of the sparse and decaying\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t\t\t\t\tb->decaying_flow_count++;\n- \t\t\t\t} else if (flow->set == CAKE_SET_SPARSE ||\n- \t\t\t\t\t   flow->set == CAKE_SET_SPARSE_WAIT) {\n- \t\t\t\t\tb->sparse_flow_count--;\n- \t\t\t\t\tb->decaying_flow_count++;\n- \t\t\t\t}\n- \t\t\t\tflow->set = CAKE_SET_DECAYING;\n=======\n+ \t\t\t\tb->sparse_flow_count--;\n+ \t\t\t\tb->bulk_flow_count++;\n+ \n+ \t\t\t\tcake_inc_srchost_bulk_flow_count(b, flow, q->flow_mode);\n+ \t\t\t\tcake_inc_dsthost_bulk_flow_count(b, flow, q->flow_mode);\n+ \n+ \t\t\t\tflow->set = CAKE_SET_BULK;\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t\t\t\t/* remove empty queue from the flowchain */\n- \t\t\t\tlist_del_init(&flow->flowchain);\n- \t\t\t\tif (flow->set == CAKE_SET_SPARSE ||\n- \t\t\t\t    flow->set == CAKE_SET_SPARSE_WAIT)\n- \t\t\t\t\tb->sparse_flow_count--;\n- \t\t\t\telse if (flow->set == CAKE_SET_BULK) {\n- \t\t\t\t\tb->bulk_flow_count--;\n- \n- \t\t\t\t\tcake_dec_srchost_bulk_flow_count(b, flow, q->flow_mode);\n- \t\t\t\t\tcake_dec_dsthost_bulk_flow_count(b, flow, q->flow_mode);\n- \t\t\t\t} else\n- \t\t\t\t\tb->decaying_flow_count--;\n- \n- \t\t\t\tflow->set = CAKE_SET_NONE;\n- \t\t\t}\n- \t\t\tgoto begin;\n- \t\t}\n=======\n+ \t\t\t}\n+ \t\t}\n+ \n+ \t\tflow->deficit += cake_get_flow_quantum(b, flow, q->flow_mode);\n+ \t\tlist_move_tail(&flow->flowchain, &b->old_flows);\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t\t/* Last packet in queue may be marked, shouldn't be dropped */\n- \t\tif (!cobalt_should_drop(&flow->cvars, &b->cparams, now, skb,\n- \t\t\t\t\t(b->bulk_flow_count *\n- \t\t\t\t\t !!(q->rate_flags &\n- \t\t\t\t\t    CAKE_FLAG_INGRESS))) ||\n- \t\t    !flow->head)\n- \t\t\tbreak;\n=======\n+ \t\t\t\tif (flow->set == CAKE_SET_BULK) {\n+ \t\t\t\t\tb->bulk_flow_count--;\n+ \n+ \t\t\t\t\tcake_dec_srchost_bulk_flow_count(b, flow, q->flow_mode);\n+ \t\t\t\t\tcake_dec_dsthost_bulk_flow_count(b, flow, q->flow_mode);\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t\t/* drop this packet, get another one */\n- \t\tif (q->rate_flags & CAKE_FLAG_INGRESS) {\n- \t\t\tlen = cake_advance_shaper(q, b, skb,\n- \t\t\t\t\t\t  now, true);\n- \t\t\tflow->deficit -= len;\n- \t\t\tb->tin_deficit -= len;\n- \t\t}\n- \t\tflow->dropped++;\n- \t\tb->tin_dropped++;\n- \t\tqdisc_tree_reduce_backlog(sch, 1, qdisc_pkt_len(skb));\n- \t\tqdisc_qstats_drop(sch);\n- \t\tkfree_skb(skb);\n=======\n+ \t\t\t\telse if (flow->set == CAKE_SET_BULK) {\n+ \t\t\t\t\tb->bulk_flow_count--;\n+ \n+ \t\t\t\t\tcake_dec_srchost_bulk_flow_count(b, flow, q->flow_mode);\n+ \t\t\t\t\tcake_dec_dsthost_bulk_flow_count(b, flow, q->flow_mode);\n+ \t\t\t\t} else\n+ \t\t\t\t\tb->decaying_flow_count--;\n+ \n>>>>>>> INCOMING PATCH\n```"
            },
            {
              "downstream_patch": "b1a1743aaa4906c41c426eda97e2e2586f79246d",
              "downstream_commit": "c6acb650a73d5705a93b9c5a2cd5e9c8161f0be3",
              "commit_date": "2025-03-13 12:47:44 +0100",
              "result": "failure",
              "error": "patching file net/sched/sch_cake.c\nHunk #1 succeeded at 643 (offset 16 lines).\nHunk #2 succeeded at 846 (offset 16 lines).\nHunk #3 succeeded at 872 (offset 16 lines).\nHunk #4 succeeded at 896 (offset 16 lines).\nHunk #5 succeeded at 1912 (offset 16 lines).\nHunk #6 succeeded at 1921 (offset 16 lines).\nHunk #7 succeeded at 1930 (offset 16 lines).\nHunk #8 succeeded at 1988 (offset 16 lines).\nHunk #9 succeeded at 2092 (offset 16 lines).\nHunk #10 succeeded at 2103 (offset 16 lines).\nHunk #11 FAILED at 2100.\nHunk #12 succeeded at 2152 (offset 16 lines).\nHunk #13 succeeded at 2171 (offset 16 lines).\n1 out of 13 hunks FAILED -- saving rejects to file net/sched/sch_cake.c.rej",
              "total_hunks": 13,
              "total_failed_hunks": 1,
              "failed_hunks": [11],
              "rej_file_content": "```diff\n--- net/sched/sch_cake.c.rej ---\n--- net/sched/sch_cake.c\n+++ net/sched/sch_cake.c\n@@ -2100,19 +2129,7 @@ static struct sk_buff *cake_dequeue(struct Qdisc *sch)\n \t\t\t}\n \t\t}\n \n-\t\tif (cake_dsrc(q->flow_mode))\n-\t\t\thost_load = max(host_load, srchost->srchost_bulk_flow_count);\n-\n-\t\tif (cake_ddst(q->flow_mode))\n-\t\t\thost_load = max(host_load, dsthost->dsthost_bulk_flow_count);\n-\n-\t\tWARN_ON(host_load > CAKE_QUEUES);\n-\n-\t\t/* The get_random_u16() is a way to apply dithering to avoid\n-\t\t * accumulating roundoff errors\n-\t\t */\n-\t\tflow->deficit += (b->flow_quantum * quantum_div[host_load] +\n-\t\t\t\t  get_random_u16()) >> 16;\n+\t\tflow->deficit += cake_get_flow_quantum(b, flow, q->flow_mode);\n \t\tlist_move_tail(&flow->flowchain, &b->old_flows);\n \n \t\tgoto retry;\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t\tif (cake_dsrc(q->flow_mode))\n- \t\t\thost_load = max(host_load, srchost->srchost_bulk_flow_count);\n- \n- \t\tif (cake_ddst(q->flow_mode))\n- \t\t\thost_load = max(host_load, dsthost->dsthost_bulk_flow_count);\n- \n- \t\tWARN_ON(host_load > CAKE_QUEUES);\n- \n- \t\t/* The shifted prandom_u32() is a way to apply dithering to\n- \t\t * avoid accumulating roundoff errors\n=======\n+ \t\tflow->deficit = cake_get_flow_quantum(b, flow, q->flow_mode);\n+ \t} else if (flow->set == CAKE_SET_SPARSE_WAIT) {\n+ \t\t/* this flow was empty, accounted as a sparse flow, but actually\n+ \t\t * in the bulk rotation.\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t\tflow->deficit += (b->flow_quantum * quantum_div[host_load] +\n- \t\t\t\t  (prandom_u32() >> 16)) >> 16;\n- \t\tlist_move_tail(&flow->flowchain, &b->old_flows);\n- \n- \t\tgoto retry;\n=======\n+ \t\tb->sparse_flow_count--;\n+ \t\tb->bulk_flow_count++;\n+ \n+ \t\tcake_inc_srchost_bulk_flow_count(b, flow, q->flow_mode);\n+ \t\tcake_inc_dsthost_bulk_flow_count(b, flow, q->flow_mode);\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t/* Retrieve a packet via the AQM */\n- \twhile (1) {\n- \t\tskb = cake_dequeue_one(sch);\n- \t\tif (!skb) {\n- \t\t\t/* this queue was actually empty */\n- \t\t\tif (cobalt_queue_empty(&flow->cvars, &b->cparams, now))\n- \t\t\t\tb->unresponsive_flow_count--;\n- \n- \t\t\tif (flow->cvars.p_drop || flow->cvars.count ||\n- \t\t\t    ktime_before(now, flow->cvars.drop_next)) {\n- \t\t\t\t/* keep in the flowchain until the state has\n- \t\t\t\t * decayed to rest\n- \t\t\t\t */\n- \t\t\t\tlist_move_tail(&flow->flowchain,\n- \t\t\t\t\t       &b->decaying_flows);\n- \t\t\t\tif (flow->set == CAKE_SET_BULK) {\n- \t\t\t\t\tb->bulk_flow_count--;\n=======\n+ {\n+ \tstruct cake_sched_data *q = qdisc_priv(sch);\n+ \tstruct cake_tin_data *b = &q->tins[q->cur_tin];\n+ \tktime_t now = ktime_get();\n+ \tstruct cake_flow *flow;\n+ \tstruct list_head *head;\n+ \tbool first_flow = true;\n+ \tstruct sk_buff *skb;\n+ \tu64 delay;\n+ \tu32 len;\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t\t\t\t\tcake_dec_srchost_bulk_flow_count(b, flow, q->flow_mode);\n- \t\t\t\t\tcake_dec_dsthost_bulk_flow_count(b, flow, q->flow_mode);\n- \n- \t\t\t\t\tb->decaying_flow_count++;\n- \t\t\t\t} else if (flow->set == CAKE_SET_SPARSE ||\n- \t\t\t\t\t   flow->set == CAKE_SET_SPARSE_WAIT) {\n- \t\t\t\t\tb->sparse_flow_count--;\n- \t\t\t\t\tb->decaying_flow_count++;\n- \t\t\t\t}\n- \t\t\t\tflow->set = CAKE_SET_DECAYING;\n- \t\t\t} else {\n- \t\t\t\t/* remove empty queue from the flowchain */\n=======\n+ \tq->cur_flow = flow - b->flows;\n+ \tfirst_flow = false;\n+ \n+ \t/* flow isolation (DRR++) */\n+ \tif (flow->deficit <= 0) {\n+ \t\t/* Keep all flows with deficits out of the sparse and decaying\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t\t\t\tlist_del_init(&flow->flowchain);\n- \t\t\t\tif (flow->set == CAKE_SET_SPARSE ||\n- \t\t\t\t    flow->set == CAKE_SET_SPARSE_WAIT)\n- \t\t\t\t\tb->sparse_flow_count--;\n- \t\t\t\telse if (flow->set == CAKE_SET_BULK) {\n- \t\t\t\t\tb->bulk_flow_count--;\n- \n- \t\t\t\t\tcake_dec_srchost_bulk_flow_count(b, flow, q->flow_mode);\n- \t\t\t\t\tcake_dec_dsthost_bulk_flow_count(b, flow, q->flow_mode);\n- \t\t\t\t} else\n- \t\t\t\t\tb->decaying_flow_count--;\n=======\n+ \t\t\t\tb->sparse_flow_count--;\n+ \t\t\t\tb->bulk_flow_count++;\n+ \n+ \t\t\t\tcake_inc_srchost_bulk_flow_count(b, flow, q->flow_mode);\n+ \t\t\t\tcake_inc_dsthost_bulk_flow_count(b, flow, q->flow_mode);\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t\t/* Last packet in queue may be marked, shouldn't be dropped */\n- \t\tif (!cobalt_should_drop(&flow->cvars, &b->cparams, now, skb,\n- \t\t\t\t\t(b->bulk_flow_count *\n- \t\t\t\t\t !!(q->rate_flags &\n- \t\t\t\t\t    CAKE_FLAG_INGRESS))) ||\n- \t\t    !flow->head)\n- \t\t\tbreak;\n=======\n+ \t\tflow->deficit += cake_get_flow_quantum(b, flow, q->flow_mode);\n+ \t\tlist_move_tail(&flow->flowchain, &b->old_flows);\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t\t/* drop this packet, get another one */\n- \t\tif (q->rate_flags & CAKE_FLAG_INGRESS) {\n- \t\t\tlen = cake_advance_shaper(q, b, skb,\n- \t\t\t\t\t\t  now, true);\n- \t\t\tflow->deficit -= len;\n- \t\t\tb->tin_deficit -= len;\n- \t\t}\n- \t\tflow->dropped++;\n- \t\tb->tin_dropped++;\n- \t\tqdisc_tree_reduce_backlog(sch, 1, qdisc_pkt_len(skb));\n- \t\tqdisc_qstats_drop(sch);\n=======\n+ \t\t\t\tif (flow->set == CAKE_SET_BULK) {\n+ \t\t\t\t\tb->bulk_flow_count--;\n+ \n+ \t\t\t\t\tcake_dec_srchost_bulk_flow_count(b, flow, q->flow_mode);\n+ \t\t\t\t\tcake_dec_dsthost_bulk_flow_count(b, flow, q->flow_mode);\n+ \n+ \t\t\t\t\tb->decaying_flow_count++;\n+ \t\t\t\t} else if (flow->set == CAKE_SET_SPARSE ||\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t\tkfree_skb(skb);\n- \t\tif (q->rate_flags & CAKE_FLAG_INGRESS)\n- \t\t\tgoto retry;\n- \t}\n- \n- \tb->tin_ecn_mark += !!flow->cvars.ecn_marked;\n- \tqdisc_bstats_update(sch, skb);\n=======\n+ \t\t\t\telse if (flow->set == CAKE_SET_BULK) {\n+ \t\t\t\t\tb->bulk_flow_count--;\n+ \n+ \t\t\t\t\tcake_dec_srchost_bulk_flow_count(b, flow, q->flow_mode);\n+ \t\t\t\t\tcake_dec_dsthost_bulk_flow_count(b, flow, q->flow_mode);\n+ \t\t\t\t} else\n+ \t\t\t\t\tb->decaying_flow_count--;\n>>>>>>> INCOMING PATCH\n```"
            },
            {
              "downstream_patch": "bb0245fa72b783cb23a9949c5048781341e91423",
              "downstream_commit": "bab61f41c942a20ef7b4feea50e9d36d19ad1a26",
              "commit_date": "2025-03-13 12:51:12 +0100",
              "result": "failure",
              "error": "patching file net/sched/sch_cake.c\nHunk #1 succeeded at 643 (offset 16 lines).\nHunk #2 succeeded at 846 (offset 16 lines).\nHunk #3 succeeded at 872 (offset 16 lines).\nHunk #4 succeeded at 896 (offset 16 lines).\nHunk #5 succeeded at 1912 (offset 16 lines).\nHunk #6 succeeded at 1921 (offset 16 lines).\nHunk #7 succeeded at 1930 (offset 16 lines).\nHunk #8 succeeded at 1988 (offset 16 lines).\nHunk #9 succeeded at 2092 (offset 16 lines).\nHunk #10 succeeded at 2103 (offset 16 lines).\nHunk #11 FAILED at 2100.\nHunk #12 succeeded at 2152 (offset 16 lines).\nHunk #13 succeeded at 2171 (offset 16 lines).\n1 out of 13 hunks FAILED -- saving rejects to file net/sched/sch_cake.c.rej",
              "total_hunks": 13,
              "total_failed_hunks": 1,
              "failed_hunks": [11],
              "rej_file_content": "```diff\n--- net/sched/sch_cake.c.rej ---\n--- net/sched/sch_cake.c\n+++ net/sched/sch_cake.c\n@@ -2100,19 +2129,7 @@ static struct sk_buff *cake_dequeue(struct Qdisc *sch)\n \t\t\t}\n \t\t}\n \n-\t\tif (cake_dsrc(q->flow_mode))\n-\t\t\thost_load = max(host_load, srchost->srchost_bulk_flow_count);\n-\n-\t\tif (cake_ddst(q->flow_mode))\n-\t\t\thost_load = max(host_load, dsthost->dsthost_bulk_flow_count);\n-\n-\t\tWARN_ON(host_load > CAKE_QUEUES);\n-\n-\t\t/* The get_random_u16() is a way to apply dithering to avoid\n-\t\t * accumulating roundoff errors\n-\t\t */\n-\t\tflow->deficit += (b->flow_quantum * quantum_div[host_load] +\n-\t\t\t\t  get_random_u16()) >> 16;\n+\t\tflow->deficit += cake_get_flow_quantum(b, flow, q->flow_mode);\n \t\tlist_move_tail(&flow->flowchain, &b->old_flows);\n \n \t\tgoto retry;\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t\tif (cake_dsrc(q->flow_mode))\n- \t\t\thost_load = max(host_load, srchost->srchost_bulk_flow_count);\n- \n- \t\tif (cake_ddst(q->flow_mode))\n- \t\t\thost_load = max(host_load, dsthost->dsthost_bulk_flow_count);\n- \n- \t\tWARN_ON(host_load > CAKE_QUEUES);\n- \n- \t\t/* The shifted prandom_u32() is a way to apply dithering to\n- \t\t * avoid accumulating roundoff errors\n=======\n+ \t\tflow->deficit = cake_get_flow_quantum(b, flow, q->flow_mode);\n+ \t} else if (flow->set == CAKE_SET_SPARSE_WAIT) {\n+ \t\t/* this flow was empty, accounted as a sparse flow, but actually\n+ \t\t * in the bulk rotation.\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t\tflow->deficit += (b->flow_quantum * quantum_div[host_load] +\n- \t\t\t\t  (prandom_u32() >> 16)) >> 16;\n- \t\tlist_move_tail(&flow->flowchain, &b->old_flows);\n- \n- \t\tgoto retry;\n=======\n+ \t\tb->sparse_flow_count--;\n+ \t\tb->bulk_flow_count++;\n+ \n+ \t\tcake_inc_srchost_bulk_flow_count(b, flow, q->flow_mode);\n+ \t\tcake_inc_dsthost_bulk_flow_count(b, flow, q->flow_mode);\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t/* Retrieve a packet via the AQM */\n- \twhile (1) {\n- \t\tskb = cake_dequeue_one(sch);\n- \t\tif (!skb) {\n- \t\t\t/* this queue was actually empty */\n- \t\t\tif (cobalt_queue_empty(&flow->cvars, &b->cparams, now))\n- \t\t\t\tb->unresponsive_flow_count--;\n- \n- \t\t\tif (flow->cvars.p_drop || flow->cvars.count ||\n- \t\t\t    ktime_before(now, flow->cvars.drop_next)) {\n- \t\t\t\t/* keep in the flowchain until the state has\n- \t\t\t\t * decayed to rest\n- \t\t\t\t */\n- \t\t\t\tlist_move_tail(&flow->flowchain,\n- \t\t\t\t\t       &b->decaying_flows);\n- \t\t\t\tif (flow->set == CAKE_SET_BULK) {\n- \t\t\t\t\tb->bulk_flow_count--;\n=======\n+ {\n+ \tstruct cake_sched_data *q = qdisc_priv(sch);\n+ \tstruct cake_tin_data *b = &q->tins[q->cur_tin];\n+ \tktime_t now = ktime_get();\n+ \tstruct cake_flow *flow;\n+ \tstruct list_head *head;\n+ \tbool first_flow = true;\n+ \tstruct sk_buff *skb;\n+ \tu64 delay;\n+ \tu32 len;\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t\t\t\t\tcake_dec_srchost_bulk_flow_count(b, flow, q->flow_mode);\n- \t\t\t\t\tcake_dec_dsthost_bulk_flow_count(b, flow, q->flow_mode);\n- \n- \t\t\t\t\tb->decaying_flow_count++;\n- \t\t\t\t} else if (flow->set == CAKE_SET_SPARSE ||\n- \t\t\t\t\t   flow->set == CAKE_SET_SPARSE_WAIT) {\n- \t\t\t\t\tb->sparse_flow_count--;\n- \t\t\t\t\tb->decaying_flow_count++;\n- \t\t\t\t}\n- \t\t\t\tflow->set = CAKE_SET_DECAYING;\n- \t\t\t} else {\n- \t\t\t\t/* remove empty queue from the flowchain */\n=======\n+ \tq->cur_flow = flow - b->flows;\n+ \tfirst_flow = false;\n+ \n+ \t/* flow isolation (DRR++) */\n+ \tif (flow->deficit <= 0) {\n+ \t\t/* Keep all flows with deficits out of the sparse and decaying\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t\t\t\tlist_del_init(&flow->flowchain);\n- \t\t\t\tif (flow->set == CAKE_SET_SPARSE ||\n- \t\t\t\t    flow->set == CAKE_SET_SPARSE_WAIT)\n- \t\t\t\t\tb->sparse_flow_count--;\n- \t\t\t\telse if (flow->set == CAKE_SET_BULK) {\n- \t\t\t\t\tb->bulk_flow_count--;\n- \n- \t\t\t\t\tcake_dec_srchost_bulk_flow_count(b, flow, q->flow_mode);\n- \t\t\t\t\tcake_dec_dsthost_bulk_flow_count(b, flow, q->flow_mode);\n- \t\t\t\t} else\n- \t\t\t\t\tb->decaying_flow_count--;\n=======\n+ \t\t\t\tb->sparse_flow_count--;\n+ \t\t\t\tb->bulk_flow_count++;\n+ \n+ \t\t\t\tcake_inc_srchost_bulk_flow_count(b, flow, q->flow_mode);\n+ \t\t\t\tcake_inc_dsthost_bulk_flow_count(b, flow, q->flow_mode);\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t\t/* Last packet in queue may be marked, shouldn't be dropped */\n- \t\tif (!cobalt_should_drop(&flow->cvars, &b->cparams, now, skb,\n- \t\t\t\t\t(b->bulk_flow_count *\n- \t\t\t\t\t !!(q->rate_flags &\n- \t\t\t\t\t    CAKE_FLAG_INGRESS))) ||\n- \t\t    !flow->head)\n- \t\t\tbreak;\n=======\n+ \t\tflow->deficit += cake_get_flow_quantum(b, flow, q->flow_mode);\n+ \t\tlist_move_tail(&flow->flowchain, &b->old_flows);\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t\t/* drop this packet, get another one */\n- \t\tif (q->rate_flags & CAKE_FLAG_INGRESS) {\n- \t\t\tlen = cake_advance_shaper(q, b, skb,\n- \t\t\t\t\t\t  now, true);\n- \t\t\tflow->deficit -= len;\n- \t\t\tb->tin_deficit -= len;\n- \t\t}\n- \t\tflow->dropped++;\n- \t\tb->tin_dropped++;\n- \t\tqdisc_tree_reduce_backlog(sch, 1, qdisc_pkt_len(skb));\n- \t\tqdisc_qstats_drop(sch);\n=======\n+ \t\t\t\tif (flow->set == CAKE_SET_BULK) {\n+ \t\t\t\t\tb->bulk_flow_count--;\n+ \n+ \t\t\t\t\tcake_dec_srchost_bulk_flow_count(b, flow, q->flow_mode);\n+ \t\t\t\t\tcake_dec_dsthost_bulk_flow_count(b, flow, q->flow_mode);\n+ \n+ \t\t\t\t\tb->decaying_flow_count++;\n+ \t\t\t\t} else if (flow->set == CAKE_SET_SPARSE ||\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t\tkfree_skb(skb);\n- \t\tif (q->rate_flags & CAKE_FLAG_INGRESS)\n- \t\t\tgoto retry;\n- \t}\n- \n- \tb->tin_ecn_mark += !!flow->cvars.ecn_marked;\n- \tqdisc_bstats_update(sch, skb);\n=======\n+ \t\t\t\telse if (flow->set == CAKE_SET_BULK) {\n+ \t\t\t\t\tb->bulk_flow_count--;\n+ \n+ \t\t\t\t\tcake_dec_srchost_bulk_flow_count(b, flow, q->flow_mode);\n+ \t\t\t\t\tcake_dec_dsthost_bulk_flow_count(b, flow, q->flow_mode);\n+ \t\t\t\t} else\n+ \t\t\t\t\tb->decaying_flow_count--;\n>>>>>>> INCOMING PATCH\n```"
            }
          ]
        }
      ]
    },
    {
      "cve_url": "https://web.git.kernel.org/pub/scm/linux/security/vulns.git/plain/cve/published/2025/CVE-2025-21666.json",
      "patch_attempts": [
        {
          "upstream_commit": "a24009bc9be60242651a21702609381b5092459e",
          "upstream_commit_date": "2025-01-14 12:29:37 +0100",
          "upstream_patch": "91751e248256efc111e52e15115840c35d85abaf",
          "total_versions_tested": 5,
          "successful_patches": 4,
          "failed_patches": 1,
          "patch_results": [
            {
              "downstream_patch": "daeac89cdb03d30028186f5ff7dc26ec8fa843e7",
              "downstream_commit": "18a7fc371d1dbf8deff16c2dd9292bcc73f43040",
              "commit_date": "2025-02-01 18:22:31 +0100",
              "result": "failure",
              "error": "patching file net/vmw_vsock/af_vsock.c\nHunk #1 succeeded at 837 (offset -42 lines).\nHunk #2 FAILED at 890.\nHunk #3 succeeded at 846 (offset -53 lines).\n1 out of 3 hunks FAILED -- saving rejects to file net/vmw_vsock/af_vsock.c.rej",
              "total_hunks": 3,
              "total_failed_hunks": 1,
              "failed_hunks": [2],
              "rej_file_content": "```diff\n--- net/vmw_vsock/af_vsock.c.rej ---\n--- net/vmw_vsock/af_vsock.c\n+++ net/vmw_vsock/af_vsock.c\n@@ -890,6 +893,9 @@ s64 vsock_connectible_has_data(struct vsock_sock *vsk)\n {\n \tstruct sock *sk = sk_vsock(vsk);\n \n+\tif (WARN_ON(!vsk->transport))\n+\t\treturn 0;\n+\n \tif (sk->sk_type == SOCK_SEQPACKET)\n \t\treturn vsk->transport->seqpacket_has_data(vsk);\n \telse\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n\n=======\n+ s64 vsock_stream_has_data(struct vsock_sock *vsk)\n+ {\n+ \tif (WARN_ON(!vsk->transport))\n+ \t\treturn 0;\n+ \n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n\n=======\n+ \tstruct sock *sk = sk_vsock(vsk);\n+ \n+ \tif (WARN_ON(!vsk->transport))\n+ \t\treturn 0;\n+ \n+ \tif (sk->sk_type == SOCK_SEQPACKET)\n+ \t\treturn vsk->transport->seqpacket_has_data(vsk);\n+ \telse\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n\n=======\n+ \tif (WARN_ON(!vsk->transport))\n+ \t\treturn 0;\n+ \n+ \treturn vsk->transport->stream_has_space(vsk);\n+ }\n+ EXPORT_SYMBOL_GPL(vsock_stream_has_space);\n>>>>>>> INCOMING PATCH\n```"
            }
          ]
        }
      ]
    },
    {
      "cve_url": "https://web.git.kernel.org/pub/scm/linux/security/vulns.git/plain/cve/published/2025/CVE-2025-21668.json",
      "patch_attempts": [
        {
          "upstream_commit": "f64f610ec6ab59dd0391b03842cea3a4cd8ee34f",
          "upstream_commit_date": "2025-01-16 16:10:32 +0100",
          "upstream_patch": "726efa92e02b460811e8bc6990dd742f03b645ea",
          "total_versions_tested": 3,
          "successful_patches": 2,
          "failed_patches": 1,
          "patch_results": [
            {
              "downstream_patch": "699cc10cc3068f9097a506eae7fe178c860dca4e",
              "downstream_commit": "d38c49f7bdf14381270736299e2ff68ec248a017",
              "commit_date": "2025-01-23 17:17:14 +0100",
              "result": "failure",
              "error": "can't find file to patch at input line 55\nPerhaps you used the wrong -p or --strip option?\nThe text leading up to this was:\n--------------------------\n|From 726efa92e02b460811e8bc6990dd742f03b645ea Mon Sep 17 00:00:00 2001\n|From: Xiaolei Wang <xiaolei.wang@windriver.com>\n|Date: Wed, 15 Jan 2025 09:41:18 +0800\n|Subject: [PATCH] pmdomain: imx8mp-blk-ctrl: add missing loop break condition\n|\n|Currently imx8mp_blk_ctrl_remove() will continue the for loop\n|until an out-of-bounds exception occurs.\n|\n|pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n|pc : dev_pm_domain_detach+0x8/0x48\n|lr : imx8mp_blk_ctrl_shutdown+0x58/0x90\n|sp : ffffffc084f8bbf0\n|x29: ffffffc084f8bbf0 x28: ffffff80daf32ac0 x27: 0000000000000000\n|x26: ffffffc081658d78 x25: 0000000000000001 x24: ffffffc08201b028\n|x23: ffffff80d0db9490 x22: ffffffc082340a78 x21: 00000000000005b0\n|x20: ffffff80d19bc180 x19: 000000000000000a x18: ffffffffffffffff\n|x17: ffffffc080a39e08 x16: ffffffc080a39c98 x15: 4f435f464f006c72\n|x14: 0000000000000004 x13: ffffff80d0172110 x12: 0000000000000000\n|x11: ffffff80d0537740 x10: ffffff80d05376c0 x9 : ffffffc0808ed2d8\n|x8 : ffffffc084f8bab0 x7 : 0000000000000000 x6 : 0000000000000000\n|x5 : ffffff80d19b9420 x4 : fffffffe03466e60 x3 : 0000000080800077\n|x2 : 0000000000000000 x1 : 0000000000000001 x0 : 0000000000000000\n|Call trace:\n| dev_pm_domain_detach+0x8/0x48\n| platform_shutdown+0x2c/0x48\n| device_shutdown+0x158/0x268\n| kernel_restart_prepare+0x40/0x58\n| kernel_kexec+0x58/0xe8\n| __do_sys_reboot+0x198/0x258\n| __arm64_sys_reboot+0x2c/0x40\n| invoke_syscall+0x5c/0x138\n| el0_svc_common.constprop.0+0x48/0xf0\n| do_el0_svc+0x24/0x38\n| el0_svc+0x38/0xc8\n| el0t_64_sync_handler+0x120/0x130\n| el0t_64_sync+0x190/0x198\n|Code: 8128c2d0 ffffffc0 aa1e03e9 d503201f\n|\n|Fixes: 556f5cf9568a (\"soc: imx: add i.MX8MP HSIO blk-ctrl\")\n|Cc: stable@vger.kernel.org\n|Signed-off-by: Xiaolei Wang <xiaolei.wang@windriver.com>\n|Reviewed-by: Lucas Stach <l.stach@pengutronix.de>\n|Reviewed-by: Fabio Estevam <festevam@gmail.com>\n|Reviewed-by: Frank Li <Frank.Li@nxp.com>\n|Link: https://lore.kernel.org/r/20250115014118.4086729-1-xiaolei.wang@windriver.com\n|Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>\n|---\n| drivers/pmdomain/imx/imx8mp-blk-ctrl.c | 2 +-\n| 1 file changed, 1 insertion(+), 1 deletion(-)\n|\n|diff --git a/drivers/pmdomain/imx/imx8mp-blk-ctrl.c b/drivers/pmdomain/imx/imx8mp-blk-ctrl.c\n|index e3a0f64c144c..3668fe66b22c 100644\n|--- a/drivers/pmdomain/imx/imx8mp-blk-ctrl.c\n|+++ b/drivers/pmdomain/imx/imx8mp-blk-ctrl.c\n--------------------------\nFile to patch: \nSkip this patch? [y] \nSkipping patch.\n1 out of 1 hunk ignored",
              "total_hunks": 0,
              "total_failed_hunks": 0,
              "failed_hunks": [],
              "rej_file_content": "No rejected diff content found.",
              "inline_merge_conflict": "No conflict markers found."
            }
          ]
        }
      ]
    },
    {
      "cve_url": "https://web.git.kernel.org/pub/scm/linux/security/vulns.git/plain/cve/published/2025/CVE-2025-21669.json",
      "patch_attempts": [
        {
          "upstream_commit": "0865b9fdb27219db79f3687bc50a0b534b437ee7",
          "upstream_commit_date": "2025-01-14 12:29:36 +0100",
          "upstream_patch": "2cb7c756f605ec02ffe562fb26828e4bcc5fdfc1",
          "total_versions_tested": 5,
          "successful_patches": 3,
          "failed_patches": 2,
          "patch_results": [
            {
              "downstream_patch": "6486915fa661584d70e8e7e4068c6c075c67dd6d",
              "downstream_commit": "8a07350fe070017a887433f4d6909433955be5f1",
              "commit_date": "2025-01-23 17:16:03 +0100",
              "result": "failure",
              "error": "patching file net/vmw_vsock/virtio_transport_common.c\nHunk #1 FAILED at 1628.\n1 out of 1 hunk FAILED -- saving rejects to file net/vmw_vsock/virtio_transport_common.c.rej",
              "total_hunks": 0,
              "total_failed_hunks": 1,
              "failed_hunks": [1],
              "rej_file_content": "```diff\n--- net/vmw_vsock/virtio_transport_common.c.rej ---\n--- net/vmw_vsock/virtio_transport_common.c\n+++ net/vmw_vsock/virtio_transport_common.c\n@@ -1628,8 +1628,11 @@ void virtio_transport_recv_pkt(struct virtio_transport *t,\n \n \tlock_sock(sk);\n \n-\t/* Check if sk has been closed before lock_sock */\n-\tif (sock_flag(sk, SOCK_DONE)) {\n+\t/* Check if sk has been closed or assigned to another transport before\n+\t * lock_sock (note: listener sockets are not assigned to any transport)\n+\t */\n+\tif (sock_flag(sk, SOCK_DONE) ||\n+\t    (sk->sk_state != TCP_LISTEN && vsk->transport != &t->transport)) {\n \t\t(void)virtio_transport_reset_no_sock(t, skb);\n \t\trelease_sock(sk);\n \t\tsock_put(sk);\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t/* Check if sk has been closed before lock_sock */\n- \tif (sock_flag(sk, SOCK_DONE)) {\n- \t\t(void)virtio_transport_reset_no_sock(t, pkt);\n=======\n+ \t/* Check if sk has been closed or assigned to another transport before\n+ \t * lock_sock (note: listener sockets are not assigned to any transport)\n+ \t */\n+ \tif (sock_flag(sk, SOCK_DONE) ||\n+ \t    (sk->sk_state != TCP_LISTEN && vsk->transport != &t->transport)) {\n+ \t\t(void)virtio_transport_reset_no_sock(t, skb);\n>>>>>>> INCOMING PATCH\n```"
            },
            {
              "downstream_patch": "18a7fc371d1dbf8deff16c2dd9292bcc73f43040",
              "downstream_commit": "a925a200299a6dfc7c172f54da6f374edc930053",
              "commit_date": "2025-02-01 18:22:31 +0100",
              "result": "failure",
              "error": "patching file net/vmw_vsock/virtio_transport_common.c\nHunk #1 FAILED at 1628.\n1 out of 1 hunk FAILED -- saving rejects to file net/vmw_vsock/virtio_transport_common.c.rej",
              "total_hunks": 0,
              "total_failed_hunks": 1,
              "failed_hunks": [1],
              "rej_file_content": "```diff\n--- net/vmw_vsock/virtio_transport_common.c.rej ---\n--- net/vmw_vsock/virtio_transport_common.c\n+++ net/vmw_vsock/virtio_transport_common.c\n@@ -1628,8 +1628,11 @@ void virtio_transport_recv_pkt(struct virtio_transport *t,\n \n \tlock_sock(sk);\n \n-\t/* Check if sk has been closed before lock_sock */\n-\tif (sock_flag(sk, SOCK_DONE)) {\n+\t/* Check if sk has been closed or assigned to another transport before\n+\t * lock_sock (note: listener sockets are not assigned to any transport)\n+\t */\n+\tif (sock_flag(sk, SOCK_DONE) ||\n+\t    (sk->sk_state != TCP_LISTEN && vsk->transport != &t->transport)) {\n \t\t(void)virtio_transport_reset_no_sock(t, skb);\n \t\trelease_sock(sk);\n \t\tsock_put(sk);\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t/* Check if sk has been closed before lock_sock */\n- \tif (sock_flag(sk, SOCK_DONE)) {\n- \t\t(void)virtio_transport_reset_no_sock(t, pkt);\n=======\n+ \t/* Check if sk has been closed or assigned to another transport before\n+ \t * lock_sock (note: listener sockets are not assigned to any transport)\n+ \t */\n+ \tif (sock_flag(sk, SOCK_DONE) ||\n+ \t    (sk->sk_state != TCP_LISTEN && vsk->transport != &t->transport)) {\n+ \t\t(void)virtio_transport_reset_no_sock(t, skb);\n>>>>>>> INCOMING PATCH\n```"
            }
          ]
        }
      ]
    },
    {
      "cve_url": "https://web.git.kernel.org/pub/scm/linux/security/vulns.git/plain/cve/published/2025/CVE-2025-21684.json",
      "patch_attempts": [
        {
          "upstream_commit": "5bc55a333a2f7316b58edc7573e8e893f7acb532",
          "upstream_commit_date": "2025-01-14 14:04:38 +0100",
          "upstream_patch": "9860370c2172704b6b4f0075a0c2a29fd84af96a",
          "total_versions_tested": 4,
          "successful_patches": 3,
          "failed_patches": 1,
          "patch_results": [
            {
              "downstream_patch": "d25041d4a3b2af64c888cf762362b2528ba59294",
              "downstream_commit": "4489cce8e4e717077cfba4a297478580ed8aadfb",
              "commit_date": "2025-03-13 12:50:21 +0100",
              "result": "failure",
              "error": "patching file drivers/gpio/gpio-xilinx.c\nHunk #1 succeeded at 66 with fuzz 2 (offset 1 line).\nHunk #8 succeeded at 405 (offset 7 lines).\nHunk #9 FAILED at 408.\nHunk #10 succeeded at 431 with fuzz 2 (offset 3 lines).\nHunk #11 succeeded at 450 (offset 3 lines).\nHunk #12 succeeded at 515 (offset 3 lines).\nHunk #13 succeeded at 532 (offset 3 lines).\nHunk #14 succeeded at 623 (offset 3 lines).\n1 out of 14 hunks FAILED -- saving rejects to file drivers/gpio/gpio-xilinx.c.rej",
              "total_hunks": 14,
              "total_failed_hunks": 1,
              "failed_hunks": [9],
              "rej_file_content": "```diff\n--- drivers/gpio/gpio-xilinx.c.rej ---\n--- drivers/gpio/gpio-xilinx.c\n+++ drivers/gpio/gpio-xilinx.c\n@@ -408,7 +408,7 @@ static void xgpio_irq_mask(struct irq_data *irq_data)\n \t\ttemp &= ~mask;\n \t\txgpio_writereg(chip->regs + XGPIO_IPIER_OFFSET, temp);\n \t}\n-\tspin_unlock_irqrestore(&chip->gpio_lock, flags);\n+\traw_spin_unlock_irqrestore(&chip->gpio_lock, flags);\n \n \tgpiochip_disable_irq(&chip->gc, irq_offset);\n }\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tspin_unlock_irqrestore(&chip->gpio_lock, flags);\n=======\n+ \traw_spin_unlock_irqrestore(&chip->gpio_lock, flags);\n+ \n+ \tgpiochip_disable_irq(&chip->gc, irq_offset);\n>>>>>>> INCOMING PATCH\n```"
            }
          ]
        }
      ]
    },
    {
      "cve_url": "https://web.git.kernel.org/pub/scm/linux/security/vulns.git/plain/cve/published/2025/CVE-2025-21686.json",
      "patch_attempts": [
        {
          "upstream_commit": "a13030fd194c88961be4679f87a1380f1bda0ebe",
          "upstream_commit_date": "2025-01-14 10:59:48 -0700",
          "upstream_patch": "19d340a2988d4f3e673cded9dde405d727d7e248",
          "total_versions_tested": 2,
          "successful_patches": 1,
          "failed_patches": 1,
          "patch_results": [
            {
              "downstream_patch": "efd96fbe23fa87de39116f632401f67b93be21ab",
              "downstream_commit": "5d114fa2b6508d89bcd96b8b0bc21a76c1d6dc1b",
              "commit_date": "2025-02-01 18:39:40 +0100",
              "result": "failure",
              "error": "patching file io_uring/rsrc.c\nHunk #1 FAILED at 928.\n1 out of 1 hunk FAILED -- saving rejects to file io_uring/rsrc.c.rej",
              "total_hunks": 0,
              "total_failed_hunks": 1,
              "failed_hunks": [1],
              "rej_file_content": "```diff\n--- io_uring/rsrc.c.rej ---\n--- io_uring/rsrc.c\n+++ io_uring/rsrc.c\n@@ -928,6 +928,13 @@ static int io_clone_buffers(struct io_ring_ctx *ctx, struct io_ring_ctx *src_ctx\n \tint i, ret, off, nr;\n \tunsigned int nbufs;\n \n+\t/*\n+\t * Accounting state is shared between the two rings; that only works if\n+\t * both rings are accounted towards the same counters.\n+\t */\n+\tif (ctx->user != src_ctx->user || ctx->mm_account != src_ctx->mm_account)\n+\t\treturn -EINVAL;\n+\n \t/* if offsets are given, must have nr specified too */\n \tif (!arg->nr && (arg->dst_off || arg->src_off))\n \t\treturn -EINVAL;\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n\n=======\n+ \t/*\n+ \t * Accounting state is shared between the two rings; that only works if\n+ \t * both rings are accounted towards the same counters.\n+ \t */\n+ \tif (ctx->user != src_ctx->user || ctx->mm_account != src_ctx->mm_account)\n+ \t\treturn -EINVAL;\n+ \n+ \t/* if offsets are given, must have nr specified too */\n+ \tif (!arg->nr && (arg->dst_off || arg->src_off))\n+ \t\treturn -EINVAL;\n>>>>>>> INCOMING PATCH\n```"
            }
          ]
        }
      ]
    },
    {
      "cve_url": "https://web.git.kernel.org/pub/scm/linux/security/vulns.git/plain/cve/published/2025/CVE-2025-21687.json",
      "patch_attempts": [
        {
          "upstream_commit": "e021e6cbfb5a695968afb6619828929a97e4a83a",
          "upstream_commit_date": "2025-01-23 13:13:27 -0700",
          "upstream_patch": "ce9ff21ea89d191e477a02ad7eabf4f996b80a69",
          "total_versions_tested": 11,
          "successful_patches": 7,
          "failed_patches": 4,
          "patch_results": [
            {
              "downstream_patch": "1485932496a1b025235af8aa1e21988d6b7ccd54",
              "downstream_commit": "5688ad8098b07f3c5a25150a9f8f298355f00277",
              "commit_date": "2025-02-21 13:49:50 +0100",
              "result": "failure",
              "error": "patching file drivers/vfio/platform/vfio_platform_common.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n2 out of 2 hunks ignored -- saving rejects to file drivers/vfio/platform/vfio_platform_common.c.rej",
              "total_hunks": 0,
              "total_failed_hunks": 0,
              "failed_hunks": [],
              "rej_file_content": "```diff\n--- drivers/vfio/platform/vfio_platform_common.c.rej ---\n--- drivers/vfio/platform/vfio_platform_common.c\n+++ drivers/vfio/platform/vfio_platform_common.c\n@@ -388,6 +388,11 @@ static ssize_t vfio_platform_read_mmio(struct vfio_platform_region *reg,\n {\n \tunsigned int done = 0;\n \n+\tif (off >= reg->size)\n+\t\treturn -EINVAL;\n+\n+\tcount = min_t(size_t, count, reg->size - off);\n+\n \tif (!reg->ioaddr) {\n \t\treg->ioaddr =\n \t\t\tioremap(reg->addr, reg->size);\n@@ -467,6 +472,11 @@ static ssize_t vfio_platform_write_mmio(struct vfio_platform_region *reg,\n {\n \tunsigned int done = 0;\n \n+\tif (off >= reg->size)\n+\t\treturn -EINVAL;\n+\n+\tcount = min_t(size_t, count, reg->size - off);\n+\n \tif (!reg->ioaddr) {\n \t\treg->ioaddr =\n \t\t\tioremap(reg->addr, reg->size);\n```",
              "inline_merge_conflict": "No conflict markers found."
            },
            {
              "downstream_patch": "9377cdc118cf327248f1a9dde7b87de067681dc9",
              "downstream_commit": "406c63ceeae3851fba6b52e423fb4efc736f6f4e",
              "commit_date": "2025-03-13 12:43:10 +0100",
              "result": "failure",
              "error": "patching file drivers/vfio/platform/vfio_platform_common.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n2 out of 2 hunks ignored -- saving rejects to file drivers/vfio/platform/vfio_platform_common.c.rej",
              "total_hunks": 0,
              "total_failed_hunks": 0,
              "failed_hunks": [],
              "rej_file_content": "```diff\n--- drivers/vfio/platform/vfio_platform_common.c.rej ---\n--- drivers/vfio/platform/vfio_platform_common.c\n+++ drivers/vfio/platform/vfio_platform_common.c\n@@ -388,6 +388,11 @@ static ssize_t vfio_platform_read_mmio(struct vfio_platform_region *reg,\n {\n \tunsigned int done = 0;\n \n+\tif (off >= reg->size)\n+\t\treturn -EINVAL;\n+\n+\tcount = min_t(size_t, count, reg->size - off);\n+\n \tif (!reg->ioaddr) {\n \t\treg->ioaddr =\n \t\t\tioremap(reg->addr, reg->size);\n@@ -467,6 +472,11 @@ static ssize_t vfio_platform_write_mmio(struct vfio_platform_region *reg,\n {\n \tunsigned int done = 0;\n \n+\tif (off >= reg->size)\n+\t\treturn -EINVAL;\n+\n+\tcount = min_t(size_t, count, reg->size - off);\n+\n \tif (!reg->ioaddr) {\n \t\treg->ioaddr =\n \t\t\tioremap(reg->addr, reg->size);\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n\n=======\n+ \tif (off >= reg->size)\n+ \t\treturn -EINVAL;\n+ \n+ \tcount = min_t(size_t, count, reg->size - off);\n+ \n+ \tif (!reg->ioaddr) {\n+ \t\treg->ioaddr =\n+ \t\t\tioremap(reg->addr, reg->size);\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n\n=======\n+ \tif (off >= reg->size)\n+ \t\treturn -EINVAL;\n+ \n+ \tcount = min_t(size_t, count, reg->size - off);\n+ \n+ \tif (!reg->ioaddr) {\n+ \t\treg->ioaddr =\n+ \t\t\tioremap(reg->addr, reg->size);\n>>>>>>> INCOMING PATCH\n```"
            },
            {
              "downstream_patch": "ed81d82bb6e9df3a137f2c343ed689e6c68268ef",
              "downstream_commit": "61717062b3c0c894b06ce2d8f31d60737766cd12",
              "commit_date": "2025-03-13 12:47:12 +0100",
              "result": "failure",
              "error": "patching file drivers/vfio/platform/vfio_platform_common.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n2 out of 2 hunks ignored -- saving rejects to file drivers/vfio/platform/vfio_platform_common.c.rej",
              "total_hunks": 0,
              "total_failed_hunks": 0,
              "failed_hunks": [],
              "rej_file_content": "```diff\n--- drivers/vfio/platform/vfio_platform_common.c.rej ---\n--- drivers/vfio/platform/vfio_platform_common.c\n+++ drivers/vfio/platform/vfio_platform_common.c\n@@ -388,6 +388,11 @@ static ssize_t vfio_platform_read_mmio(struct vfio_platform_region *reg,\n {\n \tunsigned int done = 0;\n \n+\tif (off >= reg->size)\n+\t\treturn -EINVAL;\n+\n+\tcount = min_t(size_t, count, reg->size - off);\n+\n \tif (!reg->ioaddr) {\n \t\treg->ioaddr =\n \t\t\tioremap(reg->addr, reg->size);\n@@ -467,6 +472,11 @@ static ssize_t vfio_platform_write_mmio(struct vfio_platform_region *reg,\n {\n \tunsigned int done = 0;\n \n+\tif (off >= reg->size)\n+\t\treturn -EINVAL;\n+\n+\tcount = min_t(size_t, count, reg->size - off);\n+\n \tif (!reg->ioaddr) {\n \t\treg->ioaddr =\n \t\t\tioremap(reg->addr, reg->size);\n```",
              "inline_merge_conflict": "No conflict markers found."
            },
            {
              "downstream_patch": "f65ce06387f8c1fb54bd59e18a8428248ec68eaf",
              "downstream_commit": "66325de7180152c15597c600711c7f6d5538e6aa",
              "commit_date": "2025-03-13 12:50:32 +0100",
              "result": "failure",
              "error": "patching file drivers/vfio/platform/vfio_platform_common.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n2 out of 2 hunks ignored -- saving rejects to file drivers/vfio/platform/vfio_platform_common.c.rej",
              "total_hunks": 0,
              "total_failed_hunks": 0,
              "failed_hunks": [],
              "rej_file_content": "```diff\n--- drivers/vfio/platform/vfio_platform_common.c.rej ---\n--- drivers/vfio/platform/vfio_platform_common.c\n+++ drivers/vfio/platform/vfio_platform_common.c\n@@ -388,6 +388,11 @@ static ssize_t vfio_platform_read_mmio(struct vfio_platform_region *reg,\n {\n \tunsigned int done = 0;\n \n+\tif (off >= reg->size)\n+\t\treturn -EINVAL;\n+\n+\tcount = min_t(size_t, count, reg->size - off);\n+\n \tif (!reg->ioaddr) {\n \t\treg->ioaddr =\n \t\t\tioremap(reg->addr, reg->size);\n@@ -467,6 +472,11 @@ static ssize_t vfio_platform_write_mmio(struct vfio_platform_region *reg,\n {\n \tunsigned int done = 0;\n \n+\tif (off >= reg->size)\n+\t\treturn -EINVAL;\n+\n+\tcount = min_t(size_t, count, reg->size - off);\n+\n \tif (!reg->ioaddr) {\n \t\treg->ioaddr =\n \t\t\tioremap(reg->addr, reg->size);\n```",
              "inline_merge_conflict": "No conflict markers found."
            }
          ]
        }
      ]
    },
    {
      "cve_url": "https://web.git.kernel.org/pub/scm/linux/security/vulns.git/plain/cve/published/2025/CVE-2025-21691.json",
      "patch_attempts": [
        {
          "upstream_commit": "c4b9570cfb63501638db720f3bee9f6dfd044b82",
          "upstream_commit_date": "2025-01-21 20:30:19 -0800",
          "upstream_patch": "5f537664e705b0bf8b7e329861f20128534f6a83",
          "total_versions_tested": 3,
          "successful_patches": 1,
          "failed_patches": 2,
          "patch_results": [
            {
              "downstream_patch": "7d6405c13b0d8a8367cd8df63f118b619a3f0dd2",
              "downstream_commit": "854d0d361e451a6b5f7bde2b86d634a8b6f80f3e",
              "commit_date": "2025-02-01 18:37:54 +0100",
              "result": "failure",
              "error": "patching file mm/filemap.c\nHunk #1 succeeded at 4270 (offset -105 lines).\nHunk #2 FAILED at 4444.\n1 out of 2 hunks FAILED -- saving rejects to file mm/filemap.c.rej",
              "total_hunks": 2,
              "total_failed_hunks": 1,
              "failed_hunks": [2],
              "rej_file_content": "```diff\n--- mm/filemap.c.rej ---\n--- mm/filemap.c\n+++ mm/filemap.c\n@@ -4444,6 +4458,9 @@ SYSCALL_DEFINE4(cachestat, unsigned int, fd,\n \tif (is_file_hugepages(fd_file(f)))\n \t\treturn -EOPNOTSUPP;\n \n+\tif (!can_do_cachestat(fd_file(f)))\n+\t\treturn -EPERM;\n+\n \tif (flags != 0)\n \t\treturn -EINVAL;\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n\n=======\n+ \tif (is_file_hugepages(fd_file(f)))\n+ \t\treturn -EOPNOTSUPP;\n+ \n+ \tif (!can_do_cachestat(fd_file(f)))\n+ \t\treturn -EPERM;\n+ \n+ \tif (flags != 0)\n+ \t\treturn -EINVAL;\n>>>>>>> INCOMING PATCH\n```"
            },
            {
              "downstream_patch": "780ab8329672464984cf1344bd5c3993af0226c7",
              "downstream_commit": "276df5deb88c22a983fa8b5b6ad80e746131ca24",
              "commit_date": "2025-02-01 18:39:38 +0100",
              "result": "failure",
              "error": "patching file mm/filemap.c\nHunk #1 succeeded at 4383 (offset 8 lines).\nHunk #2 FAILED at 4444.\n1 out of 2 hunks FAILED -- saving rejects to file mm/filemap.c.rej",
              "total_hunks": 2,
              "total_failed_hunks": 1,
              "failed_hunks": [2],
              "rej_file_content": "```diff\n--- mm/filemap.c.rej ---\n--- mm/filemap.c\n+++ mm/filemap.c\n@@ -4444,6 +4458,9 @@ SYSCALL_DEFINE4(cachestat, unsigned int, fd,\n \tif (is_file_hugepages(fd_file(f)))\n \t\treturn -EOPNOTSUPP;\n \n+\tif (!can_do_cachestat(fd_file(f)))\n+\t\treturn -EPERM;\n+\n \tif (flags != 0)\n \t\treturn -EINVAL;\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t}\n=======\n+ \n+ \tif (!can_do_cachestat(fd_file(f)))\n+ \t\treturn -EPERM;\n+ \n+ \tif (flags != 0)\n+ \t\treturn -EINVAL;\n>>>>>>> INCOMING PATCH\n```"
            }
          ]
        }
      ]
    },
    {
      "cve_url": "https://web.git.kernel.org/pub/scm/linux/security/vulns.git/plain/cve/published/2025/CVE-2025-21702.json",
      "patch_attempts": [
        {
          "upstream_commit": "5368a67307b3b2c347dc8965ac55b888be665934",
          "upstream_commit_date": "2025-02-05 18:13:58 -0800",
          "upstream_patch": "647cef20e649c576dff271e018d5d15d998b629d",
          "total_versions_tested": 7,
          "successful_patches": 2,
          "failed_patches": 5,
          "patch_results": [
            {
              "downstream_patch": "020ecb76812a0526f4130ab5aeb6dc7c773e7ab9",
              "downstream_commit": "5b99dea79650b50909c50aba24fbae00f203f013",
              "commit_date": "2025-03-07 16:56:51 +0100",
              "result": "failure",
              "error": "patching file net/sched/sch_fifo.c\nHunk #1 FAILED at 40.\n1 out of 1 hunk FAILED -- saving rejects to file net/sched/sch_fifo.c.rej",
              "total_hunks": 0,
              "total_failed_hunks": 1,
              "failed_hunks": [1],
              "rej_file_content": "```diff\n--- net/sched/sch_fifo.c.rej ---\n--- net/sched/sch_fifo.c\n+++ net/sched/sch_fifo.c\n@@ -40,6 +40,9 @@ static int pfifo_tail_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n {\n \tunsigned int prev_backlog;\n \n+\tif (unlikely(READ_ONCE(sch->limit) == 0))\n+\t\treturn qdisc_drop(skb, sch, to_free);\n+\n \tif (likely(sch->q.qlen < READ_ONCE(sch->limit)))\n \t\treturn qdisc_enqueue_tail(skb, sch);\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tif (likely(sch->q.qlen < sch->limit))\n=======\n+ \tif (unlikely(READ_ONCE(sch->limit) == 0))\n+ \t\treturn qdisc_drop(skb, sch, to_free);\n+ \n+ \tif (likely(sch->q.qlen < READ_ONCE(sch->limit)))\n>>>>>>> INCOMING PATCH\n```"
            },
            {
              "downstream_patch": "78285b53266d6d51fa4ff504a23df03852eba84e",
              "downstream_commit": "321794b75ac968f0bb6b9c913581949452a8d992",
              "commit_date": "2025-03-13 12:43:25 +0100",
              "result": "failure",
              "error": "patching file net/sched/sch_fifo.c\nHunk #1 FAILED at 40.\n1 out of 1 hunk FAILED -- saving rejects to file net/sched/sch_fifo.c.rej",
              "total_hunks": 0,
              "total_failed_hunks": 1,
              "failed_hunks": [1],
              "rej_file_content": "```diff\n--- net/sched/sch_fifo.c.rej ---\n--- net/sched/sch_fifo.c\n+++ net/sched/sch_fifo.c\n@@ -40,6 +40,9 @@ static int pfifo_tail_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n {\n \tunsigned int prev_backlog;\n \n+\tif (unlikely(READ_ONCE(sch->limit) == 0))\n+\t\treturn qdisc_drop(skb, sch, to_free);\n+\n \tif (likely(sch->q.qlen < READ_ONCE(sch->limit)))\n \t\treturn qdisc_enqueue_tail(skb, sch);\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tif (likely(sch->q.qlen < sch->limit))\n=======\n+ \tif (unlikely(READ_ONCE(sch->limit) == 0))\n+ \t\treturn qdisc_drop(skb, sch, to_free);\n+ \n+ \tif (likely(sch->q.qlen < READ_ONCE(sch->limit)))\n>>>>>>> INCOMING PATCH\n```"
            },
            {
              "downstream_patch": "7a9723ec27aff5674f1fd4934608937f1d650980",
              "downstream_commit": "8045b302301e64080e3be6a656d626d0aa30877d",
              "commit_date": "2025-03-13 12:47:34 +0100",
              "result": "failure",
              "error": "patching file net/sched/sch_fifo.c\nHunk #1 FAILED at 40.\n1 out of 1 hunk FAILED -- saving rejects to file net/sched/sch_fifo.c.rej",
              "total_hunks": 0,
              "total_failed_hunks": 1,
              "failed_hunks": [1],
              "rej_file_content": "```diff\n--- net/sched/sch_fifo.c.rej ---\n--- net/sched/sch_fifo.c\n+++ net/sched/sch_fifo.c\n@@ -40,6 +40,9 @@ static int pfifo_tail_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n {\n \tunsigned int prev_backlog;\n \n+\tif (unlikely(READ_ONCE(sch->limit) == 0))\n+\t\treturn qdisc_drop(skb, sch, to_free);\n+\n \tif (likely(sch->q.qlen < READ_ONCE(sch->limit)))\n \t\treturn qdisc_enqueue_tail(skb, sch);\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tif (likely(sch->q.qlen < sch->limit))\n=======\n+ \tif (unlikely(READ_ONCE(sch->limit) == 0))\n+ \t\treturn qdisc_drop(skb, sch, to_free);\n+ \n+ \tif (likely(sch->q.qlen < READ_ONCE(sch->limit)))\n>>>>>>> INCOMING PATCH\n```"
            },
            {
              "downstream_patch": "a56a6e8589a9b98d8171611fbcc1e45a15fd2455",
              "downstream_commit": "e38f9d761b34d8545010dc8b980a96a7310c6064",
              "commit_date": "2025-03-13 12:51:00 +0100",
              "result": "failure",
              "error": "patching file net/sched/sch_fifo.c\nHunk #1 FAILED at 40.\n1 out of 1 hunk FAILED -- saving rejects to file net/sched/sch_fifo.c.rej",
              "total_hunks": 0,
              "total_failed_hunks": 1,
              "failed_hunks": [1],
              "rej_file_content": "```diff\n--- net/sched/sch_fifo.c.rej ---\n--- net/sched/sch_fifo.c\n+++ net/sched/sch_fifo.c\n@@ -40,6 +40,9 @@ static int pfifo_tail_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n {\n \tunsigned int prev_backlog;\n \n+\tif (unlikely(READ_ONCE(sch->limit) == 0))\n+\t\treturn qdisc_drop(skb, sch, to_free);\n+\n \tif (likely(sch->q.qlen < READ_ONCE(sch->limit)))\n \t\treturn qdisc_enqueue_tail(skb, sch);\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tif (likely(sch->q.qlen < sch->limit))\n=======\n+ \tif (unlikely(READ_ONCE(sch->limit) == 0))\n+ \t\treturn qdisc_drop(skb, sch, to_free);\n+ \n+ \tif (likely(sch->q.qlen < READ_ONCE(sch->limit)))\n>>>>>>> INCOMING PATCH\n```"
            },
            {
              "downstream_patch": "79a955ea4a2e5ddf4a36328959de0de496419888",
              "downstream_commit": "f9825c3f507d5a3b4192bb8557c9cd8875ecf170",
              "commit_date": "2025-03-13 12:58:40 +0100",
              "result": "failure",
              "error": "patching file net/sched/sch_fifo.c\nHunk #1 FAILED at 40.\n1 out of 1 hunk FAILED -- saving rejects to file net/sched/sch_fifo.c.rej",
              "total_hunks": 0,
              "total_failed_hunks": 1,
              "failed_hunks": [1],
              "rej_file_content": "```diff\n--- net/sched/sch_fifo.c.rej ---\n--- net/sched/sch_fifo.c\n+++ net/sched/sch_fifo.c\n@@ -40,6 +40,9 @@ static int pfifo_tail_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n {\n \tunsigned int prev_backlog;\n \n+\tif (unlikely(READ_ONCE(sch->limit) == 0))\n+\t\treturn qdisc_drop(skb, sch, to_free);\n+\n \tif (likely(sch->q.qlen < READ_ONCE(sch->limit)))\n \t\treturn qdisc_enqueue_tail(skb, sch);\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tif (likely(sch->q.qlen < sch->limit))\n=======\n+ \tif (unlikely(READ_ONCE(sch->limit) == 0))\n+ \t\treturn qdisc_drop(skb, sch, to_free);\n+ \n+ \tif (likely(sch->q.qlen < READ_ONCE(sch->limit)))\n>>>>>>> INCOMING PATCH\n```"
            }
          ]
        }
      ]
    },
    {
      "cve_url": "https://web.git.kernel.org/pub/scm/linux/security/vulns.git/plain/cve/published/2025/CVE-2025-21706.json",
      "patch_attempts": [
        {
          "upstream_commit": "c86b000782daba926c627d2fa00c3f60a75e7472",
          "upstream_commit_date": "2025-01-27 15:07:02 -0800",
          "upstream_patch": "1bb0d1348546ad059f55c93def34e67cb2a034a6",
          "total_versions_tested": 4,
          "successful_patches": 3,
          "failed_patches": 1,
          "patch_results": [
            {
              "downstream_patch": "de3b8d41d2547452c4cafb146d003fa4689fbaf2",
              "downstream_commit": "785408bbafcfa24c9fc5b251f03fd0780ce182bd",
              "commit_date": "2025-02-17 09:40:42 +0100",
              "result": "failure",
              "error": "patching file net/mptcp/pm_netlink.c\nHunk #1 FAILED at 2020.\n1 out of 1 hunk FAILED -- saving rejects to file net/mptcp/pm_netlink.c.rej",
              "total_hunks": 0,
              "total_failed_hunks": 1,
              "failed_hunks": [1],
              "rej_file_content": "```diff\n--- net/mptcp/pm_netlink.c.rej ---\n--- net/mptcp/pm_netlink.c\n+++ net/mptcp/pm_netlink.c\n@@ -2020,7 +2020,8 @@ int mptcp_pm_nl_set_flags(struct sk_buff *skb, struct genl_info *info)\n \t\treturn -EINVAL;\n \t}\n \tif ((addr.flags & MPTCP_PM_ADDR_FLAG_FULLMESH) &&\n-\t    (entry->flags & MPTCP_PM_ADDR_FLAG_SIGNAL)) {\n+\t    (entry->flags & (MPTCP_PM_ADDR_FLAG_SIGNAL |\n+\t\t\t     MPTCP_PM_ADDR_FLAG_IMPLICIT))) {\n \t\tspin_unlock_bh(&pernet->lock);\n \t\tGENL_SET_ERR_MSG(info, \"invalid addr flags\");\n \t\treturn -EINVAL;\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tif ((addr->flags & MPTCP_PM_ADDR_FLAG_FULLMESH) &&\n- \t    (entry->flags & MPTCP_PM_ADDR_FLAG_SIGNAL)) {\n=======\n+ \tif ((addr.flags & MPTCP_PM_ADDR_FLAG_FULLMESH) &&\n+ \t    (entry->flags & (MPTCP_PM_ADDR_FLAG_SIGNAL |\n+ \t\t\t     MPTCP_PM_ADDR_FLAG_IMPLICIT))) {\n>>>>>>> INCOMING PATCH\n```"
            }
          ]
        }
      ]
    },
    {
      "cve_url": "https://web.git.kernel.org/pub/scm/linux/security/vulns.git/plain/cve/published/2025/CVE-2025-21712.json",
      "patch_attempts": [
        {
          "upstream_commit": "a9ae6fe1c319c4776c2b11e85e15109cd3f04076",
          "upstream_commit_date": "2025-01-24 10:03:32 -0800",
          "upstream_patch": "8d28d0ddb986f56920ac97ae704cc3340a699a30",
          "total_versions_tested": 4,
          "successful_patches": 3,
          "failed_patches": 1,
          "patch_results": [
            {
              "downstream_patch": "032fa54f486eac5507976e7e31f079a767bc13a8",
              "downstream_commit": "249d9b9da2c940e44b6a625331e33327750707c6",
              "commit_date": "2025-03-07 16:56:28 +0100",
              "result": "failure",
              "error": "patching file drivers/md/md-bitmap.c\nHunk #1 succeeded at 2029 (offset -326 lines).\npatching file drivers/md/md.c\nHunk #1 FAILED at 8376.\nHunk #2 FAILED at 8451.\n2 out of 2 hunks FAILED -- saving rejects to file drivers/md/md.c.rej",
              "total_hunks": 2,
              "total_failed_hunks": 2,
              "failed_hunks": [1, 2],
              "rej_file_content": "```diff\n--- drivers/md/md.c.rej ---\n--- drivers/md/md.c\n+++ drivers/md/md.c\n@@ -8376,6 +8376,10 @@ static int md_seq_show(struct seq_file *seq, void *v)\n \t\treturn 0;\n \n \tspin_unlock(&all_mddevs_lock);\n+\n+\t/* prevent bitmap to be freed after checking */\n+\tmutex_lock(&mddev->bitmap_info.mutex);\n+\n \tspin_lock(&mddev->lock);\n \tif (mddev->pers || mddev->raid_disks || !list_empty(&mddev->disks)) {\n \t\tseq_printf(seq, \"%s : \", mdname(mddev));\n@@ -8451,6 +8455,7 @@ static int md_seq_show(struct seq_file *seq, void *v)\n \t\tseq_printf(seq, \"\\n\");\n \t}\n \tspin_unlock(&mddev->lock);\n+\tmutex_unlock(&mddev->bitmap_info.mutex);\n \tspin_lock(&all_mddevs_lock);\n \n \tif (mddev == list_last_entry(&all_mddevs, struct mddev, all_mddevs))\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n\n=======\n+ \n+ \tif (!bitmap)\n+ \t\treturn -ENOENT;\n+ \tif (bitmap->mddev->bitmap_info.external)\n+ \t\treturn -ENOENT;\n+ \tif (!bitmap->storage.sb_page) /* no superblock */\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n\n=======\n+ \tspin_unlock(&all_mddevs_lock);\n+ \n+ \t/* prevent bitmap to be freed after checking */\n+ \tmutex_lock(&mddev->bitmap_info.mutex);\n+ \n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n\n=======\n+ \tmutex_unlock(&mddev->bitmap_info.mutex);\n+ \tspin_lock(&all_mddevs_lock);\n>>>>>>> INCOMING PATCH\n```"
            }
          ]
        }
      ]
    },
    {
      "cve_url": "https://web.git.kernel.org/pub/scm/linux/security/vulns.git/plain/cve/published/2025/CVE-2025-21721.json",
      "patch_attempts": [
        {
          "upstream_commit": "28097f7ba18753f7120bbd460bb2d099276dec8b",
          "upstream_commit_date": "2025-01-24 22:47:25 -0800",
          "upstream_patch": "ee70999a988b8abc3490609142f50ebaa8344432",
          "total_versions_tested": 7,
          "successful_patches": 2,
          "failed_patches": 5,
          "patch_results": [
            {
              "downstream_patch": "7891ac3b0a5c56f7148af507306308ab841cdc31",
              "downstream_commit": "35dcb8a3a70e9ae3be3eafb644bb2f8de2a95c4e",
              "commit_date": "2025-02-27 04:10:54 -0800",
              "result": "failure",
              "error": "patching file fs/nilfs2/dir.c\nHunk #1 FAILED at 400.\nHunk #2 FAILED at 410.\nHunk #3 FAILED at 543.\n3 out of 3 hunks FAILED -- saving rejects to file fs/nilfs2/dir.c.rej\npatching file fs/nilfs2/namei.c\nHunk #1 FAILED at 406.\nHunk #2 FAILED at 430.\n2 out of 2 hunks FAILED -- saving rejects to file fs/nilfs2/namei.c.rej\npatching file fs/nilfs2/nilfs.h\nHunk #1 FAILED at 261.\n1 out of 1 hunk FAILED -- saving rejects to file fs/nilfs2/nilfs.h.rej",
              "total_hunks": 3,
              "total_failed_hunks": 6,
              "failed_hunks": [1, 2, 3, 1, 2, 1],
              "rej_file_content": "```diff\n--- fs/nilfs2/dir.c.rej ---\n--- fs/nilfs2/dir.c\n+++ fs/nilfs2/dir.c\n@@ -400,7 +400,7 @@ int nilfs_inode_by_name(struct inode *dir, const struct qstr *qstr, ino_t *ino)\n \treturn 0;\n }\n \n-void nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n+int nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n \t\t    struct folio *folio, struct inode *inode)\n {\n \tsize_t from = offset_in_folio(folio, de);\n@@ -410,11 +410,15 @@ void nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n \n \tfolio_lock(folio);\n \terr = nilfs_prepare_chunk(folio, from, to);\n-\tBUG_ON(err);\n+\tif (unlikely(err)) {\n+\t\tfolio_unlock(folio);\n+\t\treturn err;\n+\t}\n \tde->inode = cpu_to_le64(inode->i_ino);\n \tde->file_type = fs_umode_to_ftype(inode->i_mode);\n \tnilfs_commit_chunk(folio, mapping, from, to);\n \tinode_set_mtime_to_ts(dir, inode_set_ctime_current(dir));\n+\treturn 0;\n }\n \n /*\n@@ -543,7 +547,10 @@ int nilfs_delete_entry(struct nilfs_dir_entry *dir, struct folio *folio)\n \t\tfrom = (char *)pde - kaddr;\n \tfolio_lock(folio);\n \terr = nilfs_prepare_chunk(folio, from, to);\n-\tBUG_ON(err);\n+\tif (unlikely(err)) {\n+\t\tfolio_unlock(folio);\n+\t\tgoto out;\n+\t}\n \tif (pde)\n \t\tpde->rec_len = nilfs_rec_len_to_disk(to - from);\n \tdir->inode = 0;\n\n--- fs/nilfs2/nilfs.h.rej ---\n--- fs/nilfs2/nilfs.h\n+++ fs/nilfs2/nilfs.h\n@@ -261,8 +261,8 @@ struct nilfs_dir_entry *nilfs_find_entry(struct inode *, const struct qstr *,\n int nilfs_delete_entry(struct nilfs_dir_entry *, struct folio *);\n int nilfs_empty_dir(struct inode *);\n struct nilfs_dir_entry *nilfs_dotdot(struct inode *, struct folio **);\n-void nilfs_set_link(struct inode *, struct nilfs_dir_entry *,\n-\t\t\t   struct folio *, struct inode *);\n+int nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n+\t\t   struct folio *folio, struct inode *inode);\n \n /* file.c */\n extern int nilfs_sync_file(struct file *, loff_t, loff_t, int);\n\n--- fs/nilfs2/namei.c.rej ---\n--- fs/nilfs2/namei.c\n+++ fs/nilfs2/namei.c\n@@ -406,8 +406,10 @@ static int nilfs_rename(struct mnt_idmap *idmap,\n \t\t\terr = PTR_ERR(new_de);\n \t\t\tgoto out_dir;\n \t\t}\n-\t\tnilfs_set_link(new_dir, new_de, new_folio, old_inode);\n+\t\terr = nilfs_set_link(new_dir, new_de, new_folio, old_inode);\n \t\tfolio_release_kmap(new_folio, new_de);\n+\t\tif (unlikely(err))\n+\t\t\tgoto out_dir;\n \t\tnilfs_mark_inode_dirty(new_dir);\n \t\tinode_set_ctime_current(new_inode);\n \t\tif (dir_de)\n@@ -430,28 +432,27 @@ static int nilfs_rename(struct mnt_idmap *idmap,\n \t */\n \tinode_set_ctime_current(old_inode);\n \n-\tnilfs_delete_entry(old_de, old_folio);\n-\n-\tif (dir_de) {\n-\t\tnilfs_set_link(old_inode, dir_de, dir_folio, new_dir);\n-\t\tfolio_release_kmap(dir_folio, dir_de);\n-\t\tdrop_nlink(old_dir);\n+\terr = nilfs_delete_entry(old_de, old_folio);\n+\tif (likely(!err)) {\n+\t\tif (dir_de) {\n+\t\t\terr = nilfs_set_link(old_inode, dir_de, dir_folio,\n+\t\t\t\t\t     new_dir);\n+\t\t\tdrop_nlink(old_dir);\n+\t\t}\n+\t\tnilfs_mark_inode_dirty(old_dir);\n \t}\n-\tfolio_release_kmap(old_folio, old_de);\n-\n-\tnilfs_mark_inode_dirty(old_dir);\n \tnilfs_mark_inode_dirty(old_inode);\n \n-\terr = nilfs_transaction_commit(old_dir->i_sb);\n-\treturn err;\n-\n out_dir:\n \tif (dir_de)\n \t\tfolio_release_kmap(dir_folio, dir_de);\n out_old:\n \tfolio_release_kmap(old_folio, old_de);\n out:\n-\tnilfs_transaction_abort(old_dir->i_sb);\n+\tif (likely(!err))\n+\t\terr = nilfs_transaction_commit(old_dir->i_sb);\n+\telse\n+\t\tnilfs_transaction_abort(old_dir->i_sb);\n \treturn err;\n }\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- void nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n- \t\t    struct page *page, struct inode *inode)\n=======\n+ int nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n+ \t\t    struct folio *folio, struct inode *inode)\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tlock_page(page);\n- \terr = nilfs_prepare_chunk(page, from, to);\n- \tBUG_ON(err);\n=======\n+ \tfolio_lock(folio);\n+ \terr = nilfs_prepare_chunk(folio, from, to);\n+ \tif (unlikely(err)) {\n+ \t\tfolio_unlock(folio);\n+ \t\treturn err;\n+ \t}\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tnilfs_set_de_type(de, inode);\n- \tnilfs_commit_chunk(page, mapping, from, to);\n- \tdir->i_mtime = inode_set_ctime_current(dir);\n=======\n+ \tde->file_type = fs_umode_to_ftype(inode->i_mode);\n+ \tnilfs_commit_chunk(folio, mapping, from, to);\n+ \tinode_set_mtime_to_ts(dir, inode_set_ctime_current(dir));\n+ \treturn 0;\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t\tfrom = (char *)pde - (char *)page_address(page);\n- \tlock_page(page);\n- \terr = nilfs_prepare_chunk(page, from, to);\n- \tBUG_ON(err);\n=======\n+ \t\tfrom = (char *)pde - kaddr;\n+ \tfolio_lock(folio);\n+ \terr = nilfs_prepare_chunk(folio, from, to);\n+ \tif (unlikely(err)) {\n+ \t\tfolio_unlock(folio);\n+ \t\tgoto out;\n+ \t}\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t\tnilfs_set_link(new_dir, new_de, new_page, old_inode);\n- \t\tnilfs_put_page(new_page);\n=======\n+ \t\terr = nilfs_set_link(new_dir, new_de, new_folio, old_inode);\n+ \t\tfolio_release_kmap(new_folio, new_de);\n+ \t\tif (unlikely(err))\n+ \t\t\tgoto out_dir;\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tnilfs_delete_entry(old_de, old_page);\n- \n- \tif (dir_de) {\n- \t\tnilfs_set_link(old_inode, dir_de, dir_page, new_dir);\n- \t\tnilfs_put_page(dir_page);\n- \t\tdrop_nlink(old_dir);\n=======\n+ \terr = nilfs_delete_entry(old_de, old_folio);\n+ \tif (likely(!err)) {\n+ \t\tif (dir_de) {\n+ \t\t\terr = nilfs_set_link(old_inode, dir_de, dir_folio,\n+ \t\t\t\t\t     new_dir);\n+ \t\t\tdrop_nlink(old_dir);\n+ \t\t}\n+ \t\tnilfs_mark_inode_dirty(old_dir);\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tnilfs_put_page(old_page);\n- \n- \tnilfs_mark_inode_dirty(old_dir);\n=======\n\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- }\n=======\n+ int nilfs_delete_entry(struct nilfs_dir_entry *, struct folio *);\n+ int nilfs_empty_dir(struct inode *);\n+ struct nilfs_dir_entry *nilfs_dotdot(struct inode *, struct folio **);\n+ int nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n+ \t\t   struct folio *folio, struct inode *inode);\n>>>>>>> INCOMING PATCH\n```"
            },
            {
              "downstream_patch": "b38c6c260c2415c7f0968871305e7a093daabb4c",
              "downstream_commit": "620e036978a2331e64e47a1b251986ca67843f7b",
              "commit_date": "2025-03-13 12:43:04 +0100",
              "result": "failure",
              "error": "patching file fs/nilfs2/dir.c\nHunk #1 FAILED at 400.\nHunk #2 FAILED at 410.\nHunk #3 FAILED at 543.\n3 out of 3 hunks FAILED -- saving rejects to file fs/nilfs2/dir.c.rej\npatching file fs/nilfs2/namei.c\nHunk #1 FAILED at 406.\nHunk #2 FAILED at 430.\n2 out of 2 hunks FAILED -- saving rejects to file fs/nilfs2/namei.c.rej\npatching file fs/nilfs2/nilfs.h\nHunk #1 FAILED at 261.\n1 out of 1 hunk FAILED -- saving rejects to file fs/nilfs2/nilfs.h.rej",
              "total_hunks": 3,
              "total_failed_hunks": 6,
              "failed_hunks": [1, 2, 3, 1, 2, 1],
              "rej_file_content": "```diff\n--- fs/nilfs2/dir.c.rej ---\n--- fs/nilfs2/dir.c\n+++ fs/nilfs2/dir.c\n@@ -400,7 +400,7 @@ int nilfs_inode_by_name(struct inode *dir, const struct qstr *qstr, ino_t *ino)\n \treturn 0;\n }\n \n-void nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n+int nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n \t\t    struct folio *folio, struct inode *inode)\n {\n \tsize_t from = offset_in_folio(folio, de);\n@@ -410,11 +410,15 @@ void nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n \n \tfolio_lock(folio);\n \terr = nilfs_prepare_chunk(folio, from, to);\n-\tBUG_ON(err);\n+\tif (unlikely(err)) {\n+\t\tfolio_unlock(folio);\n+\t\treturn err;\n+\t}\n \tde->inode = cpu_to_le64(inode->i_ino);\n \tde->file_type = fs_umode_to_ftype(inode->i_mode);\n \tnilfs_commit_chunk(folio, mapping, from, to);\n \tinode_set_mtime_to_ts(dir, inode_set_ctime_current(dir));\n+\treturn 0;\n }\n \n /*\n@@ -543,7 +547,10 @@ int nilfs_delete_entry(struct nilfs_dir_entry *dir, struct folio *folio)\n \t\tfrom = (char *)pde - kaddr;\n \tfolio_lock(folio);\n \terr = nilfs_prepare_chunk(folio, from, to);\n-\tBUG_ON(err);\n+\tif (unlikely(err)) {\n+\t\tfolio_unlock(folio);\n+\t\tgoto out;\n+\t}\n \tif (pde)\n \t\tpde->rec_len = nilfs_rec_len_to_disk(to - from);\n \tdir->inode = 0;\n\n--- fs/nilfs2/nilfs.h.rej ---\n--- fs/nilfs2/nilfs.h\n+++ fs/nilfs2/nilfs.h\n@@ -261,8 +261,8 @@ struct nilfs_dir_entry *nilfs_find_entry(struct inode *, const struct qstr *,\n int nilfs_delete_entry(struct nilfs_dir_entry *, struct folio *);\n int nilfs_empty_dir(struct inode *);\n struct nilfs_dir_entry *nilfs_dotdot(struct inode *, struct folio **);\n-void nilfs_set_link(struct inode *, struct nilfs_dir_entry *,\n-\t\t\t   struct folio *, struct inode *);\n+int nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n+\t\t   struct folio *folio, struct inode *inode);\n \n /* file.c */\n extern int nilfs_sync_file(struct file *, loff_t, loff_t, int);\n\n--- fs/nilfs2/namei.c.rej ---\n--- fs/nilfs2/namei.c\n+++ fs/nilfs2/namei.c\n@@ -406,8 +406,10 @@ static int nilfs_rename(struct mnt_idmap *idmap,\n \t\t\terr = PTR_ERR(new_de);\n \t\t\tgoto out_dir;\n \t\t}\n-\t\tnilfs_set_link(new_dir, new_de, new_folio, old_inode);\n+\t\terr = nilfs_set_link(new_dir, new_de, new_folio, old_inode);\n \t\tfolio_release_kmap(new_folio, new_de);\n+\t\tif (unlikely(err))\n+\t\t\tgoto out_dir;\n \t\tnilfs_mark_inode_dirty(new_dir);\n \t\tinode_set_ctime_current(new_inode);\n \t\tif (dir_de)\n@@ -430,28 +432,27 @@ static int nilfs_rename(struct mnt_idmap *idmap,\n \t */\n \tinode_set_ctime_current(old_inode);\n \n-\tnilfs_delete_entry(old_de, old_folio);\n-\n-\tif (dir_de) {\n-\t\tnilfs_set_link(old_inode, dir_de, dir_folio, new_dir);\n-\t\tfolio_release_kmap(dir_folio, dir_de);\n-\t\tdrop_nlink(old_dir);\n+\terr = nilfs_delete_entry(old_de, old_folio);\n+\tif (likely(!err)) {\n+\t\tif (dir_de) {\n+\t\t\terr = nilfs_set_link(old_inode, dir_de, dir_folio,\n+\t\t\t\t\t     new_dir);\n+\t\t\tdrop_nlink(old_dir);\n+\t\t}\n+\t\tnilfs_mark_inode_dirty(old_dir);\n \t}\n-\tfolio_release_kmap(old_folio, old_de);\n-\n-\tnilfs_mark_inode_dirty(old_dir);\n \tnilfs_mark_inode_dirty(old_inode);\n \n-\terr = nilfs_transaction_commit(old_dir->i_sb);\n-\treturn err;\n-\n out_dir:\n \tif (dir_de)\n \t\tfolio_release_kmap(dir_folio, dir_de);\n out_old:\n \tfolio_release_kmap(old_folio, old_de);\n out:\n-\tnilfs_transaction_abort(old_dir->i_sb);\n+\tif (likely(!err))\n+\t\terr = nilfs_transaction_commit(old_dir->i_sb);\n+\telse\n+\t\tnilfs_transaction_abort(old_dir->i_sb);\n \treturn err;\n }\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- void nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n- \t\t    struct page *page, struct inode *inode)\n=======\n+ int nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n+ \t\t    struct folio *folio, struct inode *inode)\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tlock_page(page);\n- \terr = nilfs_prepare_chunk(page, from, to);\n- \tBUG_ON(err);\n=======\n+ \tfolio_lock(folio);\n+ \terr = nilfs_prepare_chunk(folio, from, to);\n+ \tif (unlikely(err)) {\n+ \t\tfolio_unlock(folio);\n+ \t\treturn err;\n+ \t}\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tnilfs_set_de_type(de, inode);\n- \tnilfs_commit_chunk(page, mapping, from, to);\n- \tdir->i_mtime = dir->i_ctime = current_time(dir);\n=======\n+ \tde->file_type = fs_umode_to_ftype(inode->i_mode);\n+ \tnilfs_commit_chunk(folio, mapping, from, to);\n+ \tinode_set_mtime_to_ts(dir, inode_set_ctime_current(dir));\n+ \treturn 0;\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t\tfrom = (char *)pde - (char *)page_address(page);\n- \tlock_page(page);\n- \terr = nilfs_prepare_chunk(page, from, to);\n- \tBUG_ON(err);\n=======\n+ \t\tfrom = (char *)pde - kaddr;\n+ \tfolio_lock(folio);\n+ \terr = nilfs_prepare_chunk(folio, from, to);\n+ \tif (unlikely(err)) {\n+ \t\tfolio_unlock(folio);\n+ \t\tgoto out;\n+ \t}\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t\tnilfs_set_link(new_dir, new_de, new_page, old_inode);\n- \t\tnilfs_put_page(new_page);\n=======\n+ \t\terr = nilfs_set_link(new_dir, new_de, new_folio, old_inode);\n+ \t\tfolio_release_kmap(new_folio, new_de);\n+ \t\tif (unlikely(err))\n+ \t\t\tgoto out_dir;\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tnilfs_delete_entry(old_de, old_page);\n- \n- \tif (dir_de) {\n- \t\tnilfs_set_link(old_inode, dir_de, dir_page, new_dir);\n- \t\tnilfs_put_page(dir_page);\n- \t\tdrop_nlink(old_dir);\n=======\n+ \terr = nilfs_delete_entry(old_de, old_folio);\n+ \tif (likely(!err)) {\n+ \t\tif (dir_de) {\n+ \t\t\terr = nilfs_set_link(old_inode, dir_de, dir_folio,\n+ \t\t\t\t\t     new_dir);\n+ \t\t\tdrop_nlink(old_dir);\n+ \t\t}\n+ \t\tnilfs_mark_inode_dirty(old_dir);\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tnilfs_put_page(old_page);\n- \n- \tnilfs_mark_inode_dirty(old_dir);\n=======\n\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- }\n=======\n+ int nilfs_delete_entry(struct nilfs_dir_entry *, struct folio *);\n+ int nilfs_empty_dir(struct inode *);\n+ struct nilfs_dir_entry *nilfs_dotdot(struct inode *, struct folio **);\n+ int nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n+ \t\t   struct folio *folio, struct inode *inode);\n>>>>>>> INCOMING PATCH\n```"
            },
            {
              "downstream_patch": "f70bd2d8ca454e0ed78970f72147ca321dbaa015",
              "downstream_commit": "19dfe647f8ad9743e70aaaa2f56443aa09e74316",
              "commit_date": "2025-03-13 12:47:43 +0100",
              "result": "failure",
              "error": "patching file fs/nilfs2/dir.c\nHunk #1 FAILED at 400.\nHunk #2 FAILED at 410.\nHunk #3 FAILED at 543.\n3 out of 3 hunks FAILED -- saving rejects to file fs/nilfs2/dir.c.rej\npatching file fs/nilfs2/namei.c\nHunk #1 FAILED at 406.\nHunk #2 FAILED at 430.\n2 out of 2 hunks FAILED -- saving rejects to file fs/nilfs2/namei.c.rej\npatching file fs/nilfs2/nilfs.h\nHunk #1 FAILED at 261.\n1 out of 1 hunk FAILED -- saving rejects to file fs/nilfs2/nilfs.h.rej",
              "total_hunks": 3,
              "total_failed_hunks": 6,
              "failed_hunks": [1, 2, 3, 1, 2, 1],
              "rej_file_content": "```diff\n--- fs/nilfs2/dir.c.rej ---\n--- fs/nilfs2/dir.c\n+++ fs/nilfs2/dir.c\n@@ -400,7 +400,7 @@ int nilfs_inode_by_name(struct inode *dir, const struct qstr *qstr, ino_t *ino)\n \treturn 0;\n }\n \n-void nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n+int nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n \t\t    struct folio *folio, struct inode *inode)\n {\n \tsize_t from = offset_in_folio(folio, de);\n@@ -410,11 +410,15 @@ void nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n \n \tfolio_lock(folio);\n \terr = nilfs_prepare_chunk(folio, from, to);\n-\tBUG_ON(err);\n+\tif (unlikely(err)) {\n+\t\tfolio_unlock(folio);\n+\t\treturn err;\n+\t}\n \tde->inode = cpu_to_le64(inode->i_ino);\n \tde->file_type = fs_umode_to_ftype(inode->i_mode);\n \tnilfs_commit_chunk(folio, mapping, from, to);\n \tinode_set_mtime_to_ts(dir, inode_set_ctime_current(dir));\n+\treturn 0;\n }\n \n /*\n@@ -543,7 +547,10 @@ int nilfs_delete_entry(struct nilfs_dir_entry *dir, struct folio *folio)\n \t\tfrom = (char *)pde - kaddr;\n \tfolio_lock(folio);\n \terr = nilfs_prepare_chunk(folio, from, to);\n-\tBUG_ON(err);\n+\tif (unlikely(err)) {\n+\t\tfolio_unlock(folio);\n+\t\tgoto out;\n+\t}\n \tif (pde)\n \t\tpde->rec_len = nilfs_rec_len_to_disk(to - from);\n \tdir->inode = 0;\n\n--- fs/nilfs2/nilfs.h.rej ---\n--- fs/nilfs2/nilfs.h\n+++ fs/nilfs2/nilfs.h\n@@ -261,8 +261,8 @@ struct nilfs_dir_entry *nilfs_find_entry(struct inode *, const struct qstr *,\n int nilfs_delete_entry(struct nilfs_dir_entry *, struct folio *);\n int nilfs_empty_dir(struct inode *);\n struct nilfs_dir_entry *nilfs_dotdot(struct inode *, struct folio **);\n-void nilfs_set_link(struct inode *, struct nilfs_dir_entry *,\n-\t\t\t   struct folio *, struct inode *);\n+int nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n+\t\t   struct folio *folio, struct inode *inode);\n \n /* file.c */\n extern int nilfs_sync_file(struct file *, loff_t, loff_t, int);\n\n--- fs/nilfs2/namei.c.rej ---\n--- fs/nilfs2/namei.c\n+++ fs/nilfs2/namei.c\n@@ -406,8 +406,10 @@ static int nilfs_rename(struct mnt_idmap *idmap,\n \t\t\terr = PTR_ERR(new_de);\n \t\t\tgoto out_dir;\n \t\t}\n-\t\tnilfs_set_link(new_dir, new_de, new_folio, old_inode);\n+\t\terr = nilfs_set_link(new_dir, new_de, new_folio, old_inode);\n \t\tfolio_release_kmap(new_folio, new_de);\n+\t\tif (unlikely(err))\n+\t\t\tgoto out_dir;\n \t\tnilfs_mark_inode_dirty(new_dir);\n \t\tinode_set_ctime_current(new_inode);\n \t\tif (dir_de)\n@@ -430,28 +432,27 @@ static int nilfs_rename(struct mnt_idmap *idmap,\n \t */\n \tinode_set_ctime_current(old_inode);\n \n-\tnilfs_delete_entry(old_de, old_folio);\n-\n-\tif (dir_de) {\n-\t\tnilfs_set_link(old_inode, dir_de, dir_folio, new_dir);\n-\t\tfolio_release_kmap(dir_folio, dir_de);\n-\t\tdrop_nlink(old_dir);\n+\terr = nilfs_delete_entry(old_de, old_folio);\n+\tif (likely(!err)) {\n+\t\tif (dir_de) {\n+\t\t\terr = nilfs_set_link(old_inode, dir_de, dir_folio,\n+\t\t\t\t\t     new_dir);\n+\t\t\tdrop_nlink(old_dir);\n+\t\t}\n+\t\tnilfs_mark_inode_dirty(old_dir);\n \t}\n-\tfolio_release_kmap(old_folio, old_de);\n-\n-\tnilfs_mark_inode_dirty(old_dir);\n \tnilfs_mark_inode_dirty(old_inode);\n \n-\terr = nilfs_transaction_commit(old_dir->i_sb);\n-\treturn err;\n-\n out_dir:\n \tif (dir_de)\n \t\tfolio_release_kmap(dir_folio, dir_de);\n out_old:\n \tfolio_release_kmap(old_folio, old_de);\n out:\n-\tnilfs_transaction_abort(old_dir->i_sb);\n+\tif (likely(!err))\n+\t\terr = nilfs_transaction_commit(old_dir->i_sb);\n+\telse\n+\t\tnilfs_transaction_abort(old_dir->i_sb);\n \treturn err;\n }\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- void nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n- \t\t    struct page *page, struct inode *inode)\n=======\n+ int nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n+ \t\t    struct folio *folio, struct inode *inode)\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tlock_page(page);\n- \terr = nilfs_prepare_chunk(page, from, to);\n- \tBUG_ON(err);\n=======\n+ \tfolio_lock(folio);\n+ \terr = nilfs_prepare_chunk(folio, from, to);\n+ \tif (unlikely(err)) {\n+ \t\tfolio_unlock(folio);\n+ \t\treturn err;\n+ \t}\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tnilfs_set_de_type(de, inode);\n- \tnilfs_commit_chunk(page, mapping, from, to);\n- \tdir->i_mtime = dir->i_ctime = current_time(dir);\n=======\n+ \tde->file_type = fs_umode_to_ftype(inode->i_mode);\n+ \tnilfs_commit_chunk(folio, mapping, from, to);\n+ \tinode_set_mtime_to_ts(dir, inode_set_ctime_current(dir));\n+ \treturn 0;\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t\tfrom = (char *)pde - (char *)page_address(page);\n- \tlock_page(page);\n- \terr = nilfs_prepare_chunk(page, from, to);\n- \tBUG_ON(err);\n=======\n+ \t\tfrom = (char *)pde - kaddr;\n+ \tfolio_lock(folio);\n+ \terr = nilfs_prepare_chunk(folio, from, to);\n+ \tif (unlikely(err)) {\n+ \t\tfolio_unlock(folio);\n+ \t\tgoto out;\n+ \t}\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t\tnilfs_set_link(new_dir, new_de, new_page, old_inode);\n- \t\tnilfs_put_page(new_page);\n=======\n+ \t\terr = nilfs_set_link(new_dir, new_de, new_folio, old_inode);\n+ \t\tfolio_release_kmap(new_folio, new_de);\n+ \t\tif (unlikely(err))\n+ \t\t\tgoto out_dir;\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tnilfs_delete_entry(old_de, old_page);\n- \n- \tif (dir_de) {\n- \t\tnilfs_set_link(old_inode, dir_de, dir_page, new_dir);\n- \t\tnilfs_put_page(dir_page);\n- \t\tdrop_nlink(old_dir);\n=======\n+ \terr = nilfs_delete_entry(old_de, old_folio);\n+ \tif (likely(!err)) {\n+ \t\tif (dir_de) {\n+ \t\t\terr = nilfs_set_link(old_inode, dir_de, dir_folio,\n+ \t\t\t\t\t     new_dir);\n+ \t\t\tdrop_nlink(old_dir);\n+ \t\t}\n+ \t\tnilfs_mark_inode_dirty(old_dir);\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tnilfs_put_page(old_page);\n- \n- \tnilfs_mark_inode_dirty(old_dir);\n=======\n\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- }\n=======\n+ int nilfs_delete_entry(struct nilfs_dir_entry *, struct folio *);\n+ int nilfs_empty_dir(struct inode *);\n+ struct nilfs_dir_entry *nilfs_dotdot(struct inode *, struct folio **);\n+ int nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n+ \t\t   struct folio *folio, struct inode *inode);\n>>>>>>> INCOMING PATCH\n```"
            },
            {
              "downstream_patch": "607dc724b162f4452dc768865e578c1a509a1c8c",
              "downstream_commit": "e5606b783307b76b2d76feb8719a3ca7f036438b",
              "commit_date": "2025-03-13 12:51:12 +0100",
              "result": "failure",
              "error": "patching file fs/nilfs2/dir.c\nHunk #1 FAILED at 400.\nHunk #2 FAILED at 410.\nHunk #3 FAILED at 543.\n3 out of 3 hunks FAILED -- saving rejects to file fs/nilfs2/dir.c.rej\npatching file fs/nilfs2/namei.c\nHunk #1 FAILED at 406.\nHunk #2 FAILED at 430.\n2 out of 2 hunks FAILED -- saving rejects to file fs/nilfs2/namei.c.rej\npatching file fs/nilfs2/nilfs.h\nHunk #1 FAILED at 261.\n1 out of 1 hunk FAILED -- saving rejects to file fs/nilfs2/nilfs.h.rej",
              "total_hunks": 3,
              "total_failed_hunks": 6,
              "failed_hunks": [1, 2, 3, 1, 2, 1],
              "rej_file_content": "```diff\n--- fs/nilfs2/dir.c.rej ---\n--- fs/nilfs2/dir.c\n+++ fs/nilfs2/dir.c\n@@ -400,7 +400,7 @@ int nilfs_inode_by_name(struct inode *dir, const struct qstr *qstr, ino_t *ino)\n \treturn 0;\n }\n \n-void nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n+int nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n \t\t    struct folio *folio, struct inode *inode)\n {\n \tsize_t from = offset_in_folio(folio, de);\n@@ -410,11 +410,15 @@ void nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n \n \tfolio_lock(folio);\n \terr = nilfs_prepare_chunk(folio, from, to);\n-\tBUG_ON(err);\n+\tif (unlikely(err)) {\n+\t\tfolio_unlock(folio);\n+\t\treturn err;\n+\t}\n \tde->inode = cpu_to_le64(inode->i_ino);\n \tde->file_type = fs_umode_to_ftype(inode->i_mode);\n \tnilfs_commit_chunk(folio, mapping, from, to);\n \tinode_set_mtime_to_ts(dir, inode_set_ctime_current(dir));\n+\treturn 0;\n }\n \n /*\n@@ -543,7 +547,10 @@ int nilfs_delete_entry(struct nilfs_dir_entry *dir, struct folio *folio)\n \t\tfrom = (char *)pde - kaddr;\n \tfolio_lock(folio);\n \terr = nilfs_prepare_chunk(folio, from, to);\n-\tBUG_ON(err);\n+\tif (unlikely(err)) {\n+\t\tfolio_unlock(folio);\n+\t\tgoto out;\n+\t}\n \tif (pde)\n \t\tpde->rec_len = nilfs_rec_len_to_disk(to - from);\n \tdir->inode = 0;\n\n--- fs/nilfs2/nilfs.h.rej ---\n--- fs/nilfs2/nilfs.h\n+++ fs/nilfs2/nilfs.h\n@@ -261,8 +261,8 @@ struct nilfs_dir_entry *nilfs_find_entry(struct inode *, const struct qstr *,\n int nilfs_delete_entry(struct nilfs_dir_entry *, struct folio *);\n int nilfs_empty_dir(struct inode *);\n struct nilfs_dir_entry *nilfs_dotdot(struct inode *, struct folio **);\n-void nilfs_set_link(struct inode *, struct nilfs_dir_entry *,\n-\t\t\t   struct folio *, struct inode *);\n+int nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n+\t\t   struct folio *folio, struct inode *inode);\n \n /* file.c */\n extern int nilfs_sync_file(struct file *, loff_t, loff_t, int);\n\n--- fs/nilfs2/namei.c.rej ---\n--- fs/nilfs2/namei.c\n+++ fs/nilfs2/namei.c\n@@ -406,8 +406,10 @@ static int nilfs_rename(struct mnt_idmap *idmap,\n \t\t\terr = PTR_ERR(new_de);\n \t\t\tgoto out_dir;\n \t\t}\n-\t\tnilfs_set_link(new_dir, new_de, new_folio, old_inode);\n+\t\terr = nilfs_set_link(new_dir, new_de, new_folio, old_inode);\n \t\tfolio_release_kmap(new_folio, new_de);\n+\t\tif (unlikely(err))\n+\t\t\tgoto out_dir;\n \t\tnilfs_mark_inode_dirty(new_dir);\n \t\tinode_set_ctime_current(new_inode);\n \t\tif (dir_de)\n@@ -430,28 +432,27 @@ static int nilfs_rename(struct mnt_idmap *idmap,\n \t */\n \tinode_set_ctime_current(old_inode);\n \n-\tnilfs_delete_entry(old_de, old_folio);\n-\n-\tif (dir_de) {\n-\t\tnilfs_set_link(old_inode, dir_de, dir_folio, new_dir);\n-\t\tfolio_release_kmap(dir_folio, dir_de);\n-\t\tdrop_nlink(old_dir);\n+\terr = nilfs_delete_entry(old_de, old_folio);\n+\tif (likely(!err)) {\n+\t\tif (dir_de) {\n+\t\t\terr = nilfs_set_link(old_inode, dir_de, dir_folio,\n+\t\t\t\t\t     new_dir);\n+\t\t\tdrop_nlink(old_dir);\n+\t\t}\n+\t\tnilfs_mark_inode_dirty(old_dir);\n \t}\n-\tfolio_release_kmap(old_folio, old_de);\n-\n-\tnilfs_mark_inode_dirty(old_dir);\n \tnilfs_mark_inode_dirty(old_inode);\n \n-\terr = nilfs_transaction_commit(old_dir->i_sb);\n-\treturn err;\n-\n out_dir:\n \tif (dir_de)\n \t\tfolio_release_kmap(dir_folio, dir_de);\n out_old:\n \tfolio_release_kmap(old_folio, old_de);\n out:\n-\tnilfs_transaction_abort(old_dir->i_sb);\n+\tif (likely(!err))\n+\t\terr = nilfs_transaction_commit(old_dir->i_sb);\n+\telse\n+\t\tnilfs_transaction_abort(old_dir->i_sb);\n \treturn err;\n }\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- void nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n- \t\t    struct page *page, struct inode *inode)\n=======\n+ int nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n+ \t\t    struct folio *folio, struct inode *inode)\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tlock_page(page);\n- \terr = nilfs_prepare_chunk(page, from, to);\n- \tBUG_ON(err);\n=======\n+ \tfolio_lock(folio);\n+ \terr = nilfs_prepare_chunk(folio, from, to);\n+ \tif (unlikely(err)) {\n+ \t\tfolio_unlock(folio);\n+ \t\treturn err;\n+ \t}\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tnilfs_set_de_type(de, inode);\n- \tnilfs_commit_chunk(page, mapping, from, to);\n- \tdir->i_mtime = dir->i_ctime = current_time(dir);\n=======\n+ \tde->file_type = fs_umode_to_ftype(inode->i_mode);\n+ \tnilfs_commit_chunk(folio, mapping, from, to);\n+ \tinode_set_mtime_to_ts(dir, inode_set_ctime_current(dir));\n+ \treturn 0;\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t\tfrom = (char *)pde - (char *)page_address(page);\n- \tlock_page(page);\n- \terr = nilfs_prepare_chunk(page, from, to);\n- \tBUG_ON(err);\n=======\n+ \t\tfrom = (char *)pde - kaddr;\n+ \tfolio_lock(folio);\n+ \terr = nilfs_prepare_chunk(folio, from, to);\n+ \tif (unlikely(err)) {\n+ \t\tfolio_unlock(folio);\n+ \t\tgoto out;\n+ \t}\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n\n=======\n+ \t\terr = nilfs_set_link(new_dir, new_de, new_folio, old_inode);\n+ \t\tfolio_release_kmap(new_folio, new_de);\n+ \t\tif (unlikely(err))\n+ \t\t\tgoto out_dir;\n+ \t\tnilfs_mark_inode_dirty(new_dir);\n+ \t\tinode_set_ctime_current(new_inode);\n+ \t\tif (dir_de)\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tnilfs_delete_entry(old_de, old_page);\n- \n- \tif (dir_de) {\n- \t\tnilfs_set_link(old_inode, dir_de, dir_page, new_dir);\n- \t\tnilfs_put_page(dir_page);\n- \t\tdrop_nlink(old_dir);\n=======\n+ \terr = nilfs_delete_entry(old_de, old_folio);\n+ \tif (likely(!err)) {\n+ \t\tif (dir_de) {\n+ \t\t\terr = nilfs_set_link(old_inode, dir_de, dir_folio,\n+ \t\t\t\t\t     new_dir);\n+ \t\t\tdrop_nlink(old_dir);\n+ \t\t}\n+ \t\tnilfs_mark_inode_dirty(old_dir);\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tnilfs_put_page(old_page);\n- \n- \tnilfs_mark_inode_dirty(old_dir);\n=======\n\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- }\n=======\n+ int nilfs_delete_entry(struct nilfs_dir_entry *, struct folio *);\n+ int nilfs_empty_dir(struct inode *);\n+ struct nilfs_dir_entry *nilfs_dotdot(struct inode *, struct folio **);\n+ int nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n+ \t\t   struct folio *folio, struct inode *inode);\n>>>>>>> INCOMING PATCH\n```"
            },
            {
              "downstream_patch": "1ee2d454baa361d2964e3e2f2cca9ee3f769d93c",
              "downstream_commit": "982319391e19997b4533d1c7b3763dee35d3d6ef",
              "commit_date": "2025-03-13 12:53:25 +0100",
              "result": "failure",
              "error": "patching file fs/nilfs2/dir.c\nHunk #1 FAILED at 400.\nHunk #2 FAILED at 410.\nHunk #3 FAILED at 543.\n3 out of 3 hunks FAILED -- saving rejects to file fs/nilfs2/dir.c.rej\npatching file fs/nilfs2/namei.c\nHunk #1 FAILED at 406.\nHunk #2 FAILED at 430.\n2 out of 2 hunks FAILED -- saving rejects to file fs/nilfs2/namei.c.rej\npatching file fs/nilfs2/nilfs.h\nHunk #1 FAILED at 261.\n1 out of 1 hunk FAILED -- saving rejects to file fs/nilfs2/nilfs.h.rej",
              "total_hunks": 3,
              "total_failed_hunks": 6,
              "failed_hunks": [1, 2, 3, 1, 2, 1],
              "rej_file_content": "```diff\n--- fs/nilfs2/dir.c.rej ---\n--- fs/nilfs2/dir.c\n+++ fs/nilfs2/dir.c\n@@ -400,7 +400,7 @@ int nilfs_inode_by_name(struct inode *dir, const struct qstr *qstr, ino_t *ino)\n \treturn 0;\n }\n \n-void nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n+int nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n \t\t    struct folio *folio, struct inode *inode)\n {\n \tsize_t from = offset_in_folio(folio, de);\n@@ -410,11 +410,15 @@ void nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n \n \tfolio_lock(folio);\n \terr = nilfs_prepare_chunk(folio, from, to);\n-\tBUG_ON(err);\n+\tif (unlikely(err)) {\n+\t\tfolio_unlock(folio);\n+\t\treturn err;\n+\t}\n \tde->inode = cpu_to_le64(inode->i_ino);\n \tde->file_type = fs_umode_to_ftype(inode->i_mode);\n \tnilfs_commit_chunk(folio, mapping, from, to);\n \tinode_set_mtime_to_ts(dir, inode_set_ctime_current(dir));\n+\treturn 0;\n }\n \n /*\n@@ -543,7 +547,10 @@ int nilfs_delete_entry(struct nilfs_dir_entry *dir, struct folio *folio)\n \t\tfrom = (char *)pde - kaddr;\n \tfolio_lock(folio);\n \terr = nilfs_prepare_chunk(folio, from, to);\n-\tBUG_ON(err);\n+\tif (unlikely(err)) {\n+\t\tfolio_unlock(folio);\n+\t\tgoto out;\n+\t}\n \tif (pde)\n \t\tpde->rec_len = nilfs_rec_len_to_disk(to - from);\n \tdir->inode = 0;\n\n--- fs/nilfs2/nilfs.h.rej ---\n--- fs/nilfs2/nilfs.h\n+++ fs/nilfs2/nilfs.h\n@@ -261,8 +261,8 @@ struct nilfs_dir_entry *nilfs_find_entry(struct inode *, const struct qstr *,\n int nilfs_delete_entry(struct nilfs_dir_entry *, struct folio *);\n int nilfs_empty_dir(struct inode *);\n struct nilfs_dir_entry *nilfs_dotdot(struct inode *, struct folio **);\n-void nilfs_set_link(struct inode *, struct nilfs_dir_entry *,\n-\t\t\t   struct folio *, struct inode *);\n+int nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n+\t\t   struct folio *folio, struct inode *inode);\n \n /* file.c */\n extern int nilfs_sync_file(struct file *, loff_t, loff_t, int);\n\n--- fs/nilfs2/namei.c.rej ---\n--- fs/nilfs2/namei.c\n+++ fs/nilfs2/namei.c\n@@ -406,8 +406,10 @@ static int nilfs_rename(struct mnt_idmap *idmap,\n \t\t\terr = PTR_ERR(new_de);\n \t\t\tgoto out_dir;\n \t\t}\n-\t\tnilfs_set_link(new_dir, new_de, new_folio, old_inode);\n+\t\terr = nilfs_set_link(new_dir, new_de, new_folio, old_inode);\n \t\tfolio_release_kmap(new_folio, new_de);\n+\t\tif (unlikely(err))\n+\t\t\tgoto out_dir;\n \t\tnilfs_mark_inode_dirty(new_dir);\n \t\tinode_set_ctime_current(new_inode);\n \t\tif (dir_de)\n@@ -430,28 +432,27 @@ static int nilfs_rename(struct mnt_idmap *idmap,\n \t */\n \tinode_set_ctime_current(old_inode);\n \n-\tnilfs_delete_entry(old_de, old_folio);\n-\n-\tif (dir_de) {\n-\t\tnilfs_set_link(old_inode, dir_de, dir_folio, new_dir);\n-\t\tfolio_release_kmap(dir_folio, dir_de);\n-\t\tdrop_nlink(old_dir);\n+\terr = nilfs_delete_entry(old_de, old_folio);\n+\tif (likely(!err)) {\n+\t\tif (dir_de) {\n+\t\t\terr = nilfs_set_link(old_inode, dir_de, dir_folio,\n+\t\t\t\t\t     new_dir);\n+\t\t\tdrop_nlink(old_dir);\n+\t\t}\n+\t\tnilfs_mark_inode_dirty(old_dir);\n \t}\n-\tfolio_release_kmap(old_folio, old_de);\n-\n-\tnilfs_mark_inode_dirty(old_dir);\n \tnilfs_mark_inode_dirty(old_inode);\n \n-\terr = nilfs_transaction_commit(old_dir->i_sb);\n-\treturn err;\n-\n out_dir:\n \tif (dir_de)\n \t\tfolio_release_kmap(dir_folio, dir_de);\n out_old:\n \tfolio_release_kmap(old_folio, old_de);\n out:\n-\tnilfs_transaction_abort(old_dir->i_sb);\n+\tif (likely(!err))\n+\t\terr = nilfs_transaction_commit(old_dir->i_sb);\n+\telse\n+\t\tnilfs_transaction_abort(old_dir->i_sb);\n \treturn err;\n }\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- void nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n- \t\t    struct page *page, struct inode *inode)\n=======\n+ int nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n+ \t\t    struct folio *folio, struct inode *inode)\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tlock_page(page);\n- \terr = nilfs_prepare_chunk(page, from, to);\n- \tBUG_ON(err);\n=======\n+ \tfolio_lock(folio);\n+ \terr = nilfs_prepare_chunk(folio, from, to);\n+ \tif (unlikely(err)) {\n+ \t\tfolio_unlock(folio);\n+ \t\treturn err;\n+ \t}\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tnilfs_set_de_type(de, inode);\n- \tnilfs_commit_chunk(page, mapping, from, to);\n- \tdir->i_mtime = dir->i_ctime = current_time(dir);\n=======\n+ \tde->file_type = fs_umode_to_ftype(inode->i_mode);\n+ \tnilfs_commit_chunk(folio, mapping, from, to);\n+ \tinode_set_mtime_to_ts(dir, inode_set_ctime_current(dir));\n+ \treturn 0;\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t\tfrom = (char *)pde - (char *)page_address(page);\n- \tlock_page(page);\n- \terr = nilfs_prepare_chunk(page, from, to);\n- \tBUG_ON(err);\n=======\n+ \t\tfrom = (char *)pde - kaddr;\n+ \tfolio_lock(folio);\n+ \terr = nilfs_prepare_chunk(folio, from, to);\n+ \tif (unlikely(err)) {\n+ \t\tfolio_unlock(folio);\n+ \t\tgoto out;\n+ \t}\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n\n=======\n+ \t\terr = nilfs_set_link(new_dir, new_de, new_folio, old_inode);\n+ \t\tfolio_release_kmap(new_folio, new_de);\n+ \t\tif (unlikely(err))\n+ \t\t\tgoto out_dir;\n+ \t\tnilfs_mark_inode_dirty(new_dir);\n+ \t\tinode_set_ctime_current(new_inode);\n+ \t\tif (dir_de)\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tnilfs_delete_entry(old_de, old_page);\n- \n- \tif (dir_de) {\n- \t\tnilfs_set_link(old_inode, dir_de, dir_page, new_dir);\n- \t\tnilfs_put_page(dir_page);\n- \t\tdrop_nlink(old_dir);\n=======\n+ \terr = nilfs_delete_entry(old_de, old_folio);\n+ \tif (likely(!err)) {\n+ \t\tif (dir_de) {\n+ \t\t\terr = nilfs_set_link(old_inode, dir_de, dir_folio,\n+ \t\t\t\t\t     new_dir);\n+ \t\t\tdrop_nlink(old_dir);\n+ \t\t}\n+ \t\tnilfs_mark_inode_dirty(old_dir);\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tnilfs_put_page(old_page);\n- \n- \tnilfs_mark_inode_dirty(old_dir);\n=======\n\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- }\n=======\n+ int nilfs_delete_entry(struct nilfs_dir_entry *, struct folio *);\n+ int nilfs_empty_dir(struct inode *);\n+ struct nilfs_dir_entry *nilfs_dotdot(struct inode *, struct folio **);\n+ int nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n+ \t\t   struct folio *folio, struct inode *inode);\n>>>>>>> INCOMING PATCH\n```"
            }
          ]
        }
      ]
    },
    {
      "cve_url": "https://web.git.kernel.org/pub/scm/linux/security/vulns.git/plain/cve/published/2025/CVE-2025-21722.json",
      "patch_attempts": [
        {
          "upstream_commit": "840265f7b2795ec12a04ef948f52d12cd96f42c3",
          "upstream_commit_date": "2025-01-24 22:47:24 -0800",
          "upstream_patch": "ca76bb226bf47ff04c782cacbd299f12ddee1ec1",
          "total_versions_tested": 6,
          "successful_patches": 2,
          "failed_patches": 4,
          "patch_results": [
            {
              "downstream_patch": "19296737024cd220a1d6590bf4c092bca8c99497",
              "downstream_commit": "217114cf30ad890687c406319fdf189f8612cafc",
              "commit_date": "2025-02-21 13:50:10 +0100",
              "result": "failure",
              "error": "patching file fs/nilfs2/page.c\nHunk #1 FAILED at 392.\nHunk #2 FAILED at 399.\nHunk #3 succeeded at 404 with fuzz 2 (offset -6 lines).\nHunk #4 FAILED at 438.\n3 out of 4 hunks FAILED -- saving rejects to file fs/nilfs2/page.c.rej",
              "total_hunks": 4,
              "total_failed_hunks": 3,
              "failed_hunks": [1, 2, 4],
              "rej_file_content": "```diff\n--- fs/nilfs2/page.c.rej ---\n--- fs/nilfs2/page.c\n+++ fs/nilfs2/page.c\n@@ -392,6 +392,11 @@ void nilfs_clear_dirty_pages(struct address_space *mapping)\n /**\n  * nilfs_clear_folio_dirty - discard dirty folio\n  * @folio: dirty folio that will be discarded\n+ *\n+ * nilfs_clear_folio_dirty() clears working states including dirty state for\n+ * the folio and its buffers.  If the folio has buffers, clear only if it is\n+ * confirmed that none of the buffer heads are busy (none have valid\n+ * references and none are locked).\n  */\n void nilfs_clear_folio_dirty(struct folio *folio)\n {\n@@ -399,10 +404,6 @@ void nilfs_clear_folio_dirty(struct folio *folio)\n \n \tBUG_ON(!folio_test_locked(folio));\n \n-\tfolio_clear_uptodate(folio);\n-\tfolio_clear_mappedtodisk(folio);\n-\tfolio_clear_checked(folio);\n-\n \thead = folio_buffers(folio);\n \tif (head) {\n \t\tconst unsigned long clear_bits =\n@@ -438,6 +458,9 @@ void nilfs_clear_folio_dirty(struct folio *folio)\n \t\t} while (bh = bh->b_this_page, bh != head);\n \t}\n \n+\tfolio_clear_uptodate(folio);\n+\tfolio_clear_mappedtodisk(folio);\n+\tfolio_clear_checked(folio);\n \t__nilfs_clear_folio_dirty(folio);\n }\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n\n=======\n+ /**\n+  * nilfs_clear_folio_dirty - discard dirty folio\n+  * @folio: dirty folio that will be discarded\n+  *\n+  * nilfs_clear_folio_dirty() clears working states including dirty state for\n+  * the folio and its buffers.  If the folio has buffers, clear only if it is\n+  * confirmed that none of the buffer heads are busy (none have valid\n+  * references and none are locked).\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tfolio_batch_init(&fbatch);\n- \n=======\n+ \thead = folio_buffers(folio);\n+ \tif (head) {\n+ \t\tconst unsigned long clear_bits =\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- repeat:\n- \tnr_folios = filemap_get_folios_contig(inode->i_mapping, &index, ULONG_MAX,\n- \t\t\t&fbatch);\n=======\n+ \t\t\t BIT(BH_Async_Write) | BIT(BH_NILFS_Volatile) |\n+ \t\t\t BIT(BH_NILFS_Checked) | BIT(BH_NILFS_Redirected) |\n+ \t\t\t BIT(BH_Delay));\n+ \t\tbool busy, invalidated = false;\n+ \n+ recheck_buffers:\n+ \t\tbusy = false;\n+ \t\tbh = head;\n+ \t\tdo {\n+ \t\t\tif (atomic_read(&bh->b_count) | buffer_locked(bh)) {\n+ \t\t\t\tbusy = true;\n+ \t\t\t\tbreak;\n+ \t\t\t}\n+ \t\t} while (bh = bh->b_this_page, bh != head);\n+ \n+ \t\tif (busy) {\n+ \t\t\tif (invalidated)\n+ \t\t\t\treturn;\n+ \t\t\tinvalidate_bh_lrus();\n+ \t\t\tinvalidated = true;\n+ \t\t\tgoto recheck_buffers;\n+ \t\t}\n+ \n+ \t\tbh = head;\n+ \t\tdo {\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \ti = 0;\n- \tdo {\n- \t\tfolio = fbatch.folios[i];\n=======\n+ \tfolio_clear_uptodate(folio);\n+ \tfolio_clear_mappedtodisk(folio);\n+ \tfolio_clear_checked(folio);\n+ \t__nilfs_clear_folio_dirty(folio);\n+ }\n>>>>>>> INCOMING PATCH\n```"
            },
            {
              "downstream_patch": "7d0544bacc11d6aa26ecd7debf9353193c7a3328",
              "downstream_commit": "1ca6d471f8bd9c62ade774cc5bcbbe84fc739622",
              "commit_date": "2025-03-13 12:43:18 +0100",
              "result": "failure",
              "error": "patching file fs/nilfs2/page.c\nHunk #1 FAILED at 392.\nHunk #2 FAILED at 399.\nHunk #3 succeeded at 405 with fuzz 2 (offset -5 lines).\nHunk #4 FAILED at 438.\n3 out of 4 hunks FAILED -- saving rejects to file fs/nilfs2/page.c.rej",
              "total_hunks": 4,
              "total_failed_hunks": 3,
              "failed_hunks": [1, 2, 4],
              "rej_file_content": "```diff\n--- fs/nilfs2/page.c.rej ---\n--- fs/nilfs2/page.c\n+++ fs/nilfs2/page.c\n@@ -392,6 +392,11 @@ void nilfs_clear_dirty_pages(struct address_space *mapping)\n /**\n  * nilfs_clear_folio_dirty - discard dirty folio\n  * @folio: dirty folio that will be discarded\n+ *\n+ * nilfs_clear_folio_dirty() clears working states including dirty state for\n+ * the folio and its buffers.  If the folio has buffers, clear only if it is\n+ * confirmed that none of the buffer heads are busy (none have valid\n+ * references and none are locked).\n  */\n void nilfs_clear_folio_dirty(struct folio *folio)\n {\n@@ -399,10 +404,6 @@ void nilfs_clear_folio_dirty(struct folio *folio)\n \n \tBUG_ON(!folio_test_locked(folio));\n \n-\tfolio_clear_uptodate(folio);\n-\tfolio_clear_mappedtodisk(folio);\n-\tfolio_clear_checked(folio);\n-\n \thead = folio_buffers(folio);\n \tif (head) {\n \t\tconst unsigned long clear_bits =\n@@ -438,6 +458,9 @@ void nilfs_clear_folio_dirty(struct folio *folio)\n \t\t} while (bh = bh->b_this_page, bh != head);\n \t}\n \n+\tfolio_clear_uptodate(folio);\n+\tfolio_clear_mappedtodisk(folio);\n+\tfolio_clear_checked(folio);\n \t__nilfs_clear_folio_dirty(folio);\n }\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n\n=======\n+ /**\n+  * nilfs_clear_folio_dirty - discard dirty folio\n+  * @folio: dirty folio that will be discarded\n+  *\n+  * nilfs_clear_folio_dirty() clears working states including dirty state for\n+  * the folio and its buffers.  If the folio has buffers, clear only if it is\n+  * confirmed that none of the buffer heads are busy (none have valid\n+  * references and none are locked).\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tpagevec_init(&pvec);\n- \n=======\n+ \thead = folio_buffers(folio);\n+ \tif (head) {\n+ \t\tconst unsigned long clear_bits =\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- repeat:\n- \tpvec.nr = find_get_pages_contig(inode->i_mapping, index, PAGEVEC_SIZE,\n- \t\t\t\t\tpvec.pages);\n- \tif (pvec.nr == 0)\n=======\n+ \t\t\t BIT(BH_Async_Write) | BIT(BH_NILFS_Volatile) |\n+ \t\t\t BIT(BH_NILFS_Checked) | BIT(BH_NILFS_Redirected) |\n+ \t\t\t BIT(BH_Delay));\n+ \t\tbool busy, invalidated = false;\n+ \n+ recheck_buffers:\n+ \t\tbusy = false;\n+ \t\tbh = head;\n+ \t\tdo {\n+ \t\t\tif (atomic_read(&bh->b_count) | buffer_locked(bh)) {\n+ \t\t\t\tbusy = true;\n+ \t\t\t\tbreak;\n+ \t\t\t}\n+ \t\t} while (bh = bh->b_this_page, bh != head);\n+ \n+ \t\tif (busy) {\n+ \t\t\tif (invalidated)\n+ \t\t\t\treturn;\n+ \t\t\tinvalidate_bh_lrus();\n+ \t\t\tinvalidated = true;\n+ \t\t\tgoto recheck_buffers;\n+ \t\t}\n+ \n+ \t\tbh = head;\n+ \t\tdo {\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tif (length > 0 && pvec.pages[0]->index > index)\n- \t\tgoto out;\n=======\n+ \tfolio_clear_uptodate(folio);\n+ \tfolio_clear_mappedtodisk(folio);\n+ \tfolio_clear_checked(folio);\n+ \t__nilfs_clear_folio_dirty(folio);\n+ }\n>>>>>>> INCOMING PATCH\n```"
            },
            {
              "downstream_patch": "4d042811c72f71be7c14726db2c72b67025a7cb5",
              "downstream_commit": "95c96b95014482466ce3c09f6c81ca3c1dd2736f",
              "commit_date": "2025-03-13 12:47:23 +0100",
              "result": "failure",
              "error": "patching file fs/nilfs2/page.c\nHunk #1 FAILED at 392.\nHunk #2 FAILED at 399.\nHunk #3 succeeded at 404 with fuzz 2 (offset -6 lines).\nHunk #4 FAILED at 438.\n3 out of 4 hunks FAILED -- saving rejects to file fs/nilfs2/page.c.rej",
              "total_hunks": 4,
              "total_failed_hunks": 3,
              "failed_hunks": [1, 2, 4],
              "rej_file_content": "```diff\n--- fs/nilfs2/page.c.rej ---\n--- fs/nilfs2/page.c\n+++ fs/nilfs2/page.c\n@@ -392,6 +392,11 @@ void nilfs_clear_dirty_pages(struct address_space *mapping)\n /**\n  * nilfs_clear_folio_dirty - discard dirty folio\n  * @folio: dirty folio that will be discarded\n+ *\n+ * nilfs_clear_folio_dirty() clears working states including dirty state for\n+ * the folio and its buffers.  If the folio has buffers, clear only if it is\n+ * confirmed that none of the buffer heads are busy (none have valid\n+ * references and none are locked).\n  */\n void nilfs_clear_folio_dirty(struct folio *folio)\n {\n@@ -399,10 +404,6 @@ void nilfs_clear_folio_dirty(struct folio *folio)\n \n \tBUG_ON(!folio_test_locked(folio));\n \n-\tfolio_clear_uptodate(folio);\n-\tfolio_clear_mappedtodisk(folio);\n-\tfolio_clear_checked(folio);\n-\n \thead = folio_buffers(folio);\n \tif (head) {\n \t\tconst unsigned long clear_bits =\n@@ -438,6 +458,9 @@ void nilfs_clear_folio_dirty(struct folio *folio)\n \t\t} while (bh = bh->b_this_page, bh != head);\n \t}\n \n+\tfolio_clear_uptodate(folio);\n+\tfolio_clear_mappedtodisk(folio);\n+\tfolio_clear_checked(folio);\n \t__nilfs_clear_folio_dirty(folio);\n }\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n\n=======\n+ /**\n+  * nilfs_clear_folio_dirty - discard dirty folio\n+  * @folio: dirty folio that will be discarded\n+  *\n+  * nilfs_clear_folio_dirty() clears working states including dirty state for\n+  * the folio and its buffers.  If the folio has buffers, clear only if it is\n+  * confirmed that none of the buffer heads are busy (none have valid\n+  * references and none are locked).\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tif (page_has_buffers(page)) {\n- \t\tstruct buffer_head *bh, *head;\n=======\n+ \tBUG_ON(!folio_test_locked(folio));\n+ \n+ \thead = folio_buffers(folio);\n+ \tif (head) {\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n\n=======\n+ \n+ recheck_buffers:\n+ \t\tbusy = false;\n+ \t\tbh = head;\n+ \t\tdo {\n+ \t\t\tif (atomic_read(&bh->b_count) | buffer_locked(bh)) {\n+ \t\t\t\tbusy = true;\n+ \t\t\t\tbreak;\n+ \t\t\t}\n+ \t\t} while (bh = bh->b_this_page, bh != head);\n+ \n+ \t\tif (busy) {\n+ \t\t\tif (invalidated)\n+ \t\t\t\treturn;\n+ \t\t\tinvalidate_bh_lrus();\n+ \t\t\tinvalidated = true;\n+ \t\t\tgoto recheck_buffers;\n+ \t\t}\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t__nilfs_clear_page_dirty(page);\n=======\n+ \tfolio_clear_uptodate(folio);\n+ \tfolio_clear_mappedtodisk(folio);\n+ \tfolio_clear_checked(folio);\n+ \t__nilfs_clear_folio_dirty(folio);\n>>>>>>> INCOMING PATCH\n```"
            },
            {
              "downstream_patch": "f51ff43c4c5a6c8e72d0aca89e4d5e688938412f",
              "downstream_commit": "1bf43414ccff08200843f2b7f9c2a1479838acfb",
              "commit_date": "2025-03-13 12:50:45 +0100",
              "result": "failure",
              "error": "patching file fs/nilfs2/page.c\nHunk #1 FAILED at 392.\nHunk #2 FAILED at 399.\nHunk #3 succeeded at 404 with fuzz 2 (offset -6 lines).\nHunk #4 FAILED at 438.\n3 out of 4 hunks FAILED -- saving rejects to file fs/nilfs2/page.c.rej",
              "total_hunks": 4,
              "total_failed_hunks": 3,
              "failed_hunks": [1, 2, 4],
              "rej_file_content": "```diff\n--- fs/nilfs2/page.c.rej ---\n--- fs/nilfs2/page.c\n+++ fs/nilfs2/page.c\n@@ -392,6 +392,11 @@ void nilfs_clear_dirty_pages(struct address_space *mapping)\n /**\n  * nilfs_clear_folio_dirty - discard dirty folio\n  * @folio: dirty folio that will be discarded\n+ *\n+ * nilfs_clear_folio_dirty() clears working states including dirty state for\n+ * the folio and its buffers.  If the folio has buffers, clear only if it is\n+ * confirmed that none of the buffer heads are busy (none have valid\n+ * references and none are locked).\n  */\n void nilfs_clear_folio_dirty(struct folio *folio)\n {\n@@ -399,10 +404,6 @@ void nilfs_clear_folio_dirty(struct folio *folio)\n \n \tBUG_ON(!folio_test_locked(folio));\n \n-\tfolio_clear_uptodate(folio);\n-\tfolio_clear_mappedtodisk(folio);\n-\tfolio_clear_checked(folio);\n-\n \thead = folio_buffers(folio);\n \tif (head) {\n \t\tconst unsigned long clear_bits =\n@@ -438,6 +458,9 @@ void nilfs_clear_folio_dirty(struct folio *folio)\n \t\t} while (bh = bh->b_this_page, bh != head);\n \t}\n \n+\tfolio_clear_uptodate(folio);\n+\tfolio_clear_mappedtodisk(folio);\n+\tfolio_clear_checked(folio);\n \t__nilfs_clear_folio_dirty(folio);\n }\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n\n=======\n+ /**\n+  * nilfs_clear_folio_dirty - discard dirty folio\n+  * @folio: dirty folio that will be discarded\n+  *\n+  * nilfs_clear_folio_dirty() clears working states including dirty state for\n+  * the folio and its buffers.  If the folio has buffers, clear only if it is\n+  * confirmed that none of the buffer heads are busy (none have valid\n+  * references and none are locked).\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tif (page_has_buffers(page)) {\n- \t\tstruct buffer_head *bh, *head;\n=======\n+ \tBUG_ON(!folio_test_locked(folio));\n+ \n+ \thead = folio_buffers(folio);\n+ \tif (head) {\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n\n=======\n+ \n+ recheck_buffers:\n+ \t\tbusy = false;\n+ \t\tbh = head;\n+ \t\tdo {\n+ \t\t\tif (atomic_read(&bh->b_count) | buffer_locked(bh)) {\n+ \t\t\t\tbusy = true;\n+ \t\t\t\tbreak;\n+ \t\t\t}\n+ \t\t} while (bh = bh->b_this_page, bh != head);\n+ \n+ \t\tif (busy) {\n+ \t\t\tif (invalidated)\n+ \t\t\t\treturn;\n+ \t\t\tinvalidate_bh_lrus();\n+ \t\t\tinvalidated = true;\n+ \t\t\tgoto recheck_buffers;\n+ \t\t}\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \t__nilfs_clear_page_dirty(page);\n=======\n+ \tfolio_clear_uptodate(folio);\n+ \tfolio_clear_mappedtodisk(folio);\n+ \tfolio_clear_checked(folio);\n+ \t__nilfs_clear_folio_dirty(folio);\n>>>>>>> INCOMING PATCH\n```"
            }
          ]
        }
      ]
    },
    {
      "cve_url": "https://web.git.kernel.org/pub/scm/linux/security/vulns.git/plain/cve/published/2025/CVE-2025-21724.json",
      "patch_attempts": [
        {
          "upstream_commit": "d9df72c6acd683adf6dd23c061f3a414ec00b1f8",
          "upstream_commit_date": "2025-01-14 13:53:18 -0400",
          "upstream_patch": "e24c1551059268b37f6f40639883eafb281b8b9c",
          "total_versions_tested": 4,
          "successful_patches": 2,
          "failed_patches": 2,
          "patch_results": [
            {
              "downstream_patch": "38ac76fc06bc6826a3e4b12a98efbe98432380a9",
              "downstream_commit": "45e567800492088bc52c9abac35524b4d332a8f8",
              "commit_date": "2025-02-08 09:52:22 +0100",
              "result": "failure",
              "error": "can't find file to patch at input line 33\nPerhaps you used the wrong -p or --strip option?\nThe text leading up to this was:\n--------------------------\n|From e24c1551059268b37f6f40639883eafb281b8b9c Mon Sep 17 00:00:00 2001\n|From: Qasim Ijaz <qasdev00@gmail.com>\n|Date: Mon, 13 Jan 2025 22:38:20 +0000\n|Subject: [PATCH] iommufd/iova_bitmap: Fix shift-out-of-bounds in\n| iova_bitmap_offset_to_index()\n|\n|Resolve a UBSAN shift-out-of-bounds issue in iova_bitmap_offset_to_index()\n|where shifting the constant \"1\" (of type int) by bitmap->mapped.pgshift\n|(an unsigned long value) could result in undefined behavior.\n|\n|The constant \"1\" defaults to a 32-bit \"int\", and when \"pgshift\" exceeds\n|31 (e.g., pgshift = 63) the shift operation overflows, as the result\n|cannot be represented in a 32-bit type.\n|\n|To resolve this, the constant is updated to \"1UL\", promoting it to an\n|unsigned long type to match the operand's type.\n|\n|Fixes: 58ccf0190d19 (\"vfio: Add an IOVA bitmap support\")\n|Link: https://patch.msgid.link/r/20250113223820.10713-1-qasdev00@gmail.com\n|Reported-by: syzbot <syzbot+85992ace37d5b7b51635@syzkaller.appspotmail.com>\n|Closes: https://syzkaller.appspot.com/bug?extid=85992ace37d5b7b51635\n|Signed-off-by: Qasim Ijaz <qasdev00@gmail.com>\n|Reviewed-by: Joao Martins <joao.m.martins@oracle.com>\n|Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>\n|---\n| drivers/iommu/iommufd/iova_bitmap.c | 2 +-\n| 1 file changed, 1 insertion(+), 1 deletion(-)\n|\n|diff --git a/drivers/iommu/iommufd/iova_bitmap.c b/drivers/iommu/iommufd/iova_bitmap.c\n|index ab665cf38ef4..39a86a4a1d3a 100644\n|--- a/drivers/iommu/iommufd/iova_bitmap.c\n|+++ b/drivers/iommu/iommufd/iova_bitmap.c\n--------------------------\nFile to patch: \nSkip this patch? [y] \nSkipping patch.\n1 out of 1 hunk ignored",
              "total_hunks": 0,
              "total_failed_hunks": 0,
              "failed_hunks": [],
              "rej_file_content": "No rejected diff content found.",
              "inline_merge_conflict": "No conflict markers found."
            },
            {
              "downstream_patch": "44d9c94b7a3f29a3e07c4753603a35e9b28842a3",
              "downstream_commit": "720653309dd31c8a927ef5d87964578ad544980f",
              "commit_date": "2025-02-21 13:49:17 +0100",
              "result": "failure",
              "error": "can't find file to patch at input line 33\nPerhaps you used the wrong -p or --strip option?\nThe text leading up to this was:\n--------------------------\n|From e24c1551059268b37f6f40639883eafb281b8b9c Mon Sep 17 00:00:00 2001\n|From: Qasim Ijaz <qasdev00@gmail.com>\n|Date: Mon, 13 Jan 2025 22:38:20 +0000\n|Subject: [PATCH] iommufd/iova_bitmap: Fix shift-out-of-bounds in\n| iova_bitmap_offset_to_index()\n|\n|Resolve a UBSAN shift-out-of-bounds issue in iova_bitmap_offset_to_index()\n|where shifting the constant \"1\" (of type int) by bitmap->mapped.pgshift\n|(an unsigned long value) could result in undefined behavior.\n|\n|The constant \"1\" defaults to a 32-bit \"int\", and when \"pgshift\" exceeds\n|31 (e.g., pgshift = 63) the shift operation overflows, as the result\n|cannot be represented in a 32-bit type.\n|\n|To resolve this, the constant is updated to \"1UL\", promoting it to an\n|unsigned long type to match the operand's type.\n|\n|Fixes: 58ccf0190d19 (\"vfio: Add an IOVA bitmap support\")\n|Link: https://patch.msgid.link/r/20250113223820.10713-1-qasdev00@gmail.com\n|Reported-by: syzbot <syzbot+85992ace37d5b7b51635@syzkaller.appspotmail.com>\n|Closes: https://syzkaller.appspot.com/bug?extid=85992ace37d5b7b51635\n|Signed-off-by: Qasim Ijaz <qasdev00@gmail.com>\n|Reviewed-by: Joao Martins <joao.m.martins@oracle.com>\n|Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>\n|---\n| drivers/iommu/iommufd/iova_bitmap.c | 2 +-\n| 1 file changed, 1 insertion(+), 1 deletion(-)\n|\n|diff --git a/drivers/iommu/iommufd/iova_bitmap.c b/drivers/iommu/iommufd/iova_bitmap.c\n|index ab665cf38ef4..39a86a4a1d3a 100644\n|--- a/drivers/iommu/iommufd/iova_bitmap.c\n|+++ b/drivers/iommu/iommufd/iova_bitmap.c\n--------------------------\nFile to patch: \nSkip this patch? [y] \nSkipping patch.\n1 out of 1 hunk ignored",
              "total_hunks": 0,
              "total_failed_hunks": 0,
              "failed_hunks": [],
              "rej_file_content": "No rejected diff content found.",
              "inline_merge_conflict": "No conflict markers found."
            }
          ]
        }
      ]
    },
    {
      "cve_url": "https://web.git.kernel.org/pub/scm/linux/security/vulns.git/plain/cve/published/2025/CVE-2025-21748.json",
      "patch_attempts": [
        {
          "upstream_commit": "b2d99376c5d61eb60ffdb6c503e4b6c8f9712ddd",
          "upstream_commit_date": "2025-01-15 23:24:51 -0600",
          "upstream_patch": "aab98e2dbd648510f8f51b83fbf4721206ccae45",
          "total_versions_tested": 5,
          "successful_patches": 4,
          "failed_patches": 1,
          "patch_results": [
            {
              "downstream_patch": "f3b9fb2764591d792d160f375851013665a9e820",
              "downstream_commit": "a9042dbc1ed4bf25a5f5c699d10c3d676abf8ca2",
              "commit_date": "2025-03-13 12:50:48 +0100",
              "result": "failure",
              "error": "can't find file to patch at input line 23\nPerhaps you used the wrong -p or --strip option?\nThe text leading up to this was:\n--------------------------\n|From aab98e2dbd648510f8f51b83fbf4721206ccae45 Mon Sep 17 00:00:00 2001\n|From: Dan Carpenter <dan.carpenter@linaro.org>\n|Date: Wed, 15 Jan 2025 09:28:35 +0900\n|Subject: [PATCH] ksmbd: fix integer overflows on 32 bit systems\n|\n|On 32bit systems the addition operations in ipc_msg_alloc() can\n|potentially overflow leading to memory corruption.\n|Add bounds checking using KSMBD_IPC_MAX_PAYLOAD to avoid overflow.\n|\n|Fixes: 0626e6641f6b (\"cifsd: add server handler for central processing and tranport layers\")\n|Cc: stable@vger.kernel.org\n|Signed-off-by: Dan Carpenter <dan.carpenter@linaro.org>\n|Signed-off-by: Namjae Jeon <linkinjeon@kernel.org>\n|Signed-off-by: Steve French <stfrench@microsoft.com>\n|---\n| fs/smb/server/transport_ipc.c | 9 +++++++++\n| 1 file changed, 9 insertions(+)\n|\n|diff --git a/fs/smb/server/transport_ipc.c b/fs/smb/server/transport_ipc.c\n|index c0bb8c7722d7..0460ebea6ff0 100644\n|--- a/fs/smb/server/transport_ipc.c\n|+++ b/fs/smb/server/transport_ipc.c\n--------------------------\nFile to patch: \nSkip this patch? [y] \nSkipping patch.\n3 out of 3 hunks ignored",
              "total_hunks": 0,
              "total_failed_hunks": 0,
              "failed_hunks": [],
              "rej_file_content": "No rejected diff content found.",
              "inline_merge_conflict": "No conflict markers found."
            }
          ]
        }
      ]
    },
    {
      "cve_url": "https://web.git.kernel.org/pub/scm/linux/security/vulns.git/plain/cve/published/2025/CVE-2025-21755.json",
      "patch_attempts": [
        {
          "upstream_commit": "15d6f74f03f84c5b8d032bb1be6b90af82e5b679",
          "upstream_commit_date": "2025-02-12 20:01:28 -0800",
          "upstream_patch": "78dafe1cf3afa02ed71084b350713b07e72a18fb",
          "total_versions_tested": 6,
          "successful_patches": 5,
          "failed_patches": 1,
          "patch_results": [
            {
              "downstream_patch": "c6acb650a73d5705a93b9c5a2cd5e9c8161f0be3",
              "downstream_commit": "e7754d564579a5db9c5c9f74228df5d6dd6f1173",
              "commit_date": "2025-03-13 12:47:44 +0100",
              "result": "failure",
              "error": "patching file net/vmw_vsock/af_vsock.c\nHunk #1 FAILED at 824.\n1 out of 1 hunk FAILED -- saving rejects to file net/vmw_vsock/af_vsock.c.rej",
              "total_hunks": 0,
              "total_failed_hunks": 1,
              "failed_hunks": [1],
              "rej_file_content": "```diff\n--- net/vmw_vsock/af_vsock.c.rej ---\n--- net/vmw_vsock/af_vsock.c\n+++ net/vmw_vsock/af_vsock.c\n@@ -824,13 +824,19 @@ static void __vsock_release(struct sock *sk, int level)\n \t */\n \tlock_sock_nested(sk, level);\n \n-\tsock_orphan(sk);\n+\t/* Indicate to vsock_remove_sock() that the socket is being released and\n+\t * can be removed from the bound_table. Unlike transport reassignment\n+\t * case, where the socket must remain bound despite vsock_remove_sock()\n+\t * being called from the transport release() callback.\n+\t */\n+\tsock_set_flag(sk, SOCK_DEAD);\n \n \tif (vsk->transport)\n \t\tvsk->transport->release(vsk);\n \telse if (sock_type_connectible(sk->sk_type))\n \t\tvsock_remove_sock(vsk);\n \n+\tsock_orphan(sk);\n \tsk->sk_shutdown = SHUTDOWN_MASK;\n \n \tskb_queue_purge(&sk->sk_receive_queue);\n```",
              "inline_merge_conflict": "No conflict markers found."
            }
          ]
        }
      ]
    },
    {
      "cve_url": "https://web.git.kernel.org/pub/scm/linux/security/vulns.git/plain/cve/published/2025/CVE-2025-21756.json",
      "patch_attempts": [
        {
          "upstream_commit": "9e6c4e6b605c1fa3e24f74ee0b641e95f090188a",
          "upstream_commit_date": "2025-01-29 18:50:36 -0800",
          "upstream_patch": "fcdd2242c0231032fc84e1404315c245ae56322a",
          "total_versions_tested": 6,
          "successful_patches": 5,
          "failed_patches": 1,
          "patch_results": [
            {
              "downstream_patch": "e7754d564579a5db9c5c9f74228df5d6dd6f1173",
              "downstream_commit": "e11d808fb4bf1852bc8ed92cb448cfdc11650d4d",
              "commit_date": "2025-03-13 12:47:44 +0100",
              "result": "failure",
              "error": "patching file net/vmw_vsock/af_vsock.c\nHunk #1 succeeded at 330 (offset -7 lines).\nHunk #2 FAILED at 824.\n1 out of 2 hunks FAILED -- saving rejects to file net/vmw_vsock/af_vsock.c.rej",
              "total_hunks": 2,
              "total_failed_hunks": 1,
              "failed_hunks": [2],
              "rej_file_content": "```diff\n--- net/vmw_vsock/af_vsock.c.rej ---\n--- net/vmw_vsock/af_vsock.c\n+++ net/vmw_vsock/af_vsock.c\n@@ -824,12 +827,13 @@ static void __vsock_release(struct sock *sk, int level)\n \t */\n \tlock_sock_nested(sk, level);\n \n+\tsock_orphan(sk);\n+\n \tif (vsk->transport)\n \t\tvsk->transport->release(vsk);\n \telse if (sock_type_connectible(sk->sk_type))\n \t\tvsock_remove_sock(vsk);\n \n-\tsock_orphan(sk);\n \tsk->sk_shutdown = SHUTDOWN_MASK;\n \n \tskb_queue_purge(&sk->sk_receive_queue);\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n\n=======\n+ void vsock_remove_sock(struct vsock_sock *vsk)\n+ {\n+ \t/* Transport reassignment must not remove the binding. */\n+ \tif (sock_flag(sk_vsock(vsk), SOCK_DEAD))\n+ \t\tvsock_remove_bound(vsk);\n+ \n>>>>>>> INCOMING PATCH\n```"
            }
          ]
        }
      ]
    },
    {
      "cve_url": "https://web.git.kernel.org/pub/scm/linux/security/vulns.git/plain/cve/published/2025/CVE-2025-21757.json",
      "patch_attempts": [
        {
          "upstream_commit": "46ded709232344b5750a852747a8881763c721ab",
          "upstream_commit_date": "2025-02-01 16:55:30 -0800",
          "upstream_patch": "c71a192976ded2f2f416d03c4f595cdd4478b825",
          "total_versions_tested": 4,
          "successful_patches": 2,
          "failed_patches": 2,
          "patch_results": [
            {
              "downstream_patch": "cb9950eaaf9cc76dfe490c06aa11f185b3c7f22b",
              "downstream_commit": "90d2c9352a04027bfd8e3b4b09eb14aaec033a3b",
              "commit_date": "2025-03-13 12:47:45 +0100",
              "result": "failure",
              "error": "can't find file to patch at input line 28\nPerhaps you used the wrong -p or --strip option?\nThe text leading up to this was:\n--------------------------\n|From c71a192976ded2f2f416d03c4f595cdd4478b825 Mon Sep 17 00:00:00 2001\n|From: Jakub Kicinski <kuba@kernel.org>\n|Date: Wed, 29 Jan 2025 19:15:18 -0800\n|Subject: [PATCH] net: ipv6: fix dst refleaks in rpl, seg6 and ioam6 lwtunnels\n|\n|dst_cache_get() gives us a reference, we need to release it.\n|\n|Discovered by the ioam6.sh test, kmemleak was recently fixed\n|to catch per-cpu memory leaks.\n|\n|Fixes: 985ec6f5e623 (\"net: ipv6: rpl_iptunnel: mitigate 2-realloc issue\")\n|Fixes: 40475b63761a (\"net: ipv6: seg6_iptunnel: mitigate 2-realloc issue\")\n|Fixes: dce525185bc9 (\"net: ipv6: ioam6_iptunnel: mitigate 2-realloc issue\")\n|Reviewed-by: Justin Iurman <justin.iurman@uliege.be>\n|Reviewed-by: Simon Horman <horms@kernel.org>\n|Link: https://patch.msgid.link/20250130031519.2716843-1-kuba@kernel.org\n|Signed-off-by: Jakub Kicinski <kuba@kernel.org>\n|---\n| net/ipv6/ioam6_iptunnel.c | 5 +++--\n| net/ipv6/rpl_iptunnel.c   | 6 ++++--\n| net/ipv6/seg6_iptunnel.c  | 6 ++++--\n| 3 files changed, 11 insertions(+), 6 deletions(-)\n|\n|diff --git a/net/ipv6/ioam6_iptunnel.c b/net/ipv6/ioam6_iptunnel.c\n|index 28e5a89dc255..3936c137a572 100644\n|--- a/net/ipv6/ioam6_iptunnel.c\n|+++ b/net/ipv6/ioam6_iptunnel.c\n--------------------------\nFile to patch: \nSkip this patch? [y] \nSkipping patch.\n3 out of 3 hunks ignored\npatching file net/ipv6/rpl_iptunnel.c\nHunk #3 succeeded at 277 with fuzz 2 (offset 8 lines).\npatching file net/ipv6/seg6_iptunnel.c\nHunk #1 FAILED at 482.\nHunk #2 succeeded at 380 (offset -191 lines).\nHunk #3 succeeded at 397 (offset -195 lines).\n1 out of 3 hunks FAILED -- saving rejects to file net/ipv6/seg6_iptunnel.c.rej",
              "total_hunks": 3,
              "total_failed_hunks": 1,
              "failed_hunks": [1],
              "rej_file_content": "```diff\n--- net/ipv6/seg6_iptunnel.c.rej ---\n--- net/ipv6/seg6_iptunnel.c\n+++ net/ipv6/seg6_iptunnel.c\n@@ -482,8 +482,10 @@ static int seg6_input_core(struct net *net, struct sock *sk,\n \tlocal_bh_enable();\n \n \terr = seg6_do_srh(skb, dst);\n-\tif (unlikely(err))\n+\tif (unlikely(err)) {\n+\t\tdst_release(dst);\n \t\tgoto drop;\n+\t}\n \n \tif (!dst) {\n \t\tip6_route_input(skb);\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \n- \tskb_dst_drop(skb);\n=======\n\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \terr = skb_cow_head(skb, LL_RESERVED_SPACE(dst->dev));\n- \tif (unlikely(err))\n=======\n+ \terr = seg6_do_srh(skb, dst);\n+ \tif (unlikely(err)) {\n+ \t\tdst_release(dst);\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- }\n=======\n+ \t\tdst = ip6_route_output(net, NULL, &fl6);\n+ \t\tif (dst->error) {\n+ \t\t\terr = dst->error;\n+ \t\t\tgoto drop;\n+ \t\t}\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n\n=======\n+ \n+ \treturn dst_output(net, sk, skb);\n+ drop:\n+ \tdst_release(dst);\n+ \tkfree_skb(skb);\n+ \treturn err;\n>>>>>>> INCOMING PATCH\n```"
            },
            {
              "downstream_patch": "bf500b0d0cfe92ee62dfd4c2ace7f6353cf3a4c8",
              "downstream_commit": "02e43735932d4b5eab0309acc92d8a2d19ca2ce5",
              "commit_date": "2025-03-13 12:51:13 +0100",
              "result": "failure",
              "error": "patching file net/ipv6/ioam6_iptunnel.c\nHunk #1 FAILED at 336.\nHunk #2 FAILED at 407.\nHunk #3 FAILED at 426.\n3 out of 3 hunks FAILED -- saving rejects to file net/ipv6/ioam6_iptunnel.c.rej\npatching file net/ipv6/rpl_iptunnel.c\nHunk #3 succeeded at 277 with fuzz 2 (offset 8 lines).\npatching file net/ipv6/seg6_iptunnel.c\nHunk #1 succeeded at 490 with fuzz 2 (offset 8 lines).\nHunk #2 succeeded at 584 (offset 11 lines).\nHunk #3 succeeded at 605 (offset 11 lines).",
              "total_hunks": 3,
              "total_failed_hunks": 3,
              "failed_hunks": [1, 2, 3],
              "rej_file_content": "```diff\n--- net/ipv6/ioam6_iptunnel.c.rej ---\n--- net/ipv6/ioam6_iptunnel.c\n+++ net/ipv6/ioam6_iptunnel.c\n@@ -336,7 +336,7 @@ static int ioam6_do_encap(struct net *net, struct sk_buff *skb,\n \n static int ioam6_output(struct net *net, struct sock *sk, struct sk_buff *skb)\n {\n-\tstruct dst_entry *dst = skb_dst(skb), *cache_dst;\n+\tstruct dst_entry *dst = skb_dst(skb), *cache_dst = NULL;\n \tstruct in6_addr orig_daddr;\n \tstruct ioam6_lwt *ilwt;\n \tint err = -EINVAL;\n@@ -407,7 +407,6 @@ static int ioam6_output(struct net *net, struct sock *sk, struct sk_buff *skb)\n \t\tcache_dst = ip6_route_output(net, NULL, &fl6);\n \t\tif (cache_dst->error) {\n \t\t\terr = cache_dst->error;\n-\t\t\tdst_release(cache_dst);\n \t\t\tgoto drop;\n \t\t}\n \n@@ -426,8 +425,10 @@ static int ioam6_output(struct net *net, struct sock *sk, struct sk_buff *skb)\n \t\treturn dst_output(net, sk, skb);\n \t}\n out:\n+\tdst_release(cache_dst);\n \treturn dst->lwtstate->orig_output(net, sk, skb);\n drop:\n+\tdst_release(cache_dst);\n \tkfree_skb(skb);\n \treturn err;\n }\n```",
              "inline_merge_conflict": "```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \tstruct lwtunnel_state *lwt = skb_dst(skb)->lwtstate;\n=======\n+ \tstruct dst_entry *dst = skb_dst(skb), *cache_dst = NULL;\n+ \tstruct in6_addr orig_daddr;\n+ \tstruct ioam6_lwt *ilwt;\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- }\n=======\n+ \t\tcache_dst = ip6_route_output(net, NULL, &fl6);\n+ \t\tif (cache_dst->error) {\n+ \t\t\terr = cache_dst->error;\n+ \t\t\tgoto drop;\n+ \t\t}\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n\n=======\n+ \t\treturn dst_output(net, sk, skb);\n+ \t}\n+ out:\n+ \tdst_release(cache_dst);\n+ \treturn dst->lwtstate->orig_output(net, sk, skb);\n+ drop:\n+ \tdst_release(cache_dst);\n+ \tkfree_skb(skb);\n+ \treturn err;\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \n- \tskb_dst_drop(skb);\n=======\n\n>>>>>>> INCOMING PATCH\n```\n\n```diff\n// Conflict in: unknown\n<<<<<<< CURRENT VERSION\n- \n- \tskb_dst_drop(skb);\n=======\n\n>>>>>>> INCOMING PATCH\n```"
            }
          ]
        }
      ]
    }
  ]
}
