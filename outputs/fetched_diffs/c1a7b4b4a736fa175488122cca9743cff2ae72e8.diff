diff --git a/drivers/gpu/msm/kgsl.c b/drivers/gpu/msm/kgsl.c
index 6a7632a83eb42248e39a9b8beb6ce62949f47807..2c88eab6656d0472f3f0d3346e0609173a713072 100644
--- a/drivers/gpu/msm/kgsl.c
+++ b/drivers/gpu/msm/kgsl.c
@@ -268,6 +268,7 @@ static struct kgsl_mem_entry *kgsl_mem_entry_create(void)
 		/* put this ref in userspace memory alloc and map ioctls */
 		kref_get(&entry->refcount);
 		atomic_set(&entry->map_count, 0);
+		atomic_set(&entry->vbo_count, 0);
 	}
 
 	return entry;
diff --git a/drivers/gpu/msm/kgsl.h b/drivers/gpu/msm/kgsl.h
index a47e91bc6845ba349de5f456126b1b73f8baf37c..288fa83ff262fb7f43a92dc829dc18e65ab891df 100644
--- a/drivers/gpu/msm/kgsl.h
+++ b/drivers/gpu/msm/kgsl.h
@@ -1,7 +1,7 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (c) 2008-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022-2023, Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2022-2024, Qualcomm Innovation Center, Inc. All rights reserved.
  */
 #ifndef __KGSL_H
 #define __KGSL_H
@@ -350,6 +350,8 @@ struct kgsl_mem_entry {
 	 * debugfs accounting
 	 */
 	atomic_t map_count;
+	/** @vbo_count: Count how many VBO ranges this entry is mapped in */
+	atomic_t vbo_count;
 };
 
 struct kgsl_device_private;
diff --git a/drivers/gpu/msm/kgsl_reclaim.c b/drivers/gpu/msm/kgsl_reclaim.c
index 4b38b5501eeda74bcc268813eae737aa78466300..3c24c3eed534aa1a41177400d151461386bde294 100644
--- a/drivers/gpu/msm/kgsl_reclaim.c
+++ b/drivers/gpu/msm/kgsl_reclaim.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2022, 2024 Qualcomm Innovation Center, Inc. All rights reserved.
  */
 
 #include <linux/kthread.h>
@@ -266,6 +266,13 @@ static u32 kgsl_reclaim_process(struct kgsl_process_private *process,
 			continue;
 		}
 
+		/* Do not reclaim pages mapped into a VBO */
+		if (atomic_read(&valid_entry->vbo_count)) {
+			kgsl_mem_entry_put(entry);
+			next++;
+			continue;
+		}
+
 		if ((atomic_read(&process->unpinned_page_count) +
 			memdesc->page_count) > kgsl_reclaim_max_page_limit) {
 			kgsl_mem_entry_put(entry);
diff --git a/drivers/gpu/msm/kgsl_vbo.c b/drivers/gpu/msm/kgsl_vbo.c
index 2ab97c3f5ba0ab104b6d336c43345c4fdcfe803b..551822ba98daf1b11a835b35c47642924dadd280 100644
--- a/drivers/gpu/msm/kgsl_vbo.c
+++ b/drivers/gpu/msm/kgsl_vbo.c
@@ -43,12 +43,16 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
 		return ERR_PTR(-EINVAL);
 	}
 
+	atomic_inc(&entry->vbo_count);
 	return range;
 }
 
 static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
 {
-	kgsl_mem_entry_put(range->entry);
+	struct kgsl_mem_entry *entry = range->entry;
+
+	atomic_dec(&entry->vbo_count);
+	kgsl_mem_entry_put(entry);
 	kfree(range);
 }
 
@@ -309,8 +313,12 @@ static void kgsl_sharedmem_free_bind_op(struct kgsl_sharedmem_bind_op *op)
 	if (IS_ERR_OR_NULL(op))
 		return;
 
-	for (i = 0; i < op->nr_ops; i++)
+	for (i = 0; i < op->nr_ops; i++) {
+		/* Decrement the vbo_count we added when creating the bind_op */
+		if (op->ops[i].entry)
+			atomic_dec(&op->ops[i].entry->vbo_count);
 		kgsl_mem_entry_put(op->ops[i].entry);
+	}
 
 	kgsl_mem_entry_put(op->target);
 
@@ -416,6 +424,9 @@ kgsl_sharedmem_create_bind_op(struct kgsl_process_private *private,
 			goto err;
 		}
 
+		/* Keep the child pinned in memory */
+		atomic_inc(&entry->vbo_count);
+
 		/* Make sure the child is not a VBO */
 		if ((entry->memdesc.flags & KGSL_MEMFLAGS_VBO)) {
 			ret = -EINVAL;
