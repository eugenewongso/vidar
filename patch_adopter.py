r"""Applies downloaded patches to a target source code directory.

This module is the third and fifth step in the patch management pipeline. It is
responsible for taking a downloaded .diff file and attempting to apply it to a
local source code repository using the GNU `patch` utility.

It is run twice:
1.  `--source Vanir`: To apply the original, unaltered patches that were
    downloaded by the patch fetcher. It generates a report detailing which
    patches succeeded and which failed.
2.  `--source LLM`: To apply the patches that have been corrected by the
    LLM.

The script generates a detailed JSON report of the application results,
including the status for each patch (e.g., applied cleanly, applied with
offsets, or rejected) and captures any `.rej` files for failed hunks.

Usage:
  # To apply original patches from the fetcher
  python patch_adopter.py --source Vanir

  # To apply patches generated by the LLM
  python patch_adopter.py --source LLM
"""

import argparse
import json
import os
import re
import subprocess
import sys
import time


class PatchAdopter:
    """
    Manages the application of patch files to a source code repository.
    """

    def __init__(self, target_source_path: str, patch_dir: str,
                 report_output_path: str):
        """Initializes the PatchAdopter.

        Args:
            target_source_path: The path to the target source code directory.
            patch_dir: The directory containing the .diff patch files.
            report_output_path: The path to save the JSON report.
        """
        self.target_source_path = target_source_path
        self.patch_dir = patch_dir
        self.report_output_path = report_output_path
        self.strip_level = 1
        # Use 'gpatch' on macOS if available, otherwise 'patch'.
        self.patch_command = "gpatch" if sys.platform == "darwin" else "patch"
        self.patch_results = {"patches": []}

    def apply_patch(self, patch_file: str, patch_url: str,
                    source: str = "Vanir") -> dict:
        """
        Attempts to apply a single patch file to the target source directory.

        Args:
            patch_file: The path to the .diff file to apply.
            patch_url: The original URL of the patch for reporting purposes.
            source: The source of the patch ('Vanir' or 'LLM').

        Returns:
            A dictionary containing the detailed results of the patch attempt.
        """
        if not os.path.exists(patch_file):
            print(f"  -> ‚ùå Patch file not found: {patch_file}")
            return {
                "patch_file": os.path.basename(patch_file),
                "patch_url": patch_url,
                "source": source,
                "status": "Rejected: Missing Patch File",
                "message_output": "Patch file not found."
            }

        try:
            # Use --dry-run first to check for issues without changing files.
            result = subprocess.run(
                [self.patch_command, "-p", str(self.strip_level), "-i",
                 patch_file, "--dry-run"],
                text=True,
                capture_output=True,
                check=False  # Do not throw exception on non-zero exit code
            )
            console_output = result.stdout + result.stderr

            detailed_status = self._determine_detailed_status(console_output)
            rejected_files = self._extract_failed_files(console_output)
            
            # If the dry run was successful or had only offsets, apply for real.
            if "FAILED" not in detailed_status:
                subprocess.run(
                    [self.patch_command, "-p", str(self.strip_level), "-i", patch_file, "-f"],
                    text=True,
                    capture_output=True,
                    check=False
                )
                print(f"  -> ‚úÖ {detailed_status}")
            else:
                 print(f"  -> ‚ùå {detailed_status}")
                 
            # Find any .rej files that were created.
            reject_file_paths = self._get_rej_files()
            formatted_rejected_files = self._map_rejected_files(
                rejected_files, reject_file_paths)

            overall_status = "Applied Successfully" if not formatted_rejected_files else "Rejected"

            return {
                "patch_file": os.path.basename(patch_file),
                "patch_url": patch_url,
                "source": source,
                "status": overall_status,
                "detailed_status": detailed_status,
                "rejected_files": formatted_rejected_files,
                "message_output": console_output
            }

        except Exception as e:
            print(f"  -> ‚ùå An unexpected error occurred: {e}")
            return {
                "patch_file": os.path.basename(patch_file),
                "patch_url": patch_url,
                "source": source,
                "status": "Rejected",
                "detailed_status": "Rejected: Error Running Patch Command",
                "message_output": str(e)
            }

    def _determine_detailed_status(self, console_output: str) -> str:
        """Analyzes patch command output to determine a detailed status."""
        if "Reversed (or previously applied) patch detected" in console_output:
            return "Applied Successfully: Already Applied"
        if "can't find file to patch" in console_output:
            return "Skipped: Files Not Found"
        if "FAILED" in console_output and "hunk" in console_output:
            return "Rejected: Failed Hunks"
        if "offset" in console_output and "FAILED" not in console_output:
            return "Applied Successfully: With Offsets"
        return "Applied Successfully: Clean"

    def _extract_failed_files(self, console_output: str) -> list[str]:
        """Parses patch command output to find the names of failed files."""
        pattern = re.compile(r"patching file (\S+)\nHunk #\d+ FAILED")
        return [match.strip() for match in pattern.findall(console_output)]

    def _get_rej_files(self) -> list[str]:
        """Finds all `.rej` files within the target source directory."""
        time.sleep(1)  # Give the filesystem a moment to create .rej files.
        reject_files = []
        for root, _, files in os.walk(self.target_source_path):
            for file in files:
                if file.endswith(".rej"):
                    reject_files.append(os.path.join(root, file))
        return reject_files

    def _map_rejected_files(self, failed_files: list[str],
                              reject_files: list[str]) -> list[dict]:
        """Maps failed file paths to their corresponding `.rej` file paths."""
        rejected_mappings = []
        for failed_file in failed_files:
            # Construct the expected path for the .rej file.
            expected_rej_path = os.path.join(self.target_source_path,
                                             failed_file + ".rej")
            if expected_rej_path in reject_files:
                rejected_mappings.append({
                    "failed_file": failed_file,
                    "reject_file": expected_rej_path
                })
            else:
                rejected_mappings.append({
                    "failed_file": failed_file,
                    "reject_file": None
                })
        return rejected_mappings

    def save_report(self):
        """Saves the cumulative patch results to a JSON file."""
        with open(self.report_output_path, "w", encoding="utf-8") as report:
            json.dump(self.patch_results, report, indent=4)
        print(f"\nüìÑ Patch report saved to: {self.report_output_path}")

    def generate_summary(self):
        """Prints a summary of the patch application results to the console."""
        status_counts = {}
        for patch in self.patch_results["patches"]:
            detailed_status = patch.get("detailed_status", "Unknown")
            status_counts[detailed_status] = status_counts.get(
                detailed_status, 0) + 1
        
        summary = {
            "total_patches": len(self.patch_results["patches"]),
            "status_counts": status_counts
        }

        print("\n" + "="*40)
        print("Patch Application Summary")
        print("="*40)
        print(f"Total patches processed: {summary['total_patches']}")
        print("Status breakdown:")
        for status, count in status_counts.items():
            print(f"  - {status}: {count}")
        print("="*40)
        return summary


def main():
    """Main entry point for the patch adopter script."""
    parser = argparse.ArgumentParser(
        description="Apply downloaded patches to a target source directory.")
    parser.add_argument(
        "--source",
        choices=["Vanir", "LLM"],
        default="Vanir",
        help="Specify the source of the patches to apply.")
    args = parser.parse_args()

    # Define project paths relative to the script location.
    vidar_dir = os.path.dirname(os.path.abspath(__file__))
    project_root = os.path.dirname(vidar_dir)
    target_source_path = os.environ.get("TARGET_SOURCE_PATH")
    
    if not target_source_path:
        print("‚ùå Error: TARGET_SOURCE_PATH environment variable is not set.")
        sys.exit(1)

    # Determine directories based on the patch source.
    if args.source == "Vanir":
        patch_dir = os.path.join(project_root, "fetch_patch_output", "diff_output")
        parsed_report_path = os.path.join(vidar_dir, "reports", "parsed_report.json")
    else:  # LLM
        patch_dir = os.path.join(project_root, "patch_adoption", "generated_patches")
        parsed_report_path = os.path.join(vidar_dir, "reports", "1_llm_output.json")
    
    report_output_path = os.path.join(vidar_dir, "reports", "patch_application_report.json")

    # Validate paths.
    if not os.path.isdir(target_source_path):
        print(f"‚ùå Error: Target source directory not found at '{target_source_path}'")
        sys.exit(1)

    # Change to the target directory to ensure `patch` works correctly.
    os.chdir(target_source_path)

    try:
        with open(parsed_report_path, "r", encoding="utf-8") as f:
            report_data = json.load(f)
    except FileNotFoundError:
        print(f"‚ùå Error: Input report not found at '{parsed_report_path}'")
        sys.exit(1)

    patcher = PatchAdopter(target_source_path, patch_dir, report_output_path)
    patches_to_process = report_data.get("patches", [])
    
    print(f"Attempting to apply {len(patches_to_process)} patches from source: {args.source}")

    for patch in patches_to_process:
        patch_filename = (patch["patch_file"] if args.source == "Vanir"
                          else os.path.basename(patch.get("output_path", "")))
        if not patch_filename:
            print(f"‚ö†Ô∏è Skipping a patch entry due to missing file information.")
            continue
            
        patch_file_path = os.path.join(patch_dir, patch_filename)
        print(f"\nüîç Processing patch: {patch_filename}")
        patch_result = patcher.apply_patch(
            patch_file_path, patch["patch_url"], source=args.source)
        patcher.patch_results["patches"].append(patch_result)

    patcher.save_report()
    patcher.generate_summary()


if __name__ == "__main__":
    main()
