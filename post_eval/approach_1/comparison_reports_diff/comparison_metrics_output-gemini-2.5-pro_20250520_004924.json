[
    {
        "cve_id": "ASB-A-296915500",
        "downstream_version": "14",
        "file_name": "android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java",
        "ref_diff_file": "@@ -32,6 +32,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import android.bluetooth.BluetoothProfile;\n import android.bluetooth.BluetoothProtoEnums;\n import android.content.ContentResolver;\n@@ -54,12 +57,13 @@ import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n /**\n  * This class stores information about a single sending file It will only be used for outbound\n  * share.\n  */\n-// Next tag value for ContentProfileErrorReportUtils.report(): 15\n+// Next tag value for ContentProfileErrorReportUtils.report(): 16\n public class BluetoothOppSendFileInfo {\n     private static final String TAG = \"BluetoothOppSendFileInfo\";\n```",
        "LLM_diff_file": "@@ -33,6 +33,10 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n+import android.bluetooth.BluetoothProfile;\n+import android.bluetooth.BluetoothProtoEnums;\n import android.content.ContentResolver;\n import android.content.Context;\n import android.content.res.AssetFileDescriptor;\n@@ -51,11 +55,13 @@\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n /**\n  * This class stores information about a single sending file It will only be\n  * used for outbound share.\n  */\n+// Next tag value for ContentProfileErrorReportUtils.report(): 16\n public class BluetoothOppSendFileInfo {\n     private static final String TAG = \"BluetoothOppSendFileInfo\";\n ",
        "metrics": {
            "relative_line_count_similarity": 1.0,
            "normalized_edit_similarity": 0.74,
            "token_level_edit_distance": 44,
            "codebert_score": {
                "precision": 0.9494,
                "recall": 0.953,
                "f1": 0.9512,
                "f3": 0.9526
            },
            "token_count_ref_diff": 77,
            "token_count_llm_diff": 71,
            "token_count_total": 148,
            "cosine_similarity_openai": 0.9634
        },
        "metrics_status": "computed"
    },
    {
        "cve_id": "ASB-A-364027949",
        "downstream_version": "14",
        "file_name": "system/stack/gatt/gatt_sr.cc",
        "ref_diff_file": "@@ -772,6 +772,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_cod\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n```",
        "LLM_diff_file": "@@ -735,6 +735,11 @@\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -770,6 +775,12 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n ",
        "metrics": {
            "relative_line_count_similarity": 0.9545,
            "normalized_edit_similarity": 0.6684,
            "token_level_edit_distance": 65,
            "codebert_score": {
                "precision": 0.932,
                "recall": 0.878,
                "f1": 0.9042,
                "f3": 0.8832
            },
            "token_count_ref_diff": 114,
            "token_count_llm_diff": 84,
            "token_count_total": 198,
            "cosine_similarity_openai": 0.7897
        },
        "metrics_status": "computed"
    },
    {
        "cve_id": "ASB-A-364025411",
        "downstream_version": "14",
        "file_name": "system/stack/gatt/gatt_sr.cc",
        "ref_diff_file": "@@ -772,6 +772,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_cod\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n```",
        "LLM_diff_file": "@@ -735,6 +735,11 @@\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -770,6 +775,12 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n ",
        "metrics": {
            "relative_line_count_similarity": 0.9545,
            "normalized_edit_similarity": 0.6684,
            "token_level_edit_distance": 65,
            "codebert_score": {
                "precision": 0.932,
                "recall": 0.878,
                "f1": 0.9042,
                "f3": 0.8832
            },
            "token_count_ref_diff": 114,
            "token_count_llm_diff": 84,
            "token_count_total": 198,
            "cosine_similarity_openai": 0.7903
        },
        "metrics_status": "computed"
    },
    {
        "cve_id": "ASB-A-340480881",
        "downstream_version": "14",
        "file_name": "PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java",
        "ref_diff_file": "@@ -267,11 +267,11 @@ public final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.i(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }\n```",
        "LLM_diff_file": "@@ -258,11 +258,11 @@\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }\n ",
        "metrics": {
            "relative_line_count_similarity": 0.9286,
            "normalized_edit_similarity": 0.9323,
            "token_level_edit_distance": 9,
            "codebert_score": {
                "precision": 0.9713,
                "recall": 0.9439,
                "f1": 0.9574,
                "f3": 0.9466
            },
            "token_count_ref_diff": 61,
            "token_count_llm_diff": 54,
            "token_count_total": 115,
            "cosine_similarity_openai": 0.94
        },
        "metrics_status": "computed"
    },
    {
        "cve_id": "ASB-A-369103643",
        "downstream_version": "14",
        "file_name": "services/core/java/com/android/server/wm/WindowOrganizerController.java",
        "ref_diff_file": "@@ -1517,8 +1517,10 @@ class WindowOrganizerController extends IWindowOrganizerController.Stub\n                 final IBinder callerActivityToken = operation.getActivityToken();\n                 final Intent activityIntent = operation.getActivityIntent();\n                 final Bundle activityOptions = operation.getBundle();\n+                final SafeActivityOptions safeOptions =\n+                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n                 final int result = waitAsyncStart(() -> mService.getActivityStartController()\n-                        .startActivityInTaskFragment(taskFragment, activityIntent, activityOptions,\n+                        .startActivityInTaskFragment(taskFragment, activityIntent, safeOptions,\n                                 callerActivityToken, caller.mUid, caller.mPid,\n                                 errorCallbackToken));\n                 if (!isStartResultSuccessful(result)) {\n```",
        "LLM_diff_file": "@@ -1190,10 +1190,12 @@\n                 final IBinder callerActivityToken = operation.getActivityToken();\n                 final Intent activityIntent = operation.getActivityIntent();\n                 final Bundle activityOptions = operation.getBundle();\n-                final int result = mService.getActivityStartController()\n-                        .startActivityInTaskFragment(taskFragment, activityIntent, activityOptions,\n+                final SafeActivityOptions safeOptions =\n+                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n+                final int result = waitAsyncStart(() -> mService.getActivityStartController()\n+                        .startActivityInTaskFragment(taskFragment, activityIntent, safeOptions,\n                                 callerActivityToken, caller.mUid, caller.mPid,\n-                                errorCallbackToken);\n+                                errorCallbackToken));\n                 if (!isStartResultSuccessful(result)) {\n                     sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                             opType, convertStartFailureToThrowable(result, activityIntent));",
        "metrics": {
            "relative_line_count_similarity": 0.7692,
            "normalized_edit_similarity": 0.5733,
            "token_level_edit_distance": 59,
            "codebert_score": {
                "precision": 0.8909,
                "recall": 0.9067,
                "f1": 0.8987,
                "f3": 0.9051
            },
            "token_count_ref_diff": 55,
            "token_count_llm_diff": 66,
            "token_count_total": 121,
            "cosine_similarity_openai": 0.8886
        },
        "metrics_status": "computed"
    },
    {
        "cve_id": "ASB-A-364026473",
        "downstream_version": "14",
        "file_name": "system/stack/gatt/gatt_sr.cc",
        "ref_diff_file": "@@ -772,6 +772,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_cod\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n```",
        "LLM_diff_file": "@@ -735,6 +735,11 @@\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -770,6 +775,12 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n ",
        "metrics": {
            "relative_line_count_similarity": 0.9545,
            "normalized_edit_similarity": 0.6684,
            "token_level_edit_distance": 65,
            "codebert_score": {
                "precision": 0.932,
                "recall": 0.878,
                "f1": 0.9042,
                "f3": 0.8832
            },
            "token_count_ref_diff": 114,
            "token_count_llm_diff": 84,
            "token_count_total": 198,
            "cosine_similarity_openai": 0.7895
        },
        "metrics_status": "computed"
    },
    {
        "cve_id": "ASB-A-364027038",
        "downstream_version": "14",
        "file_name": "system/stack/gatt/gatt_sr.cc",
        "ref_diff_file": "@@ -772,6 +772,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_cod\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n```",
        "LLM_diff_file": "@@ -735,6 +735,11 @@\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -770,6 +775,12 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n ",
        "metrics": {
            "relative_line_count_similarity": 0.9545,
            "normalized_edit_similarity": 0.6684,
            "token_level_edit_distance": 65,
            "codebert_score": {
                "precision": 0.932,
                "recall": 0.878,
                "f1": 0.9042,
                "f3": 0.8832
            },
            "token_count_ref_diff": 114,
            "token_count_llm_diff": 84,
            "token_count_total": 198,
            "cosine_similarity_openai": 0.79
        },
        "metrics_status": "computed"
    },
    {
        "cve_id": "ASB-A-352542820",
        "downstream_version": "14",
        "file_name": "src/com/android/settings/users/UserSettings.java",
        "ref_diff_file": "@@ -465,7 +465,7 @@ public class UserSettings extends SettingsPreferenceFragment\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n         if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx())\n-                && !isCurrentUserGuest()) {\n+                && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n```",
        "LLM_diff_file": "@@ -465,7 +465,8 @@\n     @Override\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n-        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest()) {\n+        if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx())\n+                && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));",
        "metrics": {
            "relative_line_count_similarity": 1.0,
            "normalized_edit_similarity": 0.7586,
            "token_level_edit_distance": 29,
            "codebert_score": {
                "precision": 0.9593,
                "recall": 0.9419,
                "f1": 0.9505,
                "f3": 0.9436
            },
            "token_count_ref_diff": 49,
            "token_count_llm_diff": 49,
            "token_count_total": 98,
            "cosine_similarity_openai": 0.8872
        },
        "metrics_status": "computed"
    },
    {
        "cve_id": "ASB-A-289375038",
        "downstream_version": "14",
        "file_name": "android/app/src/com/android/bluetooth/btservice/AdapterService.java",
        "ref_diff_file": "@@ -27,6 +27,7 @@ import static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE;\n import static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n import static android.bluetooth.BluetoothAdapter.SCAN_MODE_NONE;\n import static android.bluetooth.BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n+import static android.bluetooth.BluetoothDevice.BOND_NONE;\n import static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\n import static android.bluetooth.IBluetoothLeAudio.LE_AUDIO_GROUP_ID_INVALID;\n import static android.text.format.DateUtils.MINUTE_IN_MILLIS;\n@@ -6121,6 +6122,13 @@ public class AdapterService extends Service {\n             mCsipSetCoordinatorService.handleBondStateChanged(device, fromState, toState);\n         }\n         mDatabaseManager.handleBondStateChanged(device, fromState, toState);\n+\n+        if (toState == BOND_NONE) {\n+            // Remove the permissions for unbonded devices\n+            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+        }\n     }\n \n     static int convertScanModeToHal(int mode) {\n```",
        "LLM_diff_file": "@@ -17,6 +17,7 @@\n \n package com.android.bluetooth.btservice;\n \n+import static android.bluetooth.BluetoothDevice.BOND_NONE;\n import static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\n import static android.text.format.DateUtils.MINUTE_IN_MILLIS;\n import static android.text.format.DateUtils.SECOND_IN_MILLIS;\n@@ -49,7 +50,6 @@\n import android.bluetooth.BluetoothFrameworkInitializer;\n import android.bluetooth.BluetoothMap;\n import android.bluetooth.BluetoothProfile;\n-import android.bluetooth.BluetoothProtoEnums;\n import android.bluetooth.BluetoothSap;\n import android.bluetooth.BluetoothServerSocket;\n import android.bluetooth.BluetoothSocket;",
        "metrics": {
            "relative_line_count_similarity": 0.6364,
            "normalized_edit_similarity": 0.3387,
            "token_level_edit_distance": 59,
            "codebert_score": {
                "precision": 0.8505,
                "recall": 0.7365,
                "f1": 0.7894,
                "f3": 0.7465
            },
            "token_count_ref_diff": 78,
            "token_count_llm_diff": 36,
            "token_count_total": 114,
            "cosine_similarity_openai": 0.6895
        },
        "metrics_status": "computed"
    },
    {
        "cve_id": "ASB-A-289811388",
        "downstream_version": "14",
        "file_name": "android/app/src/com/android/bluetooth/btservice/AdapterService.java",
        "ref_diff_file": "@@ -27,6 +27,7 @@ import static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE;\n import static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n import static android.bluetooth.BluetoothAdapter.SCAN_MODE_NONE;\n import static android.bluetooth.BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n+import static android.bluetooth.BluetoothDevice.BOND_NONE;\n import static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\n import static android.bluetooth.IBluetoothLeAudio.LE_AUDIO_GROUP_ID_INVALID;\n import static android.text.format.DateUtils.MINUTE_IN_MILLIS;\n@@ -6121,6 +6122,13 @@ public class AdapterService extends Service {\n             mCsipSetCoordinatorService.handleBondStateChanged(device, fromState, toState);\n         }\n         mDatabaseManager.handleBondStateChanged(device, fromState, toState);\n+\n+        if (toState == BOND_NONE) {\n+            // Remove the permissions for unbonded devices\n+            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+        }\n     }\n \n     static int convertScanModeToHal(int mode) {\n```",
        "LLM_diff_file": "@@ -17,6 +17,7 @@\n \n package com.android.bluetooth.btservice;\n \n+import static android.bluetooth.BluetoothDevice.BOND_NONE;\n import static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\n import static android.text.format.DateUtils.MINUTE_IN_MILLIS;\n import static android.text.format.DateUtils.SECOND_IN_MILLIS;\n@@ -325,6 +326,7 @@\n     private LeAudioService mLeAudioService;\n     private BassClientService mBassClientService;\n     private BatteryService mBatteryService;\n+    private GattService mGattService;\n \n     private volatile boolean mTestModeEnabled = false;\n \n@@ -1337,6 +1339,7 @@\n         mLeAudioService = LeAudioService.getLeAudioService();\n         mBassClientService = BassClientService.getBassClientService();\n         mBatteryService = BatteryService.getBatteryService();\n+        mGattService = GattService.getGattService();\n     }\n \n     @BluetoothAdapter.RfcommListenerResult\n@@ -4916,6 +4919,54 @@\n                 + ctrlState + \"traffic = \" + Arrays.toString(data));\n     }\n \n+    // Method called from JNI when the bond state of a remote device changes.\n+    @VisibleForTesting\n+    public void handleBondStateChanged(BluetoothDevice device, int fromState, int toState) {\n+        if (DBG) {\n+            Log.d(TAG,\n+                    \"handleBondStateChanged: addr=\" + device + \", fromState=\" + fromState\n+                            + \", toState=\" + toState);\n+        }\n+\n+        // Send broadcast if the old state is different from the new state\n+        if (fromState == toState) {\n+            Log.w(TAG, \"handleBondStateChanged: Same bond state, state=\" + toState);\n+            return;\n+        }\n+\n+        if (mBondStateMachine != null) {\n+            mBondStateMachine.handleBondStateChanged(device, fromState, toState);\n+        }\n+\n+        if (mRemoteDevices != null) {\n+            mRemoteDevices.handleBondStateChanged(device, toState);\n+        }\n+\n+        if (mGattService != null) {\n+            mGattService.handleBondStateChanged(device, fromState, toState);\n+        }\n+\n+        if (mHearingAidService != null) {\n+            mHearingAidService.handleBondStateChanged(device, fromState, toState);\n+        }\n+\n+        if (mHapClientService != null) {\n+            mHapClientService.handleBondStateChanged(device, fromState, toState);\n+        }\n+\n+        if (mCsipSetCoordinatorService != null) {\n+            mCsipSetCoordinatorService.handleBondStateChanged(device, fromState, toState);\n+        }\n+        mDatabaseManager.handleBondStateChanged(device, fromState, toState);\n+\n+        if (toState == BOND_NONE) {\n+            // Remove the permissions for unbonded devices\n+            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+        }\n+    }\n+\n     /**\n      * Update metadata change to registered listeners\n      */",
        "metrics": {
            "relative_line_count_similarity": 0.0,
            "normalized_edit_similarity": 0.2748,
            "token_level_edit_distance": 343,
            "codebert_score": {
                "precision": 0.8082,
                "recall": 0.8549,
                "f1": 0.8309,
                "f3": 0.85
            },
            "token_count_ref_diff": 78,
            "token_count_llm_diff": 277,
            "token_count_total": 355,
            "cosine_similarity_openai": 0.7531
        },
        "metrics_status": "computed"
    },
    {
        "cve_id": "ASB-A-375623125",
        "downstream_version": "14",
        "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
        "ref_diff_file": "@@ -3896,7 +3896,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             // Test if the proxied operation will succeed before starting the proxy operation\n             final SyncNotedAppOp testProxiedOp = startOperationDryRun(code,\n                     proxiedUid, resolvedProxiedPackageName, proxiedAttributionTag,\n-                    proxiedVirtualDeviceId, resolvedProxyPackageName, proxiedFlags,\n+                    proxiedVirtualDeviceId, proxyUid, resolvedProxyPackageName, proxiedFlags,\n                     startIfModeDefault);\n \n             if (!shouldStartForMode(testProxiedOp.getOpMode(), startIfModeDefault)) {\n@@ -3936,7 +3936,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             int attributionChainId) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n             }\n@@ -4063,11 +4063,11 @@ public class AppOpsService extends IAppOpsService.Stub {\n      */\n     private SyncNotedAppOp startOperationDryRun(int code, int uid,\n             @NonNull String packageName, @Nullable String attributionTag, int virtualDeviceId,\n-            String proxyPackageName, @OpFlags int flags,\n+            int proxyUid, String proxyPackageName, @OpFlags int flags,\n             boolean startIfModeDefault) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n             }\n```",
        "LLM_diff_file": "@@ -2637,7 +2637,7 @@\n             boolean shouldCollectMessage) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             boolean wasNull = attributionTag == null;\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n@@ -3097,6 +3097,7 @@\n         final int proxiedUid = attributionSource.getNextUid();\n         final String proxiedPackageName = attributionSource.getNextPackageName();\n         final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n+        final int proxiedVirtualDeviceId = attributionSource.getNextVirtualDeviceId();\n \n         verifyIncomingProxyUid(attributionSource);\n         verifyIncomingOp(code);\n@@ -3138,11 +3139,11 @@\n \n         if (!skipProxyOperation) {\n             // Test if the proxied operation will succeed before starting the proxy operation\n-            final SyncNotedAppOp testProxiedOp = startOperationUnchecked(clientId, code,\n-                    proxiedUid, resolvedProxiedPackageName, proxiedAttributionTag, proxyUid,\n-                    resolvedProxyPackageName, proxyAttributionTag, proxiedFlags, startIfModeDefault,\n-                    shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                    proxiedAttributionFlags, attributionChainId, /*dryRun*/ true);\n+            final SyncNotedAppOp testProxiedOp = startOperationDryRun(code,\n+                    proxiedUid, resolvedProxiedPackageName, proxiedAttributionTag,\n+                    proxiedVirtualDeviceId, proxyUid, resolvedProxyPackageName, proxiedFlags,\n+                    startIfModeDefault);\n+\n             if (!shouldStartForMode(testProxiedOp.getOpMode(), startIfModeDefault)) {\n                 return testProxiedOp;\n             }\n@@ -6508,191 +6509,4 @@\n         }\n \n         public SyncNotedAppOp noteOperation(int code, int uid, String packageName,\n-                String attributionTag, boolean shouldCollectAsyncNotedOp, String message,\n-                boolean shouldCollectMessage) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    return mPolicy.noteOperation(code, uid, packageName, attributionTag,\n-                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                            this::noteDelegateOperationImpl);\n-                } else {\n-                    return mPolicy.noteOperation(code, uid, packageName, attributionTag,\n-                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                            AppOpsService.this::noteOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                return noteDelegateOperationImpl(code, uid, packageName,\n-                        attributionTag, shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n-            }\n-            return noteOperationImpl(code, uid, packageName, attributionTag,\n-                    shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n-        }\n-\n-        private SyncNotedAppOp noteDelegateOperationImpl(int code, int uid,\n-                @Nullable String packageName, @Nullable String featureId,\n-                boolean shouldCollectAsyncNotedOp, @Nullable String message,\n-                boolean shouldCollectMessage) {\n-            return mCheckOpsDelegate.noteOperation(code, uid, packageName, featureId,\n-                    shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                    AppOpsService.this::noteOperationImpl);\n-        }\n-\n-        public SyncNotedAppOp noteProxyOperation(int code, AttributionSource attributionSource,\n-                boolean shouldCollectAsyncNotedOp, @Nullable String message,\n-                boolean shouldCollectMessage, boolean skipProxyOperation) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    return mPolicy.noteProxyOperation(code, attributionSource,\n-                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                            skipProxyOperation, this::noteDelegateProxyOperationImpl);\n-                } else {\n-                    return mPolicy.noteProxyOperation(code, attributionSource,\n-                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                            skipProxyOperation, AppOpsService.this::noteProxyOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                return noteDelegateProxyOperationImpl(code,\n-                        attributionSource, shouldCollectAsyncNotedOp, message,\n-                        shouldCollectMessage, skipProxyOperation);\n-            }\n-            return noteProxyOperationImpl(code, attributionSource, shouldCollectAsyncNotedOp,\n-                    message, shouldCollectMessage,skipProxyOperation);\n-        }\n-\n-        private SyncNotedAppOp noteDelegateProxyOperationImpl(int code,\n-                @NonNull AttributionSource attributionSource, boolean shouldCollectAsyncNotedOp,\n-                @Nullable String message, boolean shouldCollectMessage,\n-                boolean skipProxyOperation) {\n-            return mCheckOpsDelegate.noteProxyOperation(code, attributionSource,\n-                    shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n-                    AppOpsService.this::noteProxyOperationImpl);\n-        }\n-\n-        public SyncNotedAppOp startOperation(IBinder token, int code, int uid,\n-                @Nullable String packageName, @NonNull String attributionTag,\n-                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp,\n-                @Nullable String message, boolean shouldCollectMessage,\n-                @AttributionFlags int attributionFlags, int attributionChainId) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    return mPolicy.startOperation(token, code, uid, packageName,\n-                            attributionTag, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                            shouldCollectMessage, attributionFlags, attributionChainId,\n-                            this::startDelegateOperationImpl);\n-                } else {\n-                    return mPolicy.startOperation(token, code, uid, packageName, attributionTag,\n-                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                            shouldCollectMessage, attributionFlags, attributionChainId,\n-                            AppOpsService.this::startOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                return startDelegateOperationImpl(token, code, uid, packageName, attributionTag,\n-                        startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                        shouldCollectMessage, attributionFlags, attributionChainId);\n-            }\n-            return startOperationImpl(token, code, uid, packageName, attributionTag,\n-                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                    attributionFlags, attributionChainId);\n-        }\n-\n-        private SyncNotedAppOp startDelegateOperationImpl(IBinder token, int code, int uid,\n-                @Nullable String packageName, @Nullable String attributionTag,\n-                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n-                boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n-                int attributionChainId) {\n-            return mCheckOpsDelegate.startOperation(token, code, uid, packageName, attributionTag,\n-                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                    attributionFlags, attributionChainId, AppOpsService.this::startOperationImpl);\n-        }\n-\n-        public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n-                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n-                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n-                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n-                @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n-                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                            shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n-                            proxiedAttributionFlags, attributionChainId,\n-                            this::startDelegateProxyOperationImpl);\n-                } else {\n-                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n-                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                            shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n-                            proxiedAttributionFlags, attributionChainId,\n-                            AppOpsService.this::startProxyOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                return startDelegateProxyOperationImpl(clientId, code, attributionSource,\n-                        startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                        shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n-                        proxiedAttributionFlags, attributionChainId);\n-            }\n-            return startProxyOperationImpl(clientId, code, attributionSource, startIfModeDefault,\n-                    shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n-                    proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n-        }\n-\n-        private SyncNotedAppOp startDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n-                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n-                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n-                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n-                @AttributionFlags int proxiedAttributionFlsgs, int attributionChainId) {\n-            return mCheckOpsDelegate.startProxyOperation(clientId, code, attributionSource,\n-                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                    skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlsgs,\n-                    attributionChainId, AppOpsService.this::startProxyOperationImpl);\n-        }\n-\n-        public void finishOperation(IBinder clientId, int code, int uid, String packageName,\n-                String attributionTag) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    mPolicy.finishOperation(clientId, code, uid, packageName, attributionTag,\n-                            this::finishDelegateOperationImpl);\n-                } else {\n-                    mPolicy.finishOperation(clientId, code, uid, packageName, attributionTag,\n-                            AppOpsService.this::finishOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                finishDelegateOperationImpl(clientId, code, uid, packageName, attributionTag);\n-            } else {\n-                finishOperationImpl(clientId, code, uid, packageName, attributionTag);\n-            }\n-        }\n-\n-        private void finishDelegateOperationImpl(IBinder clientId, int code, int uid,\n-                String packageName, String attributionTag) {\n-            mCheckOpsDelegate.finishOperation(clientId, code, uid, packageName, attributionTag,\n-                    AppOpsService.this::finishOperationImpl);\n-        }\n-\n-        public void finishProxyOperation(@NonNull IBinder clientId, int code,\n-                @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n-                            skipProxyOperation, this::finishDelegateProxyOperationImpl);\n-                } else {\n-                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n-                            skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                finishDelegateProxyOperationImpl(clientId, code, attributionSource,\n-                        skipProxyOperation);\n-            } else {\n-                finishProxyOperationImpl(clientId, code, attributionSource, skipProxyOperation);\n-            }\n-        }\n-\n-        private Void finishDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n-                @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n-            mCheckOpsDelegate.finishProxyOperation(clientId, code, attributionSource,\n-                    skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n-            return null;\n-        }\n-    }\n-}\n-```+                String attributionTag, boolean shouldCollect",
        "metrics": {
            "relative_line_count_similarity": 0.0,
            "normalized_edit_similarity": 0.1039,
            "token_level_edit_distance": 1597,
            "codebert_score": {
                "precision": 0.7836,
                "recall": 0.8834,
                "f1": 0.8305,
                "f3": 0.8723
            },
            "token_count_ref_diff": 153,
            "token_count_llm_diff": 980,
            "token_count_total": 1133,
            "cosine_similarity_openai": 0.7778
        },
        "metrics_status": "computed"
    },
    {
        "cve_id": "ASB-A-353240784",
        "downstream_version": "14",
        "file_name": "services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java",
        "ref_diff_file": "@@ -217,6 +217,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // See {@link Provider#pendingDeletedWidgetIds}.\n     private static final String PENDING_DELETED_IDS_ATTR = \"pending_deleted_ids\";\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     // Handles user and package related broadcasts.\n     // See {@link #registerBroadcastReceiver}\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n@@ -3591,11 +3618,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (DEBUG) {\n             Slog.i(TAG, \"addWidgetLocked() \" + widget);\n         }\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(@NonNull final Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.\n```",
        "LLM_diff_file": "@@ -24,6 +24,7 @@\n \n import static com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME;\n \n+import android.annotation.NonNull;\n import android.annotation.UserIdInt;\n import android.app.ActivityManager;\n import android.app.ActivityManagerInternal;\n@@ -171,6 +172,20 @@\n     // used to verify which request has successfully been received by the host.\n     private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n \n+    // See {@link Provider#pendingDeletedWidgetIds}.\n+    private static final String PENDING_DELETED_IDS_ATTR = \"pending_deleted_ids\";\n+\n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n+    // Handles user and package related broadcasts.\n+    // See {@link #registerBroadcastReceiver}\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n         @Override\n         public void onReceive(Context context, Intent intent) {\n@@ -1043,8 +1058,8 @@\n \n             // NOTE: The lookup is enforcing security across users by making\n             // sure the provider is in the already vetted user profile.\n-            ProviderId providerId = new ProviderId(providerUid, providerComponent);\n-            Provider provider = lookupProviderLocked(providerId);\n+            ProviderId id = new ProviderId(providerUid, providerComponent);\n+            Provider provider = lookupProviderLocked(id);\n \n             if (provider == null) {\n                 Slog.e(TAG, \"No widget provider \" + providerComponent + \" for profile \"\n@@ -1699,30 +1714,12 @@\n         if (host != null) {\n             return host;\n         }\n-        ensureHostCountBeforeAddLocked(id);\n+\n         host = new Host();\n         host.id = id;\n         mHosts.add(host);\n \n         return host;\n-    }\n-\n-    /**\n-     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n-     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n-     * removes the oldest host.\n-     */\n-    private void ensureHostCountBeforeAddLocked(@NonNull final HostId hostId) {\n-        final List<Host> hosts = new ArrayList<>();\n-        for (Host host : mHosts) {\n-            if (host.id.uid == hostId.uid\n-                    && host.id.packageName.equals(hostId.packageName)) {\n-                hosts.add(host);\n-            }\n-        }\n-        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n-            deleteHostLocked(hosts.remove(0));\n-        }\n     }\n \n     private void deleteHostLocked(Host host) {\n@@ -2852,9 +2849,33 @@\n      * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n      */\n     void addWidgetLocked(Widget widget) {\n+        if (DEBUG) {\n+            Slog.i(TAG, \"addWidgetLocked() \" + widget);\n+        }\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n+    }\n+\n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(@NonNull final Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n     }\n \n     /**",
        "metrics": {
            "relative_line_count_similarity": 0.0,
            "normalized_edit_similarity": 0.4258,
            "token_level_edit_distance": 470,
            "codebert_score": {
                "precision": 0.8477,
                "recall": 0.889,
                "f1": 0.8679,
                "f3": 0.8847
            },
            "token_count_ref_diff": 283,
            "token_count_llm_diff": 518,
            "token_count_total": 801,
            "cosine_similarity_openai": 0.8695
        },
        "metrics_status": "computed"
    },
    {
        "cve_id": "ASB-A-382064697",
        "downstream_version": "14",
        "file_name": "services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java",
        "ref_diff_file": "@@ -2723,16 +2723,16 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n         }\n     }\n \n-    /**\n-     * Apply default restrictions that haven't been applied to a given admin yet.\n-     */\n+    /** Apply default restrictions that haven't been applied to a given admin yet. */\n     private void maybeSetDefaultRestrictionsForAdminLocked(int userId, ActiveAdmin admin) {\n-        Set<String> defaultRestrictions =\n-                UserRestrictionsUtils.getDefaultEnabledForManagedProfiles();\n-        if (defaultRestrictions.equals(admin.defaultEnabledRestrictionsAlreadySet)) {\n+        Set<String> newDefaultRestrictions = new HashSet(\n+            UserRestrictionsUtils.getDefaultEnabledForManagedProfiles());\n+        newDefaultRestrictions.removeAll(admin.defaultEnabledRestrictionsAlreadySet);\n+        if (newDefaultRestrictions.isEmpty()) {\n             return; // The same set of default restrictions has been already applied.\n         }\n-        for (String restriction : defaultRestrictions) {\n+\n+        for (String restriction : newDefaultRestrictions) {\n             mDevicePolicyEngine.setLocalPolicy(\n                     PolicyDefinition.getPolicyDefinitionForUserRestriction(restriction),\n                     EnforcingAdmin.createEnterpriseEnforcingAdmin(\n@@ -2740,10 +2740,9 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n                             admin.getUserHandle().getIdentifier()),\n                     new BooleanPolicyValue(true),\n                     userId);\n+            admin.defaultEnabledRestrictionsAlreadySet.add(restriction);\n+            Slogf.i(LOG_TAG, \"Enabled the following restriction by default: \" + restriction);\n         }\n-        admin.defaultEnabledRestrictionsAlreadySet.addAll(defaultRestrictions);\n-        Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \"\n-                + defaultRestrictions);\n     }\n \n     private void maybeStartSecurityLogMonitorOnActivityManagerReady() {\n```",
        "LLM_diff_file": "",
        "metrics": {},
        "metrics_status": "Metrics not computed due to: LLM processing was skipped (skipped, Error during LLM processing: 500 An internal error has occurred. Please retry or report in https://developers.generativeai.google/guide/troubleshooting)."
    }
]