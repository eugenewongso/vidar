[
    {
        "cve_id": "ASB-A-296915500",
        "downstream_version": "14",
        "file_name": "android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java",
        "ground_truth_codebase": "",
        "llm_patched_codebase": "/*\n * Copyright (c) 2008-2009, Motorola, Inc.\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * - Neither the name of the Motorola, Inc. nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.android.bluetooth.opp;\n\nimport static android.os.UserHandle.myUserId;\n\nimport android.bluetooth.BluetoothProfile;\nimport android.bluetooth.BluetoothProtoEnums;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.res.AssetFileDescriptor;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteException;\nimport android.net.Uri;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.util.EventLog;\nimport android.util.Log;\n\nimport com.android.bluetooth.BluetoothMethodProxy;\nimport com.android.bluetooth.R;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.Objects;\n\n/**\n * This class stores information about a single sending file It will only be used for outbound\n * share.\n */\n// Next tag value for ContentProfileErrorReportUtils.report(): 16\npublic class BluetoothOppSendFileInfo {\n    private static final String TAG = \"BluetoothOppSendFileInfo\";\n\n    private static final boolean D = Constants.DEBUG;\n\n\n    /** Reusable SendFileInfo for error status. */\n    static final BluetoothOppSendFileInfo SEND_FILE_INFO_ERROR =\n            new BluetoothOppSendFileInfo(null, null, 0, null, BluetoothShare.STATUS_FILE_ERROR);\n\n    /** readable media file name */\n    public final String mFileName;\n\n    /** media file input stream */\n    public final FileInputStream mInputStream;\n\n    /** vCard string data */\n    public final String mData;\n\n    public final int mStatus;\n\n    public final String mMimetype;\n\n    public final long mLength;\n\n    /** for media file */\n    public BluetoothOppSendFileInfo(String fileName, String type, long length,\n            FileInputStream inputStream, int status) {\n        mFileName = fileName;\n        mMimetype = type;\n        mLength = length;\n        mInputStream = inputStream;\n        mStatus = status;\n        mData = null;\n    }\n\n    /** for vCard, or later for vCal, vNote. Not used currently */\n    public BluetoothOppSendFileInfo(String data, String type, long length, int status) {\n        mFileName = null;\n        mInputStream = null;\n        mData = data;\n        mMimetype = type;\n        mLength = length;\n        mStatus = status;\n    }\n\n    public static BluetoothOppSendFileInfo generateFileInfo(Context context, Uri uri, String type,\n            boolean fromExternal) {\n        ContentResolver contentResolver = context.getContentResolver();\n        String scheme = uri.getScheme();\n        String fileName = null;\n        String contentType;\n        long length = 0;\n        // Support all Uri with \"content\" scheme\n        // This will allow more 3rd party applications to share files via\n        // bluetooth\n        if (\"content\".equals(scheme)) {\n            if (fromExternal && BluetoothOppUtility.isForbiddenContent(uri)) {\n                EventLog.writeEvent(0x534e4554, \"179910660\", -1, uri.toString());\n                Log.e(TAG, \"Content from forbidden URI is not allowed.\");\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            if (isContentUriForOtherUser(uri)) {\n                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n                ContentProfileErrorReportUtils.report(\n                        BluetoothProfile.OPP,\n                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__LOG_ERROR,\n                        15);\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            contentType = contentResolver.getType(uri);\n            Cursor metadataCursor;\n            try {\n                metadataCursor = BluetoothMethodProxy.getInstance().contentResolverQuery(\n                        contentResolver, uri, new String[]{\n                                OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE\n                        }, null, null, null);\n            } catch (SQLiteException e) {\n                // some content providers don't support the DISPLAY_NAME or SIZE columns\n                metadataCursor = null;\n            } catch (SecurityException e) {\n                Log.e(TAG, \"generateFileInfo: Permission error, could not access URI: \" + uri);\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            if (metadataCursor != null) {\n                try {\n                    if (metadataCursor.moveToFirst()) {\n                        int indexName = metadataCursor.getColumnIndex(OpenableColumns.DISPLAY_NAME);\n                        int indexSize = metadataCursor.getColumnIndex(OpenableColumns.SIZE);\n                        if (indexName != -1) {\n                            fileName = metadataCursor.getString(indexName);\n                        }\n                        if (indexSize != -1) {\n                            length = metadataCursor.getLong(indexSize);\n                        }\n                        if (D) {\n                            Log.d(TAG, \"fileName = \" + fileName + \" length = \" + length);\n                        }\n                    }\n                } finally {\n                    metadataCursor.close();\n                }\n            }\n            if (fileName == null) {\n                // use last segment of URI if DISPLAY_NAME query fails\n                fileName = uri.getLastPathSegment();\n                if (D) Log.d(TAG, \"fileName from URI :\" + fileName);\n            }\n        } else if (\"file\".equals(scheme)) {\n            if (uri.getPath() == null) {\n                Log.e(TAG, \"Invalid URI path: \" + uri);\n                return SEND_FILE_INFO_ERROR;\n            }\n            if (fromExternal && !BluetoothOppUtility.isInExternalStorageDir(uri)) {\n                EventLog.writeEvent(0x534e4554, \"35310991\", -1, uri.getPath());\n                Log.e(TAG, \"File based URI not in Environment.getExternalStorageDirectory() is not \"\n                        + \"allowed.\");\n                return SEND_FILE_INFO_ERROR;\n            }\n            fileName = uri.getLastPathSegment();\n            contentType = type;\n            File f = new File(uri.getPath());\n            length = f.length();\n        } else {\n            // currently don't accept other scheme\n            return SEND_FILE_INFO_ERROR;\n        }\n        FileInputStream is = null;\n        if (scheme.equals(\"content\")) {\n            try {\n                // We've found that content providers don't always have the\n                // right size in _OpenableColumns.SIZE\n                // As a second source of getting the correct file length,\n                // get a file descriptor and get the stat length\n                AssetFileDescriptor fd = BluetoothMethodProxy.getInstance()\n                        .contentResolverOpenAssetFileDescriptor(contentResolver, uri, \"r\");\n                long statLength = fd.getLength();\n                if (length != statLength && statLength > 0) {\n                    Log.e(TAG, \"Content provider length is wrong (\" + Long.toString(length)\n                            + \"), using stat length (\" + Long.toString(statLength) + \")\");\n                    length = statLength;\n                }\n\n                try {\n                    // This creates an auto-closing input-stream, so\n                    // the file descriptor will be closed whenever the InputStream\n                    // is closed.\n                    is = fd.createInputStream();\n\n                    // If the database doesn't contain the file size, get the size\n                    // by reading through the entire stream\n                    if (length == 0) {\n                        length = getStreamSize(is);\n                        Log.w(TAG, \"File length not provided. Length from stream = \" + length);\n                        // Reset the stream\n                        fd = BluetoothMethodProxy.getInstance()\n                                .contentResolverOpenAssetFileDescriptor(contentResolver, uri, \"r\");\n                        is = fd.createInputStream();\n                    }\n                } catch (IOException e) {\n                    try {\n                        fd.close();\n                    } catch (IOException e2) {\n                        // Ignore\n                    }\n                }\n            } catch (FileNotFoundException e) {\n                // Ignore\n            } catch (SecurityException e) {\n                return SEND_FILE_INFO_ERROR;\n            }\n        }\n\n        if (is == null) {\n            try {\n                is = (FileInputStream) BluetoothMethodProxy.getInstance()\n                        .contentResolverOpenInputStream(contentResolver, uri);\n\n                // If the database doesn't contain the file size, get the size\n                // by reading through the entire stream\n                if (length == 0) {\n                    length = getStreamSize(is);\n                    // Reset the stream\n                    is = (FileInputStream) BluetoothMethodProxy.getInstance()\n                            .contentResolverOpenInputStream(contentResolver, uri);\n                }\n            } catch (FileNotFoundException e) {\n                return SEND_FILE_INFO_ERROR;\n            } catch (IOException e) {\n                return SEND_FILE_INFO_ERROR;\n            }\n        }\n\n        if (length == 0) {\n            Log.e(TAG, \"Could not determine size of file\");\n            return SEND_FILE_INFO_ERROR;\n        } else if (length > 0xffffffffL) {\n            Log.e(TAG, \"File of size: \" + length + \" bytes can't be transferred\");\n            throw new IllegalArgumentException(context\n                .getString(R.string.bluetooth_opp_file_limit_exceeded));\n        }\n\n        return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n    }\n\n    private static boolean isContentUriForOtherUser(Uri uri) {\n        String uriUserId = uri.getUserInfo();\n        return !TextUtils.isEmpty(uriUserId)\n                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n    }\n\n    private static long getStreamSize(FileInputStream is) throws IOException {\n        long length = 0;\n        byte[] unused = new byte[4096];\n        int bytesRead = is.read(unused, 0, 4096);\n        while (bytesRead != -1) {\n            length += bytesRead;\n            bytesRead = is.read(unused, 0, 4096);\n        }\n        return length;\n    }\n}",
        "metrics": {},
        "metrics_status": "Metrics not computed: 'downstream_file_content_ground_truth' is missing."
    },
    {
        "cve_id": "ASB-A-364027949",
        "downstream_version": "14",
        "file_name": "system/stack/gatt/gatt_sr.cc",
        "ground_truth_codebase": "",
        "llm_patched_codebase": "/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND",
        "metrics": {},
        "metrics_status": "Metrics not computed: 'downstream_file_content_ground_truth' is missing."
    },
    {
        "cve_id": "ASB-A-364025411",
        "downstream_version": "14",
        "file_name": "system/stack/gatt/gatt_sr.cc",
        "ground_truth_codebase": "",
        "llm_patched_codebase": "/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND",
        "metrics": {},
        "metrics_status": "Metrics not computed: 'downstream_file_content_ground_truth' is missing."
    },
    {
        "cve_id": "ASB-A-340480881",
        "downstream_version": "14",
        "file_name": "PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java",
        "ground_truth_codebase": "",
        "llm_patched_codebase": "/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.permissioncontroller.permission.ui.handheld;\n\nimport static android.content.pm.PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED;\nimport static android.content.pm.PackageManager.FLAG_PERMISSION_USER_SET;\n\nimport static com.android.permissioncontroller.PermissionControllerStatsLog.REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED;\n\nimport android.app.Activity;\nimport android.app.Application;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentSender;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.graphics.drawable.Drawable;\nimport android.os.Bundle;\nimport android.os.RemoteCallback;\nimport android.os.UserHandle;\nimport android.text.Html;\nimport android.text.Spanned;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.Button;\nimport android.widget.ImageView;\nimport android.widget.TextView;\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\nimport androidx.lifecycle.ViewModelProvider;\nimport androidx.preference.Preference;\nimport androidx.preference.PreferenceCategory;\nimport androidx.preference.PreferenceFragmentCompat;\nimport androidx.preference.PreferenceGroup;\nimport androidx.preference.PreferenceScreen;\n\nimport com.android.permissioncontroller.PermissionControllerStatsLog;\nimport com.android.permissioncontroller.R;\nimport com.android.permissioncontroller.permission.model.livedatatypes.LightAppPermGroup;\nimport com.android.permissioncontroller.permission.model.livedatatypes.LightPermission;\nimport com.android.permissioncontroller.permission.ui.ManagePermissionsActivity;\nimport com.android.permissioncontroller.permission.ui.model.ReviewPermissionViewModelFactory;\nimport com.android.permissioncontroller.permission.ui.model.ReviewPermissionsViewModel;\nimport com.android.permissioncontroller.permission.ui.model.ReviewPermissionsViewModel.PermissionTarget;\nimport com.android.permissioncontroller.permission.utils.KotlinUtils;\nimport com.android.permissioncontroller.permission.utils.Utils;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Random;\n\n/**\n * If an app does not support runtime permissions the user is prompted via this fragment to select\n * which permissions to grant to the app before first use and if an update changed the permissions.\n */\npublic final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n        implements View.OnClickListener, PermissionPreference.PermissionPreferenceChangeListener,\n        PermissionPreference.PermissionPreferenceOwnerFragment {\n\n    private static final String EXTRA_PACKAGE_INFO =\n            \"com.android.permissioncontroller.permission.ui.extra.PACKAGE_INFO\";\n    private static final String LOG_TAG = ReviewPermissionsFragment.class.getSimpleName();\n\n    private ReviewPermissionsViewModel mViewModel;\n    private View mView;\n    private Button mContinueButton;\n    private Button mCancelButton;\n    private Button mMoreInfoButton;\n    private PreferenceCategory mNewPermissionsCategory;\n    private PreferenceCategory mCurrentPermissionsCategory;\n\n    private boolean mHasConfirmedRevoke;\n\n    /**\n     * Creates bundle arguments for the navigation graph\n     * @param packageInfo packageInfo added to the bundle\n     * @return the bundle\n     */\n    public static Bundle getArgs(PackageInfo packageInfo) {\n        Bundle arguments = new Bundle();\n        arguments.putParcelable(EXTRA_PACKAGE_INFO, packageInfo);\n        return arguments;\n    }\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n\n        PackageInfo packageInfo = getArguments().getParcelable(EXTRA_PACKAGE_INFO);\n        if (packageInfo == null) {\n            activity.finishAfterTransition();\n            return;\n        }\n\n        ReviewPermissionViewModelFactory factory = new ReviewPermissionViewModelFactory(\n                getActivity().getApplication(), packageInfo);\n        mViewModel = new ViewModelProvider(this, factory).get(ReviewPermissionsViewModel.class);\n        mViewModel.getPermissionGroupsLiveData().observe(this,\n                (Map<String, LightAppPermGroup> permGroupsMap) -> {\n                    if (getActivity().isFinishing()) {\n                        return;\n                    }\n                    if (permGroupsMap.isEmpty()) {\n                        //If the system called for a review but no groups are found, this means\n                        // that all groups are restricted. Hence there is nothing to review\n                        // and instantly continue.\n                        confirmPermissionsReview();\n                        executeCallback(true);\n                        activity.finishAfterTransition();\n                    } else {\n                        bindUi(permGroupsMap);\n                        loadPreferences(permGroupsMap);\n                    }\n                });\n    }\n\n    @Override\n    public void onCreatePreferences(Bundle bundle, String s) {\n        // empty\n    }\n\n    @Override\n    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,\n            @Nullable Bundle savedInstanceState) {\n        mView = inflater.inflate(R.layout.review_permissions, container, false);\n        ViewGroup preferenceRootView = mView.requireViewById(R.id.preferences_frame);\n        View prefsContainer = super.onCreateView(inflater, preferenceRootView, savedInstanceState);\n        preferenceRootView.addView(prefsContainer);\n        return mView;\n    }\n\n    @Override\n    public void onClick(View view) {\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n        if (view == mContinueButton) {\n            confirmPermissionsReview();\n            executeCallback(true);\n        } else if (view == mCancelButton) {\n            executeCallback(false);\n            activity.setResult(Activity.RESULT_CANCELED);\n        } else if (view == mMoreInfoButton) {\n            Intent intent = new Intent(Intent.ACTION_MANAGE_APP_PERMISSIONS);\n            intent.putExtra(Intent.EXTRA_PACKAGE_NAME,\n                    mViewModel.getPackageInfo().packageName);\n            intent.putExtra(Intent.EXTRA_USER, UserHandle.getUserHandleForUid(\n                    mViewModel.getPackageInfo().applicationInfo.uid));\n            intent.putExtra(ManagePermissionsActivity.EXTRA_ALL_PERMISSIONS, true);\n            getActivity().startActivity(intent);\n        }\n        activity.finishAfterTransition();\n    }\n\n    private void confirmPermissionsReview() {\n        final List<PreferenceGroup> preferenceGroups = new ArrayList<>();\n        if (mNewPermissionsCategory != null) {\n            preferenceGroups.add(mNewPermissionsCategory);\n            preferenceGroups.add(mCurrentPermissionsCategory);\n        } else {\n            PreferenceScreen preferenceScreen = getPreferenceScreen();\n            if (preferenceScreen != null) {\n                preferenceGroups.add(preferenceScreen);\n            }\n        }\n\n        final int preferenceGroupCount = preferenceGroups.size();\n        long changeIdForLogging = new Random().nextLong();\n        Application app = getActivity().getApplication();\n        for (int groupNum = 0; groupNum < preferenceGroupCount; groupNum++) {\n            final PreferenceGroup preferenceGroup = preferenceGroups.get(groupNum);\n\n            final int preferenceCount = preferenceGroup.getPreferenceCount();\n            for (int prefNum = 0; prefNum < preferenceCount; prefNum++) {\n                Preference preference = preferenceGroup.getPreference(prefNum);\n                if (preference instanceof PermissionReviewPreference) {\n                    PermissionReviewPreference permPreference =\n                            (PermissionReviewPreference) preference;\n                    LightAppPermGroup group = permPreference.getGroup();\n\n\n                    if (permPreference.getState().and(\n                            PermissionTarget.PERMISSION_FOREGROUND)\n                            != PermissionTarget.PERMISSION_NONE.getValue()) {\n                        KotlinUtils.INSTANCE.grantForegroundRuntimePermissions(app, group);\n                    }\n                    if (permPreference.getState().and(\n                            PermissionTarget.PERMISSION_BACKGROUND)\n                            != PermissionTarget.PERMISSION_NONE.getValue()) {\n                        KotlinUtils.INSTANCE.grantBackgroundRuntimePermissions(app, group);\n                    }\n                    if (permPreference.getState() == PermissionTarget.PERMISSION_NONE) {\n                        KotlinUtils.INSTANCE.revokeForegroundRuntimePermissions(app, group);\n                        KotlinUtils.INSTANCE.revokeBackgroundRuntimePermissions(app, group);\n                    }\n                    logReviewPermissionsFragmentResult(changeIdForLogging, group);\n                }\n            }\n        }\n\n        // Some permission might be restricted and hence there is no AppPermissionGroup for it.\n        // Manually unset all review-required flags, regardless of restriction.\n        PackageManager pm = getContext().getPackageManager();\n        PackageInfo pkg = mViewModel.getPackageInfo();\n        UserHandle user = UserHandle.getUserHandleForUid(pkg.applicationInfo.uid);\n\n        if (pkg.requestedPermissions == null) {\n            // No flag updating to do\n            return;\n        }\n\n        for (String perm : pkg.requestedPermissions) {\n            try {\n                pm.updatePermissionFlags(perm, pkg.packageName,\n                        FLAG_PERMISSION_REVIEW_REQUIRED | FLAG_PERMISSION_USER_SET,\n                        FLAG_PERMISSION_USER_SET, user);\n            } catch (IllegalArgumentException e) {\n                Log.e(LOG_TAG, \"Cannot unmark \" + perm + \" requested by \" + pkg.packageName\n                        + \" as review required\", e);\n            }\n        }\n    }\n\n    private void logReviewPermissionsFragmentResult(long changeId, LightAppPermGroup group) {\n        ArrayList<LightPermission> permissions = new ArrayList<>(\n                group.getAllPermissions().values());\n\n        int numPermissions = permissions.size();\n        for (int i = 0; i < numPermissions; i++) {\n            LightPermission permission = permissions.get(i);\n\n            PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                    changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                    group.getPackageName(),\n                    permission.getName(), permission.isGranted());\n            Log.i(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                    + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                    + group.getPackageName() + \" permission=\"\n                    + permission.getName() + \" granted=\" + permission.isGranted());\n        }\n    }\n\n    private void bindUi(Map<String, LightAppPermGroup> permGroupsMap) {\n        Activity activity = getActivity();\n        if (activity == null || !mViewModel.isInitialized()) {\n            return;\n        }\n\n        Drawable icon = mViewModel.getPackageInfo().applicationInfo.loadIcon(\n                    getContext().getPackageManager());\n        ImageView iconView = mView.requireViewById(R.id.app_icon);\n        iconView.setImageDrawable(icon);\n\n        // Set message\n        final int labelTemplateResId = mViewModel.isPackageUpdated()\n                ? R.string.permission_review_title_template_update\n                : R.string.permission_review_title_template_install;\n        Spanned message = Html.fromHtml(getString(labelTemplateResId,\n                Utils.getAppLabel(mViewModel.getPackageInfo().applicationInfo,\n                        getActivity().getApplication())), 0);\n        // Set the permission message as the title so it can be announced.\n        activity.setTitle(message.toString());\n\n        // Color the app name.\n        TextView permissionsMessageView = mView.requireViewById(\n                R.id.permissions_message);\n        permissionsMessageView.setText(message);\n\n        mContinueButton = mView.requireViewById(R.id.continue_button);\n        mContinueButton.setOnClickListener(this);\n\n        mCancelButton = mView.requireViewById(R.id.cancel_button);\n        mCancelButton.setOnClickListener(this);\n\n        if (activity.getPackageManager().arePermissionsIndividuallyControlled()) {\n            mMoreInfoButton = mView.requireViewById(\n                    R.id.permission_more_info_button);\n            mMoreInfoButton.setOnClickListener(this);\n            mMoreInfoButton.setVisibility(View.VISIBLE);\n        }\n    }\n\n    private PermissionReviewPreference getPreference(String key) {\n        if (mNewPermissionsCategory != null) {\n            PermissionReviewPreference pref =\n                    mNewPermissionsCategory.findPreference(key);\n\n            if (pref == null && mCurrentPermissionsCategory != null) {\n                return mCurrentPermissionsCategory.findPreference(key);\n            } else {\n                return pref;\n            }\n        } else {\n            return getPreferenceScreen().findPreference(key);\n        }\n    }\n\n    private void loadPreferences(Map<String, LightAppPermGroup> permGroupsMap) {\n        Activity activity = getActivity();\n        if (activity == null || !mViewModel.isInitialized()) {\n            return;\n        }\n\n        PreferenceScreen screen = getPreferenceScreen();\n        if (screen == null) {\n            screen = getPreferenceManager().createPreferenceScreen(getContext());\n            setPreferenceScreen(screen);\n        } else {\n            screen.removeAll();\n        }\n\n        mCurrentPermissionsCategory = null;\n        mNewPermissionsCategory = null;\n\n        final boolean isPackageUpdated = mViewModel.isPackageUpdated();\n\n        for (LightAppPermGroup group : permGroupsMap.values()) {\n            PermissionReviewPreference preference = getPreference(group.getPermGroupName());\n            if (preference == null) {\n                preference = new PermissionReviewPreference(this,\n                        group, this, mViewModel);\n                preference.setKey(group.getPermGroupName());\n                Drawable icon = KotlinUtils.INSTANCE.getPermGroupIcon(getContext(),\n                        group.getPermGroupName());\n                preference.setIcon(icon);\n                preference.setTitle(KotlinUtils.INSTANCE.getPermGroupLabel(getContext(),\n                        group.getPermGroupName()));\n            } else {\n                preference.updateUi();\n            }\n\n            if (group.isReviewRequired()) {\n                if (!isPackageUpdated) {\n                    screen.addPreference(preference);\n                } else {\n                    if (mNewPermissionsCategory == null) {\n                        mNewPermissionsCategory = new PreferenceCategory(activity);\n                        mNewPermissionsCategory.setTitle(R.string.new_permissions_category);\n                        mNewPermissionsCategory.setOrder(1);\n                        screen.addPreference(mNewPermissionsCategory);\n                    }\n                    mNewPermissionsCategory.addPreference(preference);\n                }\n            } else {\n                if (mCurrentPermissionsCategory == null) {\n                    mCurrentPermissionsCategory = new PreferenceCategory(activity);\n                    mCurrentPermissionsCategory.setTitle(R.string.current_permissions_category);\n                    mCurrentPermissionsCategory.setOrder(2);\n                    screen.addPreference(mCurrentPermissionsCategory);\n                }\n                mCurrentPermissionsCategory.addPreference(preference);\n            }\n        }\n    }\n\n    private void executeCallback(boolean success) {\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n        if (success) {\n            IntentSender intent = activity.getIntent().getParcelableExtra(Intent.EXTRA_INTENT);\n            if (intent != null) {\n                try {\n                    int flagMask = 0;\n                    int flagValues = 0;\n                    if (activity.getIntent().getBooleanExtra(\n                            Intent.EXTRA_RESULT_NEEDED, false)) {\n                        flagMask = Intent.FLAG_ACTIVITY_FORWARD_RESULT;\n                        flagValues = Intent.FLAG_ACTIVITY_FORWARD_RESULT;\n                    }\n                    activity.startIntentSenderForResult(intent, -1, null,\n                            flagMask, flagValues, 0);\n                } catch (IntentSender.SendIntentException e) {\n                        /* ignore */\n                }\n                return;\n            }\n        }\n        RemoteCallback callback = activity.getIntent().getParcelableExtra(\n                Intent.EXTRA_REMOTE_CALLBACK);\n        if (callback != null) {\n            Bundle result = new Bundle();\n            result.putBoolean(Intent.EXTRA_RETURN_RESULT, success);\n            callback.sendResult(result);\n        }\n    }\n\n    @Override\n    public boolean shouldConfirmDefaultPermissionRevoke() {\n        return !mHasConfirmedRevoke;\n    }\n\n    @Override\n    public void hasConfirmDefaultPermissionRevoke() {\n        mHasConfirmedRevoke = true;\n    }\n\n    @Override\n    public void onPreferenceChanged(String key) {\n        getPreference(key).setChanged();\n    }\n\n    @Override\n    public void onDenyAnyWay(String key, PermissionTarget changeTarget) {\n        getPreference(key).onDenyAnyWay(changeTarget);\n    }\n\n    @Override\n    public void onBackgroundAccessChosen(String key, int chosenItem) {\n        getPreference(key).onBackgroundAccessChosen(chosenItem);\n    }\n\n    /**\n     * Extend the {@link PermissionPreference}:\n     * <ul>\n     *     <li>Show the description of the permission group</li>\n     *     <li>Show the permission group as granted if the user has not toggled it yet. This means\n     *     that if the user does not touch the preference, we will later grant the permission\n     *     in {@link #confirmPermissionsReview()}.</li>\n     * </ul>\n     */\n    private static class PermissionReviewPreference extends PermissionPreference {\n        private final LightAppPermGroup mGroup;\n        private final Context mContext;\n        private boolean mWasChanged;\n\n        PermissionReviewPreference(PreferenceFragmentCompat fragment, LightAppPermGroup group,\n                PermissionPreferenceChangeListener callbacks,\n                ReviewPermissionsViewModel reviewPermissionsViewModel) {\n            super(fragment, group, callbacks, reviewPermissionsViewModel);\n            mGroup = group;\n            mContext = fragment.getContext();\n            updateUi();\n        }\n\n        LightAppPermGroup getGroup() {\n            return mGroup;\n        }\n\n        /**\n         * Mark the permission as changed by the user\n         */\n        void setChanged() {\n            mWasChanged = true;\n            updateUi();\n        }\n\n        @Override\n        void updateUi() {\n            // updateUi might be called in super-constructor before group is initialized\n            if (mGroup == null) {\n                return;\n            }\n\n            super.updateUi();\n\n            if (isEnabled()) {\n                if (mGroup.isReviewRequired() && !mWasChanged) {\n                    setSummary(KotlinUtils.INSTANCE.getPermGroupDescription(mContext,\n                            mGroup.getPermGroupName()));\n                    setCheckedOverride(true);\n                } else if (TextUtils.isEmpty(getSummary())) {\n                    // Sometimes the summary is already used, e.g. when this for a\n                    // foreground/background group. In this case show leave the original summary.\n                    setSummary(KotlinUtils.INSTANCE.getPermGroupDescription(mContext,\n                            mGroup.getPermGroupName()));\n                }\n            }\n        }\n    }\n}",
        "metrics": {},
        "metrics_status": "Metrics not computed: 'downstream_file_content_ground_truth' is missing."
    },
    {
        "cve_id": "ASB-A-369103643",
        "downstream_version": "14",
        "file_name": "services/core/java/com/android/server/wm/WindowOrganizerController.java",
        "ground_truth_codebase": "",
        "llm_patched_codebase": "/*\n * Copyright (C) 2020 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.wm;\n\nimport static android.Manifest.permission.START_TASKS_FROM_RECENTS;\nimport static android.app.ActivityManager.isStartResultSuccessful;\nimport static android.app.WindowConfiguration.WINDOWING_MODE_UNDEFINED;\nimport static android.app.WindowConfiguration.WINDOW_CONFIG_BOUNDS;\nimport static android.view.Display.DEFAULT_DISPLAY;\nimport static android.window.TaskFragmentOperation.OP_TYPE_CLEAR_ADJACENT_TASK_FRAGMENTS;\nimport static android.window.TaskFragmentOperation.OP_TYPE_CREATE_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_DELETE_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_REPARENT_ACTIVITY_TO_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_REQUEST_FOCUS_ON_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_SET_ADJACENT_TASK_FRAGMENTS;\nimport static android.window.TaskFragmentOperation.OP_TYPE_SET_ANIMATION_PARAMS;\nimport static android.window.TaskFragmentOperation.OP_TYPE_SET_COMPANION_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_SET_RELATIVE_BOUNDS;\nimport static android.window.TaskFragmentOperation.OP_TYPE_START_ACTIVITY_IN_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_UNKNOWN;\nimport static android.window.WindowContainerTransaction.Change.CHANGE_RELATIVE_BOUNDS;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_ADD_INSETS_FRAME_PROVIDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_ADD_TASK_FRAGMENT_OPERATION;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_CHILDREN_TASKS_REPARENT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_CLEAR_ADJACENT_ROOTS;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_FINISH_ACTIVITY;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_LAUNCH_TASK;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_PENDING_INTENT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REMOVE_INSETS_FRAME_PROVIDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REMOVE_TASK;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REORDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REPARENT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_RESTORE_TRANSIENT_ORDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_ADJACENT_ROOTS;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_ALWAYS_ON_TOP;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_LAUNCH_ADJACENT_FLAG_ROOT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_LAUNCH_ROOT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_REPARENT_LEAF_TASK_IF_RELAUNCH;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_START_SHORTCUT;\n\nimport static com.android.internal.protolog.ProtoLogGroup.WM_DEBUG_WINDOW_ORGANIZER;\nimport static com.android.server.wm.ActivityTaskManagerService.enforceTaskPermission;\nimport static com.android.server.wm.ActivityTaskSupervisor.PRESERVE_WINDOWS;\nimport static com.android.server.wm.Task.FLAG_FORCE_HIDDEN_FOR_PINNED_TASK;\nimport static com.android.server.wm.Task.FLAG_FORCE_HIDDEN_FOR_TASK_ORG;\nimport static com.android.server.wm.TaskFragment.EMBEDDING_ALLOWED;\nimport static com.android.server.wm.WindowContainer.POSITION_BOTTOM;\nimport static com.android.server.wm.WindowContainer.POSITION_TOP;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.ActivityManager;\nimport android.app.ActivityOptions;\nimport android.app.WindowConfiguration;\nimport android.content.ActivityNotFoundException;\nimport android.content.Intent;\nimport android.content.pm.ActivityInfo;\nimport android.content.res.Configuration;\nimport android.graphics.Point;\nimport android.graphics.Rect;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Parcel;\nimport android.os.RemoteException;\nimport android.util.AndroidRuntimeException;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.Slog;\nimport android.view.RemoteAnimationAdapter;\nimport android.view.SurfaceControl;\nimport android.view.WindowManager;\nimport android.window.IDisplayAreaOrganizerController;\nimport android.window.ITaskFragmentOrganizer;\nimport android.window.ITaskFragmentOrganizerController;\nimport android.window.ITaskOrganizerController;\nimport android.window.ITransitionMetricsReporter;\nimport android.window.ITransitionPlayer;\nimport android.window.IWindowContainerTransactionCallback;\nimport android.window.IWindowOrganizerController;\nimport android.window.TaskFragmentAnimationParams;\nimport android.window.TaskFragmentCreationParams;\nimport android.window.TaskFragmentOperation;\nimport android.window.WindowContainerToken;\nimport android.window.WindowContainerTransaction;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.protolog.ProtoLogGroup;\nimport com.android.internal.protolog.common.ProtoLog;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.server.LocalServices;\nimport com.android.server.pm.LauncherAppsService.LauncherAppsServiceInternal;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.IntSupplier;\n\n/**\n * Server side implementation for the interface for organizing windows\n * @see android.window.WindowOrganizer\n */\nclass WindowOrganizerController extends IWindowOrganizerController.Stub\n        implements BLASTSyncEngine.TransactionReadyListener {\n\n    private static final String TAG = \"WindowOrganizerController\";\n\n    private static final int TRANSACT_EFFECTS_NONE = 0;\n    /** Flag indicating that an applied transaction may have effected lifecycle */\n    private static final int TRANSACT_EFFECTS_CLIENT_CONFIG = 1;\n    private static final int TRANSACT_EFFECTS_LIFECYCLE = 1 << 1;\n\n    /**\n     * Masks specifying which configurations task-organizers can control. Incoming transactions\n     * will be filtered to only include these.\n     */\n    static final int CONTROLLABLE_CONFIGS = ActivityInfo.CONFIG_WINDOW_CONFIGURATION\n            | ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE | ActivityInfo.CONFIG_SCREEN_SIZE\n            | ActivityInfo.CONFIG_LAYOUT_DIRECTION | ActivityInfo.CONFIG_DENSITY;\n    static final int CONTROLLABLE_WINDOW_CONFIGS = WINDOW_CONFIG_BOUNDS\n            | WindowConfiguration.WINDOW_CONFIG_APP_BOUNDS;\n\n    private final ActivityTaskManagerService mService;\n    private final WindowManagerGlobalLock mGlobalLock;\n\n    private final HashMap<Integer, IWindowContainerTransactionCallback>\n            mTransactionCallbacksByPendingSyncId = new HashMap();\n\n    final TaskOrganizerController mTaskOrganizerController;\n    final DisplayAreaOrganizerController mDisplayAreaOrganizerController;\n    final TaskFragmentOrganizerController mTaskFragmentOrganizerController;\n\n    final TransitionController mTransitionController;\n\n    /**\n     * A Map which manages the relationship between\n     * {@link TaskFragmentCreationParams#getFragmentToken()} and {@link TaskFragment}\n     */\n    @VisibleForTesting\n    final ArrayMap<IBinder, TaskFragment> mLaunchTaskFragments = new ArrayMap<>();\n\n    private final Rect mTmpBounds0 = new Rect();\n    private final Rect mTmpBounds1 = new Rect();\n\n    WindowOrganizerController(ActivityTaskManagerService atm) {\n        mService = atm;\n        mGlobalLock = atm.mGlobalLock;\n        mTaskOrganizerController = new TaskOrganizerController(mService);\n        mDisplayAreaOrganizerController = new DisplayAreaOrganizerController(mService);\n        mTaskFragmentOrganizerController = new TaskFragmentOrganizerController(atm, this);\n        mTransitionController = new TransitionController(atm);\n    }\n\n    TransitionController getTransitionController() {\n        return mTransitionController;\n    }\n\n    @Override\n    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)\n            throws RemoteException {\n        try {\n            return super.onTransact(code, data, reply, flags);\n        } catch (RuntimeException e) {\n            throw ActivityTaskManagerService.logAndRethrowRuntimeExceptionOnTransact(TAG, e);\n        }\n    }\n\n    @Override\n    public void applyTransaction(WindowContainerTransaction t) {\n        if (t == null) {\n            throw new IllegalArgumentException(\"Null transaction passed to applyTransaction\");\n        }\n        enforceTaskPermission(\"applyTransaction()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                applyTransaction(t, -1 /*syncId*/, null /*transition*/, caller);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public int applySyncTransaction(WindowContainerTransaction t,\n            IWindowContainerTransactionCallback callback) {\n        if (t == null) {\n            throw new IllegalArgumentException(\"Null transaction passed to applySyncTransaction\");\n        }\n        enforceTaskPermission(\"applySyncTransaction()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                if (callback == null) {\n                    applyTransaction(t, -1 /* syncId*/, null /*transition*/, caller);\n                    return -1;\n                }\n\n                /**\n                 * If callback is non-null we are looking to synchronize this transaction by\n                 * collecting all the results in to a SurfaceFlinger transaction and then delivering\n                 * that to the given transaction ready callback. See {@link BLASTSyncEngine} for the\n                 * details of the operation. But at a high level we create a sync operation with a\n                 * given ID and an associated callback. Then we notify each WindowContainer in this\n                 * WindowContainer transaction that it is participating in a sync operation with\n                 * that ID. Once everything is notified we tell the BLASTSyncEngine \"setSyncReady\"\n                 * which means that we have added everything to the set. At any point after this,\n                 * all the WindowContainers will eventually finish applying their changes and notify\n                 * the BLASTSyncEngine which will deliver the Transaction to the callback.\n                 */\n                final BLASTSyncEngine.SyncGroup syncGroup = prepareSyncWithOrganizer(callback);\n                final int syncId = syncGroup.mSyncId;\n                if (mTransitionController.isShellTransitionsEnabled()) {\n                    mTransitionController.startLegacySyncOrQueue(syncGroup, (deferred) -> {\n                        applyTransaction(t, syncId, null /* transition */, caller, deferred);\n                        setSyncReady(syncId);\n                    });\n                } else {\n                    if (!mService.mWindowManager.mSyncEngine.hasActiveSync()) {\n                        mService.mWindowManager.mSyncEngine.startSyncSet(syncGroup);\n                        applyTransaction(t, syncId, null /*transition*/, caller);\n                        setSyncReady(syncId);\n                    } else {\n                        // Because the BLAST engine only supports one sync at a time, queue the\n                        // transaction.\n                        mService.mWindowManager.mSyncEngine.queueSyncSet(\n                                () -> mService.mWindowManager.mSyncEngine.startSyncSet(syncGroup),\n                                () -> {\n                                    applyTransaction(t, syncId, null /*transition*/, caller);\n                                    setSyncReady(syncId);\n                                });\n                    }\n                }\n                return syncId;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public IBinder startNewTransition(int type, @Nullable WindowContainerTransaction t) {\n        return startTransition(type, null /* transitionToken */, t);\n    }\n\n    @Override\n    public void startTransition(@NonNull IBinder transitionToken,\n            @Nullable WindowContainerTransaction t) {\n        startTransition(-1 /* unused type */, transitionToken, t);\n    }\n\n    private IBinder startTransition(@WindowManager.TransitionType int type,\n            @Nullable IBinder transitionToken, @Nullable WindowContainerTransaction t) {\n        enforceTaskPermission(\"startTransition()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                Transition transition = Transition.fromBinder(transitionToken);\n                if (mTransitionController.getTransitionPlayer() == null && transition == null) {\n                    Slog.w(TAG, \"Using shell transitions API for legacy transitions.\");\n                    if (t == null) {\n                        throw new IllegalArgumentException(\"Can't use legacy transitions in\"\n                                + \" compatibility mode with no WCT.\");\n                    }\n                    applyTransaction(t, -1 /* syncId */, null, caller);\n                    return null;\n                }\n                final WindowContainerTransaction wct =\n                        t != null ? t : new WindowContainerTransaction();\n                if (transition == null) {\n                    if (type < 0) {\n                        throw new IllegalArgumentException(\"Can't create transition with no type\");\n                    }\n                    // This is a direct call from shell, so the entire transition lifecycle is\n                    // contained in the provided transaction if provided. Thus, we can setReady\n                    // immediately after apply.\n                    final boolean needsSetReady = t != null;\n                    final Transition nextTransition = new Transition(type, 0 /* flags */,\n                            mTransitionController, mService.mWindowManager.mSyncEngine);\n                    nextTransition.calcParallelCollectType(wct);\n                    mTransitionController.startCollectOrQueue(nextTransition,\n                            (deferred) -> {\n                                nextTransition.start();\n                                nextTransition.mLogger.mStartWCT = wct;\n                                applyTransaction(wct, -1 /* syncId */, nextTransition, caller,\n                                        deferred);\n                                if (needsSetReady) {\n                                    nextTransition.setAllReady();\n                                }\n                            });\n                    return nextTransition.getToken();\n                }\n                // The transition already started collecting before sending a request to shell,\n                // so just start here.\n                if (!transition.isCollecting() && !transition.isForcePlaying()) {\n                    Slog.e(TAG, \"Trying to start a transition that isn't collecting. This probably\"\n                            + \" means Shell took too long to respond to a request. WM State may be\"\n                            + \" incorrect now, please file a bug\");\n                    applyTransaction(wct, -1 /*syncId*/, null /*transition*/, caller);\n                    return transition.getToken();\n                }\n                transition.start();\n                transition.mLogger.mStartWCT = wct;\n                applyTransaction(wct, -1 /*syncId*/, transition, caller);\n                // Since the transition is already provided, it means WMCore is determining the\n                // \"readiness lifecycle\" outside the provided transaction, so don't set ready here.\n                return transition.getToken();\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public int startLegacyTransition(int type, @NonNull RemoteAnimationAdapter adapter,\n            @NonNull IWindowContainerTransactionCallback callback,\n            @NonNull WindowContainerTransaction t) {\n        enforceTaskPermission(\"startLegacyTransition()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        int syncId;\n        try {\n            synchronized (mGlobalLock) {\n                if (type < 0) {\n                    throw new IllegalArgumentException(\"Can't create transition with no type\");\n                }\n                if (mTransitionController.getTransitionPlayer() != null) {\n                    throw new IllegalArgumentException(\"Can't use legacy transitions in\"\n                            + \" when shell transitions are enabled.\");\n                }\n                final DisplayContent dc =\n                        mService.mRootWindowContainer.getDisplayContent(DEFAULT_DISPLAY);\n                if (dc.mAppTransition.isTransitionSet()) {\n                    // a transition already exists, so the callback probably won't be called.\n                    return -1;\n                }\n                adapter.setCallingPidUid(caller.mPid, caller.mUid);\n                dc.prepareAppTransition(type);\n                dc.mAppTransition.overridePendingAppTransitionRemote(adapter, true /* sync */,\n                        false /* isActivityEmbedding */);\n                syncId = startSyncWithOrganizer(callback);\n                applyTransaction(t, syncId, null /* transition */, caller);\n                setSyncReady(syncId);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n        return syncId;\n    }\n\n    @Override\n    public int finishTransition(@NonNull IBinder transitionToken,\n            @Nullable WindowContainerTransaction t,\n            @Nullable IWindowContainerTransactionCallback callback) {\n        enforceTaskPermission(\"finishTransition()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                int syncId = -1;\n                if (t != null && callback != null) {\n                    syncId = startSyncWithOrganizer(callback);\n                }\n                final Transition transition = Transition.fromBinder(transitionToken);\n                // apply the incoming transaction before finish in case it alters the visibility\n                // of the participants.\n                if (t != null) {\n                    // Set the finishing transition before applyTransaction so the visibility\n                    // changes of the transition participants will only set visible-requested\n                    // and still let finishTransition handle the participants.\n                    mTransitionController.mFinishingTransition = transition;\n                    applyTransaction(t, syncId, null /*transition*/, caller, transition);\n                }\n                mTransitionController.finishTransition(transition);\n                mTransitionController.mFinishingTransition = null;\n                if (syncId >= 0) {\n                    setSyncReady(syncId);\n                }\n                return syncId;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    /**\n     * Applies the {@link WindowContainerTransaction} as a request from\n     * {@link android.window.TaskFragmentOrganizer}.\n     *\n     * @param wct   {@link WindowContainerTransaction} to apply.\n     * @param type  {@link WindowManager.TransitionType} if it needs to start a new transition.\n     * @param shouldApplyIndependently  If {@code true}, the {@code wct} will request a new\n     *                                  transition, which will be queued until the sync engine is\n     *                                  free if there is any other active sync. If {@code false},\n     *                                  the {@code wct} will be directly applied to the active sync.\n     */\n    void applyTaskFragmentTransactionLocked(@NonNull WindowContainerTransaction wct,\n            @WindowManager.TransitionType int type, boolean shouldApplyIndependently) {\n        enforceTaskFragmentOrganizerPermission(\"applyTaskFragmentTransaction()\",\n                Objects.requireNonNull(wct.getTaskFragmentOrganizer()),\n                Objects.requireNonNull(wct));\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            if (mTransitionController.getTransitionPlayer() == null) {\n                // No need to worry about transition when Shell transition is not enabled.\n                applyTransaction(wct, -1 /* syncId */, null /* transition */, caller);\n                return;\n            }\n\n            if (mService.mWindowManager.mSyncEngine.hasActiveSync()\n                    && !shouldApplyIndependently) {\n                // Although there is an active sync, we want to apply the transaction now.\n                // TODO(b/232042367) Redesign the organizer update on activity callback so that we\n                // we will know about the transition explicitly.\n                final Transition transition = mTransitionController.getCollectingTransition();\n                if (transition == null) {\n                    // This should rarely happen, and we should try to avoid using\n                    // {@link #applySyncTransaction} with Shell transition.\n                    // We still want to apply and merge the transaction to the active sync\n                    // because {@code shouldApplyIndependently} is {@code false}.\n                    ProtoLog.w(ProtoLogGroup.WM_DEBUG_WINDOW_TRANSITIONS,\n                            \"TaskFragmentTransaction changes are not collected in transition\"\n                                    + \" because there is an ongoing sync for\"\n                                    + \" applySyncTransaction().\");\n                }\n                applyTransaction(wct, -1 /* syncId */, transition, caller);\n                return;\n            }\n\n            final Transition transition = new Transition(type, 0 /* flags */,\n                    mTransitionController, mService.mWindowManager.mSyncEngine);\n            TransitionController.OnStartCollect doApply = (deferred) -> {\n                if (deferred && !mTaskFragmentOrganizerController.isValidTransaction(wct)) {\n                    transition.abort();\n                    return;\n                }\n                if (applyTransaction(wct, -1 /* syncId */, transition, caller, deferred)\n                        == TRANSACT_EFFECTS_NONE && transition.mParticipants.isEmpty()) {\n                    transition.abort();\n                    return;\n                }\n                mTransitionController.requestStartTransition(transition, null /* startTask */,\n                        null /* remoteTransition */, null /* displayChange */);\n                transition.setAllReady();\n            };\n            mTransitionController.startCollectOrQueue(transition, doApply);\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    private int applyTransaction(@NonNull WindowContainerTransaction t, int syncId,\n            @Nullable Transition transition, @NonNull CallerInfo caller) {\n        return applyTransaction(t, syncId, transition, caller, null /* finishTransition */);\n    }\n\n    private int applyTransaction(@NonNull WindowContainerTransaction t, int syncId,\n            @Nullable Transition transition, @NonNull CallerInfo caller, boolean deferred) {\n        if (deferred) {\n            try {\n                return applyTransaction(t, syncId, transition, caller);\n            } catch (RuntimeException e) {\n                // If the transaction is deferred, the caller could be from TransitionController\n                // #tryStartCollectFromQueue that executes on system's worker thread rather than\n                // binder thread. And the operation in the WCT may be outdated that violates the\n                // current state. So catch the exception to avoid crashing the system.\n                Slog.e(TAG, \"Failed to execute deferred applyTransaction\", e);\n            }\n            return TRANSACT_EFFECTS_NONE;\n        }\n        return applyTransaction(t, syncId, transition, caller);\n    }\n\n    /**\n     * @param syncId If non-null, this will be a sync-transaction.\n     * @param transition A transition to collect changes into.\n     * @param caller Info about the calling process.\n     * @param finishTransition The transition that is currently being finished.\n     * @return The effects of the window container transaction.\n     */\n    private int applyTransaction(@NonNull WindowContainerTransaction t, int syncId,\n            @Nullable Transition transition, @NonNull CallerInfo caller,\n            @Nullable Transition finishTransition) {\n        int effects = TRANSACT_EFFECTS_NONE;\n        ProtoLog.v(WM_DEBUG_WINDOW_ORGANIZER, \"Apply window transaction, syncId=%d\", syncId);\n        mService.deferWindowLayout();\n        mService.mTaskSupervisor.setDeferRootVisibilityUpdate(true /* deferUpdate */);\n        try {\n            if (transition != null) {\n                transition.applyDisplayChangeIfNeeded();\n            }\n            final List<WindowContainerTransaction.HierarchyOp> hops = t.getHierarchyOps();\n            final int hopSize = hops.size();\n            final ArraySet<WindowContainer<?>> haveConfigChanges = new ArraySet<>();\n            Iterator<Map.Entry<IBinder, WindowContainerTransaction.Change>> entries =\n                    t.getChanges().entrySet().iterator();\n            while (entries.hasNext()) {\n                final Map.Entry<IBinder, WindowContainerTransaction.Change> entry = entries.next();\n                final WindowContainer wc = WindowContainer.fromBinder(entry.getKey());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on detached container: \" + wc);\n                    continue;\n                }\n                // Make sure we add to the syncSet before performing\n                 //operations so we don't end up splitting effects between the WM\n                 //pending transaction and the BLASTSync transaction.\n                if (syncId >= 0) {\n                    addToSyncSet(syncId, wc);\n                }\n                if (transition != null) transition.collect(wc);\n\n                if ((entry.getValue().getChangeMask()\n                         & WindowContainerTransaction.Change.CHANGE_FORCE_NO_PIP) != 0) {\n                    // Disable entering pip (eg. when recents pretends to finish itself)\n                    if (finishTransition != null) {\n                        finishTransition.setCanPipOnFinish(false /* canPipOnFinish */);\n                    } else if (transition != null) {\n                        transition.setCanPipOnFinish(false /* canPipOnFinish */);\n                    }\n                }\n                // A bit hacky, but we need to detect \"remove PiP\" so that we can \"wrap\" the\n                // setWindowingMode call in force-hidden.\n                boolean forceHiddenForPip = false;\n                if (wc.asTask() != null && wc.inPinnedWindowingMode()\n                        && entry.getValue().getWindowingMode() == WINDOWING_MODE_UNDEFINED) {\n                    // We are in pip and going to undefined. Now search hierarchy ops to determine\n                    // whether we are removing pip or expanding pip.\n                    for (int i = 0; i < hopSize; ++i) {\n                        final WindowContainerTransaction.HierarchyOp hop = hops.get(i);\n                        if (hop.getType() != HIERARCHY_OP_TYPE_REORDER) continue;\n                        final WindowContainer hopWc = WindowContainer.fromBinder(\n                                hop.getContainer());\n                        if (!wc.equals(hopWc)) continue;\n                        forceHiddenForPip = !hop.getToTop();\n                    }\n                }\n                if (forceHiddenForPip) {\n                    wc.asTask().setForceHidden(FLAG_FORCE_HIDDEN_FOR_PINNED_TASK, true /* set */);\n                    // When removing pip, make sure that onStop is sent to the app ahead of\n                    // onPictureInPictureModeChanged.\n                    // See also PinnedStackTests#testStopBeforeMultiWindowCallbacksOnDismiss\n                    wc.asTask().ensureActivitiesVisible(null, 0, PRESERVE_WINDOWS);\n                    wc.asTask().mTaskSupervisor.processStoppingAndFinishingActivities(\n                            null /* launchedActivity */, false /* processPausingActivities */,\n                            \"force-stop-on-removing-pip\");\n                }\n\n                int containerEffect = applyWindowContainerChange(wc, entry.getValue(),\n                        t.getErrorCallbackToken());\n                effects |= containerEffect;\n\n                if (forceHiddenForPip) {\n                    wc.asTask().setForceHidden(FLAG_FORCE_HIDDEN_FOR_PINNED_TASK, false /* set */);\n                }\n\n                // Lifecycle changes will trigger ensureConfig for everything.\n                if ((effects & TRANSACT_EFFECTS_LIFECYCLE) == 0\n                        && (containerEffect & TRANSACT_EFFECTS_CLIENT_CONFIG) != 0) {\n                    haveConfigChanges.add(wc);\n                }\n            }\n            // Hierarchy changes\n            if (hopSize > 0) {\n                final boolean isInLockTaskMode = mService.isInLockTaskMode();\n                for (int i = 0; i < hopSize; ++i) {\n                    effects |= applyHierarchyOp(hops.get(i), effects, syncId, transition,\n                            isInLockTaskMode, caller, t.getErrorCallbackToken(),\n                            t.getTaskFragmentOrganizer(), finishTransition);\n                }\n            }\n            // Queue-up bounds-change transactions for tasks which are now organized. Do\n            // this after hierarchy ops so we have the final organized state.\n            entries = t.getChanges().entrySet().iterator();\n            while (entries.hasNext()) {\n                final Map.Entry<IBinder, WindowContainerTransaction.Change> entry = entries.next();\n                final WindowContainer wc = WindowContainer.fromBinder(entry.getKey());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on detached container: \" + wc);\n                    continue;\n                }\n                final Task task = wc.asTask();\n                final Rect surfaceBounds = entry.getValue().getBoundsChangeSurfaceBounds();\n                if (task == null || !task.isAttached() || surfaceBounds == null) {\n                    continue;\n                }\n                if (!task.isOrganized()) {\n                    final Task parent = task.getParent() != null ? task.getParent().asTask() : null;\n                    // Also allow direct children of created-by-organizer tasks to be\n                    // controlled. In the future, these will become organized anyways.\n                    if (parent == null || !parent.mCreatedByOrganizer) {\n                        throw new IllegalArgumentException(\n                                \"Can't manipulate non-organized task surface \" + task);\n                    }\n                }\n                final SurfaceControl.Transaction sft = new SurfaceControl.Transaction();\n                final SurfaceControl sc = task.getSurfaceControl();\n                sft.setPosition(sc, surfaceBounds.left, surfaceBounds.top);\n                if (surfaceBounds.isEmpty()) {\n                    sft.setWindowCrop(sc, null);\n                } else {\n                    sft.setWindowCrop(sc, surfaceBounds.width(), surfaceBounds.height());\n                }\n                task.setMainWindowSizeChangeTransaction(sft);\n            }\n            if ((effects & TRANSACT_EFFECTS_LIFECYCLE) != 0) {\n                mService.mTaskSupervisor.setDeferRootVisibilityUpdate(false /* deferUpdate */);\n                // Already calls ensureActivityConfig\n                mService.mRootWindowContainer.ensureActivitiesVisible(null, 0, PRESERVE_WINDOWS);\n                mService.mRootWindowContainer.resumeFocusedTasksTopActivities();\n            } else if ((effects & TRANSACT_EFFECTS_CLIENT_CONFIG) != 0) {\n                for (int i = haveConfigChanges.size() - 1; i >= 0; --i) {\n                    haveConfigChanges.valueAt(i).forAllActivities(r -> {\n                        r.ensureActivityConfiguration(0, PRESERVE_WINDOWS);\n                    });\n                }\n            }\n\n            if (effects != 0) {\n                mService.mWindowManager.mWindowPlacerLocked.requestTraversal();\n            }\n        } finally {\n            mService.mTaskSupervisor.setDeferRootVisibilityUpdate(false /* deferUpdate */);\n            mService.continueWindowLayout();\n        }\n        return effects;\n    }\n\n    private int applyChanges(@NonNull WindowContainer<?> container,\n            @NonNull WindowContainerTransaction.Change change) {\n        // The \"client\"-facing API should prevent bad changes; however, just in case, sanitize\n        // masks here.\n        final int configMask = change.getConfigSetMask() & CONTROLLABLE_CONFIGS;\n        final int windowMask = change.getWindowSetMask() & CONTROLLABLE_WINDOW_CONFIGS;\n        int effects = TRANSACT_EFFECTS_NONE;\n        final int windowingMode = change.getWindowingMode();\n        if (configMask != 0) {\n            if (windowingMode > -1 && windowingMode != container.getWindowingMode()) {\n                // Special handling for when we are setting a windowingMode in the same transaction.\n                // Setting the windowingMode is going to call onConfigurationChanged so we don't\n                // need it called right now. Additionally, some logic requires everything in the\n                // configuration to change at the same time (ie. surface-freezer requires bounds\n                // and mode to change at the same time).\n                final Configuration c = container.getRequestedOverrideConfiguration();\n                c.setTo(change.getConfiguration(), configMask, windowMask);\n            } else {\n                final Configuration c =\n                        new Configuration(container.getRequestedOverrideConfiguration());\n                c.setTo(change.getConfiguration(), configMask, windowMask);\n                container.onRequestedOverrideConfigurationChanged(c);\n            }\n            effects |= TRANSACT_EFFECTS_CLIENT_CONFIG;\n            if (windowMask != 0 && container.isEmbedded()) {\n                // Changing bounds of the embedded TaskFragments may result in lifecycle changes.\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n        if ((change.getChangeMask() & WindowContainerTransaction.Change.CHANGE_FOCUSABLE) != 0) {\n            if (container.setFocusable(change.getFocusable())) {\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n\n        if (windowingMode > -1) {\n            if (mService.isInLockTaskMode()\n                    && WindowConfiguration.inMultiWindowMode(windowingMode)) {\n                Slog.w(TAG, \"Dropping unsupported request to set multi-window windowing mode\"\n                        + \" during locked task mode.\");\n                return effects;\n            }\n\n            if (windowingMode == WindowConfiguration.WINDOWING_MODE_PINNED) {\n                // Do not directly put the container into PINNED mode as it may not support it or\n                // the app may not want to enter",
        "metrics": {},
        "metrics_status": "Metrics not computed: 'downstream_file_content_ground_truth' is missing."
    },
    {
        "cve_id": "ASB-A-364026473",
        "downstream_version": "14",
        "file_name": "system/stack/gatt/gatt_sr.cc",
        "ground_truth_codebase": "",
        "llm_patched_codebase": "/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_tcid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND",
        "metrics": {},
        "metrics_status": "Metrics not computed: 'downstream_file_content_ground_truth' is missing."
    },
    {
        "cve_id": "ASB-A-364027038",
        "downstream_version": "14",
        "file_name": "system/stack/gatt/gatt_sr.cc",
        "ground_truth_codebase": "",
        "llm_patched_codebase": "/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND",
        "metrics": {},
        "metrics_status": "Metrics not computed: 'downstream_file_content_ground_truth' is missing."
    },
    {
        "cve_id": "ASB-A-352542820",
        "downstream_version": "14",
        "file_name": "src/com/android/settings/users/UserSettings.java",
        "ground_truth_codebase": "",
        "llm_patched_codebase": "/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.users;\n\nimport static com.android.settingslib.Utils.getColorAttrDefaultColor;\n\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.Dialog;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.settings.SettingsEnums;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.BlendMode;\nimport android.graphics.drawable.Drawable;\nimport android.graphics.drawable.LayerDrawable;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.ContactsContract;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.SparseArray;\nimport android.view.Gravity;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.WindowManagerGlobal;\nimport android.widget.SimpleAdapter;\nimport android.widget.Toast;\n\nimport androidx.annotation.VisibleForTesting;\nimport androidx.annotation.WorkerThread;\nimport androidx.appcompat.app.AlertDialog;\nimport androidx.preference.Preference;\nimport androidx.preference.PreferenceGroup;\nimport androidx.preference.PreferenceScreen;\n\nimport com.android.internal.util.UserIcons;\nimport com.android.internal.widget.LockPatternUtils;\nimport com.android.settings.R;\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsPreferenceFragment;\nimport com.android.settings.Utils;\nimport com.android.settings.core.SubSettingLauncher;\nimport com.android.settings.password.ChooseLockGeneric;\nimport com.android.settings.search.BaseSearchIndexProvider;\nimport com.android.settings.widget.MainSwitchBarController;\nimport com.android.settings.widget.SettingsMainSwitchBar;\nimport com.android.settingslib.RestrictedLockUtils.EnforcedAdmin;\nimport com.android.settingslib.RestrictedLockUtilsInternal;\nimport com.android.settingslib.RestrictedPreference;\nimport com.android.settingslib.drawable.CircleFramedDrawable;\nimport com.android.settingslib.search.SearchIndexable;\nimport com.android.settingslib.search.SearchIndexableRaw;\nimport com.android.settingslib.users.CreateUserDialogController;\nimport com.android.settingslib.users.EditUserInfoController;\nimport com.android.settingslib.users.GrantAdminDialogController;\nimport com.android.settingslib.users.UserCreatingDialog;\nimport com.android.settingslib.utils.ThreadUtils;\n\nimport com.google.android.setupcompat.util.WizardManagerHelper;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.stream.Collectors;\n\n/**\n * Screen that manages the list of users on the device.\n * Secondary users and a guest user can be created if there is no restriction.\n *\n * The first user in the list is always the current user.\n * Owner is the primary user.\n */\n@SearchIndexable\npublic class UserSettings extends SettingsPreferenceFragment\n        implements Preference.OnPreferenceClickListener,\n        MultiUserSwitchBarController.OnMultiUserSwitchChangedListener,\n        DialogInterface.OnDismissListener {\n\n    private static final String TAG = \"UserSettings\";\n\n    /** UserId of the user being removed */\n    private static final String SAVE_REMOVING_USER = \"removing_user\";\n    private static final String SAVE_CREATE_USER = \"create_user\";\n\n    private static final String KEY_USER_LIST = \"user_list\";\n    private static final String KEY_USER_ME = \"user_me\";\n    private static final String KEY_USER_GUEST = \"user_guest\";\n    private static final String KEY_ADD_GUEST = \"guest_add\";\n    private static final String KEY_ADD_USER = \"user_add\";\n    private static final String KEY_ADD_SUPERVISED_USER = \"supervised_user_add\";\n    private static final String KEY_ADD_USER_WHEN_LOCKED = \"user_settings_add_users_when_locked\";\n    private static final String KEY_ENABLE_GUEST_TELEPHONY = \"enable_guest_calling\";\n    private static final String KEY_MULTIUSER_TOP_INTRO = \"multiuser_top_intro\";\n    private static final String KEY_TIMEOUT_TO_DOCK_USER = \"timeout_to_dock_user_preference\";\n    private static final String KEY_GUEST_CATEGORY = \"guest_category\";\n    private static final String KEY_GUEST_RESET = \"guest_reset\";\n    private static final String KEY_GUEST_EXIT = \"guest_exit\";\n    private static final String KEY_REMOVE_GUEST_ON_EXIT = \"remove_guest_on_exit\";\n    private static final String KEY_GUEST_USER_CATEGORY = \"guest_user_category\";\n    private static final String KEY_ALLOW_MULTIPLE_USERS = \"allow_multiple_users\";\n\n    private static final String SETTING_GUEST_HAS_LOGGED_IN = \"systemui.guest_has_logged_in\";\n\n    private static final int MENU_REMOVE_USER = Menu.FIRST;\n\n    private static final IntentFilter USER_REMOVED_INTENT_FILTER;\n\n    private static final int DIALOG_CONFIRM_REMOVE = 1;\n    private static final int DIALOG_ADD_USER = 2;\n    // Dialogs with id 3 and 4 got removed\n    private static final int DIALOG_USER_CANNOT_MANAGE = 5;\n    private static final int DIALOG_CHOOSE_USER_TYPE = 6;\n    private static final int DIALOG_NEED_LOCKSCREEN = 7;\n    private static final int DIALOG_CONFIRM_REMOVE_GUEST = 8;\n    private static final int DIALOG_USER_PROFILE_EDITOR = 9;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_USER = 10;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE = 11;\n    private static final int DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE = 12;\n    private static final int DIALOG_CONFIRM_RESET_AND_RESTART_GUEST = 13;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL = 14;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL = 15;\n    private static final int DIALOG_GRANT_ADMIN = 16;\n\n    private static final int MESSAGE_UPDATE_LIST = 1;\n    private static final int MESSAGE_USER_CREATED = 2;\n    static final int MESSAGE_REMOVE_GUEST_ON_EXIT_CONTROLLER_GUEST_REMOVED = 3;\n\n    private static final int USER_TYPE_USER = 1;\n    private static final int USER_TYPE_RESTRICTED_PROFILE = 2;\n\n    private static final int REQUEST_CHOOSE_LOCK = 10;\n    private static final int REQUEST_EDIT_GUEST = 11;\n\n    static final int RESULT_GUEST_REMOVED = 100;\n\n    private static final String KEY_TITLE = \"title\";\n    private static final String KEY_SUMMARY = \"summary\";\n\n    private static final String EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR =\n            \"EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR\";\n\n    static {\n        USER_REMOVED_INTENT_FILTER = new IntentFilter(Intent.ACTION_USER_REMOVED);\n        USER_REMOVED_INTENT_FILTER.addAction(Intent.ACTION_USER_INFO_CHANGED);\n    }\n\n    @VisibleForTesting\n    PreferenceGroup mUserListCategory;\n    @VisibleForTesting\n    PreferenceGroup mGuestUserCategory;\n    @VisibleForTesting\n    PreferenceGroup mGuestCategory;\n    @VisibleForTesting\n    Preference mGuestResetPreference;\n    @VisibleForTesting\n    Preference mGuestExitPreference;\n    @VisibleForTesting\n    UserPreference mMePreference;\n    @VisibleForTesting\n    RestrictedPreference mAddGuest;\n    @VisibleForTesting\n    RestrictedPreference mAddUser;\n    @VisibleForTesting\n    RestrictedPreference mAddSupervisedUser;\n    @VisibleForTesting\n    SparseArray<Bitmap> mUserIcons = new SparseArray<>();\n    private int mRemovingUserId = -1;\n    private boolean mAddingUser;\n    private boolean mGuestUserAutoCreated;\n    private String mConfigSupervisedUserCreationPackage;\n    private String mAddingUserName;\n    private UserCapabilities mUserCaps;\n    private boolean mShouldUpdateUserList = true;\n    private final Object mUserLock = new Object();\n    private UserManager mUserManager;\n    private static SparseArray<Bitmap> sDarkDefaultUserBitmapCache = new SparseArray<>();\n\n    private MultiUserSwitchBarController mSwitchBarController;\n\n    private GrantAdminDialogController mGrantAdminDialogController =\n            new GrantAdminDialogController();\n    private EditUserInfoController mEditUserInfoController =\n            new EditUserInfoController(Utils.FILE_PROVIDER_AUTHORITY);\n    private CreateUserDialogController mCreateUserDialogController =\n            new CreateUserDialogController(Utils.FILE_PROVIDER_AUTHORITY);\n    private AddUserWhenLockedPreferenceController mAddUserWhenLockedPreferenceController;\n    private GuestTelephonyPreferenceController mGuestTelephonyPreferenceController;\n    private RemoveGuestOnExitPreferenceController mRemoveGuestOnExitPreferenceController;\n    private MultiUserTopIntroPreferenceController mMultiUserTopIntroPreferenceController;\n    private TimeoutToDockUserPreferenceController mTimeoutToDockUserPreferenceController;\n    private UserCreatingDialog mUserCreatingDialog;\n    private final AtomicBoolean mGuestCreationScheduled = new AtomicBoolean();\n    private final ExecutorService mExecutor = Executors.newSingleThreadExecutor();\n\n    private CharSequence mPendingUserName;\n    private Drawable mPendingUserIcon;\n    private boolean mPendingUserIsAdmin;\n\n    // A place to cache the generated default avatar\n    private Drawable mDefaultIconDrawable;\n\n    // TODO:   Replace current Handler solution to something that doesn't leak memory and works\n    // TODO:   during a configuration change\n    private Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MESSAGE_UPDATE_LIST:\n                    updateUserList();\n                    break;\n                case MESSAGE_REMOVE_GUEST_ON_EXIT_CONTROLLER_GUEST_REMOVED:\n                    updateUserList();\n                    if (mGuestUserAutoCreated) {\n                        scheduleGuestCreation();\n                    }\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mUserChangeReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(Intent.ACTION_USER_REMOVED)) {\n                mRemovingUserId = -1;\n            } else if (intent.getAction().equals(Intent.ACTION_USER_INFO_CHANGED)) {\n                int userHandle = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);\n                if (userHandle != -1) {\n                    mUserIcons.remove(userHandle);\n                }\n            }\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n        }\n    };\n\n    @Override\n    public int getMetricsCategory() {\n        return SettingsEnums.USER;\n    }\n\n    @Override\n    public void onActivityCreated(Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n        // Assume we are in a SettingsActivity. This is only safe because we currently use\n        // SettingsActivity as base for all preference fragments.\n        final SettingsActivity activity = (SettingsActivity) getActivity();\n        final SettingsMainSwitchBar switchBar = activity.getSwitchBar();\n        switchBar.setTitle(getContext().getString(R.string.multiple_users_main_switch_title));\n        if (isCurrentUserAdmin()) {\n            switchBar.show();\n        } else {\n            switchBar.hide();\n        }\n        mSwitchBarController = new MultiUserSwitchBarController(activity,\n                new MainSwitchBarController(switchBar), this /* listener */);\n        getSettingsLifecycle().addObserver(mSwitchBarController);\n        boolean openUserEditDialog = getIntent().getBooleanExtra(\n                EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR, false);\n        if (switchBar.isChecked() && openUserEditDialog) {\n            showDialog(DIALOG_USER_PROFILE_EDITOR);\n        }\n    }\n\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        addPreferencesFromResource(R.xml.user_settings);\n        final Activity activity = getActivity();\n        if (!WizardManagerHelper.isDeviceProvisioned(activity)) {\n            activity.finish();\n            return;\n        }\n\n        mGuestUserAutoCreated = getPrefContext().getResources().getBoolean(\n                com.android.internal.R.bool.config_guestUserAutoCreated);\n\n        mAddUserWhenLockedPreferenceController = new AddUserWhenLockedPreferenceController(\n                activity, KEY_ADD_USER_WHEN_LOCKED);\n\n        mGuestTelephonyPreferenceController = new GuestTelephonyPreferenceController(\n                activity, KEY_ENABLE_GUEST_TELEPHONY);\n\n        mRemoveGuestOnExitPreferenceController = new RemoveGuestOnExitPreferenceController(\n                activity, KEY_REMOVE_GUEST_ON_EXIT, this, mHandler);\n\n        mMultiUserTopIntroPreferenceController = new MultiUserTopIntroPreferenceController(activity,\n                KEY_MULTIUSER_TOP_INTRO);\n\n        mTimeoutToDockUserPreferenceController = new TimeoutToDockUserPreferenceController(\n                activity, KEY_TIMEOUT_TO_DOCK_USER);\n\n        final PreferenceScreen screen = getPreferenceScreen();\n        mAddUserWhenLockedPreferenceController.displayPreference(screen);\n        mGuestTelephonyPreferenceController.displayPreference(screen);\n        mRemoveGuestOnExitPreferenceController.displayPreference(screen);\n        mMultiUserTopIntroPreferenceController.displayPreference(screen);\n        mTimeoutToDockUserPreferenceController.displayPreference(screen);\n\n        screen.findPreference(mAddUserWhenLockedPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mAddUserWhenLockedPreferenceController);\n\n        screen.findPreference(mGuestTelephonyPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mGuestTelephonyPreferenceController);\n\n        screen.findPreference(mRemoveGuestOnExitPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mRemoveGuestOnExitPreferenceController);\n\n        if (icicle != null) {\n            if (icicle.containsKey(SAVE_REMOVING_USER)) {\n                mRemovingUserId = icicle.getInt(SAVE_REMOVING_USER);\n            }\n            if (icicle.containsKey(SAVE_CREATE_USER)) {\n                mCreateUserDialogController.onRestoreInstanceState(icicle);\n            } else {\n                mEditUserInfoController.onRestoreInstanceState(icicle);\n            }\n        }\n\n        mUserCaps = UserCapabilities.create(activity);\n        mUserManager = (UserManager) activity.getSystemService(Context.USER_SERVICE);\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n\n        final int myUserId = UserHandle.myUserId();\n\n        mUserListCategory = (PreferenceGroup) findPreference(KEY_USER_LIST);\n        mMePreference = new UserPreference(getPrefContext(), null /* attrs */, myUserId);\n        mMePreference.setKey(KEY_USER_ME);\n        mMePreference.setOnPreferenceClickListener(this);\n        if (isCurrentUserAdmin()) {\n            mMePreference.setSummary(R.string.user_admin);\n        }\n\n        mGuestCategory = findPreference(KEY_GUEST_CATEGORY);\n\n        mGuestResetPreference = findPreference(KEY_GUEST_RESET);\n        mGuestResetPreference.setOnPreferenceClickListener(this);\n\n        mGuestExitPreference = findPreference(KEY_GUEST_EXIT);\n        mGuestExitPreference.setOnPreferenceClickListener(this);\n\n        mGuestUserCategory = findPreference(KEY_GUEST_USER_CATEGORY);\n\n        mAddGuest = findPreference(KEY_ADD_GUEST);\n        mAddGuest.setOnPreferenceClickListener(this);\n\n        mAddUser = findPreference(KEY_ADD_USER);\n        if (!mUserCaps.mCanAddRestrictedProfile) {\n            // Label should only mention adding a \"user\", not a \"profile\"\n            mAddUser.setTitle(com.android.settingslib.R.string.user_add_user);\n        }\n        mAddUser.setOnPreferenceClickListener(this);\n\n        setConfigSupervisedUserCreationPackage();\n        mAddSupervisedUser = findPreference(KEY_ADD_SUPERVISED_USER);\n        mAddSupervisedUser.setOnPreferenceClickListener(this);\n\n        activity.registerReceiverAsUser(\n                mUserChangeReceiver, UserHandle.ALL, USER_REMOVED_INTENT_FILTER, null, mHandler,\n                Context.RECEIVER_EXPORTED_UNAUDITED);\n\n        updateUI();\n        mShouldUpdateUserList = false;\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n        final PreferenceScreen screen = getPreferenceScreen();\n\n        mAddUserWhenLockedPreferenceController.updateState(screen.findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey()));\n        mGuestTelephonyPreferenceController.updateState(screen.findPreference(\n                mGuestTelephonyPreferenceController.getPreferenceKey()));\n        mTimeoutToDockUserPreferenceController.updateState(screen.findPreference(\n                mTimeoutToDockUserPreferenceController.getPreferenceKey()));\n        mRemoveGuestOnExitPreferenceController.updateState(screen.findPreference(\n                mRemoveGuestOnExitPreferenceController.getPreferenceKey()));\n        if (mShouldUpdateUserList) {\n            updateUI();\n        }\n    }\n\n    @Override\n    public void onPause() {\n        mShouldUpdateUserList = true;\n        super.onPause();\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n\n        if (mUserCaps == null || !mUserCaps.mEnabled) {\n            return;\n        }\n\n        getActivity().unregisterReceiver(mUserChangeReceiver);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        if (mCreateUserDialogController.isActive()) {\n            outState.putBoolean(SAVE_CREATE_USER, mCreateUserDialogController.isActive());\n            mCreateUserDialogController.onSaveInstanceState(outState);\n        } else {\n            mEditUserInfoController.onSaveInstanceState(outState);\n        }\n        outState.putInt(SAVE_REMOVING_USER, mRemovingUserId);\n        super.onSaveInstanceState(outState);\n    }\n\n    @Override\n    public void startActivityForResult(Intent intent, int requestCode) {\n        mEditUserInfoController.startingActivityForResult();\n        mCreateUserDialogController.startingActivityForResult();\n        super.startActivityForResult(intent, requestCode);\n    }\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        int pos = 0;\n        if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx())\n                && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n            String nickname = mUserManager.getUserName();\n            MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                    getResources().getString(R.string.user_remove_user_menu, nickname));\n            removeThisUser.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n\n            final EnforcedAdmin disallowRemoveUserAdmin =\n                    RestrictedLockUtilsInternal.checkIfRestrictionEnforced(getContext(),\n                            UserManager.DISALLOW_REMOVE_USER, UserHandle.myUserId());\n            RestrictedLockUtilsInternal.setMenuItemAsDisabledByAdmin(getContext(), removeThisUser,\n                    disallowRemoveUserAdmin);\n        }\n        super.onCreateOptionsMenu(menu, inflater);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        final int itemId = item.getItemId();\n        if (itemId == MENU_REMOVE_USER) {\n            onRemoveUserClicked(UserHandle.myUserId());\n            return true;\n        } else {\n            return super.onOptionsItemSelected(item);\n        }\n    }\n\n    @Override\n    public void onMultiUserSwitchChanged(boolean newState) {\n        updateUI();\n    }\n\n    private void updateUI() {\n        mUserCaps.updateAddUserCapabilities(getActivity());\n        loadProfile();\n        updateUserList();\n    }\n\n    /**\n     * Loads profile information for the current user.\n     */\n    private void loadProfile() {\n        if (isCurrentUserGuest()) {\n            // No need to load profile information\n            mMePreference.setIcon(getEncircledDefaultIcon());\n            mMePreference.setTitle(mGuestUserAutoCreated\n                    ? com.android.settingslib.R.string.guest_reset_guest\n                    : com.android.settingslib.R.string.guest_exit_guest);\n            mMePreference.setSelectable(true);\n            // removing a guest will result in switching back to the admin user\n            mMePreference.setEnabled(canSwitchUserNow());\n            return;\n        }\n\n        new AsyncTask<Void, Void, String>() {\n            @Override\n            protected void onPostExecute(String result) {\n                finishLoadProfile(result);\n            }\n\n            @Override\n            protected String doInBackground(Void... values) {\n                UserInfo user = mUserManager.getUserInfo(UserHandle.myUserId());\n                if (user.iconPath == null || user.iconPath.equals(\"\")) {\n                    // Assign profile photo.\n                    copyMeProfilePhoto(getActivity(), user);\n                }\n                return user.name;\n            }\n        }.execute();\n    }\n\n    private void finishLoadProfile(String profileName) {\n        if (getActivity() == null) {\n            return;\n        }\n        mMePreference.setTitle(getString(R.string.user_you, profileName));\n        int myUserId = UserHandle.myUserId();\n        Bitmap b = mUserManager.getUserIcon(myUserId);\n        if (b != null) {\n            mMePreference.setIcon(encircleUserIcon(b));\n            mUserIcons.put(myUserId, b);\n        }\n    }\n\n    private boolean hasLockscreenSecurity() {\n        LockPatternUtils lpu = new LockPatternUtils(getActivity());\n        return lpu.isSecure(UserHandle.myUserId());\n    }\n\n    private void launchChooseLockscreen() {\n        Intent chooseLockIntent = new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD);\n        chooseLockIntent.putExtra(ChooseLockGeneric.ChooseLockGenericFragment.HIDE_INSECURE_OPTIONS,\n                true);\n        startActivityForResult(chooseLockIntent, REQUEST_CHOOSE_LOCK);\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n\n        if (requestCode == REQUEST_CHOOSE_LOCK) {\n            if (resultCode != Activity.RESULT_CANCELED && hasLockscreenSecurity()) {\n                addUserNow(USER_TYPE_RESTRICTED_PROFILE);\n            }\n        } else if (mGuestUserAutoCreated && requestCode == REQUEST_EDIT_GUEST\n                && resultCode == RESULT_GUEST_REMOVED) {\n            scheduleGuestCreation();\n        } else {\n            mCreateUserDialogController.onActivityResult(requestCode, resultCode, data);\n            mEditUserInfoController.onActivityResult(requestCode, resultCode, data);\n        }\n    }\n\n    private void onAddUserClicked(int userType) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                switch (userType) {\n                    case USER_TYPE_USER:\n                        showDialog(DIALOG_ADD_USER);\n                        break;\n                    case USER_TYPE_RESTRICTED_PROFILE:\n                        if (hasLockscreenSecurity()) {\n                            showDialog(DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE);\n                        } else {\n                            showDialog(DIALOG_NEED_LOCKSCREEN);\n                        }\n                        break;\n                }\n            }\n        }\n    }\n\n    private void onAddSupervisedUserClicked() {\n        final Intent intent = new Intent()\n                .setAction(UserManager.ACTION_CREATE_SUPERVISED_USER)\n                .setPackage(mConfigSupervisedUserCreationPackage)\n                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\n        startActivity(intent);\n    }\n\n    private void onAddGuestClicked() {\n        Context context = getContext();\n        final UserCreatingDialog guestCreatingDialog =\n                new UserCreatingDialog(getActivity(), /* isGuest= */ true);\n        guestCreatingDialog.show();\n\n        ThreadUtils.postOnBackgroundThread(() -> {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_GUEST_ADD);\n            Trace.beginSection(\"UserSettings.addGuest\");\n            final UserInfo guest = mUserManager.createGuest(context);\n            Trace.endSection();\n\n            ThreadUtils.postOnMainThread(() -> {\n                guestCreatingDialog.dismiss();\n                if (guest == null) {\n                    Toast.makeText(context,\n                            com.android.settingslib.R.string.add_guest_failed,\n                            Toast.LENGTH_SHORT).show();\n                    return;\n                }\n                openUserDetails(guest, true, context);\n            });\n        });\n    }\n\n    private void onRemoveUserClicked(int userId) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                mRemovingUserId = userId;\n                showDialog(DIALOG_CONFIRM_REMOVE);\n            }\n        }\n    }\n\n    private void onUserCreated(UserInfo userInfo, Context context) {\n        hideUserCreatingDialog();\n        mAddingUser = false;\n        openUserDetails(userInfo, true, context);\n    }\n\n    private void hideUserCreatingDialog() {\n        if (mUserCreatingDialog != null && mUserCreatingDialog.isShowing()) {\n            mUserCreatingDialog.dismiss();\n        }\n    }\n\n    private void onUserCreationFailed() {\n        Toast.makeText(getContext(),\n                com.android.settingslib.R.string.add_user_failed,\n                Toast.LENGTH_SHORT).show();\n        hideUserCreatingDialog();\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser) {\n        openUserDetails(userInfo, newUser, getContext());\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser, Context context) {\n        // to prevent a crash when config changes during user creation,\n        // we simply ignore this redirection step\n        if (context == null) {\n            return;\n        }\n\n        Bundle extras = new Bundle();\n        extras.putInt(UserDetailsSettings.EXTRA_USER_ID, userInfo.id);\n        extras.putBoolean(AppRestrictionsFragment.EXTRA_NEW_USER, newUser);\n\n        SubSettingLauncher launcher = new SubSettingLauncher(context)\n                .setDestination(UserDetailsSettings.class.getName())\n                .setArguments(extras)\n                .setTitleText(userInfo.name)\n                .setSourceMetricsCategory(getMetricsCategory());\n        if (mGuestUserAutoCreated && userInfo.isGuest()) {\n            launcher.setResultListener(this, REQUEST_EDIT_GUEST);\n        }\n        launcher.launch();\n    }\n\n    @Override\n    public void onDialogShowing() {\n        super.onDialogShowing();\n\n        setOnDismissListener(this);\n    }\n\n    @Override\n    public Dialog onCreateDialog(int dialogId) {\n        Context context = getActivity();\n        if (context == null) {\n            return null;\n        }\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE: {\n                Dialog dlg =\n                        UserDialogs.createRemoveDialog(getActivity(), mRemovingUserId,\n                                new DialogInterface.OnClickListener() {\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        removeUserNow();\n                                    }\n                                }\n                        );\n                return dlg;\n            }\n            case DIALOG_USER_CANNOT_MANAGE:\n                return new AlertDialog.Builder(context)\n                        .setMessage(R.string.user_cannot_manage_message)\n                        .setPositiveButton(android.R.string.ok, null)\n                        .create();\n            case DIALOG_ADD_USER: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_user_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_USER);\n            }\n            case DIALOG_CHOOSE_USER_TYPE: {\n                List<HashMap<String, String>> data = new ArrayList<HashMap<String, String>>();\n                HashMap<String, String> addUserItem = new HashMap<String, String>();\n                addUserItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_user_item_title));\n                addUserItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_user_item_summary));\n                HashMap<String, String> addProfileItem = new HashMap<String, String>();\n                addProfileItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_title));\n                addProfileItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_summary));\n                data.add(addUserItem);\n                data.add(addProfileItem);\n                AlertDialog.Builder builder = new AlertDialog.Builder(context);\n                SimpleAdapter adapter = new SimpleAdapter(builder.getContext(),\n                        data, R.layout.two_line_list_item,\n                        new String[]{KEY_TITLE, KEY_SUMMARY},\n                        new int[]{R.id.title, R.id.summary});\n                builder.setTitle(com.android.settingslib.R.string.user_add_user_type_title);\n                builder.setAdapter(adapter,\n                        new DialogInterface.OnClickListener() {\n                            @Override\n                            public void onClick(DialogInterface dialog, int which) {\n                                onAddUserClicked(which == 0\n                                        ? USER_TYPE_USER\n                                        : USER_TYPE_RESTRICTED_PROFILE);\n                            }\n                        });\n                return builder.create();\n            }\n            case DIALOG_NEED_LOCKSCREEN: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setMessage(com.android.settingslib.R.string.user_need_lock_message)\n                        .setPositiveButton(com.android.settingslib.R.string.user_set_lock_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        launchChooseLockscreen();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_REMOVE_GUEST: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.guest_remove_guest_dialog_title)\n                        .setMessage(R.string.user_exit_guest_confirm_message)\n                        .setPositiveButton(R.string.user_exit_guest_dialog_remove,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.guest_exit_dialog_title)\n                        .setMessage(com.android.settingslib.R.string.guest_exit_dialog_message)\n                        .setPositiveButton(\n                                com.android.settingslib.R.string.guest_exit_dialog_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(\n                            com.android.settingslib.R.string.guest_exit_dialog_title_non_ephemeral)\n                        .setMessage(\n                            com.android.settingslib\n                                .R.string.guest_exit_dialog_message_non_ephemeral)\n                        .setPositiveButton(\n                            com.android.settingslib.R.string.guest_exit_save_data_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        exitGuest();\n                                    }\n                                })\n                        .setNegativeButton(\n                            com.android.settingslib.R.string.guest_exit_clear_data_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel",
        "metrics": {},
        "metrics_status": "Metrics not computed: 'downstream_file_content_ground_truth' is missing."
    },
    {
        "cve_id": "ASB-A-289375038",
        "downstream_version": "14",
        "file_name": "android/app/src/com/android/bluetooth/btservice/AdapterService.java",
        "ground_truth_codebase": "",
        "llm_patched_codebase": "/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.bluetooth.btservice;\n\nimport static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\nimport static android.text.format.DateUtils.MINUTE_IN_MILLIS;\nimport static android.text.format.DateUtils.SECOND_IN_MILLIS;\nimport static android.bluetooth.BluetoothDevice.BOND_NONE;\n\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveOrManagedUser;\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveUser;\nimport static com.android.bluetooth.Utils.enforceBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.enforceCdmAssociation;\nimport static com.android.bluetooth.Utils.enforceDumpPermission;\nimport static com.android.bluetooth.Utils.enforceLocalMacAddressPermission;\nimport static com.android.bluetooth.Utils.getBytesFromAddress;\nimport static com.android.bluetooth.Utils.hasBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.isPackageNameAccurate;\n\nimport android.annotation.NonNull;\nimport android.annotation.RequiresPermission;\nimport android.annotation.SuppressLint;\nimport android.app.AlarmManager;\nimport android.app.AppOpsManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.app.admin.DevicePolicyManager;\nimport android.bluetooth.BluetoothA2dp;\nimport android.bluetooth.BluetoothActivityEnergyInfo;\nimport android.bluetooth.BluetoothAdapter;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceProfile;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceUse;\nimport android.bluetooth.BluetoothClass;\nimport android.bluetooth.BluetoothDevice;\nimport android.bluetooth.BluetoothFrameworkInitializer;\nimport android.bluetooth.BluetoothMap;\nimport android.bluetooth.BluetoothProfile;\nimport android.bluetooth.BluetoothProtoEnums;\nimport android.bluetooth.BluetoothSap;\nimport android.bluetooth.BluetoothServerSocket;\nimport android.bluetooth.BluetoothSocket;\nimport android.bluetooth.BluetoothStatusCodes;\nimport android.bluetooth.BluetoothUuid;\nimport android.bluetooth.BufferConstraints;\nimport android.bluetooth.IBluetooth;\nimport android.bluetooth.IBluetoothActivityEnergyInfoListener;\nimport android.bluetooth.IBluetoothCallback;\nimport android.bluetooth.IBluetoothConnectionCallback;\nimport android.bluetooth.IBluetoothMetadataListener;\nimport android.bluetooth.IBluetoothOobDataCallback;\nimport android.bluetooth.IBluetoothSocketManager;\nimport android.bluetooth.IncomingRfcommSocketInfo;\nimport android.bluetooth.OobData;\nimport android.bluetooth.UidTraffic;\nimport android.companion.CompanionDeviceManager;\nimport android.content.AttributionSource;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.os.AsyncTask;\nimport android.os.BatteryStatsManager;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelUuid;\nimport android.os.PowerManager;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.DeviceConfig;\nimport android.provider.Settings;\nimport android.sysprop.BluetoothProperties;\nimport android.text.TextUtils;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.util.SparseArray;\n\nimport com.android.bluetooth.BluetoothMetricsProto;\nimport com.android.bluetooth.BluetoothStatsLog;\nimport com.android.bluetooth.R;\nimport com.android.bluetooth.Utils;\nimport com.android.bluetooth.a2dp.A2dpService;\nimport com.android.bluetooth.a2dpsink.A2dpSinkService;\nimport com.android.bluetooth.bas.BatteryService;\nimport com.android.bluetooth.bass_client.BassClientService;\nimport com.android.bluetooth.btservice.RemoteDevices.DeviceProperties;\nimport com.android.bluetooth.btservice.activityattribution.ActivityAttributionService;\nimport com.android.bluetooth.btservice.bluetoothkeystore.BluetoothKeystoreService;\nimport com.android.bluetooth.btservice.storage.DatabaseManager;\nimport com.android.bluetooth.btservice.storage.MetadataDatabase;\nimport com.android.bluetooth.csip.CsipSetCoordinatorService;\nimport com.android.bluetooth.gatt.GattService;\nimport com.android.bluetooth.gatt.ScanManager;\nimport com.android.bluetooth.hap.HapClientService;\nimport com.android.bluetooth.hearingaid.HearingAidService;\nimport com.android.bluetooth.hfp.HeadsetService;\nimport com.android.bluetooth.hfpclient.HeadsetClientService;\nimport com.android.bluetooth.hid.HidDeviceService;\nimport com.android.bluetooth.hid.HidHostService;\nimport com.android.bluetooth.le_audio.LeAudioService;\nimport com.android.bluetooth.map.BluetoothMapService;\nimport com.android.bluetooth.mapclient.MapClientService;\nimport com.android.bluetooth.pan.PanService;\nimport com.android.bluetooth.pbap.BluetoothPbapService;\nimport com.android.bluetooth.pbapclient.PbapClientService;\nimport com.android.bluetooth.sap.SapService;\nimport com.android.bluetooth.sdp.SdpManager;\nimport com.android.bluetooth.telephony.BluetoothInCallService;\nimport com.android.bluetooth.vc.VolumeControlService;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.modules.utils.BackgroundThread;\nimport com.android.modules.utils.BytesMatcher;\nimport com.android.modules.utils.SynchronousResultReceiver;\n\nimport com.google.protobuf.InvalidProtocolBufferException;\n\nimport libcore.util.SneakyThrow;\n\nimport java.io.FileDescriptor;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.time.Duration;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.function.Predicate;\nimport java.util.regex.Pattern;\n\npublic class AdapterService extends Service {\n    private static final String TAG = \"BluetoothAdapterService\";\n    private static final boolean DBG = true;\n    private static final boolean VERBOSE = false;\n    private static final int MIN_ADVT_INSTANCES_FOR_MA = 5;\n    private static final int MIN_OFFLOADED_FILTERS = 10;\n    private static final int MIN_OFFLOADED_SCAN_STORAGE_BYTES = 1024;\n    private static final Duration PENDING_SOCKET_HANDOFF_TIMEOUT = Duration.ofMinutes(1);\n\n    private final Object mEnergyInfoLock = new Object();\n    private int mStackReportedState;\n    private long mTxTimeTotalMs;\n    private long mRxTimeTotalMs;\n    private long mIdleTimeTotalMs;\n    private long mEnergyUsedTotalVoltAmpSecMicro;\n    private final SparseArray<UidTraffic> mUidTraffic = new SparseArray<>();\n\n    private final ArrayList<String> mStartedProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRegisteredProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRunningProfiles = new ArrayList<>();\n\n    public static final String ACTION_LOAD_ADAPTER_PROPERTIES =\n            \"com.android.bluetooth.btservice.action.LOAD_ADAPTER_PROPERTIES\";\n    public static final String ACTION_SERVICE_STATE_CHANGED =\n            \"com.android.bluetooth.btservice.action.STATE_CHANGED\";\n    public static final String EXTRA_ACTION = \"action\";\n    public static final int PROFILE_CONN_REJECTED = 2;\n\n    private static final String ACTION_ALARM_WAKEUP =\n            \"com.android.bluetooth.btservice.action.ALARM_WAKEUP\";\n\n    static final String BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY = \"persist.bluetooth.btsnooplogmode\";\n    static final String BLUETOOTH_BTSNOOP_DEFAULT_MODE_PROPERTY =\n            \"persist.bluetooth.btsnoopdefaultmode\";\n    private String mSnoopLogSettingAtEnable = \"empty\";\n    private String mDefaultSnoopLogSettingAtEnable = \"empty\";\n\n    public static final String BLUETOOTH_PRIVILEGED =\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED;\n    static final String BLUETOOTH_PERM = android.Manifest.permission.BLUETOOTH;\n    static final String LOCAL_MAC_ADDRESS_PERM = android.Manifest.permission.LOCAL_MAC_ADDRESS;\n    static final String RECEIVE_MAP_PERM = android.Manifest.permission.RECEIVE_BLUETOOTH_MAP;\n\n    private static final String PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"phonebook_access_permission\";\n    private static final String MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"message_access_permission\";\n    private static final String SIM_ACCESS_PERMISSION_PREFERENCE_FILE = \"sim_access_permission\";\n\n    private static final int CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS = 30;\n\n    public static final String ACTIVITY_ATTRIBUTION_NO_ACTIVE_DEVICE_ADDRESS =\n            \"no_active_device_address\";\n\n    // Report ID definition\n    public enum BqrQualityReportId {\n        QUALITY_REPORT_ID_MONITOR_MODE(0x01),\n        QUALITY_REPORT_ID_APPROACH_LSTO(0x02),\n        QUALITY_REPORT_ID_A2DP_AUDIO_CHOPPY(0x03),\n        QUALITY_REPORT_ID_SCO_VOICE_CHOPPY(0x04),\n        QUALITY_REPORT_ID_ROOT_INFLAMMATION(0x05),\n        QUALITY_REPORT_ID_LMP_LL_MESSAGE_TRACE(0x11),\n        QUALITY_REPORT_ID_BT_SCHEDULING_TRACE(0x12),\n        QUALITY_REPORT_ID_CONTROLLER_DBG_INFO(0x13);\n\n        private final int value;\n        private BqrQualityReportId(int value) {\n            this.value = value;\n        }\n        public int getValue() {\n            return value;\n        }\n    };\n\n    private final ArrayList<DiscoveringPackage> mDiscoveringPackages = new ArrayList<>();\n\n    static {\n        classInitNative();\n    }\n\n    private static AdapterService sAdapterService;\n\n    public static synchronized AdapterService getAdapterService() {\n        return sAdapterService;\n    }\n\n    private static synchronized void setAdapterService(AdapterService instance) {\n        Log.d(TAG, \"setAdapterService() - trying to set service to \" + instance);\n        if (instance == null) {\n            return;\n        }\n        sAdapterService = instance;\n    }\n\n    private static synchronized void clearAdapterService(AdapterService current) {\n        if (sAdapterService == current) {\n            sAdapterService = null;\n        }\n    }\n\n    private BluetoothAdapter mAdapter;\n    private AdapterProperties mAdapterProperties;\n    private AdapterState mAdapterStateMachine;\n    private BondStateMachine mBondStateMachine;\n    private JniCallbacks mJniCallbacks;\n    private RemoteDevices mRemoteDevices;\n\n    /* TODO: Consider to remove the search API from this class, if changed to use call-back */\n    private SdpManager mSdpManager = null;\n\n    private boolean mNativeAvailable;\n    private boolean mCleaningUp;\n    private final HashMap<BluetoothDevice, ArrayList<IBluetoothMetadataListener>>\n            mMetadataListeners = new HashMap<>();\n    private final HashMap<String, Integer> mProfileServicesState = new HashMap<String, Integer>();\n    private Set<IBluetoothConnectionCallback> mBluetoothConnectionCallbacks = new HashSet<>();\n    //Only BluetoothManagerService should be registered\n    private RemoteCallbackList<IBluetoothCallback> mCallbacks;\n    private int mCurrentRequestId;\n    private boolean mQuietmode = false;\n    private HashMap<String, CallerInfo> mBondAttemptCallerInfo = new HashMap<>();\n\n    private final Map<UUID, RfcommListenerData> mBluetoothServerSockets = new ConcurrentHashMap<>();\n    private final Executor mSocketServersExecutor = r -> new Thread(r).start();\n\n    private AlarmManager mAlarmManager;\n    private PendingIntent mPendingAlarm;\n    private BatteryStatsManager mBatteryStatsManager;\n    private PowerManager mPowerManager;\n    private PowerManager.WakeLock mWakeLock;\n    private String mWakeLockName;\n    private UserManager mUserManager;\n    private CompanionDeviceManager mCompanionDeviceManager;\n\n    private PhonePolicy mPhonePolicy;\n    private ActiveDeviceManager mActiveDeviceManager;\n    private DatabaseManager mDatabaseManager;\n    private SilenceDeviceManager mSilenceDeviceManager;\n    private AppOpsManager mAppOps;\n\n    private BluetoothSocketManagerBinder mBluetoothSocketManagerBinder;\n\n    private BluetoothKeystoreService mBluetoothKeystoreService;\n    private A2dpService mA2dpService;\n    private A2dpSinkService mA2dpSinkService;\n    private ActivityAttributionService mActivityAttributionService;\n    private HeadsetService mHeadsetService;\n    private HeadsetClientService mHeadsetClientService;\n    private BluetoothMapService mMapService;\n    private MapClientService mMapClientService;\n    private HidDeviceService mHidDeviceService;\n    private HidHostService mHidHostService;\n    private PanService mPanService;\n    private BluetoothPbapService mPbapService;\n    private PbapClientService mPbapClientService;\n    private HearingAidService mHearingAidService;\n    private HapClientService mHapClientService;\n    private SapService mSapService;\n    private VolumeControlService mVolumeControlService;\n    private CsipSetCoordinatorService mCsipSetCoordinatorService;\n    private LeAudioService mLeAudioService;\n    private BassClientService mBassClientService;\n    private BatteryService mBatteryService;\n\n    private volatile boolean mTestModeEnabled = false;\n\n    private MetricsLogger mMetricsLogger;\n\n    /**\n     * Register a {@link ProfileService} with AdapterService.\n     *\n     * @param profile the service being added.\n     */\n    public void addProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_REGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Unregister a ProfileService with AdapterService.\n     *\n     * @param profile the service being removed.\n     */\n    public void removeProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_UNREGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Notify AdapterService that a ProfileService has started or stopped.\n     *\n     * @param profile the service being removed.\n     * @param state {@link BluetoothAdapter#STATE_ON} or {@link BluetoothAdapter#STATE_OFF}\n     */\n    public void onProfileServiceStateChanged(ProfileService profile, int state) {\n        if (state != BluetoothAdapter.STATE_ON && state != BluetoothAdapter.STATE_OFF) {\n            throw new IllegalArgumentException(BluetoothAdapter.nameForState(state));\n        }\n        Message m = mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_STATE_CHANGED);\n        m.obj = profile;\n        m.arg1 = state;\n        mHandler.sendMessage(m);\n    }\n\n    /**\n     * Confirm whether the ProfileService is started expectedly.\n     *\n     * @param serviceSampleName the service simple name.\n     * @return true if the service is started expectedly, false otherwise.\n     */\n    public boolean isStartedProfile(String serviceSampleName) {\n        return mStartedProfiles.contains(serviceSampleName);\n    }\n\n    private static final int MESSAGE_PROFILE_SERVICE_STATE_CHANGED = 1;\n    private static final int MESSAGE_PROFILE_SERVICE_REGISTERED = 2;\n    private static final int MESSAGE_PROFILE_SERVICE_UNREGISTERED = 3;\n\n    class AdapterServiceHandler extends Handler {\n        @Override\n        public void handleMessage(Message msg) {\n            verboseLog(\"handleMessage() - Message: \" + msg.what);\n\n            switch (msg.what) {\n                case MESSAGE_PROFILE_SERVICE_STATE_CHANGED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_STATE_CHANGED\");\n                    processProfileServiceStateChanged((ProfileService) msg.obj, msg.arg1);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_REGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_REGISTERED\");\n                    registerProfileService((ProfileService) msg.obj);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_UNREGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_UNREGISTERED\");\n                    unregisterProfileService((ProfileService) msg.obj);\n                    break;\n            }\n        }\n\n        private void registerProfileService(ProfileService profile) {\n            if (mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" already registered.\");\n                return;\n            }\n            mRegisteredProfiles.add(profile);\n        }\n\n        private void unregisterProfileService(ProfileService profile) {\n            if (!mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" not registered (UNREGISTER).\");\n                return;\n            }\n            mRegisteredProfiles.remove(profile);\n        }\n\n        private void processProfileServiceStateChanged(ProfileService profile, int state) {\n            switch (state) {\n                case BluetoothAdapter.STATE_ON:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_ON).\");\n                        return;\n                    }\n                    if (mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" already running.\");\n                        return;\n                    }\n                    mRunningProfiles.add(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT starting triggers hardware\n                    // initializtion. Configuring a device without GATT causes start up failures.\n                    if (GattService.class.getSimpleName().equals(profile.getName())) {\n                        enableNative();\n                    } else if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                            && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n                        mAdapterProperties.onBluetoothReady();\n                        updateUuids();\n                        setBluetoothClassFromConfig();\n                        initProfileServices();\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS_BLE);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_DYNAMIC_AUDIO_BUFFER);\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n                    }\n                    break;\n                case BluetoothAdapter.STATE_OFF:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_OFF).\");\n                        return;\n                    }\n                    if (!mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not running.\");\n                        return;\n                    }\n                    mRunningProfiles.remove(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT is expected to be the only\n                    // profile available in the \"BLE ON\" state. If only GATT is left, send\n                    // BREDR_STOPPED. If GATT is stopped, deinitialize the hardware.\n                    if ((mRunningProfiles.size() == 1 && (GattService.class.getSimpleName()\n                            .equals(mRunningProfiles.get(0).getName())))) {\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n                    } else if (mRunningProfiles.size() == 0) {\n                        disableNative();\n                    }\n                    break;\n                default:\n                    Log.e(TAG, \"Unhandled profile state: \" + state);\n            }\n        }\n    }\n\n    private final AdapterServiceHandler mHandler = new AdapterServiceHandler();\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        initMetricsLogger();\n        debugLog(\"onCreate()\");\n        mDeviceConfigListener.start();\n        mRemoteDevices = new RemoteDevices(this, Looper.getMainLooper());\n        mRemoteDevices.init();\n        clearDiscoveringPackages();\n        mBinder = new AdapterServiceBinder(this);\n        mAdapter = BluetoothAdapter.getDefaultAdapter();\n        mAdapterProperties = new AdapterProperties(this);\n        mAdapterStateMachine = AdapterState.make(this);\n        mJniCallbacks = new JniCallbacks(this, mAdapterProperties);\n        mBluetoothKeystoreService = new BluetoothKeystoreService(isCommonCriteriaMode());\n        mBluetoothKeystoreService.start();\n        int configCompareResult = mBluetoothKeystoreService.getCompareResult();\n\n        // Start tracking Binder latency for the bluetooth process.\n        BluetoothFrameworkInitializer.initializeBinderCallsStats(getApplicationContext());\n\n        // Android TV doesn't show consent dialogs for just works and encryption only le pairing\n        boolean isAtvDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_LEANBACK_ONLY);\n        mUserManager = getSystemService(UserManager.class);\n        initNative(mUserManager.isGuestUser(), isCommonCriteriaMode(), configCompareResult,\n                getInitFlags(), isAtvDevice, getApplicationInfo().dataDir);\n        mNativeAvailable = true;\n        mCallbacks = new RemoteCallbackList<IBluetoothCallback>();\n        mAppOps = getSystemService(AppOpsManager.class);\n        //Load the name and address\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDADDR);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDNAME);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_CLASS_OF_DEVICE);\n        mAlarmManager = getSystemService(AlarmManager.class);\n        mPowerManager = getSystemService(PowerManager.class);\n        mBatteryStatsManager = getSystemService(BatteryStatsManager.class);\n        mCompanionDeviceManager = getSystemService(CompanionDeviceManager.class);\n\n        mBluetoothKeystoreService.initJni();\n\n        mSdpManager = SdpManager.init(this);\n        registerReceiver(mAlarmBroadcastReceiver, new IntentFilter(ACTION_ALARM_WAKEUP));\n\n        mDatabaseManager = new DatabaseManager(this);\n        mDatabaseManager.start(MetadataDatabase.createDatabase(this));\n\n        boolean isAutomotiveDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_AUTOMOTIVE);\n\n        /*\n         * Phone policy is specific to phone implementations and hence if a device wants to exclude\n         * it out then it can be disabled by using the flag below. Phone policy is never used on\n         * Android Automotive OS builds, in favor of a policy currently located in\n         * CarBluetoothService.\n         */\n        if (!isAutomotiveDevice && getResources().getBoolean(R.bool.enable_phone_policy)) {\n            Log.i(TAG, \"Phone policy enabled\");\n            mPhonePolicy = new PhonePolicy(this, new ServiceFactory());\n            mPhonePolicy.start();\n        } else {\n            Log.i(TAG, \"Phone policy disabled\");\n        }\n\n        mActiveDeviceManager = new ActiveDeviceManager(this, new ServiceFactory());\n        mActiveDeviceManager.start();\n\n        mSilenceDeviceManager = new SilenceDeviceManager(this, new ServiceFactory(),\n                Looper.getMainLooper());\n        mSilenceDeviceManager.start();\n\n        mBluetoothSocketManagerBinder = new BluetoothSocketManagerBinder(this);\n\n        mActivityAttributionService = new ActivityAttributionService();\n        mActivityAttributionService.start();\n\n        setAdapterService(this);\n\n        invalidateBluetoothCaches();\n\n        // First call to getSharedPreferences will result in a file read into\n        // memory cache. Call it here asynchronously to avoid potential ANR\n        // in the future\n        new AsyncTask<Void, Void, Void>() {\n            @Override\n            protected Void doInBackground(Void... params) {\n                getSharedPreferences(PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(SIM_ACCESS_PERMISSION_PREFERENCE_FILE, Context.MODE_PRIVATE);\n                return null;\n            }\n        }.execute();\n\n        try {\n            int systemUiUid = getApplicationContext()\n                    .createContextAsUser(UserHandle.SYSTEM, /* flags= */ 0)\n                    .getPackageManager()\n                    .getPackageUid(\"com.android.systemui\", PackageManager.MATCH_SYSTEM_ONLY);\n\n            Utils.setSystemUiUid(systemUiUid);\n        } catch (PackageManager.NameNotFoundException e) {\n            // Some platforms, such as wearables do not have a system ui.\n            Log.w(TAG, \"Unable to resolve SystemUI's UID.\", e);\n        }\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        debugLog(\"onBind()\");\n        return mBinder;\n    }\n\n    @Override\n    public boolean onUnbind(Intent intent) {\n        debugLog(\"onUnbind() - calling cleanup\");\n        cleanup();\n        return super.onUnbind(intent);\n    }\n\n    @Override\n    public void onDestroy() {\n        debugLog(\"onDestroy()\");\n        if (!isMock()) {\n            // TODO(b/27859763)\n            Log.i(TAG, \"Force exit to cleanup internal state in Bluetooth stack\");\n            System.exit(0);\n        }\n    }\n\n    private boolean initMetricsLogger() {\n        if (mMetricsLogger != null) {\n            return false;\n        }\n        mMetricsLogger = MetricsLogger.getInstance();\n        return mMetricsLogger.init(this);\n    }\n\n    private boolean closeMetricsLogger() {\n        if (mMetricsLogger == null) {\n            return false;\n        }\n        boolean result = mMetricsLogger.close();\n        mMetricsLogger = null;\n        return result;\n    }\n\n    public void setMetricsLogger(MetricsLogger metricsLogger) {\n        mMetricsLogger = metricsLogger;\n    }\n\n    void bringUpBle() {\n        debugLog(\"bleOnProcessStart()\");\n\n        if (getResources().getBoolean(\n                R.bool.config_bluetooth_reload_supported_profiles_when_enabled)) {\n            Config.init(getApplicationContext());\n        }\n\n        // Reset |mRemoteDevices| whenever BLE is turned off then on\n        // This is to replace the fact that |mRemoteDevices| was\n        // reinitialized in previous code.\n        //\n        // TODO(apanicke): The reason is unclear but\n        // I believe it is to clear the variable every time BLE was\n        // turned off then on. The same effect can be achieved by\n        // calling cleanup but this may not be necessary at all\n        // We should figure out why this is needed later\n        mRemoteDevices.reset();\n        mAdapterProperties.init(mRemoteDevices);\n\n        debugLog(\"bleOnProcessStart() - Make Bond State Machine\");\n        mBondStateMachine = BondStateMachine.make(this, mAdapterProperties, mRemoteDevices);\n\n        mJniCallbacks.init(mBondStateMachine, mRemoteDevices);\n\n        mBatteryStatsManager.reportBleScanReset();\n        BluetoothStatsLog.write_non_chained(BluetoothStatsLog.BLE_SCAN_STATE_CHANGED, -1, null,\n                BluetoothStatsLog.BLE_SCAN_STATE_CHANGED__STATE__RESET, false, false, false);\n\n        // TODO(b/228875190): GATT is assumed supported. As a result, we don't respect the\n        // configuration sysprop. Configuring a device without GATT, although rare, will cause stack\n        // start up errors yielding init loops.\n        if (!GattService.isEnabled()) {\n            Log.w(TAG,\n                    \"GATT is configured off but the stack assumes it to be enabled. Start anyway.\");\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_ON);\n    }\n\n    void bringDownBle() {\n        stopGattProfileService();\n    }\n\n    void stateChangeCallback(int status) {\n        if (status == AbstractionLayer.BT_STATE_OFF) {\n            debugLog(\"stateChangeCallback: disableNative() completed\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        } else if (status == AbstractionLayer.BT_STATE_ON) {\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STARTED);\n        } else {\n            Log.e(TAG, \"Incorrect status \" + status + \" in stateChangeCallback\");\n        }\n    }\n\n    /**\n     * Sets the Bluetooth CoD value of the local adapter if there exists a config value for it.\n     */\n    void setBluetoothClassFromConfig() {\n        int bluetoothClassConfig = retrieveBluetoothClassConfig();\n        if (bluetoothClassConfig != 0) {\n            mAdapterProperties.setBluetoothClass(new BluetoothClass(bluetoothClassConfig));\n        }\n    }\n\n    private int retrieveBluetoothClassConfig() {\n        return Settings.Global.getInt(\n                getContentResolver(), Settings.Global.BLUETOOTH_CLASS_OF_DEVICE, 0);\n    }\n\n    void startProfileServices() {\n        debugLog(\"startCoreServices()\");\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no other profiles then just\n        // move on to BREDR_STARTED. Note that configuring GATT to NOT supported will cause adapter\n        // initialization failures\n        if (supportedProfileServices.length == 1 && GattService.class.getSimpleName()\n                .equals(supportedProfileServices[0].getSimpleName())) {\n            mAdapterProperties.onBluetoothReady();\n            updateUuids();\n            setBluetoothClassFromConfig();\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_ON);\n        }\n    }\n\n    void stopProfileServices() {\n        // Make sure to stop classic background tasks now\n        cancelDiscoveryNative();\n        mAdapterProperties.setScanMode(AbstractionLayer.BT_SCAN_MODE_NONE);\n\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no profiles then just move on\n        // to BREDR_STOPPED\n        if (supportedProfileServices.length == 1 && (mRunningProfiles.size() == 1\n                && GattService.class.getSimpleName().equals(mRunningProfiles.get(0).getName()))) {\n            debugLog(\"stopProfileServices() - No profiles services to stop or already stopped.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_OFF);\n        }\n    }\n\n    private void stopGattProfileService() {\n        mAdapterProperties.onBleDisable();\n        if (mRunningProfiles.size() == 0) {\n            debugLog(\"stopGattProfileService() - No profiles services to stop.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_OFF);\n    }\n\n    private void invalidateBluetoothGetStateCache() {\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n    }\n\n    void updateLeAudioProfileServiceState() {\n        HashSet<Class> nonSupportedProfiles = new HashSet<>();\n\n        if (!isLeConnectedIsochronousStreamCentralSupported()) {\n            nonSupportedProfiles.addAll(Config.geLeAudioUnicastProfiles());\n        }\n\n        if (!isLeAudioBroadcastAssistantSupported()) {\n            nonSupportedProfiles.add(BassClientService.class);\n        }\n\n        if (isLeAudioBroadcastSourceSupported()) {\n            Config.addSupportedProfile(BluetoothProfile.LE_AUDIO_BROADCAST);\n        }\n\n        if (!nonSupportedProfiles.isEmpty()) {\n            // Remove non-supported profiles from the supported list\n            // since the controller doesn't support\n            Config.removeProfileFromSupportedList(nonSupportedProfiles);\n\n            // Disable the non-supported profiles service\n            for (Class profileService : nonSupportedProfiles) {\n                if (isStartedProfile(profileService.getSimpleName())) {\n                    setProfileServiceState(profileService, BluetoothAdapter.STATE_OFF);\n                }\n            }\n        }\n    }\n\n    void updateAdapterState(int prevState, int newState) {\n        mAdapterProperties.setState(newState);\n        invalidateBluetoothGetStateCache();\n        if (mCallbacks != null) {\n            int n = mCallbacks.beginBroadcast();\n            debugLog(\"updateAdapterState() - Broadcasting state \" + BluetoothAdapter.nameForState(\n                    newState) + \" to \" + n + \" receivers.\");\n            for (int i = 0; i < n; i++) {\n                try {\n                    mCallbacks.getBroadcastItem(i).onBluetoothStateChange(prevState, newState);\n                } catch (RemoteException e) {\n                    debugLog(\"updateAdapterState() - Callback #\" + i + \" failed (\" + e + \")\");\n                }\n            }\n            mCallbacks.finishBroadcast();\n        }\n\n        // Turn the Adapter all the way off if we are disabling and the snoop log setting changed.\n        if (newState == BluetoothAdapter.STATE_BLE_TURNING_ON) {\n            mSnoopLogSettingAtEnable =\n                    SystemProperties.get(BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY, \"empty\");\n            mDefaultSnoopLogSettingAtEnable =\n                    Settings.Global.getString(getContentResolver(),\n                            Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n            BluetoothProperties.snoop_",
        "metrics": {},
        "metrics_status": "Metrics not computed: 'downstream_file_content_ground_truth' is missing."
    },
    {
        "cve_id": "ASB-A-289811388",
        "downstream_version": "14",
        "file_name": "android/app/src/com/android/bluetooth/btservice/AdapterService.java",
        "ground_truth_codebase": "",
        "llm_patched_codebase": "/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.bluetooth.btservice;\n\nimport static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\nimport static android.text.format.DateUtils.MINUTE_IN_MILLIS;\nimport static android.text.format.DateUtils.SECOND_IN_MILLIS;\n\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveOrManagedUser;\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveUser;\nimport static com.android.bluetooth.Utils.enforceBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.enforceCdmAssociation;\nimport static com.android.bluetooth.Utils.enforceDumpPermission;\nimport static com.android.bluetooth.Utils.enforceLocalMacAddressPermission;\nimport static com.android.bluetooth.Utils.getBytesFromAddress;\nimport static com.android.bluetooth.Utils.hasBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.isPackageNameAccurate;\n\nimport android.annotation.NonNull;\nimport android.annotation.RequiresPermission;\nimport android.annotation.SuppressLint;\nimport android.app.AlarmManager;\nimport android.app.AppOpsManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.app.admin.DevicePolicyManager;\nimport android.bluetooth.BluetoothA2dp;\nimport android.bluetooth.BluetoothActivityEnergyInfo;\nimport android.bluetooth.BluetoothAdapter;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceProfile;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceUse;\nimport android.bluetooth.BluetoothClass;\nimport android.bluetooth.BluetoothDevice;\nimport android.bluetooth.BluetoothFrameworkInitializer;\nimport android.bluetooth.BluetoothMap;\nimport android.bluetooth.BluetoothProfile;\nimport android.bluetooth.BluetoothProtoEnums;\nimport android.bluetooth.BluetoothSap;\nimport android.bluetooth.BluetoothServerSocket;\nimport android.bluetooth.BluetoothSocket;\nimport android.bluetooth.BluetoothStatusCodes;\nimport android.bluetooth.BluetoothUuid;\nimport android.bluetooth.BufferConstraints;\nimport android.bluetooth.IBluetooth;\nimport android.bluetooth.IBluetoothActivityEnergyInfoListener;\nimport android.bluetooth.IBluetoothCallback;\nimport android.bluetooth.IBluetoothConnectionCallback;\nimport android.bluetooth.IBluetoothMetadataListener;\nimport android.bluetooth.IBluetoothOobDataCallback;\nimport android.bluetooth.IBluetoothSocketManager;\nimport android.bluetooth.IncomingRfcommSocketInfo;\nimport android.bluetooth.OobData;\nimport android.bluetooth.UidTraffic;\nimport android.companion.CompanionDeviceManager;\nimport android.content.AttributionSource;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.os.AsyncTask;\nimport android.os.BatteryStatsManager;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelUuid;\nimport android.os.PowerManager;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.DeviceConfig;\nimport android.provider.Settings;\nimport android.sysprop.BluetoothProperties;\nimport android.text.TextUtils;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.util.SparseArray;\n\nimport com.android.bluetooth.BluetoothMetricsProto;\nimport com.android.bluetooth.BluetoothStatsLog;\nimport com.android.bluetooth.R;\nimport com.android.bluetooth.Utils;\nimport com.android.bluetooth.a2dp.A2dpService;\nimport com.android.bluetooth.a2dpsink.A2dpSinkService;\nimport com.android.bluetooth.bas.BatteryService;\nimport com.android.bluetooth.bass_client.BassClientService;\nimport com.android.bluetooth.btservice.RemoteDevices.DeviceProperties;\nimport com.android.bluetooth.btservice.activityattribution.ActivityAttributionService;\nimport com.android.bluetooth.btservice.bluetoothkeystore.BluetoothKeystoreService;\nimport com.android.bluetooth.btservice.storage.DatabaseManager;\nimport com.android.bluetooth.btservice.storage.MetadataDatabase;\nimport com.android.bluetooth.csip.CsipSetCoordinatorService;\nimport com.android.bluetooth.gatt.GattService;\nimport com.android.bluetooth.gatt.ScanManager;\nimport com.android.bluetooth.hap.HapClientService;\nimport com.android.bluetooth.hearingaid.HearingAidService;\nimport com.android.bluetooth.hfp.HeadsetService;\nimport com.android.bluetooth.hfpclient.HeadsetClientService;\nimport com.android.bluetooth.hid.HidDeviceService;\nimport com.android.bluetooth.hid.HidHostService;\nimport com.android.bluetooth.le_audio.LeAudioService;\nimport com.android.bluetooth.map.BluetoothMapService;\nimport com.android.bluetooth.mapclient.MapClientService;\nimport com.android.bluetooth.pan.PanService;\nimport com.android.bluetooth.pbap.BluetoothPbapService;\nimport com.android.bluetooth.pbapclient.PbapClientService;\nimport com.android.bluetooth.sap.SapService;\nimport com.android.bluetooth.sdp.SdpManager;\nimport com.android.bluetooth.telephony.BluetoothInCallService;\nimport com.android.bluetooth.vc.VolumeControlService;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.modules.utils.BackgroundThread;\nimport com.android.modules.utils.BytesMatcher;\nimport com.android.modules.utils.SynchronousResultReceiver;\n\nimport com.google.protobuf.InvalidProtocolBufferException;\n\nimport libcore.util.SneakyThrow;\n\nimport java.io.FileDescriptor;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.time.Duration;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.function.Predicate;\nimport java.util.regex.Pattern;\n\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE;\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_NONE;\nimport static android.bluetooth.BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\nimport static android.bluetooth.BluetoothDevice.BOND_NONE;\n\npublic class AdapterService extends Service {\n    private static final String TAG = \"BluetoothAdapterService\";\n    private static final boolean DBG = true;\n    private static final boolean VERBOSE = false;\n    private static final int MIN_ADVT_INSTANCES_FOR_MA = 5;\n    private static final int MIN_OFFLOADED_FILTERS = 10;\n    private static final int MIN_OFFLOADED_SCAN_STORAGE_BYTES = 1024;\n    private static final Duration PENDING_SOCKET_HANDOFF_TIMEOUT = Duration.ofMinutes(1);\n\n    private final Object mEnergyInfoLock = new Object();\n    private int mStackReportedState;\n    private long mTxTimeTotalMs;\n    private long mRxTimeTotalMs;\n    private long mIdleTimeTotalMs;\n    private long mEnergyUsedTotalVoltAmpSecMicro;\n    private final SparseArray<UidTraffic> mUidTraffic = new SparseArray<>();\n\n    private final ArrayList<String> mStartedProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRegisteredProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRunningProfiles = new ArrayList<>();\n\n    public static final String ACTION_LOAD_ADAPTER_PROPERTIES =\n            \"com.android.bluetooth.btservice.action.LOAD_ADAPTER_PROPERTIES\";\n    public static final String ACTION_SERVICE_STATE_CHANGED =\n            \"com.android.bluetooth.btservice.action.STATE_CHANGED\";\n    public static final String EXTRA_ACTION = \"action\";\n    public static final int PROFILE_CONN_REJECTED = 2;\n\n    private static final String ACTION_ALARM_WAKEUP =\n            \"com.android.bluetooth.btservice.action.ALARM_WAKEUP\";\n\n    static final String BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY = \"persist.bluetooth.btsnooplogmode\";\n    static final String BLUETOOTH_BTSNOOP_DEFAULT_MODE_PROPERTY =\n            \"persist.bluetooth.btsnoopdefaultmode\";\n    private String mSnoopLogSettingAtEnable = \"empty\";\n    private String mDefaultSnoopLogSettingAtEnable = \"empty\";\n\n    public static final String BLUETOOTH_PRIVILEGED =\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED;\n    static final String BLUETOOTH_PERM = android.Manifest.permission.BLUETOOTH;\n    static final String LOCAL_MAC_ADDRESS_PERM = android.Manifest.permission.LOCAL_MAC_ADDRESS;\n    static final String RECEIVE_MAP_PERM = android.Manifest.permission.RECEIVE_BLUETOOTH_MAP;\n\n    private static final String PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"phonebook_access_permission\";\n    private static final String MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"message_access_permission\";\n    private static final String SIM_ACCESS_PERMISSION_PREFERENCE_FILE = \"sim_access_permission\";\n\n    private static final int CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS = 30;\n\n    public static final String ACTIVITY_ATTRIBUTION_NO_ACTIVE_DEVICE_ADDRESS =\n            \"no_active_device_address\";\n\n    // Report ID definition\n    public enum BqrQualityReportId {\n        QUALITY_REPORT_ID_MONITOR_MODE(0x01),\n        QUALITY_REPORT_ID_APPROACH_LSTO(0x02),\n        QUALITY_REPORT_ID_A2DP_AUDIO_CHOPPY(0x03),\n        QUALITY_REPORT_ID_SCO_VOICE_CHOPPY(0x04),\n        QUALITY_REPORT_ID_ROOT_INFLAMMATION(0x05),\n        QUALITY_REPORT_ID_LMP_LL_MESSAGE_TRACE(0x11),\n        QUALITY_REPORT_ID_BT_SCHEDULING_TRACE(0x12),\n        QUALITY_REPORT_ID_CONTROLLER_DBG_INFO(0x13);\n\n        private final int value;\n        private BqrQualityReportId(int value) {\n            this.value = value;\n        }\n        public int getValue() {\n            return value;\n        }\n    };\n\n    private final ArrayList<DiscoveringPackage> mDiscoveringPackages = new ArrayList<>();\n\n    static {\n        classInitNative();\n    }\n\n    private static AdapterService sAdapterService;\n\n    public static synchronized AdapterService getAdapterService() {\n        return sAdapterService;\n    }\n\n    private static synchronized void setAdapterService(AdapterService instance) {\n        Log.d(TAG, \"setAdapterService() - trying to set service to \" + instance);\n        if (instance == null) {\n            return;\n        }\n        sAdapterService = instance;\n    }\n\n    private static synchronized void clearAdapterService(AdapterService current) {\n        if (sAdapterService == current) {\n            sAdapterService = null;\n        }\n    }\n\n    private BluetoothAdapter mAdapter;\n    private AdapterProperties mAdapterProperties;\n    private AdapterState mAdapterStateMachine;\n    private BondStateMachine mBondStateMachine;\n    private JniCallbacks mJniCallbacks;\n    private RemoteDevices mRemoteDevices;\n\n    /* TODO: Consider to remove the search API from this class, if changed to use call-back */\n    private SdpManager mSdpManager = null;\n\n    private boolean mNativeAvailable;\n    private boolean mCleaningUp;\n    private final HashMap<BluetoothDevice, ArrayList<IBluetoothMetadataListener>>\n            mMetadataListeners = new HashMap<>();\n    private final HashMap<String, Integer> mProfileServicesState = new HashMap<String, Integer>();\n    private Set<IBluetoothConnectionCallback> mBluetoothConnectionCallbacks = new HashSet<>();\n    //Only BluetoothManagerService should be registered\n    private RemoteCallbackList<IBluetoothCallback> mCallbacks;\n    private int mCurrentRequestId;\n    private boolean mQuietmode = false;\n    private HashMap<String, CallerInfo> mBondAttemptCallerInfo = new HashMap<>();\n\n    private final Map<UUID, RfcommListenerData> mBluetoothServerSockets = new ConcurrentHashMap<>();\n    private final Executor mSocketServersExecutor = r -> new Thread(r).start();\n\n    private AlarmManager mAlarmManager;\n    private PendingIntent mPendingAlarm;\n    private BatteryStatsManager mBatteryStatsManager;\n    private PowerManager mPowerManager;\n    private PowerManager.WakeLock mWakeLock;\n    private String mWakeLockName;\n    private UserManager mUserManager;\n    private CompanionDeviceManager mCompanionDeviceManager;\n\n    private PhonePolicy mPhonePolicy;\n    private ActiveDeviceManager mActiveDeviceManager;\n    private DatabaseManager mDatabaseManager;\n    private SilenceDeviceManager mSilenceDeviceManager;\n    private AppOpsManager mAppOps;\n\n    private BluetoothSocketManagerBinder mBluetoothSocketManagerBinder;\n\n    private BluetoothKeystoreService mBluetoothKeystoreService;\n    private A2dpService mA2dpService;\n    private A2dpSinkService mA2dpSinkService;\n    private ActivityAttributionService mActivityAttributionService;\n    private HeadsetService mHeadsetService;\n    private HeadsetClientService mHeadsetClientService;\n    private BluetoothMapService mMapService;\n    private MapClientService mMapClientService;\n    private HidDeviceService mHidDeviceService;\n    private HidHostService mHidHostService;\n    private PanService mPanService;\n    private BluetoothPbapService mPbapService;\n    private PbapClientService mPbapClientService;\n    private HearingAidService mHearingAidService;\n    private HapClientService mHapClientService;\n    private SapService mSapService;\n    private VolumeControlService mVolumeControlService;\n    private CsipSetCoordinatorService mCsipSetCoordinatorService;\n    private LeAudioService mLeAudioService;\n    private BassClientService mBassClientService;\n    private BatteryService mBatteryService;\n\n    private volatile boolean mTestModeEnabled = false;\n\n    private MetricsLogger mMetricsLogger;\n\n    /**\n     * Register a {@link ProfileService} with AdapterService.\n     *\n     * @param profile the service being added.\n     */\n    public void addProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_REGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Unregister a ProfileService with AdapterService.\n     *\n     * @param profile the service being removed.\n     */\n    public void removeProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_UNREGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Notify AdapterService that a ProfileService has started or stopped.\n     *\n     * @param profile the service being removed.\n     * @param state {@link BluetoothAdapter#STATE_ON} or {@link BluetoothAdapter#STATE_OFF}\n     */\n    public void onProfileServiceStateChanged(ProfileService profile, int state) {\n        if (state != BluetoothAdapter.STATE_ON && state != BluetoothAdapter.STATE_OFF) {\n            throw new IllegalArgumentException(BluetoothAdapter.nameForState(state));\n        }\n        Message m = mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_STATE_CHANGED);\n        m.obj = profile;\n        m.arg1 = state;\n        mHandler.sendMessage(m);\n    }\n\n    /**\n     * Confirm whether the ProfileService is started expectedly.\n     *\n     * @param serviceSampleName the service simple name.\n     * @return true if the service is started expectedly, false otherwise.\n     */\n    public boolean isStartedProfile(String serviceSampleName) {\n        return mStartedProfiles.contains(serviceSampleName);\n    }\n\n    private static final int MESSAGE_PROFILE_SERVICE_STATE_CHANGED = 1;\n    private static final int MESSAGE_PROFILE_SERVICE_REGISTERED = 2;\n    private static final int MESSAGE_PROFILE_SERVICE_UNREGISTERED = 3;\n\n    class AdapterServiceHandler extends Handler {\n        @Override\n        public void handleMessage(Message msg) {\n            verboseLog(\"handleMessage() - Message: \" + msg.what);\n\n            switch (msg.what) {\n                case MESSAGE_PROFILE_SERVICE_STATE_CHANGED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_STATE_CHANGED\");\n                    processProfileServiceStateChanged((ProfileService) msg.obj, msg.arg1);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_REGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_REGISTERED\");\n                    registerProfileService((ProfileService) msg.obj);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_UNREGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_UNREGISTERED\");\n                    unregisterProfileService((ProfileService) msg.obj);\n                    break;\n            }\n        }\n\n        private void registerProfileService(ProfileService profile) {\n            if (mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" already registered.\");\n                return;\n            }\n            mRegisteredProfiles.add(profile);\n        }\n\n        private void unregisterProfileService(ProfileService profile) {\n            if (!mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" not registered (UNREGISTER).\");\n                return;\n            }\n            mRegisteredProfiles.remove(profile);\n        }\n\n        private void processProfileServiceStateChanged(ProfileService profile, int state) {\n            switch (state) {\n                case BluetoothAdapter.STATE_ON:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_ON).\");\n                        return;\n                    }\n                    if (mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" already running.\");\n                        return;\n                    }\n                    mRunningProfiles.add(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT starting triggers hardware\n                    // initializtion. Configuring a device without GATT causes start up failures.\n                    if (GattService.class.getSimpleName().equals(profile.getName())) {\n                        enableNative();\n                    } else if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                            && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n                        mAdapterProperties.onBluetoothReady();\n                        updateUuids();\n                        setBluetoothClassFromConfig();\n                        initProfileServices();\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS_BLE);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_DYNAMIC_AUDIO_BUFFER);\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n                    }\n                    break;\n                case BluetoothAdapter.STATE_OFF:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_OFF).\");\n                        return;\n                    }\n                    if (!mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not running.\");\n                        return;\n                    }\n                    mRunningProfiles.remove(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT is expected to be the only\n                    // profile available in the \"BLE ON\" state. If only GATT is left, send\n                    // BREDR_STOPPED. If GATT is stopped, deinitialize the hardware.\n                    if ((mRunningProfiles.size() == 1 && (GattService.class.getSimpleName()\n                            .equals(mRunningProfiles.get(0).getName())))) {\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n                    } else if (mRunningProfiles.size() == 0) {\n                        disableNative();\n                    }\n                    break;\n                default:\n                    Log.e(TAG, \"Unhandled profile state: \" + state);\n            }\n        }\n    }\n\n    private final AdapterServiceHandler mHandler = new AdapterServiceHandler();\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        initMetricsLogger();\n        debugLog(\"onCreate()\");\n        mDeviceConfigListener.start();\n        mRemoteDevices = new RemoteDevices(this, Looper.getMainLooper());\n        mRemoteDevices.init();\n        clearDiscoveringPackages();\n        mBinder = new AdapterServiceBinder(this);\n        mAdapter = BluetoothAdapter.getDefaultAdapter();\n        mAdapterProperties = new AdapterProperties(this);\n        mAdapterStateMachine = AdapterState.make(this);\n        mJniCallbacks = new JniCallbacks(this, mAdapterProperties);\n        mBluetoothKeystoreService = new BluetoothKeystoreService(isCommonCriteriaMode());\n        mBluetoothKeystoreService.start();\n        int configCompareResult = mBluetoothKeystoreService.getCompareResult();\n\n        // Start tracking Binder latency for the bluetooth process.\n        BluetoothFrameworkInitializer.initializeBinderCallsStats(getApplicationContext());\n\n        // Android TV doesn't show consent dialogs for just works and encryption only le pairing\n        boolean isAtvDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_LEANBACK_ONLY);\n        mUserManager = getSystemService(UserManager.class);\n        initNative(mUserManager.isGuestUser(), isCommonCriteriaMode(), configCompareResult,\n                getInitFlags(), isAtvDevice, getApplicationInfo().dataDir);\n        mNativeAvailable = true;\n        mCallbacks = new RemoteCallbackList<IBluetoothCallback>();\n        mAppOps = getSystemService(AppOpsManager.class);\n        //Load the name and address\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDADDR);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDNAME);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_CLASS_OF_DEVICE);\n        mAlarmManager = getSystemService(AlarmManager.class);\n        mPowerManager = getSystemService(PowerManager.class);\n        mBatteryStatsManager = getSystemService(BatteryStatsManager.class);\n        mCompanionDeviceManager = getSystemService(CompanionDeviceManager.class);\n\n        mBluetoothKeystoreService.initJni();\n\n        mSdpManager = SdpManager.init(this);\n        registerReceiver(mAlarmBroadcastReceiver, new IntentFilter(ACTION_ALARM_WAKEUP));\n\n        mDatabaseManager = new DatabaseManager(this);\n        mDatabaseManager.start(MetadataDatabase.createDatabase(this));\n\n        boolean isAutomotiveDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_AUTOMOTIVE);\n\n        /*\n         * Phone policy is specific to phone implementations and hence if a device wants to exclude\n         * it out then it can be disabled by using the flag below. Phone policy is never used on\n         * Android Automotive OS builds, in favor of a policy currently located in\n         * CarBluetoothService.\n         */\n        if (!isAutomotiveDevice && getResources().getBoolean(R.bool.enable_phone_policy)) {\n            Log.i(TAG, \"Phone policy enabled\");\n            mPhonePolicy = new PhonePolicy(this, new ServiceFactory());\n            mPhonePolicy.start();\n        } else {\n            Log.i(TAG, \"Phone policy disabled\");\n        }\n\n        mActiveDeviceManager = new ActiveDeviceManager(this, new ServiceFactory());\n        mActiveDeviceManager.start();\n\n        mSilenceDeviceManager = new SilenceDeviceManager(this, new ServiceFactory(),\n                Looper.getMainLooper());\n        mSilenceDeviceManager.start();\n\n        mBluetoothSocketManagerBinder = new BluetoothSocketManagerBinder(this);\n\n        mActivityAttributionService = new ActivityAttributionService();\n        mActivityAttributionService.start();\n\n        setAdapterService(this);\n\n        invalidateBluetoothCaches();\n\n        // First call to getSharedPreferences will result in a file read into\n        // memory cache. Call it here asynchronously to avoid potential ANR\n        // in the future\n        new AsyncTask<Void, Void, Void>() {\n            @Override\n            protected Void doInBackground(Void... params) {\n                getSharedPreferences(PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(SIM_ACCESS_PERMISSION_PREFERENCE_FILE, Context.MODE_PRIVATE);\n                return null;\n            }\n        }.execute();\n\n        try {\n            int systemUiUid = getApplicationContext()\n                    .createContextAsUser(UserHandle.SYSTEM, /* flags= */ 0)\n                    .getPackageManager()\n                    .getPackageUid(\"com.android.systemui\", PackageManager.MATCH_SYSTEM_ONLY);\n\n            Utils.setSystemUiUid(systemUiUid);\n        } catch (PackageManager.NameNotFoundException e) {\n            // Some platforms, such as wearables do not have a system ui.\n            Log.w(TAG, \"Unable to resolve SystemUI's UID.\", e);\n        }\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        debugLog(\"onBind()\");\n        return mBinder;\n    }\n\n    @Override\n    public boolean onUnbind(Intent intent) {\n        debugLog(\"onUnbind() - calling cleanup\");\n        cleanup();\n        return super.onUnbind(intent);\n    }\n\n    @Override\n    public void onDestroy() {\n        debugLog(\"onDestroy()\");\n        if (!isMock()) {\n            // TODO(b/27859763)\n            Log.i(TAG, \"Force exit to cleanup internal state in Bluetooth stack\");\n            System.exit(0);\n        }\n    }\n\n    private boolean initMetricsLogger() {\n        if (mMetricsLogger != null) {\n            return false;\n        }\n        mMetricsLogger = MetricsLogger.getInstance();\n        return mMetricsLogger.init(this);\n    }\n\n    private boolean closeMetricsLogger() {\n        if (mMetricsLogger == null) {\n            return false;\n        }\n        boolean result = mMetricsLogger.close();\n        mMetricsLogger = null;\n        return result;\n    }\n\n    public void setMetricsLogger(MetricsLogger metricsLogger) {\n        mMetricsLogger = metricsLogger;\n    }\n\n    void bringUpBle() {\n        debugLog(\"bleOnProcessStart()\");\n\n        if (getResources().getBoolean(\n                R.bool.config_bluetooth_reload_supported_profiles_when_enabled)) {\n            Config.init(getApplicationContext());\n        }\n\n        // Reset |mRemoteDevices| whenever BLE is turned off then on\n        // This is to replace the fact that |mRemoteDevices| was\n        // reinitialized in previous code.\n        //\n        // TODO(apanicke): The reason is unclear but\n        // I believe it is to clear the variable every time BLE was\n        // turned off then on. The same effect can be achieved by\n        // calling cleanup but this may not be necessary at all\n        // We should figure out why this is needed later\n        mRemoteDevices.reset();\n        mAdapterProperties.init(mRemoteDevices);\n\n        debugLog(\"bleOnProcessStart() - Make Bond State Machine\");\n        mBondStateMachine = BondStateMachine.make(this, mAdapterProperties, mRemoteDevices);\n\n        mJniCallbacks.init(mBondStateMachine, mRemoteDevices);\n\n        mBatteryStatsManager.reportBleScanReset();\n        BluetoothStatsLog.write_non_chained(BluetoothStatsLog.BLE_SCAN_STATE_CHANGED, -1, null,\n                BluetoothStatsLog.BLE_SCAN_STATE_CHANGED__STATE__RESET, false, false, false);\n\n        // TODO(b/228875190): GATT is assumed supported. As a result, we don't respect the\n        // configuration sysprop. Configuring a device without GATT, although rare, will cause stack\n        // start up errors yielding init loops.\n        if (!GattService.isEnabled()) {\n            Log.w(TAG,\n                    \"GATT is configured off but the stack assumes it to be enabled. Start anyway.\");\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_ON);\n    }\n\n    void bringDownBle() {\n        stopGattProfileService();\n    }\n\n    void stateChangeCallback(int status) {\n        if (status == AbstractionLayer.BT_STATE_OFF) {\n            debugLog(\"stateChangeCallback: disableNative() completed\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        } else if (status == AbstractionLayer.BT_STATE_ON) {\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STARTED);\n        } else {\n            Log.e(TAG, \"Incorrect status \" + status + \" in stateChangeCallback\");\n        }\n    }\n\n    /**\n     * Sets the Bluetooth CoD value of the local adapter if there exists a config value for it.\n     */\n    void setBluetoothClassFromConfig() {\n        int bluetoothClassConfig = retrieveBluetoothClassConfig();\n        if (bluetoothClassConfig != 0) {\n            mAdapterProperties.setBluetoothClass(new BluetoothClass(bluetoothClassConfig));\n        }\n    }\n\n    private int retrieveBluetoothClassConfig() {\n        return Settings.Global.getInt(\n                getContentResolver(), Settings.Global.BLUETOOTH_CLASS_OF_DEVICE, 0);\n    }\n\n    void startProfileServices() {\n        debugLog(\"startCoreServices()\");\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no other profiles then just\n        // move on to BREDR_STARTED. Note that configuring GATT to NOT supported will cause adapter\n        // initialization failures\n        if (supportedProfileServices.length == 1 && GattService.class.getSimpleName()\n                .equals(supportedProfileServices[0].getSimpleName())) {\n            mAdapterProperties.onBluetoothReady();\n            updateUuids();\n            setBluetoothClassFromConfig();\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_ON);\n        }\n    }\n\n    void stopProfileServices() {\n        // Make sure to stop classic background tasks now\n        cancelDiscoveryNative();\n        mAdapterProperties.setScanMode(AbstractionLayer.BT_SCAN_MODE_NONE);\n\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no profiles then just move on\n        // to BREDR_STOPPED\n        if (supportedProfileServices.length == 1 && (mRunningProfiles.size() == 1\n                && GattService.class.getSimpleName().equals(mRunningProfiles.get(0).getName()))) {\n            debugLog(\"stopProfileServices() - No profiles services to stop or already stopped.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_OFF);\n        }\n    }\n\n    private void stopGattProfileService() {\n        mAdapterProperties.onBleDisable();\n        if (mRunningProfiles.size() == 0) {\n            debugLog(\"stopGattProfileService() - No profiles services to stop.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_OFF);\n    }\n\n    private void invalidateBluetoothGetStateCache() {\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n    }\n\n    void updateLeAudioProfileServiceState() {\n        HashSet<Class> nonSupportedProfiles = new HashSet<>();\n\n        if (!isLeConnectedIsochronousStreamCentralSupported()) {\n            nonSupportedProfiles.addAll(Config.geLeAudioUnicastProfiles());\n        }\n\n        if (!isLeAudioBroadcastAssistantSupported()) {\n            nonSupportedProfiles.add(BassClientService.class);\n        }\n\n        if (isLeAudioBroadcastSourceSupported()) {\n            Config.addSupportedProfile(BluetoothProfile.LE_AUDIO_BROADCAST);\n        }\n\n        if (!nonSupportedProfiles.isEmpty()) {\n            // Remove non-supported profiles from the supported list\n            // since the controller doesn't support\n            Config.removeProfileFromSupportedList(nonSupportedProfiles);\n\n            // Disable the non-supported profiles service\n            for (Class profileService : nonSupportedProfiles) {\n                if (isStartedProfile(profileService.getSimpleName())) {\n                    setProfileServiceState(profileService, BluetoothAdapter.STATE_OFF);\n                }\n            }\n        }\n    }\n\n    void updateAdapterState(int prevState, int newState) {\n        mAdapterProperties.setState(newState);\n        invalidateBluetoothGetStateCache();\n        if (mCallbacks != null) {\n            int n = mCallbacks.beginBroadcast();\n            debugLog(\"updateAdapterState() - Broadcasting state \" + BluetoothAdapter.nameForState(\n                    newState) + \" to \" + n + \" receivers.\");\n            for (int i = 0; i < n; i++) {\n                try {\n                    mCallbacks.getBroadcastItem(i).onBluetoothStateChange(prevState, newState);\n                } catch (RemoteException e) {\n                    debugLog(\"updateAdapterState() - Callback #\" + i + \" failed (\" + e + \")\");\n                }\n            }\n            mCallbacks.finishBroadcast();\n        }\n\n        // Turn the Adapter all the way off if we are disabling and the snoop log setting changed.\n        if (newState == BluetoothAdapter.STATE_BLE_TURNING_ON) {\n            mSnoopLogSettingAtEnable =\n                    System",
        "metrics": {},
        "metrics_status": "Metrics not computed: 'downstream_file_content_ground_truth' is missing."
    },
    {
        "cve_id": "ASB-A-375623125",
        "downstream_version": "14",
        "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
        "ground_truth_codebase": "",
        "llm_patched_codebase": "/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.appop;\n\nimport static android.app.AppOpsManager.ATTRIBUTION_CHAIN_ID_NONE;\nimport static android.app.AppOpsManager.ATTRIBUTION_FLAG_TRUSTED;\nimport static android.app.AppOpsManager.CALL_BACK_ON_SWITCHED_OP;\nimport static android.app.AppOpsManager.FILTER_BY_ATTRIBUTION_TAG;\nimport static android.app.AppOpsManager.FILTER_BY_OP_NAMES;\nimport static android.app.AppOpsManager.FILTER_BY_PACKAGE_NAME;\nimport static android.app.AppOpsManager.FILTER_BY_UID;\nimport static android.app.AppOpsManager.HISTORY_FLAG_GET_ATTRIBUTION_CHAINS;\nimport static android.app.AppOpsManager.HistoricalOpsRequestFilter;\nimport static android.app.AppOpsManager.KEY_BG_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.KEY_FG_SERVICE_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.KEY_TOP_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.MODE_ALLOWED;\nimport static android.app.AppOpsManager.MODE_DEFAULT;\nimport static android.app.AppOpsManager.MODE_ERRORED;\nimport static android.app.AppOpsManager.MODE_FOREGROUND;\nimport static android.app.AppOpsManager.MODE_IGNORED;\nimport static android.app.AppOpsManager.OP_CAMERA;\nimport static android.app.AppOpsManager.OP_CAMERA_SANDBOXED;\nimport static android.app.AppOpsManager.OP_FLAGS_ALL;\nimport static android.app.AppOpsManager.OP_FLAG_SELF;\nimport static android.app.AppOpsManager.OP_FLAG_TRUSTED_PROXIED;\nimport static android.app.AppOpsManager.OP_NONE;\nimport static android.app.AppOpsManager.OP_PLAY_AUDIO;\nimport static android.app.AppOpsManager.OP_RECEIVE_AMBIENT_TRIGGER_AUDIO;\nimport static android.app.AppOpsManager.OP_RECORD_AUDIO;\nimport static android.app.AppOpsManager.OP_RECORD_AUDIO_HOTWORD;\nimport static android.app.AppOpsManager.OP_RECORD_AUDIO_SANDBOXED;\nimport static android.app.AppOpsManager.OP_VIBRATE;\nimport static android.app.AppOpsManager.OnOpStartedListener.START_TYPE_FAILED;\nimport static android.app.AppOpsManager.OnOpStartedListener.START_TYPE_STARTED;\nimport static android.app.AppOpsManager.OpEventProxyInfo;\nimport static android.app.AppOpsManager.RestrictionBypass;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_BOOT_TIME_SAMPLING;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_RARELY_USED;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_UNIFORM;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_UNIFORM_OPS;\nimport static android.app.AppOpsManager.SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE;\nimport static android.app.AppOpsManager._NUM_OP;\nimport static android.app.AppOpsManager.extractFlagsFromKey;\nimport static android.app.AppOpsManager.extractUidStateFromKey;\nimport static android.app.AppOpsManager.modeToName;\nimport static android.app.AppOpsManager.opAllowSystemBypassRestriction;\nimport static android.app.AppOpsManager.opRestrictsRead;\nimport static android.app.AppOpsManager.opToName;\nimport static android.app.AppOpsManager.opToPublicName;\nimport static android.content.pm.PermissionInfo.PROTECTION_DANGEROUS;\nimport static android.content.pm.PermissionInfo.PROTECTION_FLAG_APPOP;\n\nimport static com.android.server.appop.AppOpsService.ModeCallback.ALL_OPS;\n\nimport android.Manifest;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.UserIdInt;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.AppOpsManager.AttributedOpEntry;\nimport android.app.AppOpsManager.AttributionFlags;\nimport android.app.AppOpsManager.HistoricalOps;\nimport android.app.AppOpsManager.Mode;\nimport android.app.AppOpsManager.OpEntry;\nimport android.app.AppOpsManager.OpFlags;\nimport android.app.AppOpsManagerInternal;\nimport android.app.AppOpsManagerInternal.CheckOpsDelegate;\nimport android.app.AsyncNotedAppOp;\nimport android.app.RuntimeAppOpAccessMessage;\nimport android.app.SyncNotedAppOp;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.content.AttributionSource;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.PermissionInfo;\nimport android.content.pm.UserInfo;\nimport android.database.ContentObserver;\nimport android.hardware.camera2.CameraDevice.CAMERA_AUDIO_RESTRICTION;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.HandlerExecutor;\nimport android.os.IBinder;\nimport android.os.PackageTagsList;\nimport android.os.Process;\nimport android.os.RemoteCallback;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.ServiceManager;\nimport android.os.ShellCallback;\nimport android.os.ShellCommand;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.os.storage.StorageManagerInternal;\nimport android.permission.PermissionManager;\nimport android.provider.Settings;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.KeyValueListParser;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\nimport android.util.SparseIntArray;\nimport android.util.TimeUtils;\nimport android.util.Xml;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.Immutable;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.app.IAppOpsActiveCallback;\nimport com.android.internal.app.IAppOpsAsyncNotedCallback;\nimport com.android.internal.app.IAppOpsCallback;\nimport com.android.internal.app.IAppOpsNotedCallback;\nimport com.android.internal.app.IAppOpsService;\nimport com.android.internal.app.IAppOpsStartedCallback;\nimport com.android.internal.app.MessageSamplingConfig;\nimport com.android.internal.compat.IPlatformCompat;\nimport com.android.internal.os.Clock;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.Preconditions;\nimport com.android.internal.util.XmlUtils;\nimport com.android.internal.util.function.pooled.PooledLambda;\nimport com.android.modules.utils.TypedXmlPullParser;\nimport com.android.modules.utils.TypedXmlSerializer;\nimport com.android.server.LocalManagerRegistry;\nimport com.android.server.LocalServices;\nimport com.android.server.LockGuard;\nimport com.android.server.SystemServerInitThreadPool;\nimport com.android.server.SystemServiceManager;\nimport com.android.server.pm.PackageList;\nimport com.android.server.pm.PackageManagerLocal;\nimport com.android.server.pm.UserManagerInternal;\nimport com.android.server.pm.pkg.AndroidPackage;\nimport com.android.server.pm.pkg.PackageState;\nimport com.android.server.pm.pkg.component.ParsedAttribution;\nimport com.android.server.policy.AppOpsPolicy;\n\nimport dalvik.annotation.optimization.NeverCompile;\n\nimport libcore.util.EmptyArray;\n\nimport org.json.JSONException;\nimport org.json.JSONObject;\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.text.SimpleDateFormat;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Consumer;\n\npublic class AppOpsService extends IAppOpsService.Stub {\n    static final String TAG = \"AppOps\";\n    static final boolean DEBUG = false;\n\n    /**\n     * Used for data access validation collection, we wish to only log a specific access once\n     */\n    private final ArraySet<NoteOpTrace> mNoteOpCallerStacktraces = new ArraySet<>();\n\n    /**\n     * Version of the mRecentAccessesFile.\n     * Increment by one every time an upgrade step is added at boot, none currently exists.\n     */\n    private static final int CURRENT_VERSION = 1;\n\n    // Write at most every 30 minutes.\n    static final long WRITE_DELAY = DEBUG ? 1000 : 30*60*1000;\n\n    // Constant meaning that any UID should be matched when dispatching callbacks\n    private static final int UID_ANY = -2;\n\n    private static final int[] OPS_RESTRICTED_ON_SUSPEND = {\n            OP_PLAY_AUDIO,\n            OP_RECORD_AUDIO,\n            OP_CAMERA,\n            OP_VIBRATE,\n    };\n\n    private static final int MAX_UNFORWARDED_OPS = 10;\n    private static final int MAX_UNUSED_POOLED_OBJECTS = 3;\n    private static final int RARELY_USED_PACKAGES_INITIALIZATION_DELAY_MILLIS = 300000;\n\n    final Context mContext;\n    final AtomicFile mStorageFile;\n    final AtomicFile mRecentAccessesFile;\n    private final @Nullable File mNoteOpCallerStacktracesFile;\n    final Handler mHandler;\n\n    /**\n     * Pool for {@link AttributedOp.OpEventProxyInfoPool} to avoid to constantly reallocate new\n     * objects\n     */\n    @GuardedBy(\"this\")\n    final AttributedOp.OpEventProxyInfoPool mOpEventProxyInfoPool =\n            new AttributedOp.OpEventProxyInfoPool(MAX_UNUSED_POOLED_OBJECTS);\n\n    /**\n     * Pool for {@link AttributedOp.InProgressStartOpEventPool} to avoid to constantly reallocate\n     * new objects\n     */\n    @GuardedBy(\"this\")\n    final AttributedOp.InProgressStartOpEventPool mInProgressStartOpEventPool =\n            new AttributedOp.InProgressStartOpEventPool(mOpEventProxyInfoPool,\n                    MAX_UNUSED_POOLED_OBJECTS);\n\n    private final AppOpsManagerInternalImpl mAppOpsManagerInternal\n            = new AppOpsManagerInternalImpl();\n    @Nullable private final DevicePolicyManagerInternal dpmi =\n            LocalServices.getService(DevicePolicyManagerInternal.class);\n\n    private final IPlatformCompat mPlatformCompat = IPlatformCompat.Stub.asInterface(\n            ServiceManager.getService(Context.PLATFORM_COMPAT_SERVICE));\n\n    /**\n     * Registered callbacks, called from {@link #collectAsyncNotedOp}.\n     *\n     * <p>(package name, uid) -> callbacks\n     *\n     * @see #getAsyncNotedOpsKey(String, int)\n     */\n    @GuardedBy(\"this\")\n    private final ArrayMap<Pair<String, Integer>, RemoteCallbackList<IAppOpsAsyncNotedCallback>>\n            mAsyncOpWatchers = new ArrayMap<>();\n\n    /**\n     * Async note-ops collected from {@link #collectAsyncNotedOp} that have not been delivered to a\n     * callback yet.\n     *\n     * <p>(package name, uid) -> list&lt;ops&gt;\n     *\n     * @see #getAsyncNotedOpsKey(String, int)\n     */\n    @GuardedBy(\"this\")\n    private final ArrayMap<Pair<String, Integer>, ArrayList<AsyncNotedAppOp>>\n            mUnforwardedAsyncNotedOps = new ArrayMap<>();\n\n    boolean mWriteNoteOpsScheduled;\n\n    boolean mWriteScheduled;\n    boolean mFastWriteScheduled;\n    final Runnable mWriteRunner = new Runnable() {\n        public void run() {\n            synchronized (AppOpsService.this) {\n                mWriteScheduled = false;\n                mFastWriteScheduled = false;\n                AsyncTask<Void, Void, Void> task = new AsyncTask<Void, Void, Void>() {\n                    @Override protected Void doInBackground(Void... params) {\n                        writeRecentAccesses();\n                        return null;\n                    }\n                };\n                task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void[])null);\n            }\n        }\n    };\n\n    @GuardedBy(\"this\")\n    @VisibleForTesting\n    final SparseArray<UidState> mUidStates = new SparseArray<>();\n\n    volatile @NonNull HistoricalRegistry mHistoricalRegistry = new HistoricalRegistry(this);\n\n    /*\n     * These are app op restrictions imposed per user from various parties.\n     */\n    private final ArrayMap<IBinder, ClientUserRestrictionState> mOpUserRestrictions =\n            new ArrayMap<>();\n\n    /*\n     * These are app op restrictions imposed globally from various parties within the system.\n     */\n    private final ArrayMap<IBinder, ClientGlobalRestrictionState> mOpGlobalRestrictions =\n            new ArrayMap<>();\n\n    SparseIntArray mProfileOwners;\n\n    private volatile CheckOpsDelegateDispatcher mCheckOpsDelegateDispatcher =\n            new CheckOpsDelegateDispatcher(/*policy*/ null, /*delegate*/ null);\n\n    /**\n      * Reverse lookup for {@link AppOpsManager#opToSwitch(int)}. Initialized once and never\n      * changed\n      */\n    private final SparseArray<int[]> mSwitchedOps = new SparseArray<>();\n\n    private ActivityManagerInternal mActivityManagerInternal;\n\n    /** Package sampled for message collection in the current session */\n    @GuardedBy(\"this\")\n    private String mSampledPackage = null;\n\n    /** Appop sampled for message collection in the current session */\n    @GuardedBy(\"this\")\n    private int mSampledAppOpCode = OP_NONE;\n\n    /** Maximum distance for appop to be considered for message collection in the current session */\n    @GuardedBy(\"this\")\n    private int mAcceptableLeftDistance = 0;\n\n    /** Number of messages collected for sampled package and appop in the current session */\n    @GuardedBy(\"this\")\n    private float mMessagesCollectedCount;\n\n    /** List of rarely used packages priorities for message collection */\n    @GuardedBy(\"this\")\n    private ArraySet<String> mRarelyUsedPackages = new ArraySet<>();\n\n    /** Sampling strategy used for current session */\n    @GuardedBy(\"this\")\n    @AppOpsManager.SamplingStrategy\n    private int mSamplingStrategy;\n\n    /** Last runtime permission access message collected and ready for reporting */\n    @GuardedBy(\"this\")\n    private RuntimeAppOpAccessMessage mCollectedRuntimePermissionMessage;\n\n    /** Package Manager internal. Access via {@link #getPackageManagerInternal()} */\n    private @Nullable PackageManagerInternal mPackageManagerInternal;\n\n    /** Package Manager local. Access via {@link #getPackageManagerLocal()} */\n    private @Nullable PackageManagerLocal mPackageManagerLocal;\n\n    /** User Manager internal. Access via {@link #getUserManagerInternal()} */\n    private @Nullable UserManagerInternal mUserManagerInternal;\n\n    /** Interface for app-op modes.*/\n    @VisibleForTesting\n    AppOpsCheckingServiceInterface mAppOpsCheckingService;\n\n    /** Interface for app-op restrictions.*/\n    @VisibleForTesting AppOpsRestrictions mAppOpsRestrictions;\n\n    private AppOpsUidStateTracker mUidStateTracker;\n\n    /** Hands the definition of foreground and uid states */\n    @GuardedBy(\"this\")\n    public AppOpsUidStateTracker getUidStateTracker() {\n        if (mUidStateTracker == null) {\n            mUidStateTracker = new AppOpsUidStateTrackerImpl(\n                    LocalServices.getService(ActivityManagerInternal.class),\n                    mHandler,\n                    r -> {\n                        synchronized (AppOpsService.this) {\n                            r.run();\n                        }\n                    },\n                    Clock.SYSTEM_CLOCK, mConstants);\n\n            mUidStateTracker.addUidStateChangedCallback(new HandlerExecutor(mHandler),\n                    this::onUidStateChanged);\n        }\n        return mUidStateTracker;\n    }\n\n    /**\n     * All times are in milliseconds. These constants are kept synchronized with the system\n     * global Settings. Any access to this class or its fields should be done while\n     * holding the AppOpsService lock.\n     */\n    final class Constants extends ContentObserver {\n\n        /**\n         * How long we want for a drop in uid state from top to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_TOP_STATE_SETTLE_TIME\n         */\n        public long TOP_STATE_SETTLE_TIME;\n\n        /**\n         * How long we want for a drop in uid state from foreground to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_FG_SERVICE_STATE_SETTLE_TIME\n         */\n        public long FG_SERVICE_STATE_SETTLE_TIME;\n\n        /**\n         * How long we want for a drop in uid state from background to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_BG_STATE_SETTLE_TIME\n         */\n        public long BG_STATE_SETTLE_TIME;\n\n        private final KeyValueListParser mParser = new KeyValueListParser(',');\n        private ContentResolver mResolver;\n\n        public Constants(Handler handler) {\n            super(handler);\n            updateConstants();\n        }\n\n        public void startMonitoring(ContentResolver resolver) {\n            mResolver = resolver;\n            mResolver.registerContentObserver(\n                    Settings.Global.getUriFor(Settings.Global.APP_OPS_CONSTANTS),\n                    false, this);\n            updateConstants();\n        }\n\n        @Override\n        public void onChange(boolean selfChange, Uri uri) {\n            updateConstants();\n        }\n\n        private void updateConstants() {\n            String value = mResolver != null ? Settings.Global.getString(mResolver,\n                    Settings.Global.APP_OPS_CONSTANTS) : \"\";\n\n            synchronized (AppOpsService.this) {\n                try {\n                    mParser.setString(value);\n                } catch (IllegalArgumentException e) {\n                    // Failed to parse the settings string, log this and move on\n                    // with defaults.\n                    Slog.e(TAG, \"Bad app ops settings\", e);\n                }\n                TOP_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_TOP_STATE_SETTLE_TIME, 5 * 1000L);\n                FG_SERVICE_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_FG_SERVICE_STATE_SETTLE_TIME, 5 * 1000L);\n                BG_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_BG_STATE_SETTLE_TIME, 1 * 1000L);\n            }\n        }\n\n        void dump(PrintWriter pw) {\n            pw.println(\"  Settings:\");\n\n            pw.print(\"    \"); pw.print(KEY_TOP_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(TOP_STATE_SETTLE_TIME, pw);\n            pw.println();\n            pw.print(\"    \"); pw.print(KEY_FG_SERVICE_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(FG_SERVICE_STATE_SETTLE_TIME, pw);\n            pw.println();\n            pw.print(\"    \"); pw.print(KEY_BG_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(BG_STATE_SETTLE_TIME, pw);\n            pw.println();\n        }\n    }\n\n    @VisibleForTesting\n    final Constants mConstants;\n\n    @VisibleForTesting\n    final class UidState {\n        public final int uid;\n\n        @NonNull\n        public final ArrayMap<String, Ops> pkgOps = new ArrayMap<>();\n\n        // true indicates there is an interested observer, false there isn't but it has such an op\n        //TODO: Move foregroundOps and hasForegroundWatchers into the AppOpsServiceInterface.\n        public SparseBooleanArray foregroundOps;\n        public boolean hasForegroundWatchers;\n\n        public UidState(int uid) {\n            this.uid = uid;\n        }\n\n        public void clear() {\n            mAppOpsCheckingService.removeUid(uid);\n            for (int i = 0; i < pkgOps.size(); i++) {\n                String packageName = pkgOps.keyAt(i);\n                mAppOpsCheckingService.removePackage(packageName, UserHandle.getUserId(uid));\n            }\n        }\n\n        // Functions for uid mode access and manipulation.\n        public SparseIntArray getNonDefaultUidModes() {\n            return mAppOpsCheckingService.getNonDefaultUidModes(uid);\n        }\n\n        public int getUidMode(int op) {\n            return mAppOpsCheckingService.getUidMode(uid, op);\n        }\n\n        public boolean setUidMode(int op, int mode) {\n            return mAppOpsCheckingService.setUidMode(uid, op, mode);\n        }\n\n        @SuppressWarnings(\"GuardedBy\")\n        int evalMode(int op, int mode) {\n            return getUidStateTracker().evalMode(uid, op, mode);\n        }\n\n        public void evalForegroundOps() {\n            foregroundOps = null;\n            foregroundOps = mAppOpsCheckingService.evalForegroundUidOps(uid, foregroundOps);\n            for (int i = pkgOps.size() - 1; i >= 0; i--) {\n                foregroundOps = mAppOpsCheckingService\n                        .evalForegroundPackageOps(pkgOps.valueAt(i).packageName, foregroundOps,\n                                UserHandle.getUserId(uid));\n            }\n            hasForegroundWatchers = false;\n            if (foregroundOps != null) {\n                for (int i = 0;  i < foregroundOps.size(); i++) {\n                    if (foregroundOps.valueAt(i)) {\n                        hasForegroundWatchers = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        @SuppressWarnings(\"GuardedBy\")\n        public int getState() {\n            return getUidStateTracker().getUidState(uid);\n        }\n\n        @SuppressWarnings(\"GuardedBy\")\n        public void dump(PrintWriter pw, long nowElapsed) {\n            getUidStateTracker().dumpUidState(pw, uid, nowElapsed);\n        }\n    }\n\n    final static class Ops extends SparseArray<Op> {\n        final String packageName;\n        final UidState uidState;\n\n        /**\n         * The restriction properties of the package. If {@code null} it could not have been read\n         * yet and has to be refreshed.\n         */\n        @Nullable RestrictionBypass;\n\n        /** Lazily populated cache of attributionTags of this package */\n        final @NonNull ArraySet<String> knownAttributionTags = new ArraySet<>();\n\n        /**\n         * Lazily populated cache of <b>valid</b> attributionTags of this package, a set smaller\n         * than or equal to {@link #knownAttributionTags}.\n         */\n        final @NonNull ArraySet<String> validAttributionTags = new ArraySet<>();\n\n        Ops(String _packageName, UidState _uidState) {\n            packageName = _packageName;\n            uidState = _uidState;\n        }\n    }\n\n    /** Returned from {@link #verifyAndGetBypass(int, String, String, int, String, boolean)}. */\n    private static final class PackageVerificationResult {\n\n        final RestrictionBypass bypass;\n        final boolean isAttributionTagValid;\n\n        PackageVerificationResult(RestrictionBypass bypass, boolean isAttributionTagValid) {\n            this.bypass = bypass;\n            this.isAttributionTagValid = isAttributionTagValid;\n        }\n    }\n\n    final class Op {\n        int op;\n        int uid;\n        final UidState uidState;\n        final @NonNull String packageName;\n\n        /** attributionTag -> AttributedOp */\n        final ArrayMap<String, AttributedOp> mAttributions = new ArrayMap<>(1);\n\n        Op(UidState uidState, String packageName, int op, int uid) {\n            this.op = op;\n            this.uid = uid;\n            this.uidState = uidState;\n            this.packageName = packageName;\n        }\n\n        @Mode int getMode() {\n            return mAppOpsCheckingService.getPackageMode(packageName, this.op,\n                    UserHandle.getUserId(this.uid));\n        }\n        void setMode(@Mode int mode) {\n            mAppOpsCheckingService.setPackageMode(packageName, this.op, mode,\n                    UserHandle.getUserId(this.uid));\n        }\n\n        void removeAttributionsWithNoTime() {\n            for (int i = mAttributions.size() - 1; i >= 0; i--) {\n                if (!mAttributions.valueAt(i).hasAnyTime()) {\n                    mAttributions.removeAt(i);\n                }\n            }\n        }\n\n        private @NonNull AttributedOp getOrCreateAttribution(@NonNull Op parent,\n                @Nullable String attributionTag) {\n            AttributedOp attributedOp;\n\n            attributedOp = mAttributions.get(attributionTag);\n            if (attributedOp == null) {\n                attributedOp = new AttributedOp(AppOpsService.this, attributionTag, parent);\n                mAttributions.put(attributionTag, attributedOp);\n            }\n\n            return attributedOp;\n        }\n\n        @NonNull OpEntry createEntryLocked() {\n            final int numAttributions = mAttributions.size();\n\n            final ArrayMap<String, AppOpsManager.AttributedOpEntry> attributionEntries =\n                    new ArrayMap<>(numAttributions);\n            for (int i = 0; i < numAttributions; i++) {\n                attributionEntries.put(mAttributions.keyAt(i),\n                        mAttributions.valueAt(i).createAttributedOpEntryLocked());\n            }\n\n            return new OpEntry(op, getMode(), attributionEntries);\n        }\n\n        @NonNull OpEntry createSingleAttributionEntryLocked(@Nullable String attributionTag) {\n            final int numAttributions = mAttributions.size();\n\n            final ArrayMap<String, AttributedOpEntry> attributionEntries = new ArrayMap<>(1);\n            for (int i = 0; i < numAttributions; i++) {\n                if (Objects.equals(mAttributions.keyAt(i), attributionTag)) {\n                    attributionEntries.put(mAttributions.keyAt(i),\n                            mAttributions.valueAt(i).createAttributedOpEntryLocked());\n                    break;\n                }\n            }\n\n            return new OpEntry(op, getMode(), attributionEntries);\n        }\n\n        boolean isRunning() {\n            final int numAttributions = mAttributions.size();\n            for (int i = 0; i < numAttributions; i++) {\n                if (mAttributions.valueAt(i).isRunning()) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n\n    final ArrayMap<IBinder, ModeCallback> mModeWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<ActiveCallback>> mActiveWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<StartedCallback>> mStartedWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<NotedCallback>> mNotedWatchers = new ArrayMap<>();\n    final AudioRestrictionManager mAudioRestrictionManager = new AudioRestrictionManager();\n\n    final class ModeCallback extends OnOpModeChangedListener implements DeathRecipient  {\n        /** If mWatchedOpCode==ALL_OPS notify for ops affected by the switch-op */\n        public static final int ALL_OPS = -2;\n\n        // Need to keep this only because stopWatchingMode needs an IAppOpsCallback.\n        // Otherwise we can just use the IBinder object.\n        private final IAppOpsCallback mCallback;\n\n        ModeCallback(IAppOpsCallback callback, int watchingUid, int flags, int watchedOpCode,\n                int callingUid, int callingPid) {\n            super(watchingUid, flags, watchedOpCode, callingUid, callingPid);\n            this.mCallback = callback;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"ModeCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, getWatchingUid());\n            sb.append(\" flags=0x\");\n            sb.append(Integer.toHexString(getFlags()));\n            switch (getWatchedOpCode()) {\n                case OP_NONE:\n                    break;\n                case ALL_OPS:\n                    sb.append(\" op=(all)\");\n                    break;\n                default:\n                    sb.append(\" op=\");\n                    sb.append(opToName(getWatchedOpCode()));\n                    break;\n            }\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, getCallingUid());\n            sb.append(\" pid=\");\n            sb.append(getCallingPid());\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void unlinkToDeath() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingMode(mCallback);\n        }\n\n        @Override\n        public void onOpModeChanged(int op, int uid, String packageName) throws RemoteException {\n            mCallback.opChanged(op, uid, packageName);\n        }\n    }\n\n    final class ActiveCallback implements DeathRecipient {\n        final IAppOpsActiveCallback mCallback;\n        final int mWatchingUid;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        ActiveCallback(IAppOpsActiveCallback callback, int watchingUid, int callingUid,\n                int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"ActiveCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void destroy() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingActive(mCallback);\n        }\n    }\n\n    final class StartedCallback implements DeathRecipient {\n        final IAppOpsStartedCallback mCallback;\n        final int mWatchingUid;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        StartedCallback(IAppOpsStartedCallback callback, int watchingUid, int callingUid,\n                int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"StartedCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void destroy() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingStarted(mCallback);\n        }\n    }\n\n    final class NotedCallback implements DeathRecipient {\n        final IAppOpsNotedCallback mCallback;\n        final",
        "metrics": {},
        "metrics_status": "Metrics not computed: 'downstream_file_content_ground_truth' is missing."
    },
    {
        "cve_id": "ASB-A-353240784",
        "downstream_version": "14",
        "file_name": "services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java",
        "ground_truth_codebase": "",
        "llm_patched_codebase": "/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.appwidget;\n\nimport static android.content.Context.KEYGUARD_SERVICE;\nimport static android.content.Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;\nimport static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\nimport static android.content.res.Resources.ID_NULL;\n\nimport static com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME;\n\nimport android.annotation.UserIdInt;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.AlarmManager;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.AppOpsManagerInternal;\nimport android.app.IApplicationThread;\nimport android.app.IServiceConnection;\nimport android.app.KeyguardManager;\nimport android.app.PendingIntent;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.app.admin.DevicePolicyManagerInternal.OnCrossProfileWidgetProvidersChangeListener;\nimport android.app.usage.UsageEvents;\nimport android.app.usage.UsageStatsManagerInternal;\nimport android.appwidget.AppWidgetManager;\nimport android.appwidget.AppWidgetManagerInternal;\nimport android.appwidget.AppWidgetProviderInfo;\nimport android.appwidget.PendingHostUpdate;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.Intent.FilterComparison;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.ServiceConnection;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.LauncherApps;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.ServiceInfo;\nimport android.content.pm.ShortcutServiceInternal;\nimport android.content.pm.SuspendDialogInfo;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.content.res.TypedArray;\nimport android.content.res.XmlResourceParser;\nimport android.graphics.Point;\nimport android.graphics.drawable.Icon;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.service.appwidget.AppWidgetServiceDumpProto;\nimport android.service.appwidget.WidgetProto;\nimport android.text.TextUtils;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.AttributeSet;\nimport android.util.IntArray;\nimport android.util.LongSparseArray;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\nimport android.util.SparseIntArray;\nimport android.util.SparseLongArray;\nimport android.util.TypedValue;\nimport android.util.TypedXmlPullParser;\nimport android.util.TypedXmlSerializer;\nimport android.util.Xml;\nimport android.util.proto.ProtoOutputStream;\nimport android.view.Display;\nimport android.view.View;\nimport android.widget.RemoteViews;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.app.SuspendedAppActivity;\nimport com.android.internal.app.UnlaunchableAppActivity;\nimport com.android.internal.appwidget.IAppWidgetHost;\nimport com.android.internal.appwidget.IAppWidgetService;\nimport com.android.internal.os.BackgroundThread;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.widget.IRemoteViewsFactory;\nimport com.android.server.LocalServices;\nimport com.android.server.WidgetBackupProvider;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport androidx.annotation.NonNull;\n\nclass AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBackupProvider,\n        OnCrossProfileWidgetProvidersChangeListener {\n    private static final String TAG = \"AppWidgetServiceImpl\";\n\n    private static boolean DEBUG = false;\n\n    private static final String OLD_KEYGUARD_HOST_PACKAGE = \"android\";\n    private static final String NEW_KEYGUARD_HOST_PACKAGE = \"com.android.keyguard\";\n    private static final int KEYGUARD_HOST_ID = 0x4b455947;\n\n    private static final String STATE_FILENAME = \"appwidgets.xml\";\n\n    private static final int MIN_UPDATE_PERIOD = DEBUG ? 0 : 30 * 60 * 1000; // 30 minutes\n\n    private static final int TAG_UNDEFINED = -1;\n\n    private static final int UNKNOWN_UID = -1;\n\n    private static final int UNKNOWN_USER_ID = -10;\n\n    // Bump if the stored widgets need to be upgraded.\n    private static final int CURRENT_VERSION = 1;\n\n    // Every widget update request is associated which an increasing sequence number. This is\n    // used to verify which request has successfully been received by the host.\n    private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n\n    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            final String action = intent.getAction();\n            final int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Received broadcast: \" + action + \" on user \" + userId);\n            }\n\n            switch (action) {\n                case Intent.ACTION_MANAGED_PROFILE_AVAILABLE:\n                case Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE:\n                    synchronized (mLock) {\n                        reloadWidgetsMaskedState(userId);\n                    }\n                    break;\n                case Intent.ACTION_PACKAGES_SUSPENDED:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    updateWidgetPackageSuspensionMaskedState(intent, true, getSendingUserId());\n                    break;\n                case Intent.ACTION_PACKAGES_UNSUSPENDED:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    updateWidgetPackageSuspensionMaskedState(intent, false, getSendingUserId());\n                    break;\n                default:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    break;\n            }\n        }\n    };\n\n    // Manages persistent references to RemoteViewsServices from different App Widgets.\n    private final HashMap<Pair<Integer, FilterComparison>, HashSet<Integer>>\n            mRemoteViewsServicesAppWidgets = new HashMap<>();\n\n    private final Object mLock = new Object();\n\n    private final ArrayList<Widget> mWidgets = new ArrayList<>();\n    private final ArrayList<Host> mHosts = new ArrayList<>();\n    private final ArrayList<Provider> mProviders = new ArrayList<>();\n\n    private final ArraySet<Pair<Integer, String>> mPackagesWithBindWidgetPermission =\n            new ArraySet<>();\n\n    private final SparseBooleanArray mLoadedUserIds = new SparseBooleanArray();\n\n    private final Object mWidgetPackagesLock = new Object();\n    private final SparseArray<ArraySet<String>> mWidgetPackages = new SparseArray<>();\n\n    private BackupRestoreController mBackupRestoreController;\n\n    private final Context mContext;\n\n    private IPackageManager mPackageManager;\n    private AlarmManager mAlarmManager;\n    private UserManager mUserManager;\n    private AppOpsManager mAppOpsManager;\n    private KeyguardManager mKeyguardManager;\n    private DevicePolicyManagerInternal mDevicePolicyManagerInternal;\n    private PackageManagerInternal mPackageManagerInternal;\n    private ActivityManagerInternal mActivityManagerInternal;\n    private AppOpsManagerInternal mAppOpsManagerInternal;\n    private UsageStatsManagerInternal mUsageStatsManagerInternal;\n\n    private SecurityPolicy mSecurityPolicy;\n\n    private Handler mSaveStateHandler;\n    private Handler mCallbackHandler;\n\n    private final SparseIntArray mNextAppWidgetIds = new SparseIntArray();\n\n    private boolean mSafeMode;\n    private int mMaxWidgetBitmapMemory;\n\n    // See {@link Provider#pendingDeletedWidgetIds}.\n    private static final String PENDING_DELETED_IDS_ATTR = \"pending_deleted_ids\";\n\n    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n    // surfaces in the host app.\n    // @see AppWidgetHost\n    // @see AppWidgetHost#mHostId\n    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n    // Hard limit of number of widgets can be pinned by a host.\n    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n\n    AppWidgetServiceImpl(Context context) {\n        mContext = context;\n    }\n\n    public void onStart() {\n        mPackageManager = AppGlobals.getPackageManager();\n        mAlarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);\n        mUserManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n        mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);\n        mKeyguardManager = (KeyguardManager) mContext.getSystemService(KEYGUARD_SERVICE);\n        mDevicePolicyManagerInternal = LocalServices.getService(DevicePolicyManagerInternal.class);\n        mPackageManagerInternal = LocalServices.getService(PackageManagerInternal.class);\n        mSaveStateHandler = BackgroundThread.getHandler();\n        mCallbackHandler = new CallbackHandler(mContext.getMainLooper());\n        mBackupRestoreController = new BackupRestoreController();\n        mSecurityPolicy = new SecurityPolicy();\n\n        computeMaximumWidgetBitmapMemory();\n        registerBroadcastReceiver();\n        registerOnCrossProfileProvidersChangedListener();\n\n        LocalServices.addService(AppWidgetManagerInternal.class, new AppWidgetManagerLocal());\n    }\n\n    void systemServicesReady() {\n        mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);\n        mAppOpsManagerInternal = LocalServices.getService(AppOpsManagerInternal.class);\n        mUsageStatsManagerInternal = LocalServices.getService(UsageStatsManagerInternal.class);\n    }\n\n    private void computeMaximumWidgetBitmapMemory() {\n        Display display = mContext.getDisplayNoVerify();\n        Point size = new Point();\n        display.getRealSize(size);\n        // Cap memory usage at 1.5 times the size of the display\n        // 1.5 * 4 bytes/pixel * w * h ==> 6 * w * h\n        mMaxWidgetBitmapMemory = 6 * size.x * size.y;\n    }\n\n    private void registerBroadcastReceiver() {\n        // Register for broadcasts about package install, etc., so we can\n        // update the provider list.\n        IntentFilter packageFilter = new IntentFilter();\n        packageFilter.addAction(Intent.ACTION_PACKAGE_ADDED);\n        packageFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);\n        packageFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);\n        packageFilter.addDataScheme(\"package\");\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                packageFilter, null, null);\n\n        // Register for events related to sdcard installation.\n        IntentFilter sdFilter = new IntentFilter();\n        sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);\n        sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                sdFilter, null, null);\n\n        IntentFilter offModeFilter = new IntentFilter();\n        offModeFilter.addAction(Intent.ACTION_MANAGED_PROFILE_AVAILABLE);\n        offModeFilter.addAction(Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                offModeFilter, null, null);\n\n        IntentFilter suspendPackageFilter = new IntentFilter();\n        suspendPackageFilter.addAction(Intent.ACTION_PACKAGES_SUSPENDED);\n        suspendPackageFilter.addAction(Intent.ACTION_PACKAGES_UNSUSPENDED);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                suspendPackageFilter, null, null);\n    }\n\n    private void registerOnCrossProfileProvidersChangedListener() {\n        // The device policy is an optional component.\n        if (mDevicePolicyManagerInternal != null) {\n            mDevicePolicyManagerInternal.addOnCrossProfileWidgetProvidersChangeListener(this);\n        }\n    }\n\n    public void setSafeMode(boolean safeMode) {\n        mSafeMode = safeMode;\n    }\n\n    private void onPackageBroadcastReceived(Intent intent, int userId) {\n        final String action = intent.getAction();\n        boolean added = false;\n        boolean changed = false;\n        boolean componentsModified = false;\n\n        final String pkgList[];\n        switch (action) {\n            case Intent.ACTION_PACKAGES_SUSPENDED:\n            case Intent.ACTION_PACKAGES_UNSUSPENDED:\n                pkgList = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                changed = true;\n                break;\n            case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:\n                added = true;\n                // Follow through\n            case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:\n                pkgList = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                break;\n            default: {\n                Uri uri = intent.getData();\n                if (uri == null) {\n                    return;\n                }\n                String pkgName = uri.getSchemeSpecificPart();\n                if (pkgName == null) {\n                    return;\n                }\n                pkgList = new String[] { pkgName };\n                added = Intent.ACTION_PACKAGE_ADDED.equals(action);\n                changed = Intent.ACTION_PACKAGE_CHANGED.equals(action);\n            }\n        }\n        if (pkgList == null || pkgList.length == 0) {\n            return;\n        }\n\n        synchronized (mLock) {\n            if (!mUserManager.isUserUnlockingOrUnlocked(userId) ||\n                    isProfileWithLockedParent(userId)) {\n                return;\n            }\n            ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ false);\n\n            Bundle extras = intent.getExtras();\n\n            if (added || changed) {\n                final boolean newPackageAdded = added && (extras == null\n                        || !extras.getBoolean(Intent.EXTRA_REPLACING, false));\n\n                for (String pkgName : pkgList) {\n                    // Fix up the providers - add/remove/update.\n                    componentsModified |= updateProvidersForPackageLocked(pkgName, userId, null);\n\n                    // ... and see if these are hosts we've been awaiting.\n                    // NOTE: We are backing up and restoring only the owner.\n                    // TODO: http://b/22388012\n                    if (newPackageAdded && userId == UserHandle.USER_SYSTEM) {\n                        final int uid = getUidForPackage(pkgName, userId);\n                        if (uid >= 0 ) {\n                            resolveHostUidLocked(pkgName, uid);\n                        }\n                    }\n                }\n            } else {\n                // If the package is being updated, we'll receive a PACKAGE_ADDED\n                // shortly, otherwise it is removed permanently.\n                final boolean packageRemovedPermanently = (extras == null\n                        || !extras.getBoolean(Intent.EXTRA_REPLACING, false));\n\n                if (packageRemovedPermanently) {\n                    for (String pkgName : pkgList) {\n                        componentsModified |= removeHostsAndProvidersForPackageLocked(\n                                pkgName, userId);\n                    }\n                }\n            }\n\n            if (componentsModified) {\n                saveGroupStateAsync(userId);\n\n                // If the set of providers has been modified, notify each active AppWidgetHost\n                scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n                // Possibly notify any new components of widget id changes\n                mBackupRestoreController.widgetComponentsChanged(userId);\n            }\n        }\n    }\n\n    /**\n     * Reload all widgets' masked state for the given user and its associated profiles, including\n     * due to user not being available and package suspension.\n     * userId must be the group parent.\n     */\n    void reloadWidgetsMaskedStateForGroup(int userId) {\n        if (!mUserManager.isUserUnlockingOrUnlocked(userId)) {\n            return;\n        }\n        synchronized (mLock) {\n            reloadWidgetsMaskedState(userId);\n            int[] profileIds = mUserManager.getEnabledProfileIds(userId);\n            for (int profileId : profileIds) {\n                reloadWidgetsMaskedState(profileId);\n            }\n        }\n    }\n\n    private void reloadWidgetsMaskedState(int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            UserInfo user  = mUserManager.getUserInfo(userId);\n\n            boolean lockedProfile = !mUserManager.isUserUnlockingOrUnlocked(userId);\n            boolean quietProfile = user.isQuietModeEnabled();\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                int providerUserId = provider.getUserId();\n                if (providerUserId != userId) {\n                    continue;\n                }\n\n                boolean changed = provider.setMaskedByLockedProfileLocked(lockedProfile);\n                changed |= provider.setMaskedByQuietProfileLocked(quietProfile);\n                try {\n                    boolean suspended;\n                    try {\n                        suspended = mPackageManager.isPackageSuspendedForUser(\n                                provider.id.componentName.getPackageName(), provider.getUserId());\n                    } catch (IllegalArgumentException ex) {\n                        // Package not found.\n                        suspended = false;\n                    }\n                    changed |= provider.setMaskedBySuspendedPackageLocked(suspended);\n                } catch (RemoteException e) {\n                    Slog.e(TAG, \"Failed to query application info\", e);\n                }\n                if (changed) {\n                    if (provider.isMaskedLocked()) {\n                        maskWidgetsViewsLocked(provider, null);\n                    } else {\n                        unmaskWidgetsViewsLocked(provider);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    /**\n     * Incrementally update the masked state due to package suspension state.\n     */\n    private void updateWidgetPackageSuspensionMaskedState(Intent intent, boolean suspended,\n            int profileId) {\n        String[] packagesArray = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n        if (packagesArray == null) {\n            return;\n        }\n        Set<String> packages = new ArraySet<>(Arrays.asList(packagesArray));\n        synchronized (mLock) {\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                int providerUserId = provider.getUserId();\n                if (providerUserId != profileId\n                        || !packages.contains(provider.id.componentName.getPackageName())) {\n                    continue;\n                }\n                if (provider.setMaskedBySuspendedPackageLocked(suspended)) {\n                    if (provider.isMaskedLocked()) {\n                        maskWidgetsViewsLocked(provider, null);\n                    } else {\n                        unmaskWidgetsViewsLocked(provider);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Mask the target widget belonging to the specified provider, or all active widgets\n     * of the provider if target widget == null.\n     */\n    private void maskWidgetsViewsLocked(Provider provider, Widget targetWidget) {\n        final int widgetCount = provider.widgets.size();\n        if (widgetCount == 0) {\n            return;\n        }\n        RemoteViews views = new RemoteViews(mContext.getPackageName(),\n                R.layout.work_widget_mask_view);\n        ApplicationInfo appInfo = provider.info.providerInfo.applicationInfo;\n        final int appUserId = provider.getUserId();\n        boolean showBadge;\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final Intent onClickIntent;\n\n            if (provider.maskedBySuspendedPackage) {\n                showBadge = mUserManager.hasBadge(appUserId);\n                final String suspendingPackage = mPackageManagerInternal.getSuspendingPackage(\n                        appInfo.packageName, appUserId);\n                if (PLATFORM_PACKAGE_NAME.equals(suspendingPackage)) {\n                    onClickIntent = mDevicePolicyManagerInternal.createShowAdminSupportIntent(\n                            appUserId, true);\n                } else {\n                    final SuspendDialogInfo dialogInfo =\n                            mPackageManagerInternal.getSuspendedDialogInfo(\n                                    appInfo.packageName, suspendingPackage, appUserId);\n                    // onUnsuspend is null because we don't want to start any activity on\n                    // unsuspending from a suspended widget.\n                    onClickIntent = SuspendedAppActivity.createSuspendedAppInterceptIntent(\n                            appInfo.packageName, suspendingPackage, dialogInfo, null, null,\n                            appUserId);\n                }\n            } else if (provider.maskedByQuietProfile) {\n                showBadge = true;\n                onClickIntent = UnlaunchableAppActivity.createInQuietModeDialogIntent(appUserId);\n            } else /* provider.maskedByLockedProfile */ {\n                showBadge = true;\n                onClickIntent = mKeyguardManager\n                        .createConfirmDeviceCredentialIntent(null, null, appUserId);\n                if (onClickIntent != null) {\n                    onClickIntent.setFlags(\n                            FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);\n                }\n            }\n\n            if (onClickIntent != null) {\n                views.setOnClickPendingIntent(android.R.id.background,\n                        PendingIntent.getActivity(mContext, 0, onClickIntent,\n                                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE));\n            }\n\n            Icon icon = appInfo.icon != 0\n                    ? Icon.createWithResource(appInfo.packageName, appInfo.icon)\n                    : Icon.createWithResource(mContext, android.R.drawable.sym_def_app_icon);\n            views.setImageViewIcon(R.id.work_widget_app_icon, icon);\n            if (!showBadge) {\n                views.setViewVisibility(R.id.work_widget_badge_icon, View.INVISIBLE);\n            }\n\n            for (int j = 0; j < widgetCount; j++) {\n                Widget widget = provider.widgets.get(j);\n                if (targetWidget != null && targetWidget != widget) continue;\n                if (widget.replaceWithMaskedViewsLocked(views)) {\n                    scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void unmaskWidgetsViewsLocked(Provider provider) {\n        final int widgetCount = provider.widgets.size();\n        for (int j = 0; j < widgetCount; j++) {\n            Widget widget = provider.widgets.get(j);\n            if (widget.clearMaskedViewsLocked()) {\n                scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n            }\n        }\n    }\n\n    private void resolveHostUidLocked(String pkg, int uid) {\n        final int N = mHosts.size();\n        for (int i = 0; i < N; i++) {\n            Host host = mHosts.get(i);\n            if (host.id.uid == UNKNOWN_UID && pkg.equals(host.id.packageName)) {\n                if (DEBUG) {\n                    Slog.i(TAG, \"host \" + host.id + \" resolved to uid \" + uid);\n                }\n                host.id = new HostId(uid, host.id.hostId, host.id.packageName);\n                return;\n            }\n        }\n    }\n\n    private void ensureGroupStateLoadedLocked(int userId) {\n        ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ true );\n    }\n\n    private void ensureGroupStateLoadedLocked(int userId, boolean enforceUserUnlockingOrUnlocked) {\n        if (enforceUserUnlockingOrUnlocked && !isUserRunningAndUnlocked(userId)) {\n            throw new IllegalStateException(\n                    \"User \" + userId + \" must be unlocked for widgets to be available\");\n        }\n        if (enforceUserUnlockingOrUnlocked && isProfileWithLockedParent(userId)) {\n            throw new IllegalStateException(\n                    \"Profile \" + userId + \" must have unlocked parent\");\n        }\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        IntArray newIds = new IntArray(1);\n        for (int profileId : profileIds) {\n            if (!mLoadedUserIds.get(profileId)) {\n                mLoadedUserIds.put(profileId, true);\n                newIds.add(profileId);\n            }\n        }\n        if (newIds.size() <= 0) {\n            return;\n        }\n        final int[] newProfileIds = newIds.toArray();\n        clearProvidersAndHostsTagsLocked();\n\n        loadGroupWidgetProvidersLocked(newProfileIds);\n        loadGroupStateLocked(newProfileIds);\n    }\n\n    private boolean isUserRunningAndUnlocked(@UserIdInt int userId) {\n        return mUserManager.isUserUnlockingOrUnlocked(userId);\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {\n        if (!DumpUtils.checkDumpPermission(mContext, TAG, pw)) return;\n\n        synchronized (mLock) {\n            if (args.length > 0 && \"--proto\".equals(args[0])) {\n                dumpProto(fd);\n            } else {\n                dumpInternalLocked(pw);\n            }\n        }\n    }\n\n    private void dumpProto(FileDescriptor fd) {\n        Slog.i(TAG, \"dump proto for \" + mWidgets.size() + \" widgets\");\n\n        ProtoOutputStream proto = new ProtoOutputStream(fd);\n        int N = mWidgets.size();\n        for (int i=0; i < N; i++) {\n            dumpProtoWidget(proto, mWidgets.get(i));\n        }\n        proto.flush();\n    }\n\n    private void dumpProtoWidget(ProtoOutputStream proto, Widget widget) {\n        if (widget.host == null || widget.provider == null) {\n            Slog.d(TAG, \"skip dumping widget because host or provider is null: widget.host=\"\n                + widget.host + \" widget.provider=\"  + widget.provider);\n            return;\n        }\n        long token = proto.start(AppWidgetServiceDumpProto.WIDGETS);\n        proto.write(WidgetProto.IS_CROSS_PROFILE,\n            widget.host.getUserId() != widget.provider.getUserId());\n        proto.write(WidgetProto.IS_HOST_STOPPED, widget.host.callbacks == null);\n        proto.write(WidgetProto.HOST_PACKAGE, widget.host.id.packageName);\n        proto.write(WidgetProto.PROVIDER_PACKAGE, widget.provider.id.componentName.getPackageName());\n        proto.write(WidgetProto.PROVIDER_CLASS, widget.provider.id.componentName.getClassName());\n        if (widget.options != null) {\n            proto.write(WidgetProto.RESTORE_COMPLETED,\n                    widget.options.getBoolean(AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED));\n            proto.write(WidgetProto.MIN_WIDTH,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH, 0));\n            proto.write(WidgetProto.MIN_HEIGHT,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, 0));\n            proto.write(WidgetProto.MAX_WIDTH,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH, 0));\n            proto.write(WidgetProto.MAX_HEIGHT,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, 0));\n        }\n        proto.end(token);\n    }\n\n    private void dumpInternalLocked(PrintWriter pw) {\n        int N = mProviders.size();\n        pw.println(\"Providers:\");\n        for (int i = 0; i < N; i++) {\n            dumpProviderLocked(mProviders.get(i), i, pw);\n        }\n\n        N = mWidgets.size();\n        pw.println(\" \");\n        pw.println(\"Widgets:\");\n        for (int i = 0; i < N; i++) {\n            dumpWidget(mWidgets.get(i), i, pw);\n        }\n\n        N = mHosts.size();\n        pw.println(\" \");\n        pw.println(\"Hosts:\");\n        for (int i = 0; i < N; i++) {\n            dumpHost(mHosts.get(i), i, pw);\n        }\n\n        N = mPackagesWithBindWidgetPermission.size();\n        pw.println(\" \");\n        pw.println(\"Grants:\");\n        for (int i = 0; i < N; i++) {\n            Pair<Integer, String> grant = mPackagesWithBindWidgetPermission.valueAt(i);\n            dumpGrant(grant, i, pw);\n        }\n    }\n\n    @Override\n    public ParceledListSlice<PendingHostUpdate> startListening(IAppWidgetHost callbacks,\n            String callingPackage, int hostId, int[] appWidgetIds) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"startListening() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            // Instant apps cannot host app widgets.\n            if (mSecurityPolicy.isInstantAppLocked(callingPackage, userId)) {\n                Slog.w(TAG, \"Instant package \" + callingPackage + \" cannot host app widgets\");\n                return ParceledListSlice.emptyList();\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupOrAddHostLocked(id);\n            host.callbacks = callbacks;\n\n            long updateSequenceNo = UPDATE_COUNTER.incrementAndGet();\n            int N = appWidgetIds.length;\n            ArrayList<PendingHostUpdate> outUpdates = new ArrayList<>(N);\n            LongSparseArray<PendingHostUpdate> updatesMap = new LongSparseArray<>();\n            for (int i = 0; i < N; i++) {\n                updatesMap.clear();\n                host.getPendingUpdatesForIdLocked(mContext, appWidgetIds[i], updatesMap);\n                // We key the updates based on request id, so that the values are sorted in the\n                // order they were received.\n                int m = updatesMap.size();\n                for (int j = 0; j < m; j++) {\n                    outUpdates.add(updatesMap.valueAt(j));\n                }\n            }\n            // Reset the update counter once all the updates have been calculated\n            host.lastWidgetUpdateSequenceNo = updateSequenceNo;\n            return new ParceledListSlice<>(outUpdates);\n        }\n    }\n\n    @Override\n    public void stopListening(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"stopListening() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ false);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host != null) {\n                host.callbacks = null;\n                pruneHostLocked(host);\n                mAppOpsManagerInternal.updateAppWidgetVisibility(host.getWidgetUids(), false);\n            }\n        }\n    }\n\n    @Override\n    public int allocateAppWidgetId(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"allocateAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {",
        "metrics": {},
        "metrics_status": "Metrics not computed: 'downstream_file_content_ground_truth' is missing."
    },
    {
        "cve_id": "ASB-A-382064697",
        "downstream_version": "14",
        "file_name": "services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java",
        "ground_truth_codebase": "",
        "llm_patched_codebase": "/*\n * Copyright (C) 2010 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.devicepolicy;\n\nimport static android.Manifest.permission.BIND_DEVICE_ADMIN;\nimport static android.Manifest.permission.LOCK_DEVICE;\nimport static android.Manifest.permission.MANAGE_CA_CERTIFICATES;\nimport static android.Manifest.permission.MANAGE_DEFAULT_APPLICATIONS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ACROSS_USERS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_AIRPLANE_MODE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_APPS_CONTROL;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_APP_RESTRICTIONS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_AUDIO_OUTPUT;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_AUTOFILL;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_BLUETOOTH;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_CALLS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_CAMERA;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_CERTIFICATES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_COMMON_CRITERIA_MODE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_DEFAULT_SMS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_DISPLAY;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_FACTORY_RESET;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_FUN;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_INPUT_METHODS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_KEYGUARD;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCALE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCATION;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCK;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCK_TASK;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_MICROPHONE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_MOBILE_NETWORK;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_MODIFY_USERS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_MTE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PACKAGE_STATE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PRINTING;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PROFILES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PROFILE_INTERACTION;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_RESET_PASSWORD;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_RUN_IN_BACKGROUND;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SAFE_BOOT;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SCREEN_CAPTURE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SCREEN_CONTENT;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SECURITY_LOGGING;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SMS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_STATUS_BAR;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SYSTEM_UPDATES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_TIME;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_VPN;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_WALLPAPER;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_WIFI;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_WINDOWS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_WIPE_DATA;\nimport static android.Manifest.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS;\nimport static android.Manifest.permission.MASTER_CLEAR;\nimport static android.Manifest.permission.QUERY_ADMIN_POLICY;\nimport static android.Manifest.permission.REQUEST_PASSWORD_COMPLEXITY;\nimport static android.Manifest.permission.SET_TIME;\nimport static android.Manifest.permission.SET_TIME_ZONE;\nimport static android.accessibilityservice.AccessibilityServiceInfo.FEEDBACK_ALL_MASK;\nimport static android.accounts.AccountManager.LOGIN_ACCOUNTS_CHANGED_ACTION;\nimport static android.app.ActivityManager.LOCK_TASK_MODE_NONE;\nimport static android.app.AppOpsManager.MODE_ALLOWED;\nimport static android.app.AppOpsManager.MODE_DEFAULT;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_ACTIVITY_BG_START_RESTRICTION;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_DISMISSIBLE_NOTIFICATIONS;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_HIBERNATION;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_POWER_RESTRICTIONS;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_SUSPENSION;\nimport static android.app.admin.DeviceAdminInfo.HEADLESS_DEVICE_OWNER_MODE_AFFILIATED;\nimport static android.app.admin.DeviceAdminInfo.USES_POLICY_FORCE_LOCK;\nimport static android.app.admin.DeviceAdminInfo.USES_POLICY_WIPE_DATA;\nimport static android.app.admin.DeviceAdminReceiver.ACTION_COMPLIANCE_ACKNOWLEDGEMENT_REQUIRED;\nimport static android.app.admin.DeviceAdminReceiver.EXTRA_TRANSFER_OWNERSHIP_ADMIN_EXTRAS_BUNDLE;\nimport static android.app.admin.DevicePolicyIdentifiers.AUTO_TIMEZONE_POLICY;\nimport static android.app.admin.DevicePolicyManager.ACTION_CHECK_POLICY_COMPLIANCE;\nimport static android.app.admin.DevicePolicyManager.ACTION_DEVICE_FINANCING_STATE_CHANGED;\nimport static android.app.admin.DevicePolicyManager.ACTION_DEVICE_POLICY_RESOURCE_UPDATED;\nimport static android.app.admin.DevicePolicyManager.ACTION_MANAGED_PROFILE_PROVISIONED;\nimport static android.app.admin.DevicePolicyManager.ACTION_PROVISION_MANAGED_DEVICE;\nimport static android.app.admin.DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE;\nimport static android.app.admin.DevicePolicyManager.ACTION_PROVISION_MANAGED_USER;\nimport static android.app.admin.DevicePolicyManager.ACTION_SYSTEM_UPDATE_POLICY_CHANGED;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_APP_RESTRICTIONS;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_BLOCK_UNINSTALL;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_CERT_INSTALL;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_CERT_SELECTION;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_ENABLE_SYSTEM_APP;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_INSTALL_EXISTING_PACKAGE;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_KEEP_UNINSTALLED_PACKAGES;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_NETWORK_LOGGING;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_PACKAGE_ACCESS;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_PERMISSION_GRANT;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_SECURITY_LOGGING;\nimport static android.app.admin.DevicePolicyManager.DEVICE_OWNER_TYPE_DEFAULT;\nimport static android.app.admin.DevicePolicyManager.DEVICE_OWNER_TYPE_FINANCED;\nimport static android.app.admin.DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE_PER_USER;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_ACTIVITY_BG_START_RESTRICTION;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_DISMISSIBLE_NOTIFICATIONS;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_HIBERNATION;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_POWER_RESTRICTIONS;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_SUSPENSION;\nimport static android.app.admin.DevicePolicyManager.EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE;\nimport static android.app.admin.DevicePolicyManager.EXTRA_RESOURCE_IDS;\nimport static android.app.admin.DevicePolicyManager.EXTRA_RESOURCE_TYPE;\nimport static android.app.admin.DevicePolicyManager.EXTRA_RESOURCE_TYPE_DRAWABLE;\nimport static android.app.admin.DevicePolicyManager.EXTRA_RESOURCE_TYPE_STRING;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_BASE_INFO;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_IMEI;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_INDIVIDUAL_ATTESTATION;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_MEID;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_SERIAL;\nimport static android.app.admin.DevicePolicyManager.LEAVE_ALL_SYSTEM_APPS_ENABLED;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_BLOCK_ACTIVITY_START_IN_TASK;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_GLOBAL_ACTIONS;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_HOME;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_KEYGUARD;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_NOTIFICATIONS;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_OVERVIEW;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_SYSTEM_INFO;\nimport static android.app.admin.DevicePolicyManager.NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY;\nimport static android.app.admin.DevicePolicyManager.NON_ORG_OWNED_PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;\nimport static android.app.admin.DevicePolicyManager.OPERATION_SAFETY_REASON_NONE;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_COMPLEXITY_HIGH;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_COMPLEXITY_LOW;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_COMPLEXITY_MEDIUM;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_COMPLEXITY_NONE;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_COMPLEX;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_MANAGED;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_NUMERIC;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_NUMERIC_COMPLEX;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_SOMETHING;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED;\nimport static android.app.admin.DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT;\nimport static android.app.admin.DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED;\nimport static android.app.admin.DevicePolicyManager.PERSONAL_APPS_NOT_SUSPENDED;\nimport static android.app.admin.DevicePolicyManager.PERSONAL_APPS_SUSPENDED_EXPLICITLY;\nimport static android.app.admin.DevicePolicyManager.PERSONAL_APPS_SUSPENDED_PROFILE_TIMEOUT;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_MODE_OFF;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_MODE_OPPORTUNISTIC;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_MODE_PROVIDER_HOSTNAME;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_MODE_UNKNOWN;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_SET_ERROR_FAILURE_SETTING;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_SET_NO_ERROR;\nimport static android.app.admin.DevicePolicyManager.PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;\nimport static android.app.admin.DevicePolicyManager.STATE_USER_SETUP_FINALIZED;\nimport static android.app.admin.DevicePolicyManager.STATE_USER_UNMANAGED;\nimport static android.app.admin.DevicePolicyManager.STATUS_ACCOUNTS_NOT_EMPTY;\nimport static android.app.admin.DevicePolicyManager.STATUS_CANNOT_ADD_MANAGED_PROFILE;\nimport static android.app.admin.DevicePolicyManager.STATUS_DEVICE_ADMIN_NOT_SUPPORTED;\nimport static android.app.admin.DevicePolicyManager.STATUS_HAS_DEVICE_OWNER;\nimport static android.app.admin.DevicePolicyManager.STATUS_HAS_PAIRED;\nimport static android.app.admin.DevicePolicyManager.STATUS_HEADLESS_SYSTEM_USER_MODE_NOT_SUPPORTED;\nimport static android.app.admin.DevicePolicyManager.STATUS_MANAGED_USERS_NOT_SUPPORTED;\nimport static android.app.admin.DevicePolicyManager.STATUS_NONSYSTEM_USER_EXISTS;\nimport static android.app.admin.DevicePolicyManager.STATUS_NOT_SYSTEM_USER;\nimport static android.app.admin.DevicePolicyManager.STATUS_OK;\nimport static android.app.admin.DevicePolicyManager.STATUS_PROVISIONING_NOT_ALLOWED_FOR_NON_DEVELOPER_USERS;\nimport static android.app.admin.DevicePolicyManager.STATUS_SYSTEM_USER;\nimport static android.app.admin.DevicePolicyManager.STATUS_USER_HAS_PROFILE_OWNER;\nimport static android.app.admin.DevicePolicyManager.STATUS_USER_NOT_RUNNING;\nimport static android.app.admin.DevicePolicyManager.STATUS_USER_SETUP_COMPLETED;\nimport static android.app.admin.DevicePolicyManager.WIPE_EUICC;\nimport static android.app.admin.DevicePolicyManager.WIPE_EXTERNAL_STORAGE;\nimport static android.app.admin.DevicePolicyManager.WIPE_RESET_PROTECTION_DATA;\nimport static android.app.admin.DevicePolicyManager.WIPE_SILENTLY;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.LOCATION_CHANGED_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.LOCATION_CHANGED_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.NETWORK_LOGGING_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.NETWORK_LOGGING_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.NOTIFICATION_WORK_PROFILE_CONTENT_DESCRIPTION;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PERSONAL_APP_SUSPENSION_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PERSONAL_APP_SUSPENSION_SOON_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PERSONAL_APP_SUSPENSION_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PERSONAL_APP_SUSPENSION_TURN_ON_PROFILE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PRINTING_DISABLED_NAMED_ADMIN;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_DELETED_FAILED_PASSWORD_ATTEMPTS_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_DELETED_GENERIC_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_DELETED_ORG_OWNED_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_DELETED_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_TELEPHONY_PAUSED_BODY;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_TELEPHONY_PAUSED_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_TELEPHONY_PAUSED_TURN_ON_BUTTON;\nimport static android.app.admin.ProvisioningException.ERROR_ADMIN_PACKAGE_INSTALLATION_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_PRE_CONDITION_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_PROFILE_CREATION_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_REMOVE_NON_REQUIRED_APPS_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_SETTING_PROFILE_OWNER_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_SET_DEVICE_OWNER_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_STARTING_PROFILE_FAILED;\nimport static android.content.Intent.ACTION_MANAGED_PROFILE_AVAILABLE;\nimport static android.content.Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE;\nimport static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\nimport static android.content.pm.PackageManager.GET_META_DATA;\nimport static android.content.pm.PackageManager.MATCH_DIRECT_BOOT_AWARE;\nimport static android.content.pm.PackageManager.MATCH_DIRECT_BOOT_UNAWARE;\nimport static android.content.pm.PackageManager.MATCH_UNINSTALLED_PACKAGES;\nimport static android.content.pm.PackageManager.PERMISSION_GRANTED;\nimport static android.net.ConnectivityManager.PROFILE_NETWORK_PREFERENCE_DEFAULT;\nimport static android.net.ConnectivityManager.PROFILE_NETWORK_PREFERENCE_ENTERPRISE;\nimport static android.net.ConnectivityManager.PROFILE_NETWORK_PREFERENCE_ENTERPRISE_BLOCKING;\nimport static android.net.ConnectivityManager.PROFILE_NETWORK_PREFERENCE_ENTERPRISE_NO_FALLBACK;\nimport static android.net.NetworkStack.PERMISSION_MAINLINE_NETWORK_STACK;\nimport static android.provider.DeviceConfig.NAMESPACE_DEVICE_POLICY_MANAGER;\nimport static android.provider.Settings.Global.PRIVATE_DNS_SPECIFIER;\nimport static android.provider.Settings.Secure.MANAGED_PROVISIONING_DPC_DOWNLOADED;\nimport static android.provider.Settings.Secure.USER_SETUP_COMPLETE;\nimport static android.provider.Telephony.Carriers.DPC_URI;\nimport static android.provider.Telephony.Carriers.ENFORCE_KEY;\nimport static android.provider.Telephony.Carriers.ENFORCE_MANAGED_URI;\nimport static android.provider.Telephony.Carriers.INVALID_APN_ID;\nimport static android.security.keystore.AttestationUtils.USE_INDIVIDUAL_ATTESTATION;\nimport static com.android.internal.logging.nano.MetricsProto.MetricsEvent.PROVISIONING_ENTRY_POINT_ADB;\nimport static com.android.internal.widget.LockPatternUtils.CREDENTIAL_TYPE_NONE;\nimport static com.android.internal.widget.LockPatternUtils.StrongAuthTracker.STRONG_AUTH_REQUIRED_AFTER_DPM_LOCK_NOW;\nimport static com.android.server.SystemTimeZone.TIME_ZONE_CONFIDENCE_HIGH;\nimport static com.android.server.am.ActivityManagerService.STOCK_PM_FLAGS;\nimport static com.android.server.devicepolicy.TransferOwnershipMetadataManager.ADMIN_TYPE_DEVICE_OWNER;\nimport static com.android.server.devicepolicy.TransferOwnershipMetadataManager.ADMIN_TYPE_PROFILE_OWNER;\nimport static com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME;\nimport static com.android.server.pm.UserManagerInternal.OWNER_TYPE_DEVICE_OWNER;\nimport static com.android.server.pm.UserManagerInternal.OWNER_TYPE_PROFILE_OWNER;\nimport static com.android.server.pm.UserManagerInternal.OWNER_TYPE_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE;\n\nimport android.Manifest;\nimport android.Manifest.permission;\nimport android.accessibilityservice.AccessibilityServiceInfo;\nimport android.accounts.Account;\nimport android.accounts.AccountManager;\nimport android.accounts.AuthenticatorException;\nimport android.accounts.OperationCanceledException;\nimport android.annotation.IntDef;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.UserIdInt;\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.ActivityTaskManager;\nimport android.app.AlarmManager;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.AppOpsManager.Mode;\nimport android.app.BroadcastOptions;\nimport android.app.IActivityManager;\nimport android.app.IActivityTaskManager;\nimport android.app.IApplicationThread;\nimport android.app.IServiceConnection;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.StatusBarManager;\nimport android.app.admin.AccountTypePolicyKey;\nimport android.app.admin.BooleanPolicyValue;\nimport android.app.admin.BundlePolicyValue;\nimport android.app.admin.ComponentNamePolicyValue;\nimport android.app.admin.DeviceAdminInfo;\nimport android.app.admin.DevicePolicyCache;\nimport android.app.admin.DevicePolicyDrawableResource;\nimport android.app.admin.DevicePolicyEventLogger;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.admin.DevicePolicyManager.DeviceOwnerType;\nimport android.app.admin.DevicePolicyManager.DevicePolicyOperation;\nimport android.app.admin.DevicePolicyManager.OperationSafetyReason;\nimport android.app.admin.DevicePolicyManager.PasswordComplexity;\nimport android.app.admin.DevicePolicyManager.PersonalAppsSuspensionReason;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.app.admin.DevicePolicyManagerLiteInternal;\nimport android.app.admin.DevicePolicySafetyChecker;\nimport android.app.admin.DevicePolicyState;\nimport android.app.admin.DevicePolicyStringResource;\nimport android.app.admin.DeviceStateCache;\nimport android.app.admin.FactoryResetProtectionPolicy;\nimport android.app.admin.FullyManagedDeviceProvisioningParams;\nimport android.app.admin.IDevicePolicyManager;\nimport android.app.admin.IntegerPolicyValue;\nimport android.app.admin.IntentFilterPolicyKey;\nimport android.app.admin.LockTaskPolicy;\nimport android.app.admin.LongPolicyValue;\nimport android.app.admin.ManagedProfileProvisioningParams;\nimport android.app.admin.ManagedSubscriptionsPolicy;\nimport android.app.admin.NetworkEvent;\nimport android.app.admin.PackagePolicy;\nimport android.app.admin.ParcelableGranteeMap;\nimport android.app.admin.ParcelableResource;\nimport android.app.admin.PasswordMetrics;\nimport android.app.admin.PasswordPolicy;\nimport android.app.admin.PolicyKey;\nimport android.app.admin.PolicyValue;\nimport android.app.admin.PreferentialNetworkServiceConfig;\nimport android.app.admin.SecurityLog;\nimport android.app.admin.SecurityLog.SecurityEvent;\nimport android.app.admin.StartInstallingUpdateCallback;\nimport android.app.admin.StringSetPolicyValue;\nimport android.app.admin.SystemUpdateInfo;\nimport android.app.admin.SystemUpdatePolicy;\nimport android.app.admin.UnsafeStateException;\nimport android.app.admin.UserRestrictionPolicyKey;\nimport android.app.admin.WifiSsidPolicy;\nimport android.app.backup.IBackupManager;\nimport android.app.compat.CompatChanges;\nimport android.app.role.OnRoleHoldersChangedListener;\nimport android.app.role.RoleManager;\nimport android.app.trust.TrustManager;\nimport android.app.usage.UsageStatsManagerInternal;\nimport android.compat.annotation.ChangeId;\nimport android.compat.annotation.EnabledAfter;\nimport android.compat.annotation.EnabledSince;\nimport android.content.ActivityNotFoundException;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.IIntentReceiver;\nimport android.content.IIntentSender;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.PermissionChecker;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.CrossProfileApps;\nimport android.content.pm.CrossProfileAppsInternal;\nimport android.content.pm.IPackageDataObserver;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageInstaller;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.PermissionInfo;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.ServiceInfo;\nimport android.content.pm.Signature;\nimport android.content.pm.StringParceledListSlice;\nimport android.content.pm.UserInfo;\nimport android.content.pm.UserPackage;\nimport android.content.pm.parsing.FrameworkParsingPackageUtils;\nimport android.content.res.Resources;\nimport android.database.ContentObserver;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.hardware.usb.UsbManager;\nimport android.location.Location;\nimport android.location.LocationManager;\nimport android.media.AudioManager;\nimport android.media.IAudioService;\nimport android.net.ConnectivityManager;\nimport android.net.ConnectivitySettingsManager;\nimport android.net.IIpConnectivityMetrics;\nimport android.net.ProfileNetworkPreference;\nimport android.net.ProxyInfo;\nimport android.net.Uri;\nimport android.net.VpnManager;\nimport android.net.metrics.IpConnectivityLog;\nimport android.net.wifi.WifiManager;\nimport android.os.AsyncTask;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.ParcelFileDescriptor;\nimport android.os.PersistableBundle;\nimport android.os.PowerManager;\nimport android.os.PowerManagerInternal;\nimport android.os.Process;\nimport android.os.RemoteCallback;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.ServiceManager;\nimport android.os.ServiceSpecificException;\nimport android.os.ShellCallback;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.UserManager.EnforcingUser;\nimport android.os.UserManager.UserRestrictionSource;\nimport android.os.storage.StorageManager;\nimport android.permission.AdminPermissionControlParams;\nimport android.permission.IPermissionManager;\nimport android.permission.PermissionControllerManager;\nimport android.provider.CalendarContract;\nimport android.provider.ContactsContract.QuickContact;\nimport android.provider.ContactsInternal;\nimport android.provider.DeviceConfig;\nimport android.provider.Settings;\nimport android.provider.Settings.Global;\nimport android.provider.Telephony;\nimport android.security.AppUriAuthenticationPolicy;\nimport android.security.IKeyChainAliasCallback;\nimport android.security.IKeyChainService;\nimport android.security.KeyChain;\nimport android.security.KeyChain.KeyChainConnection;\nimport android.security.KeyStore;\nimport android.security.keymaster.KeymasterCertificateChain;\nimport android.security.keystore.AttestationUtils;\nimport android.security.keystore.KeyGenParameterSpec;\nimport android.security.keystore.ParcelableKeyGenParameterSpec;\nimport android.stats.devicepolicy.DevicePolicyEnums;\nimport android.telecom.TelecomManager;\nimport android.telephony.SubscriptionManager;\nimport android.telephony.TelephonyManager;\nimport android.telephony.data.ApnSetting;\nimport android.text.TextUtils;\nimport android.text.format.DateUtils;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.DebugUtils;\nimport android.util.IndentingPrintWriter;\nimport android.util.IntArray;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.Xml;\nimport android.view.IWindowManager;\nimport android.view.accessibility.AccessibilityManager;\nimport android.view.accessibility.IAccessibilityManager;\nimport android.view.inputmethod.InputMethodInfo;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.app.LocalePicker;\nimport com.android.internal.infra.AndroidFuture;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.net.NetworkUtilsInternal;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.os.BackgroundThread;\nimport com.android.internal.statusbar.IStatusBarService;\nimport com.android.internal.telephony.SmsApplication;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.FunctionalUtils.ThrowingRunnable;\nimport com.android.internal.util.FunctionalUtils.ThrowingSupplier;\nimport com.android.internal.util.JournaledFile;\nimport com.android.internal.util.Preconditions;\nimport com.android.internal.util.StatLogger;\nimport com.android.internal.widget.LockPatternUtils;\nimport com.android.internal.widget.LockSettingsInternal;\nimport com.android.internal.widget.LockscreenCredential;\nimport com.android.internal.widget.PasswordValidationError;\nimport com.android.modules.utils.TypedXmlPullParser;\nimport com.android.modules.utils.TypedXmlSerializer;\nimport com.android.net.module.util.ProxyUtils;\nimport com.android.server.AlarmManagerInternal;\nimport com.android.server.LocalManagerRegistry;\nimport com.android.server.LocalServices;\nimport com.android.server.LockGuard;\nimport com.android.server.PersistentDataBlockManagerInternal;\nimport com.android.server.SystemServerInitThreadPool;\nimport com.android.server.SystemService;\nimport com.android.server.SystemServiceManager;\nimport com.android.server.devicepolicy.ActiveAdmin.TrustAgentInfo;\nimport com.android.server.inputmethod.InputMethodManagerInternal;\nimport com.android.server.net.NetworkPolicyManagerInternal;\nimport com.android.server.pm.DefaultCrossProfileIntentFilter;\nimport com.android.server.pm.DefaultCrossProfileIntentFiltersUtils;\nimport com.android.server.pm.PackageManagerLocal;\nimport com.android.server.pm.RestrictionsSet;\nimport com.android.server.pm.UserManagerInternal;\nimport com.android.server.pm.UserManagerInternal.UserRestrictionsListener;\nimport com.android.server.pm.UserRestrictionsUtils;\nimport com.android.server.pm.pkg.AndroidPackage;\nimport com.android.server.storage.DeviceStorageMonitorInternal;\nimport com.android.server.uri.NeededUriGrants;\nimport com.android.server.uri.UriGrantsManagerInternal;\nimport com.android.server.utils.Slogf",
        "metrics": {},
        "metrics_status": "Metrics not computed: 'downstream_file_content_ground_truth' is missing."
    }
]